// #anon_enum_CONNECTION_OK=0_CONNECTION_BAD=1_CONNECTION_STARTED=2_CONNECTION_MADE=3_CONNECTION_AWAITING_RESPONSE=4_CONNECTION_AUTH_OK=5_CONNECTION_SETENV=6_CONNECTION_SSL_STARTUP=7_CONNECTION_NEEDED=8
// file /usr/include/postgresql/libpq-fe.h line 47
enum anonymous_4 { CONNECTION_OK=0, CONNECTION_BAD=1, CONNECTION_STARTED=2, CONNECTION_MADE=3, CONNECTION_AWAITING_RESPONSE=4, CONNECTION_AUTH_OK=5, CONNECTION_SETENV=6, CONNECTION_SSL_STARTUP=7, CONNECTION_NEEDED=8 };

// #anon_enum_PGRES_EMPTY_QUERY=0_PGRES_COMMAND_OK=1_PGRES_TUPLES_OK=2_PGRES_COPY_OUT=3_PGRES_COPY_IN=4_PGRES_BAD_RESPONSE=5_PGRES_NONFATAL_ERROR=6_PGRES_FATAL_ERROR=7_PGRES_COPY_BOTH=8_PGRES_SINGLE_TUPLE=9
// file /usr/include/postgresql/libpq-fe.h line 78
enum anonymous { PGRES_EMPTY_QUERY=0, PGRES_COMMAND_OK=1, PGRES_TUPLES_OK=2, PGRES_COPY_OUT=3, PGRES_COPY_IN=4, PGRES_BAD_RESPONSE=5, PGRES_NONFATAL_ERROR=6, PGRES_FATAL_ERROR=7, PGRES_COPY_BOTH=8, PGRES_SINGLE_TUPLE=9 };

// tag-#anon#ST[*{S8}_S8_'name'||S32'value'||U32'_pad0'|]
// file src/utils.c line 23
struct anonymous_63;

// tag-#anon#ST[*{SYM#tag-cfile#}_SYM#tag-cfile#_'tqe_next'||*{*{SYM#tag-cfile#}_SYM#tag-cfile#_}_*{SYM#tag-cfile#}_SYM#tag-cfile#__'tqe_prev'|]
// file src/cli.c line 78
struct anonymous_66;

// tag-#anon#ST[*{SYM#tag-connection#}_SYM#tag-connection#_'tqe_next'||*{*{SYM#tag-connection#}_SYM#tag-connection#_}_*{SYM#tag-connection#}_SYM#tag-connection#__'tqe_prev'|]
// file includes/kore.h line 218
struct anonymous_39;

// tag-#anon#ST[*{SYM#tag-http_arg#}_SYM#tag-http_arg#_'tqe_next'||*{*{SYM#tag-http_arg#}_SYM#tag-http_arg#_}_*{SYM#tag-http_arg#}_SYM#tag-http_arg#__'tqe_prev'|]
// file includes/http.h line 65
struct anonymous_60;

// tag-#anon#ST[*{SYM#tag-http_arg#}_SYM#tag-http_arg#_'tqh_first'||*{*{SYM#tag-http_arg#}_SYM#tag-http_arg#_}_*{SYM#tag-http_arg#}_SYM#tag-http_arg#__'tqh_last'|]
// file includes/http.h line 198
struct anonymous_35;

// tag-#anon#ST[*{SYM#tag-http_file#}_SYM#tag-http_file#_'tqe_next'||*{*{SYM#tag-http_file#}_SYM#tag-http_file#_}_*{SYM#tag-http_file#}_SYM#tag-http_file#__'tqe_prev'|]
// file includes/http.h line 155
struct anonymous_61;

// tag-#anon#ST[*{SYM#tag-http_file#}_SYM#tag-http_file#_'tqh_first'||*{*{SYM#tag-http_file#}_SYM#tag-http_file#_}_*{SYM#tag-http_file#}_SYM#tag-http_file#__'tqh_last'|]
// file includes/http.h line 199
struct anonymous_36;

// tag-#anon#ST[*{SYM#tag-http_header#}_SYM#tag-http_header#_'tqe_next'||*{*{SYM#tag-http_header#}_SYM#tag-http_header#_}_*{SYM#tag-http_header#}_SYM#tag-http_header#__'tqe_prev'|]
// file includes/http.h line 54
struct anonymous_59;

// tag-#anon#ST[*{SYM#tag-http_header#}_SYM#tag-http_header#_'tqh_first'||*{*{SYM#tag-http_header#}_SYM#tag-http_header#_}_*{SYM#tag-http_header#}_SYM#tag-http_header#__'tqh_last'|]
// file includes/http.h line 196
struct anonymous_34;

// tag-#anon#ST[*{SYM#tag-http_request#}_SYM#tag-http_request#_'tqe_next'||*{*{SYM#tag-http_request#}_SYM#tag-http_request#_}_*{SYM#tag-http_request#}_SYM#tag-http_request#__'tqe_prev'|]
// file includes/http.h line 200
struct anonymous_37;

// tag-#anon#ST[*{SYM#tag-http_request#}_SYM#tag-http_request#_'tqh_first'||*{*{SYM#tag-http_request#}_SYM#tag-http_request#_}_*{SYM#tag-http_request#}_SYM#tag-http_request#__'tqh_last'|]
// file includes/kore.h line 216
struct anonymous_38;

// tag-#anon#ST[*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#_'tqe_next'||*{*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#_}_*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#__'tqe_prev'|]
// file includes/kore.h line 244
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#_'tqh_first'||*{*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#_}_*{SYM#tag-kore_auth#}_SYM#tag-kore_auth#__'tqh_last'|]
// file src/auth.c line 24
struct anonymous_64;

// tag-#anon#ST[*{SYM#tag-kore_domain#}_SYM#tag-kore_domain#_'tqe_next'||*{*{SYM#tag-kore_domain#}_SYM#tag-kore_domain#_}_*{SYM#tag-kore_domain#}_SYM#tag-kore_domain#__'tqe_prev'|]
// file includes/kore.h line 295
struct anonymous_12;

// tag-#anon#ST[*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#_'tqe_next'||*{*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#_}_*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#__'tqe_prev'|]
// file includes/kore.h line 230
struct anonymous_40;

// tag-#anon#ST[*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#_'tqh_first'||*{*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#_}_*{SYM#tag-kore_handler_params#}_SYM#tag-kore_handler_params#__'tqh_last'|]
// file includes/kore.h line 274
struct anonymous_14;

// tag-#anon#ST[*{SYM#tag-kore_module#}_SYM#tag-kore_module#_'tqe_next'||*{*{SYM#tag-kore_module#}_SYM#tag-kore_module#_}_*{SYM#tag-kore_module#}_SYM#tag-kore_module#__'tqe_prev'|]
// file includes/kore.h line 261
struct anonymous_56;

// tag-#anon#ST[*{SYM#tag-kore_module#}_SYM#tag-kore_module#_'tqh_first'||*{*{SYM#tag-kore_module#}_SYM#tag-kore_module#_}_*{SYM#tag-kore_module#}_SYM#tag-kore_module#__'tqh_last'|]
// file src/module.c line 23
struct anonymous_55;

// tag-#anon#ST[*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#_'tqe_next'||*{*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#_}_*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#__'tqe_prev'|]
// file includes/kore.h line 275
struct anonymous_15;

// tag-#anon#ST[*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#_'tqh_first'||*{*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#_}_*{SYM#tag-kore_module_handle#}_SYM#tag-kore_module_handle#__'tqh_last'|]
// file includes/kore.h line 294
struct anonymous_11;

// tag-#anon#ST[*{SYM#tag-kore_pgsql#}_SYM#tag-kore_pgsql#_'le_next'||*{*{SYM#tag-kore_pgsql#}_SYM#tag-kore_pgsql#_}_*{SYM#tag-kore_pgsql#}_SYM#tag-kore_pgsql#__'le_prev'|]
// file includes/pgsql.h line 44
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-kore_pgsql#}_SYM#tag-kore_pgsql#_'lh_first'|]
// file includes/http.h line 194
struct anonymous_33;

// tag-#anon#ST[*{SYM#tag-kore_pool_entry#}_SYM#tag-kore_pool_entry#_'le_next'||*{*{SYM#tag-kore_pool_entry#}_SYM#tag-kore_pool_entry#_}_*{SYM#tag-kore_pool_entry#}_SYM#tag-kore_pool_entry#__'le_prev'|]
// file includes/kore.h line 330
struct anonymous_46;

// tag-#anon#ST[*{SYM#tag-kore_pool_entry#}_SYM#tag-kore_pool_entry#_'lh_first'|]
// file includes/kore.h line 341
struct anonymous_44;

// tag-#anon#ST[*{SYM#tag-kore_pool_region#}_SYM#tag-kore_pool_region#_'le_next'||*{*{SYM#tag-kore_pool_region#}_SYM#tag-kore_pool_region#_}_*{SYM#tag-kore_pool_region#}_SYM#tag-kore_pool_region#__'le_prev'|]
// file includes/kore.h line 324
struct anonymous_45;

// tag-#anon#ST[*{SYM#tag-kore_pool_region#}_SYM#tag-kore_pool_region#_'lh_first'|]
// file includes/kore.h line 340
struct anonymous_43;

// tag-#anon#ST[*{SYM#tag-kore_task#}_SYM#tag-kore_task#_'le_next'||*{*{SYM#tag-kore_task#}_SYM#tag-kore_task#_}_*{SYM#tag-kore_task#}_SYM#tag-kore_task#__'le_prev'|]
// file includes/tasks.h line 46
struct anonymous_51;

// tag-#anon#ST[*{SYM#tag-kore_task#}_SYM#tag-kore_task#_'lh_first'|]
// file includes/http.h line 193
struct anonymous_32;

// tag-#anon#ST[*{SYM#tag-kore_task#}_SYM#tag-kore_task#_'tqe_next'||*{*{SYM#tag-kore_task#}_SYM#tag-kore_task#_}_*{SYM#tag-kore_task#}_SYM#tag-kore_task#__'tqe_prev'|]
// file includes/tasks.h line 45
struct anonymous_50;

// tag-#anon#ST[*{SYM#tag-kore_task#}_SYM#tag-kore_task#_'tqh_first'||*{*{SYM#tag-kore_task#}_SYM#tag-kore_task#_}_*{SYM#tag-kore_task#}_SYM#tag-kore_task#__'tqh_last'|]
// file includes/tasks.h line 54
struct anonymous_48;

// tag-#anon#ST[*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#_'tqe_next'||*{*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#_}_*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#__'tqe_prev'|]
// file includes/tasks.h line 56
struct anonymous_49;

// tag-#anon#ST[*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#_'tqh_first'||*{*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#_}_*{SYM#tag-kore_task_thread#}_SYM#tag-kore_task_thread#__'tqh_last'|]
// file src/tasks.c line 32
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-kore_timer#}_SYM#tag-kore_timer#_'tqe_next'||*{*{SYM#tag-kore_timer#}_SYM#tag-kore_timer#_}_*{SYM#tag-kore_timer#}_SYM#tag-kore_timer#__'tqe_prev'|]
// file includes/kore.h line 358
struct anonymous_58;

// tag-#anon#ST[*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#_'tqe_next'||*{*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#_}_*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#__'tqe_prev'|]
// file includes/kore.h line 310
struct anonymous_42;

// tag-#anon#ST[*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#_'tqh_first'||*{*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#_}_*{SYM#tag-kore_validator#}_SYM#tag-kore_validator#__'tqh_last'|]
// file src/validator.c line 19
struct anonymous_62;

// tag-#anon#ST[*{SYM#tag-listener#}_SYM#tag-listener#_'le_next'||*{*{SYM#tag-listener#}_SYM#tag-listener#_}_*{SYM#tag-listener#}_SYM#tag-listener#__'le_prev'|]
// file includes/kore.h line 136
struct anonymous_29;

// tag-#anon#ST[*{SYM#tag-netbuf#}_SYM#tag-netbuf#_'tqe_next'||*{*{SYM#tag-netbuf#}_SYM#tag-netbuf#_}_*{SYM#tag-netbuf#}_SYM#tag-netbuf#__'tqe_prev'|]
// file includes/kore.h line 115
struct anonymous_27;

// tag-#anon#ST[*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#_'tqe_next'||*{*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#_}_*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#__'tqe_prev'|]
// file includes/pgsql.h line 35
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#_'tqh_first'||*{*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#_}_*{SYM#tag-pgsql_conn#}_SYM#tag-pgsql_conn#__'tqh_last'|]
// file src/pgsql.c line 58
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-pgsql_job#}_SYM#tag-pgsql_job#_'tqe_next'||*{*{SYM#tag-pgsql_job#}_SYM#tag-pgsql_job#_}_*{SYM#tag-pgsql_job#}_SYM#tag-pgsql_job#__'tqe_prev'|]
// file src/pgsql.c line 32
struct anonymous_0;

// tag-#anon#ST[*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#_'tqe_next'||*{*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#_}_*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#__'tqe_prev'|]
// file src/pgsql.c line 37
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#_'tqh_first'||*{*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#_}_*{SYM#tag-pgsql_wait#}_SYM#tag-pgsql_wait#__'tqh_last'|]
// file src/pgsql.c line 59
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#_'tqe_next'||*{*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#_}_*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#__'tqe_prev'|]
// file includes/spdy.h line 72
struct anonymous_24;

// tag-#anon#ST[*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#_'tqh_first'||*{*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#_}_*{SYM#tag-spdy_stream#}_SYM#tag-spdy_stream#__'tqh_last'|]
// file includes/kore.h line 215
struct anonymous_31;

// tag-#anon#ST[*{cS8}_cS8_'name'||*{S32(*{*{S8}_S8_}_*{S8}_S8__)->S32}_S32(*{*{S8}_S8_}_*{S8}_S8__)->S32_'configure'|]
// file src/config.c line 78
struct anonymous_23;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_54;

// tag-#anon#ST[ARR16{U64}_U64_'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous_18;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_52;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_47;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_57;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_16;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous_53;

// tag-#anon#ST[U64'length'||U64'start'|]
// file includes/kore.h line 196
struct anonymous_30;

// tag-#anon#UN[*{S32}_S32_'inherit'||*{SYM#tag-stack_st_ASIdOrRange#}_SYM#tag-stack_st_ASIdOrRange#_'asIdsOrRanges'|]
// file /usr/include/openssl/x509v3.h line 783
union anonymous_65;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_21;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_20;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_41;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_26;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_9;

// tag-#anon#UN[ARR8{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_10;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_8;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_5;

// tag-#anon#UN[SYM#tag-sockaddr_in#'ipv4'||SYM#tag-sockaddr_in6#'ipv6'|]
// file includes/kore.h line 131
union anonymous_28;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_19;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_17;

// tag-ASIdentifierChoice_st
// file /usr/include/openssl/x509v3.h line 781
struct ASIdentifierChoice_st;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-SHAstate_st
// file /usr/include/openssl/sha.h line 100
struct SHAstate_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-cfile
// file src/cli.c line 71
struct cfile;

// tag-cfile_list
// file src/cli.c line 81
struct cfile_list;

// tag-cmd
// file src/cli.c line 61
struct cmd;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-connection
// file includes/spdy.h line 28
struct connection;

// tag-connection_list
// file includes/kore.h line 222
struct connection_list;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-filegen
// file src/cli.c line 67
struct filegen;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-http_arg
// file includes/http.h line 57
struct http_arg;

// tag-http_file
// file includes/http.h line 148
struct http_file;

// tag-http_header
// file includes/http.h line 50
struct http_header;

// tag-http_request
// file includes/spdy.h line 29
struct http_request;

// tag-http_state
// file includes/http.h line 204
struct http_state;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-kore_auth
// file includes/kore.h line 237
struct kore_auth;

// tag-kore_buf
// file includes/kore.h line 316
struct kore_buf;

// tag-kore_domain
// file includes/kore.h line 271
struct kore_domain;

// tag-kore_domain_h
// file includes/kore.h line 298
struct kore_domain_h;

// tag-kore_handler_params
// file includes/kore.h line 225
struct kore_handler_params;

// tag-kore_log_packet
// file src/accesslog.c line 26
struct kore_log_packet;

// tag-kore_module
// file includes/kore.h line 253
struct kore_module;

// tag-kore_module_handle
// file includes/kore.h line 264
struct kore_module_handle;

// tag-kore_pgsql
// file includes/http.h line 194
struct kore_pgsql;

// tag-kore_pool
// file includes/kore.h line 333
struct kore_pool;

// tag-kore_pool_entry
// file includes/kore.h line 327
struct kore_pool_entry;

// tag-kore_pool_region
// file includes/kore.h line 322
struct kore_pool_region;

// tag-kore_task
// file includes/http.h line 172
struct kore_task;

// tag-kore_task_thread
// file includes/tasks.h line 43
struct kore_task_thread;

// tag-kore_timer
// file includes/kore.h line 351
struct kore_timer;

// tag-kore_validator
// file includes/kore.h line 228
struct kore_validator;

// tag-kore_worker
// file includes/kore.h line 278
struct kore_worker;

// tag-kore_wscbs
// file includes/kore.h line 344
struct kore_wscbs;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-listener
// file includes/kore.h line 125
struct listener;

// tag-listener_head
// file includes/kore.h line 139
struct listener_head;

// tag-meminfo
// file src/mem.c line 30
struct meminfo;

// tag-netbuf
// file includes/kore.h line 101
struct netbuf;

// tag-netbuf_head
// file includes/kore.h line 118
struct netbuf_head;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pg_conn
// file /usr/include/postgresql/libpq-fe.h line 129
struct pg_conn;

// tag-pg_result
// file /usr/include/postgresql/libpq-fe.h line 136
struct pg_result;

// tag-pgsql_conn
// file includes/pgsql.h line 29
struct pgsql_conn;

// tag-pgsql_job
// file includes/pgsql.h line 34
struct pgsql_job;

// tag-pgsql_wait
// file src/pgsql.c line 35
struct pgsql_wait;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-spdy_ctrl_frame
// file includes/spdy.h line 31
struct spdy_ctrl_frame;

// tag-spdy_data_frame
// file includes/spdy.h line 38
struct spdy_data_frame;

// tag-spdy_header_block
// file includes/spdy.h line 52
struct spdy_header_block;

// tag-spdy_stream
// file includes/spdy.h line 59
struct spdy_stream;

// tag-spdy_syn_stream
// file includes/spdy.h line 44
struct spdy_syn_stream;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASIdOrRange
// file /usr/include/openssl/x509v3.h line 775
struct stack_st_ASIdOrRange;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_GENERAL_SUBTREE
// file /usr/include/openssl/x509v3.h line 330
struct stack_st_GENERAL_SUBTREE;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timerlist
// file src/timer.c line 22
struct timerlist;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-websocket_data
// file src/websocket.c line 38
struct websocket_data;

// tag-wlock
// file src/worker.c line 52
struct wlock;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// BIO_free
// file /usr/include/openssl/bio.h line 657
signed int BIO_free(struct bio_st *);
// BIO_new_file
// file /usr/include/openssl/bio.h line 651
struct bio_st * BIO_new_file(const char *, const char *);
// BN_free
// file /usr/include/openssl/bn.h line 492
void BN_free(struct bignum_st *);
// BN_new
// file /usr/include/openssl/bn.h line 436
struct bignum_st * BN_new(void);
// BN_set_word
// file /usr/include/openssl/bn.h line 488
signed int BN_set_word(struct bignum_st *, unsigned long int);
// EC_KEY_free
// file /usr/include/openssl/ec.h line 772
void EC_KEY_free(struct ec_key_st *);
// EC_KEY_new_by_curve_name
// file /usr/include/openssl/ec.h line 767
struct ec_key_st * EC_KEY_new_by_curve_name(signed int);
// ERR_clear_error
// file /usr/include/openssl/err.h line 333
void ERR_clear_error(void);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// EVP_PKEY_assign
// file /usr/include/openssl/evp.h line 956
signed int EVP_PKEY_assign(struct evp_pkey_st *, signed int, void *);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_sha256
// file /usr/include/openssl/evp.h line 727
const struct env_md_st * EVP_sha256(void);
// PEM_read_bio_DHparams
// file /usr/include/openssl/pem.h line 477
struct dh_st * PEM_read_bio_DHparams(struct bio_st *, struct dh_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_PrivateKey
// file /usr/include/openssl/pem.h line 480
signed int PEM_write_PrivateKey(struct _IO_FILE *, struct evp_pkey_st *, const struct evp_cipher_st *, unsigned char *, signed int, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_X509(struct _IO_FILE *, struct x509_st *);
// PQclear
// file /usr/include/postgresql/libpq-fe.h line 484
extern void PQclear(struct pg_result *);
// PQconnectdb
// file /usr/include/postgresql/libpq-fe.h line 250
extern struct pg_conn * PQconnectdb(const char *);
// PQconsumeInput
// file /usr/include/postgresql/libpq-fe.h line 411
extern signed int PQconsumeInput(struct pg_conn *);
// PQerrorMessage
// file /usr/include/postgresql/libpq-fe.h line 313
extern char * PQerrorMessage(const struct pg_conn *);
// PQfinish
// file /usr/include/postgresql/libpq-fe.h line 262
extern void PQfinish(struct pg_conn *);
// PQgetResult
// file /usr/include/postgresql/libpq-fe.h line 407
extern struct pg_result * PQgetResult(struct pg_conn *);
// PQgetlength
// file /usr/include/postgresql/libpq-fe.h line 472
extern signed int PQgetlength(const struct pg_result *, signed int, signed int);
// PQgetvalue
// file /usr/include/postgresql/libpq-fe.h line 471
extern char * PQgetvalue(const struct pg_result *, signed int, signed int);
// PQisBusy
// file /usr/include/postgresql/libpq-fe.h line 410
extern signed int PQisBusy(struct pg_conn *);
// PQntuples
// file /usr/include/postgresql/libpq-fe.h line 456
extern signed int PQntuples(const struct pg_result *);
// PQresultErrorMessage
// file /usr/include/postgresql/libpq-fe.h line 454
extern char * PQresultErrorMessage(const struct pg_result *);
// PQresultStatus
// file /usr/include/postgresql/libpq-fe.h line 452
extern enum anonymous PQresultStatus(const struct pg_result *);
// PQsendQuery
// file /usr/include/postgresql/libpq-fe.h line 387
extern signed int PQsendQuery(struct pg_conn *, const char *);
// PQsendQueryParams
// file /usr/include/postgresql/libpq-fe.h line 388
extern signed int PQsendQueryParams(struct pg_conn *, const char *, signed int, const unsigned int *, const char * const *, const signed int *, const signed int *, signed int);
// PQsocket
// file /usr/include/postgresql/libpq-fe.h line 314
extern signed int PQsocket(const struct pg_conn *);
// PQstatus
// file /usr/include/postgresql/libpq-fe.h line 307
extern enum anonymous_4 PQstatus(const struct pg_conn *);
// RSA_generate_key_ex
// file /usr/include/openssl/rsa.h line 331
signed int RSA_generate_key_ex(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
// RSA_new
// file /usr/include/openssl/rsa.h line 320
struct rsa_st * RSA_new(void);
// SHA1_Final
// file /usr/include/openssl/sha.h line 123
signed int SHA1_Final(unsigned char *, struct SHAstate_st *);
// SHA1_Init
// file /usr/include/openssl/sha.h line 121
signed int SHA1_Init(struct SHAstate_st *);
// SHA1_Update
// file /usr/include/openssl/sha.h line 122
signed int SHA1_Update(struct SHAstate_st *, const void *, unsigned long int);
// SSL_CTX_callback_ctrl
// file /usr/include/openssl/ssl.h line 2340
signed long int SSL_CTX_callback_ctrl(struct ssl_ctx_st *, signed int, void (*)(void));
// SSL_CTX_check_private_key
// file /usr/include/openssl/ssl.h line 2285
signed int SSL_CTX_check_private_key(const struct ssl_ctx_st *);
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_get_cert_store
// file /usr/include/openssl/ssl.h line 2135
struct x509_store_st * SSL_CTX_get_cert_store(const struct ssl_ctx_st *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_client_CA_list
// file /usr/include/openssl/ssl.h line 2408
void SSL_CTX_set_client_CA_list(struct ssl_ctx_st *, struct stack_st_X509_NAME *);
// SSL_CTX_set_info_callback
// file /usr/include/openssl/ssl.h line 1246
void SSL_CTX_set_info_callback(struct ssl_ctx_st *, void (*)(const struct ssl_st *, signed int, signed int));
// SSL_CTX_set_next_protos_advertised_cb
// file /usr/include/openssl/ssl.h line 1272
void SSL_CTX_set_next_protos_advertised_cb(struct ssl_ctx_st *, signed int (*)(struct ssl_st *, const unsigned char **, unsigned int *, void *), void *);
// SSL_CTX_set_session_id_context
// file /usr/include/openssl/ssl.h line 2288
signed int SSL_CTX_set_session_id_context(struct ssl_ctx_st *, const unsigned char *, unsigned int);
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_set_verify_depth
// file /usr/include/openssl/ssl.h line 2264
void SSL_CTX_set_verify_depth(struct ssl_ctx_st *, signed int);
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_chain_file
// file /usr/include/openssl/ssl.h line 2202
signed int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st *, const char *);
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get0_next_proto_negotiated
// file /usr/include/openssl/ssl.h line 1285
void SSL_get0_next_proto_negotiated(const struct ssl_st *, const unsigned char **, unsigned int *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_get_ex_data
// file /usr/include/openssl/ssl.h line 2460
void * SSL_get_ex_data(const struct ssl_st *, signed int);
// SSL_get_peer_certificate
// file /usr/include/openssl/ssl.h line 2253
struct x509_st * SSL_get_peer_certificate(const struct ssl_st *);
// SSL_get_servername
// file /usr/include/openssl/tls1.h line 309
const char * SSL_get_servername(const struct ssl_st *, const signed int);
// SSL_get_verify_mode
// file /usr/include/openssl/ssl.h line 2167
signed int SSL_get_verify_mode(const struct ssl_st *);
// SSL_get_verify_result
// file /usr/include/openssl/ssl.h line 2457
signed long int SSL_get_verify_result(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_client_CA_file
// file /usr/include/openssl/ssl.h line 2203
struct stack_st_X509_NAME * SSL_load_client_CA_file(const char *);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_set_SSL_CTX
// file /usr/include/openssl/ssl.h line 2448
struct ssl_ctx_st * SSL_set_SSL_CTX(struct ssl_st *, struct ssl_ctx_st *);
// SSL_set_accept_state
// file /usr/include/openssl/ssl.h line 2415
void SSL_set_accept_state(struct ssl_st *);
// SSL_set_ex_data
// file /usr/include/openssl/ssl.h line 2459
signed int SSL_set_ex_data(struct ssl_st *, signed int, void *);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_set_verify
// file /usr/include/openssl/ssl.h line 2170
void SSL_set_verify(struct ssl_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSLv23_server_method
// file /usr/include/openssl/ssl.h line 2362
const struct ssl_method_st * SSLv23_server_method(void);
// TLSv1_2_server_method
// file /usr/include/openssl/ssl.h line 2376
const struct ssl_method_st * TLSv1_2_server_method(void);
// TLSv1_server_method
// file /usr/include/openssl/ssl.h line 2368
const struct ssl_method_st * TLSv1_server_method(void);
// X509_NAME_add_entry_by_txt
// file /usr/include/openssl/x509.h line 1039
signed int X509_NAME_add_entry_by_txt(struct X509_name_st *, const char *, signed int, const unsigned char *, signed int, signed int, signed int);
// X509_NAME_get_text_by_NID
// file /usr/include/openssl/x509.h line 1011
signed int X509_NAME_get_text_by_NID(struct X509_name_st *, signed int, char *, signed int);
// X509_STORE_CTX_get_current_cert
// file /usr/include/openssl/x509_vfy.h line 541
struct x509_st * X509_STORE_CTX_get_current_cert(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_error
// file /usr/include/openssl/x509_vfy.h line 538
signed int X509_STORE_CTX_get_error(struct x509_store_ctx_st *);
// X509_STORE_CTX_get_error_depth
// file /usr/include/openssl/x509_vfy.h line 540
signed int X509_STORE_CTX_get_error_depth(struct x509_store_ctx_st *);
// X509_STORE_load_locations
// file /usr/include/openssl/x509_vfy.h line 527
signed int X509_STORE_load_locations(struct x509_store_st *, const char *, const char *);
// X509_STORE_set_flags
// file /usr/include/openssl/x509_vfy.h line 467
signed int X509_STORE_set_flags(struct x509_store_st *, unsigned long int);
// X509_STORE_set_verify_cb
// file /usr/include/openssl/x509_vfy.h line 472
void X509_STORE_set_verify_cb(struct x509_store_st *, signed int (*)(signed int, struct x509_store_ctx_st *));
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_get_subject_name
// file /usr/include/openssl/x509.h line 907
struct X509_name_st * X509_get_subject_name(struct x509_st *);
// X509_gmtime_adj
// file /usr/include/openssl/x509.h line 769
struct asn1_string_st * X509_gmtime_adj(struct asn1_string_st *, signed long int);
// X509_new
// file /usr/include/openssl/x509.h line 823
struct x509_st * X509_new(void);
// X509_set_issuer_name
// file /usr/include/openssl/x509.h line 904
signed int X509_set_issuer_name(struct x509_st *, struct X509_name_st *);
// X509_set_pubkey
// file /usr/include/openssl/x509.h line 910
signed int X509_set_pubkey(struct x509_st *, struct evp_pkey_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// X509_verify_cert_error_string
// file /usr/include/openssl/x509.h line 628
const char * X509_verify_cert_error_string(signed long int);
// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __sync_bool_compare_and_swap
// file gcc_builtin_headers_generic.h line 105
_Bool __sync_bool_compare_and_swap();
// __xpg_basename
// file /usr/include/libgen.h line 34
extern char * __xpg_basename(char *);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// cli_add_cfile
// file src/cli.c line 676
static void cli_add_cfile(char *name, char *fpath, char *opath, struct stat *st, signed int build, signed int cpp);
// cli_build
// file src/cli.c line 286
static void cli_build(signed int argc, char **argv);
// cli_build_asset
// file src/cli.c line 578
static void cli_build_asset(char *fpath, struct dirent *dp);
// cli_clean
// file src/cli.c line 383
static void cli_clean(signed int argc, char **argv);
// cli_cleanup_files
// file src/cli.c line 1043
static void cli_cleanup_files(const char *spath);
// cli_compile_cfile
// file src/cli.c line 869
static void cli_compile_cfile(void *arg);
// cli_create
// file src/cli.c line 255
static void cli_create(signed int argc, char **argv);
// cli_dir_exists
// file src/cli.c line 487
static signed int cli_dir_exists(const char *fpath);
// cli_fatal
// file src/cli.c line 1052
static void cli_fatal(const char *fmt, ...);
// cli_file_close
// file src/cli.c line 508
static void cli_file_close(signed int fd);
// cli_file_create
// file src/cli.c line 554
static void cli_file_create(const char *name, const char *data, unsigned long int len);
// cli_file_exists
// file src/cli.c line 459
static signed int cli_file_exists(const char *fpath);
// cli_file_open
// file src/cli.c line 501
static void cli_file_open(const char *fpath, signed int flags, signed int *fd);
// cli_file_remove
// file src/cli.c line 723
static void cli_file_remove(char *fpath, struct dirent *dp);
// cli_file_requires_build
// file src/cli.c line 473
static signed int cli_file_requires_build(struct stat *fst, const char *opath);
// cli_file_write
// file src/cli.c line 533
static void cli_file_write(signed int fd, const void *buf, unsigned long int len);
// cli_file_writef
// file src/cli.c line 515
static void cli_file_writef(signed int fd, const char *fmt, ...);
// cli_find_files
// file src/cli.c line 730
static void cli_find_files(const char *path, void (*cb)(char *, struct dirent *));

//

// cli_generate_certs
// file src/cli.c line 767
static void cli_generate_certs(void);
// cli_help
// file src/cli.c line 249
static void cli_help(signed int argc, char **argv);
// cli_link_library
// file src/cli.c line 933
static void cli_link_library(void *arg);
// cli_mkdir
// file src/cli.c line 452
static void cli_mkdir(const char *fpath, signed int mode);
// cli_register_cfile
// file src/cli.c line 695
static void cli_register_cfile(char *fpath, struct dirent *dp);
// cli_run
// file src/cli.c line 402
static void cli_run(signed int argc, char **argv);
// cli_run_kore
// file src/cli.c line 986
static void cli_run_kore(void *arg);
// cli_spawn_proc
// file src/cli.c line 1001
static void cli_spawn_proc(void (*cb)(void *), void *arg);

//

// cli_vasprintf
// file src/cli.c line 1027
static signed int cli_vasprintf(char **out, const char *fmt, ...);
// cli_write_asset
// file src/cli.c line 570
static void cli_write_asset(const char *n, const char *e);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// configure_accept_threshold
// file src/config.c line 600
static signed int configure_accept_threshold(char **argv);
// configure_accesslog
// file src/config.c line 498
static signed int configure_accesslog(char **argv);
// configure_authentication
// file src/config.c line 842
static signed int configure_authentication(char **argv);
// configure_authentication_type
// file src/config.c line 868
static signed int configure_authentication_type(char **argv);
// configure_authentication_uri
// file src/config.c line 947
static signed int configure_authentication_uri(char **argv);
// configure_authentication_validator
// file src/config.c line 917
static signed int configure_authentication_validator(char **argv);
// configure_authentication_value
// file src/config.c line 895
static signed int configure_authentication_value(char **argv);
// configure_bind
// file src/config.c line 249
static signed int configure_bind(char **argv);
// configure_certfile
// file src/config.c line 526
static signed int configure_certfile(char **argv);
// configure_certkey
// file src/config.c line 546
static signed int configure_certkey(char **argv);
// configure_chroot
// file src/config.c line 431
static signed int configure_chroot(char **argv);
// configure_client_certificates
// file src/config.c line 405
static signed int configure_client_certificates(char **argv);
// configure_domain
// file src/config.c line 351
static signed int configure_domain(char **argv);
// configure_handler
// file src/config.c line 376
static signed int configure_handler(char **argv);
// configure_http_body_max
// file src/config.c line 656
static signed int configure_http_body_max(char **argv);
// configure_http_header_max
// file src/config.c line 634
static signed int configure_http_header_max(char **argv);
// configure_http_hsts_enable
// file src/config.c line 678
static signed int configure_http_hsts_enable(char **argv);
// configure_http_keepalive_time
// file src/config.c line 700
static signed int configure_http_keepalive_time(char **argv);
// configure_http_request_limit
// file src/config.c line 722
static signed int configure_http_request_limit(char **argv);
// configure_include
// file src/config.c line 237
static signed int configure_include(char **argv);
// configure_load
// file src/config.c line 258
static signed int configure_load(char **argv);
// configure_max_connections
// file src/config.c line 566
static signed int configure_max_connections(char **argv);
// configure_params
// file src/config.c line 764
static signed int configure_params(char **argv);
// configure_pgsql_conn_max
// file src/config.c line 1036
static signed int configure_pgsql_conn_max(char **argv);
// configure_pidfile
// file src/config.c line 483
static signed int configure_pidfile(char **argv);
// configure_rlimit_nofiles
// file src/config.c line 583
static signed int configure_rlimit_nofiles(char **argv);
// configure_runas
// file src/config.c line 446
static signed int configure_runas(char **argv);
// configure_set_affinity
// file src/config.c line 617
static signed int configure_set_affinity(char **argv);
// configure_socket_backlog
// file src/config.c line 1010
static signed int configure_socket_backlog(char **argv);
// configure_spdy_idle_time
// file src/config.c line 333
static signed int configure_spdy_idle_time(char **argv);
// configure_tls_cipher
// file src/config.c line 288
static signed int configure_tls_cipher(char **argv);
// configure_tls_dhparam
// file src/config.c line 303
static signed int configure_tls_dhparam(char **argv);
// configure_tls_version
// file src/config.c line 268
static signed int configure_tls_version(char **argv);
// configure_validate
// file src/config.c line 813
static signed int configure_validate(char **argv);
// configure_validator
// file src/config.c line 739
static signed int configure_validator(char **argv);
// configure_websocket_maxframe
// file src/config.c line 970
static signed int configure_websocket_maxframe(char **argv);
// configure_websocket_timeout
// file src/config.c line 989
static signed int configure_websocket_timeout(char **argv);
// configure_workers
// file src/config.c line 461
static signed int configure_workers(char **argv);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit_
// file /usr/include/zlib.h line 1633
extern signed int deflateInit_(struct z_stream_s *, signed int, const char *, signed int);
// deflateSetDictionary
// file /usr/include/zlib.h line 587
extern signed int deflateSetDictionary(struct z_stream_s *, const unsigned char *, unsigned int);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// domain_load_crl
// file src/domain.c line 213
static void domain_load_crl(struct kore_domain *dom);
// domain_sslstart
// file src/config.c line 1027
static void domain_sslstart(void);
// domain_x509_verify
// file src/domain.c line 246
static signed int domain_x509_verify(signed int ok, struct x509_store_ctx_st *ctx);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fatal
// file includes/kore.h line 521
void fatal(const char *fmt, ...);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_create_config
// file src/cli.c line 427
static void file_create_config(void);
// file_create_gitignore
// file src/cli.c line 441
static void file_create_gitignore(void);
// file_create_src
// file src/cli.c line 417
static void file_create_src(void);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 54
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// http_argument_add
// file src/http.c line 1079
static void http_argument_add(struct http_request *req, const char *name, void *value, unsigned int len, signed int type);
// http_argument_get
// file src/http.c line 723
signed int http_argument_get(struct http_request *req, const char *name, void **out, void *nout, unsigned int *len, signed int type);
// http_argument_urldecode
// file src/http.c line 777
signed int http_argument_urldecode(char *arg);
// http_body_bytes
// file src/http.c line 1026
unsigned char * http_body_bytes(struct http_request *req, unsigned int *len);
// http_body_recv
// file src/http.c line 1131
static signed int http_body_recv(struct netbuf *nb);
// http_body_text
// file src/http.c line 1005
char * http_body_text(struct http_request *req);
// http_error_response
// file src/http.c line 1147
static void http_error_response(struct connection *c, struct spdy_stream *s, signed int status);
// http_file_add
// file src/http.c line 1116
static void http_file_add(struct http_request *req, const char *name, const char *filename, unsigned char *data, unsigned int len);
// http_file_lookup
// file src/http.c line 825
signed int http_file_lookup(struct http_request *req, const char *name, char **fname, unsigned char **data, unsigned int *len);
// http_generic_404
// file src/http.c line 994
signed int http_generic_404(struct http_request *req);
// http_header_recv
// file includes/http.h line 240
signed int http_header_recv(struct netbuf *nb);
// http_init
// file src/http.c line 66
void http_init(void);
// http_populate_arguments
// file src/http.c line 685
signed int http_populate_arguments(struct http_request *req);
// http_populate_multipart_form
// file src/http.c line 843
signed int http_populate_multipart_form(struct http_request *req, signed int *v);
// http_process
// file src/http.c line 233
void http_process(void);
// http_process_request
// file src/http.c line 262
void http_process_request(struct http_request *req, signed int retry_only);

//

// http_request_free
// file src/http.c line 350
void http_request_free(struct http_request *req);
// http_request_header
// file includes/http.h line 229
signed int http_request_header(struct http_request *req, const char *header, char **out);
// http_request_new
// file src/http.c line 102
signed int http_request_new(struct connection *c, struct spdy_stream *s, const char *host, const char *method, const char *path, const char *version, struct http_request **out);
// http_request_sleep
// file src/http.c line 209
void http_request_sleep(struct http_request *req);
// http_request_wakeup
// file includes/http.h line 222
void http_request_wakeup(struct http_request *req);
// http_response
// file includes/http.h line 226
void http_response(struct http_request *req, signed int status, void *d, unsigned int l);
// http_response_header
// file includes/http.h line 231
void http_response_header(struct http_request *req, const char *header, const char *value);
// http_response_normal
// file src/http.c line 1222
static void http_response_normal(struct http_request *req, struct connection *c, signed int status, void *d, unsigned int len);
// http_response_spdy
// file src/http.c line 1167
static void http_response_spdy(struct http_request *req, struct connection *c, struct spdy_stream *s, signed int status, void *d, unsigned int len);
// http_response_stream
// file src/http.c line 478
void http_response_stream(struct http_request *req, signed int status, void *base, unsigned long int len, signed int (*cb)(struct netbuf *), void *arg);

//

// http_state_run
// file src/http.c line 1040
signed int http_state_run(struct http_state *states, unsigned char elm, struct http_request *req);
// http_status_text
// file src/http.c line 1295
const char * http_status_text(signed int status);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit_
// file /usr/include/zlib.h line 1635
extern signed int inflateInit_(struct z_stream_s *, const char *, signed int);
// inflateSetDictionary
// file /usr/include/zlib.h line 819
extern signed int inflateSetDictionary(struct z_stream_s *, const unsigned char *, unsigned int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kore_accesslog
// file src/accesslog.c line 154
void kore_accesslog(struct http_request *req);
// kore_accesslog_init
// file includes/kore.h line 421
void kore_accesslog_init(void);
// kore_accesslog_wait
// file includes/kore.h line 422
signed int kore_accesslog_wait(void);
// kore_accesslog_worker_init
// file src/accesslog.c line 48
void kore_accesslog_worker_init(void);
// kore_auth_cookie
// file src/auth.c line 106
static signed int kore_auth_cookie(struct http_request *req, struct kore_auth *auth);
// kore_auth_header
// file src/auth.c line 144
static signed int kore_auth_header(struct http_request *req, struct kore_auth *auth);
// kore_auth_init
// file includes/kore.h line 426
void kore_auth_init(void);
// kore_auth_lookup
// file src/auth.c line 165
struct kore_auth * kore_auth_lookup(const char *name);
// kore_auth_new
// file src/auth.c line 37
signed int kore_auth_new(const char *name);
// kore_auth_request
// file src/auth.c line 159
static signed int kore_auth_request(struct http_request *req, struct kore_auth *auth);
// kore_auth_run
// file src/auth.c line 57
signed int kore_auth_run(struct http_request *req, struct kore_auth *auth);
// kore_base64_decode
// file src/utils.c line 412
signed int kore_base64_decode(char *in, unsigned char **out, unsigned int *olen);
// kore_base64_encode
// file src/utils.c line 351
signed int kore_base64_encode(unsigned char *data, unsigned int len, char **out);
// kore_buf_append
// file src/buf.c line 33
void kore_buf_append(struct kore_buf *buf, void *d, unsigned int len);
// kore_buf_appendb
// file src/buf.c line 45
void kore_buf_appendb(struct kore_buf *buf, struct kore_buf *src);
// kore_buf_appendf
// file src/buf.c line 79
void kore_buf_appendf(struct kore_buf *buf, const char *fmt, ...);
// kore_buf_appendv
// file src/buf.c line 56
void kore_buf_appendv(struct kore_buf *buf, const char *fmt, void **args);
// kore_buf_create
// file src/buf.c line 20
struct kore_buf * kore_buf_create(unsigned int initial);
// kore_buf_free
// file src/buf.c line 101
void kore_buf_free(struct kore_buf *buf);
// kore_buf_release
// file src/buf.c line 89
unsigned char * kore_buf_release(struct kore_buf *buf, unsigned int *len);
// kore_buf_replace_string
// file src/buf.c line 108
void kore_buf_replace_string(struct kore_buf *b, char *src, void *dst, unsigned long int len);
// kore_calloc
// file src/mem.c line 94
void * kore_calloc(unsigned long int memb, unsigned long int len);
// kore_cli_main
// file includes/kore.h line 394
signed int kore_cli_main(signed int argc, char **argv);
// kore_cli_usage
// file includes/kore.h line 393
void kore_cli_usage(signed int local);
// kore_connection_accept
// file src/connection.c line 72
signed int kore_connection_accept(struct listener *l, struct connection **out);
// kore_connection_check_idletimer
// file src/connection.c line 334
void kore_connection_check_idletimer(unsigned long int now, struct connection *c);
// kore_connection_disconnect
// file src/connection.c line 129
void kore_connection_disconnect(struct connection *c);
// kore_connection_handle
// file src/connection.c line 142
signed int kore_connection_handle(struct connection *c);
// kore_connection_init
// file src/connection.c line 30
void kore_connection_init(void);
// kore_connection_new
// file src/connection.c line 37
struct connection * kore_connection_new(void *owner);
// kore_connection_nonblock
// file includes/kore.h line 443
signed int kore_connection_nonblock(signed int fd);
// kore_connection_remove
// file src/connection.c line 265
void kore_connection_remove(struct connection *c);
// kore_connection_start_idletimer
// file src/connection.c line 349
void kore_connection_start_idletimer(struct connection *c);
// kore_connection_stop_idletimer
// file src/connection.c line 358
void kore_connection_stop_idletimer(struct connection *c);
// kore_date_to_time
// file src/utils.c line 240
signed long int kore_date_to_time(char *http_date);
// kore_debug_internal
// file src/utils.c line 45
void kore_debug_internal(char *file, signed int line, const char *fmt, ...);
// kore_domain_closelogs
// file includes/kore.h line 501
void kore_domain_closelogs(void);
// kore_domain_init
// file includes/kore.h line 495
void kore_domain_init(void);
// kore_domain_load_crl
// file src/domain.c line 204
void kore_domain_load_crl(void);
// kore_domain_lookup
// file includes/kore.h line 509
struct kore_domain * kore_domain_lookup(const char *domain);
// kore_domain_new
// file includes/kore.h line 496
signed int kore_domain_new(char *domain);
// kore_domain_sslstart
// file includes/kore.h line 505
void kore_domain_sslstart(struct kore_domain *dom);
// kore_log
// file includes/kore.h line 476
void kore_log(signed int prio, const char *fmt, ...);
// kore_log_init
// file includes/kore.h line 455
void kore_log_init(void);
// kore_malloc
// file includes/kore.h line 457
void * kore_malloc(unsigned long int len);
// kore_mem_find
// file includes/kore.h line 486
void * kore_mem_find(void *src, unsigned long int slen, void *needle, unsigned int len);
// kore_mem_free
// file includes/kore.h line 461
void kore_mem_free(void *ptr);
// kore_mem_init
// file includes/kore.h line 462
void kore_mem_init(void);
// kore_module_getsym
// file src/module.c line 221
void * kore_module_getsym(const char *symbol);
// kore_module_handler_find
// file includes/kore.h line 510
struct kore_module_handle * kore_module_handler_find(const char *domain, const char *path);
// kore_module_handler_new
// file includes/kore.h line 506
signed int kore_module_handler_new(const char *path, const char *domain, const char *func, const char *auth, signed int type);
// kore_module_init
// file includes/kore.h line 497
void kore_module_init(void);
// kore_module_load
// file includes/kore.h line 504
void kore_module_load(const char *path, const char *onload);
// kore_module_loaded
// file includes/kore.h line 500
signed int kore_module_loaded(void);
// kore_module_onload
// file src/module.c line 64
void kore_module_onload(void);
// kore_module_reload
// file includes/kore.h line 498
void kore_module_reload(signed int cbs);
// kore_parse_config
// file includes/kore.h line 458
void kore_parse_config(void);
// kore_parse_config_file
// file src/config.c line 161
static void kore_parse_config_file(char *fpath);
// kore_pgsql_cleanup
// file includes/pgsql.h line 52
void kore_pgsql_cleanup(struct kore_pgsql *pgsql);
// kore_pgsql_continue
// file src/pgsql.c line 171
void kore_pgsql_continue(struct http_request *req, struct kore_pgsql *pgsql);
// kore_pgsql_getlength
// file src/pgsql.c line 238
signed int kore_pgsql_getlength(struct kore_pgsql *pgsql, signed int row, signed int col);
// kore_pgsql_getvalue
// file src/pgsql.c line 244
char * kore_pgsql_getvalue(struct kore_pgsql *pgsql, signed int row, signed int col);
// kore_pgsql_handle
// file src/pgsql.c line 141
void kore_pgsql_handle(void *c, signed int err);
// kore_pgsql_init
// file includes/pgsql.h line 50
void kore_pgsql_init(void);
// kore_pgsql_logerror
// file src/pgsql.c line 225
void kore_pgsql_logerror(struct kore_pgsql *pgsql);
// kore_pgsql_ntuples
// file src/pgsql.c line 232
signed int kore_pgsql_ntuples(struct kore_pgsql *pgsql);
// kore_pgsql_query
// file src/pgsql.c line 78
signed int kore_pgsql_query(struct kore_pgsql *pgsql, struct http_request *req, const char *query);
// kore_pgsql_query_params
// file src/pgsql.c line 94
signed int kore_pgsql_query_params(struct kore_pgsql *pgsql, struct http_request *req, const char *query, signed int result, unsigned char count, ...);
// kore_pgsql_queue_remove
// file includes/pgsql.h line 61
void kore_pgsql_queue_remove(struct http_request *req);
// kore_platform_disable_accept
// file includes/kore.h line 414
void kore_platform_disable_accept(void);
// kore_platform_disable_read
// file includes/kore.h line 412
void kore_platform_disable_read(signed int fd);
// kore_platform_enable_accept
// file includes/kore.h line 413
void kore_platform_enable_accept(void);
// kore_platform_event_all
// file src/linux.c line 179
void kore_platform_event_all(signed int fd, void *c);
// kore_platform_event_init
// file includes/kore.h line 410
void kore_platform_event_init(void);
// kore_platform_event_schedule
// file src/linux.c line 186
void kore_platform_event_schedule(signed int fd, signed int type, signed int flags, void *udata);
// kore_platform_event_wait
// file includes/kore.h line 415
signed int kore_platform_event_wait(unsigned long int timer);
// kore_platform_init
// file includes/kore.h line 409
void kore_platform_init(void);
// kore_platform_proctitle
// file includes/kore.h line 411
void kore_platform_proctitle(char *title);
// kore_platform_schedule_read
// file includes/kore.h line 417
void kore_platform_schedule_read(signed int fd, void *data);
// kore_platform_worker_setcpu
// file includes/kore.h line 419
void kore_platform_worker_setcpu(struct kore_worker *kw);
// kore_pool_get
// file includes/kore.h line 468
void * kore_pool_get(struct kore_pool *pool);
// kore_pool_init
// file includes/kore.h line 470
void kore_pool_init(struct kore_pool *pool, const char *name, unsigned int len, unsigned int elm);
// kore_pool_put
// file includes/kore.h line 469
void kore_pool_put(struct kore_pool *pool, void *ptr);
// kore_realloc
// file includes/kore.h line 460
void * kore_realloc(void *ptr, unsigned long int len);
// kore_server_bind
// file src/kore.c line 228
signed int kore_server_bind(const char *ip, const char *port);
// kore_server_sslstart
// file src/kore.c line 308
static void kore_server_sslstart(void);
// kore_server_start
// file src/kore.c line 319
static void kore_server_start(void);
// kore_signal
// file src/kore.c line 302
void kore_signal(signed int sig);
// kore_snprintf
// file includes/kore.h line 482
signed int kore_snprintf(char *str, unsigned long int size, signed int *len, const char *fmt, ...);
// kore_split_string
// file includes/kore.h line 480
signed int kore_split_string(char *input, char *delim, char **out, unsigned long int ele);
// kore_strdup
// file includes/kore.h line 475
char * kore_strdup(const char *str);
// kore_strip_chars
// file includes/kore.h line 481
void kore_strip_chars(char *in, char strip, char **out);
// kore_strlcpy
// file includes/kore.h line 478
void kore_strlcpy(char *dst, const char *src, unsigned long int len);
// kore_strtonum
// file includes/kore.h line 483
signed long long int kore_strtonum(const char *str, signed int base, signed long long int min, signed long long int max, signed int *err);
// kore_strtonum64
// file includes/kore.h line 477
unsigned long int kore_strtonum64(const char *str, signed int sign, signed int *err);
// kore_task_bind_request
// file src/tasks.c line 97
void kore_task_bind_request(struct kore_task *t, struct http_request *req);
// kore_task_channel_read
// file src/tasks.c line 166
unsigned int kore_task_channel_read(struct kore_task *t, void *out, unsigned int len);
// kore_task_channel_write
// file src/tasks.c line 155
void kore_task_channel_write(struct kore_task *t, void *data, unsigned int len);
// kore_task_create
// file src/tasks.c line 61
void kore_task_create(struct kore_task *t, signed int (*entry)(struct kore_task *));
// kore_task_create::entry_object
//
signed int entry_object(struct kore_task *);
// kore_task_destroy
// file includes/tasks.h line 62
void kore_task_destroy(struct kore_task *t);
// kore_task_finish
// file src/tasks.c line 140
void kore_task_finish(struct kore_task *t);
// kore_task_finished
// file includes/tasks.h line 63
signed int kore_task_finished(struct kore_task *t);
// kore_task_handle
// file src/tasks.c line 187
void kore_task_handle(struct kore_task *t, signed int finished);
// kore_task_init
// file includes/tasks.h line 59
void kore_task_init(void);
// kore_task_result
// file src/tasks.c line 225
signed int kore_task_result(struct kore_task *t);
// kore_task_run
// file src/tasks.c line 74
void kore_task_run(struct kore_task *t);
// kore_task_set_result
// file src/tasks.c line 237
void kore_task_set_result(struct kore_task *t, signed int result);
// kore_task_set_state
// file src/tasks.c line 217
void kore_task_set_state(struct kore_task *t, signed int state);
// kore_task_state
// file src/tasks.c line 205
signed int kore_task_state(struct kore_task *t);
// kore_time_ms
// file includes/kore.h line 454
unsigned long int kore_time_ms(void);
// kore_time_to_date
// file includes/kore.h line 474
char * kore_time_to_date(signed long int now);
// kore_timer_add
// file src/timer.c line 31
struct kore_timer * kore_timer_add(void (*cb)(void *, unsigned long int, unsigned long int), unsigned long int interval, void *arg, signed int flags);

//

// kore_timer_init
// file src/timer.c line 25
void kore_timer_init(void);
// kore_timer_remove
// file src/timer.c line 56
void kore_timer_remove(struct kore_timer *timer);
// kore_timer_run
// file src/timer.c line 63
unsigned long int kore_timer_run(unsigned long int now);
// kore_tls_info_callback
// file src/kore.c line 215
void kore_tls_info_callback(const struct ssl_st *ssl, signed int flags, signed int ret);
// kore_tls_npn_cb
// file src/kore.c line 178
signed int kore_tls_npn_cb(struct ssl_st *ssl, const unsigned char **data, unsigned int *len, void *arg);
// kore_tls_sni_cb
// file src/kore.c line 189
signed int kore_tls_sni_cb(struct ssl_st *ssl, signed int *ad, void *arg);
// kore_validator_add
// file includes/kore.h line 515
signed int kore_validator_add(const char *name, unsigned char type, const char *arg);
// kore_validator_check
// file includes/kore.h line 517
signed int kore_validator_check(struct http_request *req, struct kore_validator *val, void *data);
// kore_validator_init
// file includes/kore.h line 513
void kore_validator_init(void);
// kore_validator_lookup
// file includes/kore.h line 519
struct kore_validator * kore_validator_lookup(const char *name);
// kore_validator_reload
// file includes/kore.h line 514
void kore_validator_reload(void);
// kore_validator_run
// file src/validator.c line 66
signed int kore_validator_run(struct http_request *req, const char *name, char *data);
// kore_websocket_broadcast
// file src/websocket.c line 170
void kore_websocket_broadcast(struct connection *c, unsigned char op, void *data, unsigned long int len, signed int scope);
// kore_websocket_handshake
// file src/websocket.c line 54
void kore_websocket_handshake(struct http_request *req, struct kore_wscbs *wscbs);
// kore_websocket_send
// file src/websocket.c line 122
void kore_websocket_send(struct connection *c, unsigned char op, void *data, unsigned long int len);
// kore_worker_acceptlock_obtain
// file src/worker.c line 475
static inline signed int kore_worker_acceptlock_obtain(void);
// kore_worker_acceptlock_release
// file src/worker.c line 462
static inline void kore_worker_acceptlock_release(void);
// kore_worker_connection_add
// file includes/kore.h line 403
void kore_worker_connection_add(struct connection *c);
// kore_worker_connection_move
// file includes/kore.h line 404
void kore_worker_connection_move(struct connection *c);
// kore_worker_connection_remove
// file includes/kore.h line 405
void kore_worker_connection_remove(struct connection *c);
// kore_worker_dispatch_signal
// file includes/kore.h line 400
void kore_worker_dispatch_signal(signed int sig);
// kore_worker_entry
// file src/worker.c line 181
void kore_worker_entry(struct kore_worker *kw);
// kore_worker_init
// file includes/kore.h line 398
void kore_worker_init(void);
// kore_worker_shutdown
// file includes/kore.h line 399
void kore_worker_shutdown(void);
// kore_worker_spawn
// file src/worker.c line 118
void kore_worker_spawn(unsigned short int id, unsigned short int cpu);
// kore_worker_wait
// file includes/kore.h line 397
void kore_worker_wait(signed int final);
// kore_worker_websocket_broadcast
// file includes/kore.h line 406
void kore_worker_websocket_broadcast(struct connection *src, void (*cb)(struct connection *, void *), void *args);

//

// kore_write_kore_pid
// file src/kore.c line 371
static void kore_write_kore_pid(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// net_init
// file src/net.c line 34
void net_init(void);
// net_read
// file src/net.c line 380
signed int net_read(struct connection *c, signed int *bytes);
// net_read16
// file src/net.c line 403
unsigned short int net_read16(unsigned char *b);
// net_read32
// file src/net.c line 412
unsigned int net_read32(unsigned char *b);
// net_read64
// file src/net.c line 439
unsigned long int net_read64(unsigned char *b);
// net_read_ssl
// file includes/kore.h line 536
signed int net_read_ssl(struct connection *c, signed int *bytes);
// net_recv_expand
// file src/net.c line 165
void net_recv_expand(struct connection *c, unsigned int len, signed int (*cb)(struct netbuf *));

//

// net_recv_flush
// file includes/kore.h line 534
signed int net_recv_flush(struct connection *c);
// net_recv_queue
// file includes/kore.h line 542
void net_recv_queue(struct connection *c, unsigned int len, signed int flags, signed int (*cb)(struct netbuf *));

//

// net_recv_reset
// file includes/kore.h line 539
void net_recv_reset(struct connection *c, unsigned int len, signed int (*cb)(struct netbuf *));

//

// net_remove_netbuf
// file src/net.c line 276
void net_remove_netbuf(struct netbuf_head *list, struct netbuf *nb);
// net_send
// file src/net.c line 179
signed int net_send(struct connection *c);
// net_send_flush
// file includes/kore.h line 533
signed int net_send_flush(struct connection *c);
// net_send_queue
// file includes/kore.h line 546
void net_send_queue(struct connection *c, void *data, unsigned int len, struct spdy_stream *s, signed int before);
// net_send_stream
// file includes/kore.h line 548
void net_send_stream(struct connection *c, void *data, unsigned int len, struct spdy_stream *s, signed int (*cb)(struct netbuf *), struct netbuf **out);

//

// net_write
// file src/net.c line 358
signed int net_write(struct connection *c, signed int len, signed int *written);
// net_write16
// file src/net.c line 421
void net_write16(unsigned char *p, unsigned short int n);
// net_write32
// file src/net.c line 430
void net_write32(unsigned char *p, unsigned int n);
// net_write64
// file src/net.c line 448
void net_write64(unsigned char *p, unsigned long int n);
// net_write_ssl
// file includes/kore.h line 538
signed int net_write_ssl(struct connection *c, signed int len, signed int *written);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pgsql_conn_cleanup
// file src/pgsql.c line 408
static void pgsql_conn_cleanup(struct pgsql_conn *conn);
// pgsql_conn_create
// file src/pgsql.c line 351
static signed int pgsql_conn_create(struct kore_pgsql *pgsql);
// pgsql_conn_release
// file src/pgsql.c line 380
static void pgsql_conn_release(struct kore_pgsql *pgsql);
// pgsql_prepare
// file src/pgsql.c line 266
static signed int pgsql_prepare(struct kore_pgsql *pgsql, struct http_request *req, const char *query);
// pgsql_queue_add
// file src/pgsql.c line 318
static void pgsql_queue_add(struct http_request *req);
// pgsql_queue_wakeup
// file src/pgsql.c line 332
static void pgsql_queue_wakeup(void);
// pgsql_read_result
// file src/pgsql.c line 440
static void pgsql_read_result(struct kore_pgsql *pgsql, signed int async);
// pgsql_schedule
// file src/pgsql.c line 305
static void pgsql_schedule(struct kore_pgsql *pgsql, struct http_request *req);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// pool_region_create
// file src/pool.c line 96
static void pool_region_create(struct kore_pool *pool, unsigned int elms);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_10 *, const union anonymous_9 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_10 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_10 *, union anonymous_5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_5 *, const union anonymous_9 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_5 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous_8 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous_8 *, const union anonymous_7 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_8 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_8 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_8 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_57 *, signed int);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// sched_setaffinity
// file /usr/include/sched.h line 118
extern signed int sched_setaffinity(signed int, unsigned long int, const struct anonymous_18 *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setresgid
// file /usr/include/unistd.h line 748
extern signed int setresgid(unsigned int, unsigned int, unsigned int);
// setresuid
// file /usr/include/unistd.h line 743
extern signed int setresuid(unsigned int, unsigned int, unsigned int);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 73
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// spdy_block_write
// file src/spdy.c line 875
static void spdy_block_write(struct connection *c);
// spdy_ctrl_frame_goaway
// file src/spdy.c line 758
static signed int spdy_ctrl_frame_goaway(struct netbuf *nb);
// spdy_ctrl_frame_ping
// file src/spdy.c line 691
static signed int spdy_ctrl_frame_ping(struct netbuf *nb);
// spdy_ctrl_frame_rst_stream
// file src/spdy.c line 612
static signed int spdy_ctrl_frame_rst_stream(struct netbuf *nb);
// spdy_ctrl_frame_settings
// file src/spdy.c line 636
static signed int spdy_ctrl_frame_settings(struct netbuf *nb);
// spdy_ctrl_frame_syn_stream
// file src/spdy.c line 476
static signed int spdy_ctrl_frame_syn_stream(struct netbuf *nb);
// spdy_ctrl_frame_window
// file src/spdy.c line 713
static signed int spdy_ctrl_frame_window(struct netbuf *nb);
// spdy_data_frame_recv
// file src/spdy.c line 771
static signed int spdy_data_frame_recv(struct netbuf *nb);
// spdy_dataframe_begin
// file includes/kore.h line 568
signed int spdy_dataframe_begin(struct connection *c);
// spdy_enable_write
// file src/spdy.c line 884
static void spdy_enable_write(struct connection *c);
// spdy_frame_recv
// file includes/kore.h line 567
signed int spdy_frame_recv(struct netbuf *nb);

//

// spdy_frame_send
// file includes/kore.h line 570
void spdy_frame_send(struct connection *c, unsigned short int type, unsigned char flags, unsigned int len, struct spdy_stream *s, unsigned int misc);
// spdy_header_block_add
// file includes/kore.h line 572
void spdy_header_block_add(struct spdy_header_block *hblock, char *name, char *value);
// spdy_header_block_create
// file includes/kore.h line 579
struct spdy_header_block * spdy_header_block_create(signed int delayed_alloc);
// spdy_header_block_release
// file includes/kore.h line 574
unsigned char * spdy_header_block_release(struct connection *c, struct spdy_header_block *hblock, unsigned int *len);
// spdy_session_teardown
// file includes/kore.h line 569
void spdy_session_teardown(struct connection *c, unsigned char err);
// spdy_stream_close
// file includes/kore.h line 576
void spdy_stream_close(struct connection *c, struct spdy_stream *s, signed int rb);
// spdy_stream_get_header
// file includes/kore.h line 562
signed int spdy_stream_get_header(struct spdy_header_block *s, const char *header, char **out);
// spdy_stream_lookup
// file src/spdy.c line 246
struct spdy_stream * spdy_stream_lookup(struct connection *c, unsigned int id);
// spdy_update_wsize
// file includes/kore.h line 564
void spdy_update_wsize(struct connection *c, struct spdy_stream *s, unsigned int len);
// spdy_zlib_deflate
// file src/spdy.c line 963
static signed int spdy_zlib_deflate(struct connection *c, unsigned char *src, unsigned long int len, unsigned char **dst, unsigned int *olen);
// spdy_zlib_inflate
// file src/spdy.c line 893
static signed int spdy_zlib_inflate(struct connection *c, unsigned char *src, unsigned long int len, unsigned char **dst, unsigned int *olen);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsep
// file /usr/include/string.h line 556
extern char * strsep(char ** restrict , const char *);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// task_channel_read
// file src/tasks.c line 264
static void task_channel_read(signed int fd, void *out, unsigned int len);
// task_channel_write
// file src/tasks.c line 245
static void task_channel_write(signed int fd, void *data, unsigned int len);
// task_thread
// file src/tasks.c line 304
static void * task_thread(void *arg);
// task_thread_spawn
// file src/tasks.c line 286
static void task_thread_spawn(struct kore_task_thread **out);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file src/kore.c line 50
static void usage(void);
// utimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 138
extern signed int utimes(const char *, struct timeval *);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// version
// file src/kore.c line 67
static void version(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// websocket_disconnect
// file src/websocket.c line 327
static void websocket_disconnect(struct connection *c);
// websocket_recv_frame
// file src/websocket.c line 248
static signed int websocket_recv_frame(struct netbuf *nb);
// websocket_recv_opcode
// file src/websocket.c line 194
static signed int websocket_recv_opcode(struct netbuf *nb);
// websocket_send_single
// file src/websocket.c line 185
static void websocket_send_single(struct connection *c, void *args);
// worker_trylock
// file src/worker.c line 500
static signed int worker_trylock(void);
// worker_unlock
// file src/worker.c line 513
static void worker_unlock(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_63
{
  // name
  char *name;
  // value
  signed int value;
};

struct anonymous_66
{
  // tqe_next
  struct cfile *tqe_next;
  // tqe_prev
  struct cfile **tqe_prev;
};

struct anonymous_39
{
  // tqe_next
  struct connection *tqe_next;
  // tqe_prev
  struct connection **tqe_prev;
};

struct anonymous_60
{
  // tqe_next
  struct http_arg *tqe_next;
  // tqe_prev
  struct http_arg **tqe_prev;
};

struct anonymous_35
{
  // tqh_first
  struct http_arg *tqh_first;
  // tqh_last
  struct http_arg **tqh_last;
};

struct anonymous_61
{
  // tqe_next
  struct http_file *tqe_next;
  // tqe_prev
  struct http_file **tqe_prev;
};

struct anonymous_36
{
  // tqh_first
  struct http_file *tqh_first;
  // tqh_last
  struct http_file **tqh_last;
};

struct anonymous_59
{
  // tqe_next
  struct http_header *tqe_next;
  // tqe_prev
  struct http_header **tqe_prev;
};

struct anonymous_34
{
  // tqh_first
  struct http_header *tqh_first;
  // tqh_last
  struct http_header **tqh_last;
};

struct anonymous_37
{
  // tqe_next
  struct http_request *tqe_next;
  // tqe_prev
  struct http_request **tqe_prev;
};

struct anonymous_38
{
  // tqh_first
  struct http_request *tqh_first;
  // tqh_last
  struct http_request **tqh_last;
};

struct anonymous_13
{
  // tqe_next
  struct kore_auth *tqe_next;
  // tqe_prev
  struct kore_auth **tqe_prev;
};

struct anonymous_64
{
  // tqh_first
  struct kore_auth *tqh_first;
  // tqh_last
  struct kore_auth **tqh_last;
};

struct anonymous_12
{
  // tqe_next
  struct kore_domain *tqe_next;
  // tqe_prev
  struct kore_domain **tqe_prev;
};

struct anonymous_40
{
  // tqe_next
  struct kore_handler_params *tqe_next;
  // tqe_prev
  struct kore_handler_params **tqe_prev;
};

struct anonymous_14
{
  // tqh_first
  struct kore_handler_params *tqh_first;
  // tqh_last
  struct kore_handler_params **tqh_last;
};

struct anonymous_56
{
  // tqe_next
  struct kore_module *tqe_next;
  // tqe_prev
  struct kore_module **tqe_prev;
};

struct anonymous_55
{
  // tqh_first
  struct kore_module *tqh_first;
  // tqh_last
  struct kore_module **tqh_last;
};

struct anonymous_15
{
  // tqe_next
  struct kore_module_handle *tqe_next;
  // tqe_prev
  struct kore_module_handle **tqe_prev;
};

struct anonymous_11
{
  // tqh_first
  struct kore_module_handle *tqh_first;
  // tqh_last
  struct kore_module_handle **tqh_last;
};

struct anonymous_25
{
  // le_next
  struct kore_pgsql *le_next;
  // le_prev
  struct kore_pgsql **le_prev;
};

struct anonymous_33
{
  // lh_first
  struct kore_pgsql *lh_first;
};

struct anonymous_46
{
  // le_next
  struct kore_pool_entry *le_next;
  // le_prev
  struct kore_pool_entry **le_prev;
};

struct anonymous_44
{
  // lh_first
  struct kore_pool_entry *lh_first;
};

struct anonymous_45
{
  // le_next
  struct kore_pool_region *le_next;
  // le_prev
  struct kore_pool_region **le_prev;
};

struct anonymous_43
{
  // lh_first
  struct kore_pool_region *lh_first;
};

struct anonymous_51
{
  // le_next
  struct kore_task *le_next;
  // le_prev
  struct kore_task **le_prev;
};

struct anonymous_32
{
  // lh_first
  struct kore_task *lh_first;
};

struct anonymous_50
{
  // tqe_next
  struct kore_task *tqe_next;
  // tqe_prev
  struct kore_task **tqe_prev;
};

struct anonymous_48
{
  // tqh_first
  struct kore_task *tqh_first;
  // tqh_last
  struct kore_task **tqh_last;
};

struct anonymous_49
{
  // tqe_next
  struct kore_task_thread *tqe_next;
  // tqe_prev
  struct kore_task_thread **tqe_prev;
};

struct anonymous_6
{
  // tqh_first
  struct kore_task_thread *tqh_first;
  // tqh_last
  struct kore_task_thread **tqh_last;
};

struct anonymous_58
{
  // tqe_next
  struct kore_timer *tqe_next;
  // tqe_prev
  struct kore_timer **tqe_prev;
};

struct anonymous_42
{
  // tqe_next
  struct kore_validator *tqe_next;
  // tqe_prev
  struct kore_validator **tqe_prev;
};

struct anonymous_62
{
  // tqh_first
  struct kore_validator *tqh_first;
  // tqh_last
  struct kore_validator **tqh_last;
};

struct anonymous_29
{
  // le_next
  struct listener *le_next;
  // le_prev
  struct listener **le_prev;
};

struct anonymous_27
{
  // tqe_next
  struct netbuf *tqe_next;
  // tqe_prev
  struct netbuf **tqe_prev;
};

struct anonymous_22
{
  // tqe_next
  struct pgsql_conn *tqe_next;
  // tqe_prev
  struct pgsql_conn **tqe_prev;
};

struct anonymous_2
{
  // tqh_first
  struct pgsql_conn *tqh_first;
  // tqh_last
  struct pgsql_conn **tqh_last;
};

struct anonymous_0
{
  // tqe_next
  struct pgsql_job *tqe_next;
  // tqe_prev
  struct pgsql_job **tqe_prev;
};

struct anonymous_1
{
  // tqe_next
  struct pgsql_wait *tqe_next;
  // tqe_prev
  struct pgsql_wait **tqe_prev;
};

struct anonymous_3
{
  // tqh_first
  struct pgsql_wait *tqh_first;
  // tqh_last
  struct pgsql_wait **tqh_last;
};

struct anonymous_24
{
  // tqe_next
  struct spdy_stream *tqe_next;
  // tqe_prev
  struct spdy_stream **tqe_prev;
};

struct anonymous_31
{
  // tqh_first
  struct spdy_stream *tqh_first;
  // tqh_last
  struct spdy_stream **tqh_last;
};

struct anonymous_23
{
  // name
  const char *name;
  // configure
  signed int (*configure)(char **);
};

struct anonymous_54
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_18
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous_52
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_47
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_57
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_16
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_53
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

struct anonymous_30
{
  // length
  unsigned long int length;
  // start
  unsigned long int start;
};

union anonymous_65
{
  // inherit
  signed int *inherit;
  // asIdsOrRanges
  struct stack_st_ASIdOrRange *asIdsOrRanges;
};

union anonymous_21
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_20
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_41
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_26
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_9
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_7
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_10
{
  // __data
  struct anonymous_52 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_8
{
  // __data
  struct anonymous_47 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_26 __in6_u;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union anonymous_28
{
  // ipv4
  struct sockaddr_in ipv4;
  // ipv6
  struct sockaddr_in6 ipv6;
};

union anonymous_19
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_17
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ASIdentifierChoice_st
{
  // type
  signed int type;
  // u
  union anonymous_65 u;
};

struct ASIdentifiers_st
{
  // asnum
  struct ASIdentifierChoice_st *asnum;
  // rdi
  struct ASIdentifierChoice_st *rdi;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct AUTHORITY_KEYID_st
{
  // keyid
  struct asn1_string_st *keyid;
  // issuer
  struct stack_st_GENERAL_NAME *issuer;
  // serial
  struct asn1_string_st *serial;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct NAME_CONSTRAINTS_st
{
  // permittedSubtrees
  struct stack_st_GENERAL_SUBTREE *permittedSubtrees;
  // excludedSubtrees
  struct stack_st_GENERAL_SUBTREE *excludedSubtrees;
};

struct SHAstate_st
{
  // h0
  unsigned int h0;
  // h1
  unsigned int h1;
  // h2
  unsigned int h2;
  // h3
  unsigned int h3;
  // h4
  unsigned int h4;
  // Nl
  unsigned int Nl;
  // Nh
  unsigned int Nh;
  // data
  unsigned int data[16l];
  // num
  unsigned int num;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_20 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_41 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct cfile
{
  // st
  struct stat st;
  // build
  signed int build;
  // cpp
  signed int cpp;
  // name
  char *name;
  // fpath
  char *fpath;
  // opath
  char *opath;
  // list
  struct anonymous_66 list;
};

struct cfile_list
{
  // tqh_first
  struct cfile *tqh_first;
  // tqh_last
  struct cfile **tqh_last;
};

struct cmd
{
  // name
  const char *name;
  // descr
  const char *descr;
  // cb
  void (*cb)(signed int, char **);
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct netbuf_head
{
  // tqh_first
  struct netbuf *tqh_first;
  // tqh_last
  struct netbuf **tqh_last;
};

struct connection
{
  // type
  unsigned char type;
  // fd
  signed int fd;
  // state
  unsigned char state;
  // proto
  unsigned char proto;
  // owner
  void *owner;
  // ssl
  struct ssl_st *ssl;
  // flags
  unsigned char flags;
  // hdlr_extra
  void *hdlr_extra;
  // cert
  struct x509_st *cert;
  // wscbs
  void *wscbs;
  // tls_reneg
  signed int tls_reneg;
  // disconnect
  void (*disconnect)(struct connection *);
  // read
  signed int (*read)(struct connection *, signed int *);
  // write
  signed int (*write)(struct connection *, signed int, signed int *);
  // addrtype
  unsigned char addrtype;
  // addr
  union anonymous_28 addr;
  // idle_timer
  struct anonymous_30 idle_timer;
  // inflate_started
  unsigned char inflate_started;
  // z_inflate
  struct z_stream_s z_inflate;
  // deflate_started
  unsigned char deflate_started;
  // z_deflate
  struct z_stream_s z_deflate;
  // wsize_initial
  unsigned int wsize_initial;
  // spdy_send_wsize
  unsigned int spdy_send_wsize;
  // spdy_recv_wsize
  unsigned int spdy_recv_wsize;
  // send_queue
  struct netbuf_head send_queue;
  // snb
  struct netbuf *snb;
  // rnb
  struct netbuf *rnb;
  // client_stream_id
  unsigned int client_stream_id;
  // spdy_streams
  struct anonymous_31 spdy_streams;
  // http_requests
  struct anonymous_38 http_requests;
  // list
  struct anonymous_39 list;
  // flush_list
  struct anonymous_39 flush_list;
};

struct connection_list
{
  // tqh_first
  struct connection *tqh_first;
  // tqh_last
  struct connection **tqh_last;
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_21 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct filegen
{
  // cb
  void (*cb)(void);
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct http_arg
{
  // name
  char *name;
  // value
  void *value;
  // len
  unsigned int len;
  // s_value
  char *s_value;
  // s_len
  unsigned int s_len;
  // list
  struct anonymous_60 list;
};

struct http_file
{
  // name
  char *name;
  // filename
  char *filename;
  // data
  unsigned char *data;
  // len
  unsigned int len;
  // list
  struct anonymous_61 list;
};

struct http_header
{
  // header
  char *header;
  // value
  char *value;
  // list
  struct anonymous_59 list;
};

struct http_request
{
  // method
  unsigned char method;
  // flags
  unsigned char flags;
  // fsm_state
  unsigned char fsm_state;
  // status
  unsigned short int status;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // total
  unsigned long int total;
  // host
  char *host;
  // path
  char *path;
  // agent
  char *agent;
  // owner
  struct connection *owner;
  // stream
  struct spdy_stream *stream;
  // http_body
  struct kore_buf *http_body;
  // hdlr_extra
  void *hdlr_extra;
  // query_string
  char *query_string;
  // multipart_body
  unsigned char *multipart_body;
  // hdlr
  struct kore_module_handle *hdlr;
  // tasks
  struct anonymous_32 tasks;
  // pgsqls
  struct anonymous_33 pgsqls;
  // req_headers
  struct anonymous_34 req_headers;
  // resp_headers
  struct anonymous_34 resp_headers;
  // arguments
  struct anonymous_35 arguments;
  // files
  struct anonymous_36 files;
  // list
  struct anonymous_37 list;
  // olist
  struct anonymous_37 olist;
};

struct http_state
{
  // name
  const char *name;
  // cb
  signed int (*cb)(struct http_request *);
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct kore_auth
{
  // type
  unsigned char type;
  // name
  char *name;
  // value
  char *value;
  // redirect
  char *redirect;
  // validator
  struct kore_validator *validator;
  // list
  struct anonymous_13 list;
};

struct kore_buf
{
  // data
  unsigned char *data;
  // length
  unsigned long int length;
  // offset
  unsigned long int offset;
};

struct kore_domain
{
  // domain
  char *domain;
  // certfile
  char *certfile;
  // certkey
  char *certkey;
  // cafile
  char *cafile;
  // crlfile
  char *crlfile;
  // accesslog
  signed int accesslog;
  // ssl_ctx
  struct ssl_ctx_st *ssl_ctx;
  // handlers
  struct anonymous_11 handlers;
  // list
  struct anonymous_12 list;
};

struct kore_domain_h
{
  // tqh_first
  struct kore_domain *tqh_first;
  // tqh_last
  struct kore_domain **tqh_last;
};

struct kore_handler_params
{
  // name
  char *name;
  // method
  unsigned char method;
  // validator
  struct kore_validator *validator;
  // list
  struct anonymous_40 list;
};

struct kore_log_packet
{
  // method
  unsigned char method;
  // status
  signed int status;
  // time_req
  unsigned short int time_req;
  // worker_id
  unsigned short int worker_id;
  // worker_cpu
  unsigned short int worker_cpu;
  // addrtype
  unsigned char addrtype;
  // addr
  unsigned char addr[(signed long int)sizeof(struct in6_addr) /*16l*/ ];
  // host
  char host[254l];
  // path
  char path[2000l];
  // agent
  char agent[256l];
  // cn
  char cn[65l];
};

struct kore_module
{
  // handle
  void *handle;
  // path
  char *path;
  // onload
  char *onload;
  // ocb
  signed int (*ocb)(signed int);
  // mtime
  signed long int mtime;
  // list
  struct anonymous_56 list;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct kore_module_handle
{
  // path
  char *path;
  // func
  char *func;
  // addr
  void *addr;
  // type
  signed int type;
  // errors
  signed int errors;
  // rctx
  struct re_pattern_buffer rctx;
  // dom
  struct kore_domain *dom;
  // auth
  struct kore_auth *auth;
  // params
  struct anonymous_14 params;
  // list
  struct anonymous_15 list;
};

struct kore_pgsql
{
  // state
  unsigned char state;
  // error
  char *error;
  // result
  struct pg_result *result;
  // conn
  struct pgsql_conn *conn;
  // rlist
  struct anonymous_25 rlist;
};

struct kore_pool
{
  // elen
  unsigned int elen;
  // slen
  unsigned int slen;
  // elms
  unsigned int elms;
  // inuse
  unsigned int inuse;
  // name
  char *name;
  // regions
  struct anonymous_43 regions;
  // freelist
  struct anonymous_44 freelist;
};

struct kore_pool_entry
{
  // state
  unsigned char state;
  // region
  struct kore_pool_region *region;
  // list
  struct anonymous_46 list;
};

struct kore_pool_region
{
  // start
  void *start;
  // list
  struct anonymous_45 list;
};

struct kore_task
{
  // type
  unsigned char type;
  // state
  signed int state;
  // result
  signed int result;
  // lock
  union anonymous_8 lock;
  // req
  struct http_request *req;
  // fds
  signed int fds[2l];
  // entry
  signed int (*entry)(struct kore_task *);
  // thread
  struct kore_task_thread *thread;
  // list
  struct anonymous_50 list;
  // rlist
  struct anonymous_51 rlist;
};

struct kore_task_thread
{
  // idx
  unsigned char idx;
  // tid
  unsigned long int tid;
  // lock
  union anonymous_5 lock;
  // cond
  union anonymous_10 cond;
  // tasks
  struct anonymous_48 tasks;
  // list
  struct anonymous_49 list;
};

struct kore_timer
{
  // nextrun
  unsigned long int nextrun;
  // interval
  unsigned long int interval;
  // flags
  signed int flags;
  // arg
  void *arg;
  // cb
  void (*cb)(void *, unsigned long int, unsigned long int);
  // list
  struct anonymous_58 list;
};

struct kore_validator
{
  // type
  unsigned char type;
  // name
  char *name;
  // arg
  char *arg;
  // rctx
  struct re_pattern_buffer rctx;
  // func
  signed int (*func)(struct http_request *, char *);
  // list
  struct anonymous_42 list;
};

struct kore_worker
{
  // id
  unsigned char id;
  // cpu
  unsigned char cpu;
  // pid
  signed int pid;
  // has_lock
  unsigned char has_lock;
  // active_hdlr
  struct kore_module_handle *active_hdlr;
};

struct kore_wscbs
{
  // connect
  void (*connect)(struct connection *);
  // message
  void (*message)(struct connection *, unsigned char, void *, unsigned long int);
  // disconnect
  void (*disconnect)(struct connection *);
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct listener
{
  // type
  unsigned char type;
  // fd
  signed int fd;
  // addrtype
  unsigned char addrtype;
  // addr
  union anonymous_28 addr;
  // list
  struct anonymous_29 list;
};

struct listener_head
{
  // lh_first
  struct listener *lh_first;
};

struct meminfo
{
  // magic
  unsigned short int magic;
};

struct netbuf
{
  // buf
  unsigned char *buf;
  // s_off
  unsigned int s_off;
  // b_len
  unsigned int b_len;
  // m_len
  unsigned int m_len;
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // owner
  void *owner;
  // stream
  struct spdy_stream *stream;
  // extra
  void *extra;
  // cb
  signed int (*cb)(struct netbuf *);
  // list
  struct anonymous_27 list;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pgsql_conn
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // db
  struct pg_conn *db;
  // job
  struct pgsql_job *job;
  // list
  struct anonymous_22 list;
};

struct pgsql_job
{
  // query
  char *query;
  // req
  struct http_request *req;
  // pgsql
  struct kore_pgsql *pgsql;
  // list
  struct anonymous_0 list;
};

struct pgsql_wait
{
  // req
  struct http_request *req;
  // list
  struct anonymous_1 list;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct spdy_ctrl_frame
{
  // version
  unsigned short int version;
  // type
  unsigned short int type;
  // flags
  unsigned char flags;
  // length
  unsigned int length;
};

struct spdy_data_frame
{
  // stream_id
  unsigned int stream_id;
  // flags
  unsigned char flags;
  // length
  unsigned int length;
};

struct spdy_header_block
{
  // header_block
  unsigned char *header_block;
  // header_block_len
  unsigned int header_block_len;
  // header_offset
  unsigned int header_offset;
  // header_pairs
  unsigned int header_pairs;
};

struct spdy_stream
{
  // stream_id
  unsigned int stream_id;
  // flags
  unsigned char flags;
  // prio
  unsigned char prio;
  // post_size
  unsigned long int post_size;
  // send_size
  unsigned long int send_size;
  // frame_size
  unsigned int frame_size;
  // recv_wsize
  unsigned int recv_wsize;
  // send_wsize
  unsigned int send_wsize;
  // onclose
  void (*onclose)(struct connection *, struct spdy_stream *);
  // httpreq
  struct http_request *httpreq;
  // hblock
  struct spdy_header_block *hblock;
  // list
  struct anonymous_24 list;
};

struct spdy_syn_stream
{
  // stream_id
  unsigned int stream_id;
  // assoc_stream_id
  unsigned int assoc_stream_id;
  // slot
  unsigned char slot;
  // reserved
  unsigned char reserved;
  // prio
  unsigned char prio;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous_53 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_54 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_16 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASIdOrRange
{
  // stack
  struct stack_st stack;
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_DIST_POINT
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_GENERAL_SUBTREE
{
  // stack
  struct stack_st stack;
};

struct stack_st_IPAddressFamily
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timerlist
{
  // tqh_first
  struct kore_timer *tqh_first;
  // tqh_last
  struct kore_timer **tqh_last;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct websocket_data
{
  // op
  unsigned char op;
  // data
  void *data;
  // len
  unsigned long int len;
};

struct wlock
{
  // lock
  volatile signed int lock;
  // current
  signed int current;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// SPDY_dictionary_txt
// file src/zlib_dict.c line 17
const unsigned char SPDY_dictionary_txt[1423l] = { (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x6f, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x73, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x68, (const unsigned char)0x65, (const unsigned char)0x61, (const unsigned char)0x64, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x70, (const unsigned char)0x6f, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x03, (const unsigned char)0x70, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x6c, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x05, (const unsigned char)0x74, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0e, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0f, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0f, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x75, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x73, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x03, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x05, (const unsigned char)0x61, (const unsigned char)0x6c, (const unsigned char)0x6c, (const unsigned char)0x6f, (const unsigned char)0x77, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x61, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x7a, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x65, (const unsigned char)0x2d, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x72, (const unsigned char)0x6f, (const unsigned char)0x6c, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0a, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x6e, (const unsigned char)0x65, (const unsigned char)0x63, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0c, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x62, (const unsigned char)0x61, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x10, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x10, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x75, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0e, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6c, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x10, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6c, (const unsigned char)0x6f, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0b, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6d, (const unsigned char)0x64, (const unsigned char)0x35, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0c, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x74, (const unsigned char)0x79, (const unsigned char)0x70, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x64, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x65, (const unsigned char)0x78, (const unsigned char)0x70, (const unsigned char)0x65, (const unsigned char)0x63, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x65, (const unsigned char)0x78, (const unsigned char)0x70, (const unsigned char)0x69, (const unsigned char)0x72, (const unsigned char)0x65, (const unsigned char)0x73, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x66, (const unsigned char)0x72, (const unsigned char)0x6f, (const unsigned char)0x6d, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x08, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x11, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x6d, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x69, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x2d, (const unsigned char)0x73, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x6e, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x65, (const unsigned char)0x2d, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x08, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x13, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x75, (const unsigned char)0x6e, (const unsigned char)0x6d, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x69, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x2d, (const unsigned char)0x73, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0d, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x6d, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x69, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x08, (const unsigned char)0x6c, (const unsigned char)0x6f, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0c, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x78, (const unsigned char)0x2d, (const unsigned char)0x66, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x77, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x64, (const unsigned char)0x73, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x70, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x12, (const unsigned char)0x70, (const unsigned char)0x72, (const unsigned char)0x6f, (const unsigned char)0x78, (const unsigned char)0x79, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x13, (const unsigned char)0x70, (const unsigned char)0x72, (const unsigned char)0x6f, (const unsigned char)0x78, (const unsigned char)0x79, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x7a, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x05, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x72, (const unsigned char)0x65, (const unsigned char)0x66, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0b, (const unsigned char)0x72, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x72, (const unsigned char)0x79, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x66, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x02, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x74, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x69, (const unsigned char)0x6c, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x11, (const unsigned char)0x74, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x73, (const unsigned char)0x66, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x2d, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x75, (const unsigned char)0x70, (const unsigned char)0x67, (const unsigned char)0x72, (const unsigned char)0x61, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0a, (const unsigned char)0x75, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x76, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x79, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x03, (const unsigned char)0x76, (const unsigned char)0x69, (const unsigned char)0x61, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x77, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x6e, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x10, (const unsigned char)0x77, (const unsigned char)0x77, (const unsigned char)0x77, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x6d, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x64, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x03, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x75, (const unsigned char)0x73, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x20, (const unsigned char)0x4f, (const unsigned char)0x4b, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x07, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x73, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x08, (const unsigned char)0x48, (const unsigned char)0x54, (const unsigned char)0x54, (const unsigned char)0x50, (const unsigned char)0x2f, (const unsigned char)0x31, (const unsigned char)0x2e, (const unsigned char)0x31, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x03, (const unsigned char)0x75, (const unsigned char)0x72, (const unsigned char)0x6c, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x70, (const unsigned char)0x75, (const unsigned char)0x62, (const unsigned char)0x6c, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0a, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x2d, (const unsigned char)0x63, (const unsigned char)0x6f, (const unsigned char)0x6f, (const unsigned char)0x6b, (const unsigned char)0x69, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x0a, (const unsigned char)0x6b, (const unsigned char)0x65, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x6c, (const unsigned char)0x69, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x00, (const unsigned char)0x06, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x67, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x31, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x32, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x35, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x36, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x32, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x33, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x34, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x35, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x36, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x37, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x32, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x35, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x36, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x37, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x38, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x39, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x30, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x31, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x32, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x33, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x34, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x35, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x36, (const unsigned char)0x34, (const unsigned char)0x31, (const unsigned char)0x37, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x32, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x34, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x35, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x33, (const unsigned char)0x20, (const unsigned char)0x4e, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x2d, (const unsigned char)0x41, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x74, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x20, (const unsigned char)0x49, (const unsigned char)0x6e, (const unsigned char)0x66, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x32, (const unsigned char)0x30, (const unsigned char)0x34, (const unsigned char)0x20, (const unsigned char)0x4e, (const unsigned char)0x6f, (const unsigned char)0x20, (const unsigned char)0x43, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x33, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x20, (const unsigned char)0x4d, (const unsigned char)0x6f, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x20, (const unsigned char)0x50, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x6c, (const unsigned char)0x79, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x20, (const unsigned char)0x42, (const unsigned char)0x61, (const unsigned char)0x64, (const unsigned char)0x20, (const unsigned char)0x52, (const unsigned char)0x65, (const unsigned char)0x71, (const unsigned char)0x75, (const unsigned char)0x65, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x20, (const unsigned char)0x55, (const unsigned char)0x6e, (const unsigned char)0x61, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x68, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x7a, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x33, (const unsigned char)0x20, (const unsigned char)0x46, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x62, (const unsigned char)0x69, (const unsigned char)0x64, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x34, (const unsigned char)0x30, (const unsigned char)0x34, (const unsigned char)0x20, (const unsigned char)0x4e, (const unsigned char)0x6f, (const unsigned char)0x74, (const unsigned char)0x20, (const unsigned char)0x46, (const unsigned char)0x6f, (const unsigned char)0x75, (const unsigned char)0x6e, (const unsigned char)0x64, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x20, (const unsigned char)0x49, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x6e, (const unsigned char)0x61, (const unsigned char)0x6c, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x76, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x20, (const unsigned char)0x45, (const unsigned char)0x72, (const unsigned char)0x72, (const unsigned char)0x6f, (const unsigned char)0x72, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x31, (const unsigned char)0x20, (const unsigned char)0x4e, (const unsigned char)0x6f, (const unsigned char)0x74, (const unsigned char)0x20, (const unsigned char)0x49, (const unsigned char)0x6d, (const unsigned char)0x70, (const unsigned char)0x6c, (const unsigned char)0x65, (const unsigned char)0x6d, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x35, (const unsigned char)0x30, (const unsigned char)0x33, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x65, (const unsigned char)0x72, (const unsigned char)0x76, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x65, (const unsigned char)0x20, (const unsigned char)0x55, (const unsigned char)0x6e, (const unsigned char)0x61, (const unsigned char)0x76, (const unsigned char)0x61, (const unsigned char)0x69, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x62, (const unsigned char)0x6c, (const unsigned char)0x65, (const unsigned char)0x4a, (const unsigned char)0x61, (const unsigned char)0x6e, (const unsigned char)0x20, (const unsigned char)0x46, (const unsigned char)0x65, (const unsigned char)0x62, (const unsigned char)0x20, (const unsigned char)0x4d, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x20, (const unsigned char)0x41, (const unsigned char)0x70, (const unsigned char)0x72, (const unsigned char)0x20, (const unsigned char)0x4d, (const unsigned char)0x61, (const unsigned char)0x79, (const unsigned char)0x20, (const unsigned char)0x4a, (const unsigned char)0x75, (const unsigned char)0x6e, (const unsigned char)0x20, (const unsigned char)0x4a, (const unsigned char)0x75, (const unsigned char)0x6c, (const unsigned char)0x20, (const unsigned char)0x41, (const unsigned char)0x75, (const unsigned char)0x67, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x65, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x20, (const unsigned char)0x4f, (const unsigned char)0x63, (const unsigned char)0x74, (const unsigned char)0x20, (const unsigned char)0x4e, (const unsigned char)0x6f, (const unsigned char)0x76, (const unsigned char)0x20, (const unsigned char)0x44, (const unsigned char)0x65, (const unsigned char)0x63, (const unsigned char)0x20, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x3a, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x3a, (const unsigned char)0x30, (const unsigned char)0x30, (const unsigned char)0x20, (const unsigned char)0x4d, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x54, (const unsigned char)0x75, (const unsigned char)0x65, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x57, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x54, (const unsigned char)0x68, (const unsigned char)0x75, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x46, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x53, (const unsigned char)0x75, (const unsigned char)0x6e, (const unsigned char)0x2c, (const unsigned char)0x20, (const unsigned char)0x47, (const unsigned char)0x4d, (const unsigned char)0x54, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x75, (const unsigned char)0x6e, (const unsigned char)0x6b, (const unsigned char)0x65, (const unsigned char)0x64, (const unsigned char)0x2c, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x78, (const unsigned char)0x74, (const unsigned char)0x2f, (const unsigned char)0x68, (const unsigned char)0x74, (const unsigned char)0x6d, (const unsigned char)0x6c, (const unsigned char)0x2c, (const unsigned char)0x69, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x2f, (const unsigned char)0x70, (const unsigned char)0x6e, (const unsigned char)0x67, (const unsigned char)0x2c, (const unsigned char)0x69, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x2f, (const unsigned char)0x6a, (const unsigned char)0x70, (const unsigned char)0x67, (const unsigned char)0x2c, (const unsigned char)0x69, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x2f, (const unsigned char)0x67, (const unsigned char)0x69, (const unsigned char)0x66, (const unsigned char)0x2c, (const unsigned char)0x61, (const unsigned char)0x70, (const unsigned char)0x70, (const unsigned char)0x6c, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x2f, (const unsigned char)0x78, (const unsigned char)0x6d, (const unsigned char)0x6c, (const unsigned char)0x2c, (const unsigned char)0x61, (const unsigned char)0x70, (const unsigned char)0x70, (const unsigned char)0x6c, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x69, (const unsigned char)0x6f, (const unsigned char)0x6e, (const unsigned char)0x2f, (const unsigned char)0x78, (const unsigned char)0x68, (const unsigned char)0x74, (const unsigned char)0x6d, (const unsigned char)0x6c, (const unsigned char)0x2b, (const unsigned char)0x78, (const unsigned char)0x6d, (const unsigned char)0x6c, (const unsigned char)0x2c, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x78, (const unsigned char)0x74, (const unsigned char)0x2f, (const unsigned char)0x70, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x69, (const unsigned char)0x6e, (const unsigned char)0x2c, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x78, (const unsigned char)0x74, (const unsigned char)0x2f, (const unsigned char)0x6a, (const unsigned char)0x61, (const unsigned char)0x76, (const unsigned char)0x61, (const unsigned char)0x73, (const unsigned char)0x63, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x70, (const unsigned char)0x74, (const unsigned char)0x2c, (const unsigned char)0x70, (const unsigned char)0x75, (const unsigned char)0x62, (const unsigned char)0x6c, (const unsigned char)0x69, (const unsigned char)0x63, (const unsigned char)0x70, (const unsigned char)0x72, (const unsigned char)0x69, (const unsigned char)0x76, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x6d, (const unsigned char)0x61, (const unsigned char)0x78, (const unsigned char)0x2d, (const unsigned char)0x61, (const unsigned char)0x67, (const unsigned char)0x65, (const unsigned char)0x3d, (const unsigned char)0x67, (const unsigned char)0x7a, (const unsigned char)0x69, (const unsigned char)0x70, (const unsigned char)0x2c, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x66, (const unsigned char)0x6c, (const unsigned char)0x61, (const unsigned char)0x74, (const unsigned char)0x65, (const unsigned char)0x2c, (const unsigned char)0x73, (const unsigned char)0x64, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x3d, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x38, (const unsigned char)0x63, (const unsigned char)0x68, (const unsigned char)0x61, (const unsigned char)0x72, (const unsigned char)0x73, (const unsigned char)0x65, (const unsigned char)0x74, (const unsigned char)0x3d, (const unsigned char)0x69, (const unsigned char)0x73, (const unsigned char)0x6f, (const unsigned char)0x2d, (const unsigned char)0x38, (const unsigned char)0x38, (const unsigned char)0x35, (const unsigned char)0x39, (const unsigned char)0x2d, (const unsigned char)0x31, (const unsigned char)0x2c, (const unsigned char)0x75, (const unsigned char)0x74, (const unsigned char)0x66, (const unsigned char)0x2d, (const unsigned char)0x2c, (const unsigned char)0x2a, (const unsigned char)0x2c, (const unsigned char)0x65, (const unsigned char)0x6e, (const unsigned char)0x71, (const unsigned char)0x3d, (const unsigned char)0x30, (const unsigned char)0x2e };
// accept_lock
// file src/worker.c line 66
static struct wlock *accept_lock;
// accesslog_fd
// file src/accesslog.c line 24
static signed int accesslog_fd[2l];
// appl
// file src/cli.c line 191
static char *appl = (char *)(void *)0;
// auth_list
// file src/auth.c line 24
struct anonymous_64 auth_list;
// b64table
// file src/utils.c line 42
static char b64table[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// cfiles_count
// file src/cli.c line 195
static signed int cfiles_count;
// chroot_path
// file src/kore.c line 36
char *chroot_path = (char *)(void *)0;
// cmds
// file src/cli.c line 120
static struct cmd cmds[6l];
// cmds
// file src/cli.c line 120
static struct cmd cmds[6l] = { { .name="help", .descr="this help text", .cb=cli_help },
    { .name="run", .descr="run an application (-fnr implied)", .cb=cli_run },
    { .name="build", .descr="build an application", .cb=cli_build },
    { .name="clean", .descr="cleanup the build files", .cb=cli_clean },
    { .name="create", .descr="create a new application skeleton", .cb=cli_create },
    { .name=(const char *)(void *)0, .descr=(const char *)(void *)0, .cb=(void (*)(signed int, char **))(void *)0 } };
// command
// file src/cli.c line 196
static struct cmd *command = (struct cmd *)(void *)0;
// compiler
// file src/cli.c line 193
static char *compiler = "cc";
// config_data
// file src/cli.c line 159
static const char *config_data = "# Placeholder configuration\n\nbind\t\t127.0.0.1 8888\nload\t\t./%s.so\ntls_dhparam\tdh2048.pem\n\ndomain 127.0.0.1 {\n\tcertfile\tcert/server.crt\n\tcertkey\t\tcert/server.key\n\tstatic\t/\tpage\n}\n";
// config_file
// file src/config.c line 126
char *config_file = (char *)(void *)0;
// config_names
// file src/config.c line 81
static struct anonymous_23 config_names[40l];
// config_names
// file src/config.c line 81
static struct anonymous_23 config_names[40l] = { { .name="include", .configure=configure_include },
    { .name="bind", .configure=configure_bind },
    { .name="load", .configure=configure_load },
    { .name="static", .configure=configure_handler },
    { .name="dynamic", .configure=configure_handler },
    { .name="tls_version", .configure=configure_tls_version },
    { .name="tls_cipher", .configure=configure_tls_cipher },
    { .name="tls_dhparam", .configure=configure_tls_dhparam },
    { .name="spdy_idle_time", .configure=configure_spdy_idle_time },
    { .name="domain", .configure=configure_domain },
    { .name="chroot", .configure=configure_chroot },
    { .name="runas", .configure=configure_runas },
    { .name="workers", .configure=configure_workers },
    { .name="worker_max_connections", .configure=configure_max_connections },
    { .name="worker_rlimit_nofiles", .configure=configure_rlimit_nofiles },
    { .name="worker_accept_threshold", .configure=configure_accept_threshold },
    { .name="worker_set_affinity", .configure=configure_set_affinity },
    { .name="pidfile", .configure=configure_pidfile },
    { .name="accesslog", .configure=configure_accesslog },
    { .name="certfile", .configure=configure_certfile },
    { .name="certkey", .configure=configure_certkey },
    { .name="client_certificates", .configure=configure_client_certificates },
    { .name="http_header_max", .configure=configure_http_header_max },
    { .name="http_body_max", .configure=configure_http_body_max },
    { .name="http_hsts_enable", .configure=configure_http_hsts_enable },
    { .name="http_keepalive_time", .configure=configure_http_keepalive_time },
    { .name="http_request_limit", .configure=configure_http_request_limit },
    { .name="validator", .configure=configure_validator },
    { .name="params", .configure=configure_params },
    { .name="validate", .configure=configure_validate },
    { .name="authentication", .configure=configure_authentication },
    { .name="authentication_uri", .configure=configure_authentication_uri },
    { .name="authentication_type", .configure=configure_authentication_type },
    { .name="authentication_value", .configure=configure_authentication_value },
    { .name="authentication_validator", .configure=configure_authentication_validator },
    { .name="websocket_maxframe", .configure=configure_websocket_maxframe },
    { .name="websocket_timeout", .configure=configure_websocket_timeout },
    { .name="socket_backlog", .configure=configure_socket_backlog },
    { .name="pgsql_conn_max", .configure=configure_pgsql_conn_max },
    { .name=(const char *)(void *)0, .configure=(signed int (*)(char **))(void *)0 } };
// connection_pool
// file src/connection.c line 27
struct kore_pool connection_pool;
// cpu_count
// file src/kore.c line 31
unsigned short int cpu_count = (unsigned short int)1;
// current_auth
// file src/config.c line 128
static struct kore_auth *current_auth = (struct kore_auth *)(void *)0;
// current_domain
// file src/config.c line 129
static struct kore_domain *current_domain = (struct kore_domain *)(void *)0;
// current_handler
// file src/config.c line 130
static struct kore_module_handle *current_handler = (struct kore_module_handle *)(void *)0;
// current_method
// file src/config.c line 127
static unsigned char current_method = (unsigned char)0;
// dh2048_data
// file src/cli.c line 177
static const char *dh2048_data = "-----BEGIN DH PARAMETERS-----\nMIIBCAKCAQEAn4f4Qn5SudFjEYPWTbUaOTLUH85YWmmPFW1+b5bRa9ygr+1wfamv\nVKVT7jO8c4msSNikUf6eEfoH0H4VTCaj+Habwu+Sj+I416r3mliMD4SjNsUJrBrY\nY0QV3ZUgZz4A8ARk/WwQcRl8+ZXJz34IaLwAcpyNhoV46iHVxW0ty8ND0U4DIku/\nPNayKimu4BXWXk4RfwNVP59t8DQKqjshZ4fDnbotskmSZ+e+FHrd+Kvrq/WButvV\nBzy9fYgnUlJ82g/bziCI83R2xAdtH014fR63MpElkqdNeChb94pPbEdFlNUvYIBN\nxx2vTUQMqRbB4UdG2zuzzr5j98HDdblQ+wIBAg==\n-----END DH PARAMETERS-----";
// disconnected
// file src/worker.c line 63
static struct connection_list disconnected;
// domains
// file src/domain.c line 23
struct kore_domain_h domains;
// efd
// file src/linux.c line 32
static signed int efd = -1;
// event_count
// file src/linux.c line 33
static unsigned int event_count = (unsigned int)0;
// events
// file src/linux.c line 34
static struct epoll_event *events = (struct epoll_event *)(void *)0;
// foreground
// file src/kore.c line 32
signed int foreground = 0;
// gen_dirs
// file src/cli.c line 136
static const char *gen_dirs[5l] = { "src", "cert", "conf", "assets", (const char *)(void *)0 };
// gen_files
// file src/cli.c line 129
static struct filegen gen_files[4l];
// gen_files
// file src/cli.c line 129
static struct filegen gen_files[4l] = { { .cb=file_create_src }, { .cb=file_create_config }, { .cb=file_create_gitignore }, { .cb=(void (*)(void))(void *)0 } };
// gitignore_data
// file src/cli.c line 188
static const char *gitignore_data = "*.o\n.objs\n%s.so\nassets.h\ncert\n";
// header_buf
// file src/http.c line 47
static struct kore_buf *header_buf;
// http_body_max
// file src/http.c line 63
unsigned long int http_body_max = (unsigned long int)10240000;
// http_header_max
// file src/http.c line 61
unsigned short int http_header_max = (unsigned short int)4096;
// http_header_pool
// file src/http.c line 54
static struct kore_pool http_header_pool;
// http_host_pool
// file src/http.c line 55
static struct kore_pool http_host_pool;
// http_hsts_enable
// file src/http.c line 60
unsigned long int http_hsts_enable = (unsigned long int)31536000;
// http_keepalive_time
// file src/http.c line 62
unsigned short int http_keepalive_time = (unsigned short int)20;
// http_path_pool
// file src/http.c line 56
static struct kore_pool http_path_pool;
// http_request_count
// file src/http.c line 58
signed int http_request_count = 0;
// http_request_limit
// file src/http.c line 59
unsigned int http_request_limit = (unsigned int)1000;
// http_request_pool
// file src/http.c line 53
static struct kore_pool http_request_pool;
// http_requests
// file src/http.c line 51
static struct anonymous_38 http_requests;
// http_requests_sleeping
// file src/http.c line 52
static struct anonymous_38 http_requests_sleeping;
// http_version
// file src/http.c line 48
static char http_version[32l];
// http_version_len
// file src/http.c line 49
static unsigned short int http_version_len;
// http_version_spdy
// file src/http.c line 50
static char http_version_spdy[32l];
// kore_debug
// file src/kore.c line 33
signed int kore_debug = 0;
// kore_pid
// file src/kore.c line 30
signed int kore_pid = -1;
// kore_pidfile
// file src/kore.c line 40
char *kore_pidfile = "kore.pid";
// kore_socket_backlog
// file src/kore.c line 39
unsigned int kore_socket_backlog = (unsigned int)5000;
// kore_timers
// file src/timer.c line 22
struct timerlist kore_timers;
// kore_tls_cipher_list
// file src/kore.c line 41
char *kore_tls_cipher_list = "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK:!kRSA:!kDSA";
// kore_websocket_maxframe
// file src/websocket.c line 45
unsigned long int kore_websocket_maxframe = (unsigned long int)16384;
// kore_websocket_timeout
// file src/websocket.c line 44
unsigned long int kore_websocket_timeout = (unsigned long int)120000;
// kore_workers
// file src/worker.c line 64
static struct kore_worker *kore_workers;
// listeners
// file src/kore.c line 28
struct listener_head listeners;
// modules
// file src/module.c line 23
static struct anonymous_55 modules;
// month_names
// file src/utils.c line 26
static struct anonymous_63 month_names[13l] = { { .name="Jan", .value=0 }, { .name="Feb", .value=1 }, { .name="Mar", .value=2 }, { .name="Apr", .value=3 }, { .name="May", .value=4 }, { .name="Jun", .value=5 }, { .name="Jul", .value=6 }, { .name="Aug", .value=7 }, { .name="Sep", .value=8 }, { .name="Oct", .value=9 }, { .name="Nov", .value=10 }, { .name="Dec", .value=11 }, { .name=(char *)(void *)0, .value=0 } };
// nb_pool
// file src/net.c line 31
struct kore_pool nb_pool;
// nlisteners
// file src/kore.c line 29
unsigned char nlisteners;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pgsql_conn_count
// file src/pgsql.c line 60
static unsigned short int pgsql_conn_count;
// pgsql_conn_free
// file src/pgsql.c line 58
static struct anonymous_2 pgsql_conn_free;
// pgsql_conn_max
// file src/pgsql.c line 62
unsigned short int pgsql_conn_max = (unsigned short int)2;
// pgsql_conn_string
// file src/pgsql.c line 61
char *pgsql_conn_string = (char *)(void *)0;
// pgsql_job_pool
// file src/pgsql.c line 56
static struct kore_pool pgsql_job_pool;
// pgsql_wait_pool
// file src/pgsql.c line 57
static struct kore_pool pgsql_wait_pool;
// pgsql_wait_queue
// file src/pgsql.c line 59
static struct anonymous_3 pgsql_wait_queue;
// primary_dom
// file src/domain.c line 24
struct kore_domain *primary_dom = (struct kore_domain *)(void *)0;
// rootdir
// file src/cli.c line 192
static char *rootdir = (char *)(void *)0;
// runas_user
// file src/kore.c line 38
char *runas_user = (char *)(void *)0;
// s_fd
// file src/cli.c line 190
static signed int s_fd = -1;
// shm_accept_key
// file src/worker.c line 65
static signed int shm_accept_key;
// sig_recv
// file src/kore.c line 26
volatile signed int sig_recv;
// skip_chroot
// file src/kore.c line 35
signed int skip_chroot = 0;
// skip_runas
// file src/kore.c line 37
signed int skip_runas = 0;
// source_files
// file src/cli.c line 194
static struct cfile_list source_files;
// spdy_idle_time
// file src/spdy.c line 41
unsigned long int spdy_idle_time = (unsigned long int)120000;
// spdy_recv_wsize
// file src/spdy.c line 42
unsigned int spdy_recv_wsize = (unsigned int)65536;
// src_data
// file src/cli.c line 146
static const char *src_data = "#include <kore/kore.h>\n#include <kore/http.h>\n\nint\t\tpage(struct http_request *);\n\nint\npage(struct http_request *req)\n{\n\thttp_response(req, 200, NULL, 0);\n\treturn (KORE_RESULT_OK);\n}\n";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// task_thread_lock
// file src/tasks.c line 30
static union anonymous_5 task_thread_lock;
// task_threads
// file src/tasks.c line 32
static struct anonymous_6 task_threads;
// threads
// file src/tasks.c line 29
static unsigned char threads;
// tls_dhparam
// file src/domain.c line 25
struct dh_st *tls_dhparam = (struct dh_st *)(void *)0;
// tls_version
// file src/domain.c line 26
signed int tls_version = 0;
// validators
// file src/validator.c line 19
struct anonymous_62 validators;
// worker
// file src/worker.c line 69
struct kore_worker *worker = (struct kore_worker *)(void *)0;
// worker_accept_threshold
// file src/worker.c line 72
unsigned int worker_accept_threshold = (unsigned int)0;
// worker_active_connections
// file src/worker.c line 75
unsigned int worker_active_connections = (unsigned int)0;
// worker_clients
// file src/worker.c line 70
struct connection_list worker_clients;
// worker_count
// file src/kore.c line 34
unsigned char worker_count = (unsigned char)0;
// worker_max_connections
// file src/worker.c line 74
unsigned int worker_max_connections = (unsigned int)250;
// worker_rlimit_nofiles
// file src/worker.c line 73
unsigned int worker_rlimit_nofiles = (unsigned int)1024;
// worker_set_affinity
// file src/worker.c line 71
unsigned char worker_set_affinity = (unsigned char)1;

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64_1;
  return_value___builtin_bswap64_1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64_1;
}

// cli_add_cfile
// file src/cli.c line 676
static void cli_add_cfile(char *name, char *fpath, char *opath, struct stat *st, signed int build, signed int cpp)
{
  struct cfile *cf;
  cfiles_count = cfiles_count + 1;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct cfile) /*192ul*/ );
  cf = (struct cfile *)return_value_kore_malloc_1;
  cf->st = *st;
  cf->build = build;
  cf->cpp = cpp;
  cf->fpath = fpath;
  cf->opath = opath;
  cf->name=kore_strdup(name);
  do
  {
    cf->list.tqe_next = (struct cfile *)(void *)0;
    cf->list.tqe_prev = (&source_files)->tqh_last;
    *(&source_files)->tqh_last = cf;
    (&source_files)->tqh_last = &cf->list.tqe_next;
  }
  while((_Bool)0);
}

// cli_build
// file src/cli.c line 286
static void cli_build(signed int argc, char **argv)
{
  struct cfile *cf;
  struct timeval times[2l];
  signed int requires_relink;
  char pwd[4096l];
  char *src_path;
  char *assets_header;
  char *assets_path;
  char *p;
  char *obj_path;
  char *cpath;
  char *config;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(argc == 0)
  {
    char *return_value_getcwd_3;
    return_value_getcwd_3=getcwd(pwd, sizeof(char [4096l]) /*4096ul*/ );
    if(return_value_getcwd_3 == ((char *)NULL))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      cli_fatal("could not get cwd: %s", return_value_strerror_2);
    }

    rootdir = ".";
    appl=__xpg_basename(pwd);
  }

  else
  {
    appl = argv[(signed long int)0];
    rootdir = appl;
  }
  p=getenv("CC");
  if(!(p == ((char *)NULL)))
    compiler = p;

  cfiles_count = 0;
  do
  {
    (&source_files)->tqh_first = (struct cfile *)(void *)0;
    (&source_files)->tqh_last = &(&source_files)->tqh_first;
  }
  while((_Bool)0);
  cli_vasprintf(&src_path, "%s/src", rootdir);
  cli_vasprintf(&assets_path, "%s/assets", rootdir);
  cli_vasprintf(&config, "%s/conf/%s.conf", rootdir, appl);
  cli_vasprintf(&assets_header, "%s/src/assets.h", rootdir);
  signed int return_value_cli_dir_exists_4;
  return_value_cli_dir_exists_4=cli_dir_exists(src_path);
  _Bool tmp_if_expr_6;
  signed int return_value_cli_file_exists_5;
  if(return_value_cli_dir_exists_4 == 0)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_cli_file_exists_5=cli_file_exists(config);
    tmp_if_expr_6 = !(return_value_cli_file_exists_5 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
    cli_fatal("%s doesn't appear to be a kore app", appl);

  free((void *)config);
  cli_vasprintf(&obj_path, "%s/.objs", rootdir);
  signed int return_value_cli_dir_exists_7;
  return_value_cli_dir_exists_7=cli_dir_exists(obj_path);
  if(return_value_cli_dir_exists_7 == 0)
    cli_mkdir(obj_path, 0755);

  free((void *)obj_path);
  unlink(assets_header);
  signed int return_value_cli_dir_exists_8;
  return_value_cli_dir_exists_8=cli_dir_exists(assets_path);
  if(!(return_value_cli_dir_exists_8 == 0))
  {
    cli_file_open(assets_header, 0100 | 01000 | 01, &s_fd);
    cli_file_writef(s_fd, "#ifndef __H_KORE_ASSETS_H\n");
    cli_file_writef(s_fd, "#define __H_KORE_ASSETS_H\n");
    cli_find_files(assets_path, cli_build_asset);
    cli_file_writef(s_fd, "\n#endif\n");
    cli_file_close(s_fd);
  }

  free((void *)assets_path);
  cli_find_files(src_path, cli_register_cfile);
  free((void *)src_path);
  requires_relink = 0;
  cf = (&source_files)->tqh_first;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  for( ; !(cf == ((struct cfile *)NULL)); cf = cf->list.tqe_next)
    if(!(cf->build == 0))
    {
      printf("compiling %s\n", cf->name);
      cli_spawn_proc(cli_compile_cfile, (void *)cf);
      times[(signed long int)0].tv_usec = (signed long int)0;
      times[(signed long int)0].tv_sec = cf->st.st_mtim.tv_sec;
      times[(signed long int)1] = times[(signed long int)0];
      signed int return_value_utimes_11;
      return_value_utimes_11=utimes(cf->opath, times);
      if(return_value_utimes_11 == -1)
      {
        return_value___errno_location_9=__errno_location();
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        printf("utime(%s): %s\n", cf->opath, return_value_strerror_10);
      }

      requires_relink = requires_relink + 1;
    }

  unlink(assets_header);
  free((void *)assets_header);
  cli_vasprintf(&cpath, "%s/cert", rootdir);
  signed int return_value_cli_dir_exists_12;
  return_value_cli_dir_exists_12=cli_dir_exists(cpath);
  if(return_value_cli_dir_exists_12 == 0)
  {
    cli_mkdir(cpath, 0700);
    cli_generate_certs();
  }

  free((void *)cpath);
  if(!(requires_relink == 0))
  {
    cli_spawn_proc(cli_link_library, (void *)0);
    printf("%s built successfully!\n", appl);
  }

  else
    printf("nothing to be done\n");
}

// cli_build_asset
// file src/cli.c line 578
static void cli_build_asset(char *fpath, struct dirent *dp)
{
  struct stat st;
  unsigned char *d;
  signed long int off;
  void *base;
  signed int in;
  signed int out;
  char *cpath;
  char *ext;
  char *opath;
  char *p;
  char *name;
  name=kore_strdup(dp->d_name);
  ext=strrchr(name, 46);
  if(ext == ((char *)NULL))
    cli_fatal("couldn't find ext in %s", name);

  p = name;
  _Bool tmp_if_expr_2;
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_3;
  for( ; !((signed int)*p == 0); p = p + 1l)
  {
    if((signed int)*p == 46)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      tmp_if_expr_2 = ((signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*p == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      *p = (char)95;

  }
  signed int return_value_stat_6;
  return_value_stat_6=stat(fpath, &st);
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(return_value_stat_6 == -1)
  {
    return_value___errno_location_4=__errno_location();
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    cli_fatal("stat: %s %s", fpath, return_value_strerror_5);
  }

  cli_vasprintf(&opath, "%s/.objs/%s.o", rootdir, name);
  cli_vasprintf(&cpath, "%s/.objs/%s.c", rootdir, name);
  signed int return_value_cli_file_requires_build_8;
  return_value_cli_file_requires_build_8=cli_file_requires_build(&st, opath);
  char *tmp_post_7;
  signed int *return_value___errno_location_9;
  char *return_value_strerror_10;
  char *tmp_post_11;
  unsigned char *tmp_post_12;
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  if(return_value_cli_file_requires_build_8 == 0)
  {
    tmp_post_7 = ext;
    ext = ext + 1l;
    *tmp_post_7 = (char)0;
    cli_write_asset(name, ext);
    *ext = (char)95;
    cli_add_cfile(name, cpath, opath, &st, 0, 0);
    kore_mem_free((void *)name);
  }

  else
  {
    cli_file_open(fpath, 00, &in);
    base=mmap((void *)0, (unsigned long int)st.st_size, 0x1, 0x02, in, (signed long int)0);
    if(base == (void *)-1)
    {
      return_value___errno_location_9=__errno_location();
      return_value_strerror_10=strerror(*return_value___errno_location_9);
      cli_fatal("mmap: %s %s", fpath, return_value_strerror_10);
    }

    cli_file_open(cpath, 0100 | 01000 | 01, &out);
    printf("building asset %s\n", (const void *)dp->d_name);
    tmp_post_11 = ext;
    ext = ext + 1l;
    *tmp_post_11 = (char)0;
    cli_file_writef(out, "/* Auto generated */\n");
    cli_file_writef(out, "#include <sys/param.h>\n\n");
    cli_file_writef(out, "u_int8_t asset_%s_%s[] = {\n", name, ext);
    d = (unsigned char *)base;
    off = (signed long int)0;
    for( ; !(off >= st.st_size); off = off + 1l)
    {
      tmp_post_12 = d;
      d = d + 1l;
      cli_file_writef(out, "0x%02x,", *tmp_post_12);
    }
    cli_file_writef(out, "0x00");
    cli_file_writef(out, "};\n\n");
    cli_file_writef(out, "u_int32_t asset_len_%s_%s = %u;\n", name, ext, (unsigned int)st.st_size);
    cli_file_writef(out, "time_t asset_mtime_%s_%s = %lu;\n", name, ext, st.st_mtim.tv_sec);
    cli_write_asset(name, ext);
    signed int return_value_munmap_15;
    return_value_munmap_15=munmap(base, (unsigned long int)st.st_size);
    if(return_value_munmap_15 == -1)
    {
      return_value___errno_location_13=__errno_location();
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      cli_fatal("munmap: %s %s", fpath, return_value_strerror_14);
    }

    cli_file_close(in);
    cli_file_close(out);
    ext = ext - 1l;
    *ext = (char)46;
    cli_add_cfile(name, cpath, opath, &st, 1, 0);
    kore_mem_free((void *)name);
  }
}

// cli_clean
// file src/cli.c line 383
static void cli_clean(signed int argc, char **argv)
{
  char pwd[4096l];
  char *sofile;
  signed int return_value_cli_dir_exists_1;
  return_value_cli_dir_exists_1=cli_dir_exists(".objs");
  if(!(return_value_cli_dir_exists_1 == 0))
    cli_cleanup_files(".objs");

  char *return_value_getcwd_4;
  return_value_getcwd_4=getcwd(pwd, sizeof(char [4096l]) /*4096ul*/ );
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(return_value_getcwd_4 == ((char *)NULL))
  {
    return_value___errno_location_2=__errno_location();
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    cli_fatal("could not get cwd: %s", return_value_strerror_3);
  }

  appl=__xpg_basename(pwd);
  cli_vasprintf(&sofile, "%s.so", appl);
  signed int return_value_unlink_8;
  return_value_unlink_8=unlink(sofile);
  signed int *return_value___errno_location_7;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(return_value_unlink_8 == -1)
  {
    return_value___errno_location_7=__errno_location();
    if(!(*return_value___errno_location_7 == 2))
    {
      return_value___errno_location_5=__errno_location();
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      printf("couldn't unlink %s: %s", sofile, return_value_strerror_6);
    }

  }

  free((void *)sofile);
}

// cli_cleanup_files
// file src/cli.c line 1043
static void cli_cleanup_files(const char *spath)
{
  cli_find_files(spath, cli_file_remove);
  signed int return_value_rmdir_2;
  return_value_rmdir_2=rmdir(spath);
  signed int *return_value___errno_location_1;
  if(return_value_rmdir_2 == -1)
  {
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      printf("couldn't rmdir %s\n", spath);

  }

}

// cli_compile_cfile
// file src/cli.c line 869
static void cli_compile_cfile(void *arg)
{
  signed int idx;
  struct cfile *cf = (struct cfile *)arg;
  char *args[24l];
  char *ipath[2l];
  char *p;
  char *cppstandard;
  char *ppath;
  cli_vasprintf(&ipath[(signed long int)0], "-I%s/src", rootdir);
  cli_vasprintf(&ipath[(signed long int)1], "-I%s/src/includes", rootdir);
  idx = 0;
  signed int tmp_post_1 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_1] = compiler;
  signed int tmp_post_2 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_2] = ipath[(signed long int)0];
  signed int tmp_post_3 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_3] = ipath[(signed long int)1];
  signed int tmp_post_4 = idx;
  idx = idx + 1;
  cli_vasprintf(&args[(signed long int)tmp_post_4], "-I%s/include", (const void *)"/usr");
  cli_vasprintf(&ppath, "-I%s", (const void *)"/usr/include/postgresql");
  signed int tmp_post_5 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_5] = ppath;
  signed int tmp_post_6 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_6] = "-Wall";
  signed int tmp_post_7 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_7] = "-Wmissing-declarations";
  signed int tmp_post_8 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_8] = "-Wshadow";
  signed int tmp_post_9 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_9] = "-Wpointer-arith";
  signed int tmp_post_10 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_10] = "-Wcast-qual";
  signed int tmp_post_11 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_11] = "-Wsign-compare";
  signed int tmp_post_12 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_12] = "-fPIC";
  signed int tmp_post_13 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_13] = "-g";
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  signed int tmp_post_17;
  signed int tmp_post_18;
  signed int tmp_post_19;
  if(!(cf->cpp == 0))
  {
    tmp_post_14 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_14] = "-Woverloaded-virtual";
    tmp_post_15 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_15] = "-Wold-style-cast";
    tmp_post_16 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_16] = "-Wnon-virtual-dtor";
    p=getenv("CXXSTD");
    if(!(p == ((char *)NULL)))
    {
      cli_vasprintf(&cppstandard, "-std=%s", p);
      tmp_post_17 = idx;
      idx = idx + 1;
      args[(signed long int)tmp_post_17] = cppstandard;
    }

  }

  else
  {
    tmp_post_18 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_18] = "-Wstrict-prototypes";
    tmp_post_19 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_19] = "-Wmissing-prototypes";
  }
  signed int tmp_post_20 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_20] = "-c";
  signed int tmp_post_21 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_21] = cf->fpath;
  signed int tmp_post_22 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_22] = "-o";
  signed int tmp_post_23 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_23] = cf->opath;
  args[(signed long int)idx] = (char *)(void *)0;
  execvp(compiler, args);
}

// cli_create
// file src/cli.c line 255
static void cli_create(signed int argc, char **argv)
{
  signed int i;
  char *fpath;
  if(!(argc == 1))
    cli_fatal("missing application name");

  appl = argv[(signed long int)0];
  cli_mkdir(appl, 0755);
  rootdir = appl;
  i = 0;
  for( ; !(gen_dirs[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    cli_vasprintf(&fpath, "%s/%s", appl, gen_dirs[(signed long int)i]);
    cli_mkdir(fpath, 0755);
    free((void *)fpath);
  }
  i = 0;
  if(!(gen_files[(signed long int)i].cb == ((void (*)(void))NULL)))
  {
    gen_files[(signed long int)i].cb();
    i = i + 1;
  }

  cli_generate_certs();
  printf("%s created successfully!\n", appl);
  printf("note: do NOT use the created DH parameters/certificates in production\n");
}

// cli_dir_exists
// file src/cli.c line 487
static signed int cli_dir_exists(const char *fpath)
{
  struct stat st;
  signed int return_value_stat_1;
  return_value_stat_1=stat(fpath, &st);
  if(return_value_stat_1 == -1)
    return 0;

  else
    if(!((61440u & st.st_mode) == 16384u))
      return 0;

    else
      return 1;
}

// cli_fatal
// file src/cli.c line 1052
static void cli_fatal(const char *fmt, ...)
{
  void **args;
  char buf[2048l];
  args = (void **)&fmt;
  vsnprintf(buf, sizeof(char [2048l]) /*2048ul*/ , fmt, args);
  args = ((void **)NULL);
  if(!(command == ((struct cmd *)NULL)))
    printf("kore %s: %s\n", command->name, (const void *)buf);

  else
    printf("kore: %s\n", (const void *)buf);
  exit(1);
}

// cli_file_close
// file src/cli.c line 508
static void cli_file_close(signed int fd)
{
  signed int return_value_close_3;
  return_value_close_3=close(fd);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_close_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    printf("warning: close() %s\n", return_value_strerror_2);
  }

}

// cli_file_create
// file src/cli.c line 554
static void cli_file_create(const char *name, const char *data, unsigned long int len)
{
  signed int fd;
  char *fpath;
  cli_vasprintf(&fpath, "%s/%s", rootdir, name);
  cli_file_open(fpath, 0100 | 01000 | 01, &fd);
  cli_file_write(fd, (const void *)data, len);
  cli_file_close(fd);
  printf("created %s\n", fpath);
  free((void *)fpath);
}

// cli_file_exists
// file src/cli.c line 459
static signed int cli_file_exists(const char *fpath)
{
  struct stat st;
  signed int return_value_stat_1;
  return_value_stat_1=stat(fpath, &st);
  if(return_value_stat_1 == -1)
    return 0;

  else
    if(!((61440u & st.st_mode) == 32768u))
      return 0;

    else
      return 1;
}

// cli_file_open
// file src/cli.c line 501
static void cli_file_open(const char *fpath, signed int flags, signed int *fd)
{
  *fd=open(fpath, flags, 0644);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(*fd == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    cli_fatal("cli_file_open(%s): %s", fpath, return_value_strerror_2);
  }

}

// cli_file_remove
// file src/cli.c line 723
static void cli_file_remove(char *fpath, struct dirent *dp)
{
  signed int return_value_unlink_3;
  return_value_unlink_3=unlink(fpath);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_unlink_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "couldn't unlink %s: %s", fpath, return_value_strerror_2);
  }

}

// cli_file_requires_build
// file src/cli.c line 473
static signed int cli_file_requires_build(struct stat *fst, const char *opath)
{
  struct stat ost;
  signed int return_value_stat_4;
  return_value_stat_4=stat(opath, &ost);
  if(return_value_stat_4 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 2)
      return 1;

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    cli_fatal("stat(%s): %s", opath, return_value_strerror_3);
  }

  return (signed int)(fst->st_mtim.tv_sec != ost.st_mtim.tv_sec);
}

// cli_file_write
// file src/cli.c line 533
static void cli_file_write(signed int fd, const void *buf, unsigned long int len)
{
  signed long int r;
  const unsigned char *d;
  unsigned long int written;
  d = (const unsigned char *)buf;
  written = (unsigned long int)0;
  while(!(written == len))
  {
    r=write(fd, (const void *)(d + (signed long int)written), len - written);
    if(r == -1l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      cli_fatal("cli_file_write: %s", return_value_strerror_3);
    }

    written = written + (unsigned long int)r;
  }
}

// cli_file_writef
// file src/cli.c line 515
static void cli_file_writef(signed int fd, const char *fmt, ...)
{
  signed int l;
  char *buf;
  void **args = (void **)&fmt;
  l=vasprintf(&buf, fmt, args);
  args = ((void **)NULL);
  if(l == -1)
    cli_fatal("cli_file_writef");

  cli_file_write(fd, (const void *)buf, (unsigned long int)l);
  free((void *)buf);
}

// cli_find_files
// file src/cli.c line 730
static void cli_find_files(const char *path, void (*cb)(char *, struct dirent *))
{
  struct __dirstream *d;
  struct stat st;
  struct dirent *dp;
  char *fpath;
  d=opendir(path);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(d == ((struct __dirstream *)NULL))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    cli_fatal("cli_find_files: opendir(%s): %s", path, return_value_strerror_2);
  }

  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  do
  {
    dp=readdir(d);
    if(dp == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(dp->d_name, ".");
    if(return_value_strcmp_3 == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(dp->d_name, "..");
      tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_5)
    {
      cli_vasprintf(&fpath, "%s/%s", path, (const void *)dp->d_name);
      signed int return_value_stat_8;
      return_value_stat_8=stat(fpath, &st);
      if(return_value_stat_8 == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, "stat(%s): %s\n", fpath, return_value_strerror_7);
        free((void *)fpath);
        continue;
      }

      if((61440u & st.st_mode) == 16384u)
      {
        cli_find_files(fpath, cb);
        free((void *)fpath);
      }

      else
        if((61440u & st.st_mode) == 32768u)
          cb(fpath, dp);

        else
        {
          fprintf(stderr, "ignoring %s\n", fpath);
          free((void *)fpath);
        }
    }

  }
  while((_Bool)1);
  closedir(d);
}

// cli_generate_certs
// file src/cli.c line 767
static void cli_generate_certs(void)
{
  struct bignum_st *e;
  struct _IO_FILE *fp;
  signed long int now;
  struct X509_name_st *name;
  struct evp_pkey_st *pkey;
  struct x509_st *x509;
  struct rsa_st *kpair;
  char *fpath;
  char issuer[64l];
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(dh2048_data);
  cli_file_create("dh2048.pem", dh2048_data, return_value_strlen_1);
  x509=X509_new();
  unsigned long int return_value_ERR_get_error_2;
  char *return_value_ERR_error_string_3;
  if(x509 == ((struct x509_st *)NULL))
  {
    return_value_ERR_get_error_2=ERR_get_error();
    return_value_ERR_error_string_3=ERR_error_string(return_value_ERR_get_error_2, (char *)(void *)0);
    cli_fatal("X509_new(): %s", return_value_ERR_error_string_3);
  }

  signed int return_value_X509_set_version_6;
  return_value_X509_set_version_6=X509_set_version(x509, (signed long int)2);
  unsigned long int return_value_ERR_get_error_4;
  char *return_value_ERR_error_string_5;
  if(return_value_X509_set_version_6 == 0)
  {
    return_value_ERR_get_error_4=ERR_get_error();
    return_value_ERR_error_string_5=ERR_error_string(return_value_ERR_get_error_4, (char *)(void *)0);
    cli_fatal("X509_set_version(): %s", return_value_ERR_error_string_5);
  }

  pkey=EVP_PKEY_new();
  unsigned long int return_value_ERR_get_error_7;
  char *return_value_ERR_error_string_8;
  if(pkey == ((struct evp_pkey_st *)NULL))
  {
    return_value_ERR_get_error_7=ERR_get_error();
    return_value_ERR_error_string_8=ERR_error_string(return_value_ERR_get_error_7, (char *)(void *)0);
    cli_fatal("EVP_PKEY_new(): %s", return_value_ERR_error_string_8);
  }

  kpair=RSA_new();
  unsigned long int return_value_ERR_get_error_9;
  char *return_value_ERR_error_string_10;
  if(kpair == ((struct rsa_st *)NULL))
  {
    return_value_ERR_get_error_9=ERR_get_error();
    return_value_ERR_error_string_10=ERR_error_string(return_value_ERR_get_error_9, (char *)(void *)0);
    cli_fatal("RSA_new(): %s", return_value_ERR_error_string_10);
  }

  e=BN_new();
  unsigned long int return_value_ERR_get_error_11;
  char *return_value_ERR_error_string_12;
  if(e == ((struct bignum_st *)NULL))
  {
    return_value_ERR_get_error_11=ERR_get_error();
    return_value_ERR_error_string_12=ERR_error_string(return_value_ERR_get_error_11, (char *)(void *)0);
    cli_fatal("BN_new(): %s", return_value_ERR_error_string_12);
  }

  signed int return_value_BN_set_word_15;
  return_value_BN_set_word_15=BN_set_word(e, (unsigned long int)65537);
  unsigned long int return_value_ERR_get_error_13;
  char *return_value_ERR_error_string_14;
  if(return_value_BN_set_word_15 == 0)
  {
    return_value_ERR_get_error_13=ERR_get_error();
    return_value_ERR_error_string_14=ERR_error_string(return_value_ERR_get_error_13, (char *)(void *)0);
    cli_fatal("BN_set_word(): %s", return_value_ERR_error_string_14);
  }

  signed int return_value_RSA_generate_key_ex_18;
  return_value_RSA_generate_key_ex_18=RSA_generate_key_ex(kpair, 2048, e, (struct bn_gencb_st *)(void *)0);
  unsigned long int return_value_ERR_get_error_16;
  char *return_value_ERR_error_string_17;
  if(return_value_RSA_generate_key_ex_18 == 0)
  {
    return_value_ERR_get_error_16=ERR_get_error();
    return_value_ERR_error_string_17=ERR_error_string(return_value_ERR_get_error_16, (char *)(void *)0);
    cli_fatal("RSA_generate_key_ex(): %s", return_value_ERR_error_string_17);
  }

  BN_free(e);
  signed int return_value_EVP_PKEY_assign_21;
  return_value_EVP_PKEY_assign_21=EVP_PKEY_assign(pkey, 6, (void *)(char *)kpair);
  unsigned long int return_value_ERR_get_error_19;
  char *return_value_ERR_error_string_20;
  if(return_value_EVP_PKEY_assign_21 == 0)
  {
    return_value_ERR_get_error_19=ERR_get_error();
    return_value_ERR_error_string_20=ERR_error_string(return_value_ERR_get_error_19, (char *)(void *)0);
    cli_fatal("EVP_PKEY_assign_RSA(): %s", return_value_ERR_error_string_20);
  }

  time(&now);
  struct asn1_string_st *return_value_X509_get_serialNumber_24;
  return_value_X509_get_serialNumber_24=X509_get_serialNumber(x509);
  signed int return_value_ASN1_INTEGER_set_25;
  return_value_ASN1_INTEGER_set_25=ASN1_INTEGER_set(return_value_X509_get_serialNumber_24, now);
  unsigned long int return_value_ERR_get_error_22;
  char *return_value_ERR_error_string_23;
  if(return_value_ASN1_INTEGER_set_25 == 0)
  {
    return_value_ERR_get_error_22=ERR_get_error();
    return_value_ERR_error_string_23=ERR_error_string(return_value_ERR_get_error_22, (char *)(void *)0);
    cli_fatal("ASN1_INTEGER_set(): %s", return_value_ERR_error_string_23);
  }

  struct asn1_string_st *return_value_X509_gmtime_adj_28;
  return_value_X509_gmtime_adj_28=X509_gmtime_adj(x509->cert_info->validity->notBefore, (signed long int)0);
  unsigned long int return_value_ERR_get_error_26;
  char *return_value_ERR_error_string_27;
  if(return_value_X509_gmtime_adj_28 == ((struct asn1_string_st *)NULL))
  {
    return_value_ERR_get_error_26=ERR_get_error();
    return_value_ERR_error_string_27=ERR_error_string(return_value_ERR_get_error_26, (char *)(void *)0);
    cli_fatal("X509_gmtime_adj(): %s", return_value_ERR_error_string_27);
  }

  struct asn1_string_st *return_value_X509_gmtime_adj_31;
  return_value_X509_gmtime_adj_31=X509_gmtime_adj(x509->cert_info->validity->notAfter, (signed long int)60 * (signed long int)60 * (signed long int)24 * (signed long int)3000);
  unsigned long int return_value_ERR_get_error_29;
  char *return_value_ERR_error_string_30;
  if(return_value_X509_gmtime_adj_31 == ((struct asn1_string_st *)NULL))
  {
    return_value_ERR_get_error_29=ERR_get_error();
    return_value_ERR_error_string_30=ERR_error_string(return_value_ERR_get_error_29, (char *)(void *)0);
    cli_fatal("X509_gmtime_adj(): %s", return_value_ERR_error_string_30);
  }

  signed int return_value_X509_set_pubkey_34;
  return_value_X509_set_pubkey_34=X509_set_pubkey(x509, pkey);
  unsigned long int return_value_ERR_get_error_32;
  char *return_value_ERR_error_string_33;
  if(return_value_X509_set_pubkey_34 == 0)
  {
    return_value_ERR_get_error_32=ERR_get_error();
    return_value_ERR_error_string_33=ERR_error_string(return_value_ERR_get_error_32, (char *)(void *)0);
    cli_fatal("X509_set_pubkey(): %s", return_value_ERR_error_string_33);
  }

  name=X509_get_subject_name(x509);
  unsigned long int return_value_ERR_get_error_35;
  char *return_value_ERR_error_string_36;
  if(name == ((struct X509_name_st *)NULL))
  {
    return_value_ERR_get_error_35=ERR_get_error();
    return_value_ERR_error_string_36=ERR_error_string(return_value_ERR_get_error_35, (char *)(void *)0);
    cli_fatal("X509_get_subject_name(): %s", return_value_ERR_error_string_36);
  }

  snprintf(issuer, sizeof(char [64l]) /*64ul*/ , "kore autogen: %s", appl);
  signed int return_value_X509_NAME_add_entry_by_txt_39;
  return_value_X509_NAME_add_entry_by_txt_39=X509_NAME_add_entry_by_txt(name, "C", 0x1000 | 1, (const unsigned char *)"SE", -1, -1, 0);
  unsigned long int return_value_ERR_get_error_37;
  char *return_value_ERR_error_string_38;
  if(return_value_X509_NAME_add_entry_by_txt_39 == 0)
  {
    return_value_ERR_get_error_37=ERR_get_error();
    return_value_ERR_error_string_38=ERR_error_string(return_value_ERR_get_error_37, (char *)(void *)0);
    cli_fatal("X509_NAME_add_entry_by_txt(): C %s", return_value_ERR_error_string_38);
  }

  signed int return_value_X509_NAME_add_entry_by_txt_42;
  return_value_X509_NAME_add_entry_by_txt_42=X509_NAME_add_entry_by_txt(name, "O", 0x1000 | 1, (const unsigned char *)issuer, -1, -1, 0);
  unsigned long int return_value_ERR_get_error_40;
  char *return_value_ERR_error_string_41;
  if(return_value_X509_NAME_add_entry_by_txt_42 == 0)
  {
    return_value_ERR_get_error_40=ERR_get_error();
    return_value_ERR_error_string_41=ERR_error_string(return_value_ERR_get_error_40, (char *)(void *)0);
    cli_fatal("X509_NAME_add_entry_by_txt(): O %s", return_value_ERR_error_string_41);
  }

  signed int return_value_X509_NAME_add_entry_by_txt_45;
  return_value_X509_NAME_add_entry_by_txt_45=X509_NAME_add_entry_by_txt(name, "CN", 0x1000 | 1, (const unsigned char *)"localhost", -1, -1, 0);
  unsigned long int return_value_ERR_get_error_43;
  char *return_value_ERR_error_string_44;
  if(return_value_X509_NAME_add_entry_by_txt_45 == 0)
  {
    return_value_ERR_get_error_43=ERR_get_error();
    return_value_ERR_error_string_44=ERR_error_string(return_value_ERR_get_error_43, (char *)(void *)0);
    cli_fatal("X509_NAME_add_entry_by_txt(): CN %s", return_value_ERR_error_string_44);
  }

  signed int return_value_X509_set_issuer_name_48;
  return_value_X509_set_issuer_name_48=X509_set_issuer_name(x509, name);
  unsigned long int return_value_ERR_get_error_46;
  char *return_value_ERR_error_string_47;
  if(return_value_X509_set_issuer_name_48 == 0)
  {
    return_value_ERR_get_error_46=ERR_get_error();
    return_value_ERR_error_string_47=ERR_error_string(return_value_ERR_get_error_46, (char *)(void *)0);
    cli_fatal("X509_set_issuer_name(): %s", return_value_ERR_error_string_47);
  }

  const struct env_md_st *return_value_EVP_sha256_51;
  return_value_EVP_sha256_51=EVP_sha256();
  signed int return_value_X509_sign_52;
  return_value_X509_sign_52=X509_sign(x509, pkey, return_value_EVP_sha256_51);
  unsigned long int return_value_ERR_get_error_49;
  char *return_value_ERR_error_string_50;
  if(return_value_X509_sign_52 == 0)
  {
    return_value_ERR_get_error_49=ERR_get_error();
    return_value_ERR_error_string_50=ERR_error_string(return_value_ERR_get_error_49, (char *)(void *)0);
    cli_fatal("X509_sign(): %s", return_value_ERR_error_string_50);
  }

  cli_vasprintf(&fpath, "%s/cert/server.key", rootdir);
  fp=fopen(fpath, "w");
  signed int *return_value___errno_location_53;
  char *return_value_strerror_54;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location_53=__errno_location();
    return_value_strerror_54=strerror(*return_value___errno_location_53);
    cli_fatal("fopen(%s): %s", fpath, return_value_strerror_54);
  }

  free((void *)fpath);
  signed int return_value_PEM_write_PrivateKey_57;
  return_value_PEM_write_PrivateKey_57=PEM_write_PrivateKey(fp, pkey, (const struct evp_cipher_st *)(void *)0, (unsigned char *)(void *)0, 0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
  unsigned long int return_value_ERR_get_error_55;
  char *return_value_ERR_error_string_56;
  if(return_value_PEM_write_PrivateKey_57 == 0)
  {
    return_value_ERR_get_error_55=ERR_get_error();
    return_value_ERR_error_string_56=ERR_error_string(return_value_ERR_get_error_55, (char *)(void *)0);
    cli_fatal("PEM_write_PrivateKey(): %s", return_value_ERR_error_string_56);
  }

  fclose(fp);
  cli_vasprintf(&fpath, "%s/cert/server.crt", rootdir);
  fp=fopen(fpath, "w");
  signed int *return_value___errno_location_58;
  char *return_value_strerror_59;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    return_value___errno_location_58=__errno_location();
    return_value_strerror_59=strerror(*return_value___errno_location_58);
    cli_fatal("fopen(%s): %s", fpath, return_value_strerror_59);
  }

  free((void *)fpath);
  signed int return_value_PEM_write_X509_62;
  return_value_PEM_write_X509_62=PEM_write_X509(fp, x509);
  signed int *return_value___errno_location_60;
  char *return_value_strerror_61;
  if(return_value_PEM_write_X509_62 == 0)
  {
    return_value___errno_location_60=__errno_location();
    return_value_strerror_61=strerror(*return_value___errno_location_60);
    cli_fatal("PEM_write_X509(%s)", return_value_strerror_61);
  }

  fclose(fp);
  EVP_PKEY_free(pkey);
  X509_free(x509);
}

// cli_help
// file src/cli.c line 249
static void cli_help(signed int argc, char **argv)
{
  kore_cli_usage(1);
}

// cli_link_library
// file src/cli.c line 933
static void cli_link_library(void *arg)
{
  struct cfile *cf;
  signed int idx;
  signed int f;
  signed int i;
  signed int has_cpp;
  const signed long int has_cpp_array_size0 = (signed long int)(cfiles_count + 11 + 10);
  char *args[has_cpp_array_size0];
  char *p;
  char *libname;
  char *flags[10l];
  char *cpplib;
  p=getenv("LDFLAGS");
  if(!(p == ((char *)NULL)))
    f=kore_split_string(p, " ", flags, (unsigned long int)10);

  else
    f = 0;
  cli_vasprintf(&libname, "%s/%s.so", rootdir, appl);
  idx = 0;
  signed int tmp_post_1 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_1] = compiler;
  signed int tmp_post_2 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_2] = "-shared";
  has_cpp = 0;
  cf = (&source_files)->tqh_first;
  signed int tmp_post_3;
  for( ; !(cf == ((struct cfile *)NULL)); cf = cf->list.tqe_next)
  {
    if(!(cf->cpp == 0))
      has_cpp = 1;

    tmp_post_3 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_3] = cf->opath;
  }
  signed int tmp_post_4;
  signed int tmp_post_5;
  if(!(has_cpp == 0))
  {
    p=getenv("CXXLIB");
    if(!(p == ((char *)NULL)))
    {
      cli_vasprintf(&cpplib, "-l%s", p);
      tmp_post_4 = idx;
      idx = idx + 1;
      args[(signed long int)tmp_post_4] = cpplib;
    }

    else
    {
      tmp_post_5 = idx;
      idx = idx + 1;
      args[(signed long int)tmp_post_5] = "-lstdc++";
    }
  }

  i = 0;
  signed int tmp_post_6;
  for( ; !(i >= f); i = i + 1)
  {
    tmp_post_6 = idx;
    idx = idx + 1;
    args[(signed long int)tmp_post_6] = flags[(signed long int)i];
  }
  signed int tmp_post_7 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_7] = "-o";
  signed int tmp_post_8 = idx;
  idx = idx + 1;
  args[(signed long int)tmp_post_8] = libname;
  args[(signed long int)idx] = (char *)(void *)0;
  execvp(compiler, args);
}

// cli_mkdir
// file src/cli.c line 452
static void cli_mkdir(const char *fpath, signed int mode)
{
  signed int return_value_mkdir_3;
  return_value_mkdir_3=mkdir(fpath, (unsigned int)mode);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_mkdir_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    cli_fatal("cli_mkdir(%s): %s", fpath, return_value_strerror_2);
  }

}

// cli_register_cfile
// file src/cli.c line 695
static void cli_register_cfile(char *fpath, struct dirent *dp)
{
  struct stat st;
  char *ext;
  char *opath;
  signed int cpp;
  ext=strrchr(fpath, 46);
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(ext == ((char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(ext, ".c");
    if(!(return_value_strcmp_1 == 0))
    {
      return_value_strcmp_2=strcmp(ext, ".cpp");
      tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  if(!tmp_if_expr_4)
  {
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(ext, ".cpp");
    if(return_value_strcmp_5 == 0)
      cpp = 1;

    else
      cpp = 0;
    signed int return_value_stat_8;
    return_value_stat_8=stat(fpath, &st);
    if(return_value_stat_8 == -1)
    {
      return_value___errno_location_6=__errno_location();
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      cli_fatal("stat(%s): %s", fpath, return_value_strerror_7);
    }

    cli_vasprintf(&opath, "%s/.objs/%s.o", rootdir, (const void *)dp->d_name);
    signed int return_value_cli_file_requires_build_9;
    return_value_cli_file_requires_build_9=cli_file_requires_build(&st, opath);
    if(return_value_cli_file_requires_build_9 == 0)
      cli_add_cfile(dp->d_name, fpath, opath, &st, 0, cpp);

    else
      cli_add_cfile(dp->d_name, fpath, opath, &st, 1, cpp);
  }

}

// cli_run
// file src/cli.c line 402
static void cli_run(signed int argc, char **argv)
{
  cli_build(argc, argv);
  signed int return_value_chdir_1;
  return_value_chdir_1=chdir(rootdir);
  if(return_value_chdir_1 == -1)
    cli_fatal("couldn't change directory to %s", rootdir);

  cli_run_kore((void *)0);
}

// cli_run_kore
// file src/cli.c line 986
static void cli_run_kore(void *arg)
{
  char *args[4l];
  char *cpath;
  cli_vasprintf(&cpath, "conf/%s.conf", appl);
  args[(signed long int)0] = "kore";
  args[(signed long int)1] = "-fnrc";
  args[(signed long int)2] = cpath;
  args[(signed long int)3] = (char *)(void *)0;
  execvp("kore", args);
}

// cli_spawn_proc
// file src/cli.c line 1001
static void cli_spawn_proc(void (*cb)(void *), void *arg)
{
  signed int pid;
  signed int status;
  pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    cli_fatal("cli_compile_cfile: fork() %s", return_value_strerror_2);

  __CPROVER_DUMP_L2:
    ;
    cb(arg);
    return_value___errno_location_3=__errno_location();
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    cli_fatal("cli_spawn_proc: %s", return_value_strerror_4);
  }
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
  signed int return_value_waitpid_5;
  return_value_waitpid_5=waitpid(pid, &status, 0);
  if(return_value_waitpid_5 == -1)
    cli_fatal("couldn't wait for child %d", pid);

  _Bool tmp_if_expr_6;
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_67
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if(!((0xff00 & status) >> 8 == 0))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (((union anonymous_67){ .__in=status }).__i & 0x7f) != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = (((union anonymous_67){ .__in=status }).__i & 0x80) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_7)
    cli_fatal("subprocess trouble, check output");

}

// cli_vasprintf
// file src/cli.c line 1027
static signed int cli_vasprintf(char **out, const char *fmt, ...)
{
  signed int l;
  void **args = (void **)&fmt;
  l=vasprintf(out, fmt, args);
  args = ((void **)NULL);
  if(l == -1)
    cli_fatal("cli_vasprintf");

  return l;
}

// cli_write_asset
// file src/cli.c line 570
static void cli_write_asset(const char *n, const char *e)
{
  cli_file_writef(s_fd, "extern u_int8_t asset_%s_%s[];\n", n, e);
  cli_file_writef(s_fd, "extern u_int32_t asset_len_%s_%s;\n", n, e);
  cli_file_writef(s_fd, "extern time_t asset_mtime_%s_%s;\n", n, e);
}

// configure_accept_threshold
// file src/config.c line 600
static signed int configure_accept_threshold(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 0, (signed long long int)1, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &err);
    worker_accept_threshold = (unsigned int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad value for worker_accept_threshold: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_accesslog
// file src/config.c line 498
static signed int configure_accesslog(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(current_domain == ((struct kore_domain *)NULL))
      return 0;

    else
      if(!(current_domain->accesslog == -1))
        return 0;

      else
      {
        current_domain->accesslog=open(argv[(signed long int)1], 0100 | 02000 | 01, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
        if(current_domain->accesslog == -1)
          return 0;

        else
          return 1;
      }
}

// configure_authentication
// file src/config.c line 842
static signed int configure_authentication(char **argv)
{
  if(argv[2l] == ((char *)NULL))
  {
    printf("Missing name for authentication block\n");
    return 0;
  }

  else
    if(!(current_auth == ((struct kore_auth *)NULL)))
    {
      printf("Previous authentication block not closed\n");
      return 0;
    }

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(argv[(signed long int)2], "{");
      if(!(return_value_strcmp_1 == 0))
      {
        printf("missing { for authentication block\n");
        return 0;
      }

      else
      {
        signed int return_value_kore_auth_new_2;
        return_value_kore_auth_new_2=kore_auth_new(argv[(signed long int)1]);
        if(return_value_kore_auth_new_2 == 0)
          return 0;

        else
        {
          current_auth=kore_auth_lookup(argv[(signed long int)1]);
          return 1;
        }
      }
    }
}

// configure_authentication_type
// file src/config.c line 868
static signed int configure_authentication_type(char **argv)
{
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(current_auth == ((struct kore_auth *)NULL))
  {
    printf("authentication_type outside authentication block\n");
    return 0;
  }

  else
    if(argv[1l] == ((char *)NULL))
    {
      printf("missing parameter for authentication_type\n");
      return 0;
    }

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(argv[(signed long int)1], "cookie");
      if(return_value_strcmp_3 == 0)
        current_auth->type = (unsigned char)1;

      else
      {
        return_value_strcmp_2=strcmp(argv[(signed long int)1], "header");
        if(return_value_strcmp_2 == 0)
          current_auth->type = (unsigned char)2;

        else
        {
          return_value_strcmp_1=strcmp(argv[(signed long int)1], "request");
          if(return_value_strcmp_1 == 0)
            current_auth->type = (unsigned char)3;

          else
          {
            printf("unknown authentication type '%s'\n", argv[(signed long int)1]);
            return 0;
          }
        }
      }
      return 1;
    }
}

// configure_authentication_uri
// file src/config.c line 947
static signed int configure_authentication_uri(char **argv)
{
  if(current_auth == ((struct kore_auth *)NULL))
  {
    printf("authentication_uri outside authentication block\n");
    return 0;
  }

  else
    if(argv[1l] == ((char *)NULL))
    {
      printf("missing parameter for authentication_uri\n");
      return 0;
    }

    else
      if(!(current_auth->redirect == ((char *)NULL)))
      {
        printf("duplicate authentication_uri found\n");
        return 0;
      }

      else
      {
        current_auth->redirect=kore_strdup(argv[(signed long int)1]);
        return 1;
      }
}

// configure_authentication_validator
// file src/config.c line 917
static signed int configure_authentication_validator(char **argv)
{
  struct kore_validator *val;
  if(current_auth == ((struct kore_auth *)NULL))
  {
    printf("authentication_validator outside authentication\n");
    return 0;
  }

  else
    if(argv[1l] == ((char *)NULL))
    {
      printf("missing parameter for authentication_validator\n");
      return 0;
    }

    else
      if(!(current_auth->validator == ((struct kore_validator *)NULL)))
      {
        printf("duplicate authentication_validator found\n");
        return 0;
      }

      else
      {
        val=kore_validator_lookup(argv[(signed long int)1]);
        if(val == ((struct kore_validator *)NULL))
        {
          printf("authentication validator '%s' not found\n", argv[(signed long int)1]);
          return 0;
        }

        else
        {
          current_auth->validator = val;
          return 1;
        }
      }
}

// configure_authentication_value
// file src/config.c line 895
static signed int configure_authentication_value(char **argv)
{
  if(current_auth == ((struct kore_auth *)NULL))
  {
    printf("authentication_value outside authentication block\n");
    return 0;
  }

  else
    if(argv[1l] == ((char *)NULL))
    {
      printf("missing parameter for authentication_value\n");
      return 0;
    }

    else
      if(!(current_auth->value == ((char *)NULL)))
      {
        printf("duplicate authentication_value found\n");
        return 0;
      }

      else
      {
        current_auth->value=kore_strdup(argv[(signed long int)1]);
        return 1;
      }
}

// configure_bind
// file src/config.c line 249
static signed int configure_bind(char **argv)
{
  _Bool tmp_if_expr_1;
  if(argv[1l] == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = argv[(signed long int)2] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    signed int return_value_kore_server_bind_2;
    return_value_kore_server_bind_2=kore_server_bind(argv[(signed long int)1], argv[(signed long int)2]);
    return return_value_kore_server_bind_2;
  }
}

// configure_certfile
// file src/config.c line 526
static signed int configure_certfile(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(current_domain == ((struct kore_domain *)NULL))
    {
      printf("missing domain for certfile\n");
      return 0;
    }

    else
      if(!(current_domain->certfile == ((char *)NULL)))
        return 0;

      else
      {
        current_domain->certfile=kore_strdup(argv[(signed long int)1]);
        return 1;
      }
}

// configure_certkey
// file src/config.c line 546
static signed int configure_certkey(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(current_domain == ((struct kore_domain *)NULL))
    {
      printf("missing domain for certkey\n");
      return 0;
    }

    else
      if(!(current_domain->certkey == ((char *)NULL)))
        return 0;

      else
      {
        current_domain->certkey=kore_strdup(argv[(signed long int)1]);
        return 1;
      }
}

// configure_chroot
// file src/config.c line 431
static signed int configure_chroot(char **argv)
{
  if(!(chroot_path == ((char *)NULL)))
    return 0;

  else
    if(argv[1l] == ((char *)NULL))
      return 0;

    else
    {
      chroot_path=kore_strdup(argv[(signed long int)1]);
      return 1;
    }
}

// configure_client_certificates
// file src/config.c line 405
static signed int configure_client_certificates(char **argv)
{
  if(current_domain == ((struct kore_domain *)NULL))
  {
    printf("missing domain for require_client_cert\n");
    return 0;
  }

  else
    if(argv[1l] == ((char *)NULL))
    {
      printf("missing argument for require_client_cert\n");
      return 0;
    }

    else
      if(!(current_domain->cafile == ((char *)NULL)))
      {
        printf("require_client_cert already set for %s\n", current_domain->domain);
        return 0;
      }

      else
      {
        current_domain->cafile=kore_strdup(argv[(signed long int)1]);
        if(!(argv[2l] == ((char *)NULL)))
          current_domain->crlfile=kore_strdup(argv[(signed long int)2]);

        return 1;
      }
}

// configure_domain
// file src/config.c line 351
static signed int configure_domain(char **argv)
{
  if(argv[2l] == ((char *)NULL))
    return 0;

  else
    if(!(current_domain == ((struct kore_domain *)NULL)))
    {
      printf("previous domain configuration not closed\n");
      return 0;
    }

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(argv[(signed long int)2], "{");
      if(!(return_value_strcmp_1 == 0))
      {
        printf("missing { for domain directive\n");
        return 0;
      }

      else
      {
        signed int return_value_kore_domain_new_2;
        return_value_kore_domain_new_2=kore_domain_new(argv[(signed long int)1]);
        if(return_value_kore_domain_new_2 == 0)
        {
          printf("could not create new domain %s\n", argv[(signed long int)1]);
          return 0;
        }

        else
        {
          current_domain=kore_domain_lookup(argv[(signed long int)1]);
          return 1;
        }
      }
    }
}

// configure_handler
// file src/config.c line 376
static signed int configure_handler(char **argv)
{
  signed int type;
  _Bool tmp_if_expr_1;
  signed int return_value_strcmp_2;
  if(current_domain == ((struct kore_domain *)NULL))
  {
    printf("missing domain for page handler\n");
    return 0;
  }

  else
  {
    if(argv[1l] == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)2] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(argv[(signed long int)0], "static");
      if(return_value_strcmp_3 == 0)
        type = 1;

      else
      {
        return_value_strcmp_2=strcmp(argv[(signed long int)0], "dynamic");
        if(return_value_strcmp_2 == 0)
          type = 2;

        else
          return 0;
      }
      signed int return_value_kore_module_handler_new_4;
      return_value_kore_module_handler_new_4=kore_module_handler_new(argv[(signed long int)1], current_domain->domain, argv[(signed long int)2], argv[(signed long int)3], type);
      if(return_value_kore_module_handler_new_4 == 0)
        return 0;

      else
        return 1;
    }
  }
}

// configure_http_body_max
// file src/config.c line 656
static signed int configure_http_body_max(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(!(http_body_max == 10240000ul))
      return 0;

    else
    {
      signed long long int return_value_kore_strtonum_1;
      return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)1, 0x7fffffffffffffffL, &err);
      http_body_max = (unsigned long int)return_value_kore_strtonum_1;
      if(!(err == 1))
      {
        printf("bad http_body_max value: %s\n", argv[(signed long int)1]);
        return 0;
      }

      else
        return 1;
    }
}

// configure_http_header_max
// file src/config.c line 634
static signed int configure_http_header_max(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(!((signed int)http_header_max == 4096))
      return 0;

    else
    {
      signed long long int return_value_kore_strtonum_1;
      return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)1, (signed long long int)65535, &err);
      http_header_max = (unsigned short int)return_value_kore_strtonum_1;
      if(!(err == 1))
      {
        printf("bad http_header_max value: %s\n", argv[(signed long int)1]);
        return 0;
      }

      else
        return 1;
    }
}

// configure_http_hsts_enable
// file src/config.c line 678
static signed int configure_http_hsts_enable(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(!(http_hsts_enable == 31536000ul))
      return 0;

    else
    {
      signed long long int return_value_kore_strtonum_1;
      return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, 0x7fffffffffffffffL, &err);
      http_hsts_enable = (unsigned long int)return_value_kore_strtonum_1;
      if(!(err == 1))
      {
        printf("bad http_hsts_enable value: %s\n", argv[(signed long int)1]);
        return 0;
      }

      else
        return 1;
    }
}

// configure_http_keepalive_time
// file src/config.c line 700
static signed int configure_http_keepalive_time(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(!((signed int)http_keepalive_time == 20))
      return 0;

    else
    {
      signed long long int return_value_kore_strtonum_1;
      return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)(0x7fff * 2 + 1), &err);
      http_keepalive_time = (unsigned short int)return_value_kore_strtonum_1;
      if(!(err == 1))
      {
        printf("bad http_keepalive_time value: %s\n", argv[(signed long int)1]);
        return 0;
      }

      else
        return 1;
    }
}

// configure_http_request_limit
// file src/config.c line 722
static signed int configure_http_request_limit(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &err);
    http_request_limit = (unsigned int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad http_request_limit value: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_include
// file src/config.c line 237
static signed int configure_include(char **argv)
{
  if(argv[1l] == ((char *)NULL))
  {
    printf("No file given in include directive\n");
    return 0;
  }

  else
  {
    kore_parse_config_file(argv[(signed long int)1]);
    return 1;
  }
}

// configure_load
// file src/config.c line 258
static signed int configure_load(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    kore_module_load(argv[(signed long int)1], argv[(signed long int)2]);
    return 1;
  }
}

// configure_max_connections
// file src/config.c line 566
static signed int configure_max_connections(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)1, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &err);
    worker_max_connections = (unsigned int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad value for worker_max_connections: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_params
// file src/config.c line 764
static signed int configure_params(char **argv)
{
  struct kore_module_handle *hdlr;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(current_domain == ((struct kore_domain *)NULL))
  {
    printf("params keyword used in wrong context\n");
    return 0;
  }

  else
    if(!(current_handler == ((struct kore_module_handle *)NULL)))
    {
      printf("previous params block not closed\n");
      return 0;
    }

    else
      if(argv[2l] == ((char *)NULL))
        return 0;

      else
      {
        signed int return_value_strcasecmp_5;
        return_value_strcasecmp_5=strcasecmp(argv[(signed long int)1], "post");
        if(return_value_strcasecmp_5 == 0)
          current_method = (unsigned char)1;

        else
        {
          return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "get");
          if(return_value_strcasecmp_4 == 0)
            current_method = (unsigned char)0;

          else
          {
            return_value_strcasecmp_3=strcasecmp(argv[(signed long int)1], "put");
            if(return_value_strcasecmp_3 == 0)
              current_method = (unsigned char)2;

            else
            {
              return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "delete");
              if(return_value_strcasecmp_2 == 0)
                current_method = (unsigned char)3;

              else
              {
                return_value_strcasecmp_1=strcasecmp(argv[(signed long int)1], "head");
                if(return_value_strcasecmp_1 == 0)
                  current_method = (unsigned char)4;

                else
                {
                  printf("unknown method: %s in params block for %s\n", argv[(signed long int)1], argv[(signed long int)2]);
                  return 0;
                }
              }
            }
          }
        }
        hdlr = (&current_domain->handlers)->tqh_first;
        for( ; !(hdlr == ((struct kore_module_handle *)NULL)); hdlr = hdlr->list.tqe_next)
        {
          signed int return_value_strcmp_6;
          return_value_strcmp_6=strcmp(hdlr->path, argv[(signed long int)2]);
          if(return_value_strcmp_6 == 0)
          {
            current_handler = hdlr;
            return 1;
          }

        }
        printf("params for unknown page handler: %s\n", argv[(signed long int)2]);
        return 0;
      }
}

// configure_pgsql_conn_max
// file src/config.c line 1036
static signed int configure_pgsql_conn_max(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
  {
    printf("missing parameter for pgsql_conn_max\n");
    return 0;
  }

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)(0x7fff * 2 + 1), &err);
    pgsql_conn_max = (unsigned short int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad value for pgsql_conn_max: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_pidfile
// file src/config.c line 483
static signed int configure_pidfile(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(kore_pidfile, "kore.pid");
    if(!(return_value_strcmp_1 == 0))
      return 0;

    else
    {
      kore_pidfile=kore_strdup(argv[(signed long int)1]);
      return 1;
    }
  }
}

// configure_rlimit_nofiles
// file src/config.c line 583
static signed int configure_rlimit_nofiles(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)1, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &err);
    worker_rlimit_nofiles = (unsigned int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad value for worker_rlimit_nofiles: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_runas
// file src/config.c line 446
static signed int configure_runas(char **argv)
{
  if(!(runas_user == ((char *)NULL)))
    return 0;

  else
    if(argv[1l] == ((char *)NULL))
      return 0;

    else
    {
      runas_user=kore_strdup(argv[(signed long int)1]);
      return 1;
    }
}

// configure_set_affinity
// file src/config.c line 617
static signed int configure_set_affinity(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)1, &err);
    worker_set_affinity = (unsigned char)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad value for worker_set_affinity: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_socket_backlog
// file src/config.c line 1010
static signed int configure_socket_backlog(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &err);
    kore_socket_backlog = (unsigned int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("bad socket_backlog value: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_spdy_idle_time
// file src/config.c line 333
static signed int configure_spdy_idle_time(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed long long int return_value_kore_strtonum_1;
    return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)0, (signed long long int)65535, &err);
    spdy_idle_time = (unsigned long int)return_value_kore_strtonum_1;
    if(!(err == 1))
    {
      printf("spdy_idle_time has invalid value: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
    {
      spdy_idle_time = spdy_idle_time * (unsigned long int)1000;
      return 1;
    }
  }
}

// configure_tls_cipher
// file src/config.c line 288
static signed int configure_tls_cipher(char **argv)
{
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(kore_tls_cipher_list, "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK:!kRSA:!kDSA");
    if(!(return_value_strcmp_1 == 0))
      return 0;

    else
    {
      kore_tls_cipher_list=kore_strdup(argv[(signed long int)1]);
      return 1;
    }
  }
}

// configure_tls_dhparam
// file src/config.c line 303
static signed int configure_tls_dhparam(char **argv)
{
  struct bio_st *bio;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
    if(!(tls_dhparam == ((struct dh_st *)NULL)))
      return 0;

    else
    {
      bio=BIO_new_file(argv[(signed long int)1], "r");
      if(bio == ((struct bio_st *)NULL))
      {
        printf("%s did not exist\n", argv[(signed long int)1]);
        return 0;
      }

      else
      {
        tls_dhparam=PEM_read_bio_DHparams(bio, (struct dh_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        BIO_free(bio);
        if(tls_dhparam == ((struct dh_st *)NULL))
        {
          unsigned long int return_value_ERR_get_error_1;
          return_value_ERR_get_error_1=ERR_get_error();
          char *return_value_ERR_error_string_2;
          return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
          printf("PEM_read_bio_DHparams(): %s\n", return_value_ERR_error_string_2);
          return 0;
        }

        return 1;
      }
    }
}

// configure_tls_version
// file src/config.c line 268
static signed int configure_tls_version(char **argv)
{
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(argv[1l] == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(argv[(signed long int)1], "1.2");
    if(return_value_strcmp_3 == 0)
      tls_version = 0;

    else
    {
      return_value_strcmp_2=strcmp(argv[(signed long int)1], "1.0");
      if(return_value_strcmp_2 == 0)
        tls_version = 1;

      else
      {
        return_value_strcmp_1=strcmp(argv[(signed long int)1], "both");
        if(return_value_strcmp_1 == 0)
          tls_version = 2;

        else
        {
          printf("unknown value for tls_version: %s\n", argv[(signed long int)1]);
          return 0;
        }
      }
    }
    return 1;
  }
}

// configure_validate
// file src/config.c line 813
static signed int configure_validate(char **argv)
{
  struct kore_handler_params *p;
  struct kore_validator *val;
  if(current_handler == ((struct kore_module_handle *)NULL))
  {
    printf("validate keyword used in wrong context\n");
    return 0;
  }

  else
    if(argv[2l] == ((char *)NULL))
      return 0;

    else
    {
      val=kore_validator_lookup(argv[(signed long int)2]);
      if(val == ((struct kore_validator *)NULL))
      {
        printf("unknown validator %s for %s\n", argv[(signed long int)2], argv[(signed long int)1]);
        return 0;
      }

      else
      {
        void *return_value_kore_malloc_1;
        return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_handler_params) /*40ul*/ );
        p = (struct kore_handler_params *)return_value_kore_malloc_1;
        p->validator = val;
        p->method = current_method;
        p->name=kore_strdup(argv[(signed long int)1]);
        do
        {
          p->list.tqe_next = (struct kore_handler_params *)(void *)0;
          p->list.tqe_prev = (&current_handler->params)->tqh_last;
          *(&current_handler->params)->tqh_last = p;
          (&current_handler->params)->tqh_last = &p->list.tqe_next;
        }
        while((_Bool)0);
        return 1;
      }
    }
}

// configure_validator
// file src/config.c line 739
static signed int configure_validator(char **argv)
{
  unsigned char type;
  signed int return_value_strcmp_1;
  if(argv[3l] == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(argv[(signed long int)2], "regex");
    if(return_value_strcmp_2 == 0)
      type = (unsigned char)1;

    else
    {
      return_value_strcmp_1=strcmp(argv[(signed long int)2], "function");
      if(return_value_strcmp_1 == 0)
        type = (unsigned char)2;

      else
      {
        printf("bad type for validator %s\n", argv[(signed long int)1]);
        return 0;
      }
    }
    signed int return_value_kore_validator_add_3;
    return_value_kore_validator_add_3=kore_validator_add(argv[(signed long int)1], type, argv[(signed long int)3]);
    if(return_value_kore_validator_add_3 == 0)
    {
      printf("bad validator specified: %s\n", argv[(signed long int)1]);
      return 0;
    }

    else
      return 1;
  }
}

// configure_websocket_maxframe
// file src/config.c line 970
static signed int configure_websocket_maxframe(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
  {
    printf("missing parameter for kore_websocket_maxframe\n");
    return 0;
  }

  else
  {
    kore_websocket_maxframe=kore_strtonum64(argv[(signed long int)1], 1, &err);
    if(!(err == 1))
    {
      printf("bad kore_websocket_maxframe value\n");
      return 0;
    }

    else
      return 1;
  }
}

// configure_websocket_timeout
// file src/config.c line 989
static signed int configure_websocket_timeout(char **argv)
{
  signed int err;
  if(argv[1l] == ((char *)NULL))
  {
    printf("missing parameter for kore_websocket_timeout\n");
    return 0;
  }

  else
  {
    kore_websocket_timeout=kore_strtonum64(argv[(signed long int)1], 1, &err);
    if(!(err == 1))
    {
      printf("bad kore_websocket_timeout value\n");
      return 0;
    }

    else
    {
      kore_websocket_timeout = kore_websocket_timeout * (unsigned long int)1000;
      return 1;
    }
  }
}

// configure_workers
// file src/config.c line 461
static signed int configure_workers(char **argv)
{
  signed int err;
  if(!((signed int)worker_count == 0))
    return 0;

  else
    if(argv[1l] == ((char *)NULL))
      return 0;

    else
    {
      signed long long int return_value_kore_strtonum_1;
      return_value_kore_strtonum_1=kore_strtonum(argv[(signed long int)1], 10, (signed long long int)1, (signed long long int)255, &err);
      worker_count = (unsigned char)return_value_kore_strtonum_1;
      if(!(err == 1))
      {
        printf("%s is not a correct worker number\n", argv[(signed long int)1]);
        return 0;
      }

      else
        return 1;
    }
}

// domain_load_crl
// file src/domain.c line 213
static void domain_load_crl(struct kore_domain *dom)
{
  struct x509_store_st *store;
  ERR_clear_error();
  if(!(dom->cafile == ((char *)NULL)))
  {
    if(dom->crlfile == ((char *)NULL))
      kore_log(4, "WARNING: Running without CRL");

    else
    {
      store=SSL_CTX_get_cert_store(dom->ssl_ctx);
      if(store == ((struct x509_store_st *)NULL))
      {
        unsigned long int return_value_ERR_get_error_1;
        return_value_ERR_get_error_1=ERR_get_error();
        char *return_value_ERR_error_string_2;
        return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
        kore_log(3, "SSL_CTX_get_cert_store(): %s", return_value_ERR_error_string_2);
        goto __CPROVER_DUMP_L5;
      }

      signed int return_value_X509_STORE_load_locations_5;
      return_value_X509_STORE_load_locations_5=X509_STORE_load_locations(store, dom->crlfile, (const char *)(void *)0);
      if(return_value_X509_STORE_load_locations_5 == 0)
      {
        unsigned long int return_value_ERR_get_error_3;
        return_value_ERR_get_error_3=ERR_get_error();
        char *return_value_ERR_error_string_4;
        return_value_ERR_error_string_4=ERR_error_string(return_value_ERR_get_error_3, (char *)(void *)0);
        kore_log(3, "X509_STORE_load_locations(): %s", return_value_ERR_error_string_4);
        goto __CPROVER_DUMP_L5;
      }

      X509_STORE_set_flags(store, (unsigned long int)(0x4 | 0x8));
    }
  }


__CPROVER_DUMP_L5:
  ;
}

// domain_sslstart
// file src/config.c line 1027
static void domain_sslstart(void)
{
  kore_domain_sslstart(current_domain);
  current_domain = (struct kore_domain *)(void *)0;
}

// domain_x509_verify
// file src/domain.c line 246
static signed int domain_x509_verify(signed int ok, struct x509_store_ctx_st *ctx)
{
  struct x509_st *cert;
  const char *text;
  signed int error;
  signed int depth;
  error=X509_STORE_CTX_get_error(ctx);
  cert=X509_STORE_CTX_get_current_cert(ctx);
  if(ok == 0 && !(cert == ((struct x509_st *)NULL)))
  {
    text=X509_verify_cert_error_string((signed long int)error);
    depth=X509_STORE_CTX_get_error_depth(ctx);
    kore_log(4, "X509 verification error depth:%d - %s", depth, text);
    if(error == 3 || error == 11 || error == 12)
      ok = 1;

  }

  return ok;
}

// fatal
// file includes/kore.h line 521
void fatal(const char *fmt, ...)
{
  void **args;
  char buf[2048l];
  args = (void **)&fmt;
  vsnprintf(buf, sizeof(char [2048l]) /*2048ul*/ , fmt, args);
  args = ((void **)NULL);
  if(foreground == 0)
    kore_log(3, "%s", (const void *)buf);

  printf("kore: %s\n", (const void *)buf);
  exit(1);
}

// file_create_config
// file src/cli.c line 427
static void file_create_config(void)
{
  signed int l;
  char *name;
  char *data;
  cli_vasprintf(&name, "conf/%s.conf", appl);
  l=cli_vasprintf(&data, config_data, appl);
  cli_file_create(name, data, (unsigned long int)l);
  free((void *)name);
  free((void *)data);
}

// file_create_gitignore
// file src/cli.c line 441
static void file_create_gitignore(void)
{
  signed int l;
  char *data;
  l=cli_vasprintf(&data, gitignore_data, appl);
  cli_file_create(".gitignore", data, (unsigned long int)l);
  free((void *)data);
}

// file_create_src
// file src/cli.c line 417
static void file_create_src(void)
{
  char *name;
  cli_vasprintf(&name, "src/%s.c", appl);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src_data);
  cli_file_create(name, src_data, return_value_strlen_1);
  free((void *)name);
}

// http_argument_add
// file src/http.c line 1079
static void http_argument_add(struct http_request *req, const char *name, void *value, unsigned int len, signed int type)
{
  struct http_arg *q;
  struct kore_handler_params *p;
  if(!(value == NULL) && !(len == 0u))
  {
    p = (&req->hdlr->params)->tqh_first;
    for( ; !(p == ((struct kore_handler_params *)NULL)); p = p->list.tqe_next)
      if(p->method == req->method)
      {
        signed int return_value_strcmp_4;
        return_value_strcmp_4=strcmp(p->name, name);
        if(return_value_strcmp_4 == 0)
        {
          if(type == 6)
          {
            http_argument_urldecode((char *)value);
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen((const char *)value);
            len = (unsigned int)return_value_strlen_1;
          }

          signed int return_value_kore_validator_check_3;
          return_value_kore_validator_check_3=kore_validator_check(req, p->validator, value);
          if(!(return_value_kore_validator_check_3 == 0))
          {
            void *return_value_kore_malloc_2;
            return_value_kore_malloc_2=kore_malloc(sizeof(struct http_arg) /*56ul*/ );
            q = (struct http_arg *)return_value_kore_malloc_2;
            q->len = len;
            q->s_value = (char *)(void *)0;
            q->name=kore_strdup(name);
            q->value=kore_malloc((unsigned long int)len);
            memcpy(q->value, value, (unsigned long int)len);
            do
            {
              q->list.tqe_next = (struct http_arg *)(void *)0;
              q->list.tqe_prev = (&req->arguments)->tqh_last;
              *(&req->arguments)->tqh_last = q;
              (&req->arguments)->tqh_last = &q->list.tqe_next;
            }
            while((_Bool)0);
          }

          goto __CPROVER_DUMP_L9;
        }

      }

  }


__CPROVER_DUMP_L9:
  ;
}

// http_argument_get
// file src/http.c line 723
signed int http_argument_get(struct http_request *req, const char *name, void **out, void *nout, unsigned int *len, signed int type)
{
  struct http_arg *q;
  if(!(len == ((unsigned int *)NULL)))
    *len = (unsigned int)0;

  q = (&req->arguments)->tqh_first;
  for( ; !(q == ((struct http_arg *)NULL)); q = q->list.tqe_next)
  {
    signed int return_value_strcmp_10;
    return_value_strcmp_10=strcmp(q->name, name);
    if(return_value_strcmp_10 == 0)
      switch(type)
      {
        case 0:
        {
          if(!(len == ((unsigned int *)NULL)))
            *len = q->len;

          *out = q->value;
          return 1;
        }
        case 1:
        {
          do
          {
            if(!(len == ((unsigned int *)NULL)))
              *len = (unsigned int)sizeof(unsigned char) /*1ul*/ ;

            *((unsigned char *)nout) = *((unsigned char *)q->value);
          }
          while((_Bool)0);
          return 1;
        }
        case 2:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_1;
                return_value_kore_malloc_1=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_1;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int err;
              signed long int nval;
              nval=kore_strtonum(q->s_value, 10, (signed long long int)(-0x7fff - 1), (signed long long int)0x7fff, &err);
              if(!(err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(signed short int) /*2ul*/ ;

                *((signed short int *)nout) = (signed short int)nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 3:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_2;
                return_value_kore_malloc_2=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_2;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int http_argument_get__1__1__1__1__1__3__2__err;
              signed long int http_argument_get__1__1__1__1__1__3__2__nval;
              http_argument_get__1__1__1__1__1__3__2__nval=kore_strtonum(q->s_value, 10, (signed long long int)0, (signed long long int)(0x7fff * 2 + 1), &http_argument_get__1__1__1__1__1__3__2__err);
              if(!(http_argument_get__1__1__1__1__1__3__2__err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(unsigned short int) /*2ul*/ ;

                *((unsigned short int *)nout) = (unsigned short int)http_argument_get__1__1__1__1__1__3__2__nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 4:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_3;
                return_value_kore_malloc_3=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_3;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int http_argument_get__1__1__1__1__1__4__2__err;
              signed long int http_argument_get__1__1__1__1__1__4__2__nval;
              http_argument_get__1__1__1__1__1__4__2__nval=kore_strtonum(q->s_value, 10, (signed long long int)(-0x7fffffff - 1), (signed long long int)0x7fffffff, &http_argument_get__1__1__1__1__1__4__2__err);
              if(!(http_argument_get__1__1__1__1__1__4__2__err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(signed int) /*4ul*/ ;

                *((signed int *)nout) = (signed int)http_argument_get__1__1__1__1__1__4__2__nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 5:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_4;
                return_value_kore_malloc_4=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_4;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int http_argument_get__1__1__1__1__1__5__2__err;
              signed long int http_argument_get__1__1__1__1__1__5__2__nval;
              http_argument_get__1__1__1__1__1__5__2__nval=kore_strtonum(q->s_value, 10, (signed long long int)0, (signed long long int)((unsigned int)0x7fffffff * 2U + 1U), &http_argument_get__1__1__1__1__1__5__2__err);
              if(!(http_argument_get__1__1__1__1__1__5__2__err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(unsigned int) /*4ul*/ ;

                *((unsigned int *)nout) = (unsigned int)http_argument_get__1__1__1__1__1__5__2__nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 7:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_5;
                return_value_kore_malloc_5=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_5;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int http_argument_get__1__1__1__1__1__6__2__err;
              signed long int http_argument_get__1__1__1__1__1__6__2__nval;
              unsigned long int return_value_kore_strtonum64_6;
              return_value_kore_strtonum64_6=kore_strtonum64(q->s_value, 1, &http_argument_get__1__1__1__1__1__6__2__err);
              http_argument_get__1__1__1__1__1__6__2__nval = (signed long int)return_value_kore_strtonum64_6;
              if(!(http_argument_get__1__1__1__1__1__6__2__err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(signed long int) /*8ul*/ ;

                *((signed long int *)nout) = http_argument_get__1__1__1__1__1__6__2__nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 8:
        {
          do
          {
            if(nout == NULL)
              return 0;

            do
              if(q->s_value == ((char *)NULL))
              {
                q->s_len = q->len + (unsigned int)1;
                void *return_value_kore_malloc_7;
                return_value_kore_malloc_7=kore_malloc((unsigned long int)q->s_len);
                q->s_value = (char *)return_value_kore_malloc_7;
                kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
              }

            while((_Bool)0);
            do
            {
              signed int http_argument_get__1__1__1__1__1__7__2__err;
              unsigned long int http_argument_get__1__1__1__1__1__7__2__nval;
              unsigned long int return_value_kore_strtonum64_8;
              return_value_kore_strtonum64_8=kore_strtonum64(q->s_value, 0, &http_argument_get__1__1__1__1__1__7__2__err);
              http_argument_get__1__1__1__1__1__7__2__nval = (unsigned long int)return_value_kore_strtonum64_8;
              if(!(http_argument_get__1__1__1__1__1__7__2__err == 1))
                return 0;

              do
              {
                if(!(len == ((unsigned int *)NULL)))
                  *len = (unsigned int)sizeof(unsigned long int) /*8ul*/ ;

                *((unsigned long int *)nout) = http_argument_get__1__1__1__1__1__7__2__nval;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          return 1;
        }
        case 6:
        {
          do
            if(q->s_value == ((char *)NULL))
            {
              q->s_len = q->len + (unsigned int)1;
              void *return_value_kore_malloc_9;
              return_value_kore_malloc_9=kore_malloc((unsigned long int)q->s_len);
              q->s_value = (char *)return_value_kore_malloc_9;
              kore_strlcpy(q->s_value, (const char *)q->value, (unsigned long int)q->s_len);
            }

          while((_Bool)0);
          *out = (void *)q->s_value;
          if(!(len == ((unsigned int *)NULL)))
            *len = q->s_len - (unsigned int)1;

          return 1;
        }
        default:
          return 0;
      }

  }
  return 0;
}

// http_argument_urldecode
// file src/http.c line 777
signed int http_argument_urldecode(char *arg)
{
  unsigned char v;
  signed int err;
  unsigned long int len;
  char *p;
  char *in;
  char h[5l];
  p = arg;
  in = arg;
  len=strlen(arg);
  char *tmp_post_1;
  char *tmp_post_2;
  _Bool tmp_if_expr_7;
  const unsigned short int **return_value___ctype_b_loc_6;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_9;
  while(!((signed int)*p == 0))
  {
    if(p >= arg + (signed long int)len)
      break;

    if((signed int)*p == 43)
      *p = (char)32;

    if(!((signed int)*p == 37))
    {
      tmp_post_1 = in;
      in = in + 1l;
      tmp_post_2 = p;
      p = p + 1l;
      *tmp_post_1 = *tmp_post_2;
    }

    else
    {
      if(p + 2l >= arg + (signed long int)len)
        return 0;

      const unsigned short int **return_value___ctype_b_loc_5;
      return_value___ctype_b_loc_5=__ctype_b_loc();
      if((4096 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)p[1l]]) == 0)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc_6=__ctype_b_loc();
        tmp_if_expr_7 = !(((signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)p[(signed long int)2]] & (signed int)(unsigned short int)4096) != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        tmp_post_3 = in;
        in = in + 1l;
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_3 = *tmp_post_4;
      }

      else
      {
        h[(signed long int)0] = (char)48;
        h[(signed long int)1] = (char)120;
        h[(signed long int)2] = p[(signed long int)1];
        h[(signed long int)3] = p[(signed long int)2];
        h[(signed long int)4] = (char)0;
        signed long long int return_value_kore_strtonum_8;
        return_value_kore_strtonum_8=kore_strtonum(h, 16, (signed long long int)0, (signed long long int)255, &err);
        v = (unsigned char)return_value_kore_strtonum_8;
        if(!(err == 1))
          return err;

        tmp_post_9 = in;
        in = in + 1l;
        *tmp_post_9 = (char)v;
        p = p + (signed long int)3;
      }
    }
  }
  *in = (char)0;
  return 1;
}

// http_body_bytes
// file src/http.c line 1026
unsigned char * http_body_bytes(struct http_request *req, unsigned int *len)
{
  unsigned char *data;
  if(req->http_body == ((struct kore_buf *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    data=kore_buf_release(req->http_body, len);
    req->http_body = (struct kore_buf *)(void *)0;
    return data;
  }
}

// http_body_recv
// file src/http.c line 1131
static signed int http_body_recv(struct netbuf *nb)
{
  struct http_request *req = (struct http_request *)nb->extra;
  kore_buf_append(req->http_body, (void *)nb->buf, nb->s_off);
  req->flags = req->flags | (unsigned char)0x01;
  req->flags = req->flags & (unsigned char)~0x20;
  nb->extra = (void *)0;
  return 1;
}

// http_body_text
// file src/http.c line 1005
char * http_body_text(struct http_request *req)
{
  unsigned int len;
  unsigned char *data;
  char *text;
  if(req->http_body == ((struct kore_buf *)NULL))
    return (char *)(void *)0;

  else
  {
    data=kore_buf_release(req->http_body, &len);
    req->http_body = (struct kore_buf *)(void *)0;
    len = len + 1u;
    void *return_value_kore_malloc_1;
    return_value_kore_malloc_1=kore_malloc((unsigned long int)len);
    text = (char *)return_value_kore_malloc_1;
    kore_strlcpy(text, (char *)data, (unsigned long int)len);
    kore_mem_free((void *)data);
    return text;
  }
}

// http_error_response
// file src/http.c line 1147
static void http_error_response(struct connection *c, struct spdy_stream *s, signed int status)
{
  switch((signed int)c->proto)
  {
    case 1:
    {
      http_response_spdy((struct http_request *)(void *)0, c, s, status, (void *)0, (unsigned int)0);
      break;
    }
    case 2:
    {
      if(!(s == ((struct spdy_stream *)NULL)))
        kore_log(5, "http_error_response: s != NULL");

      http_response_normal((struct http_request *)(void *)0, c, status, (void *)0, (unsigned int)0);
      break;
    }
    default:
      fatal("http_error_response() bad proto %d", c->proto);
  }
}

// http_file_add
// file src/http.c line 1116
static void http_file_add(struct http_request *req, const char *name, const char *filename, unsigned char *data, unsigned int len)
{
  struct http_file *f;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct http_file) /*48ul*/ );
  f = (struct http_file *)return_value_kore_malloc_1;
  f->len = len;
  f->data = data;
  f->name=kore_strdup(name);
  f->filename=kore_strdup(filename);
  do
  {
    f->list.tqe_next = (struct http_file *)(void *)0;
    f->list.tqe_prev = (&req->files)->tqh_last;
    *(&req->files)->tqh_last = f;
    (&req->files)->tqh_last = &f->list.tqe_next;
  }
  while((_Bool)0);
}

// http_file_lookup
// file src/http.c line 825
signed int http_file_lookup(struct http_request *req, const char *name, char **fname, unsigned char **data, unsigned int *len)
{
  struct http_file *f = (&req->files)->tqh_first;
  for( ; !(f == ((struct http_file *)NULL)); f = f->list.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(f->name, name);
    if(return_value_strcmp_1 == 0)
    {
      *len = f->len;
      *data = f->data;
      *fname = f->filename;
      return 1;
    }

  }
  return 0;
}

// http_generic_404
// file src/http.c line 994
signed int http_generic_404(struct http_request *req)
{
  http_response(req, 404, (void *)0, (unsigned int)0);
  return 1;
}

// http_header_recv
// file includes/http.h line 240
signed int http_header_recv(struct netbuf *nb)
{
  unsigned long int len;
  unsigned long int clen;
  struct http_header *hdr;
  struct http_request *req;
  unsigned char *end_headers;
  signed int h;
  signed int i;
  signed int v;
  signed int skip;
  signed int bytes_left;
  char *request[4l];
  char *host[3l];
  char *hbuf;
  char *p;
  char *headers[25l];
  struct connection *c = (struct connection *)nb->owner;
  _Bool tmp_if_expr_5;
  signed int return_value_strncasecmp_4;
  _Bool tmp_if_expr_6;
  char *tmp_post_8;
  signed int return_value_strcasecmp_10;
  if(!(nb->b_len >= 4u))
    return 1;

  else
  {
    skip = 4;
    void *return_value_kore_mem_find_1;
    return_value_kore_mem_find_1=kore_mem_find((void *)nb->buf, (unsigned long int)nb->s_off, (void *)"\r\n\r\n", (unsigned int)4);
    end_headers = (unsigned char *)return_value_kore_mem_find_1;
    if(end_headers == ((unsigned char *)NULL))
    {
      void *return_value_kore_mem_find_2;
      return_value_kore_mem_find_2=kore_mem_find((void *)nb->buf, (unsigned long int)nb->s_off, (void *)"\n\n", (unsigned int)2);
      end_headers = (unsigned char *)return_value_kore_mem_find_2;
      if(end_headers == ((unsigned char *)NULL))
        return 1;

      skip = 2;
    }

    *end_headers = (unsigned char)0;
    end_headers = end_headers + (signed long int)skip;
    nb->flags = nb->flags | (unsigned char)0x02;
    len = (unsigned long int)(end_headers - nb->buf);
    hbuf = (char *)nb->buf;
    h=kore_split_string(hbuf, "\r\n", headers, (unsigned long int)25);
    if(!(h >= 2))
    {
      http_error_response(c, (struct spdy_stream *)(void *)0, 400);
      return 1;
    }

    else
    {
      v=kore_split_string(headers[(signed long int)0], " ", request, (unsigned long int)4);
      if(!(v == 3))
      {
        http_error_response(c, (struct spdy_stream *)(void *)0, 400);
        return 1;
      }

      else
      {
        skip = 0;
        host[(signed long int)0] = (char *)(void *)0;
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          signed int return_value_strncasecmp_3;
          return_value_strncasecmp_3=strncasecmp(headers[(signed long int)i], "host", (unsigned long int)4);
          if(return_value_strncasecmp_3 == 0)
          {
            v=kore_split_string(headers[(signed long int)i], ":", host, (unsigned long int)3);
            if(!(v == 2))
            {
              http_error_response(c, (struct spdy_stream *)(void *)0, 400);
              return 1;
            }

            if(!(host[1l] - host[0l] == 5l))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_strncasecmp_4=strncasecmp(host[(signed long int)0], "host", (unsigned long int)4);
              tmp_if_expr_5 = return_value_strncasecmp_4 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = host[(signed long int)1] == ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_6)
            {
              http_error_response(c, (struct spdy_stream *)(void *)0, 400);
              return 1;
            }

            host[(signed long int)1] = host[(signed long int)1] + 1l;
            skip = i;
            break;
          }

        }
        if(host[0l] == ((char *)NULL))
        {
          http_error_response(c, (struct spdy_stream *)(void *)0, 400);
          return 1;
        }

        else
        {
          signed int return_value_http_request_new_7;
          return_value_http_request_new_7=http_request_new(c, (struct spdy_stream *)(void *)0, host[(signed long int)1], request[(signed long int)0], request[(signed long int)1], request[(signed long int)2], &req);
          if(return_value_http_request_new_7 == 0)
            return 1;

          else
          {
            i = 1;
            for( ; !(i >= h); i = i + 1)
              if(!(i == skip))
              {
                p=strchr(headers[(signed long int)i], 58);
                if(!(p == ((char *)NULL)))
                {
                  tmp_post_8 = p;
                  p = p + 1l;
                  *tmp_post_8 = (char)0;
                  if((signed int)*p == 32)
                    p = p + 1l;

                  void *return_value_kore_pool_get_9;
                  return_value_kore_pool_get_9=kore_pool_get(&http_header_pool);
                  hdr = (struct http_header *)return_value_kore_pool_get_9;
                  hdr->header=kore_strdup(headers[(signed long int)i]);
                  hdr->value=kore_strdup(p);
                  do
                  {
                    hdr->list.tqe_next = (struct http_header *)(void *)0;
                    hdr->list.tqe_prev = (&req->req_headers)->tqh_last;
                    *(&req->req_headers)->tqh_last = hdr;
                    (&req->req_headers)->tqh_last = &hdr->list.tqe_next;
                  }
                  while((_Bool)0);
                  if(req->agent == ((char *)NULL))
                  {
                    return_value_strcasecmp_10=strcasecmp(hdr->header, "user-agent");
                    if(return_value_strcasecmp_10 == 0)
                      req->agent=kore_strdup(hdr->value);

                  }

                }

              }

            if(!((0x20 & (signed int)req->flags) == 0))
            {
              signed int return_value_http_request_header_11;
              return_value_http_request_header_11=http_request_header(req, "content-length", &p);
              if(return_value_http_request_header_11 == 0)
              {
                req->flags = req->flags | (unsigned char)0x02;
                http_error_response(req->owner, (struct spdy_stream *)(void *)0, 411);
                return 1;
              }

              signed long long int return_value_kore_strtonum_12;
              return_value_kore_strtonum_12=kore_strtonum(p, 10, (signed long long int)0, 0x7fffffffffffffffL, &v);
              clen = (unsigned long int)return_value_kore_strtonum_12;
              if(v == 0)
              {
                kore_mem_free((void *)p);
                req->flags = req->flags | (unsigned char)0x02;
                http_error_response(req->owner, (struct spdy_stream *)(void *)0, 411);
                return 1;
              }

              kore_mem_free((void *)p);
              if(clen == 0ul)
              {
                req->flags = req->flags | (unsigned char)0x01;
                req->flags = req->flags & (unsigned char)~0x20;
                return 1;
              }

              if(!(http_body_max >= clen))
              {
                kore_log(5, "body too large (%ld > %ld)", clen, http_body_max);
                req->flags = req->flags | (unsigned char)0x02;
                http_error_response(req->owner, (struct spdy_stream *)(void *)0, 411);
                return 1;
              }

              req->http_body=kore_buf_create((unsigned int)clen);
              kore_buf_append(req->http_body, (void *)end_headers, (unsigned int)((unsigned long int)nb->s_off - len));
              bytes_left = (signed int)(clen - ((unsigned long int)nb->s_off - len));
              if(bytes_left >= 1)
              {
                net_recv_reset(c, (unsigned int)bytes_left, http_body_recv);
                c->rnb->extra = (void *)req;
                c->rnb->flags = c->rnb->flags & (unsigned char)~0x01;
              }

              else
                if(bytes_left == 0)
                {
                  req->flags = req->flags | (unsigned char)0x01;
                  req->flags = req->flags & (unsigned char)~0x20;
                }

                else
                  http_error_response(req->owner, (struct spdy_stream *)(void *)0, 500);
            }

            return 1;
          }
        }
      }
    }
  }
}

// http_init
// file src/http.c line 66
void http_init(void)
{
  signed int prealloc;
  signed int l;
  do
  {
    (&http_requests)->tqh_first = (struct http_request *)(void *)0;
    (&http_requests)->tqh_last = &(&http_requests)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&http_requests_sleeping)->tqh_first = (struct http_request *)(void *)0;
    (&http_requests_sleeping)->tqh_last = &(&http_requests_sleeping)->tqh_first;
  }
  while((_Bool)0);
  header_buf=kore_buf_create((unsigned int)1024);
  l=snprintf(http_version_spdy, sizeof(char [32l]) /*32ul*/ , "kore (%d.%d.%d-%s)", 1, 2, 3, (const void *)"release");
  if(l == -1 || (unsigned long int)l >= sizeof(char [32l]) /*32ul*/ )
    fatal("http_init(): http_version_spdy buffer too small");

  l=snprintf(http_version, sizeof(char [32l]) /*32ul*/ , "server: kore (%d.%d.%d-%s)\r\n", 1, 2, 3, (const void *)"release");
  if(l == -1 || (unsigned long int)l >= sizeof(char [32l]) /*32ul*/ )
    fatal("http_init(): http_version buffer too small");

  http_version_len = (unsigned short int)l;
  prealloc = (signed int)(worker_max_connections / (unsigned int)10 < (unsigned int)1000 ? worker_max_connections / (unsigned int)10 : (unsigned int)1000);
  kore_pool_init(&http_request_pool, "http_request_pool", (unsigned int)sizeof(struct http_request) /*224ul*/ , (unsigned int)prealloc);
  kore_pool_init(&http_header_pool, "http_header_pool", (unsigned int)sizeof(struct http_header) /*32ul*/ , (unsigned int)(prealloc * 25));
  kore_pool_init(&http_host_pool, "http_host_pool", (unsigned int)254, (unsigned int)prealloc);
  kore_pool_init(&http_path_pool, "http_path_pool", (unsigned int)2000, (unsigned int)prealloc);
}

// http_populate_arguments
// file src/http.c line 685
signed int http_populate_arguments(struct http_request *req)
{
  unsigned int len;
  signed int i;
  signed int v;
  signed int c;
  signed int count;
  char *query;
  char *args[10l];
  char *val[3l];
  if((signed int)req->method == 1)
  {
    if(req->http_body == ((struct kore_buf *)NULL))
      return 0;

    query=http_body_text(req);
  }

  else
  {
    if(req->query_string == ((char *)NULL))
      return 0;

    query=kore_strdup(req->query_string);
  }
  count = 0;
  v=kore_split_string(query, "&", args, (unsigned long int)10);
  i = 0;
  for( ; !(i >= v); i = i + 1)
  {
    c=kore_split_string(args[(signed long int)i], "=", val, (unsigned long int)3);
    if(c == 1 || c == 2)
    {
      if(!(val[1l] == ((char *)NULL)))
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(val[(signed long int)1]);
        len = (unsigned int)return_value_strlen_1;
        http_argument_add(req, val[(signed long int)0], (void *)val[(signed long int)1], len, 6);
        count = count + 1;
      }

    }

  }
  kore_mem_free((void *)query);
  return count;
}

// http_populate_multipart_form
// file src/http.c line 843
signed int http_populate_multipart_form(struct http_request *req, signed int *v)
{
  signed int h;
  signed int i;
  signed int c;
  signed int l;
  unsigned int blen;
  unsigned int slen;
  unsigned int len;
  unsigned char *s;
  unsigned char *end;
  unsigned char *e;
  unsigned char *end_headers;
  unsigned char *data;
  char *d;
  char *val;
  char *type;
  char *boundary;
  char *fname;
  char *headers[5l];
  char *args[5l];
  char *opt[5l];
  char *name;
  *v = 0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_9;
  signed int return_value_memcmp_8;
  const unsigned short int **return_value___ctype_b_loc_13;
  const unsigned short int **return_value___ctype_b_loc_16;
  unsigned long int tmp_if_expr_21;
  unsigned long int return_value_strlen_19;
  unsigned long int return_value_strlen_20;
  if(!((signed int)req->method == 1))
    return 0;

  else
  {
    signed int return_value_http_request_header_1;
    return_value_http_request_header_1=http_request_header(req, "content-type", &type);
    if(return_value_http_request_header_1 == 0)
      return 0;

    else
    {
      h=kore_split_string(type, ";", args, (unsigned long int)3);
      if(!(h == 2))
      {
        kore_mem_free((void *)type);
        return 0;
      }

      else
      {
        signed int return_value_strcasecmp_2;
        return_value_strcasecmp_2=strcasecmp(args[(signed long int)0], "multipart/form-data");
        if(!(return_value_strcasecmp_2 == 0))
        {
          kore_mem_free((void *)type);
          return 0;
        }

        else
        {
          val=strchr(args[(signed long int)1], 61);
          if(val == ((char *)NULL))
          {
            kore_mem_free((void *)type);
            return 0;
          }

          else
          {
            val = val + 1l;
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(val);
            slen = (unsigned int)return_value_strlen_3;
            void *return_value_kore_malloc_4;
            return_value_kore_malloc_4=kore_malloc((unsigned long int)(slen + (unsigned int)3));
            boundary = (char *)return_value_kore_malloc_4;
            signed int return_value_kore_snprintf_5;
            return_value_kore_snprintf_5=kore_snprintf(boundary, (unsigned long int)(slen + (unsigned int)3), &l, "--%s", val);
            if(return_value_kore_snprintf_5 == 0)
            {
              kore_mem_free((void *)boundary);
              kore_mem_free((void *)type);
              return 0;
            }

            else
            {
              slen = (unsigned int)l;
              kore_mem_free((void *)type);
              req->multipart_body=http_body_bytes(req, &blen);
              if(!(blen >= 2u * slen) || !(slen >= 3u))
              {
                kore_mem_free((void *)boundary);
                return 0;
              }

              else
              {
                end = (req->multipart_body + (signed long int)blen) - (signed long int)2;
                if(!(end >= req->multipart_body))
                  tmp_if_expr_6 = (_Bool)1;

                else
                  tmp_if_expr_6 = end - (signed long int)2 < req->multipart_body ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_6)
                {
                  kore_mem_free((void *)boundary);
                  return 0;
                }

                else
                {
                  signed int return_value_memcmp_7;
                  return_value_memcmp_7=memcmp((const void *)((end - (signed long int)slen) - (signed long int)2), (const void *)boundary, (unsigned long int)slen);
                  if(!(return_value_memcmp_7 == 0))
                    tmp_if_expr_9 = (_Bool)1;

                  else
                  {
                    return_value_memcmp_8=memcmp((const void *)(end - (signed long int)2), (const void *)"--", (unsigned long int)2);
                    tmp_if_expr_9 = return_value_memcmp_8 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_9)
                  {
                    kore_mem_free((void *)boundary);
                    return 0;
                  }

                  else
                  {
                    s = req->multipart_body + (signed long int)slen + (signed long int)2;
                    while(!(s >= end))
                    {
                      void *return_value_kore_mem_find_10;
                      return_value_kore_mem_find_10=kore_mem_find((void *)s, (unsigned long int)(end - s), (void *)boundary, slen);
                      e = (unsigned char *)return_value_kore_mem_find_10;
                      if(e == ((unsigned char *)NULL))
                      {
                        kore_mem_free((void *)boundary);
                        return 0;
                      }

                      *(e - (signed long int)2) = (unsigned char)0;
                      void *return_value_kore_mem_find_11;
                      return_value_kore_mem_find_11=kore_mem_find((void *)s, (unsigned long int)((e - (signed long int)2) - s), (void *)"\r\n\r\n", (unsigned int)4);
                      end_headers = (unsigned char *)return_value_kore_mem_find_11;
                      if(end_headers == ((unsigned char *)NULL))
                      {
                        kore_mem_free((void *)boundary);
                        return 0;
                      }

                      *end_headers = (unsigned char)0;
                      data = end_headers + (signed long int)4;
                      h=kore_split_string((char *)s, "\r\n", headers, (unsigned long int)5);
                      i = 0;
                      for( ; !(i >= h); i = i + 1)
                      {
                        c=kore_split_string(headers[(signed long int)i], ":", args, (unsigned long int)5);
                        if(c == 2)
                        {
                          signed int return_value_strcasecmp_12;
                          return_value_strcasecmp_12=strcasecmp(args[(signed long int)0], "content-disposition");
                          if(return_value_strcasecmp_12 == 0)
                          {
                            d = args[(signed long int)1];
                            do
                            {
                              return_value___ctype_b_loc_13=__ctype_b_loc();
                              if((8192 & (signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)*d]) == 0)
                                break;

                              d = d + 1l;
                            }
                            while((_Bool)1);
                            c=kore_split_string(d, ";", opt, (unsigned long int)5);
                            if(c >= 2)
                            {
                              signed int return_value_strcasecmp_14;
                              return_value_strcasecmp_14=strcasecmp(opt[(signed long int)0], "form-data");
                              if(return_value_strcasecmp_14 == 0)
                              {
                                val=strchr(opt[(signed long int)1], 61);
                                if(!(val == ((char *)NULL)))
                                {
                                  unsigned long int return_value_strlen_15;
                                  return_value_strlen_15=strlen(val);
                                  if(return_value_strlen_15 >= 3ul)
                                  {
                                    val = val + 1l;
                                    kore_strip_chars(val, (char)34, &name);
                                    if(opt[2l] == ((char *)NULL))
                                    {
                                      *v = *v + 1;
                                      http_argument_add(req, name, (void *)data, (unsigned int)((e - (signed long int)2) - data), 6);
                                      kore_mem_free((void *)name);
                                    }

                                    else
                                    {
                                      d = opt[(signed long int)2];
                                      do
                                      {
                                        return_value___ctype_b_loc_16=__ctype_b_loc();
                                        if((8192 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)*d]) == 0)
                                          break;

                                        d = d + 1l;
                                      }
                                      while((_Bool)1);
                                      unsigned long int return_value_strlen_17;
                                      return_value_strlen_17=strlen("filename=");
                                      unsigned long int return_value_strlen_18;
                                      return_value_strlen_18=strlen(d);
                                      if(!(return_value_strlen_17 >= return_value_strlen_18))
                                      {
                                        return_value_strlen_19=strlen("filename=");
                                        tmp_if_expr_21 = return_value_strlen_19;
                                      }

                                      else
                                      {
                                        return_value_strlen_20=strlen(d);
                                        tmp_if_expr_21 = return_value_strlen_20;
                                      }
                                      len = (unsigned int)tmp_if_expr_21;
                                      signed int return_value_strncasecmp_23;
                                      return_value_strncasecmp_23=strncasecmp(d, "filename=", (unsigned long int)len);
                                      if(return_value_strncasecmp_23 == 0)
                                      {
                                        val=strchr(d, 61);
                                        if(val == ((char *)NULL))
                                        {
                                          kore_mem_free((void *)name);
                                          goto __CPROVER_DUMP_L28;
                                        }

                                        val = val + 1l;
                                        kore_strip_chars(val, (char)34, &fname);
                                        unsigned long int return_value_strlen_22;
                                        return_value_strlen_22=strlen(fname);
                                        if(return_value_strlen_22 >= 1ul)
                                        {
                                          *v = *v + 1;
                                          http_file_add(req, name, fname, data, (unsigned int)((e - (signed long int)2) - data));
                                        }

                                        kore_mem_free((void *)fname);
                                      }

                                      kore_mem_free((void *)name);
                                    }
                                  }

                                }

                              }

                            }

                          }

                        }


                      __CPROVER_DUMP_L28:
                        ;
                      }
                      s = e + (signed long int)slen + (signed long int)2;
                    }
                    kore_mem_free((void *)boundary);
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// http_process
// file src/http.c line 233
void http_process(void)
{
  unsigned int count;
  struct http_request *req;
  struct http_request *next;
  count = (unsigned int)0;
  req = (&http_requests)->tqh_first;
  for( ; !(req == ((struct http_request *)NULL)); req = next)
  {
    if(count >= http_request_limit)
      break;

    next = req->list.tqe_next;
    if(!((0x02 & (signed int)req->flags) == 0))
      http_request_free(req);

    else
    {
      if(!((0x04 & (signed int)req->flags) == 0))
        fatal("http_process: sleeping request on list");

      if(!((0x01 & (signed int)req->flags) == 0))
      {
        count = count + 1u;
        http_process_request(req, 0);
      }

    }
  }
}

// http_process_request
// file src/http.c line 262
void http_process_request(struct http_request *req, signed int retry_only)
{
  struct kore_module_handle *hdlr;
  signed int r;
  signed int (*cb)(struct http_request *);
  _Bool tmp_if_expr_1;
  if((0x02 & (signed int)req->flags) == 0)
  {
    if(!(req->hdlr == ((struct kore_module_handle *)NULL)))
      hdlr = req->hdlr;

    else
      hdlr=kore_module_handler_find(req->host, req->path);
    req->start=kore_time_ms();
    if(hdlr == ((struct kore_module_handle *)NULL))
      r=http_generic_404(req);

    else
    {
      if(!(req->hdlr == hdlr))
        tmp_if_expr_1 = hdlr->auth != (struct kore_auth *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        r=kore_auth_run(req, hdlr->auth);

      else
        r = 1;
      switch(r)
      {
        case 1:
        {
          req->hdlr = hdlr;
          cb = (signed int (*)(struct http_request *))hdlr->addr;
          worker->active_hdlr = hdlr;
          r=cb(req);
        }
        case 2:
          break;
        case 0:
        {
          r = 1;
          break;
        }
        default:
          fatal("kore_auth() returned unknown %d", r);
      }
    }
    req->end=kore_time_ms();
    req->total = req->total + (req->end - req->start);
    if(retry_only == 1 && !(r == 2))
      fatal("http_process_request: expected RETRY but got %d", r);

    switch(r)
    {
      case 1:
      {
        r=net_send_flush(req->owner);
        if(r == 0)
          kore_connection_disconnect(req->owner);

        break;
      }
      case 0:
      {
        kore_connection_disconnect(req->owner);
        break;
      }
      case 2:
        goto __CPROVER_DUMP_L22;
      default:
        fatal("A page handler returned an unknown result: %d", r);
    }
    if(!(hdlr == ((struct kore_module_handle *)NULL)))
    {
      if(!(hdlr->dom->accesslog == -1))
        kore_accesslog(req);

    }

    req->flags = req->flags | (unsigned char)0x02;
  }


__CPROVER_DUMP_L22:
  ;
}

// http_request_free
// file src/http.c line 350
void http_request_free(struct http_request *req)
{
  struct kore_task *t;
  struct kore_task *nt;
  signed int pending_tasks;
  struct kore_pgsql *pgsql;
  struct http_file *f;
  struct http_file *fnext;
  struct http_arg *q;
  struct http_arg *qnext;
  struct http_header *hdr;
  struct http_header *next;
  pending_tasks = 0;
  t = (&req->tasks)->lh_first;
  for( ; !(t == ((struct kore_task *)NULL)); t = nt)
  {
    nt = t->rlist.le_next;
    signed int return_value_kore_task_finished_1;
    return_value_kore_task_finished_1=kore_task_finished(t);
    if(return_value_kore_task_finished_1 == 0)
      pending_tasks = pending_tasks + 1;

    else
      kore_task_destroy(t);
  }
  if(pending_tasks == 0)
  {
    while(!(req->pgsqls.lh_first == ((struct kore_pgsql *)NULL)))
    {
      pgsql = (&req->pgsqls)->lh_first;
      kore_pgsql_cleanup(pgsql);
    }
    if(!((0x10 & (signed int)req->flags) == 0))
      kore_pgsql_queue_remove(req);

    kore_pool_put(&http_host_pool, (void *)req->host);
    kore_pool_put(&http_path_pool, (void *)req->path);
    req->host = (char *)(void *)0;
    req->path = (char *)(void *)0;
    do
    {
      if(!(req->list.tqe_next == ((struct http_request *)NULL)))
        req->list.tqe_next->list.tqe_prev = req->list.tqe_prev;

      else
        (&http_requests)->tqh_last = req->list.tqe_prev;
      *req->list.tqe_prev = req->list.tqe_next;
    }
    while((_Bool)0);
    do
    {
      if(!(req->olist.tqe_next == ((struct http_request *)NULL)))
        req->olist.tqe_next->olist.tqe_prev = req->olist.tqe_prev;

      else
        (&req->owner->http_requests)->tqh_last = req->olist.tqe_prev;
      *req->olist.tqe_prev = req->olist.tqe_next;
    }
    while((_Bool)0);
    hdr = (&req->resp_headers)->tqh_first;
    for( ; !(hdr == ((struct http_header *)NULL)); hdr = next)
    {
      next = hdr->list.tqe_next;
      do
      {
        if(!(hdr->list.tqe_next == ((struct http_header *)NULL)))
          hdr->list.tqe_next->list.tqe_prev = hdr->list.tqe_prev;

        else
          (&req->resp_headers)->tqh_last = hdr->list.tqe_prev;
        *hdr->list.tqe_prev = hdr->list.tqe_next;
      }
      while((_Bool)0);
      kore_mem_free((void *)hdr->header);
      kore_mem_free((void *)hdr->value);
      kore_pool_put(&http_header_pool, (void *)hdr);
    }
    hdr = (&req->req_headers)->tqh_first;
    for( ; !(hdr == ((struct http_header *)NULL)); hdr = next)
    {
      next = hdr->list.tqe_next;
      do
      {
        if(!(hdr->list.tqe_next == ((struct http_header *)NULL)))
          hdr->list.tqe_next->list.tqe_prev = hdr->list.tqe_prev;

        else
          (&req->req_headers)->tqh_last = hdr->list.tqe_prev;
        *hdr->list.tqe_prev = hdr->list.tqe_next;
      }
      while((_Bool)0);
      kore_mem_free((void *)hdr->header);
      kore_mem_free((void *)hdr->value);
      kore_pool_put(&http_header_pool, (void *)hdr);
    }
    q = (&req->arguments)->tqh_first;
    for( ; !(q == ((struct http_arg *)NULL)); q = qnext)
    {
      qnext = q->list.tqe_next;
      do
      {
        if(!(q->list.tqe_next == ((struct http_arg *)NULL)))
          q->list.tqe_next->list.tqe_prev = q->list.tqe_prev;

        else
          (&req->arguments)->tqh_last = q->list.tqe_prev;
        *q->list.tqe_prev = q->list.tqe_next;
      }
      while((_Bool)0);
      kore_mem_free((void *)q->name);
      if(!(q->value == NULL))
        kore_mem_free(q->value);

      if(!(q->s_value == ((char *)NULL)))
        kore_mem_free((void *)q->s_value);

      kore_mem_free((void *)q);
    }
    f = (&req->files)->tqh_first;
    for( ; !(f == ((struct http_file *)NULL)); f = fnext)
    {
      fnext = f->list.tqe_next;
      do
      {
        if(!(f->list.tqe_next == ((struct http_file *)NULL)))
          f->list.tqe_next->list.tqe_prev = f->list.tqe_prev;

        else
          (&req->files)->tqh_last = f->list.tqe_prev;
        *f->list.tqe_prev = f->list.tqe_next;
      }
      while((_Bool)0);
      kore_mem_free((void *)f->filename);
      kore_mem_free((void *)f->name);
      kore_mem_free((void *)f);
    }
    if(!(req->http_body == ((struct kore_buf *)NULL)))
      kore_buf_free(req->http_body);

    if(!(req->multipart_body == ((unsigned char *)NULL)))
      kore_mem_free((void *)req->multipart_body);

    if(!(req->agent == ((char *)NULL)))
      kore_mem_free((void *)req->agent);

    if(!(req->hdlr_extra == NULL))
    {
      if((0x40 & (signed int)req->flags) == 0)
        kore_mem_free(req->hdlr_extra);

    }

    kore_pool_put(&http_request_pool, (void *)req);
    http_request_count = http_request_count - 1;
  }

}

// http_request_header
// file includes/http.h line 229
signed int http_request_header(struct http_request *req, const char *header, char **out)
{
  signed int r;
  struct http_header *hdr;
  if((signed int)req->owner->proto == 1)
    r=spdy_stream_get_header(req->stream->hblock, header, out);

  else
  {
    hdr = (&req->req_headers)->tqh_first;
    for( ; !(hdr == ((struct http_header *)NULL)); hdr = hdr->list.tqe_next)
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(hdr->header, header);
      if(return_value_strcasecmp_3 == 0)
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(hdr->value);
        r = (signed int)(return_value_strlen_1 + (unsigned long int)1);
        void *return_value_kore_malloc_2;
        return_value_kore_malloc_2=kore_malloc((unsigned long int)r);
        *out = (char *)return_value_kore_malloc_2;
        kore_strlcpy(*out, hdr->value, (unsigned long int)r);
        return 1;
      }

    }
    r = 0;
  }
  return r;
}

// http_request_new
// file src/http.c line 102
signed int http_request_new(struct connection *c, struct spdy_stream *s, const char *host, const char *method, const char *path, const char *version, struct http_request **out)
{
  char *p;
  struct http_request *req;
  signed int m;
  signed int flags;
  unsigned long int hostlen;
  unsigned long int pathlen;
  hostlen=strlen(host);
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  char *tmp_post_10;
  if(hostlen >= 253ul)
  {
    http_error_response(c, s, 500);
    return 0;
  }

  else
  {
    pathlen=strlen(path);
    if(pathlen >= 1999ul)
    {
      http_error_response(c, s, 414);
      return 0;
    }

    else
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(version, "http/1.1");
      if(!(return_value_strcasecmp_1 == 0))
      {
        http_error_response(c, s, 505);
        return 0;
      }

      else
      {
        signed int return_value_strcasecmp_6;
        return_value_strcasecmp_6=strcasecmp(method, "get");
        if(return_value_strcasecmp_6 == 0)
        {
          m = 0;
          flags = 0x01;
        }

        else
        {
          return_value_strcasecmp_5=strcasecmp(method, "delete");
          if(return_value_strcasecmp_5 == 0)
          {
            m = 3;
            flags = 0x01;
          }

          else
          {
            return_value_strcasecmp_4=strcasecmp(method, "post");
            if(return_value_strcasecmp_4 == 0)
            {
              m = 1;
              flags = 0x20;
            }

            else
            {
              return_value_strcasecmp_3=strcasecmp(method, "put");
              if(return_value_strcasecmp_3 == 0)
              {
                m = 2;
                flags = 0x20;
              }

              else
              {
                return_value_strcasecmp_2=strcasecmp(method, "head");
                if(return_value_strcasecmp_2 == 0)
                {
                  m = 4;
                  flags = 0x01;
                }

                else
                {
                  http_error_response(c, s, 400);
                  return 0;
                }
              }
            }
          }
        }
        void *return_value_kore_pool_get_7;
        return_value_kore_pool_get_7=kore_pool_get(&http_request_pool);
        req = (struct http_request *)return_value_kore_pool_get_7;
        req->end = (unsigned long int)0;
        req->total = (unsigned long int)0;
        req->start = (unsigned long int)0;
        req->owner = c;
        req->status = (unsigned short int)0;
        req->stream = s;
        req->method = (unsigned char)m;
        req->hdlr = (struct kore_module_handle *)(void *)0;
        req->agent = (char *)(void *)0;
        req->flags = (unsigned char)flags;
        req->fsm_state = (unsigned char)0;
        req->http_body = (struct kore_buf *)(void *)0;
        req->hdlr_extra = (void *)0;
        req->query_string = (char *)(void *)0;
        req->multipart_body = (unsigned char *)(void *)0;
        p=strrchr(host, 58);
        if(!(p == ((char *)NULL)))
          *p = (char)0;

        void *return_value_kore_pool_get_8;
        return_value_kore_pool_get_8=kore_pool_get(&http_host_pool);
        req->host = (char *)return_value_kore_pool_get_8;
        memcpy((void *)req->host, (const void *)host, hostlen);
        req->host[(signed long int)hostlen] = (char)0;
        void *return_value_kore_pool_get_9;
        return_value_kore_pool_get_9=kore_pool_get(&http_path_pool);
        req->path = (char *)return_value_kore_pool_get_9;
        memcpy((void *)req->path, (const void *)path, pathlen);
        req->path[(signed long int)pathlen] = (char)0;
        req->query_string=strchr(req->path, 63);
        if(!(req->query_string == ((char *)NULL)))
        {
          tmp_post_10 = req->query_string;
          req->query_string = req->query_string + 1l;
          *tmp_post_10 = (char)0;
        }

        do
        {
          (&req->resp_headers)->tqh_first = (struct http_header *)(void *)0;
          (&req->resp_headers)->tqh_last = &(&req->resp_headers)->tqh_first;
        }
        while((_Bool)0);
        do
        {
          (&req->req_headers)->tqh_first = (struct http_header *)(void *)0;
          (&req->req_headers)->tqh_last = &(&req->req_headers)->tqh_first;
        }
        while((_Bool)0);
        do
        {
          (&req->arguments)->tqh_first = (struct http_arg *)(void *)0;
          (&req->arguments)->tqh_last = &(&req->arguments)->tqh_first;
        }
        while((_Bool)0);
        do
        {
          (&req->files)->tqh_first = (struct http_file *)(void *)0;
          (&req->files)->tqh_last = &(&req->files)->tqh_first;
        }
        while((_Bool)0);
        if(!(s == ((struct spdy_stream *)NULL)))
        {
          signed int return_value_http_request_header_11;
          return_value_http_request_header_11=http_request_header(req, "user-agent", &req->agent);
          if(return_value_http_request_header_11 == 0)
            req->agent=kore_strdup("unknown");

        }

        do
          (&req->tasks)->lh_first = (struct kore_task *)(void *)0;
        while((_Bool)0);
        do
          (&req->pgsqls)->lh_first = (struct kore_pgsql *)(void *)0;
        while((_Bool)0);
        http_request_count = http_request_count + 1;
        do
        {
          req->list.tqe_next = (&http_requests)->tqh_first;
          if(!(req->list.tqe_next == ((struct http_request *)NULL)))
            (&http_requests)->tqh_first->list.tqe_prev = &req->list.tqe_next;

          else
            (&http_requests)->tqh_last = &req->list.tqe_next;
          (&http_requests)->tqh_first = req;
          req->list.tqe_prev = &(&http_requests)->tqh_first;
        }
        while((_Bool)0);
        do
        {
          req->olist.tqe_next = (struct http_request *)(void *)0;
          req->olist.tqe_prev = (&c->http_requests)->tqh_last;
          *(&c->http_requests)->tqh_last = req;
          (&c->http_requests)->tqh_last = &req->olist.tqe_next;
        }
        while((_Bool)0);
        if(!(out == ((struct http_request **)NULL)))
          *out = req;

        return 1;
      }
    }
  }
}

// http_request_sleep
// file src/http.c line 209
void http_request_sleep(struct http_request *req)
{
  if((0x04 & (signed int)req->flags) == 0)
  {
    req->flags = req->flags | (unsigned char)0x04;
    do
    {
      if(!(req->list.tqe_next == ((struct http_request *)NULL)))
        req->list.tqe_next->list.tqe_prev = req->list.tqe_prev;

      else
        (&http_requests)->tqh_last = req->list.tqe_prev;
      *req->list.tqe_prev = req->list.tqe_next;
    }
    while((_Bool)0);
    do
    {
      req->list.tqe_next = (struct http_request *)(void *)0;
      req->list.tqe_prev = (&http_requests_sleeping)->tqh_last;
      *(&http_requests_sleeping)->tqh_last = req;
      (&http_requests_sleeping)->tqh_last = &req->list.tqe_next;
    }
    while((_Bool)0);
  }

}

// http_request_wakeup
// file includes/http.h line 222
void http_request_wakeup(struct http_request *req)
{
  if(!((0x04 & (signed int)req->flags) == 0))
  {
    req->flags = req->flags & (unsigned char)~0x04;
    do
    {
      if(!(req->list.tqe_next == ((struct http_request *)NULL)))
        req->list.tqe_next->list.tqe_prev = req->list.tqe_prev;

      else
        (&http_requests_sleeping)->tqh_last = req->list.tqe_prev;
      *req->list.tqe_prev = req->list.tqe_next;
    }
    while((_Bool)0);
    do
    {
      req->list.tqe_next = (struct http_request *)(void *)0;
      req->list.tqe_prev = (&http_requests)->tqh_last;
      *(&http_requests)->tqh_last = req;
      (&http_requests)->tqh_last = &req->list.tqe_next;
    }
    while((_Bool)0);
  }

}

// http_response
// file includes/http.h line 226
void http_response(struct http_request *req, signed int status, void *d, unsigned int l)
{
  req->status = (unsigned short int)status;
  switch((signed int)req->owner->proto)
  {
    case 1:
    {
      http_response_spdy(req, req->owner, req->stream, status, d, l);
      break;
    }
    case 2:
    {
      http_response_normal(req, req->owner, status, d, l);
      break;
    }
    default:
      fatal("http_response() bad proto %d", req->owner->proto);
  }
}

// http_response_header
// file includes/http.h line 231
void http_response_header(struct http_request *req, const char *header, const char *value)
{
  struct http_header *hdr;
  void *return_value_kore_pool_get_1;
  return_value_kore_pool_get_1=kore_pool_get(&http_header_pool);
  hdr = (struct http_header *)return_value_kore_pool_get_1;
  hdr->header=kore_strdup(header);
  hdr->value=kore_strdup(value);
  do
  {
    hdr->list.tqe_next = (struct http_header *)(void *)0;
    hdr->list.tqe_prev = (&req->resp_headers)->tqh_last;
    *(&req->resp_headers)->tqh_last = hdr;
    (&req->resp_headers)->tqh_last = &hdr->list.tqe_next;
  }
  while((_Bool)0);
}

// http_response_normal
// file src/http.c line 1222
static void http_response_normal(struct http_request *req, struct connection *c, signed int status, void *d, unsigned int len)
{
  struct http_header *hdr;
  char *conn;
  signed int connection_close;
  header_buf->offset = (unsigned long int)0;
  const char *return_value_http_status_text_1;
  return_value_http_status_text_1=http_status_text(status);
  kore_buf_appendf(header_buf, "HTTP/1.1 %d %s\r\n", status, return_value_http_status_text_1);
  kore_buf_append(header_buf, (void *)http_version, (unsigned int)http_version_len);
  if(!((0x40 & (signed int)c->flags) == 0))
    connection_close = 1;

  else
    connection_close = 0;
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(connection_close == 0 && !(req == ((struct http_request *)NULL)))
  {
    signed int return_value_http_request_header_4;
    return_value_http_request_header_4=http_request_header(req, "connection", &conn);
    if(!(return_value_http_request_header_4 == 0))
    {
      if((signed int)*conn == 99)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*conn == 67 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        return_value_strcasecmp_2=strcasecmp(conn, "close");
        if(return_value_strcasecmp_2 == 0)
          connection_close = 1;

      }

      kore_mem_free((void *)conn);
    }

  }

  if(connection_close == 0 && !(http_keepalive_time == 0))
  {
    kore_buf_appendf(header_buf, "connection: keep-alive\r\n");
    kore_buf_appendf(header_buf, "keep-alive: timeout=%d\r\n", http_keepalive_time);
  }

  else
  {
    c->flags = c->flags | (unsigned char)0x40;
    kore_buf_appendf(header_buf, "connection: close\r\n");
  }
  if(!(http_hsts_enable == 0ul))
  {
    kore_buf_appendf(header_buf, "strict-transport-security: ");
    kore_buf_appendf(header_buf, "max-age=%lu; includeSubDomains\r\n", http_hsts_enable);
  }

  if(!(req == ((struct http_request *)NULL)))
  {
    hdr = (&req->resp_headers)->tqh_first;
    for( ; !(hdr == ((struct http_header *)NULL)); hdr = hdr->list.tqe_next)
      kore_buf_appendf(header_buf, "%s: %s\r\n", hdr->header, hdr->value);
    if(status >= 200 && !(status == 204))
    {
      if((0x80 & (signed int)req->flags) == 0)
        kore_buf_appendf(header_buf, "content-length: %d\r\n", len);

    }

  }

  else
    if(status >= 200 && !(status == 204))
      kore_buf_appendf(header_buf, "content-length: %d\r\n", len);

  kore_buf_append(header_buf, (void *)"\r\n", (unsigned int)2);
  net_send_queue(c, (void *)header_buf->data, (unsigned int)header_buf->offset, (struct spdy_stream *)(void *)0, 0);
  if(!(d == NULL) && !(req == ((struct http_request *)NULL)))
  {
    if(!((signed int)req->method == 4))
      net_send_queue(c, d, len, (struct spdy_stream *)(void *)0, 0);

  }

  if((0x40 & (signed int)c->flags) == 0)
    net_recv_reset(c, (unsigned int)http_header_max, http_header_recv);

}

// http_response_spdy
// file src/http.c line 1167
static void http_response_spdy(struct http_request *req, struct connection *c, struct spdy_stream *s, signed int status, void *d, unsigned int len)
{
  unsigned int hlen;
  struct http_header *hdr;
  unsigned char *htext;
  struct spdy_header_block *hblock;
  char sbuf[512l];
  const char *return_value_http_status_text_1;
  return_value_http_status_text_1=http_status_text(status);
  snprintf(sbuf, sizeof(char [512l]) /*512ul*/ , "%d %s", status, return_value_http_status_text_1);
  hblock=spdy_header_block_create(0);
  spdy_header_block_add(hblock, ":status", sbuf);
  spdy_header_block_add(hblock, ":version", "HTTP/1.1");
  spdy_header_block_add(hblock, ":server", http_version_spdy);
  if(!(http_hsts_enable == 0ul))
  {
    snprintf(sbuf, sizeof(char [512l]) /*512ul*/ , "max-age=%lu; includeSubDomains", http_hsts_enable);
    spdy_header_block_add(hblock, ":strict-transport-security", sbuf);
  }

  if(!(req == ((struct http_request *)NULL)))
  {
    hdr = (&req->resp_headers)->tqh_first;
    for( ; !(hdr == ((struct http_header *)NULL)); hdr = hdr->list.tqe_next)
      spdy_header_block_add(hblock, hdr->header, hdr->value);
  }

  htext=spdy_header_block_release(c, hblock, &hlen);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(htext == ((unsigned char *)NULL))
    spdy_session_teardown(c, (unsigned char)2);

  else
  {
    spdy_frame_send(c, (unsigned short int)2, (unsigned char)0, hlen, s, (unsigned int)0);
    net_send_queue(c, (void *)htext, hlen, (struct spdy_stream *)(void *)0, 0);
    kore_mem_free((void *)htext);
    if(len >= 1u && !(req == ((struct http_request *)NULL)))
    {
      if(!((signed int)req->method == 4))
      {
        s->send_size = s->send_size + (unsigned long int)len;
        s->flags = s->flags | (unsigned char)0x20;
        if(!(d == NULL))
          net_send_queue(c, d, len, s, 0);

      }

    }

    if(!(req == ((struct http_request *)NULL)))
      tmp_if_expr_2 = (signed int)req->method == 4 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if(len == 0u)
        tmp_if_expr_3 = !(((signed int)s->flags & 0x40) != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      spdy_frame_send(c, (unsigned short int)99, (unsigned char)0x01, (unsigned int)0, s, (unsigned int)0);
      spdy_stream_close(c, s, 0);
    }

  }
}

// http_response_stream
// file src/http.c line 478
void http_response_stream(struct http_request *req, signed int status, void *base, unsigned long int len, signed int (*cb)(struct netbuf *), void *arg)
{
  struct netbuf *nb;
  req->status = (unsigned short int)status;
  switch((signed int)req->owner->proto)
  {
    case 1:
    {
      http_response_spdy(req, req->owner, req->stream, status, (void *)0, (unsigned int)len);
      break;
    }
    case 2:
    {
      http_response_normal(req, req->owner, status, (void *)0, (unsigned int)len);
      break;
    }
    default:
      fatal("http_response_stream() bad proto %d", req->owner->proto);
  }
  if(!((signed int)req->method == 4))
  {
    net_send_stream(req->owner, base, (unsigned int)len, req->stream, cb, &nb);
    nb->extra = arg;
  }

}

// http_state_run
// file src/http.c line 1040
signed int http_state_run(struct http_state *states, unsigned char elm, struct http_request *req)
{
  signed int r;
  signed int done = 0;
  if(done == 0)
  {
    if((signed int)req->fsm_state >= (signed int)elm)
      fatal("http_state_run: fsm_state > elm (%d/%d)", req->fsm_state, elm);

    r=(states + (signed long int)req->fsm_state)->cb(req);
    if(r == 0)
    {
      return 1;
      return 2;
      done = 1;
    }

    fatal("http_state_run: unknown return value %d", r);
  }

  req->fsm_state = (unsigned char)0;
  return 1;
}

// http_status_text
// file src/http.c line 1295
const char * http_status_text(signed int status)
{
  char *r;
  switch(status)
  {
    case 100:
    {
      r = "Continue";
      break;
    }
    case 101:
    {
      r = "Switching Protocols";
      break;
    }
    case 200:
    {
      r = "OK";
      break;
    }
    case 201:
    {
      r = "Created";
      break;
    }
    case 202:
    {
      r = "Accepted";
      break;
    }
    case 203:
    {
      r = "Non-Authoritative Information";
      break;
    }
    case 204:
    {
      r = "No Content";
      break;
    }
    case 205:
    {
      r = "Reset Content";
      break;
    }
    case 206:
    {
      r = "Partial Content";
      break;
    }
    case 300:
    {
      r = "Multiple Choices";
      break;
    }
    case 301:
    {
      r = "Moved Permanently";
      break;
    }
    case 302:
    {
      r = "Found";
      break;
    }
    case 303:
    {
      r = "See Other";
      break;
    }
    case 304:
    {
      r = "Not Modified";
      break;
    }
    case 305:
    {
      r = "Use Proxy";
      break;
    }
    case 307:
    {
      r = "Temporary Redirect";
      break;
    }
    case 400:
    {
      r = "Bad Request";
      break;
    }
    case 401:
    {
      r = "Unauthorized";
      break;
    }
    case 402:
    {
      r = "Payment Required";
      break;
    }
    case 403:
    {
      r = "Forbidden";
      break;
    }
    case 404:
    {
      r = "Not Found";
      break;
    }
    case 405:
    {
      r = "Method Not Allowed";
      break;
    }
    case 406:
    {
      r = "Not Acceptable";
      break;
    }
    case 407:
    {
      r = "Proxy Authentication Required";
      break;
    }
    case 408:
    {
      r = "Request Time-out";
      break;
    }
    case 409:
    {
      r = "Conflict";
      break;
    }
    case 410:
    {
      r = "Gone";
      break;
    }
    case 411:
    {
      r = "Length Required";
      break;
    }
    case 412:
    {
      r = "Precondition Failed";
      break;
    }
    case 413:
    {
      r = "Request Entity Too Large";
      break;
    }
    case 414:
    {
      r = "Request-URI Too Large";
      break;
    }
    case 415:
    {
      r = "Unsupported Media Type";
      break;
    }
    case 416:
    {
      r = "Requested range not satisfiable";
      break;
    }
    case 417:
    {
      r = "Expectation Failed";
      break;
    }
    case 500:
    {
      r = "Internal Server Error";
      break;
    }
    case 501:
    {
      r = "Not Implemented";
      break;
    }
    case 502:
    {
      r = "Bad Gateway";
      break;
    }
    case 503:
    {
      r = "Service Unavailable";
      break;
    }
    case 504:
    {
      r = "Gateway Time-out";
      break;
    }
    case 505:
    {
      r = "HTTP Version not supported";
      break;
    }
    default:
      r = "";
  }
  return r;
}

// kore_accesslog
// file src/accesslog.c line 154
void kore_accesslog(struct http_request *req)
{
  signed long int len;
  struct kore_log_packet logpacket;
  logpacket.addrtype = req->owner->addrtype;
  if((signed int)logpacket.addrtype == 2)
    memcpy((void *)logpacket.addr, (const void *)&req->owner->addr.ipv4.sin_addr, sizeof(struct in_addr) /*4ul*/ );

  else
    memcpy((void *)logpacket.addr, (const void *)&req->owner->addr.ipv6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
  logpacket.status = (signed int)req->status;
  logpacket.method = req->method;
  logpacket.worker_id = (unsigned short int)worker->id;
  logpacket.worker_cpu = (unsigned short int)worker->cpu;
  logpacket.time_req = (unsigned short int)req->total;
  kore_strlcpy(logpacket.host, req->host, sizeof(char [254l]) /*254ul*/ );
  kore_strlcpy(logpacket.path, req->path, sizeof(char [2000l]) /*2000ul*/ );
  if(!(req->agent == ((char *)NULL)))
    kore_strlcpy(logpacket.agent, req->agent, sizeof(char [256l]) /*256ul*/ );

  else
    kore_strlcpy(logpacket.agent, "unknown", sizeof(char [256l]) /*256ul*/ );
  memset((void *)logpacket.cn, 0, sizeof(char [65l]) /*65ul*/ );
  if(!(req->owner->cert == ((struct x509_st *)NULL)))
  {
    struct X509_name_st *return_value_X509_get_subject_name_1;
    return_value_X509_get_subject_name_1=X509_get_subject_name(req->owner->cert);
    signed int return_value_X509_NAME_get_text_by_NID_2;
    return_value_X509_NAME_get_text_by_NID_2=X509_NAME_get_text_by_NID(return_value_X509_get_subject_name_1, 13, logpacket.cn, (signed int)sizeof(char [65l]) /*65ul*/ );
    if(return_value_X509_NAME_get_text_by_NID_2 == -1)
      kore_log(4, "client cert without a CN?");

  }

  len=send(accesslog_fd[(signed long int)1], (const void *)&logpacket, sizeof(struct kore_log_packet) /*2608ul*/ , 0);
  if(len == -1l)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    kore_log(4, "kore_accesslog(): send(): %s", return_value_strerror_4);
  }

  else
    if(!((unsigned long int)len == sizeof(struct kore_log_packet) /*2608ul*/ ))
      kore_log(4, "short accesslog packet sent");

}

// kore_accesslog_init
// file includes/kore.h line 421
void kore_accesslog_init(void)
{
  signed int return_value_socketpair_3;
  return_value_socketpair_3=socketpair(1, 1, 0, accesslog_fd);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_socketpair_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("kore_accesslog_init(): socketpair() %s", return_value_strerror_2);
  }

}

// kore_accesslog_wait
// file includes/kore.h line 422
signed int kore_accesslog_wait(void)
{
  signed long int len;
  signed long int now;
  struct kore_domain *dom;
  struct pollfd pfd[1l];
  signed int nfds;
  signed int l;
  struct kore_log_packet logpacket;
  char addr[46l];
  char *method;
  char *buf;
  char *tbuf;
  char *cn;
  pfd[(signed long int)0].fd = accesslog_fd[(signed long int)0];
  pfd[(signed long int)0].events = (signed short int)0x001;
  pfd[(signed long int)0].revents = (signed short int)0;
  nfds=poll(pfd, (unsigned long int)1, 1000);
  _Bool tmp_if_expr_4;
  if(nfds == -1)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = ((signed int)pfd[(signed long int)0].revents & (0x008 | 0x010 | 0x020)) != 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location_1;
  if(tmp_if_expr_4)
  {
    if(nfds == -1)
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        return 1;

    }

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    kore_log(4, "poll(): %s", return_value_strerror_3);
    return 0;
  }

  if(nfds == 0)
    return 1;

  else
  {
    len=recv(accesslog_fd[(signed long int)0], (void *)&logpacket, sizeof(struct kore_log_packet) /*2608ul*/ , 0);
    if(len == -1l)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      kore_log(4, "recv(): %s", return_value_strerror_6);
      return 0;
    }

    if(!((unsigned long int)len == sizeof(struct kore_log_packet) /*2608ul*/ ))
      return 0;

    else
    {
      dom=kore_domain_lookup(logpacket.host);
      if(dom == ((struct kore_domain *)NULL))
      {
        kore_log(4, "got accesslog packet for unknown domain: %s", (const void *)logpacket.host);
        return 1;
      }

      else
      {
        switch((signed int)logpacket.method)
        {
          case 0:
          {
            method = "GET";
            break;
          }
          case 1:
          {
            method = "POST";
            break;
          }
          case 2:
          {
            method = "PUT";
            break;
          }
          case 3:
          {
            method = "DELETE";
            break;
          }
          case 4:
          {
            method = "HEAD";
            break;
          }
          default:
            method = "UNKNOWN";
        }
        if(!((signed int)logpacket.cn[0l] == 0))
          cn = logpacket.cn;

        else
          cn = "none";
        const char *return_value_inet_ntop_7;
        return_value_inet_ntop_7=inet_ntop((signed int)logpacket.addrtype, (const void *)&logpacket.addr, addr, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        if(return_value_inet_ntop_7 == ((const char *)NULL))
          kore_strlcpy(addr, "unknown", sizeof(char [46l]) /*46ul*/ );

        time(&now);
        tbuf=kore_time_to_date(now);
        l=asprintf(&buf, "[%s] %s %d %s %s (w#%d) (%dms) (%s) (%s)\n", tbuf, (const void *)addr, logpacket.status, method, (const void *)logpacket.path, logpacket.worker_id, logpacket.time_req, cn, (const void *)logpacket.agent);
        if(l == -1)
        {
          kore_log(4, "kore_accesslog_wait(): asprintf() == -1");
          return 0;
        }

        else
        {
          len=write(dom->accesslog, (const void *)buf, (unsigned long int)l);
          if(len == -1l)
          {
            free((void *)buf);
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            char *return_value_strerror_9;
            return_value_strerror_9=strerror(*return_value___errno_location_8);
            kore_log(4, "kore_accesslog_wait(): write(): %s", return_value_strerror_9);
            return 0;
          }

          if(!(len == (signed long int)l))
            kore_log(5, "accesslog: %s", buf);

          free((void *)buf);
          return 1;
        }
      }
    }
  }
}

// kore_accesslog_worker_init
// file src/accesslog.c line 48
void kore_accesslog_worker_init(void)
{
  close(accesslog_fd[(signed long int)0]);
  kore_domain_closelogs();
}

// kore_auth_cookie
// file src/auth.c line 106
static signed int kore_auth_cookie(struct http_request *req, struct kore_auth *auth)
{
  signed int i;
  signed int v;
  unsigned long int len;
  unsigned long int slen;
  char *value;
  char *c;
  char *cookie;
  char *cookies[10l];
  signed int return_value_http_request_header_1;
  return_value_http_request_header_1=http_request_header(req, "cookie", &cookie);
  const unsigned short int **return_value___ctype_b_loc_2;
  unsigned long int tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  if(return_value_http_request_header_1 == 0)
    return 0;

  else
  {
    slen=strlen(auth->value);
    v=kore_split_string(cookie, ";", cookies, (unsigned long int)10);
    i = 0;
    for( ; !(i >= v); i = i + 1)
    {
      c = cookies[(signed long int)i];
      do
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*c]) == 0)
          break;

        c = c + 1l;
      }
      while((_Bool)1);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(cookies[(signed long int)i]);
      if(!(slen >= return_value_strlen_3))
        tmp_if_expr_5 = slen;

      else
      {
        return_value_strlen_4=strlen(cookies[(signed long int)i]);
        tmp_if_expr_5 = return_value_strlen_4;
      }
      len = tmp_if_expr_5;
      signed int return_value_strncmp_6;
      return_value_strncmp_6=strncmp(c, auth->value, len);
      if(return_value_strncmp_6 == 0)
        break;

    }
    if(i == v)
    {
      kore_mem_free((void *)cookie);
      return 0;
    }

    else
    {
      c = cookies[(signed long int)i];
      value=strchr(c, 61);
      if(value == ((char *)NULL))
      {
        kore_mem_free((void *)cookie);
        return 0;
      }

      else
      {
        value = value + 1l;
        i=kore_validator_check(req, auth->validator, (void *)value);
        kore_mem_free((void *)cookie);
        return i;
      }
    }
  }
}

// kore_auth_header
// file src/auth.c line 144
static signed int kore_auth_header(struct http_request *req, struct kore_auth *auth)
{
  signed int r;
  char *header;
  signed int return_value_http_request_header_1;
  return_value_http_request_header_1=http_request_header(req, auth->value, &header);
  if(return_value_http_request_header_1 == 0)
    return 0;

  else
  {
    r=kore_validator_check(req, auth->validator, (void *)header);
    kore_mem_free((void *)header);
    return r;
  }
}

// kore_auth_init
// file includes/kore.h line 426
void kore_auth_init(void)
{
  do
  {
    (&auth_list)->tqh_first = (struct kore_auth *)(void *)0;
    (&auth_list)->tqh_last = &(&auth_list)->tqh_first;
  }
  while((_Bool)0);
}

// kore_auth_lookup
// file src/auth.c line 165
struct kore_auth * kore_auth_lookup(const char *name)
{
  struct kore_auth *auth = (&auth_list)->tqh_first;
  for( ; !(auth == ((struct kore_auth *)NULL)); auth = auth->list.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(auth->name, name);
    if(return_value_strcmp_1 == 0)
      return auth;

  }
  return (struct kore_auth *)(void *)0;
}

// kore_auth_new
// file src/auth.c line 37
signed int kore_auth_new(const char *name)
{
  struct kore_auth *auth;
  auth=kore_auth_lookup(name);
  if(!(auth == ((struct kore_auth *)NULL)))
    return 0;

  else
  {
    void *return_value_kore_malloc_1;
    return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_auth) /*56ul*/ );
    auth = (struct kore_auth *)return_value_kore_malloc_1;
    auth->type = (unsigned char)0;
    auth->value = (char *)(void *)0;
    auth->redirect = (char *)(void *)0;
    auth->validator = (struct kore_validator *)(void *)0;
    auth->name=kore_strdup(name);
    do
    {
      auth->list.tqe_next = (struct kore_auth *)(void *)0;
      auth->list.tqe_prev = (&auth_list)->tqh_last;
      *(&auth_list)->tqh_last = auth;
      (&auth_list)->tqh_last = &auth->list.tqe_next;
    }
    while((_Bool)0);
    return 1;
  }
}

// kore_auth_request
// file src/auth.c line 159
static signed int kore_auth_request(struct http_request *req, struct kore_auth *auth)
{
  signed int return_value_kore_validator_check_1;
  return_value_kore_validator_check_1=kore_validator_check(req, auth->validator, (void *)req);
  return return_value_kore_validator_check_1;
}

// kore_auth_run
// file src/auth.c line 57
signed int kore_auth_run(struct http_request *req, struct kore_auth *auth)
{
  signed int r;
  switch((signed int)auth->type)
  {
    case 1:
    {
      r=kore_auth_cookie(req, auth);
      break;
    }
    case 2:
    {
      r=kore_auth_header(req, auth);
      break;
    }
    case 3:
    {
      r=kore_auth_request(req, auth);
      break;
    }
    default:
    {
      kore_log(5, "unknown auth type %d", auth->type);
      return 0;
    }
  }
  if(!(r == 1))
  {
    if(r == 2)
      goto __CPROVER_DUMP_L6;

  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    return r;
  }
  if((signed int)auth->type == 3)
    return r;

  else
    if(auth->redirect == ((char *)NULL))
    {
      http_response(req, 403, (void *)0, (unsigned int)0);
      return 0;
    }

    else
    {
      http_response_header(req, "location", auth->redirect);
      http_response(req, 302, (void *)0, (unsigned int)0);
      return 0;
    }
}

// kore_base64_decode
// file src/utils.c line 412
signed int kore_base64_decode(char *in, unsigned char **out, unsigned int *olen)
{
  signed int i;
  signed int c;
  struct kore_buf *res;
  unsigned char d;
  unsigned char n;
  unsigned char o;
  unsigned int b;
  unsigned int len;
  unsigned int idx;
  i = 4;
  b = (unsigned int)0;
  d = (unsigned char)0;
  c = 0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(in);
  len = (unsigned int)return_value_strlen_1;
  res=kore_buf_create(len);
  idx = (unsigned int)0;
  for( ; !(idx >= len); idx = idx + 1u)
  {
    c = (signed int)in[(signed long int)idx];
    if(c == 61)
      break;

    o = (unsigned char)0;
    for( ; !((unsigned long int)o >= sizeof(char [65l]) /*65ul*/ ); o = o + 1)
      if((signed int)b64table[(signed long int)o] == c)
      {
        d = o;
        break;
      }

    if((unsigned long int)o == sizeof(char [65l]) /*65ul*/ )
    {
      *out = (unsigned char *)(void *)0;
      kore_buf_free(res);
      return 0;
    }

    b = b | (unsigned int)(((signed int)d & 0x3f) << (i - 1) * 6);
    i = i - 1;
    if(i == 0)
    {
      i = 2;
      for( ; i >= 0; i = i - 1)
      {
        n = (unsigned char)(b >> 8 * i);
        kore_buf_append(res, (void *)&n, (unsigned int)1);
      }
      b = (unsigned int)0;
      i = 4;
    }

  }
  if(c == 61)
  {
    if(i >= 3)
    {
      *out = (unsigned char *)(void *)0;
      kore_buf_free(res);
      return 0;
    }

    o = (unsigned char)i;
    i = 2;
    for( ; i >= (signed int)o; i = i - 1)
    {
      n = (unsigned char)(b >> 8 * i);
      kore_buf_append(res, (void *)&n, (unsigned int)1);
    }
  }

  *out=kore_buf_release(res, olen);
  return 1;
}

// kore_base64_encode
// file src/utils.c line 351
signed int kore_base64_encode(unsigned char *data, unsigned int len, char **out)
{
  struct kore_buf *res;
  unsigned char n;
  unsigned char *pdata;
  signed int i;
  signed int padding;
  unsigned int idx;
  unsigned int b;
  unsigned int plen;
  if(!(len % 3u == 0u))
  {
    padding = (signed int)((unsigned int)3 - len % (unsigned int)3);
    plen = len + (unsigned int)padding;
    void *return_value_kore_malloc_1;
    return_value_kore_malloc_1=kore_malloc((unsigned long int)plen);
    pdata = (unsigned char *)return_value_kore_malloc_1;
    memcpy((void *)pdata, (const void *)data, (unsigned long int)len);
    memset((void *)(pdata + (signed long int)len), 0, (unsigned long int)padding);
  }

  else
  {
    plen = len;
    padding = 0;
    pdata = data;
  }
  res=kore_buf_create(plen);
  i = 2;
  b = (unsigned int)0;
  idx = (unsigned int)0;
  signed int tmp_post_2;
  for( ; !(idx >= plen); idx = idx + 1u)
  {
    b = b | (unsigned int)((signed int)pdata[(signed long int)idx] << i * 8);
    tmp_post_2 = i;
    i = i - 1;
    if(tmp_post_2 == 0)
    {
      i = 3;
      for( ; i >= 0; i = i - 1)
      {
        n = (unsigned char)(b >> 6 * i & (unsigned int)0x3f);
        if((unsigned long int)n >= sizeof(char [65l]) /*65ul*/ )
        {
          kore_buf_free(res);
          return 0;
        }

        if(idx >= len && !(i >= padding))
          break;

        kore_buf_append(res, (void *)&b64table[(signed long int)n], (unsigned int)1);
      }
      b = (unsigned int)0;
      i = 2;
    }

  }
  i = 0;
  for( ; !(i >= padding); i = i + 1)
    kore_buf_append(res, (void *)(unsigned char *)"=", (unsigned int)1);
  if(!(pdata == data))
    kore_mem_free((void *)pdata);

  pdata=kore_buf_release(res, &plen);
  void *return_value_kore_malloc_3;
  return_value_kore_malloc_3=kore_malloc((unsigned long int)(plen + (unsigned int)1));
  *out = (char *)return_value_kore_malloc_3;
  kore_strlcpy(*out, (char *)pdata, (unsigned long int)(plen + (unsigned int)1));
  kore_mem_free((void *)pdata);
  return 1;
}

// kore_buf_append
// file src/buf.c line 33
void kore_buf_append(struct kore_buf *buf, void *d, unsigned int len)
{
  if(buf->offset + (unsigned long int)len >= buf->length)
  {
    buf->length = buf->length + (unsigned long int)(len + (unsigned int)128);
    void *return_value_kore_realloc_1;
    return_value_kore_realloc_1=kore_realloc((void *)buf->data, buf->length);
    buf->data = (unsigned char *)return_value_kore_realloc_1;
  }

  memcpy((void *)(buf->data + (signed long int)buf->offset), d, (unsigned long int)len);
  buf->offset = buf->offset + (unsigned long int)len;
}

// kore_buf_appendb
// file src/buf.c line 45
void kore_buf_appendb(struct kore_buf *buf, struct kore_buf *src)
{
  unsigned char *d;
  unsigned int len;
  d=kore_buf_release(src, &len);
  kore_buf_append(buf, (void *)d, len);
  kore_mem_free((void *)d);
}

// kore_buf_appendf
// file src/buf.c line 79
void kore_buf_appendf(struct kore_buf *buf, const char *fmt, ...)
{
  void **args = (void **)&fmt;
  kore_buf_appendv(buf, fmt, args);
  args = ((void **)NULL);
}

// kore_buf_appendv
// file src/buf.c line 56
void kore_buf_appendv(struct kore_buf *buf, const char *fmt, void **args)
{
  signed int l;
  char *b;
  char sb[8192l];
  l=vsnprintf(sb, sizeof(char [8192l]) /*8192ul*/ , fmt, args);
  if(l == -1)
    fatal("kore_buf_appendv(): vsnprintf error");

  if((unsigned long int)l >= sizeof(char [8192l]) /*8192ul*/ )
  {
    l=vasprintf(&b, fmt, args);
    if(l == -1)
      fatal("kore_buf_appendv(): error or truncation");

  }

  else
    b = sb;
  kore_buf_append(buf, (void *)(unsigned char *)b, (unsigned int)l);
  if(!(b == sb))
    free((void *)b);

}

// kore_buf_create
// file src/buf.c line 20
struct kore_buf * kore_buf_create(unsigned int initial)
{
  struct kore_buf *buf;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_buf) /*24ul*/ );
  buf = (struct kore_buf *)return_value_kore_malloc_1;
  void *return_value_kore_malloc_2;
  return_value_kore_malloc_2=kore_malloc((unsigned long int)initial);
  buf->data = (unsigned char *)return_value_kore_malloc_2;
  buf->length = (unsigned long int)initial;
  buf->offset = (unsigned long int)0;
  return buf;
}

// kore_buf_free
// file src/buf.c line 101
void kore_buf_free(struct kore_buf *buf)
{
  kore_mem_free((void *)buf->data);
  kore_mem_free((void *)buf);
}

// kore_buf_release
// file src/buf.c line 89
unsigned char * kore_buf_release(struct kore_buf *buf, unsigned int *len)
{
  unsigned char *p = buf->data;
  *len = (unsigned int)buf->offset;
  kore_mem_free((void *)buf);
  return p;
}

// kore_buf_replace_string
// file src/buf.c line 108
void kore_buf_replace_string(struct kore_buf *b, char *src, void *dst, unsigned long int len)
{
  unsigned int blen;
  unsigned int off;
  unsigned int off2;
  unsigned long int nlen;
  unsigned long int klen;
  char *key;
  char *end;
  char *tmp;
  char *p;
  off = (unsigned int)0;
  klen=strlen(src);
  do
  {
    blen = (unsigned int)b->offset;
    nlen = (unsigned long int)blen + len;
    p = (char *)b->data;
    void *return_value_kore_mem_find_1;
    return_value_kore_mem_find_1=kore_mem_find((void *)(p + (signed long int)off), b->offset - (unsigned long int)off, (void *)src, (unsigned int)klen);
    key = (char *)return_value_kore_mem_find_1;
    if(key == ((char *)NULL))
      break;

    end = key + (signed long int)klen;
    off = (unsigned int)(key - p);
    off2 = (unsigned int)((char *)(b->data + (signed long int)b->offset) - end);
    void *return_value_kore_malloc_2;
    return_value_kore_malloc_2=kore_malloc(nlen);
    tmp = (char *)return_value_kore_malloc_2;
    memcpy((void *)tmp, (const void *)p, (unsigned long int)off);
    if(!(dst == NULL))
      memcpy((void *)(tmp + (signed long int)off), dst, len);

    memcpy((void *)(tmp + (signed long int)off + (signed long int)len), (const void *)end, (unsigned long int)off2);
    kore_mem_free((void *)b->data);
    b->data = (unsigned char *)tmp;
    b->offset = (unsigned long int)off + len + (unsigned long int)off2;
    b->length = nlen;
    off = (unsigned int)((unsigned long int)off + len);
  }
  while((_Bool)1);
}

// kore_calloc
// file src/mem.c line 94
void * kore_calloc(unsigned long int memb, unsigned long int len)
{
  if(len == 0ul || memb == 0ul)
    fatal("kore_calloc(): zero size");

  if(!(18446744073709551615UL / memb >= len))
    fatal("kore_calloc: memb * len > SIZE_MAX");

  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(memb * len);
  return return_value_kore_malloc_1;
}

// kore_cli_main
// file includes/kore.h line 394
signed int kore_cli_main(signed int argc, char **argv)
{
  signed int i;
  if(!(argc >= 1))
    kore_cli_usage(1);

  umask((unsigned int)(0200 >> 3 | (0200 >> 3) >> 3));
  i = 0;
  for( ; !(cmds[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(argv[(signed long int)0], cmds[(signed long int)i].name);
    if(return_value_strcmp_1 == 0)
    {
      argc = argc - 1;
      argv = argv + 1l;
      command = &cmds[(signed long int)i];
      cmds[(signed long int)i].cb(argc, argv);
      break;
    }

  }
  if(cmds[(signed long int)i].name == ((const char *)NULL))
  {
    fprintf(stderr, "No such command: %s\n", argv[(signed long int)0]);
    kore_cli_usage(1);
  }

  return 0;
}

// kore_cli_usage
// file includes/kore.h line 393
void kore_cli_usage(signed int local)
{
  signed int i;
  if(!(local == 0))
    fprintf(stderr, "Usage: kore [command]\n");

  fprintf(stderr, "\nAvailable commands:\n");
  i = 0;
  for( ; !(cmds[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    printf("\t%s\t%s\n", cmds[(signed long int)i].name, cmds[(signed long int)i].descr);
  fprintf(stderr, "\nThe commands mostly exist for your convenience\n");
  fprintf(stderr, "when hacking on your Kore applications.\n");
  fprintf(stderr, "\n");
  fprintf(stderr, "Production servers should be started using ");
  fprintf(stderr, "the options.\n");
  fprintf(stderr, "\nFind more information on https://kore.io\n");
  exit(1);
}

// kore_connection_accept
// file src/connection.c line 72
signed int kore_connection_accept(struct listener *l, struct connection **out)
{
  struct connection *c;
  struct sockaddr *sin;
  unsigned int len;
  *out = (struct connection *)(void *)0;
  c=kore_connection_new((void *)l);
  c->addrtype = l->addrtype;
  if((signed int)c->addrtype == 2)
  {
    len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    sin = (struct sockaddr *)&c->addr.ipv4;
  }

  else
  {
    len = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    sin = (struct sockaddr *)&c->addr.ipv6;
  }
  c->fd=accept(l->fd, sin, &len);
  if(c->fd == -1)
  {
    kore_pool_put(&connection_pool, (void *)c);
    return 0;
  }

  else
  {
    signed int return_value_kore_connection_nonblock_1;
    return_value_kore_connection_nonblock_1=kore_connection_nonblock(c->fd);
    if(return_value_kore_connection_nonblock_1 == 0)
    {
      close(c->fd);
      kore_pool_put(&connection_pool, (void *)c);
      return 0;
    }

    else
    {
      c->state = (unsigned char)1;
      c->write = net_write_ssl;
      c->read = net_read_ssl;
      kore_worker_connection_add(c);
      kore_connection_start_idletimer(c);
      *out = c;
      return 1;
    }
  }
}

// kore_connection_check_idletimer
// file src/connection.c line 334
void kore_connection_check_idletimer(unsigned long int now, struct connection *c)
{
  unsigned long int d = now - c->idle_timer.start;
  if(d >= c->idle_timer.length)
  {
    if((signed int)c->proto == 1)
      spdy_session_teardown(c, (unsigned char)0);

    else
      kore_connection_disconnect(c);
  }

}

// kore_connection_disconnect
// file src/connection.c line 129
void kore_connection_disconnect(struct connection *c)
{
  if(!((signed int)c->state == 3))
  {
    c->state = (unsigned char)3;
    if(!(c->disconnect == ((void (*)(struct connection *))NULL)))
      c->disconnect(c);

    kore_worker_connection_move(c);
  }

}

// kore_connection_handle
// file src/connection.c line 142
signed int kore_connection_handle(struct connection *c)
{
  signed int r;
  unsigned int len;
  const unsigned char *data;
  char cn[65l];
  kore_connection_stop_idletimer(c);
  signed int return_value_SSL_get_verify_mode_3;
  signed long int return_value_SSL_get_verify_result_4;
  signed int return_value_memcmp_5;
  switch((signed int)c->state)
  {
    case 1:
    {
      if(c->ssl == ((struct ssl_st *)NULL))
      {
        c->ssl=SSL_new(primary_dom->ssl_ctx);
        if(c->ssl == ((struct ssl_st *)NULL))
          return 0;

        SSL_set_fd(c->ssl, c->fd);
        SSL_set_accept_state(c->ssl);
        SSL_set_ex_data(c->ssl, 0, (void *)(char *)c);
      }

      r=SSL_accept(c->ssl);
      if(!(r >= 1))
      {
        r=SSL_get_error(c->ssl, r);
        if(r == 2 || r == 3)
          return 1;

        return 0;
      }

      return_value_SSL_get_verify_mode_3=SSL_get_verify_mode(c->ssl);
      if(!((0x01 & return_value_SSL_get_verify_mode_3) == 0))
      {
        c->cert=SSL_get_peer_certificate(c->ssl);
        if(c->cert == ((struct x509_st *)NULL))
        {
          kore_log(5, "no client certificate presented?");
          return 0;
        }

        struct X509_name_st *return_value_X509_get_subject_name_1;
        return_value_X509_get_subject_name_1=X509_get_subject_name(c->cert);
        signed int return_value_X509_NAME_get_text_by_NID_2;
        return_value_X509_NAME_get_text_by_NID_2=X509_NAME_get_text_by_NID(return_value_X509_get_subject_name_1, 13, cn, (signed int)sizeof(char [65l]) /*65ul*/ );
        if(return_value_X509_NAME_get_text_by_NID_2 == -1)
        {
          kore_log(5, "no CN found in client certificate");
          return 0;
        }

      }

      return_value_SSL_get_verify_result_4=SSL_get_verify_result(c->ssl);
      r = (signed int)return_value_SSL_get_verify_result_4;
      if(!(r == 0))
        return 0;

      SSL_get0_next_proto_negotiated(c->ssl, &data, &len);
      if(!(data == ((const unsigned char *)NULL)))
      {
        signed int return_value_memcmp_6;
        return_value_memcmp_6=memcmp((const void *)data, (const void *)"spdy/3", (unsigned long int)((unsigned int)6 < len ? (unsigned int)6 : len));
        if(return_value_memcmp_6 == 0)
        {
          c->proto = (unsigned char)1;
          c->idle_timer.length = spdy_idle_time;
          net_recv_queue(c, (unsigned int)8, 0, spdy_frame_recv);
        }

        else
        {
          return_value_memcmp_5=memcmp((const void *)data, (const void *)"http/1.1", (unsigned long int)((unsigned int)8 < len ? (unsigned int)8 : len));
          if(return_value_memcmp_5 == 0)
          {
            c->proto = (unsigned char)2;
            if(!((signed int)http_keepalive_time == 0))
              c->idle_timer.length = (unsigned long int)((signed int)http_keepalive_time * 1000);

            net_recv_queue(c, (unsigned int)http_header_max, 0x01, http_header_recv);
          }

          else
          {
            kore_log(5, "npn: received unknown protocol");
            return 0;
          }
        }
      }

      else
      {
        c->proto = (unsigned char)2;
        if(!((signed int)http_keepalive_time == 0))
          c->idle_timer.length = (unsigned long int)((signed int)http_keepalive_time * 1000);

        net_recv_queue(c, (unsigned int)http_header_max, 0x01, http_header_recv);
      }
      c->state = (unsigned char)2;
    }
    case 2:
    {
      if(!((0x01 & (signed int)c->flags) == 0))
      {
        signed int return_value_net_recv_flush_7;
        return_value_net_recv_flush_7=net_recv_flush(c);
        if(return_value_net_recv_flush_7 == 0)
          return 0;

      }

      if(!((0x02 & (signed int)c->flags) == 0))
      {
        signed int return_value_net_send_flush_8;
        return_value_net_send_flush_8=net_send_flush(c);
        if(return_value_net_send_flush_8 == 0)
          return 0;

      }

      break;
    }
    case 3:
      break;
    default:
      ;
  }
  kore_connection_start_idletimer(c);
  return 1;
}

// kore_connection_init
// file src/connection.c line 30
void kore_connection_init(void)
{
  kore_pool_init(&connection_pool, "connection_pool", (unsigned int)sizeof(struct connection) /*504ul*/ , worker_max_connections);
}

// kore_connection_new
// file src/connection.c line 37
struct connection * kore_connection_new(void *owner)
{
  struct connection *c;
  void *return_value_kore_pool_get_1;
  return_value_kore_pool_get_1=kore_pool_get(&connection_pool);
  c = (struct connection *)return_value_kore_pool_get_1;
  c->ssl = (struct ssl_st *)(void *)0;
  c->flags = (unsigned char)0;
  c->rnb = (struct netbuf *)(void *)0;
  c->snb = (struct netbuf *)(void *)0;
  c->cert = (struct x509_st *)(void *)0;
  c->wscbs = (void *)0;
  c->owner = owner;
  c->tls_reneg = 0;
  c->disconnect = (void (*)(struct connection *))(void *)0;
  c->hdlr_extra = (void *)0;
  c->inflate_started = (unsigned char)0;
  c->deflate_started = (unsigned char)0;
  c->client_stream_id = (unsigned int)0;
  c->proto = (unsigned char)0;
  c->type = (unsigned char)2;
  c->wsize_initial = (unsigned int)65536;
  c->spdy_send_wsize = (unsigned int)65536;
  c->spdy_recv_wsize = (unsigned int)65536;
  c->idle_timer.start = (unsigned long int)0;
  c->idle_timer.length = (unsigned long int)20000;
  do
  {
    (&c->send_queue)->tqh_first = (struct netbuf *)(void *)0;
    (&c->send_queue)->tqh_last = &(&c->send_queue)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&c->spdy_streams)->tqh_first = (struct spdy_stream *)(void *)0;
    (&c->spdy_streams)->tqh_last = &(&c->spdy_streams)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&c->http_requests)->tqh_first = (struct http_request *)(void *)0;
    (&c->http_requests)->tqh_last = &(&c->http_requests)->tqh_first;
  }
  while((_Bool)0);
  return c;
}

// kore_connection_nonblock
// file includes/kore.h line 443
signed int kore_connection_nonblock(signed int fd)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    return 0;

  else
  {
    flags = flags | 04000;
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(fd, 4, flags);
    if(return_value_fcntl_1 == -1)
      return 0;

    else
    {
      flags = 1;
      signed int return_value_setsockopt_2;
      return_value_setsockopt_2=setsockopt(fd, 6, 1, (const void *)(char *)&flags, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(return_value_setsockopt_2 == -1)
        kore_log(5, "failed to set TCP_NODELAY on %d", fd);

      return 1;
    }
  }
}

// kore_connection_remove
// file src/connection.c line 265
void kore_connection_remove(struct connection *c)
{
  struct netbuf *nb;
  struct netbuf *next;
  struct spdy_stream *s;
  struct spdy_stream *snext;
  struct http_request *req;
  struct http_request *rnext;
  if(!(c->ssl == ((struct ssl_st *)NULL)))
  {
    SSL_shutdown(c->ssl);
    SSL_free(c->ssl);
  }

  if(!(c->cert == ((struct x509_st *)NULL)))
    X509_free(c->cert);

  close(c->fd);
  if(!(c->hdlr_extra == NULL))
    kore_mem_free(c->hdlr_extra);

  if(!(c->inflate_started == 0))
    inflateEnd(&c->z_inflate);

  if(!(c->deflate_started == 0))
    deflateEnd(&c->z_deflate);

  req = (&c->http_requests)->tqh_first;
  for( ; !(req == ((struct http_request *)NULL)); req = rnext)
  {
    rnext = req->olist.tqe_next;
    do
    {
      if(!(req->olist.tqe_next == ((struct http_request *)NULL)))
        req->olist.tqe_next->olist.tqe_prev = req->olist.tqe_prev;

      else
        (&c->http_requests)->tqh_last = req->olist.tqe_prev;
      *req->olist.tqe_prev = req->olist.tqe_next;
    }
    while((_Bool)0);
    req->flags = req->flags | (unsigned char)0x02;
    http_request_wakeup(req);
  }
  nb = (&c->send_queue)->tqh_first;
  for( ; !(nb == ((struct netbuf *)NULL)); nb = next)
  {
    next = nb->list.tqe_next;
    do
    {
      if(!(nb->list.tqe_next == ((struct netbuf *)NULL)))
        nb->list.tqe_next->list.tqe_prev = nb->list.tqe_prev;

      else
        (&c->send_queue)->tqh_last = nb->list.tqe_prev;
      *nb->list.tqe_prev = nb->list.tqe_next;
    }
    while((_Bool)0);
    if((0x10 & (signed int)nb->flags) == 0)
      kore_mem_free((void *)nb->buf);

    else
      if(!(nb->cb == ((signed int (*)(struct netbuf *))NULL)))
        nb->cb(nb);

    kore_pool_put(&nb_pool, (void *)nb);
  }
  if(!(c->rnb == ((struct netbuf *)NULL)))
  {
    kore_mem_free((void *)c->rnb->buf);
    kore_pool_put(&nb_pool, (void *)c->rnb);
  }

  s = (&c->spdy_streams)->tqh_first;
  for( ; !(s == ((struct spdy_stream *)NULL)); s = snext)
  {
    snext = s->list.tqe_next;
    do
    {
      if(!(s->list.tqe_next == ((struct spdy_stream *)NULL)))
        s->list.tqe_next->list.tqe_prev = s->list.tqe_prev;

      else
        (&c->spdy_streams)->tqh_last = s->list.tqe_prev;
      *s->list.tqe_prev = s->list.tqe_next;
    }
    while((_Bool)0);
    if(!(s->hblock == ((struct spdy_header_block *)NULL)))
    {
      if(!(s->hblock->header_block == ((unsigned char *)NULL)))
        kore_mem_free((void *)s->hblock->header_block);

      kore_mem_free((void *)s->hblock);
    }

    kore_mem_free((void *)s);
  }
  kore_worker_connection_remove(c);
  kore_pool_put(&connection_pool, (void *)c);
}

// kore_connection_start_idletimer
// file src/connection.c line 349
void kore_connection_start_idletimer(struct connection *c)
{
  c->flags = c->flags | (unsigned char)0x10;
  c->idle_timer.start=kore_time_ms();
}

// kore_connection_stop_idletimer
// file src/connection.c line 358
void kore_connection_stop_idletimer(struct connection *c)
{
  c->flags = c->flags & (unsigned char)~0x10;
  c->idle_timer.start = (unsigned long int)0;
}

// kore_date_to_time
// file src/utils.c line 240
signed long int kore_date_to_time(char *http_date)
{
  signed long int t;
  signed int err;
  signed int i;
  struct tm tm;
  struct tm *ltm;
  char *args[7l];
  char *tbuf[5l];
  char *sdup;
  time(&t);
  ltm=localtime(&t);
  sdup=kore_strdup(http_date);
  t = (signed long int)0;
  signed int return_value_kore_split_string_1;
  return_value_kore_split_string_1=kore_split_string(sdup, " ", args, (unsigned long int)7);
  signed long long int return_value_kore_strtonum_2;
  signed long long int return_value_kore_strtonum_4;
  signed int return_value_kore_split_string_5;
  signed long long int return_value_kore_strtonum_6;
  signed long long int return_value_kore_strtonum_7;
  signed long long int return_value_kore_strtonum_8;
  signed long int return_value_mktime_9;
  if(return_value_kore_split_string_1 == 6)
  {
    memset((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
    return_value_kore_strtonum_2=kore_strtonum(args[(signed long int)3], 10, (signed long long int)1900, (signed long long int)2068, &err);
    tm.tm_year = (signed int)(return_value_kore_strtonum_2 - (signed long int)1900);
    if(!(err == 0))
    {
      i = 0;
      for( ; !(month_names[(signed long int)i].name == ((char *)NULL)); i = i + 1)
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(month_names[(signed long int)i].name, args[(signed long int)2]);
        if(return_value_strcmp_3 == 0)
        {
          tm.tm_mon = month_names[(signed long int)i].value;
          break;
        }

      }
      if(!(month_names[(signed long int)i].name == ((char *)NULL)))
      {
        return_value_kore_strtonum_4=kore_strtonum(args[(signed long int)1], 10, (signed long long int)1, (signed long long int)31, &err);
        tm.tm_mday = (signed int)return_value_kore_strtonum_4;
        if(!(err == 0))
        {
          return_value_kore_split_string_5=kore_split_string(args[(signed long int)4], ":", tbuf, (unsigned long int)5);
          if(return_value_kore_split_string_5 == 3)
          {
            return_value_kore_strtonum_6=kore_strtonum(tbuf[(signed long int)0], 10, (signed long long int)0, (signed long long int)23, &err);
            tm.tm_hour = (signed int)return_value_kore_strtonum_6;
            if(!(err == 0))
            {
              return_value_kore_strtonum_7=kore_strtonum(tbuf[(signed long int)1], 10, (signed long long int)0, (signed long long int)59, &err);
              tm.tm_min = (signed int)return_value_kore_strtonum_7;
              if(!(err == 0))
              {
                return_value_kore_strtonum_8=kore_strtonum(tbuf[(signed long int)2], 10, (signed long long int)0, (signed long long int)60, &err);
                tm.tm_sec = (signed int)return_value_kore_strtonum_8;
                if(!(err == 0))
                {
                  tm.tm_isdst = ltm->tm_isdst;
                  return_value_mktime_9=mktime(&tm);
                  t = return_value_mktime_9 + ltm->tm_gmtoff;
                  if(t == -1l)
                    t = (signed long int)0;

                }

              }

            }

          }

        }

      }

    }

  }


out:
  ;
  kore_mem_free((void *)sdup);
  return t;
}

// kore_debug_internal
// file src/utils.c line 45
void kore_debug_internal(char *file, signed int line, const char *fmt, ...)
{
  void **args;
  char buf[2048l];
  args = (void **)&fmt;
  vsnprintf(buf, sizeof(char [2048l]) /*2048ul*/ , fmt, args);
  args = ((void **)NULL);
  printf("[%d] %s:%d - %s\n", kore_pid, file, line, (const void *)buf);
}

// kore_domain_closelogs
// file includes/kore.h line 501
void kore_domain_closelogs(void)
{
  struct kore_domain *dom = (&domains)->tqh_first;
  for( ; !(dom == ((struct kore_domain *)NULL)); dom = dom->list.tqe_next)
    close(dom->accesslog);
}

// kore_domain_init
// file includes/kore.h line 495
void kore_domain_init(void)
{
  do
  {
    (&domains)->tqh_first = (struct kore_domain *)(void *)0;
    (&domains)->tqh_last = &(&domains)->tqh_first;
  }
  while((_Bool)0);
}

// kore_domain_load_crl
// file src/domain.c line 204
void kore_domain_load_crl(void)
{
  struct kore_domain *dom = (&domains)->tqh_first;
  for( ; !(dom == ((struct kore_domain *)NULL)); dom = dom->list.tqe_next)
    domain_load_crl(dom);
}

// kore_domain_lookup
// file includes/kore.h line 509
struct kore_domain * kore_domain_lookup(const char *domain)
{
  struct kore_domain *dom = (&domains)->tqh_first;
  for( ; !(dom == ((struct kore_domain *)NULL)); dom = dom->list.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(dom->domain, domain);
    if(return_value_strcmp_1 == 0)
      return dom;

  }
  return (struct kore_domain *)(void *)0;
}

// kore_domain_new
// file includes/kore.h line 496
signed int kore_domain_new(char *domain)
{
  struct kore_domain *dom;
  struct kore_domain *return_value_kore_domain_lookup_1;
  return_value_kore_domain_lookup_1=kore_domain_lookup(domain);
  if(!(return_value_kore_domain_lookup_1 == ((struct kore_domain *)NULL)))
    return 0;

  else
  {
    void *return_value_kore_malloc_2;
    return_value_kore_malloc_2=kore_malloc(sizeof(struct kore_domain) /*88ul*/ );
    dom = (struct kore_domain *)return_value_kore_malloc_2;
    dom->accesslog = -1;
    dom->cafile = (char *)(void *)0;
    dom->certkey = (char *)(void *)0;
    dom->ssl_ctx = (struct ssl_ctx_st *)(void *)0;
    dom->certfile = (char *)(void *)0;
    dom->crlfile = (char *)(void *)0;
    dom->domain=kore_strdup(domain);
    do
    {
      (&dom->handlers)->tqh_first = (struct kore_module_handle *)(void *)0;
      (&dom->handlers)->tqh_last = &(&dom->handlers)->tqh_first;
    }
    while((_Bool)0);
    do
    {
      dom->list.tqe_next = (struct kore_domain *)(void *)0;
      dom->list.tqe_prev = (&domains)->tqh_last;
      *(&domains)->tqh_last = dom;
      (&domains)->tqh_last = &dom->list.tqe_next;
    }
    while((_Bool)0);
    if(primary_dom == ((struct kore_domain *)NULL))
      primary_dom = dom;

    return 1;
  }
}

// kore_domain_sslstart
// file includes/kore.h line 505
void kore_domain_sslstart(struct kore_domain *dom)
{
  struct stack_st_X509_NAME *certs;
  struct x509_store_st *store;
  const struct ssl_method_st *method;
  struct ec_key_st *ecdh;
  switch(tls_version)
  {
    case 0:
    {
      method=TLSv1_2_server_method();
      break;
    }
    case 1:
    {
      method=TLSv1_server_method();
      break;
    }
    case 2:
    {
      method=SSLv23_server_method();
      break;
    }
    default:
    {
      fatal("unknown tls_version: %d", tls_version);
      goto __CPROVER_DUMP_L16;
    }
  }
  dom->ssl_ctx=SSL_CTX_new(method);
  unsigned long int return_value_ERR_get_error_1;
  char *return_value_ERR_error_string_2;
  if(dom->ssl_ctx == ((struct ssl_ctx_st *)NULL))
  {
    return_value_ERR_get_error_1=ERR_get_error();
    return_value_ERR_error_string_2=ERR_error_string(return_value_ERR_get_error_1, (char *)(void *)0);
    fatal("kore_domain_sslstart(): SSL_ctx_new(): %s", return_value_ERR_error_string_2);
  }

  signed int return_value_SSL_CTX_use_certificate_chain_file_5;
  return_value_SSL_CTX_use_certificate_chain_file_5=SSL_CTX_use_certificate_chain_file(dom->ssl_ctx, dom->certfile);
  if(return_value_SSL_CTX_use_certificate_chain_file_5 == 0)
  {
    unsigned long int return_value_ERR_get_error_3;
    return_value_ERR_get_error_3=ERR_get_error();
    char *return_value_ERR_error_string_4;
    return_value_ERR_error_string_4=ERR_error_string(return_value_ERR_get_error_3, (char *)(void *)0);
    fatal("SSL_CTX_use_certificate_chain_file(%s): %s", dom->certfile, return_value_ERR_error_string_4);
  }

  signed int return_value_SSL_CTX_use_PrivateKey_file_8;
  return_value_SSL_CTX_use_PrivateKey_file_8=SSL_CTX_use_PrivateKey_file(dom->ssl_ctx, dom->certkey, 1);
  if(return_value_SSL_CTX_use_PrivateKey_file_8 == 0)
  {
    unsigned long int return_value_ERR_get_error_6;
    return_value_ERR_get_error_6=ERR_get_error();
    char *return_value_ERR_error_string_7;
    return_value_ERR_error_string_7=ERR_error_string(return_value_ERR_get_error_6, (char *)(void *)0);
    fatal("SSL_CTX_use_PrivateKey_file(%s): %s", dom->certkey, return_value_ERR_error_string_7);
  }

  signed int return_value_SSL_CTX_check_private_key_9;
  return_value_SSL_CTX_check_private_key_9=SSL_CTX_check_private_key(dom->ssl_ctx);
  if(return_value_SSL_CTX_check_private_key_9 == 0)
    fatal("Public/Private key for %s do not match", dom->domain);

  if(tls_dhparam == ((struct dh_st *)NULL))
    fatal("No DH parameters given");

  SSL_CTX_ctrl(dom->ssl_ctx, 3, (signed long int)0, (void *)(char *)tls_dhparam);
  SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x00100000L, (void *)0);
  ecdh=EC_KEY_new_by_curve_name(715);
  if(!(ecdh == ((struct ec_key_st *)NULL)))
  {
    SSL_CTX_ctrl(dom->ssl_ctx, 4, (signed long int)0, (void *)(char *)ecdh);
    EC_KEY_free(ecdh);
  }

  SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x00020000L, (void *)0);
  unsigned long int return_value_ERR_get_error_12;
  char *return_value_ERR_error_string_13;
  if(!(dom->cafile == ((char *)NULL)))
  {
    certs=SSL_load_client_CA_file(dom->cafile);
    if(certs == ((struct stack_st_X509_NAME *)NULL))
    {
      unsigned long int return_value_ERR_get_error_10;
      return_value_ERR_get_error_10=ERR_get_error();
      char *return_value_ERR_error_string_11;
      return_value_ERR_error_string_11=ERR_error_string(return_value_ERR_get_error_10, (char *)(void *)0);
      fatal("SSL_load_client_CA_file(%s): %s", dom->cafile, return_value_ERR_error_string_11);
    }

    SSL_CTX_load_verify_locations(dom->ssl_ctx, dom->cafile, (const char *)(void *)0);
    SSL_CTX_set_verify_depth(dom->ssl_ctx, 1);
    SSL_CTX_set_client_CA_list(dom->ssl_ctx, certs);
    SSL_CTX_set_verify(dom->ssl_ctx, 0x01 | 0x02, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    store=SSL_CTX_get_cert_store(dom->ssl_ctx);
    if(store == ((struct x509_store_st *)NULL))
    {
      return_value_ERR_get_error_12=ERR_get_error();
      return_value_ERR_error_string_13=ERR_error_string(return_value_ERR_get_error_12, (char *)(void *)0);
      fatal("SSL_CTX_get_cert_store(): %s", return_value_ERR_error_string_13);
    }

    X509_STORE_set_verify_cb(store, domain_x509_verify);
  }

  unsigned long int return_value_strlen_14;
  return_value_strlen_14=strlen("kore_ssl_sessionid");
  SSL_CTX_set_session_id_context(dom->ssl_ctx, (unsigned char *)"kore_ssl_sessionid", (unsigned int)return_value_strlen_14);
  dom->ssl_ctx->freelist_max_len = (unsigned int)0;
  SSL_CTX_ctrl(dom->ssl_ctx, 33, 0x00000001L, (void *)0);
  if(tls_version == 2)
  {
    SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x01000000L, (void *)0);
    SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x02000000L, (void *)0);
    SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x10000000L, (void *)0);
  }

  SSL_CTX_ctrl(dom->ssl_ctx, 32, 0x00400000L, (void *)0);
  SSL_CTX_set_cipher_list(dom->ssl_ctx, kore_tls_cipher_list);
  SSL_CTX_set_info_callback(dom->ssl_ctx, kore_tls_info_callback);
  SSL_CTX_callback_ctrl(dom->ssl_ctx, 53, (void (*)(void))kore_tls_sni_cb);
  SSL_CTX_set_next_protos_advertised_cb(dom->ssl_ctx, kore_tls_npn_cb, (void *)0);
  kore_mem_free((void *)dom->certfile);
  kore_mem_free((void *)dom->certkey);

__CPROVER_DUMP_L16:
  ;
}

// kore_log
// file includes/kore.h line 476
void kore_log(signed int prio, const char *fmt, ...)
{
  void **args;
  char buf[2048l];
  args = (void **)&fmt;
  vsnprintf(buf, sizeof(char [2048l]) /*2048ul*/ , fmt, args);
  args = ((void **)NULL);
  if(!(worker == ((struct kore_worker *)NULL)))
  {
    if(!(foreground == 0))
      printf("[wrk %d]: %s\n", worker->id, (const void *)buf);

    else
      syslog(prio, "[wrk %d]: %s", worker->id, (const void *)buf);
  }

  else
    if(!(foreground == 0))
      printf("[parent]: %s\n", (const void *)buf);

    else
      syslog(prio, "[parent]: %s", (const void *)buf);
}

// kore_log_init
// file includes/kore.h line 455
void kore_log_init(void)
{
  if(foreground == 0)
    openlog("kore", 0x08 | 0x01, 3 << 3);

}

// kore_malloc
// file includes/kore.h line 457
void * kore_malloc(unsigned long int len)
{
  unsigned long int mlen;
  void *ptr;
  struct meminfo *mem;
  unsigned char *addr;
  unsigned int *plen;
  if(len == 0ul)
    fatal("kore_malloc(): zero size");

  mlen = sizeof(unsigned int) /*4ul*/  + len + sizeof(struct meminfo) /*2ul*/ ;
  ptr=malloc(mlen);
  signed int *return_value___errno_location_1;
  if(ptr == NULL)
  {
    return_value___errno_location_1=__errno_location();
    fatal("kore_malloc(%d): %d", len, *return_value___errno_location_1);
  }

  plen = (unsigned int *)ptr;
  *plen = (unsigned int)len;
  addr = (unsigned char *)ptr + (signed long int)sizeof(unsigned int) /*4ul*/ ;
  mem = (struct meminfo *)((unsigned char *)addr + (signed long int)*((unsigned int *)((unsigned char *)addr - (signed long int)sizeof(unsigned int) /*4ul*/ )));
  mem->magic = (unsigned short int)0xd0d0;
  return (void *)addr;
}

// kore_mem_find
// file includes/kore.h line 486
void * kore_mem_find(void *src, unsigned long int slen, void *needle, unsigned int len)
{
  unsigned char *p;
  unsigned char *end = (unsigned char *)src + (signed long int)slen;
  p = (unsigned char *)src;
  for( ; !(p >= end); p = p + 1l)
    if(*p == *((unsigned char *)needle))
    {
      if(!(end - p >= (signed long int)len))
        return (void *)0;

      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)p, needle, (unsigned long int)len);
      if(return_value_memcmp_1 == 0)
        return (void *)p;

    }

  return (void *)0;
}

// kore_mem_free
// file includes/kore.h line 461
void kore_mem_free(void *ptr)
{
  unsigned char *addr;
  struct meminfo *mem;
  if(!(ptr == NULL))
  {
    mem = (struct meminfo *)((unsigned char *)ptr + (signed long int)*((unsigned int *)((unsigned char *)ptr - (signed long int)sizeof(unsigned int) /*4ul*/ )));
    if(!((signed int)mem->magic == 0xd0d0))
      fatal("kore_mem_free(): magic boundary not found");

    addr = (unsigned char *)ptr - (signed long int)sizeof(unsigned int) /*4ul*/ ;
    free((void *)addr);
  }

}

// kore_mem_init
// file includes/kore.h line 462
void kore_mem_init(void)
{
  ;
}

// kore_module_getsym
// file src/module.c line 221
void * kore_module_getsym(const char *symbol)
{
  void *ptr;
  struct kore_module *module = (&modules)->tqh_first;
  for( ; !(module == ((struct kore_module *)NULL)); module = module->list.tqe_next)
  {
    ptr=dlsym(module->handle, symbol);
    if(!(ptr == NULL))
      return ptr;

  }
  return (void *)0;
}

// kore_module_handler_find
// file includes/kore.h line 510
struct kore_module_handle * kore_module_handler_find(const char *domain, const char *path)
{
  struct kore_domain *dom;
  struct kore_module_handle *hdlr;
  dom=kore_domain_lookup(domain);
  if(dom == ((struct kore_domain *)NULL))
    return (struct kore_module_handle *)(void *)0;

  else
  {
    hdlr = (&dom->handlers)->tqh_first;
    for( ; !(hdlr == ((struct kore_module_handle *)NULL)); hdlr = hdlr->list.tqe_next)
      if(hdlr->type == 1)
      {
        signed int return_value_strcmp_1;
        return_value_strcmp_1=strcmp(hdlr->path, path);
        if(return_value_strcmp_1 == 0)
          return hdlr;

      }

      else
      {
        signed int return_value_regexec_2;
        return_value_regexec_2=regexec(&hdlr->rctx, path, (unsigned long int)0, (struct anonymous_57 *)(void *)0, 0);
        if(return_value_regexec_2 == 0)
          return hdlr;

      }
    return (struct kore_module_handle *)(void *)0;
  }
}

// kore_module_handler_new
// file includes/kore.h line 506
signed int kore_module_handler_new(const char *path, const char *domain, const char *func, const char *auth, signed int type)
{
  struct kore_auth *ap;
  void *addr;
  struct kore_domain *dom;
  struct kore_module_handle *hdlr;
  addr=kore_module_getsym(func);
  if(addr == NULL)
    return 0;

  else
  {
    dom=kore_domain_lookup(domain);
    if(dom == ((struct kore_domain *)NULL))
      return 0;

    else
    {
      if(!(auth == ((const char *)NULL)))
      {
        ap=kore_auth_lookup(auth);
        if(ap == ((struct kore_auth *)NULL))
          fatal("no authentication block '%s' found", auth);

      }

      else
        ap = (struct kore_auth *)(void *)0;
      void *return_value_kore_malloc_1;
      return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_module_handle) /*144ul*/ );
      hdlr = (struct kore_module_handle *)return_value_kore_malloc_1;
      hdlr->auth = ap;
      hdlr->dom = dom;
      hdlr->errors = 0;
      hdlr->addr = addr;
      hdlr->type = type;
      do
      {
        (&hdlr->params)->tqh_first = (struct kore_handler_params *)(void *)0;
        (&hdlr->params)->tqh_last = &(&hdlr->params)->tqh_first;
      }
      while((_Bool)0);
      hdlr->path=kore_strdup(path);
      hdlr->func=kore_strdup(func);
      if(hdlr->type == 2)
      {
        signed int return_value_regcomp_2;
        return_value_regcomp_2=regcomp(&hdlr->rctx, hdlr->path, 1 | ((1 << 1) << 1) << 1);
        if(!(return_value_regcomp_2 == 0))
        {
          kore_mem_free((void *)hdlr->func);
          kore_mem_free((void *)hdlr->path);
          kore_mem_free((void *)hdlr);
          return 0;
        }

      }

      do
      {
        hdlr->list.tqe_next = (struct kore_module_handle *)(void *)0;
        hdlr->list.tqe_prev = (&dom->handlers)->tqh_last;
        *(&dom->handlers)->tqh_last = hdlr;
        (&dom->handlers)->tqh_last = &hdlr->list.tqe_next;
      }
      while((_Bool)0);
      return 1;
    }
  }
}

// kore_module_init
// file includes/kore.h line 497
void kore_module_init(void)
{
  do
  {
    (&modules)->tqh_first = (struct kore_module *)(void *)0;
    (&modules)->tqh_last = &(&modules)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&domains)->tqh_first = (struct kore_domain *)(void *)0;
    (&domains)->tqh_last = &(&domains)->tqh_first;
  }
  while((_Bool)0);
}

// kore_module_load
// file includes/kore.h line 504
void kore_module_load(const char *path, const char *onload)
{
  struct stat st;
  struct kore_module *module;
  signed int return_value_stat_3;
  return_value_stat_3=stat(path, &st);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_stat_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("stat(%s): %s", path, return_value_strerror_2);
  }

  void *return_value_kore_malloc_4;
  return_value_kore_malloc_4=kore_malloc(sizeof(struct kore_module) /*56ul*/ );
  module = (struct kore_module *)return_value_kore_malloc_4;
  module->path=kore_strdup(path);
  module->mtime = st.st_mtim.tv_sec;
  module->onload = (char *)(void *)0;
  module->ocb = (signed int (*)(signed int))(void *)0;
  module->handle=dlopen(module->path, 0x00002 | 0x00100);
  char *return_value_dlerror_5;
  if(module->handle == NULL)
  {
    return_value_dlerror_5=dlerror();
    fatal("%s: %s", path, return_value_dlerror_5);
  }

  if(!(onload == ((const char *)NULL)))
  {
    module->onload=kore_strdup(onload);
    void *return_value_dlsym_6;
    return_value_dlsym_6=dlsym(module->handle, onload);
    module->ocb = (signed int (*)(signed int))return_value_dlsym_6;
    if(module->ocb == ((signed int (*)(signed int))NULL))
      fatal("%s: onload '%s' not present", path, onload);

  }

  do
  {
    module->list.tqe_next = (struct kore_module *)(void *)0;
    module->list.tqe_prev = (&modules)->tqh_last;
    *(&modules)->tqh_last = module;
    (&modules)->tqh_last = &module->list.tqe_next;
  }
  while((_Bool)0);
}

// kore_module_loaded
// file includes/kore.h line 500
signed int kore_module_loaded(void)
{
  if(modules.tqh_first == ((struct kore_module *)NULL))
    return 0;

  else
    return 1;
}

// kore_module_onload
// file src/module.c line 64
void kore_module_onload(void)
{
  struct kore_module *module = (&modules)->tqh_first;
  for( ; !(module == ((struct kore_module *)NULL)); module = module->list.tqe_next)
    if(!(module->ocb == ((signed int (*)(signed int))NULL)))
      module->ocb(1);

}

// kore_module_reload
// file includes/kore.h line 498
void kore_module_reload(signed int cbs)
{
  struct stat st;
  struct kore_domain *dom;
  struct kore_module_handle *hdlr;
  struct kore_module *module = (&modules)->tqh_first;
  char *return_value_dlerror_4;
  char *return_value_dlerror_6;
  for( ; !(module == ((struct kore_module *)NULL)); module = module->list.tqe_next)
  {
    signed int return_value_stat_3;
    return_value_stat_3=stat(module->path, &st);
    if(return_value_stat_3 == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      kore_log(5, "stat(%s): %s, skipping reload", module->path, return_value_strerror_2);
      goto __CPROVER_DUMP_L11;
    }

    if(!(module->mtime == st.st_mtim.tv_sec))
    {
      if(!(module->ocb == ((signed int (*)(signed int))NULL)))
      {
        if(cbs == 1)
        {
          signed int return_value;
          return_value=module->ocb(2);
          if(return_value == 0)
            kore_log(5, "not reloading %s", module->path);

        }

      }

      module->mtime = st.st_mtim.tv_sec;
      signed int return_value_dlclose_5;
      return_value_dlclose_5=dlclose(module->handle);
      if(!(return_value_dlclose_5 == 0))
      {
        return_value_dlerror_4=dlerror();
        fatal("cannot close existing module: %s", return_value_dlerror_4);
      }

      module->handle=dlopen(module->path, 0x00002 | 0x00100);
      if(module->handle == NULL)
      {
        return_value_dlerror_6=dlerror();
        fatal("kore_module_reload(): %s", return_value_dlerror_6);
      }

      if(!(module->onload == ((char *)NULL)))
      {
        void *return_value_dlsym_7;
        return_value_dlsym_7=dlsym(module->handle, module->onload);
        module->ocb = (signed int (*)(signed int))return_value_dlsym_7;
        if(module->ocb == ((signed int (*)(signed int))NULL))
          fatal("%s: onload '%s' not present", module->path, module->onload);

        if(!(cbs == 0))
          module->ocb(1);

      }

      kore_log(5, "reloaded '%s' module", module->path);
    }


  __CPROVER_DUMP_L11:
    ;
  }
  dom = (&domains)->tqh_first;
  for( ; !(dom == ((struct kore_domain *)NULL)); dom = dom->list.tqe_next)
  {
    hdlr = (&dom->handlers)->tqh_first;
    for( ; !(hdlr == ((struct kore_module_handle *)NULL)); hdlr = hdlr->list.tqe_next)
    {
      hdlr->addr=kore_module_getsym(hdlr->func);
      if(hdlr->func == ((char *)NULL))
        fatal("no function '%s' found", hdlr->func);

      hdlr->errors = 0;
    }
  }
  kore_validator_reload();
}

// kore_parse_config
// file includes/kore.h line 458
void kore_parse_config(void)
{
  kore_parse_config_file(config_file);
  signed int return_value_kore_module_loaded_1;
  return_value_kore_module_loaded_1=kore_module_loaded();
  if(return_value_kore_module_loaded_1 == 0)
    fatal("no site module was loaded");

  if(listeners.lh_first == ((struct listener *)NULL))
    fatal("no listeners defined");

  if(chroot_path == ((char *)NULL) && !(skip_chroot == 1))
    fatal("missing a chroot path");

  unsigned int return_value_getuid_2;
  return_value_getuid_2=getuid();
  if(!(return_value_getuid_2 == 0u))
  {
    if(skip_chroot == 0)
      fatal("cannot chroot, use -n to skip it");

  }

  if(runas_user == ((char *)NULL) && !(skip_runas == 1))
    fatal("missing runas user");

  unsigned int return_value_getuid_3;
  return_value_getuid_3=getuid();
  if(!(return_value_getuid_3 == 0u))
  {
    if(skip_runas == 0)
      fatal("cannot drop privileges, use -p to skip it");

  }

}

// kore_parse_config_file
// file src/config.c line 161
static void kore_parse_config_file(char *fpath)
{
  struct _IO_FILE *fp;
  signed int i;
  signed int lineno;
  char buf[8192l];
  char *p;
  char *t;
  char *argv[5l];
  fp=fopen(fpath, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    fatal("configuration given cannot be opened: %s", fpath);

  lineno = 1;
  char *return_value_fgets_1;
  const unsigned short int **return_value___ctype_b_loc_3;
  _Bool tmp_if_expr_4;
  do
  {
    return_value_fgets_1=fgets(buf, (signed int)sizeof(char [8192l]) /*8192ul*/ , fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    p = buf;
    unsigned long int return_value_strcspn_2;
    return_value_strcspn_2=strcspn(buf, "\n");
    buf[(signed long int)return_value_strcspn_2] = (char)0;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*p]) == 0)
        break;

      p = p + 1l;
    }
    while((_Bool)1);
    if((signed int)*p == 35)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)p[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      lineno = lineno + 1;

    else
    {
      t = p;
      for( ; !((signed int)*t == 0); t = t + 1l)
        if((signed int)*t == 9)
          *t = (char)32;

      signed int return_value_strcmp_5;
      return_value_strcmp_5=strcmp(p, "}");
      if(return_value_strcmp_5 == 0)
      {
        if(current_handler == ((struct kore_module_handle *)NULL))
          goto __CPROVER_DUMP_L11;

        lineno = lineno + 1;
        current_handler = (struct kore_module_handle *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L11:
        ;
        signed int return_value_strcmp_6;
        return_value_strcmp_6=strcmp(p, "}");
        if(return_value_strcmp_6 == 0)
        {
          if(current_auth == ((struct kore_auth *)NULL))
            goto __CPROVER_DUMP_L13;

          if(current_auth->validator == ((struct kore_validator *)NULL))
            fatal("no authentication validator for %s", current_auth->name);

          lineno = lineno + 1;
          current_auth = (struct kore_auth *)(void *)0;
        }

        else
        {

        __CPROVER_DUMP_L13:
          ;
          signed int return_value_strcmp_7;
          return_value_strcmp_7=strcmp(p, "}");
          if(return_value_strcmp_7 == 0)
          {
            if(!(current_domain == ((struct kore_domain *)NULL)))
              domain_sslstart();

          }

          signed int return_value_strcmp_8;
          return_value_strcmp_8=strcmp(p, "}");
          if(return_value_strcmp_8 == 0)
            lineno = lineno + 1;

          else
          {
            kore_split_string(p, " ", argv, (unsigned long int)5);
            i = 0;
            for( ; !(config_names[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
            {
              signed int return_value_strcmp_9;
              return_value_strcmp_9=strcmp(config_names[(signed long int)i].name, argv[(signed long int)0]);
              if(return_value_strcmp_9 == 0)
              {
                signed int return_value;
                return_value=config_names[(signed long int)i].configure(argv);
                if(return_value == 0)
                  fatal("configuration error on line %d", lineno);

                break;
              }

            }
            if(config_names[(signed long int)i].name == ((const char *)NULL))
              printf("unknown configuration option \"%s\" on line %d\n", p, lineno);

            lineno = lineno + 1;
          }
        }
      }
    }
  }
  while((_Bool)1);
  fclose(fp);
}

// kore_pgsql_cleanup
// file includes/pgsql.h line 52
void kore_pgsql_cleanup(struct kore_pgsql *pgsql)
{
  if(!(pgsql->result == ((struct pg_result *)NULL)))
    PQclear(pgsql->result);

  if(!(pgsql->error == ((char *)NULL)))
    kore_mem_free((void *)pgsql->error);

  if(!(pgsql->conn == ((struct pgsql_conn *)NULL)))
    pgsql_conn_release(pgsql);

  pgsql->result = (struct pg_result *)(void *)0;
  pgsql->error = (char *)(void *)0;
  pgsql->conn = (struct pgsql_conn *)(void *)0;
  do
  {
    if(!(pgsql->rlist.le_next == ((struct kore_pgsql *)NULL)))
      pgsql->rlist.le_next->rlist.le_prev = pgsql->rlist.le_prev;

    *pgsql->rlist.le_prev = pgsql->rlist.le_next;
  }
  while((_Bool)0);
}

// kore_pgsql_continue
// file src/pgsql.c line 171
void kore_pgsql_continue(struct http_request *req, struct kore_pgsql *pgsql)
{
  if(!(pgsql->error == ((char *)NULL)))
  {
    kore_mem_free((void *)pgsql->error);
    pgsql->error = (char *)(void *)0;
  }

  if(!(pgsql->result == ((struct pg_result *)NULL)))
  {
    PQclear(pgsql->result);
    pgsql->result = (struct pg_result *)(void *)0;
  }

  switch((signed int)pgsql->state)
  {
    case 1:

    case 2:
      break;
    case 5:
    {
      http_request_wakeup(req);
      pgsql_conn_release(pgsql);
      break;
    }
    case 4:

    case 3:
    {
      kore_pgsql_handle((void *)pgsql->conn, 0);
      break;
    }
    default:
      fatal("unknown pgsql state %d", pgsql->state);
  }
}

// kore_pgsql_getlength
// file src/pgsql.c line 238
signed int kore_pgsql_getlength(struct kore_pgsql *pgsql, signed int row, signed int col)
{
  signed int return_value_PQgetlength_1;
  return_value_PQgetlength_1=PQgetlength(pgsql->result, row, col);
  return return_value_PQgetlength_1;
}

// kore_pgsql_getvalue
// file src/pgsql.c line 244
char * kore_pgsql_getvalue(struct kore_pgsql *pgsql, signed int row, signed int col)
{
  char *return_value_PQgetvalue_1;
  return_value_PQgetvalue_1=PQgetvalue(pgsql->result, row, col);
  return return_value_PQgetvalue_1;
}

// kore_pgsql_handle
// file src/pgsql.c line 141
void kore_pgsql_handle(void *c, signed int err)
{
  struct http_request *req;
  struct kore_pgsql *pgsql;
  struct pgsql_conn *conn = (struct pgsql_conn *)c;
  if(!(err == 0))
    pgsql_conn_cleanup(conn);

  else
  {
    req = conn->job->req;
    pgsql = conn->job->pgsql;
    signed int return_value_PQconsumeInput_2;
    return_value_PQconsumeInput_2=PQconsumeInput(conn->db);
    if(return_value_PQconsumeInput_2 == 0)
    {
      pgsql->state = (unsigned char)4;
      char *return_value_PQerrorMessage_1;
      return_value_PQerrorMessage_1=PQerrorMessage(conn->db);
      pgsql->error=kore_strdup(return_value_PQerrorMessage_1);
    }

    else
      pgsql_read_result(pgsql, 1);
    if((signed int)pgsql->state == 2)
      http_request_sleep(req);

    else
      http_request_wakeup(req);
  }
}

// kore_pgsql_init
// file includes/pgsql.h line 50
void kore_pgsql_init(void)
{
  pgsql_conn_count = (unsigned short int)0;
  do
  {
    (&pgsql_conn_free)->tqh_first = (struct pgsql_conn *)(void *)0;
    (&pgsql_conn_free)->tqh_last = &(&pgsql_conn_free)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&pgsql_wait_queue)->tqh_first = (struct pgsql_wait *)(void *)0;
    (&pgsql_wait_queue)->tqh_last = &(&pgsql_wait_queue)->tqh_first;
  }
  while((_Bool)0);
  kore_pool_init(&pgsql_job_pool, "pgsql_job_pool", (unsigned int)sizeof(struct pgsql_job) /*40ul*/ , (unsigned int)100);
  kore_pool_init(&pgsql_wait_pool, "pgsql_wait_pool", (unsigned int)sizeof(struct pgsql_wait) /*24ul*/ , (unsigned int)100);
}

// kore_pgsql_logerror
// file src/pgsql.c line 225
void kore_pgsql_logerror(struct kore_pgsql *pgsql)
{
  char *tmp_if_expr_1;
  if(!(pgsql->error == ((char *)NULL)))
    tmp_if_expr_1 = pgsql->error;

  else
    tmp_if_expr_1 = "unknown";
  kore_log(5, "pgsql error: %s", tmp_if_expr_1);
}

// kore_pgsql_ntuples
// file src/pgsql.c line 232
signed int kore_pgsql_ntuples(struct kore_pgsql *pgsql)
{
  signed int return_value_PQntuples_1;
  return_value_PQntuples_1=PQntuples(pgsql->result);
  return return_value_PQntuples_1;
}

// kore_pgsql_query
// file src/pgsql.c line 78
signed int kore_pgsql_query(struct kore_pgsql *pgsql, struct http_request *req, const char *query)
{
  signed int return_value_pgsql_prepare_1;
  return_value_pgsql_prepare_1=pgsql_prepare(pgsql, req, query);
  if(return_value_pgsql_prepare_1 == 0)
    return 0;

  else
  {
    signed int return_value_PQsendQuery_2;
    return_value_PQsendQuery_2=PQsendQuery(pgsql->conn->db, query);
    if(return_value_PQsendQuery_2 == 0)
    {
      pgsql_conn_cleanup(pgsql->conn);
      return 0;
    }

    else
    {
      pgsql_schedule(pgsql, req);
      return 1;
    }
  }
}

// kore_pgsql_query_params
// file src/pgsql.c line 94
signed int kore_pgsql_query_params(struct kore_pgsql *pgsql, struct http_request *req, const char *query, signed int result, unsigned char count, ...)
{
  unsigned char i;
  __builtin_va_list args;
  char **values;
  signed int *lengths;
  signed int *formats;
  signed int return_value_pgsql_prepare_1;
  return_value_pgsql_prepare_1=pgsql_prepare(pgsql, req, query);
  if(return_value_pgsql_prepare_1 == 0)
    return 0;

  else
  {
    if((signed int)count >= 1)
    {
      va_start(args, count);
      void *return_value_kore_calloc_2;
      return_value_kore_calloc_2=kore_calloc((unsigned long int)count, sizeof(signed int) /*4ul*/ );
      lengths = (signed int *)return_value_kore_calloc_2;
      void *return_value_kore_calloc_3;
      return_value_kore_calloc_3=kore_calloc((unsigned long int)count, sizeof(signed int) /*4ul*/ );
      formats = (signed int *)return_value_kore_calloc_3;
      void *return_value_kore_calloc_4;
      return_value_kore_calloc_4=kore_calloc((unsigned long int)count, sizeof(char *) /*8ul*/ );
      values = (char **)return_value_kore_calloc_4;
      i = (unsigned char)0;
      for( ; !((signed int)i >= (signed int)count); i = i + 1)
      {
        void *return_value_gcc_builtin_va_arg_5;
        return_value_gcc_builtin_va_arg_5=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_5));
        values[(signed long int)i] = (char *)return_value_gcc_builtin_va_arg_5;
        unsigned int return_value_gcc_builtin_va_arg_6;
        return_value_gcc_builtin_va_arg_6=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_6));
        lengths[(signed long int)i] = (signed int)return_value_gcc_builtin_va_arg_6;
        formats[(signed long int)i]=va_arg(args, __typeof__(formats[(signed long int)i]));
      }
    }

    else
    {
      lengths = (signed int *)(void *)0;
      formats = (signed int *)(void *)0;
      values = (char **)(void *)0;
    }
    signed int return_value_PQsendQueryParams_7;
    return_value_PQsendQueryParams_7=PQsendQueryParams(pgsql->conn->db, query, (signed int)count, (const unsigned int *)(void *)0, (const char * const *)values, lengths, formats, result);
    if(return_value_PQsendQueryParams_7 == 0)
    {
      kore_mem_free((void *)values);
      kore_mem_free((void *)lengths);
      kore_mem_free((void *)formats);
      pgsql_conn_cleanup(pgsql->conn);
      return 0;
    }

    else
    {
      kore_mem_free((void *)values);
      kore_mem_free((void *)lengths);
      kore_mem_free((void *)formats);
      pgsql_schedule(pgsql, req);
      return 1;
    }
  }
}

// kore_pgsql_queue_remove
// file includes/pgsql.h line 61
void kore_pgsql_queue_remove(struct http_request *req)
{
  struct pgsql_wait *pgw;
  struct pgsql_wait *next;
  pgw = (&pgsql_wait_queue)->tqh_first;
  for( ; !(pgw == ((struct pgsql_wait *)NULL)); pgw = next)
  {
    next = pgw->list.tqe_next;
    if(pgw->req == req)
    {
      do
      {
        if(!(pgw->list.tqe_next == ((struct pgsql_wait *)NULL)))
          pgw->list.tqe_next->list.tqe_prev = pgw->list.tqe_prev;

        else
          (&pgsql_wait_queue)->tqh_last = pgw->list.tqe_prev;
        *pgw->list.tqe_prev = pgw->list.tqe_next;
      }
      while((_Bool)0);
      kore_pool_put(&pgsql_wait_pool, (void *)pgw);
      goto __CPROVER_DUMP_L7;
    }

  }

__CPROVER_DUMP_L7:
  ;
}

// kore_platform_disable_accept
// file includes/kore.h line 414
void kore_platform_disable_accept(void)
{
  struct listener *l = (&listeners)->lh_first;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  for( ; !(l == ((struct listener *)NULL)); l = l->list.le_next)
  {
    signed int return_value_epoll_ctl_3;
    return_value_epoll_ctl_3=epoll_ctl(efd, 2, l->fd, (struct epoll_event *)(void *)0);
    if(return_value_epoll_ctl_3 == -1)
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fatal("kore_platform_disable_accept: %s", return_value_strerror_2);
    }

  }
}

// kore_platform_disable_read
// file includes/kore.h line 412
void kore_platform_disable_read(signed int fd)
{
  signed int return_value_epoll_ctl_3;
  return_value_epoll_ctl_3=epoll_ctl(efd, 2, fd, (struct epoll_event *)(void *)0);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_epoll_ctl_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("kore_platform_disable_read: %s", return_value_strerror_2);
  }

}

// kore_platform_enable_accept
// file includes/kore.h line 413
void kore_platform_enable_accept(void)
{
  struct listener *l = (&listeners)->lh_first;
  for( ; !(l == ((struct listener *)NULL)); l = l->list.le_next)
    kore_platform_event_schedule(l->fd, 1, 0, (void *)l);
}

// kore_platform_event_all
// file src/linux.c line 179
void kore_platform_event_all(signed int fd, void *c)
{
  kore_platform_event_schedule(fd, 1 | 4 | 8192 | -2147483648, 0, c);
}

// kore_platform_event_init
// file includes/kore.h line 410
void kore_platform_event_init(void)
{
  efd=epoll_create(10000);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(efd == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("epoll_create(): %s", return_value_strerror_2);
  }

  event_count = worker_max_connections + (unsigned int)nlisteners;
  void *return_value_kore_calloc_3;
  return_value_kore_calloc_3=kore_calloc((unsigned long int)event_count, sizeof(struct epoll_event) /*12ul*/ );
  events = (struct epoll_event *)return_value_kore_calloc_3;
}

// kore_platform_event_schedule
// file src/linux.c line 186
void kore_platform_event_schedule(signed int fd, signed int type, signed int flags, void *udata)
{
  struct epoll_event evt;
  evt.events = (unsigned int)type;
  evt.data.ptr = udata;
  signed int return_value_epoll_ctl_7;
  return_value_epoll_ctl_7=epoll_ctl(efd, 1, fd, &evt);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_epoll_ctl_7 == -1)
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    if(*return_value___errno_location_6 == 17)
    {
      signed int return_value_epoll_ctl_3;
      return_value_epoll_ctl_3=epoll_ctl(efd, 3, fd, &evt);
      if(return_value_epoll_ctl_3 == -1)
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fatal("epoll_ctl() MOD: %s", return_value_strerror_2);
      }

    }

    else
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fatal("epoll_ctl() ADD: %s", return_value_strerror_5);
    }
  }

}

// kore_platform_event_wait
// file includes/kore.h line 415
signed int kore_platform_event_wait(unsigned long int timer)
{
  unsigned int r;
  struct connection *c;
  struct listener *l;
  unsigned char type;
  signed int n;
  signed int i;
  n=epoll_wait(efd, events, (signed int)event_count, (signed int)timer);
  if(n == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 4)
      return 0;

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fatal("epoll_wait(): %s", return_value_strerror_3);
  }

  r = (unsigned int)0;
  i = 0;
  _Bool tmp_if_expr_4;
  signed int return_value_kore_connection_handle_6;
  for( ; !(i >= n); i = i + 1)
  {
    if((events + (signed long int)i)->data.ptr == NULL)
      fatal("events[%d].data.ptr == NULL", i);

    type = *((unsigned char *)(events + (signed long int)i)->data.ptr);
    if(!((8u & (events + (signed long int)i)->events) == 0u))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = ((events + (signed long int)i)->events & (unsigned int)16) != 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      switch((signed int)type)
      {
        case 1:
          fatal("failed on listener socket");
        case 3:
        {
          kore_pgsql_handle((events + (signed long int)i)->data.ptr, 1);
          break;
        }
        case 4:
        {
          kore_task_handle((struct kore_task *)(events + (signed long int)i)->data.ptr, 1);
          break;
        }
        default:
        {
          c = (struct connection *)(events + (signed long int)i)->data.ptr;
          kore_connection_disconnect(c);
        }
      }

    else
      switch((signed int)type)
      {
        case 1:
        {
          l = (struct listener *)(events + (signed long int)i)->data.ptr;
          while(!(worker_active_connections >= worker_max_connections))
          {
            if(r >= worker_accept_threshold && !(worker_accept_threshold == 0u))
              break;

            signed int return_value_kore_connection_accept_5;
            return_value_kore_connection_accept_5=kore_connection_accept(l, &c);
            if(return_value_kore_connection_accept_5 == 0)
            {
              r = (unsigned int)1;
              break;
            }

            if(c == ((struct connection *)NULL))
              break;

            r = r + 1u;
            kore_platform_event_all(c->fd, (void *)c);
          }
          break;
        }
        case 2:
        {
          c = (struct connection *)(events + (signed long int)i)->data.ptr;
          if(!((1u & (events + (signed long int)i)->events) == 0u))
          {
            if((0x20 & (signed int)c->flags) == 0)
              c->flags = c->flags | (unsigned char)0x01;

          }

          if(!((4u & (events + (signed long int)i)->events) == 0u))
          {
            if((0x04 & (signed int)c->flags) == 0)
              c->flags = c->flags | (unsigned char)0x02;

          }

          return_value_kore_connection_handle_6=kore_connection_handle(c);
          if(return_value_kore_connection_handle_6 == 0)
            kore_connection_disconnect(c);

          break;
        }
        case 3:
        {
          kore_pgsql_handle((events + (signed long int)i)->data.ptr, 0);
          break;
        }
        case 4:
        {
          kore_task_handle((struct kore_task *)(events + (signed long int)i)->data.ptr, 0);
          break;
        }
        default:
          fatal("wrong type in event %d", type);
      }
  }
  return (signed int)r;
}

// kore_platform_init
// file includes/kore.h line 409
void kore_platform_init(void)
{
  signed long int n;
  n=sysconf(84);
  if(n == -1l)
    cpu_count = (unsigned short int)1;

  else
    cpu_count = (unsigned short int)n;
}

// kore_platform_proctitle
// file includes/kore.h line 411
void kore_platform_proctitle(char *title)
{
  signed int return_value_prctl_1;
  return_value_prctl_1=prctl(15, title);
}

// kore_platform_schedule_read
// file includes/kore.h line 417
void kore_platform_schedule_read(signed int fd, void *data)
{
  kore_platform_event_schedule(fd, 1, 0, data);
}

// kore_platform_worker_setcpu
// file includes/kore.h line 419
void kore_platform_worker_setcpu(struct kore_worker *kw)
{
  struct anonymous_18 cpuset;
  do
    __builtin_memset((void *)&cpuset, 0, sizeof(struct anonymous_18) /*128ul*/ );
  while((_Bool)0);
  unsigned long int __cpu = (unsigned long int)kw->cpu;
  if(!(__cpu / 8ul >= sizeof(struct anonymous_18) /*128ul*/ ))
    ((unsigned long int *)(&cpuset)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&cpuset)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

  else
    (unsigned long int)0;
  signed int return_value_sched_setaffinity_1;
  return_value_sched_setaffinity_1=sched_setaffinity(0, sizeof(struct anonymous_18) /*128ul*/ , &cpuset);
}

// kore_pool_get
// file includes/kore.h line 468
void * kore_pool_get(struct kore_pool *pool)
{
  unsigned char *ptr;
  struct kore_pool_entry *entry;
  if(pool->freelist.lh_first == ((struct kore_pool_entry *)NULL))
  {
    kore_log(5, "pool %s is exhausted (%d/%d)", pool->name, pool->inuse, pool->elms);
    pool_region_create(pool, pool->elms);
  }

  entry = (&pool->freelist)->lh_first;
  if(!((signed int)entry->state == 1))
    fatal("%s: element %p was not free", pool->name, entry);

  do
  {
    if(!(entry->list.le_next == ((struct kore_pool_entry *)NULL)))
      entry->list.le_next->list.le_prev = entry->list.le_prev;

    *entry->list.le_prev = entry->list.le_next;
  }
  while((_Bool)0);
  entry->state = (unsigned char)0;
  ptr = (unsigned char *)entry + (signed long int)sizeof(struct kore_pool_entry) /*32ul*/ ;
  pool->inuse = pool->inuse + 1u;
  return (void *)ptr;
}

// kore_pool_init
// file includes/kore.h line 470
void kore_pool_init(struct kore_pool *pool, const char *name, unsigned int len, unsigned int elm)
{
  pool->elms = (unsigned int)0;
  pool->inuse = (unsigned int)0;
  pool->elen = len;
  pool->name=kore_strdup(name);
  pool->slen = (unsigned int)((unsigned long int)pool->elen + sizeof(struct kore_pool_entry) /*32ul*/ );
  do
    (&pool->regions)->lh_first = (struct kore_pool_region *)(void *)0;
  while((_Bool)0);
  do
    (&pool->freelist)->lh_first = (struct kore_pool_entry *)(void *)0;
  while((_Bool)0);
  pool_region_create(pool, elm);
}

// kore_pool_put
// file includes/kore.h line 469
void kore_pool_put(struct kore_pool *pool, void *ptr)
{
  struct kore_pool_entry *entry = (struct kore_pool_entry *)((unsigned char *)ptr - (signed long int)sizeof(struct kore_pool_entry) /*32ul*/ );
  if(!((signed int)entry->state == 0))
    fatal("%s: element %p was not busy", pool->name, ptr);

  entry->state = (unsigned char)1;
  do
  {
    entry->list.le_next = (&pool->freelist)->lh_first;
    if(!(entry->list.le_next == ((struct kore_pool_entry *)NULL)))
      (&pool->freelist)->lh_first->list.le_prev = &entry->list.le_next;

    (&pool->freelist)->lh_first = entry;
    entry->list.le_prev = &(&pool->freelist)->lh_first;
  }
  while((_Bool)0);
  pool->inuse = pool->inuse - 1u;
}

// kore_realloc
// file includes/kore.h line 460
void * kore_realloc(void *ptr, unsigned long int len)
{
  struct meminfo *mem;
  void *nptr;
  if(len == 0ul)
    fatal("kore_realloc(): zero size");

  unsigned long int tmp_if_expr_1;
  if(ptr == NULL)
    nptr=kore_malloc(len);

  else
  {
    mem = (struct meminfo *)((unsigned char *)ptr + (signed long int)*((unsigned int *)((unsigned char *)ptr - (signed long int)sizeof(unsigned int) /*4ul*/ )));
    if(!((signed int)mem->magic == 0xd0d0))
      fatal("kore_realloc(): magic boundary not found");

    nptr=kore_malloc(len);
    if(!(len >= (unsigned long int)*((unsigned int *)((unsigned char *)ptr + -4l))))
      tmp_if_expr_1 = len;

    else
      tmp_if_expr_1 = (unsigned long int)*((unsigned int *)((unsigned char *)ptr - (signed long int)sizeof(unsigned int) /*4ul*/ ));
    memcpy(nptr, ptr, tmp_if_expr_1);
    kore_mem_free(ptr);
  }
  return nptr;
}

// kore_server_bind
// file src/kore.c line 228
signed int kore_server_bind(const char *ip, const char *port)
{
  struct listener *l;
  signed int on;
  signed int r;
  struct addrinfo *results;
  r=getaddrinfo(ip, port, (struct addrinfo *)(void *)0, &results);
  const char *return_value_gai_strerror_1;
  if(!(r == 0))
  {
    return_value_gai_strerror_1=gai_strerror(r);
    fatal("getaddrinfo(%s): %s", ip, return_value_gai_strerror_1);
  }

  void *return_value_kore_malloc_2;
  return_value_kore_malloc_2=kore_malloc(sizeof(struct listener) /*56ul*/ );
  l = (struct listener *)return_value_kore_malloc_2;
  l->type = (unsigned char)1;
  l->addrtype = (unsigned char)results->ai_family;
  if(!((signed int)l->addrtype == 2))
  {
    if(!((signed int)l->addrtype == 10))
      fatal("getaddrinfo(): unknown address family %d", l->addrtype);

  }

  l->fd=socket(results->ai_family, 1, 0);
  if(l->fd == -1)
  {
    kore_mem_free((void *)l);
    freeaddrinfo(results);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    printf("failed to create socket: %s\n", return_value_strerror_4);
    return 0;
  }

  signed int return_value_kore_connection_nonblock_7;
  return_value_kore_connection_nonblock_7=kore_connection_nonblock(l->fd);
  if(return_value_kore_connection_nonblock_7 == 0)
  {
    kore_mem_free((void *)l);
    freeaddrinfo(results);
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    printf("failed to make socket non blocking: %s\n", return_value_strerror_6);
    return 0;
  }

  on = 1;
  signed int return_value_setsockopt_10;
  return_value_setsockopt_10=setsockopt(l->fd, 1, 2, (const void *)(const char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt_10 == -1)
  {
    close(l->fd);
    kore_mem_free((void *)l);
    freeaddrinfo(results);
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    printf("failed to set SO_REUSEADDR: %s\n", return_value_strerror_9);
    return 0;
  }

  signed int return_value_bind_13;
  return_value_bind_13=bind(l->fd, results->ai_addr, results->ai_addrlen);
  if(return_value_bind_13 == -1)
  {
    close(l->fd);
    kore_mem_free((void *)l);
    freeaddrinfo(results);
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    printf("failed to bind to %s port %s: %s\n", ip, port, return_value_strerror_12);
    return 0;
  }

  freeaddrinfo(results);
  signed int return_value_listen_16;
  return_value_listen_16=listen(l->fd, (signed int)kore_socket_backlog);
  if(return_value_listen_16 == -1)
  {
    close(l->fd);
    kore_mem_free((void *)l);
    signed int *return_value___errno_location_14;
    return_value___errno_location_14=__errno_location();
    char *return_value_strerror_15;
    return_value_strerror_15=strerror(*return_value___errno_location_14);
    printf("failed to listen on socket: %s\n", return_value_strerror_15);
    return 0;
  }

  nlisteners = nlisteners + 1;
  do
  {
    l->list.le_next = (&listeners)->lh_first;
    if(!(l->list.le_next == ((struct listener *)NULL)))
      (&listeners)->lh_first->list.le_prev = &l->list.le_next;

    (&listeners)->lh_first = l;
    l->list.le_prev = &(&listeners)->lh_first;
  }
  while((_Bool)0);
  if(!(foreground == 0))
    kore_log(5, "running on https://%s:%s", ip, port);

  return 1;
}

// kore_server_sslstart
// file src/kore.c line 308
static void kore_server_sslstart(void)
{
  SSL_library_init();
  SSL_load_error_strings();
}

// kore_server_start
// file src/kore.c line 319
static void kore_server_start(void)
{
  signed int quit;
  signed int return_value_daemon_3;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(foreground == 0)
  {
    return_value_daemon_3=daemon(1, 1);
    if(return_value_daemon_3 == -1)
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fatal("cannot daemon(): %s", return_value_strerror_2);
    }

  }

  kore_pid=getpid();
  if(foreground == 0)
    kore_write_kore_pid();

  kore_log(5, "kore is starting up");
  kore_log(5, "pgsql built-in enabled");
  kore_log(5, "tasks built-in enabled");
  kore_platform_proctitle("kore [parent]");
  kore_worker_init();
  quit = 0;
  while(!(quit == 1))
  {
    if(!(sig_recv == 0))
    {
      switch(sig_recv)
      {
        case 1:
        {
          kore_worker_dispatch_signal(sig_recv);
          kore_module_reload(0);
          break;
        }
        case 2:

        case 3:
        {
          quit = 1;
          kore_worker_dispatch_signal(sig_recv);
          goto __CPROVER_DUMP_L9;
        }
        default:
          kore_log(5, "no action taken for signal %d", sig_recv);
      }
      sig_recv = 0;
    }

    signed int return_value_kore_accesslog_wait_4;
    return_value_kore_accesslog_wait_4=kore_accesslog_wait();
    if(return_value_kore_accesslog_wait_4 == 0)
      break;

    kore_worker_wait(0);

  __CPROVER_DUMP_L9:
    ;
  }
}

// kore_signal
// file src/kore.c line 302
void kore_signal(signed int sig)
{
  sig_recv = sig;
}

// kore_snprintf
// file includes/kore.h line 482
signed int kore_snprintf(char *str, unsigned long int size, signed int *len, const char *fmt, ...)
{
  signed int l;
  void **args = (void **)&fmt;
  l=vsnprintf(str, size, fmt, args);
  args = ((void **)NULL);
  if(l == -1 || (unsigned long int)l >= size)
    return 0;

  else
  {
    if(!(len == ((signed int *)NULL)))
      *len = l;

    return 1;
  }
}

// kore_split_string
// file includes/kore.h line 480
signed int kore_split_string(char *input, char *delim, char **out, unsigned long int ele)
{
  signed int count;
  char **ap;
  count = 0;
  ap = out;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(ap >= out + -1l + (signed long int)ele))
    {
      *ap=strsep(&input, delim);
      tmp_if_expr_1 = *ap != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    if(!((signed int)*(*ap) == 0))
    {
      ap = ap + 1l;
      count = count + 1;
    }

  }
  while((_Bool)1);
  *ap = (char *)(void *)0;
  return count;
}

// kore_strdup
// file includes/kore.h line 475
char * kore_strdup(const char *str)
{
  unsigned long int len;
  char *nstr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  len = return_value_strlen_1 + (unsigned long int)1;
  void *return_value_kore_malloc_2;
  return_value_kore_malloc_2=kore_malloc(len);
  nstr = (char *)return_value_kore_malloc_2;
  kore_strlcpy(nstr, str, len);
  return nstr;
}

// kore_strip_chars
// file includes/kore.h line 481
void kore_strip_chars(char *in, char strip, char **out)
{
  unsigned int len;
  char *s;
  char *p;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(in);
  len = (unsigned int)return_value_strlen_1;
  void *return_value_kore_malloc_2;
  return_value_kore_malloc_2=kore_malloc((unsigned long int)(len + (unsigned int)1));
  *out = (char *)return_value_kore_malloc_2;
  p = *out;
  s = in;
  char *tmp_post_3;
  for( ; !(s >= in + (signed long int)len); s = s + 1l)
    if(!(*s == strip))
    {
      tmp_post_3 = p;
      p = p + 1l;
      *tmp_post_3 = *s;
    }

  *p = (char)0;
}

// kore_strlcpy
// file includes/kore.h line 478
void kore_strlcpy(char *dst, const char *src, unsigned long int len)
{
  char *d = dst;
  const char *s = src;
  const char *end = (dst + (signed long int)len) - (signed long int)1;
  do
  {
    *d = *s;
    if((signed int)*d == 0)
      break;

    if(d == end)
    {
      *d = (char)0;
      break;
    }

    d = d + 1l;
    s = s + 1l;
  }
  while((_Bool)1);
}

// kore_strtonum
// file includes/kore.h line 483
signed long long int kore_strtonum(const char *str, signed int base, signed long long int min, signed long long int max, signed int *err)
{
  signed long long int l;
  char *ep;
  _Bool tmp_if_expr_3;
  if(!(max >= min))
  {
    *err = 0;
    return (signed long long int)0;
  }

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    l=strtoll(str, &ep, base);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(str == ep || !(*return_value___errno_location_2 == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*ep != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      *err = 0;
      return (signed long long int)0;
    }

    else
      if(!(l >= min))
      {
        *err = 0;
        return (signed long long int)0;
      }

      else
        if(!(max >= l))
        {
          *err = 0;
          return (signed long long int)0;
        }

        else
        {
          *err = 1;
          return l;
        }
  }
}

// kore_strtonum64
// file includes/kore.h line 477
unsigned long int kore_strtonum64(const char *str, signed int sign, signed int *err)
{
  unsigned long int l;
  signed long long int ll;
  char *ep;
  signed int check;
  l = (unsigned long int)0;
  check = 1;
  ll=strtoll(str, &ep, 10);
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(*return_value___errno_location_1 == 22)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value___errno_location_2=__errno_location();
    tmp_if_expr_3 = *return_value___errno_location_2 == 34 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    if(ll == 0x7fffffffffffffffLL || ll == -9223372036854775808ll)
    {
      if(!(sign == 0))
      {
        *err = 0;
        return (unsigned long int)0;
      }

      check = 0;
    }

  }

  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  if(sign == 0)
  {
    l=strtoull(str, &ep, 10);
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 22)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value___errno_location_5=__errno_location();
      tmp_if_expr_6 = *return_value___errno_location_5 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      if(l == 1UL)
      {
        *err = 0;
        return (unsigned long int)0;
      }

    }

    if(!(check == 0) && !(ll >= 0l))
    {
      *err = 0;
      return (unsigned long int)0;
    }

  }

  _Bool tmp_if_expr_7;
  if(str == ep)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = (signed int)*ep != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_7)
  {
    *err = 0;
    return (unsigned long int)0;
  }

  else
  {
    *err = 1;
    return sign != 0 ? (unsigned long int)ll : l;
  }
}

// kore_task_bind_request
// file src/tasks.c line 97
void kore_task_bind_request(struct kore_task *t, struct http_request *req)
{
  t->req = req;
  do
  {
    t->rlist.le_next = (&req->tasks)->lh_first;
    if(!(t->rlist.le_next == ((struct kore_task *)NULL)))
      (&req->tasks)->lh_first->rlist.le_prev = &t->rlist.le_next;

    (&req->tasks)->lh_first = t;
    t->rlist.le_prev = &(&req->tasks)->lh_first;
  }
  while((_Bool)0);
  http_request_sleep(req);
}

// kore_task_channel_read
// file src/tasks.c line 166
unsigned int kore_task_channel_read(struct kore_task *t, void *out, unsigned int len)
{
  signed int fd;
  unsigned int dlen;
  unsigned int bytes;
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    if(return_value_pthread_self_1 == t->thread->tid)
      fd = t->fds[(signed long int)1];

    else
      fd = t->fds[(signed long int)0];
  }
  while((_Bool)0);
  task_channel_read(fd, (void *)&dlen, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  if(!(len >= dlen))
    bytes = len;

  else
    bytes = dlen;
  task_channel_read(fd, out, bytes);
  return dlen;
}

// kore_task_channel_write
// file src/tasks.c line 155
void kore_task_channel_write(struct kore_task *t, void *data, unsigned int len)
{
  signed int fd;
  do
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    if(return_value_pthread_self_1 == t->thread->tid)
      fd = t->fds[(signed long int)1];

    else
      fd = t->fds[(signed long int)0];
  }
  while((_Bool)0);
  task_channel_write(fd, (void *)&len, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  task_channel_write(fd, data, len);
}

// kore_task_create
// file src/tasks.c line 61
void kore_task_create(struct kore_task *t, signed int (*entry)(struct kore_task *))
{
  t->req = (struct http_request *)(void *)0;
  t->entry = entry;
  t->type = (unsigned char)4;
  t->state = 1;
  pthread_rwlock_init(&t->lock, (const union anonymous_7 *)(void *)0);
  signed int return_value_socketpair_3;
  return_value_socketpair_3=socketpair(1, 1, 0, t->fds);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(return_value_socketpair_3 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("kore_task_create: socketpair() %s", return_value_strerror_2);
  }

}

// kore_task_destroy
// file includes/tasks.h line 62
void kore_task_destroy(struct kore_task *t)
{
  if(!(t->req == ((struct http_request *)NULL)))
  {
    t->req = (struct http_request *)(void *)0;
    do
    {
      if(!(t->rlist.le_next == ((struct kore_task *)NULL)))
        t->rlist.le_next->rlist.le_prev = t->rlist.le_prev;

      *t->rlist.le_prev = t->rlist.le_next;
    }
    while((_Bool)0);
  }

  pthread_rwlock_wrlock(&t->lock);
  if(!(t->fds[0l] == -1))
  {
    close(t->fds[(signed long int)0]);
    t->fds[(signed long int)0] = -1;
  }

  if(!(t->fds[1l] == -1))
  {
    close(t->fds[(signed long int)1]);
    t->fds[(signed long int)1] = -1;
  }

  pthread_rwlock_unlock(&t->lock);
  pthread_rwlock_destroy(&t->lock);
}

// kore_task_finish
// file src/tasks.c line 140
void kore_task_finish(struct kore_task *t)
{
  pthread_rwlock_wrlock(&t->lock);
  if(!(t->fds[1l] == -1))
  {
    close(t->fds[(signed long int)1]);
    t->fds[(signed long int)1] = -1;
  }

  pthread_rwlock_unlock(&t->lock);
}

// kore_task_finished
// file includes/tasks.h line 63
signed int kore_task_finished(struct kore_task *t)
{
  signed int return_value_kore_task_state_1;
  return_value_kore_task_state_1=kore_task_state(t);
  return (signed int)(return_value_kore_task_state_1 == 3);
}

// kore_task_handle
// file src/tasks.c line 187
void kore_task_handle(struct kore_task *t, signed int finished)
{
  if(!(t->req == ((struct http_request *)NULL)))
    http_request_wakeup(t->req);

  if(!(finished == 0))
  {
    kore_platform_disable_read(t->fds[(signed long int)0]);
    kore_task_set_state(t, 3);
    if(!(t->req == ((struct http_request *)NULL)))
    {
      if(!((0x02 & (signed int)t->req->flags) == 0))
        kore_task_destroy(t);

    }

  }

}

// kore_task_init
// file includes/tasks.h line 59
void kore_task_init(void)
{
  signed int r;
  threads = (unsigned char)0;
  do
  {
    (&task_threads)->tqh_first = (struct kore_task_thread *)(void *)0;
    (&task_threads)->tqh_last = &(&task_threads)->tqh_first;
  }
  while((_Bool)0);
  r=pthread_mutex_init(&task_thread_lock, (const union anonymous_9 *)(void *)0);
  if(!(r == 0))
    fatal("kore_task_init: pthread_mutex_init: %d", r);

}

// kore_task_result
// file src/tasks.c line 225
signed int kore_task_result(struct kore_task *t)
{
  signed int r;
  pthread_rwlock_rdlock(&t->lock);
  r = t->result;
  pthread_rwlock_unlock(&t->lock);
  return r;
}

// kore_task_run
// file src/tasks.c line 74
void kore_task_run(struct kore_task *t)
{
  struct kore_task_thread *tt;
  kore_platform_schedule_read(t->fds[(signed long int)0], (void *)t);
  pthread_mutex_lock(&task_thread_lock);
  if(task_threads.tqh_first == ((struct kore_task_thread *)NULL))
    task_thread_spawn(&tt);

  else
    tt = (&task_threads)->tqh_first;
  pthread_mutex_unlock(&task_thread_lock);
  pthread_mutex_lock(&tt->lock);
  t->thread = tt;
  do
  {
    t->list.tqe_next = (struct kore_task *)(void *)0;
    t->list.tqe_prev = (&tt->tasks)->tqh_last;
    *(&tt->tasks)->tqh_last = t;
    (&tt->tasks)->tqh_last = &t->list.tqe_next;
  }
  while((_Bool)0);
  pthread_mutex_unlock(&tt->lock);
  pthread_cond_signal(&tt->cond);
}

// kore_task_set_result
// file src/tasks.c line 237
void kore_task_set_result(struct kore_task *t, signed int result)
{
  pthread_rwlock_wrlock(&t->lock);
  t->result = result;
  pthread_rwlock_unlock(&t->lock);
}

// kore_task_set_state
// file src/tasks.c line 217
void kore_task_set_state(struct kore_task *t, signed int state)
{
  pthread_rwlock_wrlock(&t->lock);
  t->state = state;
  pthread_rwlock_unlock(&t->lock);
}

// kore_task_state
// file src/tasks.c line 205
signed int kore_task_state(struct kore_task *t)
{
  signed int s;
  pthread_rwlock_rdlock(&t->lock);
  s = t->state;
  pthread_rwlock_unlock(&t->lock);
  return s;
}

// kore_time_ms
// file includes/kore.h line 454
unsigned long int kore_time_ms(void)
{
  struct timeval tv;
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(return_value_gettimeofday_1 == -1)
    return (unsigned long int)0;

  else
    return (unsigned long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// kore_time_to_date
// file includes/kore.h line 474
char * kore_time_to_date(signed long int now)
{
  struct tm *tm;
  static char tbuf[32l];
  static signed long int last = (signed long int)0;
  if(!(now == last))
  {
    last = now;
    tm=gmtime(&now);
    unsigned long int return_value_strftime_1;
    return_value_strftime_1=strftime(tbuf, sizeof(char [32l]) /*32ul*/ , "%a, %d %b %Y %T GMT", tm);
    if(return_value_strftime_1 == 0ul)
      return (char *)(void *)0;

  }

  return tbuf;
}

// kore_timer_add
// file src/timer.c line 31
struct kore_timer * kore_timer_add(void (*cb)(void *, unsigned long int, unsigned long int), unsigned long int interval, void *arg, signed int flags)
{
  struct kore_timer *timer;
  struct kore_timer *t;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_timer) /*56ul*/ );
  timer = (struct kore_timer *)return_value_kore_malloc_1;
  timer->cb = cb;
  timer->arg = arg;
  timer->flags = flags;
  timer->interval = interval;
  unsigned long int return_value_kore_time_ms_2;
  return_value_kore_time_ms_2=kore_time_ms();
  timer->nextrun = return_value_kore_time_ms_2 + timer->interval;
  t = (&kore_timers)->tqh_first;
  for( ; !(t == ((struct kore_timer *)NULL)); t = t->list.tqe_next)
    if(!(timer->nextrun >= t->nextrun))
    {
      do
      {
        timer->list.tqe_prev = t->list.tqe_prev;
        timer->list.tqe_next = t;
        *t->list.tqe_prev = timer;
        t->list.tqe_prev = &timer->list.tqe_next;
      }
      while((_Bool)0);
      return timer;
    }

  do
  {
    timer->list.tqe_next = (struct kore_timer *)(void *)0;
    timer->list.tqe_prev = (&kore_timers)->tqh_last;
    *(&kore_timers)->tqh_last = timer;
    (&kore_timers)->tqh_last = &timer->list.tqe_next;
  }
  while((_Bool)0);
  return timer;
}

// kore_timer_init
// file src/timer.c line 25
void kore_timer_init(void)
{
  do
  {
    (&kore_timers)->tqh_first = (struct kore_timer *)(void *)0;
    (&kore_timers)->tqh_last = &(&kore_timers)->tqh_first;
  }
  while((_Bool)0);
}

// kore_timer_remove
// file src/timer.c line 56
void kore_timer_remove(struct kore_timer *timer)
{
  do
  {
    if(!(timer->list.tqe_next == ((struct kore_timer *)NULL)))
      timer->list.tqe_next->list.tqe_prev = timer->list.tqe_prev;

    else
      (&kore_timers)->tqh_last = timer->list.tqe_prev;
    *timer->list.tqe_prev = timer->list.tqe_next;
  }
  while((_Bool)0);
  kore_mem_free((void *)timer);
}

// kore_timer_run
// file src/timer.c line 63
unsigned long int kore_timer_run(unsigned long int now)
{
  struct kore_timer *timer;
  struct kore_timer *t;
  unsigned long int next_timer;
  unsigned long int delta;
  next_timer = (unsigned long int)100;
  timer = (&kore_timers)->tqh_first;
  if(!(timer == ((struct kore_timer *)NULL)))
  {
    if(!(now >= timer->nextrun))
      next_timer = timer->nextrun - now;

    else
    {
      do
      {
        if(!(timer->list.tqe_next == ((struct kore_timer *)NULL)))
          timer->list.tqe_next->list.tqe_prev = timer->list.tqe_prev;

        else
          (&kore_timers)->tqh_last = timer->list.tqe_prev;
        *timer->list.tqe_prev = timer->list.tqe_next;
      }
      while((_Bool)0);
      delta = now - timer->nextrun;
      timer->cb(timer->arg, now, delta);
      if(!((0x01 & timer->flags) == 0))
        kore_mem_free((void *)timer);

      else
      {
        timer->nextrun = timer->nextrun + (timer->interval - delta);
        t = (&kore_timers)->tqh_first;
        if(!(t == ((struct kore_timer *)NULL)))
        {
          if(!(timer->nextrun >= t->nextrun))
          {
            timer->list.tqe_prev = t->list.tqe_prev;
            timer->list.tqe_next = t;
            *t->list.tqe_prev = timer;
            t->list.tqe_prev = &timer->list.tqe_next;
          }

          else
            t = t->list.tqe_next;
        }

        if(t == ((struct kore_timer *)NULL))
        {
          timer->list.tqe_next = (struct kore_timer *)(void *)0;
          timer->list.tqe_prev = (&kore_timers)->tqh_last;
          *(&kore_timers)->tqh_last = timer;
          (&kore_timers)->tqh_last = &timer->list.tqe_next;
        }

      }
    }
  }

  if(next_timer >= 2ul)
    next_timer = next_timer - (unsigned long int)1;

  return next_timer;
}

// kore_tls_info_callback
// file src/kore.c line 215
void kore_tls_info_callback(const struct ssl_st *ssl, signed int flags, signed int ret)
{
  struct connection *c;
  if(!((0x10 & flags) == 0))
  {
    void *return_value_SSL_get_ex_data_1;
    return_value_SSL_get_ex_data_1=SSL_get_ex_data(ssl, 0);
    c = (struct connection *)return_value_SSL_get_ex_data_1;
    if(c == ((struct connection *)NULL))
      fatal("no SSL_get_app_data");

    c->tls_reneg = c->tls_reneg + 1;
  }

}

// kore_tls_npn_cb
// file src/kore.c line 178
signed int kore_tls_npn_cb(struct ssl_st *ssl, const unsigned char **data, unsigned int *len, void *arg)
{
  *data = (const unsigned char *)"\bspdy/3.1\bhttp/1.1";
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen("\bspdy/3.1\bhttp/1.1");
  *len = (unsigned int)return_value_strlen_1;
  return 0;
}

// kore_tls_sni_cb
// file src/kore.c line 189
signed int kore_tls_sni_cb(struct ssl_st *ssl, signed int *ad, void *arg)
{
  struct kore_domain *dom;
  const char *sname;
  sname=SSL_get_servername(ssl, 0);
  if(!(sname == ((const char *)NULL)))
  {
    dom=kore_domain_lookup(sname);
    if(dom == ((struct kore_domain *)NULL))
      goto __CPROVER_DUMP_L3;

    SSL_set_SSL_CTX(ssl, dom->ssl_ctx);
    if(!(dom->cafile == ((char *)NULL)))
      SSL_set_verify(ssl, 0x01 | 0x02, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);

    else
      SSL_set_verify(ssl, 0x00, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return 3;
  }
}

// kore_validator_add
// file includes/kore.h line 515
signed int kore_validator_add(const char *name, unsigned char type, const char *arg)
{
  struct kore_validator *val;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_validator) /*112ul*/ );
  val = (struct kore_validator *)return_value_kore_malloc_1;
  val->type = type;
  signed int return_value_regcomp_2;
  void *return_value_kore_module_getsym_3;
  switch((signed int)val->type)
  {
    case 1:
    {
      return_value_regcomp_2=regcomp(&val->rctx, arg, 1 | ((1 << 1) << 1) << 1);
      if(!(return_value_regcomp_2 == 0))
      {
        kore_mem_free((void *)val);
        kore_log(5, "validator %s has bad regex %s", name, arg);
        return 0;
      }

      break;
    }
    case 2:
    {
      return_value_kore_module_getsym_3=kore_module_getsym(arg);
      val->func = (signed int (*)(struct http_request *, char *))return_value_kore_module_getsym_3;
      if(val->func == ((signed int (*)(struct http_request *, char *))NULL))
      {
        kore_mem_free((void *)val);
        kore_log(5, "validator %s has undefined callback %s", name, arg);
        return 0;
      }

      break;
    }
    default:
    {
      kore_mem_free((void *)val);
      return 0;
    }
  }
  val->arg=kore_strdup(arg);
  val->name=kore_strdup(name);
  do
  {
    val->list.tqe_next = (struct kore_validator *)(void *)0;
    val->list.tqe_prev = (&validators)->tqh_last;
    *(&validators)->tqh_last = val;
    (&validators)->tqh_last = &val->list.tqe_next;
  }
  while((_Bool)0);
  return 1;
}

// kore_validator_check
// file includes/kore.h line 517
signed int kore_validator_check(struct http_request *req, struct kore_validator *val, void *data)
{
  signed int r;
  signed int return_value_regexec_1;
  switch((signed int)val->type)
  {
    case 1:
    {
      return_value_regexec_1=regexec(&val->rctx, (const char *)data, (unsigned long int)0, (struct anonymous_57 *)(void *)0, 0);
      if(return_value_regexec_1 == 0)
        r = 1;

      else
        r = 0;
      break;
    }
    case 2:
      r=val->func(req, (char *)data);
    default:
    {
      r = 0;
      kore_log(5, "invalid type %d for validator %s", val->type, val->name);
    }
  }
  return r;
}

// kore_validator_init
// file includes/kore.h line 513
void kore_validator_init(void)
{
  do
  {
    (&validators)->tqh_first = (struct kore_validator *)(void *)0;
    (&validators)->tqh_last = &(&validators)->tqh_first;
  }
  while((_Bool)0);
}

// kore_validator_lookup
// file includes/kore.h line 519
struct kore_validator * kore_validator_lookup(const char *name)
{
  struct kore_validator *val = (&validators)->tqh_first;
  for( ; !(val == ((struct kore_validator *)NULL)); val = val->list.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(val->name, name);
    if(return_value_strcmp_1 == 0)
      return val;

  }
  return (struct kore_validator *)(void *)0;
}

// kore_validator_reload
// file includes/kore.h line 514
void kore_validator_reload(void)
{
  struct kore_validator *val = (&validators)->tqh_first;
  for( ; !(val == ((struct kore_validator *)NULL)); val = val->list.tqe_next)
    if((signed int)val->type == 2)
    {
      void *return_value_kore_module_getsym_1;
      return_value_kore_module_getsym_1=kore_module_getsym(val->arg);
      val->func = (signed int (*)(struct http_request *, char *))return_value_kore_module_getsym_1;
      if(val->func == ((signed int (*)(struct http_request *, char *))NULL))
        fatal("no function for validator %s found", val->name);

    }

}

// kore_validator_run
// file src/validator.c line 66
signed int kore_validator_run(struct http_request *req, const char *name, char *data)
{
  struct kore_validator *val = (&validators)->tqh_first;
  for( ; !(val == ((struct kore_validator *)NULL)); val = val->list.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(val->name, name);
    if(return_value_strcmp_1 == 0)
    {
      signed int return_value_kore_validator_check_2;
      return_value_kore_validator_check_2=kore_validator_check(req, val, (void *)data);
      return return_value_kore_validator_check_2;
    }

  }
  return 0;
}

// kore_websocket_broadcast
// file src/websocket.c line 170
void kore_websocket_broadcast(struct connection *c, unsigned char op, void *data, unsigned long int len, signed int scope)
{
  struct websocket_data arg;
  arg.op = op;
  arg.len = len;
  arg.data = data;
  kore_worker_websocket_broadcast(c, websocket_send_single, (void *)&arg);
  if(scope == 2)
    fatal("kore_websocket_broadcast: no global scope yet");

}

// kore_websocket_handshake
// file src/websocket.c line 54
void kore_websocket_handshake(struct http_request *req, struct kore_wscbs *wscbs)
{
  struct SHAstate_st sctx;
  struct kore_buf *buf;
  char *key;
  char *base64;
  char *kore_websocket_handshake__1__version;
  unsigned char digest[20l];
  signed int return_value_http_request_header_1;
  return_value_http_request_header_1=http_request_header(req, "sec-websocket-key", &key);
  if(return_value_http_request_header_1 == 0)
    http_response(req, 400, (void *)0, (unsigned int)0);

  else
  {
    signed int return_value_http_request_header_2;
    return_value_http_request_header_2=http_request_header(req, "sec-websocket-version", &kore_websocket_handshake__1__version);
    if(return_value_http_request_header_2 == 0)
    {
      kore_mem_free((void *)key);
      http_response_header(req, "sec-websocket-version", "13");
      http_response(req, 400, (void *)0, (unsigned int)0);
    }

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(kore_websocket_handshake__1__version, "13");
      if(!(return_value_strcmp_3 == 0))
      {
        kore_mem_free((void *)key);
        kore_mem_free((void *)kore_websocket_handshake__1__version);
        http_response_header(req, "sec-websocket-version", "13");
        http_response(req, 400, (void *)0, (unsigned int)0);
      }

      else
      {
        kore_mem_free((void *)kore_websocket_handshake__1__version);
        buf=kore_buf_create((unsigned int)128);
        kore_buf_appendf(buf, "%s%s", key, (const void *)"258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
        kore_mem_free((void *)key);
        SHA1_Init(&sctx);
        SHA1_Update(&sctx, (const void *)buf->data, buf->offset);
        SHA1_Final(digest, &sctx);
        kore_buf_free(buf);
        signed int return_value_kore_base64_encode_4;
        return_value_kore_base64_encode_4=kore_base64_encode(digest, (unsigned int)sizeof(unsigned char [20l]) /*20ul*/ , &base64);
        if(return_value_kore_base64_encode_4 == 0)
          http_response(req, 500, (void *)0, (unsigned int)0);

        else
        {
          http_response_header(req, "upgrade", "websocket");
          http_response_header(req, "connection", "upgrade");
          http_response_header(req, "sec-websocket-accept", base64);
          kore_mem_free((void *)base64);
          http_response(req, 101, (void *)0, (unsigned int)0);
          net_recv_reset(req->owner, (unsigned int)2, websocket_recv_opcode);
          req->owner->disconnect = websocket_disconnect;
          req->owner->rnb->flags = req->owner->rnb->flags & (unsigned char)~0x01;
          req->owner->proto = (unsigned char)3;
          req->owner->wscbs = (void *)wscbs;
          req->owner->idle_timer.start=kore_time_ms();
          req->owner->idle_timer.length = kore_websocket_timeout;
          if(!(wscbs->connect == ((void (*)(struct connection *))NULL)))
            wscbs->connect(req->owner);

        }
      }
    }
  }
}

// kore_websocket_send
// file src/websocket.c line 122
void kore_websocket_send(struct connection *c, unsigned char op, void *data, unsigned long int len)
{
  unsigned char len_1;
  unsigned short int len16;
  unsigned long int len64;
  struct kore_buf *frame;
  if(!((signed int)c->proto == 3))
    fatal("kore_websocket_send(): to non websocket connection");

  if(len >= 126ul)
  {
    if(!(len >= 65535ul))
      len_1 = (unsigned char)126;

    else
      len_1 = (unsigned char)127;
  }

  else
    len_1 = (unsigned char)len;
  frame=kore_buf_create((unsigned int)len);
  op = op | (unsigned char)(1 << 7);
  kore_buf_append(frame, (void *)&op, (unsigned int)sizeof(unsigned char) /*1ul*/ );
  len_1 = len_1 & (unsigned char)~(1 << 7);
  kore_buf_append(frame, (void *)&len_1, (unsigned int)sizeof(unsigned char) /*1ul*/ );
  if(!((unsigned long int)len_1 == len))
    switch((signed int)len_1)
    {
      case 126:
      {
        net_write16((unsigned char *)&len16, (unsigned short int)len);
        kore_buf_append(frame, (void *)&len16, (unsigned int)sizeof(unsigned short int) /*2ul*/ );
        break;
      }
      case 127:
      {
        net_write64((unsigned char *)&len64, len);
        kore_buf_append(frame, (void *)&len64, (unsigned int)sizeof(unsigned long int) /*8ul*/ );
      }
    }

  kore_buf_append(frame, data, (unsigned int)len);
  net_send_queue(c, (void *)frame->data, (unsigned int)frame->offset, (struct spdy_stream *)(void *)0, 0);
  kore_buf_free(frame);
}

// kore_worker_acceptlock_obtain
// file src/worker.c line 475
static inline signed int kore_worker_acceptlock_obtain(void)
{
  signed int r;
  if((signed int)worker->has_lock == 1)
    return 1;

  else
    if((signed int)worker_count == 1)
    {
      worker->has_lock = (unsigned char)1;
      return 1;
    }

    else
      if(worker_active_connections >= worker_max_connections)
        return 0;

      else
      {
        r = 0;
        signed int return_value_worker_trylock_1;
        return_value_worker_trylock_1=worker_trylock();
        if(!(return_value_worker_trylock_1 == 0))
        {
          r = 1;
          worker->has_lock = (unsigned char)1;
        }

        return r;
      }
}

// kore_worker_acceptlock_release
// file src/worker.c line 462
static inline void kore_worker_acceptlock_release(void)
{
  if(!((signed int)worker_count == 1))
  {
    if((signed int)worker->has_lock == 1)
    {
      worker_unlock();
      worker->has_lock = (unsigned char)0;
    }

  }

}

// kore_worker_connection_add
// file includes/kore.h line 403
void kore_worker_connection_add(struct connection *c)
{
  do
  {
    c->list.tqe_next = (struct connection *)(void *)0;
    c->list.tqe_prev = (&worker_clients)->tqh_last;
    *(&worker_clients)->tqh_last = c;
    (&worker_clients)->tqh_last = &c->list.tqe_next;
  }
  while((_Bool)0);
  worker_active_connections = worker_active_connections + 1u;
}

// kore_worker_connection_move
// file includes/kore.h line 404
void kore_worker_connection_move(struct connection *c)
{
  do
  {
    if(!(c->list.tqe_next == ((struct connection *)NULL)))
      c->list.tqe_next->list.tqe_prev = c->list.tqe_prev;

    else
      (&worker_clients)->tqh_last = c->list.tqe_prev;
    *c->list.tqe_prev = c->list.tqe_next;
  }
  while((_Bool)0);
  do
  {
    c->list.tqe_next = (struct connection *)(void *)0;
    c->list.tqe_prev = (&disconnected)->tqh_last;
    *(&disconnected)->tqh_last = c;
    (&disconnected)->tqh_last = &c->list.tqe_next;
  }
  while((_Bool)0);
}

// kore_worker_connection_remove
// file includes/kore.h line 405
void kore_worker_connection_remove(struct connection *c)
{
  worker_active_connections = worker_active_connections - 1u;
}

// kore_worker_dispatch_signal
// file includes/kore.h line 400
void kore_worker_dispatch_signal(signed int sig)
{
  unsigned short int id;
  struct kore_worker *kw;
  id = (unsigned short int)0;
  for( ; !((signed int)id >= (signed int)worker_count); id = id + 1)
  {
    kw = (struct kore_worker *)((unsigned char *)kore_workers + (signed long int)(sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)id));
    signed int return_value_kill_1;
    return_value_kill_1=kill(kw->pid, sig);
  }
}

// kore_worker_entry
// file src/worker.c line 181
void kore_worker_entry(struct kore_worker *kw)
{
  unsigned long int fd;
  struct rlimit rl;
  char buf[16l];
  struct connection *c;
  struct connection *cnext;
  signed int quit;
  signed int had_lock;
  signed int r;
  unsigned long int now;
  unsigned long int idle_check;
  unsigned long int next_lock;
  unsigned long int netwait;
  struct passwd *pw = (struct passwd *)(void *)0;
  worker = kw;
  if(skip_runas == 0)
  {
    pw=getpwnam(runas_user);
    if(pw == ((struct passwd *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fatal("cannot getpwnam(\"%s\") runas user: %s", runas_user, return_value_strerror_2);
    }

  }

  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  if(skip_chroot == 0)
  {
    signed int return_value_chroot_5;
    return_value_chroot_5=chroot(chroot_path);
    if(return_value_chroot_5 == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      fatal("cannot chroot(\"%s\"): %s", chroot_path, return_value_strerror_4);
    }

    signed int return_value_chdir_8;
    return_value_chdir_8=chdir("/");
    if(return_value_chdir_8 == -1)
    {
      return_value___errno_location_6=__errno_location();
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      fatal("cannot chdir(\"/\"): %s", return_value_strerror_7);
    }

  }

  signed int return_value_getrlimit_12;
  return_value_getrlimit_12=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rl);
  if(return_value_getrlimit_12 == -1)
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    char *return_value_strerror_10;
    return_value_strerror_10=strerror(*return_value___errno_location_9);
    kore_log(4, "getrlimit(RLIMIT_NOFILE): %s", return_value_strerror_10);
  }

  else
  {
    fd = (unsigned long int)0;
    for( ; !(fd >= rl.rlim_cur); fd = fd + 1ul)
    {
      signed int return_value_fcntl_11;
      return_value_fcntl_11=fcntl((signed int)fd, 1, (void *)0);
      if(!(return_value_fcntl_11 == -1))
        worker_rlimit_nofiles = worker_rlimit_nofiles + 1u;

    }
  }
  rl.rlim_cur = (unsigned long int)worker_rlimit_nofiles;
  rl.rlim_max = (unsigned long int)worker_rlimit_nofiles;
  signed int return_value_setrlimit_15;
  return_value_setrlimit_15=setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rl);
  if(return_value_setrlimit_15 == -1)
  {
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    char *return_value_strerror_14;
    return_value_strerror_14=strerror(*return_value___errno_location_13);
    kore_log(3, "setrlimit(RLIMIT_NOFILE, %d): %s", worker_rlimit_nofiles, return_value_strerror_14);
  }

  _Bool tmp_if_expr_18;
  signed int return_value_setresgid_17;
  _Bool tmp_if_expr_20;
  signed int return_value_setresuid_19;
  if(skip_runas == 0)
  {
    signed int return_value_setgroups_16;
    return_value_setgroups_16=setgroups((unsigned long int)1, &pw->pw_gid);
    if(!(return_value_setgroups_16 == 0))
      tmp_if_expr_18 = (_Bool)1;

    else
    {
      return_value_setresgid_17=setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid);
      tmp_if_expr_18 = return_value_setresgid_17 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_18)
      tmp_if_expr_20 = (_Bool)1;

    else
    {
      return_value_setresuid_19=setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
      tmp_if_expr_20 = return_value_setresuid_19 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_20)
      fatal("cannot drop privileges");

  }

  snprintf(buf, sizeof(char [16l]) /*16ul*/ , "kore [wrk %d]", kw->id);
  kore_platform_proctitle(buf);
  if((signed int)worker_set_affinity == 1)
    kore_platform_worker_setcpu(kw);

  kore_pid = kw->pid;
  sig_recv = 0;
  signal(1, kore_signal);
  signal(3, kore_signal);
  signal(13, (void (*)(signed int))1);
  if(!(foreground == 0))
    signal(2, kore_signal);

  else
    signal(2, (void (*)(signed int))1);
  net_init();
  http_init();
  kore_timer_init();
  kore_connection_init();
  kore_domain_load_crl();
  do
  {
    (&disconnected)->tqh_first = (struct connection *)(void *)0;
    (&disconnected)->tqh_last = &(&disconnected)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&worker_clients)->tqh_first = (struct connection *)(void *)0;
    (&worker_clients)->tqh_last = &(&worker_clients)->tqh_first;
  }
  while((_Bool)0);
  quit = 0;
  had_lock = 0;
  next_lock = (unsigned long int)0;
  idle_check = (unsigned long int)0;
  kore_platform_event_init();
  kore_accesslog_worker_init();
  kore_pgsql_init();
  kore_task_init();
  kore_log(5, "worker %d started (cpu#%d)", kw->id, kw->cpu);
  kore_module_onload();
  while((_Bool)1)
  {
    if(!(sig_recv == 0))
    {
      if(sig_recv == 1)
        kore_module_reload(1);

      else
        if(sig_recv == 2 || sig_recv == 3)
          quit = 1;

      sig_recv = 0;
    }

    now=kore_time_ms();
    netwait=kore_timer_run(now);
    if(!(next_lock >= now))
    {
      signed int return_value_kore_worker_acceptlock_obtain_21;
      return_value_kore_worker_acceptlock_obtain_21=kore_worker_acceptlock_obtain();
      if(!(return_value_kore_worker_acceptlock_obtain_21 == 0))
      {
        if(had_lock == 0)
        {
          kore_platform_enable_accept();
          had_lock = 1;
        }

      }

    }

    if(worker->has_lock == 0)
    {
      if(had_lock == 1)
      {
        had_lock = 0;
        kore_platform_disable_accept();
      }

    }

    r=kore_platform_event_wait(netwait);
    if(!(worker->has_lock == 0))
    {
      if(r >= 1)
      {
        kore_worker_acceptlock_release();
        next_lock = now + (unsigned long int)500;
      }

    }

    http_process();
    if(now + -idle_check >= 10000ul)
    {
      idle_check = now;
      now=kore_time_ms();
      c = (&worker_clients)->tqh_first;
      for( ; !(c == ((struct connection *)NULL)); c = c->list.tqe_next)
      {
        if((signed int)c->proto == 1)
        {
          if(c->idle_timer.length == 0ul)
          {
            if((0x04 & (signed int)c->flags) == 0)
            {
              if((0x20 & (signed int)c->flags) == 0)
                goto __CPROVER_DUMP_L31;

            }

          }

        }

        if(!((0x10 & (signed int)c->flags) == 0))
          kore_connection_check_idletimer(now, c);


      __CPROVER_DUMP_L31:
        ;
      }
    }

    c = (&disconnected)->tqh_first;
    for( ; !(c == ((struct connection *)NULL)); c = cnext)
    {
      cnext = c->list.tqe_next;
      do
      {
        if(!(c->list.tqe_next == ((struct connection *)NULL)))
          c->list.tqe_next->list.tqe_prev = c->list.tqe_prev;

        else
          (&disconnected)->tqh_last = c->list.tqe_prev;
        *c->list.tqe_prev = c->list.tqe_next;
      }
      while((_Bool)0);
      kore_connection_remove(c);
    }
    if(http_request_count == 0 && !(quit == 0))
      break;

  }
  c = (&worker_clients)->tqh_first;
  for( ; !(c == ((struct connection *)NULL)); c = cnext)
  {
    cnext = c->list.tqe_next;
    net_send_flush(c);
    kore_connection_disconnect(c);
  }
  c = (&disconnected)->tqh_first;
  for( ; !(c == ((struct connection *)NULL)); c = cnext)
  {
    cnext = c->list.tqe_next;
    net_send_flush(c);
    do
    {
      if(!(c->list.tqe_next == ((struct connection *)NULL)))
        c->list.tqe_next->list.tqe_prev = c->list.tqe_prev;

      else
        (&disconnected)->tqh_last = c->list.tqe_prev;
      *c->list.tqe_prev = c->list.tqe_next;
    }
    while((_Bool)0);
    kore_connection_remove(c);
  }
  exit(0);
}

// kore_worker_init
// file includes/kore.h line 398
void kore_worker_init(void)
{
  unsigned long int len;
  unsigned short int i;
  unsigned short int cpu;
  if((signed int)worker_count == 0)
    worker_count = (unsigned char)1;

  len = sizeof(struct wlock) /*8ul*/  + sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)worker_count;
  shm_accept_key=shmget((signed int)0, len, 01000 | 02000 | 0700);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(shm_accept_key == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("kore_worker_init(): shmget() %s", return_value_strerror_2);
  }

  void *return_value_shmat_5;
  return_value_shmat_5=shmat(shm_accept_key, (void *)0, 0);
  accept_lock = (struct wlock *)return_value_shmat_5;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(accept_lock == (struct wlock *)-1)
  {
    return_value___errno_location_3=__errno_location();
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fatal("kore_worker_init(): shmat() %s", return_value_strerror_4);
  }

  accept_lock->lock = 0;
  accept_lock->current = 0;
  kore_workers = (struct kore_worker *)((unsigned char *)accept_lock + (signed long int)sizeof(struct wlock) /*8ul*/ );
  memset((void *)kore_workers, 0, sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)worker_count);
  cpu = (unsigned short int)0;
  i = (unsigned short int)0;
  unsigned short int tmp_post_6;
  for( ; !((signed int)i >= (signed int)worker_count); i = i + 1)
  {
    tmp_post_6 = cpu;
    cpu = cpu + 1;
    kore_worker_spawn(i, tmp_post_6);
    if(cpu == cpu_count)
      cpu = (unsigned short int)0;

  }
}

// kore_worker_shutdown
// file includes/kore.h line 399
void kore_worker_shutdown(void)
{
  struct kore_worker *kw;
  unsigned short int id;
  unsigned short int done;
  kore_log(5, "waiting for workers to drain and shutdown");
  do
  {
    done = (unsigned short int)0;
    id = (unsigned short int)0;
    for( ; !((signed int)id >= (signed int)worker_count); id = id + 1)
    {
      kw = (struct kore_worker *)((unsigned char *)kore_workers + (signed long int)(sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)id));
      if(!(kw->pid == 0))
        kore_worker_wait(1);

      else
        done = done + 1;
    }
    if((signed int)done == (signed int)worker_count)
      break;

  }
  while((_Bool)1);
  signed int return_value_shmctl_3;
  return_value_shmctl_3=shmctl(shm_accept_key, 0, (struct shmid_ds *)(void *)0);
  if(return_value_shmctl_3 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    kore_log(5, "failed to deleted shm segment: %s", return_value_strerror_2);
  }

}

// kore_worker_spawn
// file src/worker.c line 118
void kore_worker_spawn(unsigned short int id, unsigned short int cpu)
{
  struct kore_worker *kw = (struct kore_worker *)((unsigned char *)kore_workers + (signed long int)(sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)id));
  kw->id = (unsigned char)id;
  kw->cpu = (unsigned char)cpu;
  kw->has_lock = (unsigned char)0;
  kw->active_hdlr = (struct kore_module_handle *)(void *)0;
  kw->pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(kw->pid == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fatal("could not spawn worker child: %s", return_value_strerror_2);
  }

  if(kw->pid == 0)
  {
    kw->pid=getpid();
    kore_worker_entry(kw);
  }

}

// kore_worker_wait
// file includes/kore.h line 397
void kore_worker_wait(signed int final)
{
  unsigned short int id;
  signed int pid;
  struct kore_worker *kw;
  signed int status;
  if(!(final == 0))
    pid=waitpid(-1, &status, 0);

  else
    pid=waitpid(-1, &status, 1);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_if_expr_1;
  if(!(pid == -1))
  {
    if(!(pid == 0))
    {
      id = (unsigned short int)0;
      for( ; !((signed int)id >= (signed int)worker_count); id = id + 1)
      {
        kw = (struct kore_worker *)((unsigned char *)kore_workers + (signed long int)(sizeof(struct kore_worker) /*24ul*/  * (unsigned long int)id));
        if(kw->pid == pid)
        {
          kore_log(5, "worker %d (%d)-> status %d", kw->id, pid, status);
          if(!(final == 0))
          {
            kw->pid = 0;
            break;
          }

          /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_67
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
          ;
          if(!((0xff00 & status) >> 8 == 0))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = (((union anonymous_67){ .__in=status }).__i & 0x7f) != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (((union anonymous_67){ .__in=status }).__i & 0x80) != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
          {
            if(!(kw->active_hdlr == ((struct kore_module_handle *)NULL)))
              tmp_if_expr_1 = kw->active_hdlr->func;

            else
              tmp_if_expr_1 = "none";
            kore_log(5, "worker %d (pid: %d) (hdlr: %s) gone", kw->id, kw->pid, tmp_if_expr_1);
            if(kw->pid == accept_lock->current)
              worker_unlock();

            if(!(kw->active_hdlr == ((struct kore_module_handle *)NULL)))
            {
              kw->active_hdlr->errors = kw->active_hdlr->errors + 1;
              kore_log(5, "hdlr %s has caused %d error(s)", kw->active_hdlr->func, kw->active_hdlr->errors);
            }

            kore_log(5, "restarting worker %d", kw->id);
            kore_worker_spawn((unsigned short int)kw->id, (unsigned short int)kw->cpu);
          }

          else
            kore_log(5, "worker %d (pid: %d) signaled us (%d)", kw->id, kw->pid, status);
          break;
        }

      }
    }

  }

}

// kore_worker_websocket_broadcast
// file includes/kore.h line 406
void kore_worker_websocket_broadcast(struct connection *src, void (*cb)(struct connection *, void *), void *args)
{
  struct connection *c = (&worker_clients)->tqh_first;
  for( ; !(c == ((struct connection *)NULL)); c = c->list.tqe_next)
    if(!(c == src))
    {
      if((signed int)c->proto == 3)
        cb(c, args);

    }

}

// kore_write_kore_pid
// file src/kore.c line 371
static void kore_write_kore_pid(void)
{
  struct _IO_FILE *fp;
  fp=fopen(kore_pidfile, "w+");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    printf("warning: couldn't write pid to %s (%s)\n", kore_pidfile, return_value_strerror_2);
  }

  else
  {
    fprintf(fp, "%d\n", kore_pid);
    fclose(fp);
  }
}

// main
// file src/kore.c line 83
signed int main(signed int argc, char **argv)
{
  struct listener *l;
  signed int ch;
  signed int flags = 0;
  do
  {
    ch=getopt(argc, argv, "c:dfhnrv");
    if(ch == -1)
      break;

    flags = flags + 1;
    switch(ch)
    {
      case 99:
      {
        config_file = optarg;
        break;
      }
      case 100:
      {
        printf("kore not compiled with debug support\n");
        break;
      }
      case 102:
      {
        foreground = 1;
        break;
      }
      case 104:
      {
        usage();
        break;
      }
      case 110:
      {
        skip_chroot = 1;
        break;
      }
      case 114:
      {
        skip_runas = 1;
        break;
      }
      case 118:
      {
        version();
        break;
      }
      default:
        usage();
    }
  }
  while((_Bool)1);
  argc = argc - optind;
  argv = argv + (signed long int)optind;
  kore_mem_init();
  if(argc >= 1)
  {
    if(!(flags == 0))
      fatal("You cannot specify kore flags and a command");

    signed int return_value_kore_cli_main_1;
    return_value_kore_cli_main_1=kore_cli_main(argc, argv);
    return return_value_kore_cli_main_1;
  }

  kore_pid=getpid();
  nlisteners = (unsigned char)0;
  do
    (&listeners)->lh_first = (struct listener *)(void *)0;
  while((_Bool)0);
  kore_log_init();
  kore_auth_init();
  kore_domain_init();
  kore_module_init();
  kore_validator_init();
  kore_server_sslstart();
  if(config_file == ((char *)NULL))
    usage();

  kore_parse_config();
  kore_platform_init();
  kore_accesslog_init();
  sig_recv = 0;
  signal(1, kore_signal);
  signal(3, kore_signal);
  if(!(foreground == 0))
    signal(2, kore_signal);

  else
    signal(2, (void (*)(signed int))1);
  kore_server_start();
  kore_log(5, "server shutting down");
  kore_worker_shutdown();
  if(foreground == 0)
    unlink(kore_pidfile);

  l = (&listeners)->lh_first;
  for( ; !(l == ((struct listener *)NULL)); l = l->list.le_next)
    close(l->fd);
  kore_log(5, "goodbye");
  return 0;
}

// net_init
// file src/net.c line 34
void net_init(void)
{
  kore_pool_init(&nb_pool, "nb_pool", (unsigned int)sizeof(struct netbuf) /*72ul*/ , (unsigned int)1000);
}

// net_read
// file src/net.c line 380
signed int net_read(struct connection *c, signed int *bytes)
{
  signed int r;
  signed long int return_value_read_1;
  return_value_read_1=read(c->fd, (void *)(c->rnb->buf + (signed long int)c->rnb->s_off), (unsigned long int)(c->rnb->b_len - c->rnb->s_off));
  r = (signed int)return_value_read_1;
  if(!(r >= 1))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 4 || *return_value___errno_location_2 == 11)
    {
      c->flags = c->flags & (unsigned char)~0x01;
      return 1;
    }

    return 0;
  }

  *bytes = r;
  return 1;
}

// net_read16
// file src/net.c line 403
unsigned short int net_read16(unsigned char *b)
{
  unsigned short int r = *((unsigned short int *)b);
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(r);
  return return_value_ntohs_1;
}

// net_read32
// file src/net.c line 412
unsigned int net_read32(unsigned char *b)
{
  unsigned int r = *((unsigned int *)b);
  unsigned int return_value_ntohl_1;
  return_value_ntohl_1=ntohl(r);
  return return_value_ntohl_1;
}

// net_read64
// file src/net.c line 439
unsigned long int net_read64(unsigned char *b)
{
  unsigned long int r = *((unsigned long int *)b);
  unsigned long int return_value___bswap_64_1;
  return_value___bswap_64_1=__bswap_64(r);
  return return_value___bswap_64_1;
}

// net_read_ssl
// file includes/kore.h line 536
signed int net_read_ssl(struct connection *c, signed int *bytes)
{
  signed int r;
  r=SSL_read(c->ssl, (void *)(c->rnb->buf + (signed long int)c->rnb->s_off), (signed int)(c->rnb->b_len - c->rnb->s_off));
  if(c->tls_reneg >= 2)
    return 0;

  else
    if(!(r >= 1))
    {
      r=SSL_get_error(c->ssl, r);
      if(r == 2 || r == 3)
      {
        c->flags = c->flags & (unsigned char)~0x01;
        return 1;
      }

      return 0;
    }

    else
    {
      *bytes = r;
      return 1;
    }
}

// net_recv_expand
// file src/net.c line 165
void net_recv_expand(struct connection *c, unsigned int len, signed int (*cb)(struct netbuf *))
{
  if(!((signed int)c->rnb->type == 0))
    fatal("net_recv_expand(): wrong netbuf type");

  c->rnb->cb = cb;
  c->rnb->b_len = c->rnb->b_len + len;
  c->rnb->m_len = c->rnb->b_len;
  void *return_value_kore_realloc_1;
  return_value_kore_realloc_1=kore_realloc((void *)c->rnb->buf, (unsigned long int)c->rnb->b_len);
  c->rnb->buf = (unsigned char *)return_value_kore_realloc_1;
}

// net_recv_flush
// file includes/kore.h line 534
signed int net_recv_flush(struct connection *c)
{
  signed int r;
  if(c->rnb == ((struct netbuf *)NULL))
    fatal("net_recv_flush(): c->rnb == NULL");

  _Bool tmp_if_expr_1;
  if(!((0x01 & (signed int)c->flags) == 0))
  {
    signed int return_value;
    return_value=c->read(c, &r);
    if(return_value == 0)
      return 0;

    if(!((0x01 & (signed int)c->flags) == 0))
    {
      c->rnb->s_off = c->rnb->s_off + (unsigned int)(unsigned long int)r;
      if(c->rnb->s_off == c->rnb->b_len)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = ((signed int)c->rnb->flags & 0x01) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        r=c->rnb->cb(c->rnb);
        if(!(r == 1))
          return r;

      }

    }

  }

  return 1;
}

// net_recv_queue
// file includes/kore.h line 542
void net_recv_queue(struct connection *c, unsigned int len, signed int flags, signed int (*cb)(struct netbuf *))
{
  if(!(c->rnb == ((struct netbuf *)NULL)))
    fatal("net_recv_queue(): called incorrectly for %p", c);

  void *return_value_kore_pool_get_1;
  return_value_kore_pool_get_1=kore_pool_get(&nb_pool);
  c->rnb = (struct netbuf *)return_value_kore_pool_get_1;
  c->rnb->cb = cb;
  c->rnb->owner = (void *)c;
  c->rnb->s_off = (unsigned int)0;
  c->rnb->b_len = len;
  c->rnb->m_len = len;
  c->rnb->extra = (void *)0;
  c->rnb->stream = (struct spdy_stream *)(void *)0;
  c->rnb->flags = (unsigned char)flags;
  c->rnb->type = (unsigned char)0;
  void *return_value_kore_malloc_2;
  return_value_kore_malloc_2=kore_malloc((unsigned long int)c->rnb->b_len);
  c->rnb->buf = (unsigned char *)return_value_kore_malloc_2;
}

// net_recv_reset
// file includes/kore.h line 539
void net_recv_reset(struct connection *c, unsigned int len, signed int (*cb)(struct netbuf *))
{
  if(!((signed int)c->rnb->type == 0))
    fatal("net_recv_reset(): wrong netbuf type");

  c->rnb->cb = cb;
  c->rnb->s_off = (unsigned int)0;
  c->rnb->b_len = len;
  if(c->rnb->m_len >= c->rnb->b_len)
  {
    if(!(c->rnb->m_len >= 4096u))
      goto __CPROVER_DUMP_L3;

  }

  kore_mem_free((void *)c->rnb->buf);
  c->rnb->m_len = len;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc((unsigned long int)c->rnb->m_len);
  c->rnb->buf = (unsigned char *)return_value_kore_malloc_1;

__CPROVER_DUMP_L3:
  ;
}

// net_remove_netbuf
// file src/net.c line 276
void net_remove_netbuf(struct netbuf_head *list, struct netbuf *nb)
{
  if((signed int)nb->type == 0)
    fatal("net_remove_netbuf(): cannot remove recv netbuf");

  nb->stream = (struct spdy_stream *)(void *)0;
  if(!((0x04 & (signed int)nb->flags) == 0))
    nb->flags = nb->flags | (unsigned char)0x02;

  else
  {
    if((0x10 & (signed int)nb->flags) == 0)
      kore_mem_free((void *)nb->buf);

    else
      if(!(nb->cb == ((signed int (*)(struct netbuf *))NULL)))
        nb->cb(nb);

    do
    {
      if(!(nb->list.tqe_next == ((struct netbuf *)NULL)))
        nb->list.tqe_next->list.tqe_prev = nb->list.tqe_prev;

      else
        list->tqh_last = nb->list.tqe_prev;
      *nb->list.tqe_prev = nb->list.tqe_next;
    }
    while((_Bool)0);
    kore_pool_put(&nb_pool, (void *)nb);
  }
}

// net_send
// file src/net.c line 179
signed int net_send(struct connection *c)
{
  signed int r;
  unsigned int len;
  unsigned int smin;
  c->snb = (&c->send_queue)->tqh_first;
  unsigned int tmp_if_expr_2;
  if(!(c->snb->b_len == 0u))
  {
    if(!(c->snb->stream == ((struct spdy_stream *)NULL)))
    {
      if(!((0x20 & (signed int)c->snb->stream->flags) == 0))
      {
        signed int return_value_spdy_dataframe_begin_1;
        return_value_spdy_dataframe_begin_1=spdy_dataframe_begin(c);
        if(return_value_spdy_dataframe_begin_1 == 0)
        {
          c->snb = (struct netbuf *)(void *)0;
          return 1;
        }

        c->snb = (&c->send_queue)->tqh_first;
      }

    }

    smin = c->snb->b_len - c->snb->s_off;
    if(!(c->snb->stream == ((struct spdy_stream *)NULL)))
    {
      if(c->snb->stream->frame_size >= 1u)
      {
        if(!(smin >= c->snb->stream->frame_size))
          tmp_if_expr_2 = smin;

        else
          tmp_if_expr_2 = c->snb->stream->frame_size;
        smin = tmp_if_expr_2;
      }

    }

    len = (unsigned int)8192 < smin ? (unsigned int)8192 : smin;
    signed int return_value;
    return_value=c->write(c, (signed int)len, &r);
    if(return_value == 0)
      return 0;

    if((0x02 & (signed int)c->flags) == 0)
      return 1;

    c->snb->s_off = c->snb->s_off + (unsigned int)(unsigned long int)r;
    c->snb->flags = c->snb->flags & (unsigned char)~0x04;
    if(!(c->snb->stream == ((struct spdy_stream *)NULL)))
      spdy_update_wsize(c, c->snb->stream, (unsigned int)r);

  }

  _Bool tmp_if_expr_3;
  if(c->snb->s_off == c->snb->b_len)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = ((signed int)c->snb->flags & 0x02) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    net_remove_netbuf(&c->send_queue, c->snb);
    c->snb = (struct netbuf *)(void *)0;
  }

  return 1;
}

// net_send_flush
// file includes/kore.h line 533
signed int net_send_flush(struct connection *c)
{
  while(!(c->send_queue.tqh_first == ((struct netbuf *)NULL)))
  {
    if((0x02 & (signed int)c->flags) == 0)
      break;

    signed int return_value_net_send_1;
    return_value_net_send_1=net_send(c);
    if(return_value_net_send_1 == 0)
      return 0;

  }
  if(!((0x40 & (signed int)c->flags) == 0))
  {
    if(c->send_queue.tqh_first == ((struct netbuf *)NULL))
      kore_connection_disconnect(c);

  }

  return 1;
}

// net_send_queue
// file includes/kore.h line 546
void net_send_queue(struct connection *c, void *data, unsigned int len, struct spdy_stream *s, signed int before)
{
  unsigned char *d;
  struct netbuf *nb;
  unsigned int avail;
  d = (unsigned char *)data;
  if(before == 0)
  {
    nb = *((struct netbuf_head *)(&c->send_queue)->tqh_last)->tqh_last;
    if(nb == ((struct netbuf *)NULL))
      goto __CPROVER_DUMP_L2;

    if(!((0x10 & (signed int)nb->flags) == 0))
      goto __CPROVER_DUMP_L2;

    if(!(nb->stream == s))
      goto __CPROVER_DUMP_L2;

    if(nb->b_len >= nb->m_len)
      goto __CPROVER_DUMP_L2;

    avail = nb->m_len - nb->b_len;
    if(!(len >= avail))
    {
      memcpy((void *)(nb->buf + (signed long int)nb->b_len), (const void *)d, (unsigned long int)len);
      nb->b_len = nb->b_len + len;
      goto __CPROVER_DUMP_L9;
    }

    if(avail >= len)
      goto __CPROVER_DUMP_L2;

    memcpy((void *)(nb->buf + (signed long int)nb->b_len), (const void *)d, (unsigned long int)avail);
    nb->b_len = nb->b_len + avail;
    len = len - avail;
    d = d + (signed long int)avail;
    if(!(len == 0u))
      goto __CPROVER_DUMP_L2;

  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    void *return_value_kore_pool_get_1;
    return_value_kore_pool_get_1=kore_pool_get(&nb_pool);
    nb = (struct netbuf *)return_value_kore_pool_get_1;
    nb->flags = (unsigned char)0;
    nb->cb = (signed int (*)(struct netbuf *))(void *)0;
    nb->owner = (void *)c;
    nb->s_off = (unsigned int)0;
    nb->stream = s;
    nb->b_len = len;
    nb->type = (unsigned char)1;
    if(!(nb->b_len >= 8192u))
      nb->m_len = (unsigned int)8192;

    else
      nb->m_len = nb->b_len;
    void *return_value_kore_malloc_2;
    return_value_kore_malloc_2=kore_malloc((unsigned long int)nb->m_len);
    nb->buf = (unsigned char *)return_value_kore_malloc_2;
    if(len >= 1u)
      memcpy((void *)nb->buf, (const void *)d, (unsigned long int)nb->b_len);

    if(before == 1)
      do
      {
        nb->list.tqe_prev = c->snb->list.tqe_prev;
        nb->list.tqe_next = c->snb;
        *c->snb->list.tqe_prev = nb;
        c->snb->list.tqe_prev = &nb->list.tqe_next;
      }
      while((_Bool)0);

    else
      do
      {
        nb->list.tqe_next = (struct netbuf *)(void *)0;
        nb->list.tqe_prev = (&c->send_queue)->tqh_last;
        *(&c->send_queue)->tqh_last = nb;
        (&c->send_queue)->tqh_last = &nb->list.tqe_next;
      }
      while((_Bool)0);
  }

__CPROVER_DUMP_L9:
  ;
}

// net_send_stream
// file includes/kore.h line 548
void net_send_stream(struct connection *c, void *data, unsigned int len, struct spdy_stream *s, signed int (*cb)(struct netbuf *), struct netbuf **out)
{
  struct netbuf *nb;
  void *return_value_kore_pool_get_1;
  return_value_kore_pool_get_1=kore_pool_get(&nb_pool);
  nb = (struct netbuf *)return_value_kore_pool_get_1;
  nb->cb = cb;
  nb->owner = (void *)c;
  nb->s_off = (unsigned int)0;
  nb->buf = (unsigned char *)data;
  nb->stream = s;
  nb->b_len = len;
  nb->m_len = nb->b_len;
  nb->type = (unsigned char)1;
  nb->flags = (unsigned char)0x10;
  do
  {
    nb->list.tqe_next = (struct netbuf *)(void *)0;
    nb->list.tqe_prev = (&c->send_queue)->tqh_last;
    *(&c->send_queue)->tqh_last = nb;
    (&c->send_queue)->tqh_last = &nb->list.tqe_next;
  }
  while((_Bool)0);
  if(!(out == ((struct netbuf **)NULL)))
    *out = nb;

}

// net_write
// file src/net.c line 358
signed int net_write(struct connection *c, signed int len, signed int *written)
{
  signed int r;
  signed long int return_value_write_1;
  return_value_write_1=write(c->fd, (const void *)(c->snb->buf + (signed long int)c->snb->s_off), (unsigned long int)len);
  r = (signed int)return_value_write_1;
  if(!(r >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 4 || *return_value___errno_location_2 == 11)
    {
      c->flags = c->flags & (unsigned char)~0x02;
      return 1;
    }

    return 0;
  }

  *written = r;
  return 1;
}

// net_write16
// file src/net.c line 421
void net_write16(unsigned char *p, unsigned short int n)
{
  unsigned short int r;
  r=htons(n);
  memcpy((void *)p, (const void *)&r, sizeof(unsigned short int) /*2ul*/ );
}

// net_write32
// file src/net.c line 430
void net_write32(unsigned char *p, unsigned int n)
{
  unsigned int r;
  r=htonl(n);
  memcpy((void *)p, (const void *)&r, sizeof(unsigned int) /*4ul*/ );
}

// net_write64
// file src/net.c line 448
void net_write64(unsigned char *p, unsigned long int n)
{
  unsigned long int r;
  r=__bswap_64(n);
  memcpy((void *)p, (const void *)&r, sizeof(unsigned long int) /*8ul*/ );
}

// net_write_ssl
// file includes/kore.h line 538
signed int net_write_ssl(struct connection *c, signed int len, signed int *written)
{
  signed int r;
  r=SSL_write(c->ssl, (const void *)(c->snb->buf + (signed long int)c->snb->s_off), len);
  if(c->tls_reneg >= 2)
    return 0;

  else
    if(!(r >= 1))
    {
      r=SSL_get_error(c->ssl, r);
      if(r == 2 || r == 3)
      {
        c->snb->flags = c->snb->flags | (unsigned char)0x04;
        c->flags = c->flags & (unsigned char)~0x02;
        return 1;
      }

      return 0;
    }

    else
    {
      *written = r;
      return 1;
    }
}

// pgsql_conn_cleanup
// file src/pgsql.c line 408
static void pgsql_conn_cleanup(struct pgsql_conn *conn)
{
  struct http_request *req;
  struct kore_pgsql *pgsql;
  if(!((0x01 & (signed int)conn->flags) == 0))
    do
    {
      if(!(conn->list.tqe_next == ((struct pgsql_conn *)NULL)))
        conn->list.tqe_next->list.tqe_prev = conn->list.tqe_prev;

      else
        (&pgsql_conn_free)->tqh_last = conn->list.tqe_prev;
      *conn->list.tqe_prev = conn->list.tqe_next;
    }
    while((_Bool)0);

  if(!(conn->job == ((struct pgsql_job *)NULL)))
  {
    req = conn->job->req;
    pgsql = conn->job->pgsql;
    http_request_wakeup(req);
    pgsql->conn = (struct pgsql_conn *)(void *)0;
    pgsql->state = (unsigned char)4;
    char *return_value_PQerrorMessage_1;
    return_value_PQerrorMessage_1=PQerrorMessage(conn->db);
    pgsql->error=kore_strdup(return_value_PQerrorMessage_1);
    kore_mem_free((void *)conn->job->query);
    kore_pool_put(&pgsql_job_pool, (void *)conn->job);
    conn->job = (struct pgsql_job *)(void *)0;
  }

  if(!(conn->db == ((struct pg_conn *)NULL)))
    PQfinish(conn->db);

  pgsql_conn_count = pgsql_conn_count - 1;
  kore_mem_free((void *)conn);
}

// pgsql_conn_create
// file src/pgsql.c line 351
static signed int pgsql_conn_create(struct kore_pgsql *pgsql)
{
  struct pgsql_conn *conn;
  if(pgsql_conn_string == ((char *)NULL))
    fatal("pgsql_conn_create: no connection string");

  pgsql_conn_count = pgsql_conn_count + 1;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct pgsql_conn) /*40ul*/ );
  conn = (struct pgsql_conn *)return_value_kore_malloc_1;
  memset((void *)conn, 0, sizeof(struct pgsql_conn) /*40ul*/ );
  conn->db=PQconnectdb(pgsql_conn_string);
  _Bool tmp_if_expr_4;
  enum anonymous_4 return_value_PQstatus_3;
  if(conn->db == ((struct pg_conn *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_PQstatus_3=PQstatus(conn->db);
    tmp_if_expr_4 = (signed int)return_value_PQstatus_3 != CONNECTION_OK ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    pgsql->state = (unsigned char)4;
    char *return_value_PQerrorMessage_2;
    return_value_PQerrorMessage_2=PQerrorMessage(conn->db);
    pgsql->error=kore_strdup(return_value_PQerrorMessage_2);
    pgsql_conn_cleanup(conn);
    return 0;
  }

  conn->job = (struct pgsql_job *)(void *)0;
  conn->flags = (unsigned char)0x01;
  conn->type = (unsigned char)3;
  do
  {
    conn->list.tqe_next = (struct pgsql_conn *)(void *)0;
    conn->list.tqe_prev = (&pgsql_conn_free)->tqh_last;
    *(&pgsql_conn_free)->tqh_last = conn;
    (&pgsql_conn_free)->tqh_last = &conn->list.tqe_next;
  }
  while((_Bool)0);
  return 1;
}

// pgsql_conn_release
// file src/pgsql.c line 380
static void pgsql_conn_release(struct kore_pgsql *pgsql)
{
  signed int fd;
  struct pg_result *return_value_PQgetResult_1;
  if(!(pgsql->conn == ((struct pgsql_conn *)NULL)))
  {
    kore_mem_free((void *)pgsql->conn->job->query);
    kore_pool_put(&pgsql_job_pool, (void *)pgsql->conn->job);
    do
    {
      return_value_PQgetResult_1=PQgetResult(pgsql->conn->db);
      if(return_value_PQgetResult_1 == ((struct pg_result *)NULL))
        break;

    }
    while((_Bool)1);
    pgsql->conn->job = (struct pgsql_job *)(void *)0;
    pgsql->conn->flags = pgsql->conn->flags | (unsigned char)0x01;
    do
    {
      pgsql->conn->list.tqe_next = (struct pgsql_conn *)(void *)0;
      pgsql->conn->list.tqe_prev = (&pgsql_conn_free)->tqh_last;
      *(&pgsql_conn_free)->tqh_last = pgsql->conn;
      (&pgsql_conn_free)->tqh_last = &pgsql->conn->list.tqe_next;
    }
    while((_Bool)0);
    fd=PQsocket(pgsql->conn->db);
    kore_platform_disable_read(fd);
    pgsql->conn = (struct pgsql_conn *)(void *)0;
    pgsql->state = (unsigned char)6;
    pgsql_queue_wakeup();
  }

}

// pgsql_prepare
// file src/pgsql.c line 266
static signed int pgsql_prepare(struct kore_pgsql *pgsql, struct http_request *req, const char *query)
{
  struct pgsql_conn *conn;
  pgsql->state = (unsigned char)1;
  pgsql->result = (struct pg_result *)(void *)0;
  pgsql->error = (char *)(void *)0;
  pgsql->conn = (struct pgsql_conn *)(void *)0;
  if(pgsql_conn_free.tqh_first == ((struct pgsql_conn *)NULL))
  {
    if((signed int)pgsql_conn_count >= (signed int)pgsql_conn_max)
    {
      pgsql_queue_add(req);
      return 0;
    }

    signed int return_value_pgsql_conn_create_1;
    return_value_pgsql_conn_create_1=pgsql_conn_create(pgsql);
    if(return_value_pgsql_conn_create_1 == 0)
      return 0;

  }

  http_request_sleep(req);
  conn = (&pgsql_conn_free)->tqh_first;
  if((0x01 & (signed int)conn->flags) == 0)
    fatal("received a pgsql conn that was not free?");

  conn->flags = conn->flags & (unsigned char)~0x01;
  do
  {
    if(!(conn->list.tqe_next == ((struct pgsql_conn *)NULL)))
      conn->list.tqe_next->list.tqe_prev = conn->list.tqe_prev;

    else
      (&pgsql_conn_free)->tqh_last = conn->list.tqe_prev;
    *conn->list.tqe_prev = conn->list.tqe_next;
  }
  while((_Bool)0);
  pgsql->conn = conn;
  void *return_value_kore_pool_get_2;
  return_value_kore_pool_get_2=kore_pool_get(&pgsql_job_pool);
  conn->job = (struct pgsql_job *)return_value_kore_pool_get_2;
  conn->job->query=kore_strdup(query);
  conn->job->pgsql = pgsql;
  conn->job->req = req;
  do
  {
    pgsql->rlist.le_next = (&req->pgsqls)->lh_first;
    if(!(pgsql->rlist.le_next == ((struct kore_pgsql *)NULL)))
      (&req->pgsqls)->lh_first->rlist.le_prev = &pgsql->rlist.le_next;

    (&req->pgsqls)->lh_first = pgsql;
    pgsql->rlist.le_prev = &(&req->pgsqls)->lh_first;
  }
  while((_Bool)0);
  return 1;
}

// pgsql_queue_add
// file src/pgsql.c line 318
static void pgsql_queue_add(struct http_request *req)
{
  struct pgsql_wait *pgw;
  http_request_sleep(req);
  void *return_value_kore_pool_get_1;
  return_value_kore_pool_get_1=kore_pool_get(&pgsql_wait_pool);
  pgw = (struct pgsql_wait *)return_value_kore_pool_get_1;
  pgw->req = req;
  pgw->req->flags = pgw->req->flags | (unsigned char)0x10;
  do
  {
    pgw->list.tqe_next = (struct pgsql_wait *)(void *)0;
    pgw->list.tqe_prev = (&pgsql_wait_queue)->tqh_last;
    *(&pgsql_wait_queue)->tqh_last = pgw;
    (&pgsql_wait_queue)->tqh_last = &pgw->list.tqe_next;
  }
  while((_Bool)0);
}

// pgsql_queue_wakeup
// file src/pgsql.c line 332
static void pgsql_queue_wakeup(void)
{
  struct pgsql_wait *pgw;
  struct pgsql_wait *next;
  pgw = (&pgsql_wait_queue)->tqh_first;
  for( ; !(pgw == ((struct pgsql_wait *)NULL)); pgw = next)
  {
    next = pgw->list.tqe_next;
    if((0x02 & (signed int)pgw->req->flags) == 0)
    {
      http_request_wakeup(pgw->req);
      pgw->req->flags = pgw->req->flags & (unsigned char)~0x10;
      do
      {
        if(!(pgw->list.tqe_next == ((struct pgsql_wait *)NULL)))
          pgw->list.tqe_next->list.tqe_prev = pgw->list.tqe_prev;

        else
          (&pgsql_wait_queue)->tqh_last = pgw->list.tqe_prev;
        *pgw->list.tqe_prev = pgw->list.tqe_next;
      }
      while((_Bool)0);
      kore_pool_put(&pgsql_wait_pool, (void *)pgw);
      goto __CPROVER_DUMP_L7;
    }

  }

__CPROVER_DUMP_L7:
  ;
}

// pgsql_read_result
// file src/pgsql.c line 440
static void pgsql_read_result(struct kore_pgsql *pgsql, signed int async)
{
  if(!(async == 0))
  {
    signed int return_value_PQisBusy_1;
    return_value_PQisBusy_1=PQisBusy(pgsql->conn->db);
    if(!(return_value_PQisBusy_1 == 0))
    {
      pgsql->state = (unsigned char)2;
      goto __CPROVER_DUMP_L9;
    }

  }

  pgsql->result=PQgetResult(pgsql->conn->db);
  char *return_value_PQresultErrorMessage_3;
  if(pgsql->result == ((struct pg_result *)NULL))
    pgsql->state = (unsigned char)5;

  else
  {
    enum anonymous return_value_PQresultStatus_2;
    return_value_PQresultStatus_2=PQresultStatus(pgsql->result);
    switch((signed int)return_value_PQresultStatus_2)
    {
      case PGRES_COPY_OUT:

      case PGRES_COPY_IN:

      case PGRES_NONFATAL_ERROR:

      case PGRES_COPY_BOTH:
        goto __CPROVER_DUMP_L8;
      case PGRES_COMMAND_OK:
      {
        pgsql->state = (unsigned char)5;
        goto __CPROVER_DUMP_L8;
      }
      case PGRES_TUPLES_OK:

      case PGRES_SINGLE_TUPLE:
      {
        pgsql->state = (unsigned char)3;
        goto __CPROVER_DUMP_L8;
      }
      case PGRES_EMPTY_QUERY:

      case PGRES_BAD_RESPONSE:

      case PGRES_FATAL_ERROR:
      {
        pgsql->state = (unsigned char)4;
        return_value_PQresultErrorMessage_3=PQresultErrorMessage(pgsql->result);
        pgsql->error=kore_strdup(return_value_PQresultErrorMessage_3);
      }
      default:

        __CPROVER_DUMP_L8:
          ;
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// pgsql_schedule
// file src/pgsql.c line 305
static void pgsql_schedule(struct kore_pgsql *pgsql, struct http_request *req)
{
  signed int fd;
  fd=PQsocket(pgsql->conn->db);
  if(!(fd >= 0))
    fatal("PQsocket returned < 0 fd on open connection");

  kore_platform_schedule_read(fd, (void *)pgsql->conn);
  pgsql->state = (unsigned char)2;
}

// pool_region_create
// file src/pool.c line 96
static void pool_region_create(struct kore_pool *pool, unsigned int elms)
{
  unsigned int i;
  unsigned char *p;
  struct kore_pool_region *reg;
  struct kore_pool_entry *entry;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_pool_region) /*24ul*/ );
  reg = (struct kore_pool_region *)return_value_kore_malloc_1;
  do
  {
    reg->list.le_next = (&pool->regions)->lh_first;
    if(!(reg->list.le_next == ((struct kore_pool_region *)NULL)))
      (&pool->regions)->lh_first->list.le_prev = &reg->list.le_next;

    (&pool->regions)->lh_first = reg;
    reg->list.le_prev = &(&pool->regions)->lh_first;
  }
  while((_Bool)0);
  reg->start=kore_malloc((unsigned long int)(elms * pool->slen));
  p = (unsigned char *)reg->start;
  i = (unsigned int)0;
  for( ; !(i >= elms); i = i + 1u)
  {
    entry = (struct kore_pool_entry *)p;
    entry->region = reg;
    entry->state = (unsigned char)1;
    do
    {
      entry->list.le_next = (&pool->freelist)->lh_first;
      if(!(entry->list.le_next == ((struct kore_pool_entry *)NULL)))
        (&pool->freelist)->lh_first->list.le_prev = &entry->list.le_next;

      (&pool->freelist)->lh_first = entry;
      entry->list.le_prev = &(&pool->freelist)->lh_first;
    }
    while((_Bool)0);
    p = p + (signed long int)pool->slen;
  }
  pool->elms = pool->elms + elms;
}

// spdy_block_write
// file src/spdy.c line 875
static void spdy_block_write(struct connection *c)
{
  c->flags = c->flags | (unsigned char)0x04;
  c->flags = c->flags & (unsigned char)~0x02;
}

// spdy_ctrl_frame_goaway
// file src/spdy.c line 758
static signed int spdy_ctrl_frame_goaway(struct netbuf *nb)
{
  struct connection *c = (struct connection *)nb->owner;
  c->flags = c->flags | (unsigned char)0x80;
  kore_connection_disconnect(c);
  return 1;
}

// spdy_ctrl_frame_ping
// file src/spdy.c line 691
static signed int spdy_ctrl_frame_ping(struct netbuf *nb)
{
  unsigned int id;
  struct connection *c = (struct connection *)nb->owner;
  id=ntohl(*((unsigned int *)(nb->buf + (signed long int)8)));
  if(id % 2u == 0u)
  {
    spdy_session_teardown(c, (unsigned char)1);
    return 1;
  }

  else
  {
    spdy_frame_send(c, (unsigned short int)6, (unsigned char)0, (unsigned int)4, (struct spdy_stream *)(void *)0, id);
    net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
    return 1;
  }
}

// spdy_ctrl_frame_rst_stream
// file src/spdy.c line 612
static signed int spdy_ctrl_frame_rst_stream(struct netbuf *nb)
{
  struct spdy_stream *s;
  unsigned int stream_id;
  struct connection *c = (struct connection *)nb->owner;
  stream_id=net_read32(nb->buf + (signed long int)8);
  if(stream_id % 2u == 0u)
    return 0;

  else
  {
    s=spdy_stream_lookup(c, stream_id);
    if(s == ((struct spdy_stream *)NULL))
      return 0;

    else
    {
      spdy_stream_close(c, s, 1);
      net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
      return 1;
    }
  }
}

// spdy_ctrl_frame_settings
// file src/spdy.c line 636
static signed int spdy_ctrl_frame_settings(struct netbuf *nb)
{
  struct spdy_stream *s;
  unsigned char *buf;
  unsigned int ecount;
  unsigned int i;
  unsigned int id;
  unsigned int val;
  unsigned int length;
  unsigned int diff;
  struct connection *c = (struct connection *)nb->owner;
  ecount=net_read32(nb->buf + (signed long int)8);
  unsigned int return_value_net_read32_1;
  return_value_net_read32_1=net_read32(nb->buf + (signed long int)4);
  length = return_value_net_read32_1 & (unsigned int)0xffffff;
  if(!((signed int)ecount >= 0) || !((signed int)length >= 0))
  {
    spdy_session_teardown(c, (unsigned char)1);
    return 1;
  }

  else
    if(!(length == 8u * ecount + 4u))
    {
      spdy_session_teardown(c, (unsigned char)1);
      return 1;
    }

    else
    {
      buf = nb->buf + (signed long int)8 + (signed long int)4;
      i = (unsigned int)0;
      for( ; !(i >= ecount); i = i + 1u)
      {
        unsigned int return_value_net_read32_2;
        return_value_net_read32_2=net_read32(buf);
        id = return_value_net_read32_2 & (unsigned int)0xffffff;
        val=net_read32(buf + (signed long int)4);
        if(!((signed int)val >= 0))
          buf = buf + (signed long int)8;

        else
        {
          if(id == 7u)
          {
            diff = val - c->wsize_initial;
            c->wsize_initial = val;
            s = (&c->spdy_streams)->tqh_first;
            for( ; !(s == ((struct spdy_stream *)NULL)); s = s->list.tqe_next)
              s->send_wsize = s->send_wsize + diff;
          }

          buf = buf + (signed long int)8;
        }
      }
      net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
      return 1;
    }
}

// spdy_ctrl_frame_syn_stream
// file src/spdy.c line 476
static signed int spdy_ctrl_frame_syn_stream(struct netbuf *nb)
{
  struct spdy_stream *s;
  struct spdy_syn_stream syn;
  struct spdy_ctrl_frame ctrl;
  unsigned char *src;
  char *host;
  char *method;
  char *path;
  char *spdy_ctrl_frame_syn_stream__1__version;
  struct connection *c = (struct connection *)nb->owner;
  unsigned short int return_value_net_read16_1;
  return_value_net_read16_1=net_read16(nb->buf);
  ctrl.version = (unsigned short int)((signed int)return_value_net_read16_1 & 0x7fff);
  ctrl.type=net_read16(nb->buf + (signed long int)2);
  ctrl.flags = *((unsigned char *)(nb->buf + (signed long int)4));
  unsigned int return_value_net_read32_2;
  return_value_net_read32_2=net_read32(nb->buf + (signed long int)4);
  ctrl.length = return_value_net_read32_2 & (unsigned int)0xffffff;
  syn.stream_id=net_read32(nb->buf + (signed long int)8);
  syn.assoc_stream_id=net_read32(nb->buf + (signed long int)12);
  unsigned short int return_value_net_read16_3;
  return_value_net_read16_3=net_read16(nb->buf + (signed long int)16);
  syn.prio = (unsigned char)((signed int)return_value_net_read16_3 & 0xe000);
  unsigned short int return_value_net_read16_4;
  return_value_net_read16_4=net_read16(nb->buf + (signed long int)16);
  syn.slot = (unsigned char)((signed int)return_value_net_read16_4 & 0x7);
  if(c->spdy_send_wsize >= 1u)
  {
    if(!((0x04 & (signed int)c->flags) == 0))
      spdy_enable_write(c);

  }

  if(!((signed int)ctrl.length >= 0))
  {
    spdy_session_teardown(c, (unsigned char)1);
    return 1;
  }

  else
    if(syn.stream_id == 0u || syn.stream_id % 2u == 0u)
    {
      spdy_session_teardown(c, (unsigned char)1);
      return 1;
    }

    else
      if(!(syn.stream_id >= c->client_stream_id))
      {
        spdy_session_teardown(c, (unsigned char)1);
        return 1;
      }

      else
      {
        s=spdy_stream_lookup(c, syn.stream_id);
        if(!(s == ((struct spdy_stream *)NULL)))
        {
          spdy_session_teardown(c, (unsigned char)1);
          return 1;
        }

        else
        {
          void *return_value_kore_malloc_5;
          return_value_kore_malloc_5=kore_malloc(sizeof(struct spdy_stream) /*80ul*/ );
          s = (struct spdy_stream *)return_value_kore_malloc_5;
          s->send_size = (unsigned long int)0;
          s->frame_size = (unsigned int)0;
          s->httpreq = (struct http_request *)(void *)0;
          s->onclose = (void (*)(struct connection *, struct spdy_stream *))(void *)0;
          s->prio = syn.prio;
          s->flags = ctrl.flags;
          s->recv_wsize = spdy_recv_wsize;
          s->send_wsize = c->wsize_initial;
          s->stream_id = syn.stream_id;
          s->hblock=spdy_header_block_create(1);
          src = nb->buf + (signed long int)8 + (signed long int)10;
          signed int return_value_spdy_zlib_inflate_6;
          return_value_spdy_zlib_inflate_6=spdy_zlib_inflate(c, src, (unsigned long int)(ctrl.length - (unsigned int)10), &s->hblock->header_block, &s->hblock->header_block_len);
          if(return_value_spdy_zlib_inflate_6 == 0)
          {
            kore_mem_free((void *)s->hblock->header_block);
            kore_mem_free((void *)s->hblock);
            kore_mem_free((void *)s);
            spdy_session_teardown(c, (unsigned char)2);
            return 1;
          }

          else
          {
            s->hblock->header_pairs=net_read32(s->hblock->header_block);
            if(!((signed int)s->hblock->header_pairs >= 0))
            {
              kore_mem_free((void *)s->hblock->header_block);
              kore_mem_free((void *)s->hblock);
              kore_mem_free((void *)s);
              spdy_session_teardown(c, (unsigned char)1);
              return 1;
            }

            else
            {
              path = (char *)(void *)0;
              host = (char *)(void *)0;
              method = (char *)(void *)0;
              spdy_ctrl_frame_syn_stream__1__version = (char *)(void *)0;
              signed int return_value_spdy_stream_get_header_7;
              return_value_spdy_stream_get_header_7=spdy_stream_get_header(s->hblock, ":path", &path);
              if(return_value_spdy_stream_get_header_7 == 0)
              {
                kore_mem_free((void *)s->hblock->header_block);
                kore_mem_free((void *)s->hblock);
                kore_mem_free((void *)s);
                if(!(path == ((char *)NULL)))
                  kore_mem_free((void *)path);

                if(!(host == ((char *)NULL)))
                  kore_mem_free((void *)host);

                if(!(method == ((char *)NULL)))
                  kore_mem_free((void *)method);

                if(!(spdy_ctrl_frame_syn_stream__1__version == ((char *)NULL)))
                  kore_mem_free((void *)spdy_ctrl_frame_syn_stream__1__version);

                spdy_session_teardown(c, (unsigned char)1);
                return 1;
              }

              else
              {
                signed int return_value_spdy_stream_get_header_8;
                return_value_spdy_stream_get_header_8=spdy_stream_get_header(s->hblock, ":method", &method);
                if(return_value_spdy_stream_get_header_8 == 0)
                {
                  kore_mem_free((void *)s->hblock->header_block);
                  kore_mem_free((void *)s->hblock);
                  kore_mem_free((void *)s);
                  if(!(path == ((char *)NULL)))
                    kore_mem_free((void *)path);

                  if(!(host == ((char *)NULL)))
                    kore_mem_free((void *)host);

                  if(!(method == ((char *)NULL)))
                    kore_mem_free((void *)method);

                  if(!(spdy_ctrl_frame_syn_stream__1__version == ((char *)NULL)))
                    kore_mem_free((void *)spdy_ctrl_frame_syn_stream__1__version);

                  spdy_session_teardown(c, (unsigned char)1);
                  return 1;
                }

                else
                {
                  signed int return_value_spdy_stream_get_header_9;
                  return_value_spdy_stream_get_header_9=spdy_stream_get_header(s->hblock, ":host", &host);
                  if(return_value_spdy_stream_get_header_9 == 0)
                  {
                    kore_mem_free((void *)s->hblock->header_block);
                    kore_mem_free((void *)s->hblock);
                    kore_mem_free((void *)s);
                    if(!(path == ((char *)NULL)))
                      kore_mem_free((void *)path);

                    if(!(host == ((char *)NULL)))
                      kore_mem_free((void *)host);

                    if(!(method == ((char *)NULL)))
                      kore_mem_free((void *)method);

                    if(!(spdy_ctrl_frame_syn_stream__1__version == ((char *)NULL)))
                      kore_mem_free((void *)spdy_ctrl_frame_syn_stream__1__version);

                    spdy_session_teardown(c, (unsigned char)1);
                    return 1;
                  }

                  else
                  {
                    signed int return_value_spdy_stream_get_header_10;
                    return_value_spdy_stream_get_header_10=spdy_stream_get_header(s->hblock, ":version", &spdy_ctrl_frame_syn_stream__1__version);
                    if(return_value_spdy_stream_get_header_10 == 0)
                    {
                      kore_mem_free((void *)s->hblock->header_block);
                      kore_mem_free((void *)s->hblock);
                      kore_mem_free((void *)s);
                      if(!(path == ((char *)NULL)))
                        kore_mem_free((void *)path);

                      if(!(host == ((char *)NULL)))
                        kore_mem_free((void *)host);

                      if(!(method == ((char *)NULL)))
                        kore_mem_free((void *)method);

                      if(!(spdy_ctrl_frame_syn_stream__1__version == ((char *)NULL)))
                        kore_mem_free((void *)spdy_ctrl_frame_syn_stream__1__version);

                      spdy_session_teardown(c, (unsigned char)1);
                      return 1;
                    }

                    else
                    {
                      c->client_stream_id = s->stream_id;
                      do
                      {
                        s->list.tqe_next = (struct spdy_stream *)(void *)0;
                        s->list.tqe_prev = (&c->spdy_streams)->tqh_last;
                        *(&c->spdy_streams)->tqh_last = s;
                        (&c->spdy_streams)->tqh_last = &s->list.tqe_next;
                      }
                      while((_Bool)0);
                      http_request_new(c, s, host, method, path, spdy_ctrl_frame_syn_stream__1__version, (struct http_request **)&s->httpreq);
                      kore_mem_free((void *)path);
                      kore_mem_free((void *)method);
                      kore_mem_free((void *)host);
                      kore_mem_free((void *)spdy_ctrl_frame_syn_stream__1__version);
                      net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
}

// spdy_ctrl_frame_window
// file src/spdy.c line 713
static signed int spdy_ctrl_frame_window(struct netbuf *nb)
{
  signed int r;
  struct spdy_stream *s;
  unsigned int stream_id;
  unsigned int window_size;
  struct connection *c = (struct connection *)nb->owner;
  stream_id=net_read32(nb->buf + (signed long int)8);
  window_size=net_read32(nb->buf + (signed long int)8 + (signed long int)4);
  r = 1;
  s=spdy_stream_lookup(c, stream_id);
  if(!(s == ((struct spdy_stream *)NULL)))
  {
    s->send_wsize = s->send_wsize + window_size;
    if((unsigned long int)s->send_wsize >= 2147483648ul)
      return 0;

    if(!((0x04 & (signed int)c->flags) == 0))
    {
      if(s->send_wsize >= 1u)
      {
        if(c->spdy_send_wsize >= 1u)
        {
          spdy_enable_write(c);
          r=net_send_flush(c);
        }

      }

    }

  }

  else
  {
    c->spdy_send_wsize = c->spdy_send_wsize + window_size;
    if((unsigned long int)c->spdy_send_wsize >= 2147483648ul)
      return 0;

    if(!((0x04 & (signed int)c->flags) == 0))
    {
      if(c->spdy_send_wsize >= 1u)
      {
        spdy_enable_write(c);
        r=net_send_flush(c);
      }

    }

  }
  net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
  return r;
}

// spdy_data_frame_recv
// file src/spdy.c line 771
static signed int spdy_data_frame_recv(struct netbuf *nb)
{
  struct spdy_stream *s;
  signed int err;
  struct http_request *req;
  struct spdy_data_frame data;
  char *content;
  struct connection *c = (struct connection *)nb->owner;
  unsigned int return_value_net_read32_1;
  return_value_net_read32_1=net_read32(nb->buf);
  data.stream_id = return_value_net_read32_1 & (unsigned int)~(1 << 31);
  data.flags = *((unsigned char *)(nb->buf + (signed long int)4));
  unsigned int return_value_net_read32_2;
  return_value_net_read32_2=net_read32(nb->buf + (signed long int)4);
  data.length = return_value_net_read32_2 & (unsigned int)0xffffff;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  if(!((signed int)data.length >= 0))
    return 0;

  else
  {
    s=spdy_stream_lookup(c, data.stream_id);
    if(s == ((struct spdy_stream *)NULL))
      return 0;

    else
    {
      req = (struct http_request *)s->httpreq;
      if(req == ((struct http_request *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = !(((signed int)req->flags & 0x20) != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        return 0;

      else
      {
        if(req->http_body == ((struct kore_buf *)NULL))
        {
          signed int return_value_spdy_stream_get_header_4;
          return_value_spdy_stream_get_header_4=spdy_stream_get_header(s->hblock, "content-length", &content);
          if(return_value_spdy_stream_get_header_4 == 0)
            return 0;

          signed long long int return_value_kore_strtonum_5;
          return_value_kore_strtonum_5=kore_strtonum(content, 10, (signed long long int)0, 0x7fffffffffffffffLL, &err);
          s->post_size = (unsigned long int)return_value_kore_strtonum_5;
          if(err == 0)
          {
            kore_mem_free((void *)content);
            return 0;
          }

          kore_mem_free((void *)content);
          if(s->post_size == 0ul)
          {
            req->flags = req->flags | (unsigned char)0x01;
            req->flags = req->flags & (unsigned char)~0x20;
            net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
            return 1;
          }

          if(!(http_body_max >= s->post_size))
          {
            kore_log(5, "body data too large (%ld > %ld)", s->post_size, http_body_max);
            return 0;
          }

          req->http_body=kore_buf_create((unsigned int)s->post_size);
        }

        if(!(s->post_size >= req->http_body->offset + (unsigned long int)data.length))
          return 0;

        else
        {
          kore_buf_append(req->http_body, (void *)(nb->buf + (signed long int)8), data.length);
          if(!((0x01 & (signed int)data.flags) == 0))
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = req->http_body->offset == s->post_size ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_6)
          {
            if(!(req->http_body->offset == s->post_size))
              return 0;

            s->post_size = (unsigned long int)0;
            s->flags = s->flags | (unsigned char)0x01;
            req->flags = req->flags | (unsigned char)0x01;
            req->flags = req->flags & (unsigned char)~0x20;
          }

          net_recv_reset(c, (unsigned int)8, spdy_frame_recv);
          s->recv_wsize = s->recv_wsize - data.length;
          spdy_frame_send(c, (unsigned short int)9, (unsigned char)0, (unsigned int)8, s, data.length);
          s->recv_wsize = s->recv_wsize + data.length;
          c->spdy_recv_wsize = c->spdy_recv_wsize - data.length;
          spdy_frame_send(c, (unsigned short int)9, (unsigned char)0, (unsigned int)8, (struct spdy_stream *)(void *)0, data.length);
          c->spdy_recv_wsize = c->spdy_recv_wsize + data.length;
          return 1;
        }
      }
    }
  }
}

// spdy_dataframe_begin
// file includes/kore.h line 568
signed int spdy_dataframe_begin(struct connection *c)
{
  struct spdy_stream *s = c->snb->stream;
  _Bool tmp_if_expr_1;
  if(!(s->frame_size == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = s->send_size == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fatal("spdy_dataframe_begin(): s:%u fz:%d - sz:%d", s->stream_id, s->frame_size, s->send_size);

  _Bool tmp_if_expr_2;
  if(!((signed int)s->send_wsize >= 1))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)c->spdy_send_wsize <= 0 ? (_Bool)1 : (_Bool)0;
  unsigned long int tmp_if_expr_3;
  if(tmp_if_expr_2)
  {
    spdy_block_write(c);
    return 0;
  }

  else
  {
    if(s->send_size >= 8193ul)
      tmp_if_expr_3 = (unsigned long int)8192;

    else
      tmp_if_expr_3 = s->send_size;
    s->frame_size = (unsigned int)tmp_if_expr_3;
    s->flags = s->flags & (unsigned char)~0x20;
    spdy_frame_send(c, (unsigned short int)99, (unsigned char)0, s->frame_size, s, (unsigned int)0);
    return 1;
  }
}

// spdy_enable_write
// file src/spdy.c line 884
static void spdy_enable_write(struct connection *c)
{
  c->flags = c->flags & (unsigned char)~0x04;
  c->flags = c->flags | (unsigned char)0x02;
}

// spdy_frame_recv
// file includes/kore.h line 567
signed int spdy_frame_recv(struct netbuf *nb)
{
  struct spdy_stream *s;
  struct spdy_ctrl_frame ctrl;
  struct spdy_data_frame data;
  signed int (*cb)(struct netbuf *);
  signed int r;
  struct connection *c = (struct connection *)nb->owner;
  unsigned int return_value_net_read32_5;
  return_value_net_read32_5=net_read32(nb->buf);
  if(!((2147483648u & return_value_net_read32_5) == 0u))
  {
    unsigned short int return_value_net_read16_1;
    return_value_net_read16_1=net_read16(nb->buf);
    ctrl.version = (unsigned short int)((signed int)return_value_net_read16_1 & 0x7fff);
    ctrl.type=net_read16(nb->buf + (signed long int)2);
    ctrl.flags = *((unsigned char *)(nb->buf + (signed long int)4));
    unsigned int return_value_net_read32_2;
    return_value_net_read32_2=net_read32(nb->buf + (signed long int)4);
    ctrl.length = return_value_net_read32_2 & (unsigned int)0xffffff;
    if(!((signed int)ctrl.length >= 0))
    {
      spdy_session_teardown(c, (unsigned char)1);
      return 1;
    }

    if(!((signed int)ctrl.version == 3))
    {
      spdy_session_teardown(c, (unsigned char)1);
      return 1;
    }

    switch((signed int)ctrl.type)
    {
      case 1:
      {
        cb = spdy_ctrl_frame_syn_stream;
        break;
      }
      case 3:
      {
        cb = spdy_ctrl_frame_rst_stream;
        break;
      }
      case 4:
      {
        cb = spdy_ctrl_frame_settings;
        break;
      }
      case 6:
      {
        cb = spdy_ctrl_frame_ping;
        break;
      }
      case 9:
      {
        cb = spdy_ctrl_frame_window;
        break;
      }
      case 7:
      {
        cb = spdy_ctrl_frame_goaway;
        break;
      }
      default:
        cb = (signed int (*)(struct netbuf *))(void *)0;
    }
    r = 1;
    if(!(cb == ((signed int (*)(struct netbuf *))NULL)))
      net_recv_expand(c, ctrl.length, cb);

  }

  else
  {
    unsigned int return_value_net_read32_3;
    return_value_net_read32_3=net_read32(nb->buf);
    data.stream_id = return_value_net_read32_3 & (unsigned int)~(1 << 31);
    s=spdy_stream_lookup(c, data.stream_id);
    if(s == ((struct spdy_stream *)NULL))
    {
      if((0x80 & (signed int)c->flags) == 0)
        r = 0;

      else
        r = 1;
    }

    else
      if(!((0x01 & (signed int)s->flags) == 0))
        r = 0;

      else
      {
        data.flags = *((unsigned char *)(nb->buf + (signed long int)4));
        unsigned int return_value_net_read32_4;
        return_value_net_read32_4=net_read32(nb->buf + (signed long int)4);
        data.length = return_value_net_read32_4 & (unsigned int)0xffffff;
        if(!((signed int)data.length >= 0))
          r = 0;

        else
        {
          r = 1;
          net_recv_expand(c, data.length, spdy_data_frame_recv);
        }
      }
  }
  if(!(r == 1))
  {
    r = 1;
    spdy_session_teardown(c, (unsigned char)1);
  }

  return r;
}

// spdy_frame_send
// file includes/kore.h line 570
void spdy_frame_send(struct connection *c, unsigned short int type, unsigned char flags, unsigned int len, struct spdy_stream *s, unsigned int misc)
{
  unsigned char nb[16l];
  unsigned int length;
  if((signed int)type == 2 || (signed int)type == 99)
  {
    if(s == ((struct spdy_stream *)NULL))
      fatal("spdy_frame_send(): stream is NULL for %d", type);

  }

  length = (unsigned int)0;
  memset((void *)nb, 0, sizeof(unsigned char [16l]) /*16ul*/ );
  unsigned int tmp_if_expr_1;
  switch((signed int)type)
  {
    case 6:

    case 2:
    {
      net_write16(&nb[(signed long int)0], (unsigned short int)3);
      nb[(signed long int)0] = nb[(signed long int)0] | (unsigned char)(1 << 7);
      net_write16(&nb[(signed long int)2], type);
      if(!((signed int)type == 6))
      {
        net_write32(&nb[(signed long int)4], len + (unsigned int)4);
        nb[(signed long int)4] = flags;
        net_write32(&nb[(signed long int)8], s->stream_id);
      }

      else
      {
        net_write32(&nb[(signed long int)4], len);
        nb[(signed long int)4] = flags;
        net_write32(&nb[(signed long int)8], misc);
      }
      length = (unsigned int)12;
      break;
    }
    case 7:
    {
      net_write16(&nb[(signed long int)0], (unsigned short int)3);
      nb[(signed long int)0] = nb[(signed long int)0] | (unsigned char)(1 << 7);
      net_write16(&nb[(signed long int)2], type);
      net_write32(&nb[(signed long int)4], len);
      nb[(signed long int)4] = flags;
      length = (unsigned int)8;
      break;
    }
    case 9:
    {
      net_write16(&nb[(signed long int)0], (unsigned short int)3);
      nb[(signed long int)0] = nb[(signed long int)0] | (unsigned char)(1 << 7);
      net_write16(&nb[(signed long int)2], type);
      net_write32(&nb[(signed long int)4], len);
      nb[(signed long int)4] = flags;
      if(!(s == ((struct spdy_stream *)NULL)))
        tmp_if_expr_1 = s->stream_id;

      else
        tmp_if_expr_1 = (unsigned int)0;
      net_write32(&nb[(signed long int)8], tmp_if_expr_1);
      net_write32(&nb[(signed long int)12], misc);
      length = (unsigned int)16;
      break;
    }
    case 99:
    {
      net_write32(&nb[(signed long int)0], s->stream_id);
      nb[(signed long int)0] = nb[(signed long int)0] & (unsigned char)~(1 << 7);
      net_write32(&nb[(signed long int)4], len);
      nb[(signed long int)4] = flags;
      length = (unsigned int)8;
    }
  }
  if((0x01 & (signed int)flags) == 0 && (signed int)type == 99)
    net_send_queue(c, (void *)nb, length, (struct spdy_stream *)(void *)0, 1);

  else
    net_send_queue(c, (void *)nb, length, (struct spdy_stream *)(void *)0, 0);
}

// spdy_header_block_add
// file includes/kore.h line 572
void spdy_header_block_add(struct spdy_header_block *hblock, char *name, char *value)
{
  unsigned char *p;
  unsigned int nlen;
  unsigned int vlen;
  unsigned int tlen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  nlen = (unsigned int)return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(value);
  vlen = (unsigned int)return_value_strlen_2;
  tlen = nlen + (unsigned int)4 + vlen + (unsigned int)4;
  if(!(hblock->header_block_len >= hblock->header_offset + tlen))
  {
    hblock->header_block_len = hblock->header_block_len + nlen + vlen + (unsigned int)128;
    void *return_value_kore_realloc_3;
    return_value_kore_realloc_3=kore_realloc((void *)hblock->header_block, (unsigned long int)hblock->header_block_len);
    hblock->header_block = (unsigned char *)return_value_kore_realloc_3;
  }

  p = hblock->header_block + (signed long int)hblock->header_offset;
  net_write32(p, nlen);
  memcpy((void *)(p + (signed long int)4), (const void *)(unsigned char *)name, (unsigned long int)nlen);
  hblock->header_offset = hblock->header_offset + (unsigned int)4 + nlen;
  p = hblock->header_block + (signed long int)hblock->header_offset;
  net_write32(p, vlen);
  memcpy((void *)(p + (signed long int)4), (const void *)(unsigned char *)value, (unsigned long int)vlen);
  hblock->header_offset = hblock->header_offset + (unsigned int)4 + vlen;
  hblock->header_pairs = hblock->header_pairs + 1u;
}

// spdy_header_block_create
// file includes/kore.h line 579
struct spdy_header_block * spdy_header_block_create(signed int delayed_alloc)
{
  struct spdy_header_block *hblock;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct spdy_header_block) /*24ul*/ );
  hblock = (struct spdy_header_block *)return_value_kore_malloc_1;
  if(delayed_alloc == 0)
  {
    void *return_value_kore_malloc_2;
    return_value_kore_malloc_2=kore_malloc((unsigned long int)128);
    hblock->header_block = (unsigned char *)return_value_kore_malloc_2;
    hblock->header_block_len = (unsigned int)128;
    hblock->header_offset = (unsigned int)4;
  }

  else
  {
    hblock->header_block = (unsigned char *)(void *)0;
    hblock->header_block_len = (unsigned int)0;
    hblock->header_offset = (unsigned int)0;
  }
  hblock->header_pairs = (unsigned int)0;
  return hblock;
}

// spdy_header_block_release
// file includes/kore.h line 574
unsigned char * spdy_header_block_release(struct connection *c, struct spdy_header_block *hblock, unsigned int *len)
{
  unsigned char *deflated;
  net_write32(hblock->header_block, hblock->header_pairs);
  signed int return_value_spdy_zlib_deflate_1;
  return_value_spdy_zlib_deflate_1=spdy_zlib_deflate(c, hblock->header_block, (unsigned long int)hblock->header_offset, &deflated, len);
  if(return_value_spdy_zlib_deflate_1 == 0)
  {
    kore_mem_free((void *)hblock->header_block);
    kore_mem_free((void *)hblock);
    return (unsigned char *)(void *)0;
  }

  else
  {
    kore_mem_free((void *)hblock->header_block);
    kore_mem_free((void *)hblock);
    return deflated;
  }
}

// spdy_session_teardown
// file includes/kore.h line 569
void spdy_session_teardown(struct connection *c, unsigned char err)
{
  unsigned char d[8l];
  net_write32((unsigned char *)&d[(signed long int)0], c->client_stream_id);
  net_write32((unsigned char *)&d[(signed long int)4], (unsigned int)err);
  spdy_frame_send(c, (unsigned short int)7, (unsigned char)0, (unsigned int)8, (struct spdy_stream *)(void *)0, (unsigned int)0);
  net_send_queue(c, (void *)d, (unsigned int)sizeof(unsigned char [8l]) /*8ul*/ , (struct spdy_stream *)(void *)0, 0);
  c->flags = c->flags & (unsigned char)~0x01;
  c->flags = c->flags | (unsigned char)0x20;
  net_send_flush(c);
  kore_connection_disconnect(c);
}

// spdy_stream_close
// file includes/kore.h line 576
void spdy_stream_close(struct connection *c, struct spdy_stream *s, signed int rb)
{
  struct http_request *req;
  struct netbuf *nb;
  struct netbuf *nt;
  if(!(s->onclose == ((void (*)(struct connection *, struct spdy_stream *))NULL)))
    s->onclose(c, s);

  if(!(rb == 0))
  {
    nb = (&c->send_queue)->tqh_first;
    for( ; !(nb == ((struct netbuf *)NULL)); nb = nt)
    {
      nt = nb->list.tqe_next;
      if(nb->stream == s)
        net_remove_netbuf(&c->send_queue, nb);

    }
  }

  do
  {
    if(!(s->list.tqe_next == ((struct spdy_stream *)NULL)))
      s->list.tqe_next->list.tqe_prev = s->list.tqe_prev;

    else
      (&c->spdy_streams)->tqh_last = s->list.tqe_prev;
    *s->list.tqe_prev = s->list.tqe_next;
  }
  while((_Bool)0);
  if(!(s->hblock == ((struct spdy_header_block *)NULL)))
  {
    if(!(s->hblock->header_block == ((unsigned char *)NULL)))
      kore_mem_free((void *)s->hblock->header_block);

    kore_mem_free((void *)s->hblock);
  }

  if(!(s->httpreq == ((struct http_request *)NULL)))
  {
    req = s->httpreq;
    req->stream = (struct spdy_stream *)(void *)0;
    req->flags = req->flags | (unsigned char)0x02;
  }

  kore_mem_free((void *)s);
}

// spdy_stream_get_header
// file includes/kore.h line 562
signed int spdy_stream_get_header(struct spdy_header_block *s, const char *header, char **out)
{
  char *cmp;
  unsigned char *p;
  unsigned char *end;
  unsigned int i;
  unsigned int nlen;
  unsigned int vlen;
  p = s->header_block + (signed long int)4;
  end = s->header_block + (signed long int)s->header_block_len;
  if(p >= end)
    return 0;

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= s->header_pairs); i = i + 1u)
    {
      nlen=net_read32(p);
      if(!(end >= p + (signed long int)nlen + 4l) || !((signed int)nlen >= 0))
        return 0;

      vlen=net_read32(p + (signed long int)nlen + (signed long int)4);
      if(!(end >= p + (signed long int)nlen + (signed long int)vlen + 8l) || !((signed int)vlen >= 0))
        return 0;

      cmp = (char *)(p + (signed long int)4);
      signed int return_value_strncasecmp_2;
      return_value_strncasecmp_2=strncasecmp(cmp, header, (unsigned long int)nlen);
      if(return_value_strncasecmp_2 == 0)
      {
        cmp = (char *)(p + (signed long int)nlen + (signed long int)8);
        void *return_value_kore_malloc_1;
        return_value_kore_malloc_1=kore_malloc((unsigned long int)(vlen + (unsigned int)1));
        *out = (char *)return_value_kore_malloc_1;
        kore_strlcpy(*out, cmp, (unsigned long int)(vlen + (unsigned int)1));
        return 1;
      }

      p = p + (signed long int)(nlen + vlen + (unsigned int)8);
    }
    return 0;
  }
}

// spdy_stream_lookup
// file src/spdy.c line 246
struct spdy_stream * spdy_stream_lookup(struct connection *c, unsigned int id)
{
  struct spdy_stream *s = (&c->spdy_streams)->tqh_first;
  for( ; !(s == ((struct spdy_stream *)NULL)); s = s->list.tqe_next)
    if(s->stream_id == id)
      return s;

  return (struct spdy_stream *)(void *)0;
}

// spdy_update_wsize
// file includes/kore.h line 564
void spdy_update_wsize(struct connection *c, struct spdy_stream *s, unsigned int len)
{
  s->send_size = s->send_size - (unsigned long int)len;
  s->frame_size = s->frame_size - len;
  s->send_wsize = s->send_wsize - len;
  c->spdy_send_wsize = c->spdy_send_wsize - len;
  if(s->frame_size == 0u)
  {
    if(s->send_size >= 1ul)
      s->flags = s->flags | (unsigned char)0x20;

  }

  _Bool tmp_if_expr_1;
  if(s->send_size == 0ul)
  {
    if(!((0x40 & (signed int)s->flags) == 0))
      goto __CPROVER_DUMP_L3;

    if((0x10 & (signed int)s->flags) == 0)
    {
      s->flags = s->flags | (unsigned char)0x10;
      spdy_frame_send(c, (unsigned short int)99, (unsigned char)0x01, (unsigned int)0, s, (unsigned int)0);
    }

    if((17 & (signed int)s->flags) == 0)
      goto __CPROVER_DUMP_L3;

    spdy_stream_close(c, s, 0);
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!((signed int)s->send_wsize >= 1))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)c->spdy_send_wsize <= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      spdy_block_write(c);

  }
}

// spdy_zlib_deflate
// file src/spdy.c line 963
static signed int spdy_zlib_deflate(struct connection *c, unsigned char *src, unsigned long int len, unsigned char **dst, unsigned int *olen)
{
  unsigned long int have;
  signed int r;
  signed int ret;
  unsigned char deflate_buffer[16348l];
  if((signed int)c->deflate_started == 0)
  {
    c->z_deflate.avail_in = (unsigned int)0;
    c->z_deflate.next_in = ((unsigned char *)NULL);
    c->z_deflate.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    c->z_deflate.zfree = ((void (*)(void *, void *))NULL);
    r=deflateInit_(&c->z_deflate, -1, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(r == 0))
      return 0;

    r=deflateSetDictionary(&c->z_deflate, SPDY_dictionary_txt, (unsigned int)1423);
    if(!(r == 0))
    {
      deflateEnd(&c->z_deflate);
      return 0;
    }

    c->deflate_started = (unsigned char)1;
  }

  *olen = (unsigned int)0;
  *dst = (unsigned char *)(void *)0;
  ret = -1;
  c->z_deflate.avail_in = (unsigned int)len;
  c->z_deflate.next_in = src;
  while(ret == -1)
  {
    c->z_deflate.avail_out = (unsigned int)16348;
    c->z_deflate.next_out = deflate_buffer;
    r=deflate(&c->z_deflate, 2);
    if(!(r == -5) && !(r == -4) && !(r == -3))
    {
      if(r == 0)
        goto __CPROVER_DUMP_L6;

    }

    else
    {
      ret = 0;
      continue;

    __CPROVER_DUMP_L6:
      ;
      have = (unsigned long int)((unsigned int)16348 - c->z_deflate.avail_out);
      *olen = *olen + (unsigned int)have;
      void *return_value_kore_realloc_1;
      return_value_kore_realloc_1=kore_realloc((void *)*dst, (unsigned long int)*olen);
      *dst = (unsigned char *)return_value_kore_realloc_1;
      memcpy((void *)(*dst + (signed long int)((unsigned long int)*olen - have)), (const void *)deflate_buffer, have);
      if(c->z_deflate.avail_in == 0u)
      {
        if(!(c->z_deflate.avail_out == 0u))
          ret = 1;

      }

    }
  }
  return ret;
}

// spdy_zlib_inflate
// file src/spdy.c line 893
static signed int spdy_zlib_inflate(struct connection *c, unsigned char *src, unsigned long int len, unsigned char **dst, unsigned int *olen)
{
  unsigned long int have;
  signed int r;
  signed int ret;
  unsigned char inflate_buffer[16348l];
  if((signed int)c->inflate_started == 0)
  {
    c->z_inflate.avail_in = (unsigned int)0;
    c->z_inflate.next_in = ((unsigned char *)NULL);
    c->z_inflate.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    c->z_inflate.zfree = ((void (*)(void *, void *))NULL);
    r=inflateInit_(&c->z_inflate, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(r == 0))
      return 0;

    c->inflate_started = (unsigned char)1;
  }

  *olen = (unsigned int)0;
  *dst = (unsigned char *)(void *)0;
  ret = -1;
  c->z_inflate.avail_in = (unsigned int)len;
  c->z_inflate.next_in = src;
  _Bool tmp_if_expr_2;
  while(ret == -1)
  {
    c->z_inflate.avail_out = (unsigned int)16348;
    c->z_inflate.next_out = inflate_buffer;
    r=inflate(&c->z_inflate, 2);
    if(!(r == 2))
    {
      if(r == -5 || r == -4 || r == -3)
        goto __CPROVER_DUMP_L6;

      if(r == 0)
        goto __CPROVER_DUMP_L7;

      if(r == 1)
        goto __CPROVER_DUMP_L10;

    }

    else
    {
      r=inflateSetDictionary(&c->z_inflate, SPDY_dictionary_txt, (unsigned int)1423);
      if(!(r == 0))
      {
        inflateEnd(&c->z_inflate);
        return 0;
      }

      continue;

    __CPROVER_DUMP_L6:
      ;
      ret = 0;
      continue;

    __CPROVER_DUMP_L7:
      ;
      have = (unsigned long int)((unsigned int)16348 - c->z_inflate.avail_out);
      *olen = *olen + (unsigned int)have;
      void *return_value_kore_realloc_1;
      return_value_kore_realloc_1=kore_realloc((void *)*dst, (unsigned long int)*olen);
      *dst = (unsigned char *)return_value_kore_realloc_1;
      memcpy((void *)(*dst + (signed long int)((unsigned long int)*olen - have)), (const void *)inflate_buffer, have);
      if(!(c->z_inflate.avail_in == 0u))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = c->z_inflate.avail_out == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {

      __CPROVER_DUMP_L10:
        ;
        ret = 1;
      }

    }
  }
  return ret;
}

// task_channel_read
// file src/tasks.c line 264
static void task_channel_read(signed int fd, void *out, unsigned int len)
{
  signed long int r;
  unsigned char *d;
  unsigned int offset;
  d = (unsigned char *)out;
  offset = (unsigned int)0;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!(offset == len))
  {
    r=read(fd, (void *)(d + (signed long int)offset), (unsigned long int)(len - offset));
    if(r == -1l)
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

    }

    if(r == -1l)
    {
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fatal("task_channel_read: %s", return_value_strerror_3);
    }

    if(r == 0l)
      fatal("task_channel_read: unexpected eof");

    offset = offset + (unsigned int)r;
  }
}

// task_channel_write
// file src/tasks.c line 245
static void task_channel_write(signed int fd, void *data, unsigned int len)
{
  signed long int r;
  unsigned char *d;
  unsigned int offset;
  d = (unsigned char *)data;
  offset = (unsigned int)0;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!(offset == len))
  {
    r=write(fd, (const void *)(d + (signed long int)offset), (unsigned long int)(len - offset));
    if(r == -1l)
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

    }

    if(r == -1l)
    {
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fatal("task_channel_write: %s", return_value_strerror_3);
    }

    offset = offset + (unsigned int)r;
  }
}

// task_thread
// file src/tasks.c line 304
static void * task_thread(void *arg)
{
  struct kore_task *t;
  struct kore_task_thread *tt = (struct kore_task_thread *)arg;
  pthread_mutex_lock(&tt->lock);
  pthread_mutex_lock(&task_thread_lock);
  do
  {
    tt->list.tqe_next = (struct kore_task_thread *)(void *)0;
    tt->list.tqe_prev = (&task_threads)->tqh_last;
    *(&task_threads)->tqh_last = tt;
    (&task_threads)->tqh_last = &tt->list.tqe_next;
  }
  while((_Bool)0);
  pthread_mutex_unlock(&task_thread_lock);
  if(tt->tasks.tqh_first == ((struct kore_task *)NULL))
    pthread_cond_wait(&tt->cond, &tt->lock);

  t = (&tt->tasks)->tqh_first;
  do
  {
    if(!(t->list.tqe_next == ((struct kore_task *)NULL)))
      t->list.tqe_next->list.tqe_prev = t->list.tqe_prev;

    else
      (&tt->tasks)->tqh_last = t->list.tqe_prev;
    *t->list.tqe_prev = t->list.tqe_next;
  }
  while((_Bool)0);
  pthread_mutex_unlock(&tt->lock);
  pthread_mutex_lock(&task_thread_lock);
  do
  {
    if(!(tt->list.tqe_next == ((struct kore_task_thread *)NULL)))
      tt->list.tqe_next->list.tqe_prev = tt->list.tqe_prev;

    else
      (&task_threads)->tqh_last = tt->list.tqe_prev;
    *tt->list.tqe_prev = tt->list.tqe_next;
  }
  while((_Bool)0);
  pthread_mutex_unlock(&task_thread_lock);
  kore_task_set_state(t, 2);
  signed int return_value;
  return_value=t->entry(t);
  kore_task_set_result(t, return_value);
  kore_task_finish(t);
  pthread_mutex_lock(&task_thread_lock);
  tt->list.tqe_next = (&task_threads)->tqh_first;
  if(!(tt->list.tqe_next == ((struct kore_task_thread *)NULL)))
    (&task_threads)->tqh_first->list.tqe_prev = &tt->list.tqe_next;

  else
    (&task_threads)->tqh_last = &tt->list.tqe_next;
  (&task_threads)->tqh_first = tt;
  tt->list.tqe_prev = &(&task_threads)->tqh_first;
  pthread_mutex_unlock(&task_thread_lock);
  pthread_mutex_lock(&tt->lock);
  pthread_exit((void *)0);
  return (void *)0;
}

// task_thread_spawn
// file src/tasks.c line 286
static void task_thread_spawn(struct kore_task_thread **out)
{
  struct kore_task_thread *tt;
  void *return_value_kore_malloc_1;
  return_value_kore_malloc_1=kore_malloc(sizeof(struct kore_task_thread) /*136ul*/ );
  tt = (struct kore_task_thread *)return_value_kore_malloc_1;
  unsigned char tmp_post_2 = threads;
  threads = threads + 1;
  tt->idx = tmp_post_2;
  do
  {
    (&tt->tasks)->tqh_first = (struct kore_task *)(void *)0;
    (&tt->tasks)->tqh_last = &(&tt->tasks)->tqh_first;
  }
  while((_Bool)0);
  pthread_cond_init(&tt->cond, (const union anonymous_9 *)(void *)0);
  pthread_mutex_init(&tt->lock, (const union anonymous_9 *)(void *)0);
  signed int return_value_pthread_create_5;
  return_value_pthread_create_5=pthread_create(&tt->tid, (const union pthread_attr_t *)(void *)0, task_thread, (void *)tt);
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(return_value_pthread_create_5 == 0))
  {
    return_value___errno_location_3=__errno_location();
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fatal("pthread_create: %s", return_value_strerror_4);
  }

  *out = tt;
}

// usage
// file src/kore.c line 50
static void usage(void)
{
  fprintf(stderr, "Usage: kore [options | command]\n");
  fprintf(stderr, "\n");
  fprintf(stderr, "Available options:\n");
  fprintf(stderr, "\t-c\tspecify the configuration file to use\n");
  fprintf(stderr, "\t-d\trun with debug on (if compiled in)\n");
  fprintf(stderr, "\t-f\tstart kore in foreground mode\n");
  fprintf(stderr, "\t-h\tthis help text\n");
  fprintf(stderr, "\t-n\tdo not chroot (if not starting kore as root)\n");
  fprintf(stderr, "\t-r\tdo not runas (uid drop) (if not starting kore as root)\n");
  fprintf(stderr, "\t-v\tdisplay kore's version information\n");
  kore_cli_usage(0);
}

// version
// file src/kore.c line 67
static void version(void)
{
  printf("kore %d.%d.%d-%s ", 1, 2, 3, (const void *)"release");
  printf("pgsql ");
  printf("tasks ");
  printf("\n");
  exit(0);
}

// websocket_disconnect
// file src/websocket.c line 327
static void websocket_disconnect(struct connection *c)
{
  struct kore_wscbs *wscbs = (struct kore_wscbs *)c->wscbs;
  if(!(wscbs->disconnect == ((void (*)(struct connection *))NULL)))
    wscbs->disconnect(c);

}

// websocket_recv_frame
// file src/websocket.c line 248
static signed int websocket_recv_frame(struct netbuf *nb)
{
  struct connection *c;
  signed int ret;
  struct kore_wscbs *wscbs;
  unsigned long int len;
  unsigned long int i;
  unsigned long int total;
  unsigned char op;
  unsigned char moff;
  unsigned char extra;
  c = (struct connection *)nb->owner;
  wscbs = (struct kore_wscbs *)c->wscbs;
  op = (unsigned char)((signed int)nb->buf[(signed long int)0] & 0x0f);
  len = (unsigned long int)((signed int)nb->buf[(signed long int)1] & ~(1 << 7));
  unsigned short int return_value_net_read16_1;
  switch(len)
  {
    case (unsigned long int)126:
    {
      moff = (unsigned char)4;
      extra = (unsigned char)sizeof(unsigned short int) /*2ul*/ ;
      return_value_net_read16_1=net_read16(&nb->buf[(signed long int)2]);
      len = (unsigned long int)return_value_net_read16_1;
      break;
    }
    case (unsigned long int)127:
    {
      moff = (unsigned char)10;
      extra = (unsigned char)sizeof(unsigned long int) /*8ul*/ ;
      len=net_read64(&nb->buf[(signed long int)2]);
      break;
    }
    default:
    {
      extra = (unsigned char)0;
      moff = (unsigned char)2;
    }
  }
  if(!(kore_websocket_maxframe >= len))
    return 0;

  else
  {
    extra = extra + (unsigned char)2;
    total = len + (unsigned long int)extra + (unsigned long int)4;
    if(!((unsigned long int)nb->b_len >= total))
    {
      total = total - (unsigned long int)nb->b_len;
      net_recv_expand(c, (unsigned int)total, websocket_recv_frame);
      return 1;
    }

    else
      if(!(total == (unsigned long int)nb->b_len))
        return 0;

      else
      {
        i = (unsigned long int)0;
        for( ; !(i >= len); i = i + 1ul)
          nb->buf[(signed long int)((unsigned long int)((signed int)moff + 4) + i)] = nb->buf[(signed long int)((unsigned long int)((signed int)moff + 4) + i)] ^ nb->buf[(signed long int)((unsigned long int)moff + i % (unsigned long int)4)];
        ret = 1;
        switch((signed int)op)
        {
          case 0x00:

          case 0x10:
          {
            ret = 0;
            kore_log(3, "%p: we do not support op 0x%02x yet", c, op);
            break;
          }
          case 0x01:

          case 0x02:
          {
            if(!(wscbs->message == ((void (*)(struct connection *, unsigned char, void *, unsigned long int))NULL)))
              wscbs->message(c, op, (void *)&nb->buf[(signed long int)((signed int)moff + 4)], len);

            break;
          }
          case 0x08:
          {
            kore_connection_disconnect(c);
            break;
          }
          case 0x09:
          {
            kore_websocket_send(c, (unsigned char)0x10, (void *)&nb->buf[(signed long int)((signed int)moff + 4)], len);
            break;
          }
          default:
            return 0;
        }
        net_recv_reset(c, (unsigned int)2, websocket_recv_opcode);
        return ret;
      }
  }
}

// websocket_recv_opcode
// file src/websocket.c line 194
static signed int websocket_recv_opcode(struct netbuf *nb)
{
  unsigned char op;
  unsigned char len;
  struct connection *c = (struct connection *)nb->owner;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if((128 & (signed int)nb->buf[1l]) == 0)
    return 0;

  else
  {
    if(!((64 & (signed int)*nb->buf) == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ((signed int)nb->buf[(signed long int)0] & 1 << 7 - 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = ((signed int)nb->buf[(signed long int)0] & 1 << 7 - 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
    {
      len = (unsigned char)((signed int)nb->buf[(signed long int)1] & ~(1 << 7));
      op = (unsigned char)((signed int)nb->buf[(signed long int)0] & 0x0f);
      switch((signed int)op)
      {
        case 0x00:

        case 0x01:

        case 0x02:
          break;
        case 0x08:

        case 0x09:

        case 0x10:
        {
          if((signed int)len >= 126)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = !(((signed int)nb->buf[(signed long int)0] & 1 << 7) != 0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            return 0;

          break;
        }
        default:
          return 0;
      }
      switch((signed int)len)
      {
        case 126:
        {
          len = len + (unsigned char)sizeof(unsigned short int) /*2ul*/ ;
          break;
        }
        case 127:
          len = len + (unsigned char)sizeof(unsigned long int) /*8ul*/ ;
      }
      len = len + (unsigned char)4;
      net_recv_expand(c, (unsigned int)len, websocket_recv_frame);
      return 1;
    }
  }
}

// websocket_send_single
// file src/websocket.c line 185
static void websocket_send_single(struct connection *c, void *args)
{
  struct websocket_data *arg = (struct websocket_data *)args;
  kore_websocket_send(c, arg->op, arg->data, arg->len);
  net_send_flush(c);
}

// worker_trylock
// file src/worker.c line 500
static signed int worker_trylock(void)
{
  _Bool return_value___sync_bool_compare_and_swap_1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap_1 = *(&accept_lock->lock) == 0;
  *(&accept_lock->lock) = *(&accept_lock->lock) == 0 ? 1 : *(&accept_lock->lock);
  FENCE(WRfence);
  __CPROVER_atomic_end();
  if(return_value___sync_bool_compare_and_swap_1 == (_Bool)0)
    return 0;

  else
  {
    accept_lock->current = worker->pid;
    return 1;
  }
}

// worker_unlock
// file src/worker.c line 513
static void worker_unlock(void)
{
  accept_lock->current = 0;
  _Bool return_value___sync_bool_compare_and_swap_1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap_1 = *(&accept_lock->lock) == 1;
  *(&accept_lock->lock) = *(&accept_lock->lock) == 1 ? 0 : *(&accept_lock->lock);
  FENCE(WRfence);
  __CPROVER_atomic_end();
  if(return_value___sync_bool_compare_and_swap_1 == (_Bool)0)
    kore_log(5, "worker_unlock(): wasnt locked");

}

