// tag-#anon#ST[ARR6{U8}$U8$'b'|]
// file /usr/include/bluetooth/bluetooth.h line 300
struct anonymous$4;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$0;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR6{U8}$U8$'b'|]#'bdaddr'||U8'pscan_rep_mode'||U8'pscan_period_mode'||U8'pscan_mode'||ARR3{U8}$U8$'dev_class'||U16'clock_offset'|]
// file /usr/include/bluetooth/hci.h line 1748
struct anonymous$2;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$3;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-acc_cal
// file cwiid.h line 199
struct acc_cal;

// tag-balance_cal
// file cwiid.h line 204
struct balance_cal;

// tag-balance_state
// file ../libcwiid/cwiid.h line 301
struct balance_state;

// tag-classic_state
// file ../libcwiid/cwiid.h line 293
struct classic_state;

// tag-cwiid_acc_mesg
// file ../libcwiid/cwiid.h line 223
struct cwiid_acc_mesg;

// tag-cwiid_balance_mesg
// file ../libcwiid/cwiid.h line 255
struct cwiid_balance_mesg;

// tag-cwiid_bdinfo
// file cwiid.h line 343
struct cwiid_bdinfo;

// tag-cwiid_btn_mesg
// file ../libcwiid/cwiid.h line 218
struct cwiid_btn_mesg;

// tag-cwiid_classic_mesg
// file ../libcwiid/cwiid.h line 246
struct cwiid_classic_mesg;

// tag-cwiid_command
// file cwiid.h line 164
enum cwiid_command { CWIID_CMD_STATUS=0, CWIID_CMD_LED=1, CWIID_CMD_RUMBLE=2, CWIID_CMD_RPT_MODE=3 };

// tag-cwiid_error
// file ../libcwiid/cwiid.h line 193
enum cwiid_error { CWIID_ERROR_NONE=0, CWIID_ERROR_DISCONNECT=1, CWIID_ERROR_COMM=2 };

// tag-cwiid_error_mesg
// file ../libcwiid/cwiid.h line 268
struct cwiid_error_mesg;

// tag-cwiid_ext_type
// file ../libcwiid/cwiid.h line 184
enum cwiid_ext_type { CWIID_EXT_NONE=0, CWIID_EXT_NUNCHUK=1, CWIID_EXT_CLASSIC=2, CWIID_EXT_BALANCE=3, CWIID_EXT_MOTIONPLUS=4, CWIID_EXT_UNKNOWN=5 };

// tag-cwiid_ir_mesg
// file ../libcwiid/cwiid.h line 234
struct cwiid_ir_mesg;

// tag-cwiid_ir_src
// file ../libcwiid/cwiid.h line 228
struct cwiid_ir_src;

// tag-cwiid_mesg
// file ../libcwiid/cwiid.h line 273
union cwiid_mesg;

// tag-cwiid_mesg_type
// file ../libcwiid/cwiid.h line 171
enum cwiid_mesg_type { CWIID_MESG_STATUS=0, CWIID_MESG_BTN=1, CWIID_MESG_ACC=2, CWIID_MESG_IR=3, CWIID_MESG_NUNCHUK=4, CWIID_MESG_CLASSIC=5, CWIID_MESG_BALANCE=6, CWIID_MESG_MOTIONPLUS=7, CWIID_MESG_ERROR=8, CWIID_MESG_UNKNOWN=9 };

// tag-cwiid_motionplus_mesg
// file ../libcwiid/cwiid.h line 263
struct cwiid_motionplus_mesg;

// tag-cwiid_nunchuk_mesg
// file ../libcwiid/cwiid.h line 239
struct cwiid_nunchuk_mesg;

// tag-cwiid_state
// file ../libcwiid/cwiid.h line 319
struct cwiid_state;

// tag-cwiid_status_mesg
// file ../libcwiid/cwiid.h line 212
struct cwiid_status_mesg;

// tag-ext_state
// file ../libcwiid/cwiid.h line 312
union ext_state;

// tag-mesg_array
// file cwiid_internal.h line 147
struct mesg_array;

// tag-motionplus_state
// file ../libcwiid/cwiid.h line 308
struct motionplus_state;

// tag-nunchuk_state
// file ../libcwiid/cwiid.h line 287
struct nunchuk_state;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rw_mesg
// file cwiid_internal.h line 161
struct rw_mesg;

// tag-rw_status
// file cwiid_internal.h line 154
enum rw_status { RW_IDLE=0, RW_READ=1, RW_WRITE=2, RW_CANCEL=3 };

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_l2
// file /usr/include/bluetooth/l2cap.h line 41
struct sockaddr_l2;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-wiimote
// file cwiid.h line 333
struct wiimote;

// tag-write_seq
// file cwiid_internal.h line 136
struct write_seq;

// tag-write_seq_type
// file cwiid_internal.h line 131
enum write_seq_type { WRITE_SEQ_RPT=0, WRITE_SEQ_MEM=1 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous$4 *ba1, const struct anonymous$4 *ba2);
// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous$4 *dst, const struct anonymous$4 *src);
// cancel_mesg_callback
// file cwiid_internal.h line 205
signed int cancel_mesg_callback(struct wiimote *wiimote);
// cancel_rw
// file cwiid_internal.h line 204
signed int cancel_rw(struct wiimote *wiimote);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cwiid_beep
// file command.c line 328
signed int cwiid_beep(struct wiimote *wiimote);
// cwiid_callback
// file wmdemo.c line 308
void cwiid_callback(struct wiimote *wiimote, signed int mesg_count, union cwiid_mesg *mesg, struct timespec *timestamp);
// cwiid_close
// file ../libcwiid/cwiid.h line 362
signed int cwiid_close(struct wiimote *wiimote);
// cwiid_command
// file command.c line 52
signed int cwiid_command(struct wiimote *wiimote, enum cwiid_command command, signed int flags);
// cwiid_disable
// file ../libcwiid/cwiid.h line 368
signed int cwiid_disable(struct wiimote *wiimote, signed int flags);
// cwiid_enable
// file ../libcwiid/cwiid.h line 367
signed int cwiid_enable(struct wiimote *wiimote, signed int flags);
// cwiid_err
// file cwiid_internal.h line 197
void cwiid_err(struct wiimote *wiimote, const char *str, ...);
// cwiid_err_default
// file util.c line 74
void cwiid_err_default(struct wiimote *wiimote, const char *str, void **ap);
// cwiid_err_func$object
//
void cwiid_err_func$object(struct wiimote *, const char *, void **);
// cwiid_find_wiimote
// file bluetooth.c line 173
signed int cwiid_find_wiimote(struct anonymous$4 *bdaddr, signed int timeout);
// cwiid_get_acc_cal
// file interface.c line 161
signed int cwiid_get_acc_cal(struct wiimote *wiimote, enum cwiid_ext_type ext_type, struct acc_cal *acc_cal);
// cwiid_get_balance_cal
// file interface.c line 199
signed int cwiid_get_balance_cal(struct wiimote *wiimote, struct balance_cal *balance_cal);
// cwiid_get_bdinfo_array
// file bluetooth.c line 54
signed int cwiid_get_bdinfo_array(signed int dev_id, unsigned int timeout, signed int max_bdinfo, struct cwiid_bdinfo **bdinfo, unsigned char flags);
// cwiid_get_data
// file interface.c line 45
const void * cwiid_get_data(struct wiimote *wiimote);
// cwiid_get_id
// file ../libcwiid/cwiid.h line 364
signed int cwiid_get_id(struct wiimote *wiimote);
// cwiid_get_mesg
// file interface.c line 115
signed int cwiid_get_mesg(struct wiimote *wiimote, signed int *mesg_count, union cwiid_mesg **mesg, struct timespec *timestamp);
// cwiid_get_state
// file ../libcwiid/cwiid.h line 375
signed int cwiid_get_state(struct wiimote *wiimote, struct cwiid_state *state);
// cwiid_open
// file ../libcwiid/cwiid.h line 360
struct wiimote * cwiid_open(struct anonymous$4 *bdaddr, signed int flags);
// cwiid_open_timeout
// file connect.c line 73
struct wiimote * cwiid_open_timeout(struct anonymous$4 *bdaddr, signed int flags, signed int timeout);
// cwiid_read
// file command.c line 157
signed int cwiid_read(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, void *data);
// cwiid_request_status
// file ../libcwiid/cwiid.h line 386
signed int cwiid_request_status(struct wiimote *wiimote);
// cwiid_send_rpt
// file command.c line 79
signed int cwiid_send_rpt(struct wiimote *wiimote, unsigned char flags, unsigned char report, unsigned long int len, const void *data);
// cwiid_set_data
// file interface.c line 39
signed int cwiid_set_data(struct wiimote *wiimote, const void *data);
// cwiid_set_err
// file ../libcwiid/cwiid.h line 354
signed int cwiid_set_err(void (*err)(struct wiimote *, const char *, void **));
// cwiid_set_err::err$object
//
void err$object(struct wiimote *, const char *, void **);
// cwiid_set_led
// file ../libcwiid/cwiid.h line 387
signed int cwiid_set_led(struct wiimote *wiimote, unsigned char led);
// cwiid_set_mesg_callback
// file ../libcwiid/cwiid.h line 371
signed int cwiid_set_mesg_callback(struct wiimote *wiimote, void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *));
// cwiid_set_mesg_callback::callback$object
//
void callback$object(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
// cwiid_set_rpt_mode
// file ../libcwiid/cwiid.h line 389
signed int cwiid_set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode);
// cwiid_set_rumble
// file ../libcwiid/cwiid.h line 388
signed int cwiid_set_rumble(struct wiimote *wiimote, unsigned char rumble);
// cwiid_write
// file command.c line 234
signed int cwiid_write(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, const void *data);
// err
// file wmdemo.c line 47
void err(struct wiimote *wiimote, const char *s, void **ap);
// exec_write_seq
// file cwiid_internal.h line 199
signed int exec_write_seq(struct wiimote *wiimote, unsigned int len, struct write_seq *seq);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// full_read
// file cwiid_internal.h line 201
signed int full_read(signed int fd, void *buf, unsigned long int len);
// getchar
// file /usr/include/stdio.h line 538
extern signed int getchar(void);
// hci_close_dev
// file /usr/include/bluetooth/hci_lib.h line 52
signed int hci_close_dev(signed int);
// hci_get_route
// file /usr/include/bluetooth/hci_lib.h line 146
signed int hci_get_route(struct anonymous$4 *);
// hci_inquiry
// file /usr/include/bluetooth/hci_lib.h line 59
signed int hci_inquiry(signed int, signed int, signed int, const unsigned char *, struct anonymous$2 **, signed long int);
// hci_open_dev
// file /usr/include/bluetooth/hci_lib.h line 51
signed int hci_open_dev(signed int);
// hci_read_remote_name
// file /usr/include/bluetooth/hci_lib.h line 66
signed int hci_read_remote_name(signed int, const struct anonymous$4 *, signed int, char *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mesg_callback_thread
// file cwiid_internal.h line 194
void * mesg_callback_thread(struct wiimote *wiimote);
// mesg_callback_thread::1::callback$object
//
void callback$object(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// print_state
// file wmdemo.c line 210
void print_state(struct cwiid_state *state);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_acc
// file process.c line 92
signed int process_acc(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_btn
// file process.c line 72
signed int process_btn(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_error
// file process.c line 28
signed int process_error(struct wiimote *wiimote, signed long int len, struct mesg_array *ma);
// process_ext
// file process.c line 180
signed int process_ext(struct wiimote *wiimote, unsigned char *data, unsigned char len, struct mesg_array *ma);
// process_ir10
// file process.c line 108
signed int process_ir10(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_ir12
// file process.c line 151
signed int process_ir12(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_read
// file process.c line 259
signed int process_read(struct wiimote *wiimote, unsigned char *data);
// process_status
// file process.c line 48
signed int process_status(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_write
// file process.c line 282
signed int process_write(struct wiimote *wiimote, unsigned char *data);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous$3 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$3 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$3 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_mesg_array
// file cwiid_internal.h line 203
signed int read_mesg_array(signed int fd, struct mesg_array *ma);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// router_thread
// file cwiid_internal.h line 192
void * router_thread(struct wiimote *wiimote);
// set_led_state
// file wmdemo.c line 196
void set_led_state(struct wiimote *wiimote, unsigned char led_state);
// set_rpt_mode
// file wmdemo.c line 203
void set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// status_thread
// file cwiid_internal.h line 193
void * status_thread(struct wiimote *wiimote);
// str2ba
// file /usr/include/bluetooth/bluetooth.h line 327
signed int str2ba(const char *, struct anonymous$4 *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// update_rpt_mode
// file cwiid_internal.h line 222
signed int update_rpt_mode(struct wiimote *wiimote, signed char rpt_mode);
// update_state
// file state.c line 26
signed int update_state(struct wiimote *wiimote, struct mesg_array *ma);
// verify_handshake
// file cwiid_internal.h line 198
signed int verify_handshake(struct wiimote *wiimote);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_mesg_array
// file cwiid_internal.h line 202
signed int write_mesg_array(struct wiimote *wiimote, struct mesg_array *ma);

struct anonymous$4
{
  // b
  unsigned char b[6l];
} __attribute__ ((__packed__));

struct anonymous$0
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$2
{
  // bdaddr
  struct anonymous$4 bdaddr;
  // pscan_rep_mode
  unsigned char pscan_rep_mode;
  // pscan_period_mode
  unsigned char pscan_period_mode;
  // pscan_mode
  unsigned char pscan_mode;
  // dev_class
  unsigned char dev_class[3l];
  // clock_offset
  unsigned short int clock_offset;
} __attribute__ ((__packed__));

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$1
{
  // __data
  struct anonymous$0 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct acc_cal
{
  // zero
  unsigned char zero[3l];
  // one
  unsigned char one[3l];
};

struct balance_cal
{
  // right_top
  unsigned short int right_top[3l];
  // right_bottom
  unsigned short int right_bottom[3l];
  // left_top
  unsigned short int left_top[3l];
  // left_bottom
  unsigned short int left_bottom[3l];
};

struct balance_state
{
  // right_top
  unsigned short int right_top;
  // right_bottom
  unsigned short int right_bottom;
  // left_top
  unsigned short int left_top;
  // left_bottom
  unsigned short int left_bottom;
};

struct classic_state
{
  // l_stick
  unsigned char l_stick[2l];
  // r_stick
  unsigned char r_stick[2l];
  // l
  unsigned char l;
  // r
  unsigned char r;
  // buttons
  unsigned short int buttons;
};

struct cwiid_acc_mesg
{
  // type
  enum cwiid_mesg_type type;
  // acc
  unsigned char acc[3l];
};

struct cwiid_balance_mesg
{
  // type
  enum cwiid_mesg_type type;
  // right_top
  unsigned short int right_top;
  // right_bottom
  unsigned short int right_bottom;
  // left_top
  unsigned short int left_top;
  // left_bottom
  unsigned short int left_bottom;
};

struct cwiid_bdinfo
{
  // bdaddr
  struct anonymous$4 bdaddr;
  // btclass
  unsigned char btclass[3l];
  // name
  char name[32l];
};

struct cwiid_btn_mesg
{
  // type
  enum cwiid_mesg_type type;
  // buttons
  unsigned short int buttons;
};

struct cwiid_classic_mesg
{
  // type
  enum cwiid_mesg_type type;
  // l_stick
  unsigned char l_stick[2l];
  // r_stick
  unsigned char r_stick[2l];
  // l
  unsigned char l;
  // r
  unsigned char r;
  // buttons
  unsigned short int buttons;
};

struct cwiid_error_mesg
{
  // type
  enum cwiid_mesg_type type;
  // error
  enum cwiid_error error;
};

struct cwiid_ir_src
{
  // valid
  char valid;
  // pos
  unsigned short int pos[2l];
  // size
  signed char size;
};

struct cwiid_ir_mesg
{
  // type
  enum cwiid_mesg_type type;
  // src
  struct cwiid_ir_src src[4l];
};

struct cwiid_status_mesg
{
  // type
  enum cwiid_mesg_type type;
  // battery
  unsigned char battery;
  // ext_type
  enum cwiid_ext_type ext_type;
};

struct cwiid_nunchuk_mesg
{
  // type
  enum cwiid_mesg_type type;
  // stick
  unsigned char stick[2l];
  // acc
  unsigned char acc[3l];
  // buttons
  unsigned char buttons;
};

struct cwiid_motionplus_mesg
{
  // type
  enum cwiid_mesg_type type;
  // angle_rate
  unsigned short int angle_rate[3l];
};

union cwiid_mesg
{
  // type
  enum cwiid_mesg_type type;
  // status_mesg
  struct cwiid_status_mesg status_mesg;
  // btn_mesg
  struct cwiid_btn_mesg btn_mesg;
  // acc_mesg
  struct cwiid_acc_mesg acc_mesg;
  // ir_mesg
  struct cwiid_ir_mesg ir_mesg;
  // nunchuk_mesg
  struct cwiid_nunchuk_mesg nunchuk_mesg;
  // classic_mesg
  struct cwiid_classic_mesg classic_mesg;
  // balance_mesg
  struct cwiid_balance_mesg balance_mesg;
  // motionplus_mesg
  struct cwiid_motionplus_mesg motionplus_mesg;
  // error_mesg
  struct cwiid_error_mesg error_mesg;
};

struct nunchuk_state
{
  // stick
  unsigned char stick[2l];
  // acc
  unsigned char acc[3l];
  // buttons
  unsigned char buttons;
};

struct motionplus_state
{
  // angle_rate
  unsigned short int angle_rate[3l];
};

union ext_state
{
  // nunchuk
  struct nunchuk_state nunchuk;
  // classic
  struct classic_state classic;
  // balance
  struct balance_state balance;
  // motionplus
  struct motionplus_state motionplus;
};

struct cwiid_state
{
  // rpt_mode
  unsigned char rpt_mode;
  // led
  unsigned char led;
  // rumble
  unsigned char rumble;
  // battery
  unsigned char battery;
  // buttons
  unsigned short int buttons;
  // acc
  unsigned char acc[3l];
  // ir_src
  struct cwiid_ir_src ir_src[4l];
  // ext_type
  enum cwiid_ext_type ext_type;
  // ext
  union ext_state ext;
  // error
  enum cwiid_error error;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct mesg_array
{
  // count
  unsigned char count;
  // timestamp
  struct timespec timestamp;
  // array
  union cwiid_mesg array[5l];
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rw_mesg
{
  // type
  enum rw_status type;
  // error
  unsigned char error;
  // offset
  unsigned int offset;
  // len
  unsigned char len;
  // data
  char data[16l];
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_l2
{
  // l2_family
  unsigned short int l2_family;
  // l2_psm
  unsigned short int l2_psm;
  // l2_bdaddr
  struct anonymous$4 l2_bdaddr;
  // l2_cid
  unsigned short int l2_cid;
  // l2_bdaddr_type
  unsigned char l2_bdaddr_type;
};

struct wiimote
{
  // flags
  signed int flags;
  // ctl_socket
  signed int ctl_socket;
  // int_socket
  signed int int_socket;
  // router_thread
  unsigned long int router_thread;
  // status_thread
  unsigned long int status_thread;
  // mesg_callback_thread
  unsigned long int mesg_callback_thread;
  // mesg_pipe
  signed int mesg_pipe[2l];
  // status_pipe
  signed int status_pipe[2l];
  // rw_pipe
  signed int rw_pipe[2l];
  // state
  struct cwiid_state state;
  // rw_status
  enum rw_status rw_status;
  // mesg_callback
  void (*mesg_callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
  // state_mutex
  union anonymous$3 state_mutex;
  // rw_mutex
  union anonymous$3 rw_mutex;
  // rpt_mutex
  union anonymous$3 rpt_mutex;
  // id
  signed int id;
  // data
  const void *data;
};

struct write_seq
{
  // type
  enum write_seq_type type;
  // report_offset
  unsigned int report_offset;
  // data
  const void *data;
  // len
  unsigned short int len;
  // flags
  unsigned char flags;
};


// cwiid_err_func
// file util.c line 63
static void (*cwiid_err_func)(struct wiimote *, const char *, void **);
// cwiid_err_func
// file util.c line 63
static void (*cwiid_err_func)(struct wiimote *, const char *, void **) = cwiid_err_default;
// global_mutex
// file connect.c line 64
union anonymous$3 global_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ir_block1
// file state.c line 108
unsigned char ir_block1[10l] = { 2, 0, 0, 'q', 1, 0, 170, 0, 'd', 0 };
// ir_block2
// file state.c line 109
unsigned char ir_block2[3l] = { 'c', 3, 0 };
// ir_disable_seq
// file state.c line 129
struct write_seq ir_disable_seq[2l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// ir_enable10_seq
// file state.c line 111
struct write_seq ir_enable10_seq[6l];
// ir_enable10_seq
// file state.c line 111
struct write_seq ir_enable10_seq[6l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00030, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00000, .data=(const void *)ir_block1,
    .len=(unsigned short int)(sizeof(unsigned char [10l]) /*10ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB0001A, .data=(const void *)ir_block2,
    .len=(unsigned short int)(sizeof(unsigned char [3l]) /*3ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00033, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 } };
// ir_enable12_seq
// file state.c line 120
struct write_seq ir_enable12_seq[6l];
// ir_enable12_seq
// file state.c line 120
struct write_seq ir_enable12_seq[6l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00030, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00000, .data=(const void *)ir_block1,
    .len=(unsigned short int)(sizeof(unsigned char [10l]) /*10ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB0001A, .data=(const void *)ir_block2,
    .len=(unsigned short int)(sizeof(unsigned char [3l]) /*3ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00033, .data=(const void *)"\003",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 } };
// speaker_disable_seq
// file command.c line 322
struct write_seq speaker_disable_seq[2l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x14, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// speaker_enable_seq
// file command.c line 311
struct write_seq speaker_enable_seq[7l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x14, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20009, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20001, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20001, .data=(const void *)"\0\0\0\f@\0\0",
    .len=(unsigned short int)7,
    .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20008, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// wiimote_id
// file connect.c line 65
static signed int wiimote_id = 0;

// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous$4 *ba1, const struct anonymous$4 *ba2)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)ba1, (const void *)ba2, sizeof(struct anonymous$4) /*6ul*/ );
  return return_value_memcmp$1;
}

// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous$4 *dst, const struct anonymous$4 *src)
{
  memcpy((void *)dst, (const void *)src, sizeof(struct anonymous$4) /*6ul*/ );
}

// cancel_mesg_callback
// file cwiid_internal.h line 205
signed int cancel_mesg_callback(struct wiimote *wiimote)
{
  signed int ret = 0;
  signed int return_value_pthread_cancel$1;
  return_value_pthread_cancel$1=pthread_cancel(wiimote->mesg_callback_thread);
  if(!(return_value_pthread_cancel$1 == 0))
  {
    cwiid_err(wiimote, "Thread cancel error (callback thread)");
    ret = -1;
  }

  signed int return_value_pthread_detach$2;
  return_value_pthread_detach$2=pthread_detach(wiimote->mesg_callback_thread);
  if(!(return_value_pthread_detach$2 == 0))
  {
    cwiid_err(wiimote, "Thread detach error (callback thread)");
    ret = -1;
  }

  return ret;
}

// cancel_rw
// file cwiid_internal.h line 204
signed int cancel_rw(struct wiimote *wiimote)
{
  struct rw_mesg rw_mesg;
  rw_mesg.type = (enum rw_status)RW_CANCEL;
  signed long int return_value_write$1;
  return_value_write$1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
  if(!((unsigned long int)return_value_write$1 == sizeof(struct rw_mesg) /*32ul*/ ))
  {
    cwiid_err(wiimote, "Pipe write error (rw)");
    return -1;
  }

  else
    return 0;
}

// cwiid_beep
// file command.c line 328
signed int cwiid_beep(struct wiimote *wiimote)
{
  unsigned char buf[21l] = { (unsigned char)0xA0, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3 };
  signed int i;
  signed int ret = 0;
  union anonymous$3 timer_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  union anonymous$1 timer_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
  struct timespec t;
  signed int return_value_exec_write_seq$1;
  return_value_exec_write_seq$1=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [7l]) /*168ul*/  / sizeof(struct write_seq) /*24ul*/ ), speaker_enable_seq);
  if(!(return_value_exec_write_seq$1 == 0))
  {
    cwiid_err(wiimote, "Speaker enable error");
    ret = -1;
  }

  pthread_mutex_lock(&timer_mutex);
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    clock_gettime(0, &t);
    t.tv_nsec = t.tv_nsec + (signed long int)10204081;
    signed int return_value_cwiid_send_rpt$2;
    return_value_cwiid_send_rpt$2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x18, (unsigned long int)21, (const void *)buf);
    if(!(return_value_cwiid_send_rpt$2 == 0))
    {
      printf("%d\n", i);
      cwiid_err(wiimote, "Report send error (speaker data)");
      ret = -1;
      break;
    }

    pthread_cond_timedwait(&timer_cond, &timer_mutex, &t);
  }
  pthread_mutex_unlock(&timer_mutex);
  signed int return_value_exec_write_seq$3;
  return_value_exec_write_seq$3=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [2l]) /*48ul*/  / sizeof(struct write_seq) /*24ul*/ ), speaker_disable_seq);
  if(!(return_value_exec_write_seq$3 == 0))
  {
    cwiid_err(wiimote, "Speaker disable error");
    ret = -1;
  }

  return ret;
}

// cwiid_callback
// file wmdemo.c line 308
void cwiid_callback(struct wiimote *wiimote, signed int mesg_count, union cwiid_mesg *mesg, struct timespec *timestamp)
{
  signed int i;
  signed int j;
  signed int valid_source;
  i = 0;
  signed int return_value_cwiid_close$1;
  for( ; !(i >= mesg_count); i = i + 1)
    switch((signed int)(mesg + (signed long int)i)->type)
    {
      case CWIID_MESG_STATUS:
      {
        printf("Status Report: battery=%d extension=", (mesg + (signed long int)i)->status_mesg.battery);
        switch((signed int)(mesg + (signed long int)i)->status_mesg.ext_type)
        {
          case CWIID_EXT_NONE:
          {
            printf("none");
            break;
          }
          case CWIID_EXT_NUNCHUK:
          {
            printf("Nunchuk");
            break;
          }
          case CWIID_EXT_CLASSIC:
          {
            printf("Classic Controller");
            break;
          }
          case CWIID_EXT_BALANCE:
          {
            printf("Balance Board");
            break;
          }
          case CWIID_EXT_MOTIONPLUS:
          {
            printf("MotionPlus");
            break;
          }
          default:
            printf("Unknown Extension");
        }
        printf("\n");
        break;
      }
      case CWIID_MESG_BTN:
      {
        printf("Button Report: %.4X\n", (mesg + (signed long int)i)->btn_mesg.buttons);
        break;
      }
      case CWIID_MESG_ACC:
      {
        printf("Acc Report: x=%d, y=%d, z=%d\n", (mesg + (signed long int)i)->acc_mesg.acc[(signed long int)0], (mesg + (signed long int)i)->acc_mesg.acc[(signed long int)1], (mesg + (signed long int)i)->acc_mesg.acc[(signed long int)2]);
        break;
      }
      case CWIID_MESG_IR:
      {
        printf("IR Report: ");
        valid_source = 0;
        j = 0;
        for( ; !(j >= 4); j = j + 1)
          if(!((mesg + (signed long int)i)->ir_mesg.src[(signed long int)j].valid == 0))
          {
            valid_source = 1;
            printf("(%d,%d) ", (mesg + (signed long int)i)->ir_mesg.src[(signed long int)j].pos[(signed long int)0], (mesg + (signed long int)i)->ir_mesg.src[(signed long int)j].pos[(signed long int)1]);
          }

        if(valid_source == 0)
          printf("no sources detected");

        printf("\n");
        break;
      }
      case CWIID_MESG_NUNCHUK:
      {
        printf("Nunchuk Report: btns=%.2X stick=(%d,%d) acc.x=%d acc.y=%d acc.z=%d\n", (mesg + (signed long int)i)->nunchuk_mesg.buttons, (mesg + (signed long int)i)->nunchuk_mesg.stick[(signed long int)0], (mesg + (signed long int)i)->nunchuk_mesg.stick[(signed long int)1], (mesg + (signed long int)i)->nunchuk_mesg.acc[(signed long int)0], (mesg + (signed long int)i)->nunchuk_mesg.acc[(signed long int)1], (mesg + (signed long int)i)->nunchuk_mesg.acc[(signed long int)2]);
        break;
      }
      case CWIID_MESG_CLASSIC:
      {
        printf("Classic Report: btns=%.4X l_stick=(%d,%d) r_stick=(%d,%d) l=%d r=%d\n", (mesg + (signed long int)i)->classic_mesg.buttons, (mesg + (signed long int)i)->classic_mesg.l_stick[(signed long int)0], (mesg + (signed long int)i)->classic_mesg.l_stick[(signed long int)1], (mesg + (signed long int)i)->classic_mesg.r_stick[(signed long int)0], (mesg + (signed long int)i)->classic_mesg.r_stick[(signed long int)1], (mesg + (signed long int)i)->classic_mesg.l, (mesg + (signed long int)i)->classic_mesg.r);
        break;
      }
      case CWIID_MESG_BALANCE:
      {
        printf("Balance Report: right_top=%d right_bottom=%d left_top=%d left_bottom=%d\n", (mesg + (signed long int)i)->balance_mesg.right_top, (mesg + (signed long int)i)->balance_mesg.right_bottom, (mesg + (signed long int)i)->balance_mesg.left_top, (mesg + (signed long int)i)->balance_mesg.left_bottom);
        break;
      }
      case CWIID_MESG_MOTIONPLUS:
      {
        printf("MotionPlus Report: angle_rate=(%d,%d,%d)\n", (mesg + (signed long int)i)->motionplus_mesg.angle_rate[(signed long int)0], (mesg + (signed long int)i)->motionplus_mesg.angle_rate[(signed long int)1], (mesg + (signed long int)i)->motionplus_mesg.angle_rate[(signed long int)2]);
        break;
      }
      case CWIID_MESG_ERROR:
      {
        return_value_cwiid_close$1=cwiid_close(wiimote);
        if(!(return_value_cwiid_close$1 == 0))
        {
          fprintf(stderr, "Error on wiimote disconnect\n");
          exit(-1);
        }

        exit(0);
        break;
      }
      default:
        printf("Unknown Report");
    }
}

// cwiid_close
// file ../libcwiid/cwiid.h line 362
signed int cwiid_close(struct wiimote *wiimote)
{
  void *pthread_ret;
  signed int return_value_pthread_cancel$1;
  return_value_pthread_cancel$1=pthread_cancel(wiimote->router_thread);
  signed int return_value_pthread_join$2;
  return_value_pthread_join$2=pthread_join(wiimote->router_thread, &pthread_ret);
  if(!(return_value_pthread_join$2 == 0))
    cwiid_err(wiimote, "Thread join error (router thread)");

  else
    if(!(pthread_ret == NULL) && !(pthread_ret == (void *)-1))
      cwiid_err(wiimote, "Bad return value from router thread");

  signed int return_value_pthread_cancel$3;
  return_value_pthread_cancel$3=pthread_cancel(wiimote->status_thread);
  signed int return_value_pthread_join$4;
  return_value_pthread_join$4=pthread_join(wiimote->status_thread, &pthread_ret);
  if(!(return_value_pthread_join$4 == 0))
    cwiid_err(wiimote, "Thread join error (status thread)");

  else
    if(!(pthread_ret == NULL) && !(pthread_ret == (void *)-1))
      cwiid_err(wiimote, "Bad return value from status thread");

  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_cancel_mesg_callback$5;
    return_value_cancel_mesg_callback$5=cancel_mesg_callback(wiimote);
  }

  signed int return_value_cancel_rw$6;
  return_value_cancel_rw$6=cancel_rw(wiimote);
  signed int return_value_close$7;
  return_value_close$7=close(wiimote->int_socket);
  if(!(return_value_close$7 == 0))
    cwiid_err(wiimote, "Socket close error (interrupt channel)");

  signed int return_value_close$8;
  return_value_close$8=close(wiimote->ctl_socket);
  if(!(return_value_close$8 == 0))
    cwiid_err(wiimote, "Socket close error (control channel)");

  signed int return_value_close$9;
  return_value_close$9=close(wiimote->mesg_pipe[(signed long int)0]);
  _Bool tmp_if_expr$11;
  signed int return_value_close$10;
  if(!(return_value_close$9 == 0))
    tmp_if_expr$11 = (_Bool)1;

  else
  {
    return_value_close$10=close(wiimote->mesg_pipe[(signed long int)1]);
    tmp_if_expr$11 = return_value_close$10 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$11)
    cwiid_err(wiimote, "Pipe close error (mesg pipe)");

  signed int return_value_close$12;
  return_value_close$12=close(wiimote->status_pipe[(signed long int)0]);
  _Bool tmp_if_expr$14;
  signed int return_value_close$13;
  if(!(return_value_close$12 == 0))
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_close$13=close(wiimote->status_pipe[(signed long int)1]);
    tmp_if_expr$14 = return_value_close$13 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$14)
    cwiid_err(wiimote, "Pipe close error (status pipe)");

  signed int return_value_close$15;
  return_value_close$15=close(wiimote->rw_pipe[(signed long int)0]);
  _Bool tmp_if_expr$17;
  signed int return_value_close$16;
  if(!(return_value_close$15 == 0))
    tmp_if_expr$17 = (_Bool)1;

  else
  {
    return_value_close$16=close(wiimote->rw_pipe[(signed long int)1]);
    tmp_if_expr$17 = return_value_close$16 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$17)
    cwiid_err(wiimote, "Pipe close error (rw pipe)");

  signed int return_value_pthread_mutex_destroy$18;
  return_value_pthread_mutex_destroy$18=pthread_mutex_destroy(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_destroy$18 == 0))
    cwiid_err(wiimote, "Mutex destroy error (state)");

  signed int return_value_pthread_mutex_destroy$19;
  return_value_pthread_mutex_destroy$19=pthread_mutex_destroy(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_destroy$19 == 0))
    cwiid_err(wiimote, "Mutex destroy error (rw)");

  signed int return_value_pthread_mutex_destroy$20;
  return_value_pthread_mutex_destroy$20=pthread_mutex_destroy(&wiimote->rpt_mutex);
  if(!(return_value_pthread_mutex_destroy$20 == 0))
    cwiid_err(wiimote, "Mutex destroy error (rpt)");

  free((void *)wiimote);
  return 0;
}

// cwiid_command
// file command.c line 52
signed int cwiid_command(struct wiimote *wiimote, enum cwiid_command command, signed int flags)
{
  signed int ret;
  switch((signed int)command)
  {
    case CWIID_CMD_STATUS:
    {
      ret=cwiid_request_status(wiimote);
      break;
    }
    case CWIID_CMD_LED:
    {
      ret=cwiid_set_led(wiimote, (unsigned char)flags);
      break;
    }
    case CWIID_CMD_RUMBLE:
    {
      ret=cwiid_set_rumble(wiimote, (unsigned char)flags);
      break;
    }
    case CWIID_CMD_RPT_MODE:
    {
      ret=cwiid_set_rpt_mode(wiimote, (unsigned char)flags);
      break;
    }
    default:
      ret = -1;
  }
  return ret;
}

// cwiid_disable
// file ../libcwiid/cwiid.h line 368
signed int cwiid_disable(struct wiimote *wiimote, signed int flags)
{
  unsigned char data;
  if(!((0x08 & flags) == 0))
  {
    if(!((0x08 & wiimote->flags) == 0))
    {
      signed int return_value_fcntl$1;
      return_value_fcntl$1=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 0);
      if(!(return_value_fcntl$1 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        return -1;
      }

    }

  }

  if(!((0x10 & flags) == 0))
  {
    data = (unsigned char)0x55;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400F0, (unsigned short int)1, (const void *)&data);
    data = (unsigned char)0x00;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400FB, (unsigned short int)1, (const void *)&data);
    cwiid_request_status(wiimote);
  }

  wiimote->flags = wiimote->flags & ~flags;
  return 0;
}

// cwiid_enable
// file ../libcwiid/cwiid.h line 367
signed int cwiid_enable(struct wiimote *wiimote, signed int flags)
{
  unsigned char data;
  if(!((0x08 & flags) == 0))
  {
    if((0x08 & wiimote->flags) == 0)
    {
      signed int return_value_fcntl$1;
      return_value_fcntl$1=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 04000);
      if(!(return_value_fcntl$1 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        return -1;
      }

    }

  }

  if(!((0x10 & flags) == 0))
  {
    data = (unsigned char)0x04;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA600FE, (unsigned short int)1, (const void *)&data);
    cwiid_request_status(wiimote);
  }

  wiimote->flags = wiimote->flags | flags;
  return 0;
}

// cwiid_err
// file cwiid_internal.h line 197
void cwiid_err(struct wiimote *wiimote, const char *str, ...)
{
  void **ap;
  if(!(cwiid_err_func == ((void (*)(struct wiimote *, const char *, void **))NULL)))
  {
    ap = (void **)&str;
    cwiid_err_func(wiimote, str, ap);
    ap = ((void **)NULL);
  }

}

// cwiid_err_default
// file util.c line 74
void cwiid_err_default(struct wiimote *wiimote, const char *str, void **ap)
{
  vfprintf(stderr, str, ap);
  fprintf(stderr, "\n");
}

// cwiid_find_wiimote
// file bluetooth.c line 173
signed int cwiid_find_wiimote(struct anonymous$4 *bdaddr, signed int timeout)
{
  struct cwiid_bdinfo *bdinfo;
  signed int bdinfo_count;
  if(timeout == -1)
  {
    do
    {
      bdinfo_count=cwiid_get_bdinfo_array(-1, (unsigned int)2, 1, &bdinfo, (unsigned char)0);
      if(!(bdinfo_count == 0))
        break;

    }
    while((_Bool)1);
    if(bdinfo_count == -1)
      return -1;

  }

  else
  {
    bdinfo_count=cwiid_get_bdinfo_array(-1, (unsigned int)timeout, 1, &bdinfo, (unsigned char)0);
    if(bdinfo_count == -1)
      return -1;

    else
      if(bdinfo_count == 0)
      {
        cwiid_err((struct wiimote *)(void *)0, "No wiimotes found");
        return -1;
      }

  }
  bacpy(bdaddr, &(bdinfo + (signed long int)0)->bdaddr);
  free((void *)bdinfo);
  return 0;
}

// cwiid_get_acc_cal
// file interface.c line 161
signed int cwiid_get_acc_cal(struct wiimote *wiimote, enum cwiid_ext_type ext_type, struct acc_cal *acc_cal)
{
  unsigned char flags;
  unsigned int offset;
  unsigned char buf[7l];
  char *err_str;
  switch((signed int)ext_type)
  {
    case CWIID_EXT_NONE:
    {
      flags = (unsigned char)0x00;
      offset = (unsigned int)0x16;
      err_str = "";
      break;
    }
    case CWIID_EXT_NUNCHUK:
    {
      flags = (unsigned char)0x04;
      offset = (unsigned int)0xA40020;
      err_str = "nunchuk ";
      break;
    }
    default:
    {
      cwiid_err(wiimote, "Unsupported calibration request");
      return -1;
    }
  }
  signed int return_value_cwiid_read$1;
  return_value_cwiid_read$1=cwiid_read(wiimote, flags, offset, (unsigned short int)7, (void *)buf);
  if(!(return_value_cwiid_read$1 == 0))
  {
    cwiid_err(wiimote, "Read error (%scal)", err_str);
    return -1;
  }

  else
  {
    acc_cal->zero[(signed long int)0] = buf[(signed long int)0];
    acc_cal->zero[(signed long int)1] = buf[(signed long int)1];
    acc_cal->zero[(signed long int)2] = buf[(signed long int)2];
    acc_cal->one[(signed long int)0] = buf[(signed long int)4];
    acc_cal->one[(signed long int)1] = buf[(signed long int)5];
    acc_cal->one[(signed long int)2] = buf[(signed long int)6];
    return 0;
  }
}

// cwiid_get_balance_cal
// file interface.c line 199
signed int cwiid_get_balance_cal(struct wiimote *wiimote, struct balance_cal *balance_cal)
{
  unsigned char buf[24l];
  signed int return_value_cwiid_read$1;
  return_value_cwiid_read$1=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xa40024, (unsigned short int)24, (void *)buf);
  if(!(return_value_cwiid_read$1 == 0))
  {
    cwiid_err(wiimote, "Read error (balancecal)");
    return -1;
  }

  else
  {
    balance_cal->right_top[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)0] << 8 | (signed int)(unsigned short int)buf[(signed long int)1]);
    balance_cal->right_bottom[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)2] << 8 | (signed int)(unsigned short int)buf[(signed long int)3]);
    balance_cal->left_top[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)4] << 8 | (signed int)(unsigned short int)buf[(signed long int)5]);
    balance_cal->left_bottom[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)6] << 8 | (signed int)(unsigned short int)buf[(signed long int)7]);
    balance_cal->right_top[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)8] << 8 | (signed int)(unsigned short int)buf[(signed long int)9]);
    balance_cal->right_bottom[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)10] << 8 | (signed int)(unsigned short int)buf[(signed long int)11]);
    balance_cal->left_top[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)12] << 8 | (signed int)(unsigned short int)buf[(signed long int)13]);
    balance_cal->left_bottom[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)14] << 8 | (signed int)(unsigned short int)buf[(signed long int)15]);
    balance_cal->right_top[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)16] << 8 | (signed int)(unsigned short int)buf[(signed long int)17]);
    balance_cal->right_bottom[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)18] << 8 | (signed int)(unsigned short int)buf[(signed long int)19]);
    balance_cal->left_top[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)20] << 8 | (signed int)(unsigned short int)buf[(signed long int)21]);
    balance_cal->left_bottom[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)22] << 8 | (signed int)(unsigned short int)buf[(signed long int)23]);
    return 0;
  }
}

// cwiid_get_bdinfo_array
// file bluetooth.c line 54
signed int cwiid_get_bdinfo_array(signed int dev_id, unsigned int timeout, signed int max_bdinfo, struct cwiid_bdinfo **bdinfo, unsigned char flags)
{
  struct anonymous$2 *dev_list = (struct anonymous$2 *)(void *)0;
  signed int max_inquiry;
  signed int dev_count;
  signed int sock = -1;
  signed int bdinfo_count;
  signed int i;
  signed int j;
  signed int cwiid_get_bdinfo_array$$1$$err = 0;
  signed int ret;
  *bdinfo = (struct cwiid_bdinfo *)(void *)0;
  void *return_value_malloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  signed int return_value_strncmp$6;
  signed int return_value_strncmp$5;
  if(dev_id == -1)
  {
    dev_id=hci_get_route((struct anonymous$4 *)(void *)0);
    if(!(dev_id == -1))
      goto __CPROVER_DUMP_L1;

    cwiid_err((struct wiimote *)(void *)0, "No Bluetooth interface found");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!((0x01 & (signed int)flags) == 0) && !(max_bdinfo == -1))
      max_inquiry = max_bdinfo;

    else
      max_inquiry = 256;
    dev_count=hci_inquiry(dev_id, (signed int)timeout, max_inquiry, (const unsigned char *)(void *)0, &dev_list, (signed long int)0x0001);
    if(dev_count == -1)
    {
      cwiid_err((struct wiimote *)(void *)0, "Bluetooth device inquiry error");
      cwiid_get_bdinfo_array$$1$$err = 1;
    }

    else
      if(dev_count == 0)
        bdinfo_count = 0;

      else
      {
        sock=hci_open_dev(dev_id);
        if(sock == -1)
        {
          cwiid_err((struct wiimote *)(void *)0, "Bluetooth interface open error");
          cwiid_get_bdinfo_array$$1$$err = 1;
        }

        else
        {
          if(max_bdinfo == -1)
            max_bdinfo = dev_count;

          return_value_malloc$1=malloc((unsigned long int)max_bdinfo * sizeof(struct cwiid_bdinfo) /*41ul*/ );
          *bdinfo = (struct cwiid_bdinfo *)return_value_malloc$1;
          if(*bdinfo == ((struct cwiid_bdinfo *)NULL))
          {
            cwiid_err((struct wiimote *)(void *)0, "Memory allocation error (bdinfo array)");
            cwiid_get_bdinfo_array$$1$$err = 1;
          }

          else
          {
            i = 0;
            bdinfo_count = i;
            for( ; !(bdinfo_count >= max_bdinfo) && !(i >= dev_count); i = i + 1)
            {
              if((0x01 & (signed int)flags) == 0)
              {
                if(!((signed int)(dev_list + (signed long int)i)->dev_class[0l] == 0x04))
                  tmp_if_expr$2 = (_Bool)1;

                else
                  tmp_if_expr$2 = (signed int)(dev_list + (signed long int)i)->dev_class[(signed long int)1] != 0x25 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$2)
                  tmp_if_expr$3 = (_Bool)1;

                else
                  tmp_if_expr$3 = (signed int)(dev_list + (signed long int)i)->dev_class[(signed long int)2] != 0x00 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$3)
                  goto __CPROVER_DUMP_L19;

              }

              signed int return_value_hci_read_remote_name$4;
              return_value_hci_read_remote_name$4=hci_read_remote_name(sock, &(dev_list + (signed long int)i)->bdaddr, 32, (*bdinfo + (signed long int)bdinfo_count)->name, 10000);
              if(!(return_value_hci_read_remote_name$4 == 0))
              {
                cwiid_err((struct wiimote *)(void *)0, "Bluetooth name read error");
                cwiid_get_bdinfo_array$$1$$err = 1;
                goto CODA;
              }

              if((0x01 & (signed int)flags) == 0)
              {
                return_value_strncmp$6=strncmp((*bdinfo + (signed long int)bdinfo_count)->name, "Nintendo RVL-CNT-01", (unsigned long int)32);
                if(return_value_strncmp$6 == 0)
                  goto __CPROVER_DUMP_L16;

                return_value_strncmp$5=strncmp((*bdinfo + (signed long int)bdinfo_count)->name, "Nintendo RVL-WBC-01", (unsigned long int)32);
                if(return_value_strncmp$5 == 0)
                  goto __CPROVER_DUMP_L16;

              }

              else
              {

              __CPROVER_DUMP_L16:
                ;
                bacpy(&(*bdinfo + (signed long int)bdinfo_count)->bdaddr, &(dev_list + (signed long int)i)->bdaddr);
                j = 0;
                for( ; !(j >= 3); j = j + 1)
                  (*bdinfo + (signed long int)bdinfo_count)->btclass[(signed long int)j] = (dev_list + (signed long int)i)->dev_class[(signed long int)j];
                bdinfo_count = bdinfo_count + 1;
              }

            __CPROVER_DUMP_L19:
              ;
            }
            if(bdinfo_count == 0)
              free((void *)*bdinfo);

            else
              if(!(bdinfo_count >= max_bdinfo))
              {
                void *return_value_realloc$7;
                return_value_realloc$7=realloc((void *)*bdinfo, (unsigned long int)bdinfo_count * sizeof(struct cwiid_bdinfo) /*41ul*/ );
                *bdinfo = (struct cwiid_bdinfo *)return_value_realloc$7;
                if(*bdinfo == ((struct cwiid_bdinfo *)NULL))
                {
                  cwiid_err((struct wiimote *)(void *)0, "Memory reallocation error (bdinfo array)");
                  cwiid_get_bdinfo_array$$1$$err = 1;
                }

              }

          }
        }
      }

  CODA:
    ;
    if(!(dev_list == ((struct anonymous$2 *)NULL)))
      free((void *)dev_list);

    if(!(sock == -1))
      hci_close_dev(sock);

    if(!(cwiid_get_bdinfo_array$$1$$err == 0))
    {
      if(!(*bdinfo == ((struct cwiid_bdinfo *)NULL)))
        free((void *)*bdinfo);

      ret = -1;
    }

    else
      ret = bdinfo_count;
    return ret;
  }
}

// cwiid_get_data
// file interface.c line 45
const void * cwiid_get_data(struct wiimote *wiimote)
{
  return wiimote->data;
}

// cwiid_get_id
// file ../libcwiid/cwiid.h line 364
signed int cwiid_get_id(struct wiimote *wiimote)
{
  return wiimote->id;
}

// cwiid_get_mesg
// file interface.c line 115
signed int cwiid_get_mesg(struct wiimote *wiimote, signed int *mesg_count, union cwiid_mesg **mesg, struct timespec *timestamp)
{
  struct mesg_array ma;
  signed int return_value_read_mesg_array$2;
  return_value_read_mesg_array$2=read_mesg_array(wiimote->mesg_pipe[(signed long int)0], &ma);
  if(!(return_value_read_mesg_array$2 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 11)
      return -1;

    else
    {
      cwiid_err(wiimote, "Pipe read error (mesg_pipe)");
      return -1;
    }
  }

  *mesg_count = (signed int)ma.count;
  *timestamp = ma.timestamp;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)ma.count * sizeof(union cwiid_mesg) /*36ul*/ );
  *mesg = (union cwiid_mesg *)return_value_malloc$3;
  if(*mesg == ((union cwiid_mesg *)NULL))
  {
    cwiid_err(wiimote, "Memory allocation error (mesg array)");
    return -1;
  }

  else
  {
    memcpy((void *)*mesg, (const void *)&ma.array, (unsigned long int)ma.count * sizeof(union cwiid_mesg) /*36ul*/ );
    return 0;
  }
}

// cwiid_get_state
// file ../libcwiid/cwiid.h line 375
signed int cwiid_get_state(struct wiimote *wiimote, struct cwiid_state *state)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (state mutex)");
    return -1;
  }

  else
  {
    memcpy((void *)state, (const void *)&wiimote->state, sizeof(struct cwiid_state) /*60ul*/ );
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&wiimote->state_mutex);
    if(!(return_value_pthread_mutex_unlock$2 == 0))
    {
      cwiid_err(wiimote, "Mutex unlock error (state mutex) - deadlock warning");
      return -1;
    }

    else
      return 0;
  }
}

// cwiid_open
// file ../libcwiid/cwiid.h line 360
struct wiimote * cwiid_open(struct anonymous$4 *bdaddr, signed int flags)
{
  struct wiimote *return_value_cwiid_open_timeout$1;
  return_value_cwiid_open_timeout$1=cwiid_open_timeout(bdaddr, flags, 5);
  return return_value_cwiid_open_timeout$1;
}

// cwiid_open_timeout
// file connect.c line 73
struct wiimote * cwiid_open_timeout(struct anonymous$4 *bdaddr, signed int flags, signed int timeout)
{
  struct wiimote *wiimote = (struct wiimote *)(void *)0;
  struct sockaddr_l2 remote_addr;
  char mesg_pipe_init = (char)0;
  char status_pipe_init = (char)0;
  char rw_pipe_init = (char)0;
  char state_mutex_init = (char)0;
  char rw_mutex_init = (char)0;
  char rpt_mutex_init = (char)0;
  char router_thread_init = (char)0;
  char status_thread_init = (char)0;
  void *pthread_ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct wiimote) /*272ul*/ );
  wiimote = (struct wiimote *)return_value_malloc$1;
  signed int return_value_pthread_mutex_lock$2;
  signed int tmp_post$3;
  signed int return_value_pthread_mutex_unlock$4;
  struct anonymous$4 literal$6;
  signed int return_value_bacmp$7;
  signed int return_value_connect$8;
  signed int return_value_connect$9;
  signed int return_value_pipe$10;
  signed int return_value_pipe$11;
  signed int return_value_pipe$12;
  signed int return_value_fcntl$13;
  signed int return_value_pthread_mutex_init$15;
  signed int return_value_pthread_mutex_init$16;
  signed int return_value_pthread_mutex_init$17;
  signed int return_value_pthread_create$18;
  signed int return_value_pthread_create$19;
  if(wiimote == ((struct wiimote *)NULL))
    cwiid_err((struct wiimote *)(void *)0, "Memory allocation error (cwiid_wiimote_t)");

  else
  {
    wiimote->flags = flags;
    wiimote->int_socket = -1;
    wiimote->ctl_socket = wiimote->int_socket;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&global_mutex);
    if(!(return_value_pthread_mutex_lock$2 == 0))
      cwiid_err((struct wiimote *)(void *)0, "Mutex lock error (global mutex)");

    else
    {
      tmp_post$3 = wiimote_id;
      wiimote_id = wiimote_id + 1;
      wiimote->id = tmp_post$3;
      return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&global_mutex);
      if(!(return_value_pthread_mutex_unlock$4 == 0))
        cwiid_err(wiimote, "Mutex unlock error (global mutex) - deadlock warning");

      else
      {
        literal$6 = (struct anonymous$4){ .b={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } };
        return_value_bacmp$7=bacmp(bdaddr, &literal$6);
        if(return_value_bacmp$7 == 0)
        {
          signed int return_value_cwiid_find_wiimote$5;
          return_value_cwiid_find_wiimote$5=cwiid_find_wiimote(bdaddr, timeout);
          if(!(return_value_cwiid_find_wiimote$5 == 0))
            goto ERR_HND;

          sleep((unsigned int)1);
        }

        memset((void *)&remote_addr, 0, sizeof(struct sockaddr_l2) /*14ul*/ );
        remote_addr.l2_family = (unsigned short int)31;
        remote_addr.l2_bdaddr = *bdaddr;
        remote_addr.l2_psm = (unsigned short int)17;
        wiimote->ctl_socket=socket(31, 5, 0);
        if(wiimote->ctl_socket == -1)
          cwiid_err(wiimote, "Socket creation error (control socket)");

        else
        {
          return_value_connect$8=connect(wiimote->ctl_socket, (struct sockaddr *)&remote_addr, (unsigned int)sizeof(struct sockaddr_l2) /*14ul*/ );
          if(!(return_value_connect$8 == 0))
            cwiid_err(wiimote, "Socket connect error (control channel)");

          else
          {
            remote_addr.l2_psm = (unsigned short int)19;
            wiimote->int_socket=socket(31, 5, 0);
            if(wiimote->int_socket == -1)
              cwiid_err(wiimote, "Socket creation error (interrupt socket)");

            else
            {
              return_value_connect$9=connect(wiimote->int_socket, (struct sockaddr *)&remote_addr, (unsigned int)sizeof(struct sockaddr_l2) /*14ul*/ );
              if(!(return_value_connect$9 == 0))
                cwiid_err(wiimote, "Socket connect error (interrupt channel)");

              else
              {
                return_value_pipe$10=pipe(wiimote->mesg_pipe);
                if(!(return_value_pipe$10 == 0))
                  cwiid_err(wiimote, "Pipe creation error (mesg pipe)");

                else
                {
                  mesg_pipe_init = (char)1;
                  return_value_pipe$11=pipe(wiimote->status_pipe);
                  if(!(return_value_pipe$11 == 0))
                    cwiid_err(wiimote, "Pipe creation error (status pipe)");

                  else
                  {
                    status_pipe_init = (char)1;
                    return_value_pipe$12=pipe(wiimote->rw_pipe);
                    if(!(return_value_pipe$12 == 0))
                      cwiid_err(wiimote, "Pipe creation error (rw pipe)");

                    else
                    {
                      rw_pipe_init = (char)1;
                      return_value_fcntl$13=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 04000);
                      if(!(return_value_fcntl$13 == 0))
                        cwiid_err(wiimote, "File control error (mesg write pipe)");

                      else
                      {
                        if(!((0x08 & wiimote->flags) == 0))
                        {
                          signed int return_value_fcntl$14;
                          return_value_fcntl$14=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 04000);
                          if(!(return_value_fcntl$14 == 0))
                          {
                            cwiid_err(wiimote, "File control error (mesg read pipe)");
                            goto ERR_HND;
                          }

                        }

                        return_value_pthread_mutex_init$15=pthread_mutex_init(&wiimote->state_mutex, (const union anonymous *)(void *)0);
                        if(!(return_value_pthread_mutex_init$15 == 0))
                          cwiid_err(wiimote, "Mutex initialization error (state mutex)");

                        else
                        {
                          state_mutex_init = (char)1;
                          return_value_pthread_mutex_init$16=pthread_mutex_init(&wiimote->rw_mutex, (const union anonymous *)(void *)0);
                          if(!(return_value_pthread_mutex_init$16 == 0))
                            cwiid_err(wiimote, "Mutex initialization error (rw mutex)");

                          else
                          {
                            rw_mutex_init = (char)1;
                            return_value_pthread_mutex_init$17=pthread_mutex_init(&wiimote->rpt_mutex, (const union anonymous *)(void *)0);
                            if(!(return_value_pthread_mutex_init$17 == 0))
                              cwiid_err(wiimote, "Mutex initialization error (rpt mutex)");

                            else
                            {
                              rpt_mutex_init = (char)1;
                              wiimote->rw_status = (enum rw_status)RW_IDLE;
                              return_value_pthread_create$18=pthread_create(&wiimote->router_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))router_thread, (void *)wiimote);
                              if(!(return_value_pthread_create$18 == 0))
                                cwiid_err(wiimote, "Thread creation error (router thread)");

                              else
                              {
                                router_thread_init = (char)1;
                                return_value_pthread_create$19=pthread_create(&wiimote->status_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))status_thread, (void *)wiimote);
                                if(!(return_value_pthread_create$19 == 0))
                                  cwiid_err(wiimote, "Thread creation error (status thread)");

                                else
                                {
                                  status_thread_init = (char)1;
                                  memset((void *)&wiimote->state, 0, sizeof(struct cwiid_state) /*60ul*/ );
                                  wiimote->mesg_callback = (void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))(void *)0;
                                  cwiid_set_led(wiimote, (unsigned char)0);
                                  cwiid_request_status(wiimote);
                                  return wiimote;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

ERR_HND:
  ;
  _Bool tmp_if_expr$26;
  signed int return_value_close$25;
  _Bool tmp_if_expr$29;
  signed int return_value_close$28;
  _Bool tmp_if_expr$32;
  signed int return_value_close$31;
  if(!(wiimote == ((struct wiimote *)NULL)))
  {
    if(!(router_thread_init == 0))
    {
      pthread_cancel(wiimote->router_thread);
      signed int return_value_pthread_join$20;
      return_value_pthread_join$20=pthread_join(wiimote->router_thread, &pthread_ret);
      if(!(return_value_pthread_join$20 == 0))
        cwiid_err(wiimote, "Thread join error (router thread)");

      else
        if(!(pthread_ret == NULL) || !(pthread_ret == (void *)-1))
          cwiid_err(wiimote, "Bad return value from router thread");

    }

    if(!(status_thread_init == 0))
    {
      pthread_cancel(wiimote->status_thread);
      signed int return_value_pthread_join$21;
      return_value_pthread_join$21=pthread_join(wiimote->status_thread, &pthread_ret);
      if(!(return_value_pthread_join$21 == 0))
        cwiid_err(wiimote, "Thread join error (status thread)");

      else
        if(!(pthread_ret == NULL) || !(pthread_ret == (void *)-1))
          cwiid_err(wiimote, "Bad return value from status thread");

    }

    if(!(wiimote->int_socket == -1))
    {
      signed int return_value_close$22;
      return_value_close$22=close(wiimote->int_socket);
      if(!(return_value_close$22 == 0))
        cwiid_err(wiimote, "Socket close error (interrupt channel)");

    }

    if(!(wiimote->ctl_socket == -1))
    {
      signed int return_value_close$23;
      return_value_close$23=close(wiimote->ctl_socket);
      if(!(return_value_close$23 == 0))
        cwiid_err(wiimote, "Socket close error (control channel)");

    }

    if(!(mesg_pipe_init == 0))
    {
      signed int return_value_close$24;
      return_value_close$24=close(wiimote->mesg_pipe[(signed long int)0]);
      if(!(return_value_close$24 == 0))
        tmp_if_expr$26 = (_Bool)1;

      else
      {
        return_value_close$25=close(wiimote->mesg_pipe[(signed long int)1]);
        tmp_if_expr$26 = return_value_close$25 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$26)
        cwiid_err(wiimote, "Pipe close error (mesg pipe)");

    }

    if(!(status_pipe_init == 0))
    {
      signed int return_value_close$27;
      return_value_close$27=close(wiimote->status_pipe[(signed long int)0]);
      if(!(return_value_close$27 == 0))
        tmp_if_expr$29 = (_Bool)1;

      else
      {
        return_value_close$28=close(wiimote->status_pipe[(signed long int)1]);
        tmp_if_expr$29 = return_value_close$28 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$29)
        cwiid_err(wiimote, "Pipe close error (status pipe)");

    }

    if(!(rw_pipe_init == 0))
    {
      signed int return_value_close$30;
      return_value_close$30=close(wiimote->rw_pipe[(signed long int)0]);
      if(!(return_value_close$30 == 0))
        tmp_if_expr$32 = (_Bool)1;

      else
      {
        return_value_close$31=close(wiimote->rw_pipe[(signed long int)1]);
        tmp_if_expr$32 = return_value_close$31 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$32)
        cwiid_err(wiimote, "Pipe close error (rw pipe)");

    }

    if(!(state_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy$33;
      return_value_pthread_mutex_destroy$33=pthread_mutex_destroy(&wiimote->state_mutex);
      if(!(return_value_pthread_mutex_destroy$33 == 0))
        cwiid_err(wiimote, "Mutex destroy error (state mutex)");

    }

    if(!(rw_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy$34;
      return_value_pthread_mutex_destroy$34=pthread_mutex_destroy(&wiimote->rw_mutex);
      if(!(return_value_pthread_mutex_destroy$34 == 0))
        cwiid_err(wiimote, "Mutex destroy error (rw mutex)");

    }

    if(!(rpt_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy$35;
      return_value_pthread_mutex_destroy$35=pthread_mutex_destroy(&wiimote->rpt_mutex);
      if(!(return_value_pthread_mutex_destroy$35 == 0))
        cwiid_err(wiimote, "Mutex destroy error (rpt mutex)");

    }

    free((void *)wiimote);
  }

  return (struct wiimote *)(void *)0;
}

// cwiid_read
// file command.c line 157
signed int cwiid_read(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, void *data)
{
  unsigned char buf[6l];
  struct rw_mesg mesg;
  unsigned char *cursor;
  signed int ret = 0;
  buf[(signed long int)0] = (unsigned char)((signed int)flags & (0x00 | 0x04));
  buf[(signed long int)1] = (unsigned char)(offset >> 16 & (unsigned int)0xFF);
  buf[(signed long int)2] = (unsigned char)(offset >> 8 & (unsigned int)0xFF);
  buf[(signed long int)3] = (unsigned char)(offset & (unsigned int)0xFF);
  buf[(signed long int)4] = (unsigned char)((signed int)len >> 8 & 0xFF);
  buf[(signed long int)5] = (unsigned char)((signed int)len & 0xFF);
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rw_mutex)");
    return -1;
  }

  else
  {
    wiimote->rw_status = (enum rw_status)RW_READ;
    signed int return_value_cwiid_send_rpt$2;
    return_value_cwiid_send_rpt$2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x17, (unsigned long int)6, (const void *)buf);
    if(!(return_value_cwiid_send_rpt$2 == 0))
    {
      cwiid_err(wiimote, "Report send error (read)");
      ret = -1;
    }

    else
    {
      cursor = (unsigned char *)data;
      for( ; !(cursor - (unsigned char *)data >= (signed long int)len); cursor = cursor + (signed long int)mesg.len)
      {
        signed int return_value_full_read$3;
        return_value_full_read$3=full_read(wiimote->rw_pipe[(signed long int)0], (void *)&mesg, sizeof(struct rw_mesg) /*32ul*/ );
        if(!(return_value_full_read$3 == 0))
        {
          cwiid_err(wiimote, "Pipe read error (rw pipe)");
          ret = -1;
          break;
        }

        if((signed int)mesg.type == RW_CANCEL)
        {
          ret = -1;
          break;
        }

        else
          if(!((signed int)mesg.type == RW_READ))
          {
            cwiid_err(wiimote, "Unexpected write message");
            ret = -1;
            break;
          }

        if(!(mesg.error == 0))
        {
          cwiid_err(wiimote, "Wiimote read error");
          ret = -1;
          break;
        }

        memcpy((void *)cursor, (const void *)&mesg.data, (unsigned long int)mesg.len);
      }
    }

  CODA:
    ;
    wiimote->rw_status = (enum rw_status)RW_IDLE;
    signed int return_value_pthread_mutex_unlock$4;
    return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&wiimote->rw_mutex);
    if(!(return_value_pthread_mutex_unlock$4 == 0))
      cwiid_err(wiimote, "Mutex unlock error (rw_mutex) - deadlock warning");

    return ret;
  }
}

// cwiid_request_status
// file ../libcwiid/cwiid.h line 386
signed int cwiid_request_status(struct wiimote *wiimote)
{
  unsigned char data = (unsigned char)0;
  signed int return_value_cwiid_send_rpt$1;
  return_value_cwiid_send_rpt$1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x15, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt$1 == 0))
  {
    cwiid_err(wiimote, "Status request error");
    return -1;
  }

  else
    return 0;
}

// cwiid_send_rpt
// file command.c line 79
signed int cwiid_send_rpt(struct wiimote *wiimote, unsigned char flags, unsigned char report, unsigned long int len, const void *data)
{
  unsigned char *buf;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(len * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
  buf = (unsigned char *)return_value_malloc$1;
  signed int return_value_verify_handshake$2;
  if(buf == ((unsigned char *)NULL))
  {
    cwiid_err(wiimote, "Memory allocation error (mesg array)");
    return -1;
  }

  else
  {
    buf[(signed long int)0] = (unsigned char)(0x50 | 0x02);
    buf[(signed long int)1] = report;
    memcpy((void *)(buf + (signed long int)2), data, len);
    if((0x01 & (signed int)flags) == 0)
      buf[(signed long int)2] = buf[(signed long int)2] | wiimote->state.rumble;

    signed long int return_value_write$3;
    return_value_write$3=write(wiimote->ctl_socket, (const void *)buf, len + (unsigned long int)2);
    if(!(return_value_write$3 == 2l + (signed long int)len))
    {
      free((void *)buf);
      return -1;
    }

    else
    {
      return_value_verify_handshake$2=verify_handshake(wiimote);
      if(!(return_value_verify_handshake$2 == 0))
      {
        free((void *)buf);
        return -1;
      }

    }
    return 0;
  }
}

// cwiid_set_data
// file interface.c line 39
signed int cwiid_set_data(struct wiimote *wiimote, const void *data)
{
  wiimote->data = data;
  return 0;
}

// cwiid_set_err
// file ../libcwiid/cwiid.h line 354
signed int cwiid_set_err(void (*err)(struct wiimote *, const char *, void **))
{
  cwiid_err_func = err;
  return 0;
}

// cwiid_set_led
// file ../libcwiid/cwiid.h line 387
signed int cwiid_set_led(struct wiimote *wiimote, unsigned char led)
{
  unsigned char data;
  wiimote->state.led = (unsigned char)((signed int)led & 0x0F);
  data = (unsigned char)((signed int)wiimote->state.led << 4);
  signed int return_value_cwiid_send_rpt$1;
  return_value_cwiid_send_rpt$1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x11, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt$1 == 0))
  {
    cwiid_err(wiimote, "Report send error (led)");
    return -1;
  }

  else
    return 0;
}

// cwiid_set_mesg_callback
// file ../libcwiid/cwiid.h line 371
signed int cwiid_set_mesg_callback(struct wiimote *wiimote, void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))
{
  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_cancel_mesg_callback$1;
    return_value_cancel_mesg_callback$1=cancel_mesg_callback(wiimote);
    if(!(return_value_cancel_mesg_callback$1 == 0))
      return -1;

  }

  wiimote->mesg_callback = callback;
  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_pthread_create$2;
    return_value_pthread_create$2=pthread_create(&wiimote->mesg_callback_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))mesg_callback_thread, (void *)wiimote);
    if(!(return_value_pthread_create$2 == 0))
    {
      cwiid_err(wiimote, "Thread creation error (callback thread)");
      return -1;
    }

  }

  return 0;
}

// cwiid_set_rpt_mode
// file ../libcwiid/cwiid.h line 389
signed int cwiid_set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode)
{
  signed int return_value_update_rpt_mode$1;
  return_value_update_rpt_mode$1=update_rpt_mode(wiimote, (signed char)rpt_mode);
  return return_value_update_rpt_mode$1;
}

// cwiid_set_rumble
// file ../libcwiid/cwiid.h line 388
signed int cwiid_set_rumble(struct wiimote *wiimote, unsigned char rumble)
{
  unsigned char data;
  wiimote->state.rumble = (unsigned char)(rumble != 0 ? 1 : 0);
  data = (unsigned char)((signed int)wiimote->state.led << 4);
  signed int return_value_cwiid_send_rpt$1;
  return_value_cwiid_send_rpt$1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x11, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt$1 == 0))
  {
    cwiid_err(wiimote, "Report send error (led)");
    return -1;
  }

  else
    return 0;
}

// cwiid_write
// file command.c line 234
signed int cwiid_write(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, const void *data)
{
  unsigned char buf[21l];
  unsigned short int sent = (unsigned short int)0;
  struct rw_mesg mesg;
  signed int ret = 0;
  buf[(signed long int)0] = flags;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rw mutex)");
    return -1;
  }

  else
  {
    wiimote->rw_status = (enum rw_status)RW_WRITE;
    while(!((signed int)sent >= (signed int)len))
    {
      buf[(signed long int)1] = (unsigned char)(offset + (unsigned int)sent >> 16 & (unsigned int)0xFF);
      buf[(signed long int)2] = (unsigned char)(offset + (unsigned int)sent >> 8 & (unsigned int)0xFF);
      buf[(signed long int)3] = (unsigned char)(offset + (unsigned int)sent & (unsigned int)0xFF);
      if((signed int)len + -((signed int)sent) >= 0x10)
        buf[(signed long int)4] = (unsigned char)0x10;

      else
        buf[(signed long int)4] = (unsigned char)((signed int)len - (signed int)sent);
      memcpy((void *)(buf + (signed long int)5), data + (signed long int)sent, (unsigned long int)buf[(signed long int)4]);
      signed int return_value_cwiid_send_rpt$2;
      return_value_cwiid_send_rpt$2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x16, (unsigned long int)21, (const void *)buf);
      if(!(return_value_cwiid_send_rpt$2 == 0))
      {
        cwiid_err(wiimote, "Report send error (write)");
        ret = -1;
        break;
      }

      signed long int return_value_read$3;
      return_value_read$3=read(wiimote->rw_pipe[(signed long int)0], (void *)&mesg, sizeof(struct rw_mesg) /*32ul*/ );
      if(!((unsigned long int)return_value_read$3 == sizeof(struct rw_mesg) /*32ul*/ ))
      {
        cwiid_err(wiimote, "Pipe read error (rw pipe)");
        ret = -1;
        break;
      }

      if((signed int)mesg.type == RW_CANCEL)
      {
        ret = -1;
        break;
      }

      else
        if(!((signed int)mesg.type == RW_WRITE))
        {
          cwiid_err(wiimote, "Unexpected read message");
          ret = -1;
          break;
        }

      if(!(mesg.error == 0))
      {
        cwiid_err(wiimote, "Wiimote write error");
        ret = -1;
        break;
      }

      sent = sent + (unsigned short int)buf[(signed long int)4];
    }

  CODA:
    ;
    wiimote->rw_status = (enum rw_status)RW_IDLE;
    signed int return_value_pthread_mutex_unlock$4;
    return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&wiimote->rw_mutex);
    if(!(return_value_pthread_mutex_unlock$4 == 0))
      cwiid_err(wiimote, "Mutex unlock error (rw_mutex) - deadlock warning");

    return ret;
  }
}

// err
// file wmdemo.c line 47
void err(struct wiimote *wiimote, const char *s, void **ap)
{
  signed int return_value_cwiid_get_id$1;
  if(!(wiimote == ((struct wiimote *)NULL)))
  {
    return_value_cwiid_get_id$1=cwiid_get_id(wiimote);
    printf("%d:", return_value_cwiid_get_id$1);
  }

  else
    printf("-1:");
  vprintf(s, ap);
  printf("\n");
}

// exec_write_seq
// file cwiid_internal.h line 199
signed int exec_write_seq(struct wiimote *wiimote, unsigned int len, struct write_seq *seq)
{
  unsigned int i = (unsigned int)0;
  signed int return_value_cwiid_send_rpt$1;
  signed int return_value_cwiid_write$2;
  for( ; !(i >= len); i = i + 1u)
    switch((signed int)(seq + (signed long int)i)->type)
    {
      case WRITE_SEQ_RPT:
      {
        return_value_cwiid_send_rpt$1=cwiid_send_rpt(wiimote, (seq + (signed long int)i)->flags, (unsigned char)(seq + (signed long int)i)->report_offset, (unsigned long int)(seq + (signed long int)i)->len, (seq + (signed long int)i)->data);
        if(!(return_value_cwiid_send_rpt$1 == 0))
          return -1;

        break;
      }
      case WRITE_SEQ_MEM:
      {
        return_value_cwiid_write$2=cwiid_write(wiimote, (seq + (signed long int)i)->flags, (seq + (signed long int)i)->report_offset, (seq + (signed long int)i)->len, (seq + (signed long int)i)->data);
        if(!(return_value_cwiid_write$2 == 0))
          return -1;

      }
    }
  return 0;
}

// full_read
// file cwiid_internal.h line 201
signed int full_read(signed int fd, void *buf, unsigned long int len)
{
  signed long int last_len = (signed long int)0;
  do
  {
    last_len=read(fd, buf, len);
    if(last_len == -1l)
      return -1;

    len = len - (unsigned long int)last_len;
    buf = buf + last_len;
  }
  while(len >= 1ul);
  return 0;
}

// main
// file wmdemo.c line 55
signed int main(signed int argc, char **argv)
{
  struct wiimote *wiimote;
  struct cwiid_state state;
  struct anonymous$4 bdaddr;
  unsigned char mesg = (unsigned char)0;
  unsigned char led_state = (unsigned char)0;
  unsigned char rpt_mode = (unsigned char)0;
  unsigned char rumble = (unsigned char)0;
  signed int main$$1$$exit = 0;
  cwiid_set_err(err);
  if(argc >= 2)
    str2ba(argv[(signed long int)1], &bdaddr);

  else
  {
    struct anonymous$4 literal$1 = { .b={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } };
    bdaddr = *(&literal$1);
  }
  printf("Put Wiimote in discoverable mode now (press 1+2)...\n");
  wiimote=cwiid_open(&bdaddr, 0);
  signed int return_value_cwiid_set_rumble$4;
  signed int return_value_cwiid_request_status$7;
  signed int return_value_cwiid_get_state$8;
  if(wiimote == ((struct wiimote *)NULL))
  {
    fprintf(stderr, "Unable to connect to wiimote\n");
    return -1;
  }

  else
  {
    signed int return_value_cwiid_set_mesg_callback$2;
    return_value_cwiid_set_mesg_callback$2=cwiid_set_mesg_callback(wiimote, cwiid_callback);
    if(!(return_value_cwiid_set_mesg_callback$2 == 0))
      fprintf(stderr, "Unable to set message callback\n");

    printf("Note: To demonstrate the new API interfaces, wmdemo no longer enables messages by default.\nOutput can be gathered through the new state-based interface (s), or by enabling the messages interface (m).\n");
    printf("%s", (const void *)"1: toggle LED 1\n2: toggle LED 2\n3: toggle LED 3\n4: toggle LED 4\n5: toggle rumble\na: toggle accelerometer reporting\nb: toggle button reporting\nc: enable motionplus, if connected\ne: toggle extension reporting\ni: toggle ir reporting\nm: toggle messages\np: print this menu\nr: request status message ((t) enables callback output)\ns: print current state\nt: toggle status reporting\nx: exit\n");
    while(main$$1$$exit == 0)
    {
      signed int return_value_getchar$3;
      return_value_getchar$3=getchar();
      switch(return_value_getchar$3)
      {
        case 49:
        {
          led_state = (unsigned char)(((signed int)led_state & 0x01) != 0 ? (signed int)led_state & ~0x01 : (signed int)led_state | 0x01);
          set_led_state(wiimote, led_state);
          break;
        }
        case 50:
        {
          led_state = (unsigned char)(((signed int)led_state & 0x02) != 0 ? (signed int)led_state & ~0x02 : (signed int)led_state | 0x02);
          set_led_state(wiimote, led_state);
          break;
        }
        case 51:
        {
          led_state = (unsigned char)(((signed int)led_state & 0x04) != 0 ? (signed int)led_state & ~0x04 : (signed int)led_state | 0x04);
          set_led_state(wiimote, led_state);
          break;
        }
        case 52:
        {
          led_state = (unsigned char)(((signed int)led_state & 0x08) != 0 ? (signed int)led_state & ~0x08 : (signed int)led_state | 0x08);
          set_led_state(wiimote, led_state);
          break;
        }
        case 53:
        {
          rumble = (unsigned char)(((signed int)rumble & 1) != 0 ? (signed int)rumble & ~1 : (signed int)rumble | 1);
          return_value_cwiid_set_rumble$4=cwiid_set_rumble(wiimote, rumble);
          if(!(return_value_cwiid_set_rumble$4 == 0))
            fprintf(stderr, "Error setting rumble\n");

          break;
        }
        case 97:
        {
          rpt_mode = (unsigned char)(((signed int)rpt_mode & 0x04) != 0 ? (signed int)rpt_mode & ~0x04 : (signed int)rpt_mode | 0x04);
          set_rpt_mode(wiimote, rpt_mode);
          break;
        }
        case 98:
        {
          rpt_mode = (unsigned char)(((signed int)rpt_mode & 0x02) != 0 ? (signed int)rpt_mode & ~0x02 : (signed int)rpt_mode | 0x02);
          set_rpt_mode(wiimote, rpt_mode);
          break;
        }
        case 99:
        {
          cwiid_enable(wiimote, 0x10);
          break;
        }
        case 101:
        {
          rpt_mode = (unsigned char)(((signed int)rpt_mode & (0x10 | 0x20 | 0x40 | 0x80)) != 0 ? (signed int)rpt_mode & ~(0x10 | 0x20 | 0x40 | 0x80) : (signed int)rpt_mode | 0x10 | 0x20 | 0x40 | 0x80);
          set_rpt_mode(wiimote, rpt_mode);
          break;
        }
        case 105:
        {
          rpt_mode = (unsigned char)(((signed int)rpt_mode & 0x08) != 0 ? (signed int)rpt_mode & ~0x08 : (signed int)rpt_mode | 0x08);
          set_rpt_mode(wiimote, rpt_mode);
          break;
        }
        case 109:
        {
          if(mesg == 0)
          {
            signed int return_value_cwiid_enable$5;
            return_value_cwiid_enable$5=cwiid_enable(wiimote, 0x01);
            if(!(return_value_cwiid_enable$5 == 0))
              fprintf(stderr, "Error enabling messages\n");

            else
              mesg = (unsigned char)1;
          }

          else
          {
            signed int return_value_cwiid_disable$6;
            return_value_cwiid_disable$6=cwiid_disable(wiimote, 0x01);
            if(!(return_value_cwiid_disable$6 == 0))
              fprintf(stderr, "Error disabling message\n");

            else
              mesg = (unsigned char)0;
          }
          break;
        }
        case 112:
        {
          printf("%s", (const void *)"1: toggle LED 1\n2: toggle LED 2\n3: toggle LED 3\n4: toggle LED 4\n5: toggle rumble\na: toggle accelerometer reporting\nb: toggle button reporting\nc: enable motionplus, if connected\ne: toggle extension reporting\ni: toggle ir reporting\nm: toggle messages\np: print this menu\nr: request status message ((t) enables callback output)\ns: print current state\nt: toggle status reporting\nx: exit\n");
          break;
        }
        case 114:
        {
          return_value_cwiid_request_status$7=cwiid_request_status(wiimote);
          if(!(return_value_cwiid_request_status$7 == 0))
            fprintf(stderr, "Error requesting status message\n");

          break;
        }
        case 115:
        {
          return_value_cwiid_get_state$8=cwiid_get_state(wiimote, &state);
          if(!(return_value_cwiid_get_state$8 == 0))
            fprintf(stderr, "Error getting state\n");

          print_state(&state);
          break;
        }
        case 116:
        {
          rpt_mode = (unsigned char)(((signed int)rpt_mode & 0x01) != 0 ? (signed int)rpt_mode & ~0x01 : (signed int)rpt_mode | 0x01);
          set_rpt_mode(wiimote, rpt_mode);
          break;
        }
        case 120:
        {
          main$$1$$exit = -1;
          break;
        }
        case 10:
          break;
        default:
          fprintf(stderr, "invalid option\n");
      }
    }
    signed int return_value_cwiid_close$9;
    return_value_cwiid_close$9=cwiid_close(wiimote);
    if(!(return_value_cwiid_close$9 == 0))
    {
      fprintf(stderr, "Error on wiimote disconnect\n");
      return -1;
    }

    else
      return 0;
  }
}

// mesg_callback_thread
// file cwiid_internal.h line 194
void * mesg_callback_thread(struct wiimote *wiimote)
{
  signed int mesg_pipe = wiimote->mesg_pipe[(signed long int)0];
  void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *) = wiimote->mesg_callback;
  struct mesg_array ma;
  signed int cancelstate;
  while((_Bool)1)
  {
    signed int return_value_read_mesg_array$1;
    return_value_read_mesg_array$1=read_mesg_array(mesg_pipe, &ma);
    if(!(return_value_read_mesg_array$1 == 0))
      cwiid_err(wiimote, "Mesg pipe read error");

    else
    {
      signed int return_value_pthread_setcancelstate$2;
      return_value_pthread_setcancelstate$2=pthread_setcancelstate(1, &cancelstate);
      if(!(return_value_pthread_setcancelstate$2 == 0))
        cwiid_err(wiimote, "Cancel state disable error (callback thread)");

      callback(wiimote, (signed int)ma.count, ma.array, &ma.timestamp);
      signed int return_value_pthread_setcancelstate$3;
      return_value_pthread_setcancelstate$3=pthread_setcancelstate(0, &cancelstate);
      if(!(return_value_pthread_setcancelstate$3 == 0))
        cwiid_err(wiimote, "Cancel state restore error (callback thread)");

    }
  }
  return (void *)0;
}

// print_state
// file wmdemo.c line 210
void print_state(struct cwiid_state *state)
{
  signed int i;
  signed int valid_source = 0;
  printf("Report Mode:");
  if(!((0x01 & (signed int)state->rpt_mode) == 0))
    printf(" STATUS");

  if(!((0x02 & (signed int)state->rpt_mode) == 0))
    printf(" BTN");

  if(!((0x04 & (signed int)state->rpt_mode) == 0))
    printf(" ACC");

  if(!((0x08 & (signed int)state->rpt_mode) == 0))
    printf(" IR");

  if(!((0x10 & (signed int)state->rpt_mode) == 0))
    printf(" NUNCHUK");

  if(!((0x20 & (signed int)state->rpt_mode) == 0))
    printf(" CLASSIC");

  if(!((0x40 & (signed int)state->rpt_mode) == 0))
    printf(" BALANCE");

  if(!((0x80 & (signed int)state->rpt_mode) == 0))
    printf(" MOTIONPLUS");

  printf("\n");
  printf("Active LEDs:");
  if(!((0x01 & (signed int)state->led) == 0))
    printf(" 1");

  if(!((0x02 & (signed int)state->led) == 0))
    printf(" 2");

  if(!((0x04 & (signed int)state->led) == 0))
    printf(" 3");

  if(!((0x08 & (signed int)state->led) == 0))
    printf(" 4");

  printf("\n");
  printf("Rumble: %s\n", state->rumble != 0 ? "On" : "Off");
  printf("Battery: %d%%\n", (signed int)((100.0 * (double)state->battery) / (double)0xD0));
  printf("Buttons: %X\n", state->buttons);
  printf("Acc: x=%d y=%d z=%d\n", state->acc[(signed long int)0], state->acc[(signed long int)1], state->acc[(signed long int)2]);
  printf("IR: ");
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(state->ir_src[(signed long int)i].valid == 0))
    {
      valid_source = 1;
      printf("(%d,%d) ", state->ir_src[(signed long int)i].pos[(signed long int)0], state->ir_src[(signed long int)i].pos[(signed long int)1]);
    }

  if(valid_source == 0)
    printf("no sources detected");

  printf("\n");
  switch((signed int)state->ext_type)
  {
    case CWIID_EXT_NONE:
    {
      printf("No extension\n");
      break;
    }
    case CWIID_EXT_UNKNOWN:
    {
      printf("Unknown extension attached\n");
      break;
    }
    case CWIID_EXT_NUNCHUK:
    {
      printf("Nunchuk: btns=%.2X stick=(%d,%d) acc.x=%d acc.y=%d acc.z=%d\n", state->ext.nunchuk.buttons, state->ext.nunchuk.stick[(signed long int)0], state->ext.nunchuk.stick[(signed long int)1], state->ext.nunchuk.acc[(signed long int)0], state->ext.nunchuk.acc[(signed long int)1], state->ext.nunchuk.acc[(signed long int)2]);
      break;
    }
    case CWIID_EXT_CLASSIC:
    {
      printf("Classic: btns=%.4X l_stick=(%d,%d) r_stick=(%d,%d) l=%d r=%d\n", state->ext.classic.buttons, state->ext.classic.l_stick[(signed long int)0], state->ext.classic.l_stick[(signed long int)1], state->ext.classic.r_stick[(signed long int)0], state->ext.classic.r_stick[(signed long int)1], state->ext.classic.l, state->ext.classic.r);
      break;
    }
    case CWIID_EXT_BALANCE:
    {
      printf("Balance: right_top=%d right_bottom=%d left_top=%d left_bottom=%d\n", state->ext.balance.right_top, state->ext.balance.right_bottom, state->ext.balance.left_top, state->ext.balance.left_bottom);
      break;
    }
    case CWIID_EXT_MOTIONPLUS:
      printf("MotionPlus: angle_rate=(%d,%d,%d)\n", state->ext.motionplus.angle_rate[(signed long int)0], state->ext.motionplus.angle_rate[(signed long int)1], state->ext.motionplus.angle_rate[(signed long int)2]);
  }
}

// process_acc
// file process.c line 92
signed int process_acc(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_acc_mesg *acc_mesg;
  unsigned char tmp_post$1;
  if(!((0x04 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post$1 = ma->count;
    ma->count = ma->count + 1;
    acc_mesg = &ma->array[(signed long int)tmp_post$1].acc_mesg;
    acc_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_ACC;
    acc_mesg->acc[(signed long int)0] = data[(signed long int)0];
    acc_mesg->acc[(signed long int)1] = data[(signed long int)1];
    acc_mesg->acc[(signed long int)2] = data[(signed long int)2];
  }

  return 0;
}

// process_btn
// file process.c line 72
signed int process_btn(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_btn_mesg *btn_mesg;
  unsigned short int buttons = (unsigned short int)(((signed int)data[(signed long int)0] & 0x1F) << 8 | (signed int)data[(signed long int)1] & 0x9F);
  _Bool tmp_if_expr$2;
  unsigned char tmp_post$1;
  if(!((0x02 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    if(!(wiimote->state.buttons == buttons))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (wiimote->flags & 0x04) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      tmp_post$1 = ma->count;
      ma->count = ma->count + 1;
      btn_mesg = &ma->array[(signed long int)tmp_post$1].btn_mesg;
      btn_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_BTN;
      btn_mesg->buttons = buttons;
    }

  }

  return 0;
}

// process_error
// file process.c line 28
signed int process_error(struct wiimote *wiimote, signed long int len, struct mesg_array *ma)
{
  struct cwiid_error_mesg *error_mesg;
  unsigned char tmp_post$1 = ma->count;
  ma->count = ma->count + 1;
  error_mesg = &ma->array[(signed long int)tmp_post$1].error_mesg;
  error_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_ERROR;
  if(len == 0l)
    error_mesg->error = (enum cwiid_error)CWIID_ERROR_DISCONNECT;

  else
    error_mesg->error = (enum cwiid_error)CWIID_ERROR_COMM;
  signed int return_value_cancel_rw$2;
  return_value_cancel_rw$2=cancel_rw(wiimote);
  if(!(return_value_cancel_rw$2 == 0))
    cwiid_err(wiimote, "RW cancel error");

  return 0;
}

// process_ext
// file process.c line 180
signed int process_ext(struct wiimote *wiimote, unsigned char *data, unsigned char len, struct mesg_array *ma)
{
  struct cwiid_nunchuk_mesg *nunchuk_mesg;
  struct cwiid_classic_mesg *classic_mesg;
  struct cwiid_balance_mesg *balance_mesg;
  struct cwiid_motionplus_mesg *motionplus_mesg;
  signed int i;
  unsigned char tmp_post$1;
  unsigned char tmp_post$2;
  unsigned char tmp_post$3;
  unsigned char tmp_post$4;
  switch((signed int)wiimote->state.ext_type)
  {
    case CWIID_EXT_NONE:
    {
      cwiid_err(wiimote, "Received unexpected extension report");
      break;
    }
    case CWIID_EXT_UNKNOWN:
      break;
    case CWIID_EXT_NUNCHUK:
    {
      if(!((0x10 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post$1 = ma->count;
        ma->count = ma->count + 1;
        nunchuk_mesg = &ma->array[(signed long int)tmp_post$1].nunchuk_mesg;
        nunchuk_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_NUNCHUK;
        nunchuk_mesg->stick[(signed long int)0] = data[(signed long int)0];
        nunchuk_mesg->stick[(signed long int)1] = data[(signed long int)1];
        nunchuk_mesg->acc[(signed long int)0] = data[(signed long int)2];
        nunchuk_mesg->acc[(signed long int)1] = data[(signed long int)3];
        nunchuk_mesg->acc[(signed long int)2] = data[(signed long int)4];
        nunchuk_mesg->buttons = (unsigned char)(~((signed int)data[(signed long int)5]) & 0x03);
      }

      break;
    }
    case CWIID_EXT_CLASSIC:
    {
      if(!((0x20 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post$2 = ma->count;
        ma->count = ma->count + 1;
        classic_mesg = &ma->array[(signed long int)tmp_post$2].classic_mesg;
        classic_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_CLASSIC;
        i = 0;
        for( ; !(i >= 6); i = i + 1)
          data[(signed long int)i] = data[(signed long int)i];
        classic_mesg->l_stick[(signed long int)0] = (unsigned char)((signed int)data[(signed long int)0] & 0x3F);
        classic_mesg->l_stick[(signed long int)1] = (unsigned char)((signed int)data[(signed long int)1] & 0x3F);
        classic_mesg->r_stick[(signed long int)0] = (unsigned char)(((signed int)data[(signed long int)0] & 0xC0) >> 3 | ((signed int)data[(signed long int)1] & 0xC0) >> 5 | ((signed int)data[(signed long int)2] & 0x80) >> 7);
        classic_mesg->r_stick[(signed long int)1] = (unsigned char)((signed int)data[(signed long int)2] & 0x1F);
        classic_mesg->l = (unsigned char)(((signed int)data[(signed long int)2] & 0x60) >> 2 | ((signed int)data[(signed long int)3] & 0xE0) >> 5);
        classic_mesg->r = (unsigned char)((signed int)data[(signed long int)3] & 0x1F);
        classic_mesg->buttons = (unsigned short int)~((signed int)(unsigned short int)data[(signed long int)4] << 8 | (signed int)(unsigned short int)data[(signed long int)5]);
      }

      break;
    }
    case CWIID_EXT_BALANCE:
      if(!((0x40 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post$3 = ma->count;
        ma->count = ma->count + 1;
        balance_mesg = &ma->array[(signed long int)tmp_post$3].balance_mesg;
        balance_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_BALANCE;
        balance_mesg->right_top = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)0] << 8 | (signed int)(unsigned short int)data[(signed long int)1]);
        balance_mesg->right_bottom = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)2] << 8 | (signed int)(unsigned short int)data[(signed long int)3]);
        balance_mesg->left_top = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)4] << 8 | (signed int)(unsigned short int)data[(signed long int)5]);
        balance_mesg->left_bottom = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)6] << 8 | (signed int)(unsigned short int)data[(signed long int)7]);
      }

    case CWIID_EXT_MOTIONPLUS:
      if(!((0x80 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post$4 = ma->count;
        ma->count = ma->count + 1;
        motionplus_mesg = &ma->array[(signed long int)tmp_post$4].motionplus_mesg;
        motionplus_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_MOTIONPLUS;
        motionplus_mesg->angle_rate[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)5] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)2]);
        motionplus_mesg->angle_rate[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)4] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)1]);
        motionplus_mesg->angle_rate[(signed long int)2] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)3] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)0]);
      }

  }
  return 0;
}

// process_ir10
// file process.c line 108
signed int process_ir10(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_ir_mesg *ir_mesg;
  signed int i;
  const unsigned char *block;
  unsigned char tmp_post$1;
  if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post$1 = ma->count;
    ma->count = ma->count + 1;
    ir_mesg = &ma->array[(signed long int)tmp_post$1].ir_mesg;
    ir_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_IR;
    i = 0;
    block = data;
    for( ; !(i >= 4); block = block + (signed long int)5)
    {
      if((signed int)*block == 0xFF)
        ir_mesg->src[(signed long int)i].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)i].valid = (char)1;
        ir_mesg->src[(signed long int)i].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x30) << 4 | (signed int)(unsigned short int)block[(signed long int)0]);
        ir_mesg->src[(signed long int)i].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0xC0) << 2 | (signed int)(unsigned short int)block[(signed long int)1]);
        ir_mesg->src[(signed long int)i].size = (signed char)-1;
      }
      if((signed int)block[3l] == 0xFF)
        ir_mesg->src[(signed long int)(i + 1)].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)(i + 1)].valid = (char)1;
        ir_mesg->src[(signed long int)(i + 1)].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x03) << 8 | (signed int)(unsigned short int)block[(signed long int)3]);
        ir_mesg->src[(signed long int)(i + 1)].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x0C) << 6 | (signed int)(unsigned short int)block[(signed long int)4]);
        ir_mesg->src[(signed long int)(i + 1)].size = (signed char)-1;
      }
      i = i + 2;
    }
  }

  return 0;
}

// process_ir12
// file process.c line 151
signed int process_ir12(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_ir_mesg *ir_mesg;
  signed int i;
  const unsigned char *block;
  unsigned char tmp_post$1;
  if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post$1 = ma->count;
    ma->count = ma->count + 1;
    ir_mesg = &ma->array[(signed long int)tmp_post$1].ir_mesg;
    ir_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_IR;
    i = 0;
    block = data;
    for( ; !(i >= 4); block = block + (signed long int)3)
    {
      if((signed int)*block == 0xFF)
        ir_mesg->src[(signed long int)i].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)i].valid = (char)1;
        ir_mesg->src[(signed long int)i].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x30) << 4 | (signed int)(unsigned short int)block[(signed long int)0]);
        ir_mesg->src[(signed long int)i].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0xC0) << 2 | (signed int)(unsigned short int)block[(signed long int)1]);
        ir_mesg->src[(signed long int)i].size = (signed char)((signed int)block[(signed long int)2] & 0x0F);
      }
      i = i + 1;
    }
  }

  return 0;
}

// process_read
// file process.c line 259
signed int process_read(struct wiimote *wiimote, unsigned char *data)
{
  struct rw_mesg rw_mesg;
  if(!((signed int)wiimote->rw_status == RW_READ))
  {
    cwiid_err(wiimote, "Received unexpected read report");
    return -1;
  }

  else
  {
    rw_mesg.type = (enum rw_status)RW_READ;
    rw_mesg.len = (unsigned char)(((signed int)data[(signed long int)0] >> 4) + 1);
    rw_mesg.error = (unsigned char)((signed int)data[(signed long int)0] & 0x0F);
    memcpy((void *)&rw_mesg.data, (const void *)(data + (signed long int)3), (unsigned long int)rw_mesg.len);
    signed long int return_value_write$1;
    return_value_write$1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
    if(!((unsigned long int)return_value_write$1 == sizeof(struct rw_mesg) /*32ul*/ ))
    {
      cwiid_err(wiimote, "RW pipe write error");
      return -1;
    }

    else
      return 0;
  }
}

// process_status
// file process.c line 48
signed int process_status(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_status_mesg status_mesg;
  status_mesg.type = (enum cwiid_mesg_type)CWIID_MESG_STATUS;
  status_mesg.battery = data[(signed long int)5];
  if(!((0x02 & (signed int)data[2l]) == 0))
    status_mesg.ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;

  else
    status_mesg.ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
  signed long int return_value_write$1;
  return_value_write$1=write(wiimote->status_pipe[(signed long int)1], (const void *)&status_mesg, sizeof(struct cwiid_status_mesg) /*12ul*/ );
  if(!((unsigned long int)return_value_write$1 == sizeof(struct cwiid_status_mesg) /*12ul*/ ))
  {
    cwiid_err(wiimote, "Status pipe write error");
    return -1;
  }

  else
    return 0;
}

// process_write
// file process.c line 282
signed int process_write(struct wiimote *wiimote, unsigned char *data)
{
  struct rw_mesg rw_mesg;
  if(!((signed int)wiimote->rw_status == RW_WRITE))
  {
    cwiid_err(wiimote, "Received unexpected write report");
    return -1;
  }

  else
  {
    rw_mesg.type = (enum rw_status)RW_WRITE;
    rw_mesg.error = data[(signed long int)0];
    signed long int return_value_write$1;
    return_value_write$1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
    if(!((unsigned long int)return_value_write$1 == sizeof(struct rw_mesg) /*32ul*/ ))
    {
      cwiid_err(wiimote, "RW pipe write error");
      return -1;
    }

    else
      return 0;
  }
}

// read_mesg_array
// file cwiid_internal.h line 203
signed int read_mesg_array(signed int fd, struct mesg_array *ma)
{
  signed long int len = (void *)&ma->array[(signed long int)0] - (void *)ma;
  signed int return_value_full_read$1;
  return_value_full_read$1=full_read(fd, (void *)ma, (unsigned long int)len);
  if(!(return_value_full_read$1 == 0))
    return -1;

  else
  {
    len = (signed long int)((unsigned long int)ma->count * sizeof(union cwiid_mesg) /*36ul*/ );
    signed int return_value_full_read$2;
    return_value_full_read$2=full_read(fd, (void *)&ma->array[(signed long int)0], (unsigned long int)len);
    if(!(return_value_full_read$2 == 0))
      return -1;

    else
      return 0;
  }
}

// router_thread
// file cwiid_internal.h line 192
void * router_thread(struct wiimote *wiimote)
{
  unsigned char buf[23l];
  signed long int len;
  struct mesg_array ma;
  char router_thread$$1$$err;
  char print_clock_err = (char)1;
  signed int return_value_process_status$2;
  signed int return_value_process_btn$3;
  signed int return_value_process_btn$4;
  _Bool tmp_if_expr$6;
  signed int return_value_process_acc$5;
  signed int return_value_process_btn$7;
  _Bool tmp_if_expr$9;
  signed int return_value_process_ext$8;
  signed int return_value_process_btn$10;
  _Bool tmp_if_expr$12;
  signed int return_value_process_acc$11;
  _Bool tmp_if_expr$14;
  signed int return_value_process_ir12$13;
  signed int return_value_process_btn$15;
  _Bool tmp_if_expr$17;
  signed int return_value_process_ext$16;
  signed int return_value_process_btn$18;
  _Bool tmp_if_expr$20;
  signed int return_value_process_acc$19;
  _Bool tmp_if_expr$22;
  signed int return_value_process_ext$21;
  signed int return_value_process_btn$23;
  _Bool tmp_if_expr$25;
  signed int return_value_process_ir10$24;
  _Bool tmp_if_expr$27;
  signed int return_value_process_ext$26;
  signed int return_value_process_btn$28;
  _Bool tmp_if_expr$30;
  signed int return_value_process_acc$29;
  _Bool tmp_if_expr$32;
  signed int return_value_process_ir10$31;
  _Bool tmp_if_expr$34;
  signed int return_value_process_ext$33;
  signed int return_value_process_ext$35;
  signed int return_value_process_read$36;
  _Bool tmp_if_expr$38;
  signed int return_value_process_btn$37;
  signed int return_value_process_write$39;
  while((_Bool)1)
  {
    len=read(wiimote->int_socket, (void *)buf, (unsigned long int)23);
    ma.count = (unsigned char)0;
    signed int return_value_clock_gettime$1;
    return_value_clock_gettime$1=clock_gettime(0, &ma.timestamp);
    if(!(return_value_clock_gettime$1 == 0))
    {
      if(!(print_clock_err == 0))
      {
        cwiid_err(wiimote, "clock_gettime error");
        print_clock_err = (char)0;
      }

    }

    router_thread$$1$$err = (char)0;
    if(len == 0l || len == -1l)
    {
      process_error(wiimote, len, &ma);
      write_mesg_array(wiimote, &ma);
      break;
    }

    else
    {
      if(!((signed int)buf[0l] == 161))
        cwiid_err(wiimote, "Invalid packet type");

      switch((signed int)buf[(signed long int)1])
      {
        case 0x20:
        {
          return_value_process_status$2=process_status(wiimote, &buf[(signed long int)2], &ma);
          router_thread$$1$$err = (char)return_value_process_status$2;
          break;
        }
        case 0x30:
        {
          return_value_process_btn$3=process_btn(wiimote, &buf[(signed long int)2], &ma);
          router_thread$$1$$err = (char)return_value_process_btn$3;
          break;
        }
        case 0x31:
        {
          return_value_process_btn$4=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$4 == 0))
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_process_acc$5=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr$6 = return_value_process_acc$5 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$6;
          break;
        }
        case 0x32:
        {
          return_value_process_btn$7=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$7 == 0))
            tmp_if_expr$9 = (_Bool)1;

          else
          {
            return_value_process_ext$8=process_ext(wiimote, &buf[(signed long int)4], (unsigned char)8, &ma);
            tmp_if_expr$9 = return_value_process_ext$8 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$9;
          break;
        }
        case 0x33:
        {
          return_value_process_btn$10=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$10 == 0))
            tmp_if_expr$12 = (_Bool)1;

          else
          {
            return_value_process_acc$11=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr$12 = return_value_process_acc$11 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$12)
            tmp_if_expr$14 = (_Bool)1;

          else
          {
            return_value_process_ir12$13=process_ir12(wiimote, &buf[(signed long int)7], &ma);
            tmp_if_expr$14 = return_value_process_ir12$13 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$14;
          break;
        }
        case 0x34:
        {
          return_value_process_btn$15=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$15 == 0))
            tmp_if_expr$17 = (_Bool)1;

          else
          {
            return_value_process_ext$16=process_ext(wiimote, &buf[(signed long int)4], (unsigned char)19, &ma);
            tmp_if_expr$17 = return_value_process_ext$16 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$17;
          break;
        }
        case 0x35:
        {
          return_value_process_btn$18=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$18 == 0))
            tmp_if_expr$20 = (_Bool)1;

          else
          {
            return_value_process_acc$19=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr$20 = return_value_process_acc$19 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$20)
            tmp_if_expr$22 = (_Bool)1;

          else
          {
            return_value_process_ext$21=process_ext(wiimote, &buf[(signed long int)7], (unsigned char)16, &ma);
            tmp_if_expr$22 = return_value_process_ext$21 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$22;
          break;
        }
        case 0x36:
        {
          return_value_process_btn$23=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$23 == 0))
            tmp_if_expr$25 = (_Bool)1;

          else
          {
            return_value_process_ir10$24=process_ir10(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr$25 = return_value_process_ir10$24 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$25)
            tmp_if_expr$27 = (_Bool)1;

          else
          {
            return_value_process_ext$26=process_ext(wiimote, &buf[(signed long int)14], (unsigned char)9, &ma);
            tmp_if_expr$27 = return_value_process_ext$26 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$27;
          break;
        }
        case 0x37:
        {
          return_value_process_btn$28=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn$28 == 0))
            tmp_if_expr$30 = (_Bool)1;

          else
          {
            return_value_process_acc$29=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr$30 = return_value_process_acc$29 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$30)
            tmp_if_expr$32 = (_Bool)1;

          else
          {
            return_value_process_ir10$31=process_ir10(wiimote, &buf[(signed long int)7], &ma);
            tmp_if_expr$32 = return_value_process_ir10$31 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$32)
            tmp_if_expr$34 = (_Bool)1;

          else
          {
            return_value_process_ext$33=process_ext(wiimote, &buf[(signed long int)17], (unsigned char)6, &ma);
            tmp_if_expr$34 = return_value_process_ext$33 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$34;
          break;
        }
        case 0x3D:
        {
          return_value_process_ext$35=process_ext(wiimote, &buf[(signed long int)2], (unsigned char)21, &ma);
          router_thread$$1$$err = (char)return_value_process_ext$35;
          break;
        }
        case 0x3E:

        case 0x3F:
        {
          cwiid_err(wiimote, "Unsupported report type received (interleaved data)");
          router_thread$$1$$err = (char)1;
          break;
        }
        case 0x21:
        {
          return_value_process_read$36=process_read(wiimote, &buf[(signed long int)4]);
          if(!(return_value_process_read$36 == 0))
            tmp_if_expr$38 = (_Bool)1;

          else
          {
            return_value_process_btn$37=process_btn(wiimote, &buf[(signed long int)2], &ma);
            tmp_if_expr$38 = return_value_process_btn$37 != 0 ? (_Bool)1 : (_Bool)0;
          }
          router_thread$$1$$err = (char)tmp_if_expr$38;
          break;
        }
        case 0x22:
        {
          return_value_process_write$39=process_write(wiimote, &buf[(signed long int)2]);
          router_thread$$1$$err = (char)return_value_process_write$39;
          break;
        }
        default:
        {
          cwiid_err(wiimote, "Unknown message type");
          router_thread$$1$$err = (char)1;
        }
      }
      if(router_thread$$1$$err == 0 && (signed int)ma.count >= 1)
      {
        signed int return_value_update_state$40;
        return_value_update_state$40=update_state(wiimote, &ma);
        if(!(return_value_update_state$40 == 0))
          cwiid_err(wiimote, "State update error");

        if(!((0x01 & wiimote->flags) == 0))
          write_mesg_array(wiimote, &ma);

      }

    }
  }
  return (void *)0;
}

// set_led_state
// file wmdemo.c line 196
void set_led_state(struct wiimote *wiimote, unsigned char led_state)
{
  signed int return_value_cwiid_set_led$1;
  return_value_cwiid_set_led$1=cwiid_set_led(wiimote, led_state);
  if(!(return_value_cwiid_set_led$1 == 0))
    fprintf(stderr, "Error setting LEDs \n");

}

// set_rpt_mode
// file wmdemo.c line 203
void set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode)
{
  signed int return_value_cwiid_set_rpt_mode$1;
  return_value_cwiid_set_rpt_mode$1=cwiid_set_rpt_mode(wiimote, rpt_mode);
  if(!(return_value_cwiid_set_rpt_mode$1 == 0))
    fprintf(stderr, "Error setting report mode\n");

}

// status_thread
// file cwiid_internal.h line 193
void * status_thread(struct wiimote *wiimote)
{
  struct mesg_array ma;
  struct cwiid_status_mesg *status_mesg;
  unsigned char buf[2l];
  ma.count = (unsigned char)1;
  status_mesg = &ma.array[(signed long int)0].status_mesg;
  signed int return_value_cwiid_write$5;
  signed int return_value_cwiid_write$4;
  signed int return_value_cwiid_read$3;
  while((_Bool)1)
  {
    signed int return_value_full_read$1;
    return_value_full_read$1=full_read(wiimote->status_pipe[(signed long int)0], (void *)status_mesg, sizeof(struct cwiid_status_mesg) /*12ul*/ );
    if(!(return_value_full_read$1 == 0))
    {
      cwiid_err(wiimote, "Pipe read error (status)");
      break;
    }

    if(!((signed int)status_mesg->type == CWIID_MESG_STATUS))
      cwiid_err(wiimote, "Bad message on status pipe");

    else
    {
      if((signed int)status_mesg->ext_type == CWIID_EXT_UNKNOWN)
      {
        signed int return_value_cwiid_read$2;
        return_value_cwiid_read$2=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xA400FE, (unsigned short int)1, (void *)&buf[(signed long int)0]);
        if(!(return_value_cwiid_read$2 == 0))
        {
          cwiid_err(wiimote, "Read error (extension error)");
          status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
        }

        switch((signed int)buf[(signed long int)0])
        {
          case 0x2E:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
            break;
          }
          case 0x00:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NUNCHUK;
            break;
          }
          case 0x01:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_CLASSIC;
            break;
          }
          case 0x2A:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_BALANCE;
            break;
          }
          case 0x04:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_MOTIONPLUS;
            break;
          }
          case 0xFF:
          {
            buf[(signed long int)0] = (unsigned char)0x55;
            buf[(signed long int)1] = (unsigned char)0x00;
            return_value_cwiid_write$5=cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400F0, (unsigned short int)1, (const void *)&buf[(signed long int)0]);
            if(!(return_value_cwiid_write$5 == 0))
            {
              cwiid_err(wiimote, "Extension initialization error");
              status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
            }

            else
            {
              return_value_cwiid_write$4=cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400FB, (unsigned short int)1, (const void *)&buf[(signed long int)1]);
              if(!(return_value_cwiid_write$4 == 0))
              {
                cwiid_err(wiimote, "Extension initialization error");
                status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
              }

              else
              {
                return_value_cwiid_read$3=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xA400FE, (unsigned short int)1, (void *)&buf[(signed long int)0]);
                if(!(return_value_cwiid_read$3 == 0))
                {
                  cwiid_err(wiimote, "Read error (extension error)");
                  status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
                }

                else
                  switch((signed int)buf[(signed long int)0])
                  {
                    case 0x2E:

                    case 0xFF:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
                      break;
                    }
                    case 0x00:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NUNCHUK;
                      break;
                    }
                    case 0x01:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_CLASSIC;
                      break;
                    }
                    case 0x2A:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_BALANCE;
                      break;
                    }
                    default:
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
                  }
              }
            }
          }
        }
      }

      signed int return_value_update_state$6;
      return_value_update_state$6=update_state(wiimote, &ma);
      if(!(return_value_update_state$6 == 0))
        cwiid_err(wiimote, "State update error");

      signed int return_value_update_rpt_mode$7;
      return_value_update_rpt_mode$7=update_rpt_mode(wiimote, (signed char)-1);
      if(!(return_value_update_rpt_mode$7 == 0))
        cwiid_err(wiimote, "Error reseting report mode");

      if(!((0x01 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        if(!((0x01 & wiimote->flags) == 0))
        {
          signed int return_value_write_mesg_array$8;
          return_value_write_mesg_array$8=write_mesg_array(wiimote, &ma);
        }

      }

    }
  }
  return (void *)0;
}

// update_rpt_mode
// file cwiid_internal.h line 222
signed int update_rpt_mode(struct wiimote *wiimote, signed char rpt_mode)
{
  unsigned char buf[2l];
  unsigned char rpt_type;
  struct write_seq *ir_enable_seq;
  signed int seq_len;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&wiimote->rpt_mutex);
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  if(!(return_value_pthread_mutex_lock$1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rpt mutex)");
    return -1;
  }

  else
  {
    if((signed int)rpt_mode == -1)
      rpt_mode = (signed char)wiimote->state.rpt_mode;

    if(!((240 & (signed int)rpt_mode) == 0))
    {
      if((signed int)wiimote->state.ext_type == CWIID_EXT_NUNCHUK)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)wiimote->state.ext_type == CWIID_EXT_CLASSIC ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)wiimote->state.ext_type == CWIID_EXT_MOTIONPLUS ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      if(!((0x04 & (signed int)rpt_mode) == 0) && !((0x08 & (signed int)rpt_mode) == 0))
      {
        rpt_type = (unsigned char)0x37;
        ir_enable_seq = ir_enable10_seq;
        seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
      }

      else
        if(!((0x08 & (signed int)rpt_mode) == 0))
        {
          rpt_type = (unsigned char)0x36;
          ir_enable_seq = ir_enable10_seq;
          seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
        }

        else
          if(!((0x04 & (signed int)rpt_mode) == 0))
            rpt_type = (unsigned char)0x35;

          else
            if(!((0x02 & (signed int)rpt_mode) == 0))
              rpt_type = (unsigned char)0x32;

            else
              rpt_type = (unsigned char)0x3D;
    }

    else
    {
      if(!((240 & (signed int)rpt_mode) == 0))
        tmp_if_expr$2 = (signed int)wiimote->state.ext_type == CWIID_EXT_BALANCE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        rpt_type = (unsigned char)0x32;

      else
        if(!((0x08 & (signed int)rpt_mode) == 0))
        {
          rpt_type = (unsigned char)0x33;
          ir_enable_seq = ir_enable12_seq;
          seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
        }

        else
          if(!((0x04 & (signed int)rpt_mode) == 0))
            rpt_type = (unsigned char)0x31;

          else
            rpt_type = (unsigned char)0x30;
    }
    if(!((0x08 & (signed int)rpt_mode) == 0))
    {
      signed int return_value_exec_write_seq$6;
      return_value_exec_write_seq$6=exec_write_seq(wiimote, (unsigned int)seq_len, ir_enable_seq);
      if(!(return_value_exec_write_seq$6 == 0))
      {
        cwiid_err(wiimote, "IR enable error");
        return -1;
      }

    }

    else
      if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        if((0x08 & (signed int)rpt_mode) == 0)
        {
          signed int return_value_exec_write_seq$7;
          return_value_exec_write_seq$7=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [2l]) /*48ul*/  / sizeof(struct write_seq) /*24ul*/ ), ir_disable_seq);
          if(!(return_value_exec_write_seq$7 == 0))
          {
            cwiid_err(wiimote, "IR disable error");
            return -1;
          }

        }

      }

    buf[(signed long int)0] = (unsigned char)((wiimote->flags & 0x02) != 0 ? 0x04 : 0);
    buf[(signed long int)1] = rpt_type;
    signed int return_value_cwiid_send_rpt$8;
    return_value_cwiid_send_rpt$8=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x12, (unsigned long int)2, (const void *)buf);
    if(!(return_value_cwiid_send_rpt$8 == 0))
    {
      cwiid_err(wiimote, "Send report error (report mode)");
      return -1;
    }

    else
    {
      if(!((~((signed int)rpt_mode) & 0x02 & (signed int)wiimote->state.rpt_mode) == 0))
        wiimote->state.buttons = (unsigned short int)0;

      if(!((~((signed int)rpt_mode) & 0x04 & (signed int)wiimote->state.rpt_mode) == 0))
        memset((void *)wiimote->state.acc, 0, sizeof(unsigned char [3l]) /*3ul*/ );

      if(!((~((signed int)rpt_mode) & 0x08 & (signed int)wiimote->state.rpt_mode) == 0))
        memset((void *)wiimote->state.ir_src, 0, sizeof(struct cwiid_ir_src [4l]) /*32ul*/ );

      if((signed int)wiimote->state.ext_type == CWIID_EXT_NUNCHUK)
        tmp_if_expr$11 = (0x10 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$11 = (_Bool)0;
      if(tmp_if_expr$11)
        memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

      else
      {
        if((signed int)wiimote->state.ext_type == CWIID_EXT_CLASSIC)
          tmp_if_expr$10 = (0x20 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        if(tmp_if_expr$10)
          memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

        else
        {
          if((signed int)wiimote->state.ext_type == CWIID_EXT_BALANCE)
            tmp_if_expr$9 = (0x40 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$9 = (_Bool)0;
          if(tmp_if_expr$9)
            memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

          else
            if((signed int)wiimote->state.ext_type == CWIID_EXT_MOTIONPLUS)
            {
              if(!((~((signed int)rpt_mode) & 0x80 & (signed int)wiimote->state.rpt_mode) == 0))
                memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

            }

        }
      }
      wiimote->state.rpt_mode = (unsigned char)rpt_mode;
      signed int return_value_pthread_mutex_unlock$12;
      return_value_pthread_mutex_unlock$12=pthread_mutex_unlock(&wiimote->rpt_mutex);
      if(!(return_value_pthread_mutex_unlock$12 == 0))
      {
        cwiid_err(wiimote, "Mutex unlock error (rpt mutex) - deadlock warning");
        return -1;
      }

      else
        return 0;
    }
  }
}

// update_state
// file state.c line 26
signed int update_state(struct wiimote *wiimote, struct mesg_array *ma)
{
  signed int i;
  union cwiid_mesg *mesg;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (state mutex)");
    return -1;
  }

  else
  {
    i = 0;
    while(!(i >= (signed int)ma->count))
    {
      mesg = &ma->array[(signed long int)i];
      switch((signed int)mesg->type)
      {
        case CWIID_MESG_STATUS:
        {
          wiimote->state.battery = mesg->status_mesg.battery;
          if(!(wiimote->state.ext_type == mesg->status_mesg.ext_type))
          {
            memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );
            wiimote->state.ext_type = mesg->status_mesg.ext_type;
          }

          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_BTN:
        {
          wiimote->state.buttons = mesg->btn_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_ACC:
        {
          memcpy((void *)wiimote->state.acc, (const void *)mesg->acc_mesg.acc, sizeof(unsigned char [3l]) /*3ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_IR:
        {
          memcpy((void *)wiimote->state.ir_src, (const void *)mesg->ir_mesg.src, sizeof(struct cwiid_ir_src [4l]) /*32ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_NUNCHUK:
        {
          memcpy((void *)wiimote->state.ext.nunchuk.stick, (const void *)mesg->nunchuk_mesg.stick, sizeof(unsigned char [2l]) /*2ul*/ );
          memcpy((void *)wiimote->state.ext.nunchuk.acc, (const void *)mesg->nunchuk_mesg.acc, sizeof(unsigned char [3l]) /*3ul*/ );
          wiimote->state.ext.nunchuk.buttons = mesg->nunchuk_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_CLASSIC:
        {
          memcpy((void *)wiimote->state.ext.classic.l_stick, (const void *)mesg->classic_mesg.l_stick, sizeof(unsigned char [2l]) /*2ul*/ );
          memcpy((void *)wiimote->state.ext.classic.r_stick, (const void *)mesg->classic_mesg.r_stick, sizeof(unsigned char [2l]) /*2ul*/ );
          wiimote->state.ext.classic.l = mesg->classic_mesg.l;
          wiimote->state.ext.classic.r = mesg->classic_mesg.r;
          wiimote->state.ext.classic.buttons = mesg->classic_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_BALANCE:
        {
          wiimote->state.ext.balance.right_top = mesg->balance_mesg.right_top;
          wiimote->state.ext.balance.right_bottom = mesg->balance_mesg.right_bottom;
          wiimote->state.ext.balance.left_top = mesg->balance_mesg.left_top;
          wiimote->state.ext.balance.left_bottom = mesg->balance_mesg.left_bottom;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_MOTIONPLUS:
        {
          memcpy((void *)wiimote->state.ext.motionplus.angle_rate, (const void *)mesg->motionplus_mesg.angle_rate, sizeof(unsigned short int [3l]) /*6ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_ERROR:
          wiimote->state.error = mesg->error_mesg.error;
        case CWIID_MESG_UNKNOWN:

        default:
        {

        __CPROVER_DUMP_L13:
          ;
          i = i + 1;
        }
      }
    }
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&wiimote->state_mutex);
    if(!(return_value_pthread_mutex_unlock$2 == 0))
    {
      cwiid_err(wiimote, "Mutex unlock error (state mutex) - deadlock warning");
      return -1;
    }

    else
      return 0;
  }
}

// verify_handshake
// file cwiid_internal.h line 198
signed int verify_handshake(struct wiimote *wiimote)
{
  unsigned char handshake;
  signed long int return_value_read$1;
  return_value_read$1=read(wiimote->ctl_socket, (void *)&handshake, (unsigned long int)1);
  if(!(return_value_read$1 == 1l))
  {
    cwiid_err(wiimote, "Socket read error (handshake)");
    return -1;
  }

  else
    if(!((0xF0 & (signed int)handshake) == 0x00))
    {
      cwiid_err(wiimote, "Handshake expected, non-handshake received");
      return -1;
    }

    else
      if(!((0x0F & (signed int)handshake) == 0x00))
      {
        cwiid_err(wiimote, "Non-successful handshake");
        return -1;
      }

  return 0;
}

// write_mesg_array
// file cwiid_internal.h line 202
signed int write_mesg_array(struct wiimote *wiimote, struct mesg_array *ma)
{
  signed long int len = (void *)&ma->array[(signed long int)ma->count] - (void *)ma;
  signed int ret = 0;
  signed long int return_value_write$5;
  return_value_write$5=write(wiimote->mesg_pipe[(signed long int)1], (const void *)ma, (unsigned long int)len);
  if(!(return_value_write$5 == len))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
    {
      cwiid_err(wiimote, "Mesg pipe overflow");
      signed int return_value_fcntl$3;
      return_value_fcntl$3=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 0);
      if(!(return_value_fcntl$3 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        ret = -1;
      }

      else
      {
        signed long int return_value_write$1;
        return_value_write$1=write(wiimote->mesg_pipe[(signed long int)1], (const void *)ma, (unsigned long int)len);
        if(!(return_value_write$1 == len))
        {
          cwiid_err(wiimote, "Pipe write error (mesg pipe)");
          ret = -1;
        }

        signed int return_value_fcntl$2;
        return_value_fcntl$2=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 04000);
        if(!(return_value_fcntl$2 == 0))
          cwiid_err(wiimote, "File control error (mesg pipe");

      }
    }

    else
    {
      cwiid_err(wiimote, "Pipe write error (mesg pipe)");
      ret = -1;
    }
  }

  return ret;
}

