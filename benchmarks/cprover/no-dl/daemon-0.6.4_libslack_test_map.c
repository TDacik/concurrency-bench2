// tag-#anon#ST[*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'rfds'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'xfds'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'wfds'|]
// file libslack/agent.c line 165
struct anonymous_24;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_20;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_18;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_10;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_6;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_13;

// tag-#anon#ST[S32'init'||U32'_pad0'||*{SYM#tag-Prop#}_SYM#tag-Prop#_'prop'||*{S8}_S8_'home'||S32'dirty'||U32'_pad1'||*{SYM#tag-Locker#}_SYM#tag-Locker#_'locker'|]
// file libslack/prop.c line 133
struct anonymous_5;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_7;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_17;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_16;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_22;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_15;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_19;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||*{S8}_S8_'pidfile'|]
// file libslack/daemon.c line 104
struct anonymous_26;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous_2;

// tag-#anon#UN[*{SYM#tag-pollfd#}_SYM#tag-pollfd#_'pfds'||SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'rfds'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'xfds'||*{SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#}_SYM#tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]#_'wfds'|]#'s'|]
// file libslack/agent.c line 160
union anonymous_23;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_9;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_0;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_21;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_12;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_11;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_1;

// tag-#anon#cST[ARR19{SYM#tag-conf_t#}_SYM#tag-conf_t#_'conf'|]
// file libslack/lim.c line 130
struct anonymous_27;

// tag-Agent
// file libslack/agent.h line 30
struct Agent;

// tag-List
// file libslack/list.h line 34
struct List;

// tag-Lister
// file libslack/list.h line 35
struct Lister;

// tag-Locker
// file libslack/slack/locker.h line 31
struct Locker;

// tag-Map
// file libslack/map.h line 31
struct Map;

// tag-Mapper
// file libslack/map.h line 32
struct Mapper;

// tag-Mapping
// file libslack/map.h line 33
struct Mapping;

// tag-Msg
// file libslack/msg.h line 38
struct Msg;

// tag-MsgFileData
// file libslack/msg.c line 117
struct MsgFileData;

// tag-MsgPlexData
// file libslack/msg.c line 119
struct MsgPlexData;

// tag-MsgSyslogData
// file libslack/msg.c line 118
struct MsgSyslogData;

// tag-Option
// file libslack/prog.h line 43
struct Option;

// tag-OptionAction
// file libslack/prog.h line 60
enum OptionAction { OPT_NOTHING=0, OPT_VARIABLE=1, OPT_FUNCTION=2 };

// tag-OptionArgument
// file libslack/prog.h line 53
enum OptionArgument { OPT_NONE=0, OPT_INTEGER=1, OPT_STRING=2 };

// tag-Options
// file libslack/prog.h line 44
struct Options;

// tag-Point
// file libslack/map.c line 2420
struct Point;

// tag-Pool
// file libslack/mem.h line 40
struct Pool;

// tag-Prog
// file libslack/prog.c line 201
struct Prog;

// tag-Prop
// file libslack/prop.c line 123
struct Prop;

// tag-String
// file libslack/str.h line 36
struct String;

// tag-StringAlignment
// file libslack/str.h line 39
enum StringAlignment { ALIGN_LEFT=60, ALIGN_RIGHT=62, ALIGN_CENTRE=124, ALIGN_CENTER=124, ALIGN_FULL=61 };

// tag-StringTR
// file libslack/str.h line 37
struct StringTR;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-action_t
// file libslack/agent.c line 144
struct action_t;

// tag-activity_t
// file libslack/agent.c line 146
struct activity_t;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-conf_t
// file libslack/lim.c line 119
struct conf_t;

// tag-dlink_t
// file libslack/link.h line 30
struct dlink_t;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip_mreq
// file /usr/include/netinet/in.h line 264
struct ip_mreq;

// tag-ipv6_mreq
// file /usr/include/netinet/in.h line 288
struct ipv6_mreq;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-net_interface_t
// file libslack/net.h line 48
struct net_interface_t;

// tag-option
// file libslack/getopt.h line 83
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-reaction_t
// file libslack/agent.c line 145
struct reaction_t;

// tag-real_signal_handler_t
// file libslack/sig.c line 98
struct real_signal_handler_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rudp_t
// file libslack/net.h line 49
struct rudp_t;

// tag-servent
// file /usr/include/netdb.h line 257
struct servent;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-slink_t
// file libslack/link.h line 29
struct slink_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_any_t
// file libslack/net.h line 41
union sockaddr_any_t;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockopt_t
// file libslack/net.h line 39
struct sockopt_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-syslog_map_t
// file libslack/msg.c line 153
struct syslog_map_t;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timewheel_t
// file libslack/agent.c line 143
struct timewheel_t;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// __ctype_toupper_loc
// file /usr/include/ctype.h line 83
extern const signed int ** __ctype_toupper_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 398
extern signed int __fxstat(signed int, signed int, struct stat *);
// __lxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 402
extern signed int __lxstat(signed int, const char *, struct stat *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject);
// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2);
// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3);
// __uflow
// file /usr/include/libio.h line 391
extern signed int __uflow(struct _IO_FILE *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// act
// file libslack/agent.c line 1927
static signed int act(signed int (*action)(struct Agent *, void *), struct Agent *agent, void *arg);
// act::action_object
//
signed int action_object(struct Agent *, void *);
// adjust
// file libslack/list.c line 318
static signed int adjust(struct List *list, signed long int index, unsigned long int range, unsigned long int length);
// adjust_link1
// file libslack/str.c line 497
static signed int adjust_link1(struct String *str, signed long int index_link1, unsigned long int range_link1, unsigned long int length_link1);
// agent_acceleration
// file libslack/agent.c line 1423
signed int agent_acceleration(struct Agent *agent, signed int fd);
// agent_acceleration_unlocked
// file libslack/agent.c line 1452
signed int agent_acceleration_unlocked(struct Agent *agent, signed int fd);
// agent_cancel
// file libslack/agent.c line 1740
signed int agent_cancel(struct Agent *agent, void *action_id);
// agent_cancel_unlocked
// file libslack/agent.c line 1768
signed int agent_cancel_unlocked(struct Agent *agent, void *action_id);
// agent_connect
// file libslack/agent.c line 620
signed int agent_connect(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_connect::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_connect_unlocked
// file libslack/agent.c line 648
signed int agent_connect_unlocked(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_connect_unlocked::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_create
// file libslack/agent.c line 325
struct Agent * agent_create(void);
// agent_create_measured
// file libslack/agent.c line 386
struct Agent * agent_create_measured(void);
// agent_create_measured_with_locker
// file libslack/agent.c line 402
struct Agent * agent_create_measured_with_locker(struct Locker *locker);
// agent_create_using_select
// file libslack/agent.c line 442
struct Agent * agent_create_using_select(void);
// agent_create_using_select_with_locker
// file libslack/agent.c line 458
struct Agent * agent_create_using_select_with_locker(struct Locker *locker);
// agent_create_with_locker
// file libslack/agent.c line 341
struct Agent * agent_create_with_locker(struct Locker *locker);
// agent_dadt
// file libslack/agent.c line 1507
signed int agent_dadt(struct Agent *agent, signed int fd);
// agent_dadt_unlocked
// file libslack/agent.c line 1535
signed int agent_dadt_unlocked(struct Agent *agent, signed int fd);
// agent_destroy
// file libslack/agent.c line 526
void * agent_destroy(struct Agent **agent);
// agent_detail
// file libslack/agent.c line 1192
signed int agent_detail(struct Agent *agent, signed int fd);
// agent_detail_unlocked
// file libslack/agent.c line 1220
signed int agent_detail_unlocked(struct Agent *agent, signed int fd);
// agent_disconnect
// file libslack/agent.c line 811
signed int agent_disconnect(struct Agent *agent, signed int fd);
// agent_disconnect_unlocked
// file libslack/agent.c line 840
signed int agent_disconnect_unlocked(struct Agent *agent, signed int fd);
// agent_last
// file libslack/agent.c line 1262
struct timeval * agent_last(struct Agent *agent, signed int fd);
// agent_last_unlocked
// file libslack/agent.c line 1291
struct timeval * agent_last_unlocked(struct Agent *agent, signed int fd);
// agent_rdlock
// file libslack/agent.c line 558
signed int agent_rdlock(const struct Agent *agent);
// agent_recv
// file libslack/agent.c line 1101
signed int agent_recv(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_recv::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_recv_unlocked
// file libslack/agent.c line 1129
signed int agent_recv_unlocked(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg);
// agent_recv_unlocked::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_release
// file libslack/agent.c line 482
void agent_release(struct Agent *agent);
// agent_schedule
// file libslack/agent.c line 1585
void * agent_schedule(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg);
// agent_schedule::action_object
//
signed int action_object(struct Agent *, void *);
// agent_schedule_unlocked
// file libslack/agent.c line 1645
void * agent_schedule_unlocked(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg);
// agent_schedule_unlocked::action_object
//
signed int action_object(struct Agent *, void *);
// agent_send
// file libslack/agent.c line 1027
signed int agent_send(struct Agent *agent, signed int fd, signed int sockfd);
// agent_send_unlocked
// file libslack/agent.c line 1055
signed int agent_send_unlocked(struct Agent *agent, signed int fd, signed int sockfd);
// agent_start
// file libslack/agent.c line 2270
signed int agent_start(struct Agent *agent);
// agent_start_unlocked
// file libslack/agent.c line 2087
static signed int agent_start_unlocked(struct Agent *agent);
// agent_start_unlocked::1::1::1::2::1::1::1::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_start_unlocked::1::1::2::2::1::1::1::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// agent_stop
// file libslack/agent.c line 2312
signed int agent_stop(struct Agent *agent);
// agent_stop_unlocked
// file libslack/agent.c line 2302
static signed int agent_stop_unlocked(struct Agent *agent);
// agent_transfer
// file libslack/agent.c line 927
signed int agent_transfer(struct Agent *agent, signed int fd, struct Agent *dst);
// agent_transfer_unlocked
// file libslack/agent.c line 956
signed int agent_transfer_unlocked(struct Agent *agent, signed int fd, struct Agent *dst);
// agent_unlock
// file libslack/agent.c line 596
signed int agent_unlock(const struct Agent *agent);
// agent_velocity
// file libslack/agent.c line 1342
signed int agent_velocity(struct Agent *agent, signed int fd);
// agent_velocity_unlocked
// file libslack/agent.c line 1370
signed int agent_velocity_unlocked(struct Agent *agent, signed int fd);
// agent_wrlock
// file libslack/agent.c line 579
signed int agent_wrlock(const struct Agent *agent);
// alert
// file libslack/err.c line 456
void alert(signed int priority, const char *format, ...);
// alertsys
// file libslack/err.c line 677
void alertsys(signed int priority, const char *format, ...);
// asprintf
// file libslack/str.c line 6826
signed int asprintf(char **str, const char *format, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// bin
// file libslack/str.c line 6284
signed int bin(const char *str);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// build_sockopts
// file libslack/net.c line 286
static struct sockopt_t * build_sockopts(struct sockopt_t *sockopts, signed int *rcvbufsz, signed int *sndbufsz);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chomp
// file libslack/str.c line 6204
signed int chomp(char *str);
// chop
// file libslack/str.c line 6113
signed int chop(char *str);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// consume
// file libslack/map.c line 2517
void * consume(void *arg);
// contract
// file libslack/list.c line 296
static signed int contract(struct List *list, signed long int index, unsigned long int range);
// contract_link1
// file libslack/str.c line 475
static signed int contract_link1(struct String *str, signed long int index_link1, unsigned long int range_link1);
// coproc_close
// file libslack/coproc.c line 348
signed int coproc_close(signed int pid, signed int *to, signed int *from, signed int *err);
// coproc_open
// file libslack/coproc.c line 216
signed int coproc_open(signed int *to, signed int *from, signed int *err, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data);

//
void action_object(void *);
// coproc_pty_close
// file libslack/coproc.c line 464
signed int coproc_pty_close(signed int pid, signed int *masterfd, const char *slavename);
// coproc_pty_open
// file libslack/coproc.c line 405
signed int coproc_pty_open(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data);

//
void action_object(void *);
// cstr
// file libslack/str.h line 82
char * cstr(const struct String *str);
// cstrcat
// file libslack/str.c line 6689
char * cstrcat(char *dst, const char *src);
// cstrchr
// file libslack/str.c line 6714
char * cstrchr(const char *str, signed int c);
// cstrcpy
// file libslack/str.c line 6666
char * cstrcpy(char *dst, const char *src);
// cstrpbrk
// file libslack/str.c line 6736
char * cstrpbrk(const char *str, const char *brk);
// cstrrchr
// file libslack/str.c line 6762
char * cstrrchr(const char *str, signed int c);
// cstrstr
// file libslack/str.c line 6787
char * cstrstr(const char *str, const char *srch);
// daemon_absolute_path
// file libslack/daemon.c line 273
char * daemon_absolute_path(const char *path);
// daemon_become_user
// file libslack/daemon.c line 233
signed int daemon_become_user(unsigned int uid, unsigned int gid, char *user);
// daemon_check_path
// file libslack/daemon.c line 395
static signed int daemon_check_path(char *path, char *explanation, unsigned long int explanation_size, signed int level);
// daemon_close
// file libslack/daemon.c line 1038
signed int daemon_close(void);
// daemon_construct_pidfile
// file libslack/daemon.c line 598
static signed int daemon_construct_pidfile(const char *name, char **pidfile);
// daemon_getpid
// file libslack/daemon.c line 1069
signed int daemon_getpid(const char *name);
// daemon_init
// file libslack/daemon.c line 876
signed int daemon_init(const char *name);
// daemon_is_running
// file libslack/daemon.c line 1126
signed int daemon_is_running(const char *name);
// daemon_lock_pidfile
// file libslack/daemon.c line 633
static signed int daemon_lock_pidfile(char *pidfile);
// daemon_parse_config
// file libslack/daemon.c line 525
void * daemon_parse_config(const char *path, void *obj, void (*parser)(void *, const char *, char *, unsigned long int));
// daemon_parse_config::parser_object
//
void parser_object(void *, const char *, char *, unsigned long int);
// daemon_path_is_safe
// file libslack/daemon.c line 490
signed int daemon_path_is_safe(const char *path, char *explanation, unsigned long int explanation_size);
// daemon_pidfile
// file libslack/daemon.c line 790
signed int daemon_pidfile(const char *name);
// daemon_pidfile_unlocked
// file libslack/daemon.c line 728
static signed int daemon_pidfile_unlocked(const char *name);
// daemon_prevent_core
// file libslack/daemon.c line 169
signed int daemon_prevent_core(void);
// daemon_revoke_privileges
// file libslack/daemon.c line 200
signed int daemon_revoke_privileges(void);
// daemon_started_by_inetd
// file libslack/daemon.c line 149
signed int daemon_started_by_inetd(void);
// daemon_started_by_init
// file libslack/daemon.c line 130
signed int daemon_started_by_init(void);
// daemon_stop
// file libslack/daemon.c line 1195
signed int daemon_stop(const char *name);
// debug_invoke
// file libslack/locker.c line 243
static signed int debug_invoke(const char *name, signed int (*action)(void *), void *lock);
// debug_invoke::action_object
//
signed int action_object(void *);
// debug_level_match
// file libslack/err.c line 250
static signed int debug_level_match(unsigned long int level);
// debug_pthread_mutex_lock
// file libslack/locker.c line 261
static signed int debug_pthread_mutex_lock(union anonymous_11 *mutex);
// debug_pthread_mutex_trylock
// file libslack/locker.c line 256
static signed int debug_pthread_mutex_trylock(union anonymous_11 *mutex);
// debug_pthread_mutex_unlock
// file libslack/locker.c line 266
static signed int debug_pthread_mutex_unlock(union anonymous_11 *mutex);
// debug_pthread_rwlock_rdlock
// file libslack/locker.c line 307
static signed int debug_pthread_rwlock_rdlock(union anonymous_12 *rwlock);
// debug_pthread_rwlock_tryrdlock
// file libslack/locker.c line 302
static signed int debug_pthread_rwlock_tryrdlock(union anonymous_12 *rwlock);
// debug_pthread_rwlock_trywrlock
// file libslack/locker.c line 312
static signed int debug_pthread_rwlock_trywrlock(union anonymous_12 *rwlock);
// debug_pthread_rwlock_unlock
// file libslack/locker.c line 322
static signed int debug_pthread_rwlock_unlock(union anonymous_12 *rwlock);
// debug_pthread_rwlock_wrlock
// file libslack/locker.c line 317
static signed int debug_pthread_rwlock_wrlock(union anonymous_12 *rwlock);
// debugf
// file libslack/err.c line 263
void debugf(unsigned long int level, const char *format, ...);
// debugsysf
// file libslack/err.c line 514
void debugsysf(unsigned long int level, const char *format, ...);
// decode
// file libslack/str.h line 226
struct String * decode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// decode_with_locker
// file libslack/str.c line 5738
struct String * decode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// direct_cmp
// file libslack/map.c line 2471
static signed int direct_cmp(signed int a, signed int b);
// direct_copy
// file libslack/map.c line 2466
static signed int direct_copy(signed int key);
// direct_hash
// file libslack/map.c line 2476
static unsigned long int direct_hash(unsigned long int size, signed int key);
// dlink_alloc
// file libslack/link.c line 489
void * dlink_alloc(void **freelist);
// dlink_free
// file libslack/link.c line 539
void * dlink_free(void **freelist, void *item);
// dlink_freelist_attach
// file libslack/link.c line 428
void * dlink_freelist_attach(void *freelist1, void *freelist2);
// dlink_freelist_init
// file libslack/link.c line 363
void * dlink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size);
// dlink_has_next
// file libslack/link.c line 143
signed int dlink_has_next(void *link);
// dlink_has_prev
// file libslack/link.c line 181
signed int dlink_has_prev(void *link);
// dlink_insert
// file libslack/link.h line 51
void * dlink_insert(void *link, void *item);
// dlink_next
// file libslack/link.h line 47
void * dlink_next(void *link);
// dlink_prev
// file libslack/link.c line 200
void * dlink_prev(void *link);
// dlink_remove
// file libslack/link.h line 53
void * dlink_remove(void *link);
// do_decode_with_locker
// file libslack/str.c line 5388
static struct String * do_decode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable);
// do_encode_with_locker
// file libslack/str.c line 5336
static struct String * do_encode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable);
// do_exec
// file libslack/coproc.c line 159
static void do_exec(signed int has_meta, const char *cmd, char * const *argv, char * const *envv);
// do_split_with_locker
// file libslack/str.c line 3966
static struct List * do_split_with_locker(struct Locker *locker, const char *str, signed long int length, const char *delim);
// do_tr_compile_table
// file libslack/str.c line 2680
static struct StringTR * do_tr_compile_table(struct StringTR *table, const char *from, signed long int fromlen, const char *to, signed long int tolen, signed int option);
// do_tr_compiled
// file libslack/str.c line 2866
static signed int do_tr_compiled(unsigned char *str, unsigned long int *length, struct StringTR *table);
// dump
// file libslack/err.c line 411
void dump(const char *format, ...);
// dumpsys
// file libslack/err.c line 638
void dumpsys(const char *format, ...);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// encode
// file libslack/str.h line 224
struct String * encode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// encode_with_locker
// file libslack/str.c line 5704
struct String * encode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// endgrent
// file /usr/include/grp.h line 70
extern void endgrent(void);
// endpwent
// file /usr/include/pwd.h line 78
extern void endpwent(void);
// error
// file libslack/err.c line 316
signed int error(const char *format, ...);
// errorsys
// file libslack/err.c line 559
signed int errorsys(const char *format, ...);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expand
// file libslack/list.c line 275
static signed int expand(struct List *list, signed long int index, unsigned long int range);
// expand_link1
// file libslack/str.c line 454
static signed int expand_link1(struct String *str, signed long int index_link1, unsigned long int range_link1);
// expire
// file libslack/agent.c line 1957
static signed int expire(struct Agent *agent);
// expire::1::1::action_object
//
signed int action_object(struct Agent *, void *);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fatal
// file libslack/err.c line 367
void fatal(const char *format, ...);
// fatalsys
// file libslack/err.c line 599
void fatalsys(const char *format, ...);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fcntl_clear_flag
// file libslack/fio.c line 399
signed int fcntl_clear_flag(signed int fd, signed int flag);
// fcntl_lock
// file libslack/fio.h line 41
signed int fcntl_lock(signed int fd, signed int cmd, signed int type, signed int whence, signed int start, signed int len);
// fcntl_set_flag
// file libslack/fio.c line 376
signed int fcntl_set_flag(signed int fd, signed int flag);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetline
// file libslack/fio.c line 122
char * fgetline(char *line, unsigned long int size, struct _IO_FILE *stream);
// fgetline_unlocked
// file libslack/fio.c line 143
char * fgetline_unlocked(char *line, unsigned long int size, struct _IO_FILE *stream);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_exists
// file libslack/fio.c line 503
signed int fifo_exists(const char *path, signed int prepare);
// fifo_has_reader
// file libslack/fio.c line 535
signed int fifo_has_reader(const char *path, signed int prepare);
// fifo_open
// file libslack/fio.c line 598
signed int fifo_open(const char *path, unsigned int mode, signed int lock, signed int *writefd);
// flockfile
// file /usr/include/stdio.h line 912
extern void flockfile(struct _IO_FILE *);
// fmt
// file libslack/str.c line 3757
struct List * fmt(const char *str, unsigned long int line_width, enum StringAlignment alignment);
// fmt_with_locker
// file libslack/str.c line 3773
struct List * fmt_with_locker(struct Locker *locker, const char *str, unsigned long int line_width, enum StringAlignment alignment);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fpathconf
// file /usr/include/unistd.h line 616
extern signed long int fpathconf(signed int, signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// fstat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat_link1(signed int __fd_link1, struct stat *__statbuf_link1);
// funlockfile
// file /usr/include/stdio.h line 919
extern void funlockfile(struct _IO_FILE *);
// getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
static inline signed int getc_unlocked(struct _IO_FILE *__fp);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getegid
// file /usr/include/unistd.h line 684
extern unsigned int getegid(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getgroups
// file /usr/include/unistd.h line 689
extern signed int getgroups(signed int, unsigned int *);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// getopt_long
// file libslack/getopt.h line 139
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getprotonamebysocktype
// file libslack/net.c line 496
static const char * getprotonamebysocktype(signed int socktype);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(signed int, struct rlimit *);
// getservbyname_r
// file /usr/include/netdb.h line 312
extern signed int getservbyname_r(const char *, const char *, struct servent *, char *, unsigned long int, struct servent ** restrict );
// getservportbynameandtype
// file libslack/net.c line 506
static unsigned short int getservportbynameandtype(const char *name, signed int type);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// groupname2gid
// file libslack/pseudo.c line 174
static signed int groupname2gid(const char *groupname);
// grow
// file libslack/list.c line 218
static signed int grow(struct List *list, unsigned long int items);
// grow_link1
// file libslack/str.c line 397
static signed int grow_link1(struct String *str, unsigned long int bytes);
// handle_debug_option
// file libslack/prog.c line 1719
static void handle_debug_option(signed int *arg);
// handle_verbose_option
// file libslack/prog.c line 1714
static void handle_verbose_option(signed int *arg);
// hash
// file libslack/map.c line 217
static unsigned long int hash(unsigned long int size, const void *key);
// hex
// file libslack/str.c line 6370
signed int hex(const char *str);
// hsort
// file libslack/hsort.c line 201
void hsort(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *));
// hsort::cmp_object
//
signed int cmp_object(const void *, const void *);
// hsort_closure
// file libslack/hsort.c line 295
void hsort_closure(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *, const void *), const void *data);
// hsort_closure::cmp_object
//
signed int cmp_object(const void *, const void *, const void *);
// if_indextoname
// file /usr/include/net/if.h line 194
extern char * if_indextoname(unsigned int, char *);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// iface_release
// file libslack/net.c line 2007
static void iface_release(struct net_interface_t *iface);
// inet6_required
// file libslack/net.c line 468
static signed int inet6_required(void);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// install
// file libslack/agent.c line 1639
static void install(struct action_t **parent, struct action_t *action);
// int_arg
// file libslack/prog.c line 1862
static signed int int_arg(const char *argument);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_multicast
// file libslack/net.c line 555
static signed int is_multicast(struct sockaddr *address);
// iterate_builtin
// file libslack/map.c line 2548
void * iterate_builtin(void *arg);
// iterate_rdlocked
// file libslack/map.c line 2583
void * iterate_rdlocked(void *arg);
// iterate_wrlocked
// file libslack/map.c line 2610
void * iterate_wrlocked(void *arg);
// join
// file libslack/str.c line 4465
struct String * join(const struct List *list, const char *delim);
// join_with_locker
// file libslack/str.c line 4481
struct String * join_with_locker(struct Locker *locker, const struct List *list, const char *delim);
// key_cmp
// file libslack/prop.c line 192
static signed int key_cmp(const char **a, const char **b);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// killitems
// file libslack/list.c line 337
static void killitems(struct List *list, unsigned long int index, unsigned long int range);
// lc
// file libslack/str.c line 5810
char * lc(char *str);
// lcfirst
// file libslack/str.c line 5885
char * lcfirst(char *str);
// limit_arg
// file libslack/lim.c line 238
signed long int limit_arg(void);
// limit_canon
// file libslack/lim.c line 429
signed long int limit_canon(void);
// limit_child
// file libslack/lim.c line 254
signed long int limit_child(void);
// limit_chown
// file libslack/lim.c line 801
signed long int limit_chown(void);
// limit_fcanon
// file libslack/lim.c line 413
signed long int limit_fcanon(signed int fd);
// limit_fchown
// file libslack/lim.c line 785
signed long int limit_fchown(signed int fd);
// limit_finput
// file libslack/lim.c line 461
signed long int limit_finput(signed int fd);
// limit_flink
// file libslack/lim.c line 557
signed long int limit_flink(signed int fd);
// limit_fname
// file libslack/lim.c line 607
signed long int limit_fname(signed int fd);
// limit_fnotrunc
// file libslack/lim.c line 737
signed long int limit_fnotrunc(signed int fd);
// limit_fpath
// file libslack/lim.c line 657
signed long int limit_fpath(signed int fd);
// limit_fpathconf
// file libslack/lim.c line 217
static signed long int limit_fpathconf(signed int limit, signed int fd);
// limit_fpipe
// file libslack/lim.c line 705
signed long int limit_fpipe(signed int fd);
// limit_fvdisable
// file libslack/lim.c line 509
signed long int limit_fvdisable(signed int fd);
// limit_group
// file libslack/lim.c line 286
signed long int limit_group(void);
// limit_input
// file libslack/lim.c line 477
signed long int limit_input(void);
// limit_job
// file libslack/lim.c line 349
signed long int limit_job(void);
// limit_link
// file libslack/lim.c line 573
signed long int limit_link(void);
// limit_name
// file libslack/lim.c line 623
signed long int limit_name(void);
// limit_notrunc
// file libslack/lim.c line 753
signed long int limit_notrunc(void);
// limit_open
// file libslack/lim.h line 34
signed long int limit_open(void);
// limit_path
// file libslack/lim.h line 57
signed long int limit_path(void);
// limit_pathconf
// file libslack/lim.c line 193
static signed long int limit_pathconf(signed int limit, const char *path);
// limit_pcanon
// file libslack/lim.c line 397
signed long int limit_pcanon(const char *path);
// limit_pchown
// file libslack/lim.c line 769
signed long int limit_pchown(const char *path);
// limit_pinput
// file libslack/lim.c line 445
signed long int limit_pinput(const char *path);
// limit_plink
// file libslack/lim.c line 541
signed long int limit_plink(const char *path);
// limit_pname
// file libslack/lim.c line 590
signed long int limit_pname(const char *path);
// limit_pnotrunc
// file libslack/lim.c line 721
signed long int limit_pnotrunc(const char *path);
// limit_ppath
// file libslack/lim.c line 640
signed long int limit_ppath(const char *path);
// limit_ppipe
// file libslack/lim.c line 689
signed long int limit_ppipe(const char *path);
// limit_pvdisable
// file libslack/lim.c line 493
signed long int limit_pvdisable(const char *path);
// limit_save_ids
// file libslack/lim.c line 365
signed long int limit_save_ids(void);
// limit_stream
// file libslack/lim.c line 318
signed long int limit_stream(void);
// limit_sysconf
// file libslack/lim.c line 169
static signed long int limit_sysconf(signed int limit);
// limit_tick
// file libslack/lim.c line 270
signed long int limit_tick(void);
// limit_tzname
// file libslack/lim.c line 334
signed long int limit_tzname(void);
// limit_vdisable
// file libslack/lim.c line 525
signed long int limit_vdisable(void);
// limit_version
// file libslack/lim.c line 381
signed long int limit_version(void);
// list_append
// file libslack/slack/list.h line 81
struct List * list_append(struct List *list, void *item);
// list_append_int
// file libslack/list.c line 1307
struct List * list_append_int(struct List *list, signed int item);
// list_append_int_unlocked
// file libslack/list.c line 1322
struct List * list_append_int_unlocked(struct List *list, signed int item);
// list_append_list
// file libslack/list.c line 1339
struct List * list_append_list(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_append_list::copy_object
//
void * copy_object(const void *);
// list_append_list_unlocked
// file libslack/list.c line 1355
struct List * list_append_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_append_list_unlocked::copy_object
//
void * copy_object(const void *);
// list_append_unlocked
// file libslack/list.c line 1292
struct List * list_append_unlocked(struct List *list, void *item);
// list_apply
// file libslack/list.c line 2245
void list_apply(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply::action_object
//
void action_object(void *, unsigned long int *, void *);
// list_apply_rdlocked
// file libslack/list.c line 2262
void list_apply_rdlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_rdlocked::action_object
//
void action_object(void *, unsigned long int *, void *);
// list_apply_unlocked
// file libslack/list.c line 2327
void list_apply_unlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_unlocked::action_object
//
void action_object(void *, unsigned long int *, void *);
// list_apply_wrlocked
// file libslack/list.c line 2295
void list_apply_wrlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data);
// list_apply_wrlocked::action_object
//
void action_object(void *, unsigned long int *, void *);
// list_break
// file libslack/list.c line 2950
void list_break(struct List *list);
// list_copy
// file libslack/list.c line 418
struct List * list_copy(const struct List *src, void * (*copy)(const void *));
// list_copy::copy_object
//
void * copy_object(const void *);
// list_copy_with_locker
// file libslack/list.c line 513
struct List * list_copy_with_locker(struct Locker *locker, const struct List *src, void * (*copy)(const void *));
// list_copy_with_locker::copy_object
//
void * copy_object(const void *);
// list_create
// file libslack/slack/list.h line 44
struct List * list_create(void (*destroy)(void *));
// list_create::destroy_object
//
void destroy_object(void *);
// list_create_with_locker
// file libslack/list.c line 434
struct List * list_create_with_locker(struct Locker *locker, void (*destroy)(void *));
// list_create_with_locker::destroy_object
//
void destroy_object(void *);
// list_destroy
// file libslack/slack/list.h line 56
void * list_destroy(struct List **list);
// list_disown
// file libslack/list.c line 703
void (*list_disown(struct List *list))(void *);

//


//


//

// list_disown::1::destroy_object
//
void destroy_object(void *);
// list_disown_unlocked
// file libslack/list.c line 732
void (*list_disown_unlocked(struct List *list))(void *);

//

// list_disown_unlocked::1::destroy_object
//
void destroy_object(void *);
// list_empty
// file libslack/list.c line 846
signed int list_empty(const struct List *list);
// list_empty_unlocked
// file libslack/list.c line 875
signed int list_empty_unlocked(const struct List *list);
// list_extract
// file libslack/list.c line 1669
struct List * list_extract(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract::copy_object
//
void * copy_object(const void *);
// list_extract_unlocked
// file libslack/list.c line 1684
struct List * list_extract_unlocked(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract_unlocked::copy_object
//
void * copy_object(const void *);
// list_extract_with_locker
// file libslack/list.c line 1700
struct List * list_extract_with_locker(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_extract_with_locker::copy_object
//
void * copy_object(const void *);
// list_extract_with_locker_unlocked
// file libslack/list.c line 1730
struct List * list_extract_with_locker_unlocked(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));

//

// list_extract_with_locker_unlocked::copy_object
//
void * copy_object(const void *);
// list_grep
// file libslack/list.c line 2461
struct List * list_grep(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep::grep_object
//
signed int grep_object(void *, unsigned long int *, void *);
// list_grep_unlocked
// file libslack/list.c line 2476
struct List * list_grep_unlocked(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_unlocked::grep_object
//
signed int grep_object(void *, unsigned long int *, void *);
// list_grep_with_locker
// file libslack/list.c line 2492
struct List * list_grep_with_locker(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_with_locker::grep_object
//
signed int grep_object(void *, unsigned long int *, void *);
// list_grep_with_locker_unlocked
// file libslack/list.c line 2525
struct List * list_grep_with_locker_unlocked(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data);
// list_grep_with_locker_unlocked::grep_object
//
signed int grep_object(void *, unsigned long int *, void *);
// list_has_next
// file libslack/list.c line 2922
signed int list_has_next(struct List *list);
// list_insert
// file libslack/list.c line 1099
struct List * list_insert(struct List *list, signed long int index, void *item);
// list_insert_int
// file libslack/list.c line 1160
struct List * list_insert_int(struct List *list, signed long int index, signed int item);
// list_insert_int_unlocked
// file libslack/list.c line 1175
struct List * list_insert_int_unlocked(struct List *list, signed long int index, signed int item);
// list_insert_list
// file libslack/list.c line 1195
struct List * list_insert_list(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *));
// list_insert_list::copy_object
//
void * copy_object(const void *);
// list_insert_list_unlocked
// file libslack/list.c line 1241
struct List * list_insert_list_unlocked(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *));
// list_insert_list_unlocked::copy_object
//
void * copy_object(const void *);
// list_insert_unlocked
// file libslack/list.c line 1128
struct List * list_insert_unlocked(struct List *list, signed long int index, void *item);
// list_item
// file libslack/slack/list.h line 61
void * list_item(const struct List *list, signed long int index);
// list_item_int
// file libslack/list.c line 815
signed int list_item_int(const struct List *list, signed long int index);
// list_item_int_unlocked
// file libslack/list.c line 830
signed int list_item_int_unlocked(const struct List *list, signed long int index);
// list_item_unlocked
// file libslack/list.c line 787
void * list_item_unlocked(const struct List *list, signed long int index);
// list_last
// file libslack/list.c line 942
signed long int list_last(const struct List *list);
// list_last_unlocked
// file libslack/list.c line 971
signed long int list_last_unlocked(const struct List *list);
// list_length
// file libslack/slack/list.h line 67
signed long int list_length(const struct List *list);
// list_length_unlocked
// file libslack/list.c line 923
signed long int list_length_unlocked(const struct List *list);
// list_make
// file libslack/list.c line 379
struct List * list_make(void (*destroy)(void *), ...);
// list_make::destroy_object
//
void destroy_object(void *);
// list_make_with_locker
// file libslack/list.c line 461
struct List * list_make_with_locker(struct Locker *locker, void (*destroy)(void *), ...);
// list_make_with_locker::destroy_object
//
void destroy_object(void *);
// list_map
// file libslack/list.c line 2357
struct List * list_map(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map::destroy_object
//
void destroy_object(void *);
// list_map::map_object
//
void * map_object(void *, unsigned long int *, void *);
// list_map_unlocked
// file libslack/list.c line 2372
struct List * list_map_unlocked(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_unlocked::destroy_object
//
void destroy_object(void *);
// list_map_unlocked::map_object
//
void * map_object(void *, unsigned long int *, void *);
// list_map_with_locker
// file libslack/list.c line 2388
struct List * list_map_with_locker(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_with_locker::destroy_object
//
void destroy_object(void *);
// list_map_with_locker::map_object
//
void * map_object(void *, unsigned long int *, void *);
// list_map_with_locker_unlocked
// file libslack/list.c line 2421
struct List * list_map_with_locker_unlocked(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data);
// list_map_with_locker_unlocked::destroy_object
//
void destroy_object(void *);
// list_map_with_locker_unlocked::map_object
//
void * map_object(void *, unsigned long int *, void *);
// list_next
// file libslack/list.c line 2972
void * list_next(struct List *list);
// list_next_int
// file libslack/list.c line 2990
signed int list_next_int(struct List *list);
// list_own
// file libslack/list.c line 652
signed int list_own(struct List *list, void (*destroy)(void *));
// list_own::destroy_object
//
void destroy_object(void *);
// list_own_unlocked
// file libslack/list.c line 680
signed int list_own_unlocked(struct List *list, void (*destroy)(void *));
// list_own_unlocked::destroy_object
//
void destroy_object(void *);
// list_pop
// file libslack/list.c line 1841
void * list_pop(struct List *list);
// list_pop_int
// file libslack/list.c line 1903
signed int list_pop_int(struct List *list);
// list_pop_int_unlocked
// file libslack/list.c line 1918
signed int list_pop_int_unlocked(struct List *list);
// list_pop_unlocked
// file libslack/list.c line 1870
void * list_pop_unlocked(struct List *list);
// list_prepend
// file libslack/list.c line 1371
struct List * list_prepend(struct List *list, void *item);
// list_prepend_int
// file libslack/list.c line 1401
struct List * list_prepend_int(struct List *list, signed int item);
// list_prepend_int_unlocked
// file libslack/list.c line 1417
struct List * list_prepend_int_unlocked(struct List *list, signed int item);
// list_prepend_list
// file libslack/list.c line 1434
struct List * list_prepend_list(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_prepend_list::copy_object
//
void * copy_object(const void *);
// list_prepend_list_unlocked
// file libslack/list.c line 1450
struct List * list_prepend_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *));
// list_prepend_list_unlocked::copy_object
//
void * copy_object(const void *);
// list_prepend_unlocked
// file libslack/list.c line 1386
struct List * list_prepend_unlocked(struct List *list, void *item);
// list_push
// file libslack/list.c line 1780
struct List * list_push(struct List *list, void *item);
// list_push_int
// file libslack/list.c line 1810
struct List * list_push_int(struct List *list, signed int item);
// list_push_int_unlocked
// file libslack/list.c line 1825
struct List * list_push_int_unlocked(struct List *list, signed int item);
// list_push_unlocked
// file libslack/list.c line 1795
struct List * list_push_unlocked(struct List *list, void *item);
// list_query
// file libslack/list.c line 2566
signed long int list_query(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data);
// list_query::query_object
//
signed int query_object(void *, unsigned long int *, void *);
// list_query_unlocked
// file libslack/list.c line 2595
signed long int list_query_unlocked(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data);
// list_query_unlocked::query_object
//
signed int query_object(void *, unsigned long int *, void *);
// list_rdlock
// file libslack/list.c line 548
signed int list_rdlock(const struct List *list);
// list_release
// file libslack/list.c line 602
void list_release(struct List *list);
// list_remove
// file libslack/list.c line 993
struct List * list_remove(struct List *list, signed long int index);
// list_remove_current
// file libslack/list.c line 3010
void list_remove_current(struct List *list);
// list_remove_range
// file libslack/list.c line 1027
struct List * list_remove_range(struct List *list, signed long int index, signed long int range);
// list_remove_range_unlocked
// file libslack/list.c line 1057
struct List * list_remove_range_unlocked(struct List *list, signed long int index, signed long int range);
// list_remove_unlocked
// file libslack/list.c line 1008
struct List * list_remove_unlocked(struct List *list, signed long int index);
// list_replace
// file libslack/list.c line 1469
struct List * list_replace(struct List *list, signed long int index, signed long int range, void *item);
// list_replace_int
// file libslack/list.c line 1538
struct List * list_replace_int(struct List *list, signed long int index, signed long int range, signed int item);
// list_replace_int_unlocked
// file libslack/list.c line 1553
struct List * list_replace_int_unlocked(struct List *list, signed long int index, signed long int range, signed int item);
// list_replace_list
// file libslack/list.c line 1573
struct List * list_replace_list(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *));
// list_replace_list::copy_object
//
void * copy_object(const void *);
// list_replace_list_unlocked
// file libslack/list.c line 1617
struct List * list_replace_list_unlocked(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *));
// list_replace_list_unlocked::copy_object
//
void * copy_object(const void *);
// list_replace_unlocked
// file libslack/list.c line 1498
struct List * list_replace_unlocked(struct List *list, signed long int index, signed long int range, void *item);
// list_shift
// file libslack/list.c line 1934
void * list_shift(struct List *list);
// list_shift_int
// file libslack/list.c line 1996
signed int list_shift_int(struct List *list);
// list_shift_int_unlocked
// file libslack/list.c line 2011
signed int list_shift_int_unlocked(struct List *list);
// list_shift_unlocked
// file libslack/list.c line 1963
void * list_shift_unlocked(struct List *list);
// list_sort
// file libslack/slack/list.h line 123
struct List * list_sort(struct List *list, signed int (*cmp)(const void *, const void *));
// list_sort::cmp_object
//
signed int cmp_object(const void *, const void *);
// list_sort_unlocked
// file libslack/list.c line 2220
struct List * list_sort_unlocked(struct List *list, signed int (*cmp)(const void *, const void *));
// list_sort_unlocked::cmp_object
//
signed int cmp_object(const void *, const void *);
// list_splice
// file libslack/list.c line 2095
struct List * list_splice(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice::copy_object
//
void * copy_object(const void *);
// list_splice_unlocked
// file libslack/list.c line 2110
struct List * list_splice_unlocked(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_unlocked::copy_object
//
void * copy_object(const void *);
// list_splice_with_locker
// file libslack/list.c line 2126
struct List * list_splice_with_locker(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_with_locker::copy_object
//
void * copy_object(const void *);
// list_splice_with_locker_unlocked
// file libslack/list.c line 2159
struct List * list_splice_with_locker_unlocked(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *));
// list_splice_with_locker_unlocked::copy_object
//
void * copy_object(const void *);
// list_unlock
// file libslack/list.c line 586
signed int list_unlock(const struct List *list);
// list_unshift
// file libslack/list.c line 2027
struct List * list_unshift(struct List *list, void *item);
// list_unshift_int
// file libslack/list.c line 2057
struct List * list_unshift_int(struct List *list, signed int item);
// list_unshift_int_unlocked
// file libslack/list.c line 2073
struct List * list_unshift_int_unlocked(struct List *list, signed int item);
// list_unshift_unlocked
// file libslack/list.c line 2042
struct List * list_unshift_unlocked(struct List *list, void *item);
// list_vmake
// file libslack/list.c line 400
struct List * list_vmake(void (*destroy)(void *), void **args);
// list_vmake::destroy_object
//
void destroy_object(void *);
// list_vmake_with_locker
// file libslack/list.c line 482
struct List * list_vmake_with_locker(struct Locker *locker, void (*destroy)(void *), __builtin_va_list args);
// list_vmake_with_locker::destroy_object
//
void destroy_object(void *);
// list_wrlock
// file libslack/list.c line 569
signed int list_wrlock(const struct List *list);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lister_create
// file libslack/list.c line 2629
struct Lister * lister_create(struct List *list);
// lister_create_rdlocked
// file libslack/list.c line 2646
struct Lister * lister_create_rdlocked(struct List *list);
// lister_create_unlocked
// file libslack/list.c line 2693
struct Lister * lister_create_unlocked(const struct List *list);
// lister_create_wrlocked
// file libslack/list.c line 2670
struct Lister * lister_create_wrlocked(struct List *list);
// lister_destroy
// file libslack/list.c line 2765
void * lister_destroy(struct Lister **lister);
// lister_destroy_unlocked
// file libslack/list.c line 2787
void * lister_destroy_unlocked(struct Lister **lister);
// lister_has_next
// file libslack/list.c line 2810
signed int lister_has_next(struct Lister *lister);
// lister_next
// file libslack/list.c line 2829
void * lister_next(struct Lister *lister);
// lister_next_int
// file libslack/list.c line 2847
signed int lister_next_int(struct Lister *lister);
// lister_release
// file libslack/list.c line 2719
void lister_release(struct Lister *lister);
// lister_release_unlocked
// file libslack/list.c line 2746
void lister_release_unlocked(struct Lister *lister);
// lister_remove
// file libslack/list.c line 2868
void lister_remove(struct Lister *lister);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// locker_create
// file libslack/locker.c line 359
struct Locker * locker_create(void *lock, signed int (*tryrdlock)(void *), signed int (*rdlock)(void *), signed int (*trywrlock)(void *), signed int (*wrlock)(void *), signed int (*unlock)(void *));
// locker_create::rdlock_object
//
signed int rdlock_object(void *);
// locker_create::tryrdlock_object
//
signed int tryrdlock_object(void *);
// locker_create::trywrlock_object
//
signed int trywrlock_object(void *);
// locker_create::unlock_object
//
signed int unlock_object(void *);
// locker_create::wrlock_object
//
signed int wrlock_object(void *);
// locker_create_debug_mutex
// file libslack/slack/locker.h line 66
struct Locker * locker_create_debug_mutex(union anonymous_11 *mutex);
// locker_create_debug_rwlock
// file libslack/slack/locker.h line 67
struct Locker * locker_create_debug_rwlock(union anonymous_12 *rwlock);
// locker_create_mutex
// file libslack/slack/locker.h line 64
struct Locker * locker_create_mutex(union anonymous_11 *mutex);
// locker_create_rwlock
// file libslack/slack/locker.h line 65
struct Locker * locker_create_rwlock(union anonymous_12 *rwlock);
// locker_destroy
// file libslack/slack/locker.h line 70
void * locker_destroy(struct Locker **locker);
// locker_rdlock
// file libslack/locker.c line 453
signed int locker_rdlock(struct Locker *locker);
// locker_release
// file libslack/locker.c line 390
void locker_release(struct Locker *locker);
// locker_tryrdlock
// file libslack/locker.c line 435
signed int locker_tryrdlock(struct Locker *locker);
// locker_trywrlock
// file libslack/locker.c line 472
signed int locker_trywrlock(struct Locker *locker);
// locker_unlock
// file libslack/locker.c line 508
signed int locker_unlock(struct Locker *locker);
// locker_wrlock
// file libslack/locker.c line 490
signed int locker_wrlock(struct Locker *locker);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf);
// mail
// file libslack/net.c line 4142
signed int mail(const char *server, const char *sender, const char *recipients, const char *subject, const char *message);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map_add
// file libslack/map.h line 62
signed int map_add(struct Map *map, const void *key, void *value);
// map_add_unlocked
// file libslack/map.c line 887
signed int map_add_unlocked(struct Map *map, const void *key, void *value);
// map_apply
// file libslack/map.h line 99
void map_apply(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply::action_object
//
void action_object(void *, void *, void *);
// map_apply_rdlocked
// file libslack/map.c line 1907
void map_apply_rdlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_rdlocked::action_object
//
void action_object(void *, void *, void *);
// map_apply_unlocked
// file libslack/map.c line 1978
void map_apply_unlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_unlocked::action_object
//
void action_object(void *, void *, void *);
// map_apply_wrlocked
// file libslack/map.c line 1943
void map_apply_wrlocked(struct Map *map, void (*action)(void *, void *, void *), void *data);
// map_apply_wrlocked::action_object
//
void action_object(void *, void *, void *);
// map_break
// file libslack/map.h line 85
void map_break(struct Map *map);
// map_create
// file libslack/map.h line 41
struct Map * map_create(void (*destroy)(void *));
// map_create::destroy_object
//
void destroy_object(void *);
// map_create_generic
// file libslack/map.h line 49
struct Map * map_create_generic(void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic::cmp_object
//
signed int cmp_object(const void *, const void *);
// map_create_generic::copy_object
//
void * copy_object(const void *);
// map_create_generic::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_generic::key_destroy_object
//
void key_destroy_object(void *);
// map_create_generic::value_destroy_object
//
void value_destroy_object(void *);
// map_create_generic_sized
// file libslack/map.c line 450
struct Map * map_create_generic_sized(unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_sized::cmp_object
//
signed int cmp_object(const void *, const void *);
// map_create_generic_sized::copy_object
//
void * copy_object(const void *);
// map_create_generic_sized::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_generic_sized::key_destroy_object
//
void key_destroy_object(void *);
// map_create_generic_sized::value_destroy_object
//
void value_destroy_object(void *);
// map_create_generic_with_locker
// file libslack/map.h line 51
struct Map * map_create_generic_with_locker(struct Locker *locker, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_with_locker::cmp_object
//
signed int cmp_object(const void *, const void *);
// map_create_generic_with_locker::copy_object
//
void * copy_object(const void *);
// map_create_generic_with_locker::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_generic_with_locker::key_destroy_object
//
void key_destroy_object(void *);
// map_create_generic_with_locker::value_destroy_object
//
void value_destroy_object(void *);
// map_create_generic_with_locker_sized
// file libslack/map.c line 482
struct Map * map_create_generic_with_locker_sized(struct Locker *locker, unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *));
// map_create_generic_with_locker_sized::cmp_object
//
signed int cmp_object(const void *, const void *);
// map_create_generic_with_locker_sized::copy_object
//
void * copy_object(const void *);
// map_create_generic_with_locker_sized::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_generic_with_locker_sized::key_destroy_object
//
void key_destroy_object(void *);
// map_create_generic_with_locker_sized::value_destroy_object
//
void value_destroy_object(void *);
// map_create_sized
// file libslack/map.c line 306
struct Map * map_create_sized(unsigned long int size, void (*destroy)(void *));
// map_create_sized::destroy_object
//
void destroy_object(void *);
// map_create_sized_with_hash
// file libslack/map.c line 342
struct Map * map_create_sized_with_hash(unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_sized_with_hash::destroy_object
//
void destroy_object(void *);
// map_create_sized_with_hash::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_with_hash
// file libslack/map.c line 324
struct Map * map_create_with_hash(unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_hash::destroy_object
//
void destroy_object(void *);
// map_create_with_hash::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_with_locker
// file libslack/map.c line 358
struct Map * map_create_with_locker(struct Locker *locker, void (*destroy)(void *));
// map_create_with_locker::destroy_object
//
void destroy_object(void *);
// map_create_with_locker_sized
// file libslack/map.c line 374
struct Map * map_create_with_locker_sized(struct Locker *locker, unsigned long int size, void (*destroy)(void *));
// map_create_with_locker_sized::destroy_object
//
void destroy_object(void *);
// map_create_with_locker_sized_with_hash
// file libslack/map.c line 406
struct Map * map_create_with_locker_sized_with_hash(struct Locker *locker, unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_locker_sized_with_hash::destroy_object
//
void destroy_object(void *);
// map_create_with_locker_sized_with_hash::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_create_with_locker_with_hash
// file libslack/map.c line 390
struct Map * map_create_with_locker_with_hash(struct Locker *locker, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *));
// map_create_with_locker_with_hash::destroy_object
//
void destroy_object(void *);
// map_create_with_locker_with_hash::hash_object
//
unsigned long int hash_object(unsigned long int, const void *);
// map_destroy
// file libslack/map.h line 57
void * map_destroy(struct Map **map);
// map_disown
// file libslack/map.c line 721
void (*map_disown(struct Map *map))(void *);

//


//


//

// map_disown::1::ret_object
//
void ret_object(void *);
// map_disown_unlocked
// file libslack/map.c line 750
void (*map_disown_unlocked(struct Map *map))(void *);

//

// map_disown_unlocked::1::destroy_object
//
void destroy_object(void *);
// map_get
// file libslack/map.h line 70
void * map_get(struct Map *map, const void *key);
// map_get_unlocked
// file libslack/map.h line 71
void * map_get_unlocked(const struct Map *map, const void *key);
// map_has_next
// file libslack/map.h line 84
signed int map_has_next(struct Map *map);
// map_histogram
// file libslack/map.c line 2306
static void map_histogram(const char *name, struct Map *map);
// map_insert
// file libslack/map.c line 938
signed int map_insert(struct Map *map, const void *key, void *value, signed int replace);
// map_insert_unlocked
// file libslack/map.c line 967
signed int map_insert_unlocked(struct Map *map, const void *key, void *value, signed int replace);
// map_keys
// file libslack/map.h line 91
struct List * map_keys(struct Map *map);
// map_keys_unlocked
// file libslack/map.c line 1691
struct List * map_keys_unlocked(struct Map *map);
// map_keys_with_locker
// file libslack/map.c line 1707
struct List * map_keys_with_locker(struct Locker *locker, struct Map *map);
// map_keys_with_locker_unlocked
// file libslack/map.c line 1737
struct List * map_keys_with_locker_unlocked(struct Locker *locker, struct Map *map);
// map_next
// file libslack/map.h line 86
void * map_next(struct Map *map);
// map_next_mapping
// file libslack/map.h line 87
const struct Mapping * map_next_mapping(struct Map *map);
// map_own
// file libslack/map.c line 646
signed int map_own(struct Map *map, void (*destroy)(void *));
// map_own::destroy_object
//
void destroy_object(void *);
// map_own_unlocked
// file libslack/map.c line 675
signed int map_own_unlocked(struct Map *map, void (*destroy)(void *));
// map_own_unlocked::destroy_object
//
void destroy_object(void *);
// map_put
// file libslack/map.c line 904
signed int map_put(struct Map *map, const void *key, void *value);
// map_put_unlocked
// file libslack/map.c line 919
signed int map_put_unlocked(struct Map *map, const void *key, void *value);
// map_rdlock
// file libslack/map.h line 53
signed int map_rdlock(const struct Map *map);
// map_release
// file libslack/map.h line 56
void map_release(struct Map *map);
// map_remove
// file libslack/map.h line 68
signed int map_remove(struct Map *map, const void *key);
// map_remove_current
// file libslack/map.h line 88
void map_remove_current(struct Map *map);
// map_remove_unlocked
// file libslack/map.c line 1061
signed int map_remove_unlocked(struct Map *map, const void *key);
// map_resize
// file libslack/map.c line 795
static signed int map_resize(struct Map *map);
// map_resize::_tmp::return_value_map_disown_unlocked_7_object
//
void return_value_map_disown_unlocked_7_object(void *);
// map_size
// file libslack/map.h line 103
signed long int map_size(struct Map *map);
// map_size_unlocked
// file libslack/map.h line 104
signed long int map_size_unlocked(const struct Map *map);
// map_unlock
// file libslack/map.h line 55
signed int map_unlock(const struct Map *map);
// map_values
// file libslack/map.h line 95
struct List * map_values(struct Map *map);
// map_values_unlocked
// file libslack/map.c line 1799
struct List * map_values_unlocked(struct Map *map);
// map_values_with_locker
// file libslack/map.c line 1815
struct List * map_values_with_locker(struct Locker *locker, struct Map *map);
// map_values_with_locker_unlocked
// file libslack/map.c line 1845
struct List * map_values_with_locker_unlocked(struct Locker *locker, struct Map *map);
// map_wrlock
// file libslack/map.h line 54
signed int map_wrlock(const struct Map *map);
// mapper_create
// file libslack/map.h line 72
struct Mapper * mapper_create(struct Map *map);
// mapper_create_rdlocked
// file libslack/map.h line 73
struct Mapper * mapper_create_rdlocked(struct Map *map);
// mapper_create_unlocked
// file libslack/map.c line 1244
struct Mapper * mapper_create_unlocked(struct Map *map);
// mapper_create_wrlocked
// file libslack/map.h line 74
struct Mapper * mapper_create_wrlocked(struct Map *map);
// mapper_destroy
// file libslack/map.h line 78
void * mapper_destroy(struct Mapper **mapper);
// mapper_destroy_unlocked
// file libslack/map.c line 1341
void * mapper_destroy_unlocked(struct Mapper **mapper);
// mapper_has_next
// file libslack/map.h line 80
signed int mapper_has_next(struct Mapper *mapper);
// mapper_next
// file libslack/map.h line 81
void * mapper_next(struct Mapper *mapper);
// mapper_next_mapping
// file libslack/map.h line 82
const struct Mapping * mapper_next_mapping(struct Mapper *mapper);
// mapper_release
// file libslack/map.h line 76
void mapper_release(struct Mapper *mapper);
// mapper_release_unlocked
// file libslack/map.c line 1300
void mapper_release_unlocked(struct Mapper *mapper);
// mapper_remove
// file libslack/map.h line 83
void mapper_remove(struct Mapper *mapper);
// mapping_create
// file libslack/map.c line 238
static struct Mapping * mapping_create(void *key, void *value, void (*key_destroy)(void *), void (*value_destroy)(void *));
// mapping_create::key_destroy_object
//
void key_destroy_object(void *);
// mapping_create::value_destroy_object
//
void value_destroy_object(void *);
// mapping_key
// file libslack/map.h line 89
const void * mapping_key(const struct Mapping *mapping);
// mapping_release
// file libslack/map.c line 261
static void mapping_release(struct Mapping *mapping);
// mapping_value
// file libslack/map.h line 90
const void * mapping_value(const struct Mapping *mapping);
// measure
// file libslack/agent.c line 2017
static void measure(struct Agent *agent, signed int fd, struct timeval *now);
// mem_create_secure
// file libslack/mem.c line 270
void * mem_create_secure(unsigned long int size);
// mem_create_space
// file libslack/mem.c line 469
void * mem_create_space(unsigned long int size, ...);
// mem_destroy
// file libslack/mem.h line 48
void * mem_destroy(void **mem);
// mem_destroy_secure
// file libslack/mem.c line 373
void * mem_destroy_secure(void **mem);
// mem_release_secure
// file libslack/mem.c line 333
void mem_release_secure(void *mem);
// mem_resize_fn
// file libslack/mem.h line 46
void * mem_resize_fn(void **mem, unsigned long int size);
// mem_space_start
// file libslack/mem.c line 526
unsigned long int mem_space_start(unsigned long int size, ...);
// mem_strdup
// file libslack/mem.h line 54
char * mem_strdup(const char *str);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkfifo
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 349
extern signed int mkfifo(const char *, unsigned int);
// mlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 103
extern signed int mlock(const void *, unsigned long int);
// msg
// file libslack/err.c line 149
void msg(const char *format, ...);
// msg_add_plex
// file libslack/msg.c line 1222
signed int msg_add_plex(struct Msg *mesg, struct Msg *item);
// msg_add_plex_unlocked
// file libslack/msg.c line 1251
signed int msg_add_plex_unlocked(struct Msg *mesg, struct Msg *item);
// msg_create
// file libslack/msg.c line 230
struct Msg * msg_create(signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *));
// msg_create::destroy_object
//
void destroy_object(void *);
// msg_create::out_object
//
void out_object(void *, const void *, unsigned long int);
// msg_create_fd
// file libslack/msg.c line 533
struct Msg * msg_create_fd(signed int fd);
// msg_create_fd_with_locker
// file libslack/msg.c line 549
struct Msg * msg_create_fd_with_locker(struct Locker *locker, signed int fd);
// msg_create_file
// file libslack/msg.c line 763
struct Msg * msg_create_file(const char *path);
// msg_create_file_with_locker
// file libslack/msg.c line 779
struct Msg * msg_create_file_with_locker(struct Locker *locker, const char *path);
// msg_create_plex
// file libslack/msg.c line 1177
struct Msg * msg_create_plex(struct Msg *msg1, struct Msg *msg2);
// msg_create_plex_with_locker
// file libslack/msg.c line 1193
struct Msg * msg_create_plex_with_locker(struct Locker *locker, struct Msg *msg1, struct Msg *msg2);
// msg_create_stderr
// file libslack/msg.c line 579
struct Msg * msg_create_stderr(void);
// msg_create_stderr_with_locker
// file libslack/msg.c line 595
struct Msg * msg_create_stderr_with_locker(struct Locker *locker);
// msg_create_stdout
// file libslack/msg.c line 613
struct Msg * msg_create_stdout(void);
// msg_create_stdout_with_locker
// file libslack/msg.c line 629
struct Msg * msg_create_stdout_with_locker(struct Locker *locker);
// msg_create_syslog
// file libslack/msg.c line 897
struct Msg * msg_create_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// msg_create_syslog_with_locker
// file libslack/msg.c line 913
struct Msg * msg_create_syslog_with_locker(struct Locker *locker, const char *ident, signed int option, signed int facility, signed int priority);
// msg_create_with_locker
// file libslack/msg.c line 246
struct Msg * msg_create_with_locker(struct Locker *locker, signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *));
// msg_create_with_locker::destroy_object
//
void destroy_object(void *);
// msg_create_with_locker::out_object
//
void out_object(void *, const void *, unsigned long int);
// msg_destroy
// file libslack/msg.c line 358
void * msg_destroy(struct Msg **mesg);
// msg_fddata_create
// file libslack/msg.c line 478
static signed int * msg_fddata_create(signed int fd);
// msg_fddata_release
// file libslack/msg.c line 499
static void msg_fddata_release(signed int *data);
// msg_filedata_create
// file libslack/msg.c line 671
static struct MsgFileData * msg_filedata_create(const char *path);
// msg_filedata_init
// file libslack/msg.c line 646
static signed int msg_filedata_init(struct MsgFileData *data, const char *path);
// msg_filedata_release
// file libslack/msg.c line 696
static void msg_filedata_release(struct MsgFileData *data);
// msg_out
// file libslack/msg.h line 50
void msg_out(struct Msg *dst, const char *format, ...);
// msg_out_fd
// file libslack/msg.c line 513
static void msg_out_fd(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_file
// file libslack/msg.c line 717
static void msg_out_file(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_plex
// file libslack/msg.c line 1147
static void msg_out_plex(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_syslog
// file libslack/msg.c line 875
static void msg_out_syslog(void *data, const void *mesg, unsigned long int mesglen);
// msg_out_unlocked
// file libslack/msg.h line 51
void msg_out_unlocked(struct Msg *dst, const char *format, ...);
// msg_plexdata_add
// file libslack/msg.c line 1070
static signed int msg_plexdata_add(struct MsgPlexData *data, struct Msg *mesg);
// msg_plexdata_create
// file libslack/msg.c line 1099
static struct MsgPlexData * msg_plexdata_create(struct Msg *msg1, struct Msg *msg2);
// msg_plexdata_init
// file libslack/msg.c line 1048
static signed int msg_plexdata_init(struct MsgPlexData *data, struct Msg *msg1, struct Msg *msg2);
// msg_plexdata_release
// file libslack/msg.c line 1124
static void msg_plexdata_release(struct MsgPlexData *data);
// msg_rdlock
// file libslack/msg.c line 282
signed int msg_rdlock(struct Msg *mesg);
// msg_release
// file libslack/msg.c line 337
void msg_release(struct Msg *mesg);
// msg_set_timestamp_format
// file libslack/msg.c line 1271
const char * msg_set_timestamp_format(const char *format);
// msg_set_timestamp_format_locker
// file libslack/msg.c line 1304
signed int msg_set_timestamp_format_locker(struct Locker *locker);
// msg_sysdata_create
// file libslack/msg.c line 832
static struct MsgSyslogData * msg_sysdata_create(const char *ident, signed int option, signed int facility, signed int priority);
// msg_sysdata_init
// file libslack/msg.c line 808
static signed int msg_sysdata_init(struct MsgSyslogData *data, const char *ident, signed int option, signed int facility, signed int priority);
// msg_sysdata_release
// file libslack/msg.c line 857
static void msg_sysdata_release(struct MsgSyslogData *data);
// msg_syslog_set_facility
// file libslack/msg.c line 941
struct Msg * msg_syslog_set_facility(struct Msg *mesg, signed int facility);
// msg_syslog_set_facility_unlocked
// file libslack/msg.c line 971
struct Msg * msg_syslog_set_facility_unlocked(struct Msg *mesg, signed int facility);
// msg_syslog_set_priority
// file libslack/msg.c line 995
struct Msg * msg_syslog_set_priority(struct Msg *mesg, signed int priority);
// msg_syslog_set_priority_unlocked
// file libslack/msg.h line 67
struct Msg * msg_syslog_set_priority_unlocked(struct Msg *mesg, signed int priority);
// msg_unlock
// file libslack/msg.h line 47
signed int msg_unlock(struct Msg *mesg);
// msg_wrlock
// file libslack/msg.h line 46
signed int msg_wrlock(struct Msg *mesg);
// mt_test
// file libslack/map.c line 2675
void mt_test(signed int test, struct Locker *locker);
// munlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 106
extern signed int munlock(const void *, unsigned long int);
// nap
// file libslack/fio.c line 350
signed int nap(signed long int sec, signed long int usec);
// net_client
// file libslack/net.c line 369
signed int net_client(const char *host, const char *service, unsigned short int port, signed long int timeout, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_client_connect
// file libslack/net.c line 709
static signed int net_client_connect(struct sockaddr *remoteaddr, unsigned long int remotesize, unsigned short int localport, signed int type, signed int protocol, signed int timeout, struct sockopt_t *sockopts);
// net_create_client
// file libslack/net.c line 825
signed int net_create_client(const char *host, const char *service, unsigned short int port, unsigned short int localport, signed int type, signed int protocol, signed long int timeout, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize);
// net_create_server
// file libslack/net.c line 577
signed int net_create_server(const char *interface, const char *service, unsigned short int port, signed int type, signed int protocol, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize);
// net_expect
// file libslack/net.c line 3761
signed long int net_expect(signed int sockfd, signed long int timeout, const char *format, ...);
// net_gethostbyname
// file libslack/net.c line 1779
struct hostent * net_gethostbyname(const char *name, struct hostent *hostbuf, void **buf, unsigned long int *size, signed int *herrno);
// net_getservbyname
// file libslack/net.c line 1895
struct servent * net_getservbyname(const char *name, const char *proto, struct servent *servbuf, void **buf, unsigned long int *size);
// net_in6addr
// file libslack/net.c line 457
static struct sockaddr * net_in6addr(struct sockaddr_in6 *in6, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port);
// net_inaddr
// file libslack/net.c line 447
static struct sockaddr * net_inaddr(struct sockaddr_in *in, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port);
// net_interfaces
// file libslack/net.c line 2039
struct List * net_interfaces(void);
// net_interfaces_by_family
// file libslack/net.c line 2080
struct List * net_interfaces_by_family(signed int family);
// net_interfaces_by_family_with_locker
// file libslack/net.c line 2096
struct List * net_interfaces_by_family_with_locker(signed int family, struct Locker *locker);
// net_interfaces_with_locker
// file libslack/net.c line 2055
struct List * net_interfaces_with_locker(struct Locker *locker);
// net_multicast_get_interface
// file libslack/net.c line 1389
signed int net_multicast_get_interface(signed int sockfd);
// net_multicast_get_loopback
// file libslack/net.c line 1509
signed int net_multicast_get_loopback(signed int sockfd);
// net_multicast_get_ttl
// file libslack/net.c line 1603
signed int net_multicast_get_ttl(signed int sockfd);
// net_multicast_join
// file libslack/net.c line 1158
signed int net_multicast_join(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_leave
// file libslack/net.c line 1238
signed int net_multicast_leave(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_receiver
// file libslack/net.c line 1054
signed int net_multicast_receiver(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex);
// net_multicast_sender
// file libslack/net.c line 995
signed int net_multicast_sender(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex, signed int ttl, unsigned int noloopback);
// net_multicast_set_interface
// file libslack/net.c line 1319
signed int net_multicast_set_interface(signed int sockfd, const char *ifname, unsigned int ifindex);
// net_multicast_set_loopback
// file libslack/net.c line 1465
signed int net_multicast_set_loopback(signed int sockfd, unsigned int loopback);
// net_multicast_set_ttl
// file libslack/net.c line 1561
signed int net_multicast_set_ttl(signed int sockfd, signed int ttl);
// net_options
// file libslack/net.c line 1989
signed int net_options(signed int sockfd, struct sockopt_t *sockopts);
// net_pack
// file libslack/net.c line 2706
signed long int net_pack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...);
// net_packto
// file libslack/net.c line 2760
signed long int net_packto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, ...);
// net_read
// file libslack/net.c line 3687
signed long int net_read(signed int sockfd, signed long int timeout, char *buf, unsigned long int count);
// net_rudp_transact
// file libslack/net.c line 2557
signed long int net_rudp_transact(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, void *ibuf, unsigned long int isize);
// net_rudp_transactwith
// file libslack/net.c line 2582
signed long int net_rudp_transactwith(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, signed int oflags, void *ibuf, unsigned long int isize, signed int iflags, union sockaddr_any_t *addr, unsigned long int addrsize);
// net_send
// file libslack/net.c line 3813
signed long int net_send(signed int sockfd, signed long int timeout, const char *format, ...);
// net_server
// file libslack/net.c line 313
signed int net_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_tos_lowcost
// file libslack/net.c line 1718
signed int net_tos_lowcost(signed int sockfd);
// net_tos_lowdelay
// file libslack/net.c line 1655
signed int net_tos_lowdelay(signed int sockfd);
// net_tos_normal
// file libslack/net.c line 1736
signed int net_tos_normal(signed int sockfd);
// net_tos_reliability
// file libslack/net.c line 1695
signed int net_tos_reliability(signed int sockfd);
// net_tos_throughput
// file libslack/net.c line 1675
signed int net_tos_throughput(signed int sockfd);
// net_udp_client
// file libslack/net.c line 415
signed int net_udp_client(const char *host, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_udp_server
// file libslack/net.c line 392
signed int net_udp_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize);
// net_unaddr
// file libslack/net.c line 439
static struct sockaddr * net_unaddr(struct sockaddr_un *un, unsigned long int family, const char *path);
// net_unpack
// file libslack/net.c line 2818
signed long int net_unpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...);
// net_unpackfrom
// file libslack/net.c line 2873
signed long int net_unpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, ...);
// net_vexpect
// file libslack/net.c line 3784
signed long int net_vexpect(signed int sockfd, signed long int timeout, const char *format, void **args);
// net_vpack
// file libslack/net.c line 2729
signed long int net_vpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args);
// net_vpackto
// file libslack/net.c line 2783
signed long int net_vpackto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, void **args);
// net_vsend
// file libslack/net.c line 3836
signed long int net_vsend(signed int sockfd, signed long int timeout, const char *format, void **args);
// net_vunpack
// file libslack/net.c line 2841
signed long int net_vunpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args);
// net_vunpackfrom
// file libslack/net.c line 2896
signed long int net_vunpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, void **args);
// net_write
// file libslack/net.c line 3720
signed long int net_write(signed int sockfd, signed long int timeout, const char *buf, unsigned long int count);
// new_shargv
// file libslack/coproc.c line 137
static char * const * new_shargv(const char *cmd, char * const *argv);
// next_day
// file libslack/agent.c line 1809
static void next_day(struct Agent *agent);
// next_hour
// file libslack/agent.c line 1846
static void next_hour(struct Agent *agent);
// next_minute
// file libslack/agent.c line 1867
static void next_minute(struct Agent *agent);
// next_second
// file libslack/agent.c line 1888
static void next_second(struct Agent *agent);
// nonblock_off
// file libslack/fio.c line 485
signed int nonblock_off(signed int fd);
// nonblock_on
// file libslack/fio.c line 468
signed int nonblock_on(signed int fd);
// nonblock_set
// file libslack/fio.c line 451
signed int nonblock_set(signed int fd, signed int arg);
// oct
// file libslack/str.c line 6469
signed int oct(const char *str);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// openpty
// file /usr/include/pty.h line 33
extern signed int openpty(signed int *, signed int *, char *, struct termios *, struct winsize *);
// opt_action
// file libslack/prog.c line 1889
static void opt_action(struct Options *options, signed int rc, signed int longindex, const char *argument);
// opt_convert
// file libslack/prog.c line 1762
static struct option * opt_convert(struct Options *options);
// opt_optstring
// file libslack/prog.c line 1806
static char * opt_optstring(struct Options *options);
// opt_process
// file libslack/prog.c line 2051
signed int opt_process(signed int argc, char **argv, struct Options *options, char *msgbuf, unsigned long int bufsize);
// opt_usage
// file libslack/prog.c line 2139
char * opt_usage(char *buf, unsigned long int size, struct Options *options);
// pack
// file libslack/net.c line 3000
signed long int pack(void *buf, unsigned long int size, const char *format, ...);
// pathconf
// file /usr/include/unistd.h line 612
extern signed long int pathconf(const char *, signed int);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// point_cmp
// file libslack/map.c line 2445
static signed int point_cmp(struct Point *a, struct Point *b);
// point_copy
// file libslack/map.c line 2440
static struct Point * point_copy(struct Point *point);
// point_create
// file libslack/map.c line 2427
static struct Point * point_create(signed int x, signed int y);
// point_hash
// file libslack/map.c line 2456
static unsigned long int point_hash(unsigned long int size, struct Point *point);
// point_release
// file libslack/map.c line 2461
static void point_release(struct Point *point);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// pool_alloc
// file libslack/mem.c line 919
void * pool_alloc(struct Pool *pool, unsigned long int size);
// pool_clear
// file libslack/mem.c line 980
void pool_clear(struct Pool *pool);
// pool_clear_secure
// file libslack/mem.c line 859
void pool_clear_secure(struct Pool *pool);
// pool_clear_unlocked
// file libslack/mem.c line 975
static void pool_clear_unlocked(struct Pool *pool);
// pool_clear_with_locker
// file libslack/mem.c line 956
static void pool_clear_with_locker(struct Pool *pool, signed int lock_pool);
// pool_create
// file libslack/mem.c line 616
struct Pool * pool_create(unsigned long int size);
// pool_create_secure
// file libslack/mem.c line 743
struct Pool * pool_create_secure(unsigned long int size);
// pool_create_secure_with_locker
// file libslack/mem.c line 759
struct Pool * pool_create_secure_with_locker(struct Locker *locker, unsigned long int size);
// pool_create_with_locker
// file libslack/mem.c line 632
struct Pool * pool_create_with_locker(struct Locker *locker, unsigned long int size);
// pool_destroy
// file libslack/mem.c line 714
void * pool_destroy(struct Pool **pool);
// pool_destroy_secure
// file libslack/mem.c line 834
void * pool_destroy_secure(struct Pool **pool);
// pool_release
// file libslack/mem.c line 680
void pool_release(struct Pool *pool);
// pool_release_secure
// file libslack/mem.c line 797
void pool_release_secure(struct Pool *pool);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// produce
// file libslack/map.c line 2497
void * produce(void *arg);
// prog_alert
// file libslack/prog.h line 123
struct Msg * prog_alert(void);
// prog_alert_fd
// file libslack/prog.c line 1305
signed int prog_alert_fd(signed int fd);
// prog_alert_file
// file libslack/prog.c line 1367
signed int prog_alert_file(const char *path);
// prog_alert_none
// file libslack/prog.c line 1423
signed int prog_alert_none(void);
// prog_alert_stderr
// file libslack/prog.c line 1350
signed int prog_alert_stderr(void);
// prog_alert_stdout
// file libslack/prog.c line 1333
signed int prog_alert_stdout(void);
// prog_alert_syslog
// file libslack/prog.c line 1395
signed int prog_alert_syslog(const char *id, signed int option, signed int facility, signed int priority);
// prog_author
// file libslack/prog.c line 757
const char * prog_author(void);
// prog_basename
// file libslack/prog.c line 1668
const char * prog_basename(const char *path);
// prog_contact
// file libslack/prog.c line 773
const char * prog_contact(void);
// prog_date
// file libslack/prog.c line 741
const char * prog_date(void);
// prog_dbg
// file libslack/prog.h line 122
struct Msg * prog_dbg(void);
// prog_dbg_fd
// file libslack/prog.c line 1170
signed int prog_dbg_fd(signed int fd);
// prog_dbg_file
// file libslack/prog.c line 1232
signed int prog_dbg_file(const char *path);
// prog_dbg_none
// file libslack/prog.c line 1288
signed int prog_dbg_none(void);
// prog_dbg_stderr
// file libslack/prog.c line 1215
signed int prog_dbg_stderr(void);
// prog_dbg_stdout
// file libslack/prog.c line 1198
signed int prog_dbg_stdout(void);
// prog_dbg_syslog
// file libslack/prog.c line 1260
signed int prog_dbg_syslog(const char *id, signed int option, signed int facility, signed int priority);
// prog_debug_level
// file libslack/prog.h line 124
unsigned long int prog_debug_level(void);
// prog_desc
// file libslack/prog.c line 709
const char * prog_desc(void);
// prog_err
// file libslack/prog.h line 121
struct Msg * prog_err(void);
// prog_err_fd
// file libslack/prog.c line 1052
signed int prog_err_fd(signed int fd);
// prog_err_file
// file libslack/prog.c line 1097
signed int prog_err_file(const char *path);
// prog_err_none
// file libslack/prog.c line 1153
signed int prog_err_none(void);
// prog_err_stderr
// file libslack/prog.c line 1080
signed int prog_err_stderr(void);
// prog_err_syslog
// file libslack/prog.c line 1125
signed int prog_err_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// prog_help_msg
// file libslack/prog.c line 1540
void prog_help_msg(void);
// prog_init
// file libslack/prog.c line 245
void prog_init(void);
// prog_legal
// file libslack/prog.c line 821
const char * prog_legal(void);
// prog_name
// file libslack/prog.h line 109
const char * prog_name(void);
// prog_opt_process
// file libslack/prog.c line 1452
signed int prog_opt_process(signed int ac, char **av);
// prog_options
// file libslack/prog.c line 677
const struct Options * prog_options(void);
// prog_out
// file libslack/prog.h line 120
struct Msg * prog_out(void);
// prog_out_fd
// file libslack/prog.c line 934
signed int prog_out_fd(signed int fd);
// prog_out_file
// file libslack/prog.c line 978
signed int prog_out_file(const char *path);
// prog_out_none
// file libslack/prog.c line 1033
signed int prog_out_none(void);
// prog_out_stdout
// file libslack/prog.c line 961
signed int prog_out_stdout(void);
// prog_out_syslog
// file libslack/prog.c line 1006
signed int prog_out_syslog(const char *ident, signed int option, signed int facility, signed int priority);
// prog_set_alert
// file libslack/prog.c line 555
struct Msg * prog_set_alert(struct Msg *alert);
// prog_set_author
// file libslack/prog.c line 408
const char * prog_set_author(const char *author);
// prog_set_contact
// file libslack/prog.c line 426
const char * prog_set_contact(const char *contact);
// prog_set_date
// file libslack/prog.c line 391
const char * prog_set_date(const char *date);
// prog_set_dbg
// file libslack/prog.c line 537
struct Msg * prog_set_dbg(struct Msg *dbg);
// prog_set_debug_level
// file libslack/prog.c line 603
signed long int prog_set_debug_level(unsigned long int debug_level);
// prog_set_desc
// file libslack/prog.c line 357
const char * prog_set_desc(const char *desc);
// prog_set_err
// file libslack/prog.c line 519
struct Msg * prog_set_err(struct Msg *err);
// prog_set_legal
// file libslack/prog.c line 478
const char * prog_set_legal(const char *legal);
// prog_set_locker
// file libslack/prog.c line 640
signed int prog_set_locker(struct Locker *locker);
// prog_set_name
// file libslack/prog.c line 305
const char * prog_set_name(const char *name);
// prog_set_options
// file libslack/prog.c line 322
struct Options * prog_set_options(struct Options *options);
// prog_set_out
// file libslack/prog.c line 499
struct Msg * prog_set_out(struct Msg *out);
// prog_set_syntax
// file libslack/prog.c line 340
const char * prog_set_syntax(const char *syntax);
// prog_set_url
// file libslack/prog.c line 460
const char * prog_set_url(const char *url);
// prog_set_vendor
// file libslack/prog.c line 443
const char * prog_set_vendor(const char *vendor);
// prog_set_verbosity_level
// file libslack/prog.c line 622
signed long int prog_set_verbosity_level(unsigned long int verbosity_level);
// prog_set_version
// file libslack/prog.c line 374
const char * prog_set_version(const char *version);
// prog_syntax
// file libslack/prog.c line 693
const char * prog_syntax(void);
// prog_url
// file libslack/prog.c line 805
const char * prog_url(void);
// prog_usage_msg
// file libslack/prog.c line 1495
void prog_usage_msg(const char *format, ...);
// prog_vendor
// file libslack/prog.c line 789
const char * prog_vendor(void);
// prog_verbosity_level
// file libslack/prog.h line 125
unsigned long int prog_verbosity_level(void);
// prog_version
// file libslack/prog.c line 725
const char * prog_version(void);
// prog_version_msg
// file libslack/prog.c line 1634
void prog_version_msg(void);
// prop_clear
// file libslack/prop.c line 1121
signed int prop_clear(void);
// prop_create
// file libslack/prop.c line 153
static struct Prop * prop_create(struct Map *map, struct Prop *defaults);
// prop_get
// file libslack/prop.c line 540
const char * prop_get(const char *name);
// prop_get_bool
// file libslack/prop.c line 759
signed int prop_get_bool(const char *name);
// prop_get_bool_or
// file libslack/prop.c line 779
signed int prop_get_bool_or(const char *name, signed int default_value);
// prop_get_double
// file libslack/prop.c line 701
double prop_get_double(const char *name);
// prop_get_double_or
// file libslack/prop.c line 718
double prop_get_double_or(const char *name, double default_value);
// prop_get_int
// file libslack/prop.c line 644
signed int prop_get_int(const char *name);
// prop_get_int_or
// file libslack/prop.c line 661
signed int prop_get_int_or(const char *name, signed int default_value);
// prop_get_or
// file libslack/prop.c line 576
const char * prop_get_or(const char *name, const char *default_value);
// prop_init
// file libslack/prop.c line 434
static signed int prop_init(void);
// prop_load
// file libslack/prop.c line 392
static struct Prop * prop_load(const char *path, struct Prop *defaults);
// prop_locker
// file libslack/prop.c line 1152
signed int prop_locker(struct Locker *locker);
// prop_parse
// file libslack/prop.c line 299
static void prop_parse(struct Map *map, const char *path, char *line, unsigned long int lineno);
// prop_release
// file libslack/prop.c line 174
static void prop_release(struct Prop *prop);
// prop_save
// file libslack/prop.c line 914
signed int prop_save(void);
// prop_set
// file libslack/prop.c line 597
const char * prop_set(const char *name, const char *value);
// prop_set_bool
// file libslack/prop.c line 847
signed int prop_set_bool(const char *name, signed int value);
// prop_set_double
// file libslack/prop.c line 739
double prop_set_double(const char *name, double value);
// prop_set_int
// file libslack/prop.c line 682
signed int prop_set_int(const char *name, signed int value);
// prop_unset
// file libslack/prop.c line 866
signed int prop_unset(const char *name);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_11 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_11 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_11 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_12 *);
// pthread_rwlock_tryrdlock
// file /usr/include/pthread.h line 903
extern signed int pthread_rwlock_tryrdlock(union anonymous_12 *);
// pthread_rwlock_trywrlock
// file /usr/include/pthread.h line 918
extern signed int pthread_rwlock_trywrlock(union anonymous_12 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_12 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_12 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pty_change_window_size
// file libslack/pseudo.c line 716
signed int pty_change_window_size(signed int masterfd, signed int row, signed int col, signed int xpixel, signed int ypixel);
// pty_fork
// file libslack/pseudo.h line 54
signed int pty_fork(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize);
// pty_make_controlling_tty
// file libslack/pseudo.c line 637
signed int pty_make_controlling_tty(signed int *slavefd, const char *slavename);
// pty_make_controlling_tty::1::old_object
//
void old_object(signed int);
// pty_open
// file libslack/pseudo.c line 217
signed int pty_open(signed int *masterfd, signed int *slavefd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize);
// pty_release
// file libslack/pseudo.h line 50
signed int pty_release(const char *slavename);
// pty_set_owner
// file libslack/pseudo.c line 595
signed int pty_set_owner(const char *slavename, unsigned int uid);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// quote
// file libslack/str.c line 5126
struct String * quote(const char *str, const char *quotable, char quote_char);
// quote_equals
// file libslack/prop.c line 244
static struct String * quote_equals(const char *src);
// quote_special
// file libslack/prop.c line 213
static struct String * quote_special(const char *src);
// quote_with_locker
// file libslack/str.c line 5142
struct String * quote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// rcpt
// file libslack/net.c line 4112
static signed int rcpt(signed int smtp, const char *recipients);
// react
// file libslack/agent.c line 1942
static signed int react(signed int (*reaction)(struct Agent *, signed int, signed int, void *), struct Agent *agent, signed int fd, signed int revents, void *arg);
// react::reaction_object
//
signed int reaction_object(struct Agent *, signed int, signed int, void *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_timeout
// file libslack/fio.c line 201
signed int read_timeout(signed int fd, signed long int sec, signed long int usec);
// reader
// file libslack/map.c line 2639
void * reader(void *arg);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// readv
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 39
extern signed long int readv(signed int, struct iovec *, signed int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfd
// file libslack/net.h line 142
signed long int recvfd(signed int sockfd, void *buf, unsigned long int nbytes, signed int flags, signed int *fd);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_7 *, signed int);
// regexpr
// file libslack/str.c line 3117
struct List * regexpr(const char *pattern, const char *text, signed int cflags, signed int eflags);
// regexpr_compile
// file libslack/str.c line 3166
signed int regexpr_compile(struct re_pattern_buffer *compiled, const char *pattern, signed int cflags);
// regexpr_compiled
// file libslack/str.c line 3291
struct List * regexpr_compiled(const struct re_pattern_buffer *compiled, const char *text, signed int eflags);
// regexpr_compiled_with_locker
// file libslack/str.c line 3307
struct List * regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const char *text, signed int eflags);
// regexpr_release
// file libslack/str.c line 3184
void regexpr_release(struct re_pattern_buffer *compiled);
// regexpr_split
// file libslack/str.c line 4236
struct List * regexpr_split(const char *str, const char *delim, signed int cflags, signed int eflags);
// regexpr_split_with_locker
// file libslack/str.c line 4252
struct List * regexpr_split_with_locker(struct Locker *locker, const char *str, const char *delim, signed int cflags, signed int eflags);
// regexpr_with_locker
// file libslack/str.c line 3133
struct List * regexpr_with_locker(struct Locker *locker, const char *pattern, const char *text, signed int cflags, signed int eflags);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// release_action
// file libslack/agent.c line 273
static struct action_t * release_action(struct action_t *action);
// release_actions
// file libslack/agent.c line 282
static void release_actions(struct action_t *action);
// rudp_create
// file libslack/net.c line 2363
struct rudp_t * rudp_create(void);
// rudp_destroy
// file libslack/net.c line 2406
void * rudp_destroy(struct rudp_t **rudp);
// rudp_init
// file libslack/net.c line 2342
static signed int rudp_init(struct rudp_t *rudp);
// rudp_minmax
// file libslack/net.c line 2331
static double rudp_minmax(double rto);
// rudp_newpack
// file libslack/net.c line 2453
static unsigned int rudp_newpack(struct rudp_t *rudp);
// rudp_release
// file libslack/net.c line 2390
void rudp_release(struct rudp_t *rudp);
// rudp_start
// file libslack/net.c line 2473
static double rudp_start(struct rudp_t *rudp);
// rudp_stop
// file libslack/net.c line 2492
static signed int rudp_stop(struct rudp_t *rudp, unsigned int rtt);
// rudp_timeout
// file libslack/net.c line 2520
static signed int rudp_timeout(struct rudp_t *rudp);
// rudp_timestamp
// file libslack/net.c line 2428
static unsigned int rudp_timestamp(struct rudp_t *rudp);
// rw_timeout
// file libslack/fio.c line 297
signed int rw_timeout(signed int fd, signed long int sec, signed long int usec);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_10 *, struct anonymous_10 *, struct anonymous_10 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendfd
// file libslack/net.h line 141
signed long int sendfd(signed int sockfd, const void *buf, unsigned long int nbytes, signed int flags, signed int fd);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// service_number
// file libslack/net.c line 525
static signed int service_number(const char *service);
// service_port
// file libslack/net.c line 539
static unsigned short int service_port(const char *service, signed int type, signed int port);
// set_errno
// file libslack/err.h line 83
signed int set_errno(signed int errnum);
// set_errnull
// file libslack/err.h line 84
void * set_errnull(signed int errnum);
// set_errnullf
// file libslack/err.c line 748
void (*set_errnullf(signed int errnum))();
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(signed int, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shrink
// file libslack/list.c line 247
static signed int shrink(struct List *list, unsigned long int items);
// shrink_link1
// file libslack/str.c line 426
static signed int shrink_link1(struct String *str, unsigned long int bytes);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_6 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_6 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_addset
// file libslack/sig.c line 201
signed int signal_addset(signed int signo_handled, signed int signo_blocked);
// signal_catcher
// file libslack/sig.c line 120
static void signal_catcher(signed int signo);
// signal_handle
// file libslack/sig.c line 264
signed int signal_handle(signed int signo);
// signal_handle_all
// file libslack/sig.c line 292
void signal_handle_all(void);
// signal_raise
// file libslack/sig.c line 242
signed int signal_raise(signed int signo);
// signal_received
// file libslack/sig.c line 221
signed int signal_received(signed int signo);
// signal_set_handler
// file libslack/sig.c line 149
signed int signal_set_handler(signed int signo, signed int flags, void (*handler)(signed int));

//

// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_6 *, struct anonymous_6 *);
// slink_alloc
// file libslack/link.c line 460
void * slink_alloc(void **freelist);
// slink_free
// file libslack/link.c line 518
void * slink_free(void **freelist, void *item);
// slink_freelist_attach
// file libslack/link.c line 396
void * slink_freelist_attach(void *freelist1, void *freelist2);
// slink_freelist_init
// file libslack/link.c line 334
void * slink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size);
// slink_has_next
// file libslack/link.c line 105
signed int slink_has_next(void *link);
// slink_insert
// file libslack/link.c line 220
void * slink_insert(void *link, void *item);
// slink_next
// file libslack/link.c line 124
void * slink_next(void *link);
// slink_remove
// file libslack/link.c line 280
void * slink_remove(void *link);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_cmp
// file libslack/map.c line 2409
static signed int sort_cmp(const char **a, const char **b);
// soundex
// file libslack/str.c line 4592
signed int soundex(const char *str);
// split
// file libslack/str.h line 175
struct List * split(const char *str, const char *delim);
// split_with_locker
// file libslack/str.c line 4128
struct List * split_with_locker(struct Locker *locker, const char *str, const char *delim);
// squeeze
// file libslack/str.c line 4982
char * squeeze(char *str);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link1(const char *__path_link1, struct stat *__statbuf_link1);
// stat_link2
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link2(const char *__path_link2, struct stat *__statbuf_link2);
// stat_link3
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link3(const char *__path_link3, struct stat *__statbuf_link3);
// str_append
// file libslack/str.c line 1538
struct String * str_append(struct String *str, const char *format, ...);
// str_append_str
// file libslack/str.c line 1610
struct String * str_append_str(struct String *str, const struct String *src);
// str_append_str_unlocked
// file libslack/str.c line 1628
struct String * str_append_str_unlocked(struct String *str, const struct String *src);
// str_append_unlocked
// file libslack/str.c line 1558
struct String * str_append_unlocked(struct String *str, const char *format, ...);
// str_bin
// file libslack/str.c line 6235
signed int str_bin(const struct String *str);
// str_bin_unlocked
// file libslack/str.c line 6264
signed int str_bin_unlocked(const struct String *str);
// str_chomp
// file libslack/str.c line 6141
signed int str_chomp(struct String *str);
// str_chomp_unlocked
// file libslack/str.c line 6170
signed int str_chomp_unlocked(struct String *str);
// str_chop
// file libslack/str.c line 6055
signed int str_chop(struct String *str);
// str_chop_unlocked
// file libslack/str.c line 6084
signed int str_chop_unlocked(struct String *str);
// str_clear
// file libslack/str.c line 1212
struct String * str_clear(struct String *str);
// str_clear_unlocked
// file libslack/str.c line 1227
struct String * str_clear_unlocked(struct String *str);
// str_copy
// file libslack/str.c line 740
struct String * str_copy(const struct String *str);
// str_copy_unlocked
// file libslack/str.c line 755
struct String * str_copy_unlocked(const struct String *str);
// str_copy_with_locker
// file libslack/str.c line 771
struct String * str_copy_with_locker(struct Locker *locker, const struct String *str);
// str_copy_with_locker_unlocked
// file libslack/str.c line 787
struct String * str_copy_with_locker_unlocked(struct Locker *locker, const struct String *str);
// str_create
// file libslack/str.c line 531
struct String * str_create(const char *format, ...);
// str_create_sized
// file libslack/str.c line 609
struct String * str_create_sized(unsigned long int size, const char *format, ...);
// str_create_with_locker
// file libslack/str.c line 552
struct String * str_create_with_locker(struct Locker *locker, const char *format, ...);
// str_create_with_locker_sized
// file libslack/str.c line 630
struct String * str_create_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, ...);
// str_decode
// file libslack/str.c line 5606
struct String * str_decode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_unlocked
// file libslack/str.c line 5621
struct String * str_decode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_with_locker
// file libslack/str.c line 5637
struct String * str_decode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_decode_with_locker_unlocked
// file libslack/str.c line 5670
struct String * str_decode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_destroy
// file libslack/str.c line 894
void * str_destroy(struct String **str);
// str_empty
// file libslack/str.c line 987
signed int str_empty(const struct String *str);
// str_empty_unlocked
// file libslack/str.c line 1016
signed int str_empty_unlocked(const struct String *str);
// str_encode
// file libslack/str.c line 5517
struct String * str_encode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_unlocked
// file libslack/str.c line 5532
struct String * str_encode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_with_locker
// file libslack/str.c line 5548
struct String * str_encode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_encode_with_locker_unlocked
// file libslack/str.c line 5581
struct String * str_encode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable);
// str_fgetline
// file libslack/str.c line 812
struct String * str_fgetline(struct _IO_FILE *stream);
// str_fgetline_with_locker
// file libslack/str.c line 828
struct String * str_fgetline_with_locker(struct Locker *locker, struct _IO_FILE *stream);
// str_fmt
// file libslack/str.c line 3675
struct List * str_fmt(const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_unlocked
// file libslack/str.c line 3690
struct List * str_fmt_unlocked(const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_with_locker
// file libslack/str.c line 3706
struct List * str_fmt_with_locker(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_fmt_with_locker_unlocked
// file libslack/str.c line 3739
struct List * str_fmt_with_locker_unlocked(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment);
// str_hex
// file libslack/str.c line 6321
signed int str_hex(const struct String *str);
// str_hex_unlocked
// file libslack/str.c line 6350
signed int str_hex_unlocked(const struct String *str);
// str_insert
// file libslack/str.h line 93
struct String * str_insert(struct String *str, signed long int index, const char *format, ...);
// str_insert_str
// file libslack/str.c line 1457
struct String * str_insert_str(struct String *str, signed long int index, const struct String *src);
// str_insert_str_unlocked
// file libslack/str.c line 1501
struct String * str_insert_str_unlocked(struct String *str, signed long int index, const struct String *src);
// str_insert_unlocked
// file libslack/str.c line 1368
struct String * str_insert_unlocked(struct String *str, signed long int index, const char *format, ...);
// str_join
// file libslack/str.c line 4341
struct String * str_join(const struct List *list, const char *delim);
// str_join_unlocked
// file libslack/str.c line 4356
struct String * str_join_unlocked(const struct List *list, const char *delim);
// str_join_with_locker
// file libslack/str.c line 4372
struct String * str_join_with_locker(struct Locker *locker, const struct List *list, const char *delim);
// str_join_with_locker_unlocked
// file libslack/str.c line 4402
struct String * str_join_with_locker_unlocked(struct Locker *locker, const struct List *list, const char *delim);
// str_lc
// file libslack/str.c line 5757
struct String * str_lc(struct String *str);
// str_lc_unlocked
// file libslack/str.c line 5786
struct String * str_lc_unlocked(struct String *str);
// str_lcfirst
// file libslack/str.c line 5834
struct String * str_lcfirst(struct String *str);
// str_lcfirst_unlocked
// file libslack/str.c line 5863
struct String * str_lcfirst_unlocked(struct String *str);
// str_length
// file libslack/str.h line 80
signed long int str_length(const struct String *str);
// str_length_unlocked
// file libslack/str.c line 1063
signed long int str_length_unlocked(const struct String *str);
// str_oct
// file libslack/str.c line 6418
signed int str_oct(const struct String *str);
// str_oct_unlocked
// file libslack/str.c line 6447
signed int str_oct_unlocked(const struct String *str);
// str_prepend
// file libslack/str.c line 1644
struct String * str_prepend(struct String *str, const char *format, ...);
// str_prepend_str
// file libslack/str.c line 1716
struct String * str_prepend_str(struct String *str, const struct String *src);
// str_prepend_str_unlocked
// file libslack/str.c line 1734
struct String * str_prepend_str_unlocked(struct String *str, const struct String *src);
// str_prepend_unlocked
// file libslack/str.c line 1664
struct String * str_prepend_unlocked(struct String *str, const char *format, ...);
// str_quote
// file libslack/str.c line 5023
struct String * str_quote(const struct String *str, const char *quotable, char quote_char);
// str_quote_unlocked
// file libslack/str.c line 5038
struct String * str_quote_unlocked(const struct String *str, const char *quotable, char quote_char);
// str_quote_with_locker
// file libslack/str.c line 5054
struct String * str_quote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_quote_with_locker_unlocked
// file libslack/str.c line 5090
struct String * str_quote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_rdlock
// file libslack/str.c line 929
signed int str_rdlock(const struct String *str);
// str_recalc_length
// file libslack/str.c line 1161
signed long int str_recalc_length(struct String *str);
// str_recalc_length_unlocked
// file libslack/str.c line 1191
signed long int str_recalc_length_unlocked(struct String *str);
// str_regexpr
// file libslack/str.c line 3035
struct List * str_regexpr(const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_compiled
// file libslack/str.c line 3208
struct List * str_regexpr_compiled(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_unlocked
// file libslack/str.c line 3224
struct List * str_regexpr_compiled_unlocked(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_with_locker
// file libslack/str.c line 3240
struct List * str_regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_compiled_with_locker_unlocked
// file libslack/str.c line 3273
struct List * str_regexpr_compiled_with_locker_unlocked(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags);
// str_regexpr_split
// file libslack/str.c line 4154
struct List * str_regexpr_split(const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_unlocked
// file libslack/str.c line 4169
struct List * str_regexpr_split_unlocked(const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_with_locker
// file libslack/str.c line 4185
struct List * str_regexpr_split_with_locker(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_split_with_locker_unlocked
// file libslack/str.c line 4218
struct List * str_regexpr_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags);
// str_regexpr_unlocked
// file libslack/str.c line 3050
struct List * str_regexpr_unlocked(const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_with_locker
// file libslack/str.c line 3066
struct List * str_regexpr_with_locker(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regexpr_with_locker_unlocked
// file libslack/str.c line 3099
struct List * str_regexpr_with_locker_unlocked(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags);
// str_regsub
// file libslack/str.c line 3382
struct String * str_regsub(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all);
// str_regsub_compiled
// file libslack/str.c line 3439
struct String * str_regsub_compiled(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all);
// str_regsub_compiled_unlocked
// file libslack/str.c line 3469
struct String * str_regsub_compiled_unlocked(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all);
// str_regsub_unlocked
// file libslack/str.c line 3410
struct String * str_regsub_unlocked(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all);
// str_release
// file libslack/str.h line 73
void str_release(struct String *str);
// str_remove
// file libslack/str.c line 1246
struct String * str_remove(struct String *str, signed long int index);
// str_remove_range
// file libslack/str.c line 1280
struct String * str_remove_range(struct String *str, signed long int index, signed long int range);
// str_remove_range_unlocked
// file libslack/str.c line 1309
struct String * str_remove_range_unlocked(struct String *str, signed long int index, signed long int range);
// str_remove_unlocked
// file libslack/str.c line 1261
struct String * str_remove_unlocked(struct String *str, signed long int index);
// str_repeat
// file libslack/str.c line 2211
struct String * str_repeat(unsigned long int count, const char *format, ...);
// str_repeat_with_locker
// file libslack/str.c line 2232
struct String * str_repeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, ...);
// str_replace
// file libslack/str.c line 1754
struct String * str_replace(struct String *str, signed long int index, signed long int range, const char *format, ...);
// str_replace_str
// file libslack/str.c line 1852
struct String * str_replace_str(struct String *str, signed long int index, signed long int range, const struct String *src);
// str_replace_str_unlocked
// file libslack/str.c line 1896
struct String * str_replace_str_unlocked(struct String *str, signed long int index, signed long int range, const struct String *src);
// str_replace_unlocked
// file libslack/str.c line 1774
struct String * str_replace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, ...);
// str_set_length
// file libslack/str.c line 1107
signed long int str_set_length(struct String *str, unsigned long int length);
// str_set_length_unlocked
// file libslack/str.c line 1136
signed long int str_set_length_unlocked(struct String *str, unsigned long int length);
// str_soundex
// file libslack/str.c line 4545
signed int str_soundex(const struct String *str);
// str_soundex_unlocked
// file libslack/str.c line 4574
signed int str_soundex_unlocked(const struct String *str);
// str_splice
// file libslack/str.c line 2114
struct String * str_splice(struct String *str, signed long int index, signed long int range);
// str_splice_unlocked
// file libslack/str.c line 2129
struct String * str_splice_unlocked(struct String *str, signed long int index, signed long int range);
// str_splice_with_locker
// file libslack/str.c line 2145
struct String * str_splice_with_locker(struct Locker *locker, struct String *str, signed long int index, signed long int range);
// str_splice_with_locker_unlocked
// file libslack/str.c line 2178
struct String * str_splice_with_locker_unlocked(struct Locker *locker, struct String *str, signed long int index, signed long int range);
// str_split
// file libslack/str.c line 4030
struct List * str_split(const struct String *str, const char *delim);
// str_split_unlocked
// file libslack/str.c line 4045
struct List * str_split_unlocked(const struct String *str, const char *delim);
// str_split_with_locker
// file libslack/str.c line 4061
struct List * str_split_with_locker(struct Locker *locker, const struct String *str, const char *delim);
// str_split_with_locker_unlocked
// file libslack/str.c line 4094
struct List * str_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim);
// str_squeeze
// file libslack/str.c line 4914
struct String * str_squeeze(struct String *str);
// str_squeeze_unlocked
// file libslack/str.c line 4943
struct String * str_squeeze_unlocked(struct String *str);
// str_substr
// file libslack/str.c line 1945
struct String * str_substr(const struct String *str, signed long int index, signed long int range);
// str_substr_unlocked
// file libslack/str.c line 1960
struct String * str_substr_unlocked(const struct String *str, signed long int index, signed long int range);
// str_substr_with_locker
// file libslack/str.c line 1976
struct String * str_substr_with_locker(struct Locker *locker, const struct String *str, signed long int index, signed long int range);
// str_substr_with_locker_unlocked
// file libslack/str.c line 2006
struct String * str_substr_with_locker_unlocked(struct Locker *locker, const struct String *str, signed long int index, signed long int range);
// str_tr
// file libslack/str.c line 2371
signed int str_tr(struct String *str, const char *from, const char *to, signed int option);
// str_tr_compile
// file libslack/str.c line 2549
struct StringTR * str_tr_compile(const struct String *from, const struct String *to, signed int option);
// str_tr_compile_table
// file libslack/str.c line 2808
static struct StringTR * str_tr_compile_table(struct StringTR *table, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_table_unlocked
// file libslack/str.c line 2845
static struct StringTR * str_tr_compile_table_unlocked(struct StringTR *table, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_unlocked
// file libslack/str.c line 2565
struct StringTR * str_tr_compile_unlocked(const struct String *from, const struct String *to, signed int option);
// str_tr_compile_with_locker
// file libslack/str.c line 2581
struct StringTR * str_tr_compile_with_locker(struct Locker *locker, const struct String *from, const struct String *to, signed int option);
// str_tr_compile_with_locker_unlocked
// file libslack/str.c line 2606
struct StringTR * str_tr_compile_with_locker_unlocked(struct Locker *locker, const struct String *from, const struct String *to, signed int option);
// str_tr_compiled
// file libslack/str.c line 2930
signed int str_tr_compiled(struct String *str, struct StringTR *table);
// str_tr_compiled_unlocked
// file libslack/str.c line 2971
signed int str_tr_compiled_unlocked(struct String *str, struct StringTR *table);
// str_tr_str
// file libslack/str.c line 2425
signed int str_tr_str(struct String *str, const struct String *from, const struct String *to, signed int option);
// str_tr_str_unlocked
// file libslack/str.c line 2455
signed int str_tr_str_unlocked(struct String *str, const struct String *from, const struct String *to, signed int option);
// str_tr_unlocked
// file libslack/str.c line 2396
signed int str_tr_unlocked(struct String *str, const char *from, const char *to, signed int option);
// str_trim
// file libslack/str.c line 4644
struct String * str_trim(struct String *str);
// str_trim_left
// file libslack/str.c line 4744
struct String * str_trim_left(struct String *str);
// str_trim_left_unlocked
// file libslack/str.c line 4773
struct String * str_trim_left_unlocked(struct String *str);
// str_trim_right
// file libslack/str.c line 4830
struct String * str_trim_right(struct String *str);
// str_trim_right_unlocked
// file libslack/str.c line 4859
struct String * str_trim_right_unlocked(struct String *str);
// str_trim_unlocked
// file libslack/str.c line 4673
struct String * str_trim_unlocked(struct String *str);
// str_uc
// file libslack/str.c line 5906
struct String * str_uc(struct String *str);
// str_uc_unlocked
// file libslack/str.c line 5935
struct String * str_uc_unlocked(struct String *str);
// str_ucfirst
// file libslack/str.c line 5983
struct String * str_ucfirst(struct String *str);
// str_ucfirst_unlocked
// file libslack/str.c line 6012
struct String * str_ucfirst_unlocked(struct String *str);
// str_unlock
// file libslack/str.c line 971
signed int str_unlock(const struct String *str);
// str_unquote
// file libslack/str.c line 5182
struct String * str_unquote(const struct String *str, const char *quotable, char quote_char);
// str_unquote_unlocked
// file libslack/str.c line 5197
struct String * str_unquote_unlocked(const struct String *str, const char *quotable, char quote_char);
// str_unquote_with_locker
// file libslack/str.c line 5213
struct String * str_unquote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_unquote_with_locker_unlocked
// file libslack/str.c line 5250
struct String * str_unquote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char);
// str_vappend
// file libslack/str.c line 1579
struct String * str_vappend(struct String *str, const char *format, void **args);
// str_vappend_unlocked
// file libslack/str.c line 1594
struct String * str_vappend_unlocked(struct String *str, const char *format, void **args);
// str_vcreate
// file libslack/str.c line 573
struct String * str_vcreate(const char *format, void **args);
// str_vcreate_sized
// file libslack/str.c line 651
struct String * str_vcreate_sized(unsigned long int size, const char *format, void **args);
// str_vcreate_with_locker
// file libslack/str.c line 589
struct String * str_vcreate_with_locker(struct Locker *locker, const char *format, void **args);
// str_vcreate_with_locker_sized
// file libslack/str.c line 671
struct String * str_vcreate_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, void **args);
// str_vinsert
// file libslack/str.c line 1389
struct String * str_vinsert(struct String *str, signed long int index, const char *format, void **args);
// str_vinsert_unlocked
// file libslack/str.c line 1418
struct String * str_vinsert_unlocked(struct String *str, signed long int index, const char *format, void **args);
// str_vprepend
// file libslack/str.c line 1685
struct String * str_vprepend(struct String *str, const char *format, void **args);
// str_vprepend_unlocked
// file libslack/str.c line 1700
struct String * str_vprepend_unlocked(struct String *str, const char *format, void **args);
// str_vrepeat
// file libslack/str.c line 2253
struct String * str_vrepeat(unsigned long int count, const char *format, void **args);
// str_vrepeat_with_locker
// file libslack/str.c line 2269
struct String * str_vrepeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, void **args);
// str_vreplace
// file libslack/str.c line 1795
struct String * str_vreplace(struct String *str, signed long int index, signed long int range, const char *format, void **args);
// str_vreplace_unlocked
// file libslack/str.c line 1821
struct String * str_vreplace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, void **args);
// str_wrlock
// file libslack/str.c line 954
signed int str_wrlock(const struct String *str);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlcat
// file libslack/str.c line 6619
unsigned long int strlcat(char *dst, const char *src, unsigned long int size);
// strlcpy
// file libslack/str.h line 257
unsigned long int strlcpy(char *dst, const char *src, unsigned long int size);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// substr
// file libslack/str.c line 2048
struct String * substr(const char *str, signed long int index, signed long int range);
// substr_with_locker
// file libslack/str.c line 2065
struct String * substr_with_locker(struct Locker *locker, const char *str, signed long int index, signed long int range);
// swap
// file libslack/hsort.c line 156
static void swap(char *p1, char *p2, unsigned long int n);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_facility_str
// file libslack/msg.c line 1395
const char * syslog_facility_str(signed int spec);
// syslog_lookup
// file libslack/msg.c line 1323
static signed int syslog_lookup(const struct syslog_map_t *map, const char *name);
// syslog_lookup_facility
// file libslack/msg.c line 1364
signed int syslog_lookup_facility(const char *facility);
// syslog_lookup_priority
// file libslack/msg.c line 1379
signed int syslog_lookup_priority(const char *priority);
// syslog_lookup_str
// file libslack/msg.c line 1343
static const char * syslog_lookup_str(const struct syslog_map_t *map, signed int spec, signed int mask);
// syslog_parse
// file libslack/msg.c line 1451
signed int syslog_parse(const char *spec, signed int *facility, signed int *priority);
// syslog_priority_str
// file libslack/msg.c line 1411
const char * syslog_priority_str(signed int spec);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// test_action
// file libslack/map.c line 2414
static void test_action(char *key, char *value, char *cat);
// test_hash
// file libslack/map.c line 2345
static void test_hash(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout
// file libslack/agent.c line 1909
static signed int timeout(struct Agent *agent);
// timeval_add
// file libslack/agent.c line 1624
static void timeval_add(struct timeval *absolute, struct timeval *relative, struct timeval *result);
// timeval_diff
// file libslack/agent.c line 1614
static void timeval_diff(struct timeval *start, struct timeval *end, struct timeval *diff);
// timeval_set
// file libslack/agent.c line 1633
static void timeval_set(struct timeval *tv, signed long int tv_sec, signed long int tv_usec);
// timewheel_create
// file libslack/agent.c line 250
static struct timewheel_t * timewheel_create();
// timewheel_release
// file libslack/agent.c line 288
static void timewheel_release(struct timewheel_t *timewheel);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c);
// tr
// file libslack/str.c line 2480
signed int tr(char *str, const char *from, const char *to, signed int option);
// tr_compile
// file libslack/str.c line 2509
struct StringTR * tr_compile(const char *from, const char *to, signed int option);
// tr_compile_table
// file libslack/str.c line 2793
static struct StringTR * tr_compile_table(struct StringTR *table, const char *from, const char *to, signed int option);
// tr_compile_with_locker
// file libslack/str.c line 2525
struct StringTR * tr_compile_with_locker(struct Locker *locker, const char *from, const char *to, signed int option);
// tr_compiled
// file libslack/str.c line 2989
signed int tr_compiled(char *str, struct StringTR *table);
// tr_destroy
// file libslack/str.c line 2655
void * tr_destroy(struct StringTR **table);
// tr_release
// file libslack/str.c line 2628
void tr_release(struct StringTR *table);
// translate
// file libslack/agent.c line 2065
static signed int translate(signed int revents);
// trim
// file libslack/str.c line 4711
char * trim(char *str);
// trim_left
// file libslack/str.c line 4800
char * trim_left(char *str);
// trim_right
// file libslack/str.c line 4886
char * trim_right(char *str);
// ttyname_r
// file /usr/include/unistd.h line 774
extern signed int ttyname_r(signed int, char *, unsigned long int);
// uc
// file libslack/str.c line 5959
char * uc(char *str);
// ucfirst
// file libslack/str.c line 6034
char * ucfirst(char *str);
// uid2gid
// file libslack/pseudo.c line 196
static signed int uid2gid(unsigned int uid);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unpack
// file libslack/net.c line 3346
signed long int unpack(void *buf, unsigned long int size, const char *format, ...);
// unquote
// file libslack/str.c line 5286
struct String * unquote(const char *str, const char *quotable, char quote_char);
// unquote_equals
// file libslack/prop.c line 258
static struct String * unquote_equals(const char *src);
// unquote_special
// file libslack/prop.c line 230
static struct String * unquote_special(const char *src);
// unquote_with_locker
// file libslack/str.c line 5302
struct String * unquote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char);
// update
// file libslack/agent.c line 1976
static signed int update(struct Agent *agent);
// user_home
// file libslack/prop.c line 272
static char * user_home(void);
// valert
// file libslack/err.c line 475
void valert(signed int priority, const char *format, void **args);
// valertsys
// file libslack/err.c line 696
void valertsys(signed int priority, const char *format, void **args);
// vasprintf
// file libslack/str.c line 6852
signed int vasprintf(char **str, const char *format, void **args);
// vdebugf
// file libslack/err.c line 285
void vdebugf(unsigned long int level, const char *format, void **args);
// vdebugsysf
// file libslack/err.c line 536
void vdebugsysf(unsigned long int level, const char *format, void **args);
// vdump
// file libslack/err.c line 430
void vdump(const char *format, void **args);
// vdumpsys
// file libslack/err.c line 657
void vdumpsys(const char *format, void **args);
// verbose
// file libslack/err.c line 190
void verbose(unsigned long int level, const char *format, ...);
// verror
// file libslack/err.c line 337
signed int verror(const char *format, void **args);
// verrorsys
// file libslack/err.c line 579
signed int verrorsys(const char *format, void **args);
// vfatal
// file libslack/err.c line 386
void vfatal(const char *format, void **args);
// vfatalsys
// file libslack/err.c line 618
void vfatalsys(const char *format, void **args);
// vhangup
// file /usr/include/unistd.h line 906
extern signed int vhangup(void);
// vmsg
// file libslack/err.c line 168
void vmsg(const char *format, void **args);
// vmsg_out
// file libslack/msg.h line 52
void vmsg_out(struct Msg *dst, const char *format, void **args);
// vmsg_out_unlocked
// file libslack/msg.c line 455
void vmsg_out_unlocked(struct Msg *dst, const char *format, void **args);
// vpack
// file libslack/net.c line 3037
signed long int vpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsscanf
// file /usr/include/stdio.h line 483
extern signed int vsscanf(const char *, const char *, void **);
// vunpack
// file libslack/net.c line 3400
signed long int vunpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args);
// vverbose
// file libslack/err.c line 212
void vverbose(unsigned long int level, const char *format, void **args);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_timeout
// file libslack/fio.c line 246
signed int write_timeout(signed int fd, signed long int sec, signed long int usec);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);

struct anonymous_24
{
  // rfds
  struct anonymous_10 *rfds;
  // xfds
  struct anonymous_10 *xfds;
  // wfds
  struct anonymous_10 *wfds;
};

struct anonymous_20
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_18
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_10
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_6
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_13
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_5
{
  // init
  signed int init;
  // prop
  struct Prop *prop;
  // home
  char *home;
  // dirty
  signed int dirty;
  // locker
  struct Locker *locker;
};

struct anonymous_7
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_15
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_19
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_21
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_14 _kill;
  // _timer
  struct anonymous_15 _timer;
  // _rt
  struct anonymous_16 _rt;
  // _sigchld
  struct anonymous_17 _sigchld;
  // _sigfault
  struct anonymous_18 _sigfault;
  // _sigpoll
  struct anonymous_19 _sigpoll;
  // _sigsys
  struct anonymous_20 _sigsys;
};

struct anonymous_22
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_21 _sifields;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_11
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_26
{
  // lock
  union anonymous_11 lock;
  // pidfile
  char *pidfile;
};

union anonymous_2
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_23
{
  // pfds
  struct pollfd *pfds;
  // s
  struct anonymous_24 s;
};

union anonymous_9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_22 *, void *);
};

union anonymous_0
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_12
{
  // __data
  struct anonymous_13 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_1
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct conf_t
{
  // name
  const signed int name;
  // value
  const signed long int value;
  // offset
  const signed long int offset;
};

struct anonymous_27
{
  // conf
  struct conf_t conf[19l];
};

struct Agent
{
  // state
  signed int state;
  // ids
  signed long int *ids;
  // ids_size
  unsigned long int ids_size;
  // method
  signed int method;
  // u
  union anonymous_23 u;
  // reactions
  struct reaction_t *reactions;
  // tempo
  struct activity_t *tempo;
  // activity
  struct activity_t *activity;
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // timewheel
  struct timewheel_t *timewheel;
  // timers
  unsigned long int timers;
  // locker
  struct Locker *locker;
};

struct List
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // list
  void **list;
  // destroy
  void (*destroy)(void *);
  // lister
  struct Lister *lister;
  // locker
  struct Locker *locker;
};

struct Lister
{
  // list
  struct List *list;
  // index
  signed long int index;
};

struct Locker
{
  // lock
  void *lock;
  // tryrdlock
  signed int (*tryrdlock)(void *);
  // rdlock
  signed int (*rdlock)(void *);
  // trywrlock
  signed int (*trywrlock)(void *);
  // wrlock
  signed int (*wrlock)(void *);
  // unlock
  signed int (*unlock)(void *);
};

struct Map
{
  // size
  unsigned long int size;
  // items
  unsigned long int items;
  // chain
  struct List **chain;
  // hash
  unsigned long int (*hash)(unsigned long int, const void *);
  // copy
  void * (*copy)(const void *);
  // cmp
  signed int (*cmp)(const void *, const void *);
  // key_destroy
  void (*key_destroy)(void *);
  // value_destroy
  void (*value_destroy)(void *);
  // mapper
  struct Mapper *mapper;
  // locker
  struct Locker *locker;
};

struct Mapper
{
  // map
  struct Map *map;
  // chain_index
  signed long int chain_index;
  // item_index
  signed long int item_index;
  // next_chain_index
  signed long int next_chain_index;
  // next_item_index
  signed long int next_item_index;
};

struct Mapping
{
  // key
  void *key;
  // value
  void *value;
  // key_destroy
  void (*key_destroy)(void *);
  // value_destroy
  void (*value_destroy)(void *);
};

struct Msg
{
  // type
  signed int type;
  // out
  void (*out)(void *, const void *, unsigned long int);
  // data
  void *data;
  // destroy
  void (*destroy)(void *);
  // locker
  struct Locker *locker;
};

struct MsgFileData
{
  // fd
  signed int fd;
};

struct MsgPlexData
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // list
  struct Msg **list;
};

struct MsgSyslogData
{
  // facility
  signed int facility;
  // priority
  signed int priority;
};

struct Option
{
  // name
  const char *name;
  // short_name
  char short_name;
  // argname
  const char *argname;
  // desc
  const char *desc;
  // has_arg
  signed int has_arg;
  // arg_type
  enum OptionArgument arg_type;
  // action
  enum OptionAction action;
  // object
  void *object;
  // function
  void (*function)(void);
};

struct Options
{
  // parent
  struct Options *parent;
  // options
  struct Option *options;
};

struct Point
{
  // x
  signed int x;
  // y
  signed int y;
};

struct Pool
{
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // pool
  char *pool;
  // locker
  struct Locker *locker;
};

struct Prog
{
  // name
  const char *name;
  // options
  struct Options *options;
  // syntax
  const char *syntax;
  // desc
  const char *desc;
  // version
  const char *version;
  // date
  const char *date;
  // author
  const char *author;
  // contact
  const char *contact;
  // vendor
  const char *vendor;
  // url
  const char *url;
  // legal
  const char *legal;
  // out
  struct Msg *out;
  // err
  struct Msg *err;
  // dbg
  struct Msg *dbg;
  // log
  struct Msg *log;
  // debug_level
  unsigned long int debug_level;
  // verbosity_level
  unsigned long int verbosity_level;
  // locker
  struct Locker *locker;
};

struct Prop
{
  // map
  struct Map *map;
  // defaults
  struct Prop *defaults;
};

struct String
{
  // size
  unsigned long int size;
  // length
  unsigned long int length;
  // str
  char *str;
  // locker
  struct Locker *locker;
};

struct StringTR
{
  // squash
  signed int squash;
  // table
  signed short int table[256l];
  // locker
  struct Locker *locker;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct action_t
{
  // next
  struct action_t *next;
  // prev
  struct action_t *prev;
  // parent
  struct action_t **parent;
  // when
  struct timeval when;
  // action
  signed int (*action)(struct Agent *, void *);
  // arg
  void *arg;
  // day
  unsigned long int day;
  // hour
  unsigned long int hour;
  // minute
  unsigned long int minute;
  // second
  unsigned long int second;
  // jiffy
  unsigned long int jiffy;
};

struct activity_t
{
  // since
  struct timeval since;
  // detail
  unsigned long int detail;
  // dt
  signed int dt;
  // ddt
  signed int ddt;
  // dddt
  signed int dddt;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dlink_t
{
  // next
  void *next;
  // prev
  void *prev;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_2 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_0 ifr_ifrn;
  // ifr_ifru
  union anonymous_1 ifr_ifru;
};

struct in6_addr
{
  // __in6_u
  union anonymous __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip_mreq
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_interface
  struct in_addr imr_interface;
};

struct ipv6_mreq
{
  // ipv6mr_multiaddr
  struct in6_addr ipv6mr_multiaddr;
  // ipv6mr_interface
  unsigned int ipv6mr_interface;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct net_interface_t
{
  // name
  char name[16l];
  // index
  unsigned int index;
  // flags
  signed short int flags;
  // mtu
  signed int mtu;
  // addr
  union sockaddr_any_t *addr;
  // brdaddr
  union sockaddr_any_t *brdaddr;
  // dstaddr
  union sockaddr_any_t *dstaddr;
  // hwaddr
  union sockaddr_any_t *hwaddr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct reaction_t
{
  // fd
  signed int fd;
  // events
  signed int events;
  // reaction
  signed int (*reaction)(struct Agent *, signed int, signed int, void *);
  // arg
  void *arg;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_9 __sigaction_handler;
  // sa_mask
  struct anonymous_6 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct real_signal_handler_t
{
  // action
  struct sigaction action[1l];
  // handler
  void (*handler)(signed int);
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rudp_t
{
  // rtt
  double rtt;
  // srtt
  double srtt;
  // rttvar
  double rttvar;
  // rto
  double rto;
  // nrexmt
  signed int nrexmt;
  // base
  unsigned int base;
  // sequence
  unsigned int sequence;
};

struct servent
{
  // s_name
  char *s_name;
  // s_aliases
  char **s_aliases;
  // s_port
  signed int s_port;
  // s_proto
  char *s_proto;
};

struct slink_t
{
  // next
  void *next;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union sockaddr_any_t
{
  // any
  struct sockaddr any;
  // un
  struct sockaddr_un un;
  // in
  struct sockaddr_in in;
  // in6
  struct sockaddr_in6 in6;
};

struct sockopt_t
{
  // level
  signed int level;
  // optname
  signed int optname;
  // optval
  const void *optval;
  // optlen
  signed int optlen;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct syslog_map_t
{
  // name
  char *name;
  // val
  signed int val;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timewheel_t
{
  // now
  struct timeval now[1l];
  // day
  unsigned long int day;
  // hour
  unsigned long int hour;
  // minute
  unsigned long int minute;
  // second
  unsigned long int second;
  // jiffy
  unsigned long int jiffy;
  // days
  struct action_t *days[10l];
  // hours
  struct action_t *hours[24l];
  // minutes
  struct action_t *minutes[60l];
  // seconds
  struct action_t *seconds[60l];
  // jiffies
  struct action_t *jiffies[100l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// MIN_EMPTY_STRING_SIZE
// file libslack/str.c line 377
static const unsigned long int MIN_EMPTY_STRING_SIZE = (const unsigned long int)1024;
// MIN_LIST_SIZE
// file libslack/list.c line 207
static const unsigned long int MIN_LIST_SIZE = (const unsigned long int)4;
// MIN_STRING_SIZE
// file libslack/str.c line 373
static const unsigned long int MIN_STRING_SIZE = (const unsigned long int)32;
// barrier
// file libslack/map.c line 2491
signed int barrier[2l];
// debug
// file libslack/map.c line 2494
signed int debug = 0;
// environ
// file libslack/coproc.c line 71
extern char **environ;
// eq
// file libslack/prop.c line 199
static const char *eq = "=";
// errors
// file libslack/map.c line 2495
signed int errors = 0;
// g
// file libslack/daemon.c line 109
static struct anonymous_26 g = { .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .pidfile=(char *)(void *)0 };
// g_link1
// file libslack/lim.c line 134
static struct anonymous_27 g_link1 = { .conf={ { .name=0, .value=(const signed long int)131072, .offset=(const signed long int)0 },
    { .name=1, .value=(const signed long int)1024, .offset=(const signed long int)0 },
    { .name=2, .value=(const signed long int)-1, .offset=(const signed long int)0 },
    { .name=3, .value=(const signed long int)32, .offset=(const signed long int)0 },
    { .name=4, .value=(const signed long int)1024, .offset=(const signed long int)0 },
    { .name=5, .value=(const signed long int)1024, .offset=(const signed long int)0 },
    { .name=6, .value=(const signed long int)3, .offset=(const signed long int)0 },
    { .name=7, .value=(const signed long int)0, .offset=(const signed long int)0 },
    { .name=8, .value=(const signed long int)0, .offset=(const signed long int)0 },
    { .name=29, .value=(const signed long int)0, .offset=(const signed long int)0 },
    { .name=1, .value=(const signed long int)255, .offset=(const signed long int)0 },
    { .name=2, .value=(const signed long int)255, .offset=(const signed long int)0 },
    { .name=8, .value=(const signed long int)0, .offset=(const signed long int)0 },
    { .name=0, .value=(const signed long int)32768, .offset=(const signed long int)0 },
    { .name=3, .value=(const signed long int)1024, .offset=(const signed long int)0 },
    { .name=4, .value=(const signed long int)4096, .offset=(const signed long int)2 },
    { .name=5, .value=(const signed long int)4096, .offset=(const signed long int)0 },
    { .name=7, .value=(const signed long int)0, .offset=(const signed long int)0 },
    { .name=6, .value=(const signed long int)0, .offset=(const signed long int)0 } } };
// g_link2
// file libslack/prog.c line 227
static struct Prog g_link2 = { .name=(const char *)(void *)0, .options=(struct Options *)(void *)0, .syntax=(const char *)(void *)0,
    .desc=(const char *)(void *)0, .version=(const char *)(void *)0,
    .date=(const char *)(void *)0, .author=(const char *)(void *)0,
    .contact=(const char *)(void *)0, .vendor=(const char *)(void *)0,
    .url=(const char *)(void *)0, .legal=(const char *)(void *)0,
    .out=(struct Msg *)(void *)0, .err=(struct Msg *)(void *)0,
    .dbg=(struct Msg *)(void *)0, .log=(struct Msg *)(void *)0,
    .debug_level=(unsigned long int)0, .verbosity_level=(unsigned long int)0,
    .locker=(struct Locker *)(void *)0 };
// g_link3
// file libslack/prop.c line 141
static struct anonymous_5 g_link3 = { .init=0, .prop=(struct Prop *)(void *)0, .home=(char *)(void *)0,
    .dirty=0, .locker=(struct Locker *)(void *)0 };
// g_handler
// file libslack/sig.c line 108
static struct real_signal_handler_t g_handler[65l];
// g_received
// file libslack/sig.c line 109
static volatile signed int g_received[65l];
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// in6addr_loopback
// file /usr/include/netinet/in.h line 228
extern struct in6_addr in6addr_loopback;
// lim
// file libslack/map.c line 2493
const signed int lim = 1000;
// locker
// file libslack/map.c line 2484
struct Locker *locker = (struct Locker *)(void *)0;
// mtmap
// file libslack/map.c line 2483
struct Map *mtmap = (struct Map *)(void *)0;
// mutex
// file libslack/map.c line 2485
union anonymous_11 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// num_table_sizes
// file libslack/map.c line 180
static const unsigned long int num_table_sizes = sizeof(const unsigned long int [22l]) /*176ul*/  / sizeof(const unsigned long int) /*8ul*/ ;
// optarg
// file libslack/getopt.h line 36
extern char *optarg;
// optind
// file libslack/getopt.h line 50
extern signed int optind;
// prog_optab
// file libslack/prog.c line 1724
static struct Option prog_optab[5l];
// prog_optab
// file libslack/prog.c line 1724
static struct Option prog_optab[5l] = { { .name="help", .short_name=(char)104, .argname=(const char *)(void *)0, .desc="Print a help message then exit",
    .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))prog_help_msg },
    { .name="version", .short_name=(char)86, .argname=(const char *)(void *)0,
    .desc="Print a version message then exit", .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))prog_version_msg },
    { .name="verbose", .short_name=(char)118, .argname="level",
    .desc="Set the verbosity level", .has_arg=2,
    .arg_type=(enum OptionArgument)1, .action=(enum OptionAction)2,
    .object=(void *)0, .function=(void (*)(void))handle_verbose_option },
    { .name="debug", .short_name=(char)100, .argname="level", .desc="Set the debugging level",
    .has_arg=2, .arg_type=(enum OptionArgument)1,
    .action=(enum OptionAction)2, .object=(void *)0,
    .function=(void (*)(void))handle_debug_option },
    { .name=(const char *)(void *)0, .short_name=(char)0, .argname=(const char *)(void *)0,
    .desc=(const char *)(void *)0, .has_arg=0,
    .arg_type=(enum OptionArgument)0, .action=(enum OptionAction)0,
    .object=(void *)0, .function=(void (*)(void))(void *)0 } };
// prog_options_table
// file libslack/prog.c line 1749
struct Options prog_options_table[1l];
// prog_options_table
// file libslack/prog.c line 1749
struct Options prog_options_table[1l] = { { .parent=(struct Options *)(void *)0, .options=prog_optab } };
// rand_mutex
// file libslack/map.c line 2637
union anonymous_11 rand_mutex[1l] = { { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// rwlock
// file libslack/map.c line 2487
union anonymous_12 rwlock = { .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } };
// size
// file libslack/map.c line 2492
signed int size[2l];
// special_char
// file libslack/prop.c line 198
static const char *special_char = "\a\b\f\n\r\t\v";
// special_code
// file libslack/prop.c line 197
static const char *special_code = "abfnrtv";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// syslog_facility_map
// file libslack/msg.c line 173
static const struct syslog_map_t syslog_facility_map[19l] = { { .name="kern", .val=0 << 3 }, { .name="user", .val=1 << 3 }, { .name="mail", .val=2 << 3 }, { .name="daemon", .val=3 << 3 }, { .name="auth", .val=4 << 3 }, { .name="syslog", .val=5 << 3 }, { .name="lpr", .val=6 << 3 }, { .name="news", .val=7 << 3 }, { .name="uucp", .val=8 << 3 }, { .name="cron", .val=9 << 3 }, { .name="local0", .val=16 << 3 }, { .name="local1", .val=17 << 3 }, { .name="local2", .val=18 << 3 }, { .name="local3", .val=19 << 3 }, { .name="local4", .val=20 << 3 }, { .name="local5", .val=21 << 3 }, { .name="local6", .val=22 << 3 }, { .name="local7", .val=23 << 3 }, { .name=(char *)(void *)0, .val=-1 } };
// syslog_priority_map
// file libslack/msg.c line 196
static const struct syslog_map_t syslog_priority_map[9l] = { { .name="emerg", .val=0 }, { .name="alert", .val=1 }, { .name="crit", .val=2 }, { .name="err", .val=3 }, { .name="warning", .val=4 }, { .name="notice", .val=5 }, { .name="info", .val=6 }, { .name="debug", .val=7 }, { .name=(char *)(void *)0, .val=-1 } };
// table_resize_factor
// file libslack/map.c line 184
static const double table_resize_factor = 2.0;
// table_sizes
// file libslack/map.c line 173
static const unsigned long int table_sizes[22l] = { (const unsigned long int)11, (const unsigned long int)23, (const unsigned long int)47, (const unsigned long int)101, (const unsigned long int)199, (const unsigned long int)401, (const unsigned long int)797, (const unsigned long int)1601, (const unsigned long int)3203, (const unsigned long int)6397, (const unsigned long int)12799, (const unsigned long int)25601, (const unsigned long int)51199, (const unsigned long int)102397, (const unsigned long int)204803, (const unsigned long int)409597, (const unsigned long int)819187, (const unsigned long int)1638431, (const unsigned long int)3276799, (const unsigned long int)6553621, (const unsigned long int)13107197, (const unsigned long int)26214401 };
// timestamp_format
// file libslack/msg.c line 213
static const char *timestamp_format = "%Y%m%d %H:%M:%S ";
// timestamp_format_locker
// file libslack/msg.c line 214
static struct Locker *timestamp_format_locker = (struct Locker *)(void *)0;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
    if((signed int)__s[(signed long int)__result] == __reject)
      break;

  return __result;
}

// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

  }
  return __result;
}

// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

    if((signed int)__s[(signed long int)__result] == __reject3)
      break;

  }
  return __result;
}

// act
// file libslack/agent.c line 1927
static signed int act(signed int (*action)(struct Agent *, void *), struct Agent *agent, void *arg)
{
  signed int err;
  signed int ret;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_set_errno_3;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    ret=action(agent, arg);
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value_1=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_4 = return_value_1;
    }

    else
      tmp_if_expr_4 = 0;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_3=set_errno(err);
      return return_value_set_errno_3;
    }

    else
      return ret;
  }
}

// adjust
// file libslack/list.c line 318
static signed int adjust(struct List *list, signed long int index, unsigned long int range, unsigned long int length)
{
  signed int return_value_expand_1;
  signed int return_value_contract_2;
  if(!(range >= length))
  {
    return_value_expand_1=expand(list, (signed long int)((unsigned long int)index + range), length - range);
    return return_value_expand_1;
  }

  else
    if(!(length >= range))
    {
      return_value_contract_2=contract(list, (signed long int)((unsigned long int)index + length), range - length);
      return return_value_contract_2;
    }

    else
      return 0;
}

// adjust_link1
// file libslack/str.c line 497
static signed int adjust_link1(struct String *str, signed long int index_link1, unsigned long int range_link1, unsigned long int length_link1)
{
  signed int return_value_expand_1_link1;
  signed int return_value_contract_2_link1;
  if(!(range_link1 >= length_link1))
  {
    return_value_expand_1_link1=expand_link1(str, (signed long int)((unsigned long int)index_link1 + range_link1), length_link1 - range_link1);
    return return_value_expand_1_link1;
  }

  else
    if(!(length_link1 >= range_link1))
    {
      return_value_contract_2_link1=contract_link1(str, (signed long int)((unsigned long int)index_link1 + length_link1), range_link1 - length_link1);
      return return_value_contract_2_link1;
    }

    else
      return 0;
}

// agent_acceleration
// file libslack/agent.c line 1423
signed int agent_acceleration(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_acceleration_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_acceleration_unlocked
// file libslack/agent.c line 1452
signed int agent_acceleration_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  signed int return_value_set_errno_9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 3ul))
        {
          return_value_set_errno_7=set_errno(22);
          return return_value_set_errno_7;
        }

        return agent->tempo->ddt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno_8=set_errno(22);
        return return_value_set_errno_8;
      }

      else
        if(!((agent->activity + id)->detail >= 3ul))
        {
          return_value_set_errno_9=set_errno(22);
          return return_value_set_errno_9;
        }

        else
          return (agent->activity + id)->ddt;
    }
  }
}

// agent_cancel
// file libslack/agent.c line 1740
signed int agent_cancel(struct Agent *agent, void *action_id)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_cancel_unlocked(agent, action_id);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_cancel_unlocked
// file libslack/agent.c line 1768
signed int agent_cancel_unlocked(struct Agent *agent, void *action_id)
{
  struct action_t *event = (struct action_t *)action_id;
  struct action_t *next;
  _Bool tmp_if_expr_2;
  if(agent == ((struct Agent *)NULL) || event == ((struct action_t *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(agent->timewheel != ((struct timewheel_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(agent->timers != 0ul) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_3)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    void *return_value_dlink_remove_4;
    return_value_dlink_remove_4=dlink_remove((void *)event);
    next = (struct action_t *)return_value_dlink_remove_4;
    if(*event->parent == event)
      *event->parent = next;

    free((void *)event);
    agent->timers = agent->timers - 1ul;
    return 0;
  }
}

// agent_connect
// file libslack/agent.c line 620
signed int agent_connect(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_connect_unlocked(agent, fd, events, reaction, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_connect_unlocked
// file libslack/agent.c line 648
signed int agent_connect_unlocked(struct Agent *agent, signed int fd, signed int events, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int return_value_set_errno_1;
  unsigned long int tmp_post_10;
  if((7 & events) == 0 || reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !((-8 & events) == 0) || !(fd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)(fd + 1) * sizeof(signed long int) /*8ul*/ );
      agent->ids = (signed long int *)return_value_malloc_2;
      if(agent->ids == ((signed long int *)NULL))
        return -1;

      memset((void *)agent->ids, 0xff, (unsigned long int)(fd + 1) * sizeof(signed long int) /*8ul*/ );
      agent->ids_size = (unsigned long int)(fd + 1);
    }

    else
      if((unsigned long int)fd >= agent->ids_size)
      {
        void *return_value_mem_resize_fn_3;
        return_value_mem_resize_fn_3=mem_resize_fn((void **)&agent->ids, (agent->ids_size << 1) * sizeof(signed long int) /*8ul*/ );
        agent->ids = (signed long int *)return_value_mem_resize_fn_3;
        if(agent->ids == ((signed long int *)NULL))
          return -1;

        memset((void *)(agent->ids + (signed long int)agent->ids_size), 0xff, agent->ids_size * sizeof(signed long int) /*8ul*/ );
        agent->ids_size = agent->ids_size << 1;
      }

    if(agent->reactions == ((struct reaction_t *)NULL))
    {
      if(agent->method == 0)
      {
        void *return_value_malloc_4;
        return_value_malloc_4=malloc((unsigned long int)16 * sizeof(struct pollfd) /*8ul*/ );
        agent->u.pfds = (struct pollfd *)return_value_malloc_4;
        if(agent->u.pfds == ((struct pollfd *)NULL))
          return -1;

        memset((void *)agent->u.pfds, 0, (unsigned long int)16 * sizeof(struct pollfd) /*8ul*/ );
      }

      void *return_value_malloc_5;
      return_value_malloc_5=malloc((unsigned long int)16 * sizeof(struct reaction_t) /*24ul*/ );
      agent->reactions = (struct reaction_t *)return_value_malloc_5;
      if(agent->reactions == ((struct reaction_t *)NULL))
        return -1;

      memset((void *)agent->reactions, 0, (unsigned long int)16 * sizeof(struct reaction_t) /*24ul*/ );
      if(!(agent->tempo == ((struct activity_t *)NULL)))
      {
        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)16 * sizeof(struct activity_t) /*40ul*/ );
        agent->activity = (struct activity_t *)return_value_malloc_6;
        if(agent->activity == ((struct activity_t *)NULL))
          return -1;

        memset((void *)agent->activity, 0, (unsigned long int)16 * sizeof(struct activity_t) /*40ul*/ );
      }

      agent->size = (unsigned long int)16;
    }

    else
      if(agent->length == agent->size)
      {
        if(agent->method == 0)
        {
          void *return_value_mem_resize_fn_7;
          return_value_mem_resize_fn_7=mem_resize_fn((void **)&agent->u.pfds, (agent->size << 1) * sizeof(struct pollfd) /*8ul*/ );
          if(return_value_mem_resize_fn_7 == NULL)
            return -1;

          memset((void *)(agent->u.pfds + (signed long int)agent->size), 0, agent->size * sizeof(struct pollfd) /*8ul*/ );
        }

        void *return_value_mem_resize_fn_8;
        return_value_mem_resize_fn_8=mem_resize_fn((void **)&agent->reactions, (agent->size << 1) * sizeof(struct reaction_t) /*24ul*/ );
        if(return_value_mem_resize_fn_8 == NULL)
          return -1;

        memset((void *)(agent->reactions + (signed long int)agent->size), 0, agent->size * sizeof(struct reaction_t) /*24ul*/ );
        if(!(agent->tempo == ((struct activity_t *)NULL)))
        {
          void *return_value_mem_resize_fn_9;
          return_value_mem_resize_fn_9=mem_resize_fn((void **)&agent->activity, (agent->size << 1) * sizeof(struct activity_t) /*40ul*/ );
          if(return_value_mem_resize_fn_9 == NULL)
            return -1;

          memset((void *)(agent->activity + (signed long int)agent->size), 0, agent->size * sizeof(struct activity_t) /*40ul*/ );
        }

        agent->size = agent->size << 1;
      }

    if(agent->ids[(signed long int)fd] == -1l)
    {
      tmp_post_10 = agent->length;
      agent->length = agent->length + 1ul;
      agent->ids[(signed long int)fd] = (signed long int)tmp_post_10;
    }

    if(agent->method == 0)
    {
      (agent->u.pfds + agent->ids[(signed long int)fd])->fd = fd;
      (agent->u.pfds + agent->ids[(signed long int)fd])->events = (signed short int)0;
      (agent->u.pfds + agent->ids[(signed long int)fd])->revents = (signed short int)0;
      if(!((4 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x001;

      if(!((1 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x002;

      if(!((2 & events) == 0))
        (agent->u.pfds + agent->ids[(signed long int)fd])->events = (agent->u.pfds + agent->ids[(signed long int)fd])->events | (signed short int)0x004;

    }

    else
    {
      if(!((4 & events) == 0))
      {
        if(agent->u.s.rfds == ((struct anonymous_10 *)NULL))
        {
          void *return_value_malloc_11;
          return_value_malloc_11=malloc(sizeof(struct anonymous_10) /*128ul*/ );
          agent->u.s.rfds = (struct anonymous_10 *)return_value_malloc_11;
          if(agent->u.s.rfds == ((struct anonymous_10 *)NULL))
            return -1;

          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.rfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((1 & events) == 0))
      {
        if(agent->u.s.xfds == ((struct anonymous_10 *)NULL))
        {
          void *return_value_malloc_12;
          return_value_malloc_12=malloc(sizeof(struct anonymous_10) /*128ul*/ );
          agent->u.s.xfds = (struct anonymous_10 *)return_value_malloc_12;
          if(agent->u.s.xfds == ((struct anonymous_10 *)NULL))
            return -1;

          do
          {
            signed int agent_connect_unlocked__1__6__2__1____d0;
            signed int agent_connect_unlocked__1__6__2__1____d1;
            asm("cld; rep; stosq" : "=c"(agent_connect_unlocked__1__6__2__1____d0), "=D"(agent_connect_unlocked__1__6__2__1____d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.xfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((2 & events) == 0))
      {
        if(agent->u.s.wfds == ((struct anonymous_10 *)NULL))
        {
          void *return_value_malloc_13;
          return_value_malloc_13=malloc(sizeof(struct anonymous_10) /*128ul*/ );
          agent->u.s.wfds = (struct anonymous_10 *)return_value_malloc_13;
          if(agent->u.s.wfds == ((struct anonymous_10 *)NULL))
            return -1;

          do
          {
            signed int agent_connect_unlocked__1__6__3__1____d0;
            signed int agent_connect_unlocked__1__6__3__1____d1;
            asm("cld; rep; stosq" : "=c"(agent_connect_unlocked__1__6__3__1____d0), "=D"(agent_connect_unlocked__1__6__3__1____d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&agent->u.s.wfds->fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
        }

      }

      if(!((4 & events) == 0))
        agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      if(!((1 & events) == 0))
        agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      if(!((2 & events) == 0))
        agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    }
    (agent->reactions + agent->ids[(signed long int)fd])->fd = fd;
    (agent->reactions + agent->ids[(signed long int)fd])->events = events;
    (agent->reactions + agent->ids[(signed long int)fd])->reaction = reaction;
    (agent->reactions + agent->ids[(signed long int)fd])->arg = arg;
    return 0;
  }
}

// agent_create
// file libslack/agent.c line 325
struct Agent * agent_create(void)
{
  struct Agent *return_value_agent_create_with_locker_1;
  return_value_agent_create_with_locker_1=agent_create_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_with_locker_1;
}

// agent_create_measured
// file libslack/agent.c line 386
struct Agent * agent_create_measured(void)
{
  struct Agent *return_value_agent_create_measured_with_locker_1;
  return_value_agent_create_measured_with_locker_1=agent_create_measured_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_measured_with_locker_1;
}

// agent_create_measured_with_locker
// file libslack/agent.c line 402
struct Agent * agent_create_measured_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc_1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 0;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct activity_t) /*40ul*/ );
    agent->tempo = (struct activity_t *)return_value_malloc_2;
    if(agent->tempo == ((struct activity_t *)NULL))
    {
      free((void *)agent);
      return (struct Agent *)(void *)0;
    }

    else
    {
      memset((void *)agent->tempo, 0, sizeof(struct activity_t) /*40ul*/ );
      agent->locker = locker;
      return agent;
    }
  }
}

// agent_create_using_select
// file libslack/agent.c line 442
struct Agent * agent_create_using_select(void)
{
  struct Agent *return_value_agent_create_using_select_with_locker_1;
  return_value_agent_create_using_select_with_locker_1=agent_create_using_select_with_locker((struct Locker *)(void *)0);
  return return_value_agent_create_using_select_with_locker_1;
}

// agent_create_using_select_with_locker
// file libslack/agent.c line 458
struct Agent * agent_create_using_select_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc_1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 1;
    agent->locker = locker;
    return agent;
  }
}

// agent_create_with_locker
// file libslack/agent.c line 341
struct Agent * agent_create_with_locker(struct Locker *locker)
{
  struct Agent *agent;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Agent) /*120ul*/ );
  agent = (struct Agent *)return_value_malloc_1;
  if(agent == ((struct Agent *)NULL))
    return (struct Agent *)(void *)0;

  else
  {
    memset((void *)agent, 0, sizeof(struct Agent) /*120ul*/ );
    agent->method = 0;
    agent->locker = locker;
    return agent;
  }
}

// agent_dadt
// file libslack/agent.c line 1507
signed int agent_dadt(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_dadt_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_dadt_unlocked
// file libslack/agent.c line 1535
signed int agent_dadt_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  signed int return_value_set_errno_9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 4ul))
        {
          return_value_set_errno_7=set_errno(22);
          return return_value_set_errno_7;
        }

        return agent->tempo->dddt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno_8=set_errno(22);
        return return_value_set_errno_8;
      }

      else
        if(!((agent->activity + id)->detail >= 4ul))
        {
          return_value_set_errno_9=set_errno(22);
          return return_value_set_errno_9;
        }

        else
          return (agent->activity + id)->dddt;
    }
  }
}

// agent_destroy
// file libslack/agent.c line 526
void * agent_destroy(struct Agent **agent)
{
  if(!(agent == ((struct Agent **)NULL)))
  {
    if(!(*agent == ((struct Agent *)NULL)))
    {
      agent_release(*agent);
      *agent = (struct Agent *)(void *)0;
    }

  }

  return (void *)0;
}

// agent_detail
// file libslack/agent.c line 1192
signed int agent_detail(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_detail_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_detail_unlocked
// file libslack/agent.c line 1220
signed int agent_detail_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
      if(fd == -1)
        return (signed int)agent->tempo->detail;

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno_7=set_errno(22);
          return return_value_set_errno_7;
        }

        else
          return (signed int)(agent->activity + id)->detail;
      }
  }
}

// agent_disconnect
// file libslack/agent.c line 811
signed int agent_disconnect(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_disconnect_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_disconnect_unlocked
// file libslack/agent.c line 840
signed int agent_disconnect_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed long int last_id;
  signed int last_fd;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  signed int return_value_set_errno_4;
  signed int return_value_set_errno_9;
  if(agent == ((struct Agent *)NULL) || !(fd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->method == 0)
    {
      if(agent->u.pfds == ((struct pollfd *)NULL))
      {
        return_value_set_errno_2=set_errno(22);
        return return_value_set_errno_2;
      }

    }

    else
      if(agent->u.s.rfds == ((struct anonymous_10 *)NULL))
      {
        if(agent->u.s.wfds == ((struct anonymous_10 *)NULL))
        {
          if(agent->u.s.xfds == ((struct anonymous_10 *)NULL))
          {
            return_value_set_errno_3=set_errno(22);
            return return_value_set_errno_3;
          }

        }

      }

    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if(!(agent->tempo == ((struct activity_t *)NULL)))
        tmp_if_expr_6 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_8)
    {
      return_value_set_errno_4=set_errno(22);
      return return_value_set_errno_4;
    }

    else
    {
      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno_9=set_errno(22);
        return return_value_set_errno_9;
      }

      else
      {
        last_fd = (agent->reactions + (signed long int)(agent->length - (unsigned long int)1))->fd;
        last_id = agent->ids[(signed long int)last_fd];
        if(agent->method == 0)
        {
          agent->u.pfds[id] = agent->u.pfds[last_id];
          memset((void *)&agent->u.pfds[last_id], 0, sizeof(struct pollfd) /*8ul*/ );
        }

        else
        {
          if(!(agent->u.s.rfds == ((struct anonymous_10 *)NULL)))
            agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.rfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

          if(!(agent->u.s.xfds == ((struct anonymous_10 *)NULL)))
            agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.xfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

          if(!(agent->u.s.wfds == ((struct anonymous_10 *)NULL)))
            agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = agent->u.s.wfds->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

        }
        agent->reactions[id] = agent->reactions[last_id];
        if(!(agent->tempo == ((struct activity_t *)NULL)))
          agent->activity[id] = agent->activity[last_id];

        agent->ids[(signed long int)last_fd] = id;
        agent->length = agent->length - 1ul;
        memset((void *)&agent->reactions[last_id], 0, sizeof(struct reaction_t) /*24ul*/ );
        if(!(agent->tempo == ((struct activity_t *)NULL)))
          memset((void *)&agent->activity[last_id], 0, sizeof(struct activity_t) /*40ul*/ );

        agent->ids[(signed long int)fd] = (signed long int)-1;
        return 0;
      }
    }
  }
}

// agent_last
// file libslack/agent.c line 1262
struct timeval * agent_last(struct Agent *agent, signed int fd)
{
  struct timeval *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  void *return_value_set_errnull_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct timeval *)return_value_set_errnull_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct timeval *)return_value_set_errnull_2;
    }

    else
    {
      ret=agent_last_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errnull_4=set_errnull(err);
        return (struct timeval *)return_value_set_errnull_4;
      }

      else
        return ret;
    }
  }
}

// agent_last_unlocked
// file libslack/agent.c line 1291
struct timeval * agent_last_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_7;
  void *return_value_set_errnull_8;
  void *return_value_set_errnull_9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct timeval *)return_value_set_errnull_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct timeval *)return_value_set_errnull_2;
    }

    else
    {
      if(fd == -1)
      {
        if(agent->tempo->detail == 0ul)
        {
          return_value_set_errnull_7=set_errnull(22);
          return (struct timeval *)return_value_set_errnull_7;
        }

        return &agent->tempo->since;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errnull_8=set_errnull(22);
        return (struct timeval *)return_value_set_errnull_8;
      }

      else
        if((agent->activity + id)->detail == 0ul)
        {
          return_value_set_errnull_9=set_errnull(22);
          return (struct timeval *)return_value_set_errnull_9;
        }

        else
          return &(agent->activity + id)->since;
    }
  }
}

// agent_rdlock
// file libslack/agent.c line 558
signed int agent_rdlock(const struct Agent *agent)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->rdlock(agent->locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// agent_recv
// file libslack/agent.c line 1101
signed int agent_recv(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_recv_unlocked(agent, sockfd, reaction, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_recv_unlocked
// file libslack/agent.c line 1129
signed int agent_recv_unlocked(struct Agent *agent, signed int sockfd, signed int (*reaction)(struct Agent *, signed int, signed int, void *), void *arg)
{
  /* tag-#anon#lST[SYM#tag-reaction_t#'reaction'||SYM#tag-activity_t#'activity'|] */
struct anonymous_25
{
  // reaction
  struct reaction_t reaction;
  // activity
  struct activity_t activity;
};

/* */
  ;
  struct anonymous_25 buf;
  signed long int id;
  signed int fd;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_4;
  if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL) || agent == ((struct Agent *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed long int return_value_recvfd_2;
    return_value_recvfd_2=recvfd(sockfd, (void *)&buf, sizeof(struct anonymous_25) /*64ul*/ , 0, &fd);
    if(!((unsigned long int)return_value_recvfd_2 == sizeof(struct anonymous_25) /*64ul*/ ))
      return -1;

    else
    {
      if(reaction == ((signed int (*)(struct Agent *, signed int, signed int, void *))NULL))
        reaction = buf.reaction.reaction;

      if(arg == NULL)
        arg = buf.reaction.arg;

      signed int return_value_agent_connect_unlocked_3;
      return_value_agent_connect_unlocked_3=agent_connect_unlocked(agent, fd, buf.reaction.events, reaction, arg);
      if(return_value_agent_connect_unlocked_3 == -1)
        return -1;

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno_4=set_errno(22);
          return return_value_set_errno_4;
        }

        else
        {
          agent->activity[id] = buf.activity;
          return 0;
        }
      }
    }
  }
}

// agent_release
// file libslack/agent.c line 482
void agent_release(struct Agent *agent)
{
  struct Locker *agent_release__1__locker;
  if(!(agent == ((struct Agent *)NULL)))
  {
    signed int return_value_agent_wrlock_1;
    return_value_agent_wrlock_1=agent_wrlock(agent);
    if(return_value_agent_wrlock_1 == 0)
    {
      agent_release__1__locker = agent->locker;
      free((void *)agent->ids);
      if(agent->method == 0)
        free((void *)agent->u.pfds);

      else
      {
        free((void *)agent->u.s.rfds);
        free((void *)agent->u.s.wfds);
        free((void *)agent->u.s.xfds);
      }
      free((void *)agent->reactions);
      free((void *)agent->tempo);
      free((void *)agent->activity);
      timewheel_release(agent->timewheel);
      free((void *)agent);
      if(!(agent_release__1__locker == ((struct Locker *)NULL)))
        agent_release__1__locker->unlock(agent_release__1__locker->lock);

      else
        0;
    }

  }

}

// agent_schedule
// file libslack/agent.c line 1585
void * agent_schedule(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg)
{
  void *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  void *return_value_set_errnull_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      ret=agent_schedule_unlocked(agent, sec, usec, action, arg);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errnull_4=set_errnull(err);
        return return_value_set_errnull_4;
      }

      else
        return ret;
    }
  }
}

// agent_schedule_unlocked
// file libslack/agent.c line 1645
void * agent_schedule_unlocked(struct Agent *agent, signed long int sec, signed long int usec, signed int (*action)(struct Agent *, void *), void *arg)
{
  struct action_t *event;
  struct timeval now[1l];
  struct timeval delta[1l];
  struct timeval when[1l];
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_3;
  if(action == ((signed int (*)(struct Agent *, void *))NULL) || agent == ((struct Agent *)NULL) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    if(agent->timewheel == ((struct timewheel_t *)NULL))
    {
      agent->timewheel=timewheel_create();
      if(!(agent->timewheel == ((struct timewheel_t *)NULL)))
        goto __CPROVER_DUMP_L2;

      return (void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_gettimeofday_2;
      return_value_gettimeofday_2=gettimeofday(now, (struct timezone *)(void *)0);
      if(return_value_gettimeofday_2 == -1)
        return (void *)0;

      else
      {
        if(now[0l].tv_sec == agent->timewheel->now[0l].tv_sec)
          tmp_if_expr_3 = (signed int)(now[0l].tv_usec < agent->timewheel->now[0l].tv_usec);

        else
          tmp_if_expr_3 = (signed int)(now[0l].tv_sec < agent->timewheel->now[0l].tv_sec);
        if(!(tmp_if_expr_3 == 0))
          agent->timewheel->now[0l] = now[0l];

        void *return_value_malloc_4;
        return_value_malloc_4=malloc(sizeof(struct action_t) /*96ul*/ );
        event = (struct action_t *)return_value_malloc_4;
        if(event == ((struct action_t *)NULL))
          return (void *)0;

        else
        {
          timeval_set(delta, sec, usec);
          timeval_add(now, delta, when);
          event->when = when[0l];
          event->action = action;
          event->arg = arg;
          timeval_diff(agent->timewheel->now, when, delta);
          event->day = (unsigned long int)(delta[0l].tv_sec / (signed long int)(24 * 60 * 60));
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->day * (unsigned long int)24 * (unsigned long int)60 * (unsigned long int)60);
          event->hour = (unsigned long int)(delta[0l].tv_sec / (signed long int)(60 * 60));
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->hour * (unsigned long int)60 * (unsigned long int)60);
          event->minute = (unsigned long int)(delta[0l].tv_sec / (signed long int)60);
          delta[0l].tv_sec = delta[0l].tv_sec - (signed long int)(event->minute * (unsigned long int)60);
          event->second = (unsigned long int)delta[0l].tv_sec;
          event->jiffy = (unsigned long int)(delta[0l].tv_usec / (signed long int)10000);
          event->jiffy = event->jiffy + agent->timewheel->jiffy;
          if(event->jiffy >= 100ul)
          {
            event->jiffy = event->jiffy - (unsigned long int)100;
            event->second = event->second + 1ul;
          }

          event->second = event->second + agent->timewheel->second;
          if(event->second >= 60ul)
          {
            event->second = event->second - (unsigned long int)60;
            event->minute = event->minute + 1ul;
          }

          event->minute = event->minute + agent->timewheel->minute;
          if(event->minute >= 60ul)
          {
            event->minute = event->minute - (unsigned long int)60;
            event->hour = event->hour + 1ul;
          }

          event->hour = event->hour + agent->timewheel->hour;
          if(event->hour >= 24ul)
          {
            event->hour = event->hour - (unsigned long int)24;
            event->day = event->day + 1ul;
          }

          event->day = event->day + agent->timewheel->day;
          if(!(event->day == agent->timewheel->day))
            install(&agent->timewheel->days[(signed long int)(event->day % (unsigned long int)10)], event);

          else
            if(!(event->hour == agent->timewheel->hour))
              install(&agent->timewheel->hours[(signed long int)event->hour], event);

            else
              if(!(event->minute == agent->timewheel->minute))
                install(&agent->timewheel->minutes[(signed long int)event->minute], event);

              else
                if(!(event->second == agent->timewheel->second))
                  install(&agent->timewheel->seconds[(signed long int)event->second], event);

                else
                  install(&agent->timewheel->jiffies[(signed long int)event->jiffy], event);
          agent->timers = agent->timers + 1ul;
          return (void *)event;
        }
      }
    }
}

// agent_send
// file libslack/agent.c line 1027
signed int agent_send(struct Agent *agent, signed int fd, signed int sockfd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_send_unlocked(agent, fd, sockfd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_send_unlocked
// file libslack/agent.c line 1055
signed int agent_send_unlocked(struct Agent *agent, signed int fd, signed int sockfd)
{
  /* tag-#anon#lST[SYM#tag-reaction_t#'reaction'||SYM#tag-activity_t#'activity'|] */
struct anonymous_25
{
  // reaction
  struct reaction_t reaction;
  // activity
  struct activity_t activity;
};

/* */
  ;
  struct anonymous_25 buf;
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  if(agent == ((struct Agent *)NULL) || !(fd >= 0) || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno_7=set_errno(22);
        return return_value_set_errno_7;
      }

      else
      {
        buf.reaction = agent->reactions[id];
        buf.activity = agent->activity[id];
        signed long int return_value_sendfd_8;
        return_value_sendfd_8=sendfd(sockfd, (const void *)&buf, sizeof(struct anonymous_25) /*64ul*/ , 0, fd);
        if(return_value_sendfd_8 == -1l)
          return -1;

        else
        {
          signed int return_value_agent_disconnect_unlocked_9;
          return_value_agent_disconnect_unlocked_9=agent_disconnect_unlocked(agent, fd);
          if(return_value_agent_disconnect_unlocked_9 == -1)
            return -1;

          else
            return 0;
        }
      }
    }
  }
}

// agent_start
// file libslack/agent.c line 2270
signed int agent_start(struct Agent *agent)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_start_unlocked(agent);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_start_unlocked
// file libslack/agent.c line 2087
static signed int agent_start_unlocked(struct Agent *agent)
{
  _Bool tmp_if_expr_2;
  if(agent == ((struct Agent *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = agent->state != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  signed int return_value_update_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_10;
  signed int return_value_update_13;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    agent->state = 1;
    if(!(agent->timers == 0ul))
    {
      return_value_update_3=update(agent);
      if(!(return_value_update_3 == -1))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      while((_Bool)1)
      {
        if(agent->length == 0ul)
        {
          if(agent->timers == 0ul)
            goto __CPROVER_DUMP_L46;

        }

        if(agent->state == 2)
          break;

        signed int nfds;
        signed int timo;
        unsigned long int i;
        timo=timeout(agent);
        if(agent->method == 0)
        {
          nfds=poll(agent->u.pfds, agent->length, timo > 10 ? timo - 10 : timo);
          if(nfds == -1)
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            if(*return_value___errno_location_4 == 4)
              agent->state = 0;

            return -1;
          }

          if(!(nfds == 0))
          {
            struct timeval now[1l];
            signed int return_value_gettimeofday_5;
            return_value_gettimeofday_5=gettimeofday(now, (struct timezone *)(void *)0);
            if(return_value_gettimeofday_5 == -1)
              return -1;

            if(!(agent->tempo == ((struct activity_t *)NULL)))
              measure(agent, -1, now);

            i = (unsigned long int)0;
            do
            {
              if(!(nfds == 0))
                tmp_if_expr_6 = i < agent->length ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_6 = (_Bool)0;
              if(!tmp_if_expr_6)
                break;

              if(!((agent->u.pfds + (signed long int)i)->revents == 0))
              {
                signed int (*agent_start_unlocked__1__1__1__2__1__1__1__reaction)(struct Agent *, signed int, signed int, void *) = (agent->reactions + (signed long int)i)->reaction;
                signed int agent_start_unlocked__1__1__1__2__1__1__1__fd = (agent->reactions + (signed long int)i)->fd;
                signed int agent_start_unlocked__1__1__1__2__1__1__1__revents;
                agent_start_unlocked__1__1__1__2__1__1__1__revents=translate((signed int)(agent->u.pfds + (signed long int)i)->revents);
                void *agent_start_unlocked__1__1__1__2__1__1__1__arg = (agent->reactions + (signed long int)i)->arg;
                (agent->u.pfds + (signed long int)i)->revents = (signed short int)0;
                if(!(agent->tempo == ((struct activity_t *)NULL)))
                  measure(agent, agent_start_unlocked__1__1__1__2__1__1__1__fd, now);

                signed int return_value_react_7;
                return_value_react_7=react(agent_start_unlocked__1__1__1__2__1__1__1__reaction, agent, agent_start_unlocked__1__1__1__2__1__1__1__fd, agent_start_unlocked__1__1__1__2__1__1__1__revents, agent_start_unlocked__1__1__1__2__1__1__1__arg);
                if(return_value_react_7 == -1)
                  return -1;

                nfds = nfds - 1;
              }

              i = i + 1ul;
            }
            while((_Bool)1);
          }

          else
          {
            struct timeval agent_start_unlocked__1__1__1__3__delta[1l];
            struct timeval agent_start_unlocked__1__1__1__3__result[1l];
            timeval_set(agent_start_unlocked__1__1__1__3__delta, (signed long int)0, (signed long int)(timo * 1000));
            timeval_add(agent->timewheel->now, agent_start_unlocked__1__1__1__3__delta, agent_start_unlocked__1__1__1__3__result);
            agent->timewheel->now[0l] = agent_start_unlocked__1__1__1__3__result[0l];
            agent->timewheel->jiffy = agent->timewheel->jiffy + (unsigned long int)(timo / 10);
            if(agent->timewheel->jiffy == 100ul)
              next_second(agent);

            signed int return_value_expire_8;
            return_value_expire_8=expire(agent);
            if(return_value_expire_8 == -1)
              return -1;

          }
        }

        else
        {
          struct timeval tv[1l];
          struct timeval *to;
          struct anonymous_10 readset[1l];
          struct anonymous_10 *rfds = (struct anonymous_10 *)(void *)0;
          struct anonymous_10 writeset[1l];
          struct anonymous_10 *wfds = (struct anonymous_10 *)(void *)0;
          struct anonymous_10 exceptset[1l];
          struct anonymous_10 *xfds = (struct anonymous_10 *)(void *)0;
          if(!(agent->u.s.rfds == ((struct anonymous_10 *)NULL)))
          {
            rfds = readset;
            *rfds = *agent->u.s.rfds;
          }

          if(!(agent->u.s.wfds == ((struct anonymous_10 *)NULL)))
          {
            wfds = writeset;
            *wfds = *agent->u.s.wfds;
          }

          if(!(agent->u.s.xfds == ((struct anonymous_10 *)NULL)))
          {
            xfds = exceptset;
            *xfds = *agent->u.s.xfds;
          }

          if(timo == -1)
            to = (struct timeval *)(void *)0;

          else
          {
            tv[0l].tv_sec = (signed long int)(timo / 1000);
            tv[0l].tv_usec = (signed long int)((timo % 1000) * 1000);
            to = tv;
          }
          nfds=select((signed int)agent->ids_size, rfds, wfds, xfds, to);
          if(nfds == -1)
            return -1;

          if(!(nfds == 0))
          {
            struct timeval agent_start_unlocked__1__1__2__2__now[1l];
            signed int return_value_gettimeofday_9;
            return_value_gettimeofday_9=gettimeofday(agent_start_unlocked__1__1__2__2__now, (struct timezone *)(void *)0);
            if(return_value_gettimeofday_9 == -1)
              return -1;

            if(!(agent->tempo == ((struct activity_t *)NULL)))
              measure(agent, -1, agent_start_unlocked__1__1__2__2__now);

            i = (unsigned long int)0;
            do
            {
              if(!(nfds == 0))
                tmp_if_expr_10 = i < agent->length ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_10 = (_Bool)0;
              if(!tmp_if_expr_10)
                break;

              signed int fd = (agent->reactions + (signed long int)i)->fd;
              signed int revents = 0;
              if(!(rfds == ((struct anonymous_10 *)NULL)))
              {
                if(!((rfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 4;

              }

              if(!(wfds == ((struct anonymous_10 *)NULL)))
              {
                if(!((wfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 2;

              }

              if(!(xfds == ((struct anonymous_10 *)NULL)))
              {
                if(!((xfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  revents = revents | 1;

              }

              if(!(revents == 0))
              {
                signed int (*reaction)(struct Agent *, signed int, signed int, void *) = (agent->reactions + (signed long int)i)->reaction;
                void *arg = (agent->reactions + (signed long int)i)->arg;
                if(!(agent->tempo == ((struct activity_t *)NULL)))
                  measure(agent, fd, agent_start_unlocked__1__1__2__2__now);

                signed int return_value_react_11;
                return_value_react_11=react(reaction, agent, fd, revents, arg);
                if(return_value_react_11 == -1)
                  return -1;

                nfds = nfds - 1;
              }

              i = i + 1ul;
            }
            while((_Bool)1);
          }

          else
          {
            struct timeval delta[1l];
            struct timeval result[1l];
            timeval_set(delta, (signed long int)0, (signed long int)(timo * 1000));
            timeval_add(agent->timewheel->now, delta, result);
            agent->timewheel->now[0l] = result[0l];
            agent->timewheel->jiffy = agent->timewheel->jiffy + (unsigned long int)(timo / 10);
            if(agent->timewheel->jiffy == 100ul)
              next_second(agent);

            signed int return_value_expire_12;
            return_value_expire_12=expire(agent);
            if(return_value_expire_12 == -1)
              return -1;

          }
        }
        if(!(agent->timers == 0ul))
        {
          return_value_update_13=update(agent);
          if(return_value_update_13 == -1)
            return -1;

        }

      }

    __CPROVER_DUMP_L46:
      ;
      agent->state = 0;
      return 0;
    }
  }
}

// agent_stop
// file libslack/agent.c line 2312
signed int agent_stop(struct Agent *agent)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_stop_unlocked(agent);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_stop_unlocked
// file libslack/agent.c line 2302
static signed int agent_stop_unlocked(struct Agent *agent)
{
  _Bool tmp_if_expr_2;
  if(agent == ((struct Agent *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = agent->state != 1 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    agent->state = 2;
    return 0;
  }
}

// agent_transfer
// file libslack/agent.c line 927
signed int agent_transfer(struct Agent *agent, signed int fd, struct Agent *dst)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_transfer_unlocked(agent, fd, dst);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_transfer_unlocked
// file libslack/agent.c line 956
signed int agent_transfer_unlocked(struct Agent *agent, signed int fd, struct Agent *dst)
{
  struct reaction_t reaction;
  struct activity_t activity;
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  if(agent == ((struct Agent *)NULL) || dst == ((struct Agent *)NULL) || !(fd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
      if(dst->tempo == ((struct activity_t *)NULL))
      {
        return_value_set_errno_7=set_errno(22);
        return return_value_set_errno_7;
      }

      else
      {
        id = agent->ids[(signed long int)fd];
        if(id == -1l)
        {
          return_value_set_errno_8=set_errno(22);
          return return_value_set_errno_8;
        }

        else
        {
          reaction = agent->reactions[id];
          activity = agent->activity[id];
          signed int return_value_agent_connect_9;
          return_value_agent_connect_9=agent_connect(dst, reaction.fd, reaction.events, reaction.reaction, reaction.arg);
          if(return_value_agent_connect_9 == -1)
            return -1;

          else
          {
            dst->activity[dst->ids[(signed long int)fd]] = activity;
            signed int return_value_agent_disconnect_unlocked_10;
            return_value_agent_disconnect_unlocked_10=agent_disconnect_unlocked(agent, fd);
            if(return_value_agent_disconnect_unlocked_10 == -1)
            {
              agent_disconnect(dst, fd);
              return -1;
            }

            else
              return 0;
          }
        }
      }
  }
}

// agent_unlock
// file libslack/agent.c line 596
signed int agent_unlock(const struct Agent *agent)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// agent_velocity
// file libslack/agent.c line 1342
signed int agent_velocity(struct Agent *agent, signed int fd)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(agent == ((struct Agent *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value=agent->locker->rdlock(agent->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=agent_velocity_unlocked(agent, fd);
      if(!(agent->locker == ((struct Locker *)NULL)))
      {
        return_value_1=agent->locker->unlock(agent->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// agent_velocity_unlocked
// file libslack/agent.c line 1370
signed int agent_velocity_unlocked(struct Agent *agent, signed int fd)
{
  signed long int id;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  signed int return_value_set_errno_9;
  if(agent == ((struct Agent *)NULL) || !(fd >= -1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(agent->ids == ((signed long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(agent->reactions != ((struct reaction_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = !(agent->tempo != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(agent->activity != ((struct activity_t *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = agent->ids_size <= (unsigned long int)fd ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      if(fd == -1)
      {
        if(!(agent->tempo->detail >= 2ul))
        {
          return_value_set_errno_7=set_errno(22);
          return return_value_set_errno_7;
        }

        return agent->tempo->dt;
      }

      id = agent->ids[(signed long int)fd];
      if(id == -1l)
      {
        return_value_set_errno_8=set_errno(22);
        return return_value_set_errno_8;
      }

      else
        if(!((agent->activity + id)->detail >= 2ul))
        {
          return_value_set_errno_9=set_errno(22);
          return return_value_set_errno_9;
        }

        else
          return (agent->activity + id)->dt;
    }
  }
}

// agent_wrlock
// file libslack/agent.c line 579
signed int agent_wrlock(const struct Agent *agent)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->wrlock(agent->locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// alert
// file libslack/err.c line 456
void alert(signed int priority, const char *format, ...)
{
  void **args = (void **)&format;
  valert(priority, format, args);
  args = ((void **)NULL);
}

// alertsys
// file libslack/err.c line 677
void alertsys(signed int priority, const char *format, ...)
{
  void **args = (void **)&format;
  valertsys(priority, format, args);
  args = ((void **)NULL);
}

// asprintf
// file libslack/str.c line 6826
signed int asprintf(char **str, const char *format, ...)
{
  signed int ret;
  void **args = (void **)&format;
  ret=vasprintf(str, format, args);
  args = ((void **)NULL);
  return ret;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// bin
// file libslack/str.c line 6284
signed int bin(const char *str)
{
  signed int ret = 0;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if((signed int)*str == 48)
    {
      if((signed int)str[1l] == 98)
        str = str + (signed long int)2;

    }

    for( ; !(*str == 0); str = str + 1l)
    {
      ret = ret << 1;
      switch((signed int)*str)
      {
        case 48:
          break;
        case 49:
        {
          ret = ret | 1;
          break;
        }
        default:
        {
          return_value_set_errno_2=set_errno(22);
          return return_value_set_errno_2;
        }
      }
    }
    return ret;
  }
}

// build_sockopts
// file libslack/net.c line 286
static struct sockopt_t * build_sockopts(struct sockopt_t *sockopts, signed int *rcvbufsz, signed int *sndbufsz)
{
  unsigned long int so = (unsigned long int)0;
  if(!(*rcvbufsz == 0))
  {
    (sockopts + (signed long int)so)->level = 1;
    (sockopts + (signed long int)so)->optname = 8;
    (sockopts + (signed long int)so)->optval = (const void *)rcvbufsz;
    (sockopts + (signed long int)so)->optlen = (signed int)sizeof(signed int) /*4ul*/ ;
    so = so + 1ul;
  }

  if(!(*sndbufsz == 0))
  {
    (sockopts + (signed long int)so)->level = 1;
    (sockopts + (signed long int)so)->optname = 7;
    (sockopts + (signed long int)so)->optval = (const void *)sndbufsz;
    (sockopts + (signed long int)so)->optlen = (signed int)sizeof(signed int) /*4ul*/ ;
    so = so + 1ul;
  }

  (sockopts + (signed long int)so)->optval = (void *)0;
  return sockopts;
}

// chomp
// file libslack/str.c line 6204
signed int chomp(char *str)
{
  char *s;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_2;
  if(str == ((char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if((signed int)*str == 0)
      return 0;

    else
    {
      for( ; !(str[1l] == 0); str = str + 1l)
        ;
      s = str;
      do
      {
        if((signed int)*s == 10)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*s == 13 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        *s = (char)0;
        s = s - 1l;
      }
      while((_Bool)1);
      return (signed int)(str - s);
    }
}

// chop
// file libslack/str.c line 6113
signed int chop(char *str)
{
  signed int ret;
  _Bool tmp_if_expr_2;
  if(str == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*str != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    for( ; !(str[1l] == 0); str = str + 1l)
      ;
    ret = (signed int)*str;
    *str = (char)0;
    return ret;
  }
}

// consume
// file libslack/map.c line 2517
void * consume(void *arg)
{
  signed int i;
  signed int test = *((signed int *)arg);
  char ack;
  i = 1;
  signed long int return_value_read_1;
  signed int *return_value___errno_location_2;
  for( ; lim >= i; i = i + 1)
  {
    if(!(debug == 0))
      printf("c: pop\n");

    do
    {
      return_value_read_1=read(size[(signed long int)0], (void *)&ack, (unsigned long int)1);
      if(!(return_value_read_1 == -1l))
        break;

      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 4))
        break;

    }
    while((_Bool)1);
    signed int return_value_map_remove_3;
    return_value_map_remove_3=map_remove(mtmap, (void *)(signed long int)i);
    if(return_value_map_remove_3 == -1)
    {
      errors = errors + 1;
      printf("Test%d: map_remove(mtmap, %d), failed\n", test, i);
      break;
    }

    if(!(debug == 0))
      printf("c: remove %d\n", i);

  }
  if(!(i == 1 + lim))
  {
    errors = errors + 1;
    printf("Test%d: consumer read %d items, not %d\n", test, i - 1, lim);
  }

  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// contract
// file libslack/list.c line 296
static signed int contract(struct List *list, signed long int index, unsigned long int range)
{
  memmove((void *)(list->list + index), (const void *)(list->list + index + (signed long int)range), ((list->length - (unsigned long int)index) - range) * sizeof(void *) /*8ul*/ );
  signed int return_value_shrink_1;
  return_value_shrink_1=shrink(list, range);
  if(return_value_shrink_1 == -1)
    return -1;

  else
  {
    list->length = list->length - range;
    return 0;
  }
}

// contract_link1
// file libslack/str.c line 475
static signed int contract_link1(struct String *str, signed long int index_link1, unsigned long int range_link1)
{
  memmove((void *)(str->str + index_link1), (const void *)(str->str + index_link1 + (signed long int)range_link1), ((str->length - (unsigned long int)index_link1) - range_link1) * sizeof(char) /*1ul*/ );
  signed int return_value_shrink_1_link1;
  return_value_shrink_1_link1=shrink_link1(str, range_link1);
  if(return_value_shrink_1_link1 == -1)
    return -1;

  else
  {
    str->length = str->length - range_link1;
    return 0;
  }
}

// coproc_close
// file libslack/coproc.c line 348
signed int coproc_close(signed int pid, signed int *to, signed int *from, signed int *err)
{
  signed int status = 0;
  signed int return_value_set_errno_1;
  if(!(pid >= 1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(to == ((signed int *)NULL)))
    {
      if(!(*to == -1))
      {
        close(*to);
        *to = -1;
      }

    }

    if(!(from == ((signed int *)NULL)))
    {
      if(!(*from == -1))
      {
        close(*from);
        *from = -1;
      }

    }

    if(!(err == ((signed int *)NULL)))
    {
      if(!(*err == -1))
      {
        close(*err);
        *err = -1;
      }

    }

    signed int return_value_waitpid_2;
    return_value_waitpid_2=waitpid(pid, &status, 0);
    if(return_value_waitpid_2 == -1)
      return -1;

    else
      return status;
  }
}

// coproc_open
// file libslack/coproc.c line 216
signed int coproc_open(signed int *to, signed int *from, signed int *err, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data)
{
  signed int to_pipe[2l];
  signed int from_pipe[2l];
  signed int err_pipe[2l];
  signed int pid;
  signed int has_meta;
  signed int return_value_set_errno_1;
  unsigned long int tmp_statement_expression_2;
  signed int return_value_set_errno_4;
  if(err == ((signed int *)NULL) || from == ((signed int *)NULL) || to == ((signed int *)NULL) || cmd == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    char __r0;
    char __r1;
    char __r2;
    unsigned long int return_value___builtin_strcspn_3;
    return_value___builtin_strcspn_3=__builtin_strcspn(cmd, "|&;()<>[]{}_`'~\"\\*? \t\r\n");
    tmp_statement_expression_2 = return_value___builtin_strcspn_3;
    has_meta = (signed int)((signed int)cmd[(signed long int)tmp_statement_expression_2] != 0);
    if(argv == ((char * const *)NULL) && has_meta == 0 || !(argv == ((char * const *)NULL)) && !(has_meta == 0))
    {
      return_value_set_errno_4=set_errno(22);
      return return_value_set_errno_4;
    }

    else
    {
      signed int return_value_pipe_5;
      return_value_pipe_5=pipe(to_pipe);
      if(return_value_pipe_5 == -1)
        return -1;

      else
      {
        signed int return_value_pipe_6;
        return_value_pipe_6=pipe(from_pipe);
        if(return_value_pipe_6 == -1)
        {
          close(to_pipe[(signed long int)0]);
          close(to_pipe[(signed long int)1]);
          return -1;
        }

        else
        {
          signed int return_value_pipe_7;
          return_value_pipe_7=pipe(err_pipe);
          if(return_value_pipe_7 == -1)
          {
            close(to_pipe[(signed long int)0]);
            close(to_pipe[(signed long int)1]);
            close(from_pipe[(signed long int)0]);
            close(from_pipe[(signed long int)1]);
            return -1;
          }

          else
          {
            pid=fork();
            if(!(pid == -1))
            {
              if(pid == 0)
                goto __CPROVER_DUMP_L7;

            }

            else
            {
              close(to_pipe[(signed long int)0]);
              close(to_pipe[(signed long int)1]);
              close(from_pipe[(signed long int)0]);
              close(from_pipe[(signed long int)1]);
              close(err_pipe[(signed long int)0]);
              close(err_pipe[(signed long int)1]);
              return -1;

            __CPROVER_DUMP_L7:
              ;
              if(!(action == ((void (*)(void *))NULL)))
                action(data);

              close(to_pipe[(signed long int)1]);
              close(from_pipe[(signed long int)0]);
              close(err_pipe[(signed long int)0]);
              if(!(to_pipe[0l] == 0))
              {
                signed int return_value_dup2_8;
                return_value_dup2_8=dup2(to_pipe[(signed long int)0], 0);
                if(return_value_dup2_8 == -1)
                  _exit(1);

                close(to_pipe[(signed long int)0]);
              }

              if(!(from_pipe[1l] == 1))
              {
                signed int return_value_dup2_9;
                return_value_dup2_9=dup2(from_pipe[(signed long int)1], 1);
                if(return_value_dup2_9 == -1)
                  _exit(1);

                close(from_pipe[(signed long int)1]);
              }

              if(!(err_pipe[1l] == 2))
              {
                signed int return_value_dup2_10;
                return_value_dup2_10=dup2(err_pipe[(signed long int)1], 2);
                if(return_value_dup2_10 == -1)
                  _exit(1);

                close(err_pipe[(signed long int)1]);
              }

              do_exec(has_meta, cmd, argv, envv);
              _exit(1);
            }
            close(to_pipe[(signed long int)0]);
            close(from_pipe[(signed long int)1]);
            close(err_pipe[(signed long int)1]);
            *to = to_pipe[(signed long int)1];
            *from = from_pipe[(signed long int)0];
            *err = err_pipe[(signed long int)0];
            return pid;
          }
        }
      }
    }
  }
}

// coproc_pty_close
// file libslack/coproc.c line 464
signed int coproc_pty_close(signed int pid, signed int *masterfd, const char *slavename)
{
  signed int status = 0;
  signed int return_value_set_errno_1;
  if(!(pid >= 1))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(masterfd == ((signed int *)NULL)))
    {
      if(!(*masterfd == -1))
      {
        pty_release(slavename);
        close(*masterfd);
        *masterfd = -1;
      }

    }

    signed int return_value_waitpid_2;
    return_value_waitpid_2=waitpid(pid, &status, 0);
    if(return_value_waitpid_2 == -1)
      return -1;

    else
      return status;
  }
}

// coproc_pty_open
// file libslack/coproc.c line 405
signed int coproc_pty_open(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize, const char *cmd, char * const *argv, char * const *envv, void (*action)(void *), void *data)
{
  signed int pid;
  signed int has_meta;
  signed int return_value_set_errno_1;
  unsigned long int tmp_statement_expression_2;
  signed int return_value_set_errno_4;
  if(masterfd == ((signed int *)NULL) || cmd == ((const char *)NULL) || slavename == ((char *)NULL) || !(slavenamesize >= 64ul))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    char __r0;
    char __r1;
    char __r2;
    unsigned long int return_value___builtin_strcspn_3;
    return_value___builtin_strcspn_3=__builtin_strcspn(cmd, "|&;()<>[]{}_`'~\"\\*? \t\r\n");
    tmp_statement_expression_2 = return_value___builtin_strcspn_3;
    has_meta = (signed int)((signed int)cmd[(signed long int)tmp_statement_expression_2] != 0);
    if(argv == ((char * const *)NULL) && has_meta == 0 || !(argv == ((char * const *)NULL)) && !(has_meta == 0))
    {
      return_value_set_errno_4=set_errno(22);
      return return_value_set_errno_4;
    }

    else
    {
      pid=pty_fork(masterfd, slavename, slavenamesize, slave_termios, slave_winsize);
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        return -1;

      __CPROVER_DUMP_L4:
        ;
        if(!(action == ((void (*)(void *))NULL)))
          action(data);

        do_exec(has_meta, cmd, argv, envv);
        _exit(1);
      }
      return pid;
    }
  }
}

// cstr
// file libslack/str.h line 82
char * cstr(const struct String *str)
{
  void *return_value_set_errnull_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
    return str->str;
}

// cstrcat
// file libslack/str.c line 6689
char * cstrcat(char *dst, const char *src)
{
  for( ; !(*dst == 0); dst = dst + 1l)
    ;
  char *tmp_post_1;
  const char *tmp_post_2;
  do
  {
    tmp_post_1 = dst;
    dst = dst + 1l;
    tmp_post_2 = src;
    src = src + 1l;
    *tmp_post_1 = *tmp_post_2;
    if(*tmp_post_1 == 0)
      break;

  }
  while((_Bool)1);
  return dst - (signed long int)1;
}

// cstrchr
// file libslack/str.c line 6714
char * cstrchr(const char *str, signed int c)
{
  for( ; !(*str == 0); str = str + 1l)
    if(*str == (char)c)
      break;

  return (char *)str;
}

// cstrcpy
// file libslack/str.c line 6666
char * cstrcpy(char *dst, const char *src)
{
  char *tmp_post_1;
  const char *tmp_post_2;
  do
  {
    tmp_post_1 = dst;
    dst = dst + 1l;
    tmp_post_2 = src;
    src = src + 1l;
    *tmp_post_1 = *tmp_post_2;
    if(*tmp_post_1 == 0)
      break;

  }
  while((_Bool)1);
  return dst - (signed long int)1;
}

// cstrpbrk
// file libslack/str.c line 6736
char * cstrpbrk(const char *str, const char *brk)
{
  const char *b;
  for( ; !(*str == 0); str = str + 1l)
  {
    b = brk;
    for( ; !(*b == 0); b = b + 1l)
      if(*str == *b)
        return (char *)str;

  }
  return (char *)str;
}

// cstrrchr
// file libslack/str.c line 6762
char * cstrrchr(const char *str, signed int c)
{
  char *match = (char *)(void *)0;
  for( ; !(*str == 0); str = str + 1l)
    if(*str == (char)c)
      match = (char *)str;

  return match != ((char *)NULL) ? match : (char *)str;
}

// cstrstr
// file libslack/str.c line 6787
char * cstrstr(const char *str, const char *srch)
{
  if((signed int)*srch == 0)
    return (char *)str;

  else
  {
    do
    {
      str=cstrchr(str, (signed int)*srch);
      if(*str == 0)
        break;

      char *s = (char *)str;
      char *r = (char *)srch;
      do
      {
        r = r + 1l;
        if((signed int)*r == 0)
          return (char *)str;

        s = s + 1l;
        if(!(*s == *r))
          break;

      }
      while((_Bool)1);
      str = str + 1l;
    }
    while((_Bool)1);
    return (char *)str;
  }
}

// daemon_absolute_path
// file libslack/daemon.c line 273
char * daemon_absolute_path(const char *path)
{
  unsigned long int path_len;
  char *abs_path;
  char *p;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if(path == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    if(!((signed int)*path == 47))
    {
      signed long int daemon_absolute_path__1__1__lim;
      daemon_absolute_path__1__1__lim=limit_path();
      char *cwd;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)daemon_absolute_path__1__1__lim * sizeof(char) /*1ul*/ );
      cwd = (char *)return_value_malloc_2;
      unsigned long int cwd_len;
      signed int rc;
      if(cwd == ((char *)NULL))
        return (char *)(void *)0;

      char *return_value_getcwd_3;
      return_value_getcwd_3=getcwd(cwd, (unsigned long int)daemon_absolute_path__1__1__lim);
      if(return_value_getcwd_3 == ((char *)NULL))
      {
        free((void *)cwd);
        return (char *)(void *)0;
      }

      cwd_len=strlen(cwd);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(path);
      if(1ul + return_value_strlen_5 + cwd_len >= (unsigned long int)daemon_absolute_path__1__1__lim)
      {
        free((void *)cwd);
        void *return_value_set_errnull_4;
        return_value_set_errnull_4=set_errnull(36);
        return (char *)return_value_set_errnull_4;
      }

      rc=snprintf(cwd + (signed long int)cwd_len, (unsigned long int)daemon_absolute_path__1__1__lim - cwd_len, "%c%s", 47, path);
      if(rc == -1 || (unsigned long int)rc >= (unsigned long int)daemon_absolute_path__1__1__lim + -cwd_len)
      {
        free((void *)cwd);
        void *return_value_set_errnull_6;
        return_value_set_errnull_6=set_errnull(36);
        return (char *)return_value_set_errnull_6;
      }

      abs_path = cwd;
    }

    else
    {
      abs_path=mem_strdup(path);
      if(abs_path == ((char *)NULL))
        return (char *)(void *)0;

    }
    path_len=strlen(abs_path);
    p = abs_path;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 47)
      {
        if((signed int)p[1l] == 47)
        {
          memmove((void *)p, (const void *)(p + (signed long int)1), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)1) - abs_path));
          path_len = path_len - 1ul;
          p = p - 1l;
        }

        else
          if((signed int)p[1l] == 46)
          {
            if((signed int)p[2l] == 47)
              tmp_if_expr_10 = (_Bool)1;

            else
              tmp_if_expr_10 = (signed int)p[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_10)
            {
              signed int keep_sep;
              if(p == abs_path)
                tmp_if_expr_7 = (signed int)p[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_7 = (_Bool)0;
              keep_sep = (signed int)tmp_if_expr_7;
              memmove((void *)(p + (signed long int)keep_sep), (const void *)(p + (signed long int)2), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)2) - abs_path));
              path_len = path_len - (unsigned long int)(2 - keep_sep);
              p = p - 1l;
            }

            else
              if((signed int)p[2l] == 46)
              {
                if((signed int)p[3l] == 47)
                  tmp_if_expr_9 = (_Bool)1;

                else
                  tmp_if_expr_9 = (signed int)p[(signed long int)3] == 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_9)
                {
                  char *scan;
                  char *parent;
                  signed int daemon_absolute_path__1__3__1__1__2__2__keep_sep;
                  parent = p;
                  scan = parent;
                  while(!(abs_path >= scan))
                  {
                    scan = scan - 1l;
                    if((signed int)*scan == 47)
                    {
                      parent = scan;
                      break;
                    }

                  }
                  if(parent == abs_path)
                    tmp_if_expr_8 = (signed int)p[(signed long int)3] == 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_8 = (_Bool)0;
                  daemon_absolute_path__1__3__1__1__2__2__keep_sep = (signed int)tmp_if_expr_8;
                  memmove((void *)(parent + (signed long int)daemon_absolute_path__1__3__1__1__2__2__keep_sep), (const void *)(p + (signed long int)3), (path_len + (unsigned long int)1) - (unsigned long int)((p + (signed long int)3) - abs_path));
                  path_len = path_len - (unsigned long int)((p + (signed long int)3) - parent);
                  p = parent - (signed long int)1;
                }

              }

          }

      }

    for( ; path_len >= 2ul; abs_path[(signed long int)path_len] = (char)0)
    {
      if(!((signed int)abs_path[-1l + (signed long int)path_len] == 47))
        break;

      path_len = path_len - 1ul;
    }
    return abs_path;
  }
}

// daemon_become_user
// file libslack/daemon.c line 233
signed int daemon_become_user(unsigned int uid, unsigned int gid, char *user)
{
  unsigned int gids[10l];
  signed int daemon_become_user__1__g = 0;
  signed int return_value_setgroups_5;
  return_value_setgroups_5=setgroups((unsigned long int)0, (const unsigned int *)(void *)0);
  _Bool tmp_if_expr_6;
  if(return_value_setgroups_5 == -1)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    daemon_become_user__1__g=getgroups(0, (unsigned int *)(void *)0);
    tmp_if_expr_6 = daemon_become_user__1__g != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  signed int return_value_getgroups_1;
  _Bool tmp_if_expr_4;
  unsigned int return_value_getgid_3;
  if(tmp_if_expr_6)
  {
    if(!(daemon_become_user__1__g == 1))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_getgroups_1=getgroups(10, gids);
      tmp_if_expr_2 = return_value_getgroups_1 != 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_getgid_3=getgid();
      tmp_if_expr_4 = gids[(signed long int)0] != return_value_getgid_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return -1;

  }

  signed int return_value_setgid_7;
  return_value_setgid_7=setgid(gid);
  _Bool tmp_if_expr_9;
  unsigned int return_value_getgid_8;
  if(return_value_setgid_7 == -1)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_getgid_8=getgid();
    tmp_if_expr_9 = return_value_getgid_8 != gid ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  unsigned int return_value_getegid_10;
  if(tmp_if_expr_9)
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value_getegid_10=getegid();
    tmp_if_expr_11 = return_value_getegid_10 != gid ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_initgroups_12;
  _Bool tmp_if_expr_15;
  unsigned int return_value_getuid_14;
  _Bool tmp_if_expr_17;
  unsigned int return_value_geteuid_16;
  if(tmp_if_expr_11)
    return -1;

  else
    if(!(user == ((char *)NULL)))
    {
      return_value_initgroups_12=initgroups(user, gid);
      if(!(return_value_initgroups_12 == -1))
        goto __CPROVER_DUMP_L14;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      signed int return_value_setuid_13;
      return_value_setuid_13=setuid(uid);
      if(return_value_setuid_13 == -1)
        tmp_if_expr_15 = (_Bool)1;

      else
      {
        return_value_getuid_14=getuid();
        tmp_if_expr_15 = return_value_getuid_14 != uid ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_15)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        return_value_geteuid_16=geteuid();
        tmp_if_expr_17 = return_value_geteuid_16 != uid ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
        return -1;

      else
        return 0;
    }
}

// daemon_check_path
// file libslack/daemon.c line 395
static signed int daemon_check_path(char *path, char *explanation, unsigned long int explanation_size, signed int level)
{
  struct stat status[1l];
  char *sep;
  signed int rc;
  signed int return_value_set_errno_1;
  if(level >= 17)
  {
    return_value_set_errno_1=set_errno(40);
    return return_value_set_errno_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(path);
    sep = path + (signed long int)return_value_strlen_2;
    while(!(sep == ((char *)NULL)))
    {
      sep[(signed long int)(sep == path)] = (char)0;
      signed int return_value_lstat_3;
      return_value_lstat_3=lstat(path, status);
      if(return_value_lstat_3 == -1)
        return -1;

      if((61440u & status[0l].st_mode) == 40960u)
      {
        unsigned long int daemon_check_path__1__1__1__1__lim;
        char *sym_linked;
        char *tmp;
        signed long int return_value_limit_path_4;
        return_value_limit_path_4=limit_path();
        daemon_check_path__1__1__1__1__lim = (unsigned long int)return_value_limit_path_4;
        void *return_value_malloc_5;
        return_value_malloc_5=malloc(daemon_check_path__1__1__1__1__lim * sizeof(char) /*1ul*/ );
        sym_linked = (char *)return_value_malloc_5;
        if(sym_linked == ((char *)NULL))
          return -1;

        memset((void *)sym_linked, 0, daemon_check_path__1__1__1__1__lim);
        signed long int return_value_readlink_6;
        return_value_readlink_6=readlink(path, sym_linked, daemon_check_path__1__1__1__1__lim);
        if(return_value_readlink_6 == -1l)
        {
          free((void *)sym_linked);
          return -1;
        }

        if(!((signed int)*sym_linked == 47))
        {
          void *return_value_malloc_7;
          return_value_malloc_7=malloc(daemon_check_path__1__1__1__1__lim * sizeof(char) /*1ul*/ );
          tmp = (char *)return_value_malloc_7;
          if(tmp == ((char *)NULL))
          {
            free((void *)sym_linked);
            return -1;
          }

          rc=snprintf(tmp, daemon_check_path__1__1__1__1__lim, "%s%c..%c%s", path, 47, 47, sym_linked);
          if(rc == -1 || (unsigned long int)rc >= daemon_check_path__1__1__1__1__lim)
          {
            free((void *)sym_linked);
            free((void *)tmp);
            signed int return_value_set_errno_8;
            return_value_set_errno_8=set_errno(36);
            return return_value_set_errno_8;
          }

          rc=snprintf(sym_linked, daemon_check_path__1__1__1__1__lim, "%s", tmp);
          free((void *)tmp);
          if(rc == -1 || (unsigned long int)rc >= daemon_check_path__1__1__1__1__lim)
          {
            free((void *)sym_linked);
            signed int return_value_set_errno_9;
            return_value_set_errno_9=set_errno(36);
            return return_value_set_errno_9;
          }

        }

        tmp=daemon_absolute_path(sym_linked);
        free((void *)sym_linked);
        sym_linked = tmp;
        if(sym_linked == ((char *)NULL))
          return -1;

        rc=daemon_check_path(sym_linked, explanation, explanation_size, level + 1);
        free((void *)sym_linked);
        if(!(rc == -1))
        {
          if(rc == 0)
            goto __CPROVER_DUMP_L12;

          if(rc == 1)
            goto __CPROVER_DUMP_L13;

        }

        else
        {
          return -1;

        __CPROVER_DUMP_L12:
          ;
          return 0;
        }
      }

      else
        if(!((18u & status[0l].st_mode) == 0u))
        {
          if(!(explanation == ((char *)NULL)))
            snprintf(explanation, explanation_size, "%s is %s%s%s writable", path, (status[0l].st_mode & (unsigned int)(0200 >> 3)) != 0u ? "group" : "", (status[0l].st_mode & (unsigned int)(0200 >> 3 | (0200 >> 3) >> 3)) == (unsigned int)(0200 >> 3 | (0200 >> 3) >> 3) ? " and " : "", (status[0l].st_mode & (unsigned int)((0200 >> 3) >> 3)) != 0u ? "world" : "");

          return 0;
        }


    __CPROVER_DUMP_L13:
      ;
      if(sep == path)
        break;

      sep=strrchr(path, 47);
    }
    return 1;
  }
}

// daemon_close
// file libslack/daemon.c line 1038
signed int daemon_close(void)
{
  signed int err;
  err=pthread_mutex_lock(&g.lock);
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(g.pidfile == ((char *)NULL)))
    {
      unlink(g.pidfile);
      mem_destroy((void **)&g.pidfile);
    }

    signed int daemon_close__1__3__err;
    daemon_close__1__3__err=pthread_mutex_unlock(&g.lock);
    if(!(daemon_close__1__3__err == 0))
    {
      return_value_set_errno_2=set_errno(daemon_close__1__3__err);
      return return_value_set_errno_2;
    }

    else
      return 0;
  }
}

// daemon_construct_pidfile
// file libslack/daemon.c line 598
static signed int daemon_construct_pidfile(const char *name, char **pidfile)
{
  signed long int path_len;
  const char *pid_dir;
  char *suffix = ".pid";
  unsigned long int daemon_construct_pidfile__1__size;
  path_len=limit_path();
  unsigned int return_value_getuid_1;
  return_value_getuid_1=getuid();
  pid_dir = return_value_getuid_1 != 0u ? "/tmp" : "/var/run";
  unsigned long int tmp_if_expr_5;
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if((signed int)*name == 47)
  {
    return_value_strlen_2=strlen(name);
    tmp_if_expr_5 = return_value_strlen_2;
  }

  else
  {
    return_value_strlen_3=strlen(name);
    return_value_strlen_4=strlen(suffix);
    tmp_if_expr_5 = sizeof(const char *) /*8ul*/  + (unsigned long int)1 + return_value_strlen_3 + return_value_strlen_4;
  }
  daemon_construct_pidfile__1__size = tmp_if_expr_5 + (unsigned long int)1;
  signed int return_value_set_errno_6;
  void *return_value_malloc_7;
  if(!((unsigned long int)path_len >= daemon_construct_pidfile__1__size))
  {
    return_value_set_errno_6=set_errno(36);
    return return_value_set_errno_6;
  }

  else
    if(*pidfile == ((char *)NULL))
    {
      return_value_malloc_7=malloc((unsigned long int)path_len * sizeof(char) /*1ul*/ );
      *pidfile = (char *)return_value_malloc_7;
      if(!(*pidfile == ((char *)NULL)))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      if((signed int)*name == 47)
        snprintf(*pidfile, (unsigned long int)path_len, "%s", name);

      else
        snprintf(*pidfile, (unsigned long int)path_len, "%s%c%s%s", pid_dir, 47, name, suffix);
      return 0;
    }
}

// daemon_getpid
// file libslack/daemon.c line 1069
signed int daemon_getpid(const char *name)
{
  char *pidfile = (char *)(void *)0;
  char buf[8192l];
  signed long int bytes;
  signed int pid_fd;
  signed int pid = 0;
  signed int return_value_set_errno_1;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile_2;
    return_value_daemon_construct_pidfile_2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile_2 == -1)
      return -1;

    else
    {
      pid_fd=open(pidfile, 00);
      free((void *)pidfile);
      if(pid_fd == -1)
        return -1;

      else
      {
        bytes=read(pid_fd, (void *)buf, (unsigned long int)8192);
        close(pid_fd);
        if(bytes == -1l)
          return -1;

        else
        {
          signed int return_value_sscanf_3;
          return_value_sscanf_3=sscanf(buf, "%d", &pid);
          if(!(return_value_sscanf_3 == 1))
            return -1;

          else
            return (signed int)pid;
        }
      }
    }
  }
}

// daemon_init
// file libslack/daemon.c line 876
signed int daemon_init(const char *name)
{
  signed int pid;
  signed long int nopen;
  signed int fd;
  signed int return_value_daemon_started_by_init_2;
  return_value_daemon_started_by_init_2=daemon_started_by_init();
  _Bool tmp_if_expr_4;
  signed int return_value_daemon_started_by_inetd_3;
  if(!(return_value_daemon_started_by_init_2 == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_daemon_started_by_inetd_3=daemon_started_by_inetd();
    tmp_if_expr_4 = return_value_daemon_started_by_inetd_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_4)
  {
    pid=fork();
    if(pid == -1)
      return -1;

    if(!(pid == 0))
      exit(0);

    setsid();
    struct sigaction daemon_init__1__1__1__act[1l];
    daemon_init__1__1__1__act[0l].__sigaction_handler.sa_handler = (void (*)(signed int))1;
    sigemptyset(&daemon_init__1__1__1__act[0l].sa_mask);
    daemon_init__1__1__1__act[0l].sa_flags = 0;
    signed int return_value_sigaction_1;
    return_value_sigaction_1=sigaction(1, daemon_init__1__1__1__act, (struct sigaction *)(void *)0);
    if(return_value_sigaction_1 == -1)
      return -1;

    pid=fork();
    if(pid == -1)
      return -1;

    if(!(pid == 0))
      exit(0);

  }

  signed int return_value_chdir_5;
  return_value_chdir_5=chdir("/");
  signed int return_value_daemon_pidfile_10;
  if(return_value_chdir_5 == -1)
    return -1;

  else
  {
    umask((unsigned int)0);
    nopen=limit_open();
    if(nopen == -1l)
      return -1;

    else
    {
      signed int return_value_daemon_started_by_inetd_9;
      return_value_daemon_started_by_inetd_9=daemon_started_by_inetd();
      if(!(return_value_daemon_started_by_inetd_9 == 0))
      {
        fd = 0;
        for( ; !((signed long int)fd >= nopen); fd = fd + 1)
        {
          if(fd == 0 || fd == 1 || fd == 2)
            goto __CPROVER_DUMP_L13;

          close(fd);

        __CPROVER_DUMP_L13:
          ;
        }
      }

      else
      {
        fd = 0;
        for( ; !((signed long int)fd >= nopen); fd = fd + 1)
          close(fd);
        fd=open("/dev/null", 02);
        if(fd == -1)
          return -1;

        if(!(fd == 0))
        {
          signed int return_value_dup2_6;
          return_value_dup2_6=dup2(fd, 0);
          if(return_value_dup2_6 == -1)
            return -1;

          close(fd);
        }

        signed int return_value_dup2_7;
        return_value_dup2_7=dup2(0, 1);
        if(return_value_dup2_7 == -1)
          return -1;

        signed int return_value_dup2_8;
        return_value_dup2_8=dup2(0, 2);
        if(return_value_dup2_8 == -1)
          return -1;

      }
      if(!(name == ((const char *)NULL)))
      {
        return_value_daemon_pidfile_10=daemon_pidfile(name);
        return return_value_daemon_pidfile_10;
      }

      else
        return 0;
    }
  }
}

// daemon_is_running
// file libslack/daemon.c line 1126
signed int daemon_is_running(const char *name)
{
  char *pidfile = (char *)(void *)0;
  signed int pid_fd;
  signed int return_value_set_errno_1;
  signed int *return_value___errno_location_4;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile_2;
    return_value_daemon_construct_pidfile_2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile_2 == -1)
      return -1;

    else
    {
      pid_fd=open(pidfile, 00);
      if(pid_fd == -1)
      {
        free((void *)pidfile);
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 2))
          return -1;

        return 0;
      }

      signed int return_value_fcntl_lock_6;
      return_value_fcntl_lock_6=fcntl_lock(pid_fd, 6, 0, 0, 0, 0);
      if(return_value_fcntl_lock_6 == -1)
      {
        free((void *)pidfile);
        close(pid_fd);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        if(!(*return_value___errno_location_5 == 13))
        {
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 11))
            return -1;

        }

        return 1;
      }

      free((void *)pidfile);
      close(pid_fd);
      return 0;
    }
  }
}

// daemon_lock_pidfile
// file libslack/daemon.c line 633
static signed int daemon_lock_pidfile(char *pidfile)
{
  unsigned int mode = (unsigned int)(0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
  struct stat statbuf_fd[1l];
  struct stat statbuf_fs[1l];
  signed int pid_fd;
  signed int return_value_fcntl_lock_3;
  signed int return_value_fstat_4;
  signed int return_value_stat_6;
  do
  {

  start:
    ;
    pid_fd=open(pidfile, 02 | 0100 | 0200, mode);
    if(pid_fd == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 17))
        return -1;

      pid_fd=open(pidfile, 02);
      if(pid_fd == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 2)
          goto start;

        return -1;
      }

    }

    return_value_fcntl_lock_3=fcntl_lock(pid_fd, 6, 1, 0, 0, 0);
    if(return_value_fcntl_lock_3 == -1)
    {
      close(pid_fd);
      return -1;
    }

    return_value_fstat_4=fstat(pid_fd, statbuf_fd);
    if(return_value_fstat_4 == -1)
    {
      close(pid_fd);
      return -1;
    }

    return_value_stat_6=stat(pidfile, statbuf_fs);
    if(return_value_stat_6 == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 2)
      {
        close(pid_fd);
        goto start;
      }

      close(pid_fd);
      return -1;
      break;
    }

    if(statbuf_fd[0l].st_ino == statbuf_fs[0l].st_ino)
      break;

    close(pid_fd);
  }
  while((_Bool)1);
  return pid_fd;
}

// daemon_parse_config
// file libslack/daemon.c line 525
void * daemon_parse_config(const char *path, void *obj, void (*parser)(void *, const char *, char *, unsigned long int))
{
  struct _IO_FILE *conf;
  char line[8192l];
  char buf[8192l];
  signed int lineno;
  signed int rc;
  conf=fopen(path, "r");
  char *return_value_fgets_1;
  unsigned long int return_value_strlen_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  if(conf == ((struct _IO_FILE *)NULL))
    return (void *)0;

  else
  {
    line[(signed long int)0] = (char)0;
    lineno = 1;
    do
    {
      return_value_fgets_1=fgets(buf, 8192, conf);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      char *start = buf;
      char *end;
      unsigned long int length;
      signed int cont_line;
      char *return_value___builtin_strchr_3;
      return_value___builtin_strchr_3=__builtin_strchr(start, 35);
      end = return_value___builtin_strchr_3;
      if(!(end == ((char *)NULL)))
        *end = (char)0;

      else
      {
        return_value_strlen_2=strlen(start);
        end = start + (signed long int)return_value_strlen_2;
      }
      for( ; !(start >= end); end = end - 1l)
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)end[-1l]]) == 0)
          break;

      }
      if(!(start == end) && !((signed int)*start == 0))
      {
        cont_line = (signed int)((signed int)end[(signed long int)-1] == 92);
        if(!(cont_line == 0))
          end = end - 1l;

        length=strlen(line);
        rc=snprintf(line + (signed long int)length, (unsigned long int)8192 - length, "%*.*s", (signed int)(end - start), (signed int)(end - start), start);
        if(rc == -1 || (unsigned long int)rc >= 8192ul + -length)
          return (void *)0;

        if(cont_line == 0)
        {
          parser(obj, path, line, (unsigned long int)lineno);
          line[(signed long int)0] = (char)0;
        }

      }

      lineno = lineno + 1;
    }
    while((_Bool)1);
    fclose(conf);
    return obj;
  }
}

// daemon_path_is_safe
// file libslack/daemon.c line 490
signed int daemon_path_is_safe(const char *path, char *explanation, unsigned long int explanation_size)
{
  char *abs_path;
  signed int rc;
  signed int return_value_set_errno_1;
  if(path == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    abs_path=daemon_absolute_path(path);
    if(abs_path == ((char *)NULL))
      return -1;

    else
    {
      rc=daemon_check_path(abs_path, explanation, explanation_size, 0);
      free((void *)abs_path);
      return rc;
    }
  }
}

// daemon_pidfile
// file libslack/daemon.c line 790
signed int daemon_pidfile(const char *name)
{
  signed int rc;
  signed int err;
  err=pthread_mutex_lock(&g.lock);
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    rc=daemon_pidfile_unlocked(name);
    signed int daemon_pidfile__1__2__err;
    daemon_pidfile__1__2__err=pthread_mutex_unlock(&g.lock);
    if(!(daemon_pidfile__1__2__err == 0))
    {
      return_value_set_errno_2=set_errno(daemon_pidfile__1__2__err);
      return return_value_set_errno_2;
    }

    else
      return rc;
  }
}

// daemon_pidfile_unlocked
// file libslack/daemon.c line 728
static signed int daemon_pidfile_unlocked(const char *name)
{
  char pid[32l];
  signed int pid_fd;
  signed int return_value_set_errno_1;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile_2;
    return_value_daemon_construct_pidfile_2=daemon_construct_pidfile(name, &g.pidfile);
    if(return_value_daemon_construct_pidfile_2 == -1)
      return -1;

    else
    {
      pid_fd=daemon_lock_pidfile(g.pidfile);
      if(pid_fd == -1)
      {
        mem_destroy((void **)&g.pidfile);
        return -1;
      }

      else
      {
        signed int return_value_getpid_3;
        return_value_getpid_3=getpid();
        snprintf(pid, (unsigned long int)32, "%d\n", (signed int)return_value_getpid_3);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(pid);
        signed long int return_value_write_5;
        return_value_write_5=write(pid_fd, (const void *)pid, return_value_strlen_4);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(pid);
        if(!((unsigned long int)return_value_write_5 == return_value_strlen_6))
        {
          daemon_close();
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// daemon_prevent_core
// file libslack/daemon.c line 169
signed int daemon_prevent_core(void)
{
  struct rlimit limit[1l] = { { .rlim_cur=(unsigned long int)0, .rlim_max=(unsigned long int)0 } };
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit(4, limit);
  if(return_value_getrlimit_1 == -1)
    return -1;

  else
  {
    limit[0l].rlim_cur = (unsigned long int)0;
    signed int return_value_setrlimit_2;
    return_value_setrlimit_2=setrlimit(4, limit);
    return return_value_setrlimit_2;
  }
}

// daemon_revoke_privileges
// file libslack/daemon.c line 200
signed int daemon_revoke_privileges(void)
{
  unsigned int uid;
  uid=getuid();
  unsigned int gid;
  gid=getgid();
  unsigned int euid;
  euid=geteuid();
  unsigned int egid;
  egid=getegid();
  signed int return_value_setgid_1;
  _Bool tmp_if_expr_4;
  unsigned int return_value_getegid_2;
  unsigned int return_value_getgid_3;
  signed int return_value_setuid_5;
  _Bool tmp_if_expr_8;
  unsigned int return_value_geteuid_6;
  unsigned int return_value_getuid_7;
  if(!(egid == gid))
  {
    return_value_setgid_1=setgid(gid);
    if(return_value_setgid_1 == -1)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_getegid_2=getegid();
      return_value_getgid_3=getgid();
      tmp_if_expr_4 = return_value_getegid_2 != return_value_getgid_3 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_4)
      goto __CPROVER_DUMP_L3;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(euid == uid))
    {
      return_value_setuid_5=setuid(uid);
      if(return_value_setuid_5 == -1)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_geteuid_6=geteuid();
        return_value_getuid_7=getuid();
        tmp_if_expr_8 = return_value_geteuid_6 != return_value_getuid_7 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_8)
        goto __CPROVER_DUMP_L6;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      endpwent();
      endgrent();
      return 0;
    }
  }
}

// daemon_started_by_inetd
// file libslack/daemon.c line 149
signed int daemon_started_by_inetd(void)
{
  unsigned long int optlen = sizeof(signed int) /*4ul*/ ;
  signed int optval;
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(0, 1, 3, (void *)&optval, (unsigned int *)(void *)&optlen);
  return (signed int)(return_value_getsockopt_1 == 0);
}

// daemon_started_by_init
// file libslack/daemon.c line 130
signed int daemon_started_by_init(void)
{
  signed int return_value_getppid_1;
  return_value_getppid_1=getppid();
  return (signed int)(return_value_getppid_1 == 1);
}

// daemon_stop
// file libslack/daemon.c line 1195
signed int daemon_stop(const char *name)
{
  char *pidfile = (char *)(void *)0;
  char pidbuf[32l];
  signed long int bytes;
  signed int pid_fd;
  signed int pid = -1;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_8;
  signed int *return_value___errno_location_7;
  signed int return_value_set_errno_3;
  if(name == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_daemon_construct_pidfile_2;
    return_value_daemon_construct_pidfile_2=daemon_construct_pidfile(name, &pidfile);
    if(return_value_daemon_construct_pidfile_2 == -1)
      return -1;

    else
    {
      pid_fd=daemon_lock_pidfile(pidfile);
      if(pid_fd == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        if(*return_value___errno_location_6 == 13)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value___errno_location_7=__errno_location();
          tmp_if_expr_8 = *return_value___errno_location_7 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          pid_fd=open(pidfile, 00);
          if(pid_fd == -1)
          {
            free((void *)pidfile);
            return -1;
          }

          free((void *)pidfile);
          bytes=read(pid_fd, (void *)pidbuf, (unsigned long int)32);
          if(!(bytes >= 1l))
          {
            close(pid_fd);
            return -1;
          }

          close(pid_fd);
          signed int return_value_sscanf_4;
          return_value_sscanf_4=sscanf(pidbuf, "%d", &pid);
          if(!(return_value_sscanf_4 == 1) || !(pid >= 1))
          {
            return_value_set_errno_3=set_errno(22);
            return return_value_set_errno_3;
          }

          signed int return_value_kill_5;
          return_value_kill_5=kill((signed int)pid, 15);
          return return_value_kill_5;
        }

        free((void *)pidfile);
        return -1;
      }

      close(pid_fd);
      unlink(pidfile);
      free((void *)pidfile);
      signed int return_value_set_errno_9;
      return_value_set_errno_9=set_errno(3);
      return return_value_set_errno_9;
    }
  }
}

// debug_invoke
// file libslack/locker.c line 243
static signed int debug_invoke(const char *name, signed int (*action)(void *), void *lock)
{
  signed int err;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  printf("[%lu] %s(%p) ...\n", (unsigned long int)return_value_pthread_self_1, name, lock);
  err=action(lock);
  unsigned long int return_value_pthread_self_2;
  char *return_value_strerror_3;
  unsigned long int return_value_pthread_self_4;
  if(!(err == 0))
  {
    return_value_pthread_self_2=pthread_self();
    return_value_strerror_3=strerror(err);
    printf("[%lu] %s(%p) done (%s)\n", (unsigned long int)return_value_pthread_self_2, name, lock, return_value_strerror_3);
  }

  else
  {
    return_value_pthread_self_4=pthread_self();
    printf("[%lu] %s(%p) done\n", (unsigned long int)return_value_pthread_self_4, name, lock);
  }
  return err;
}

// debug_level_match
// file libslack/err.c line 250
static signed int debug_level_match(unsigned long int level)
{
  unsigned long int debug_level;
  unsigned long int debug_section;
  unsigned long int section;
  debug_level=prog_debug_level();
  debug_section = debug_level & (unsigned long int)0xffffff00;
  debug_level = debug_level & (unsigned long int)0x000000ff;
  section = level & (unsigned long int)0xffffff00;
  level = level & (unsigned long int)0x000000ff;
  return (signed int)((!(debug_section != 0ul) || (debug_section & section) != 0ul) && debug_level >= level);
}

// debug_pthread_mutex_lock
// file libslack/locker.c line 261
static signed int debug_pthread_mutex_lock(union anonymous_11 *mutex)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_mutex_lock", (signed int (*)(void *))pthread_mutex_lock, (void *)mutex);
  return return_value_debug_invoke_1;
}

// debug_pthread_mutex_trylock
// file libslack/locker.c line 256
static signed int debug_pthread_mutex_trylock(union anonymous_11 *mutex)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_mutex_trylock", (signed int (*)(void *))pthread_mutex_trylock, (void *)mutex);
  return return_value_debug_invoke_1;
}

// debug_pthread_mutex_unlock
// file libslack/locker.c line 266
static signed int debug_pthread_mutex_unlock(union anonymous_11 *mutex)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_mutex_unlock", (signed int (*)(void *))pthread_mutex_unlock, (void *)mutex);
  return return_value_debug_invoke_1;
}

// debug_pthread_rwlock_rdlock
// file libslack/locker.c line 307
static signed int debug_pthread_rwlock_rdlock(union anonymous_12 *rwlock)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_rwlock_rdlock", (signed int (*)(void *))pthread_rwlock_rdlock, (void *)rwlock);
  return return_value_debug_invoke_1;
}

// debug_pthread_rwlock_tryrdlock
// file libslack/locker.c line 302
static signed int debug_pthread_rwlock_tryrdlock(union anonymous_12 *rwlock)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_rwlock_tryrdlock", (signed int (*)(void *))pthread_rwlock_tryrdlock, (void *)rwlock);
  return return_value_debug_invoke_1;
}

// debug_pthread_rwlock_trywrlock
// file libslack/locker.c line 312
static signed int debug_pthread_rwlock_trywrlock(union anonymous_12 *rwlock)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_rwlock_trywrlock", (signed int (*)(void *))pthread_rwlock_trywrlock, (void *)rwlock);
  return return_value_debug_invoke_1;
}

// debug_pthread_rwlock_unlock
// file libslack/locker.c line 322
static signed int debug_pthread_rwlock_unlock(union anonymous_12 *rwlock)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_rwlock_unlock", (signed int (*)(void *))pthread_rwlock_unlock, (void *)rwlock);
  return return_value_debug_invoke_1;
}

// debug_pthread_rwlock_wrlock
// file libslack/locker.c line 317
static signed int debug_pthread_rwlock_wrlock(union anonymous_12 *rwlock)
{
  signed int return_value_debug_invoke_1;
  return_value_debug_invoke_1=debug_invoke("pthread_rwlock_wrlock", (signed int (*)(void *))pthread_rwlock_wrlock, (void *)rwlock);
  return return_value_debug_invoke_1;
}

// debugf
// file libslack/err.c line 263
void debugf(unsigned long int level, const char *format, ...)
{
  signed int return_value_debug_level_match_1;
  return_value_debug_level_match_1=debug_level_match(level);
  if(!(return_value_debug_level_match_1 == 0))
  {
    void **args = (void **)&format;
    vdebugf(level, format, args);
    args = ((void **)NULL);
  }

}

// debugsysf
// file libslack/err.c line 514
void debugsysf(unsigned long int level, const char *format, ...)
{
  signed int return_value_debug_level_match_1;
  return_value_debug_level_match_1=debug_level_match(level);
  if(!(return_value_debug_level_match_1 == 0))
  {
    void **args = (void **)&format;
    vdebugsysf(level, format, args);
    args = ((void **)NULL);
  }

}

// decode
// file libslack/str.h line 226
struct String * decode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_decode_with_locker_1;
  return_value_decode_with_locker_1=decode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_decode_with_locker_1;
}

// decode_with_locker
// file libslack/str.c line 5738
struct String * decode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull_1;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    struct String *return_value_do_decode_with_locker_3;
    return_value_do_decode_with_locker_3=do_decode_with_locker(locker, str, return_value_strlen_2, uncoded, coded, quote_char, printable);
    return return_value_do_decode_with_locker_3;
  }
}

// direct_cmp
// file libslack/map.c line 2471
static signed int direct_cmp(signed int a, signed int b)
{
  return a - b;
}

// direct_copy
// file libslack/map.c line 2466
static signed int direct_copy(signed int key)
{
  return key;
}

// direct_hash
// file libslack/map.c line 2476
static unsigned long int direct_hash(unsigned long int size, signed int key)
{
  return (unsigned long int)key % size;
}

// dlink_alloc
// file libslack/link.c line 489
void * dlink_alloc(void **freelist)
{
  void *alloc;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(freelist == ((void **)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    if(*freelist == NULL)
    {
      return_value_set_errnull_2=set_errnull(28);
      return return_value_set_errnull_2;
    }

    else
    {
      alloc = *freelist;
      *freelist=dlink_remove(*freelist);
      return alloc;
    }
}

// dlink_free
// file libslack/link.c line 539
void * dlink_free(void **freelist, void *item)
{
  void *return_value_set_errnull_1;
  if(item == NULL || freelist == ((void **)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    *freelist=dlink_insert(*freelist, item);
    return *freelist;
  }
}

// dlink_freelist_attach
// file libslack/link.c line 428
void * dlink_freelist_attach(void *freelist1, void *freelist2)
{
  char *freelist;
  void *return_value_set_errnull_1;
  signed int return_value_dlink_has_next_2;
  void *return_value_dlink_next_3;
  if(freelist2 == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    freelist = (char *)freelist1;
    if(freelist == ((char *)NULL))
      return freelist2;

    else
    {
      do
      {
        return_value_dlink_has_next_2=dlink_has_next((void *)freelist);
        if(return_value_dlink_has_next_2 == 0)
          break;

        return_value_dlink_next_3=dlink_next((void *)freelist);
        freelist = (char *)return_value_dlink_next_3;
      }
      while((_Bool)1);
      ((struct dlink_t *)freelist)->next = freelist2;
      ((struct dlink_t *)freelist2)->prev = (void *)freelist;
      return freelist1;
    }
  }
}

// dlink_freelist_init
// file libslack/link.c line 363
void * dlink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size)
{
  char *link;
  char *prev;
  void *return_value_set_errnull_1;
  if(freelist == NULL || nelem == 0ul || size == 0ul)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    prev = (char *)(void *)0;
    link = (char *)freelist;
    do
    {
      nelem = nelem - 1ul;
      if(nelem == 0ul)
        break;

      ((struct dlink_t *)link)->next = (void *)(link + (signed long int)size);
      ((struct dlink_t *)link)->prev = (void *)prev;
      prev = link;
      link = link + (signed long int)size;
    }
    while((_Bool)1);
    ((struct dlink_t *)link)->next = (void *)0;
    ((struct dlink_t *)link)->prev = (void *)prev;
    return freelist;
  }
}

// dlink_has_next
// file libslack/link.c line 143
signed int dlink_has_next(void *link)
{
  signed int return_value_set_errno_1;
  if(link == NULL)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)(((struct dlink_t *)link)->next != (void *)0);
}

// dlink_has_prev
// file libslack/link.c line 181
signed int dlink_has_prev(void *link)
{
  signed int return_value_set_errno_1;
  if(link == NULL)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)(((struct dlink_t *)link)->prev != (void *)0);
}

// dlink_insert
// file libslack/link.h line 51
void * dlink_insert(void *link, void *item)
{
  struct dlink_t *insert;
  struct dlink_t *next;
  struct dlink_t *prev;
  void *return_value_set_errnull_1;
  void *tmp_if_expr_2;
  if(item == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    insert = (struct dlink_t *)item;
    next = (struct dlink_t *)link;
    if(!(next == ((struct dlink_t *)NULL)))
      tmp_if_expr_2 = next->prev;

    else
      tmp_if_expr_2 = (void *)0;
    prev = (struct dlink_t *)tmp_if_expr_2;
    insert->next = (void *)next;
    insert->prev = (void *)prev;
    if(!(next == ((struct dlink_t *)NULL)))
      next->prev = (void *)insert;

    if(!(prev == ((struct dlink_t *)NULL)))
      prev->next = (void *)insert;

    return (void *)insert;
  }
}

// dlink_next
// file libslack/link.h line 47
void * dlink_next(void *link)
{
  void *return_value_set_errnull_1;
  if(link == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    return ((struct dlink_t *)link)->next;
}

// dlink_prev
// file libslack/link.c line 200
void * dlink_prev(void *link)
{
  void *return_value_set_errnull_1;
  if(link == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    return ((struct dlink_t *)link)->prev;
}

// dlink_remove
// file libslack/link.h line 53
void * dlink_remove(void *link)
{
  struct dlink_t *remove;
  void *return_value_set_errnull_1;
  if(link == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    remove = (struct dlink_t *)link;
    if(!(remove->next == NULL))
      ((struct dlink_t *)remove->next)->prev = remove->prev;

    if(!(remove->prev == NULL))
      ((struct dlink_t *)remove->prev)->next = remove->next;

    return remove->next;
  }
}

// do_decode_with_locker
// file libslack/str.c line 5388
static struct String * do_decode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *decoded;
  const char *start;
  const char *slosh;
  char *target;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  _Bool tmp_if_expr_13;
  char *return_value___builtin_strchr_12;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    decoded=str_create_with_locker_sized(locker, length + (unsigned long int)1, "");
    if(decoded == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      start = str;
      for( ; !((unsigned long int)(start - str) >= length); start = slosh + (signed long int)1)
      {
        slosh = start;
        for( ; !((unsigned long int)(slosh - str) >= length); slosh = slosh + 1l)
          if(*slosh == quote_char)
            break;

        if((unsigned long int)(slosh - str) == length)
          break;

        if(!(printable == 0))
        {
          signed int digits = 0;
          const char *s = slosh + (signed long int)1;
          char c = (char)0;
          const unsigned short int **return_value___ctype_b_loc_8;
          return_value___ctype_b_loc_8=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*s]) == 0))
            tmp_if_expr_9 = (signed int)*s <= 55 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
          {
            s = s - 1l;
            do
            {
              digits = digits + 1;
              c = c << 3;
              s = s + 1l;
              c = c | (char)((signed int)*s - 48);
              if(!(digits >= 3))
              {
                return_value___ctype_b_loc_2=__ctype_b_loc();
                tmp_if_expr_3 = ((signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)s[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
                tmp_if_expr_4 = (signed int)s[(signed long int)1] <= 55 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_4 = (_Bool)0;
            }
            while(tmp_if_expr_4);
          }

          else
            if((signed int)*s == 120)
            {
              return_value___ctype_b_loc_7=__ctype_b_loc();
              if(!((4096 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)s[1l]]) == 0))
                do
                {
                  digits = digits + 1;
                  c = c << 4;
                  s = s + 1l;
                  switch((signed int)*s)
                  {
                    case 48:

                    case 49:

                    case 50:

                    case 51:

                    case 52:

                    case 53:

                    case 54:

                    case 55:

                    case 56:

                    case 57:
                    {
                      c = c | (char)((signed int)*s - 48);
                      goto __CPROVER_DUMP_L18;
                    }
                    case 97:

                    case 98:

                    case 99:

                    case 100:

                    case 101:

                    case 102:
                    {
                      c = c | (char)(((signed int)*s - 97) + 10);
                      goto __CPROVER_DUMP_L18;
                    }
                    case 65:

                    case 66:

                    case 67:

                    case 68:

                    case 69:

                    case 70:
                      c = c | (char)(((signed int)*s - 65) + 10);
                    default:
                    {

                    __CPROVER_DUMP_L18:
                      ;
                      if(!(digits >= 2))
                      {
                        return_value___ctype_b_loc_5=__ctype_b_loc();
                        tmp_if_expr_6 = ((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)s[(signed long int)1]] & (signed int)(unsigned short int)4096) != 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_6 = (_Bool)0;
                    }
                  }
                }
                while(tmp_if_expr_6);

            }

          if(!(digits == 0))
          {
            struct String *return_value_str_append_10;
            return_value_str_append_10=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, c);
            if(return_value_str_append_10 == ((struct String *)NULL))
            {
              str_release(decoded);
              return (struct String *)(void *)0;
            }

            slosh = s;
            goto __CPROVER_DUMP_L30;
          }

        }

        if(slosh[1l] == 0)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          return_value___builtin_strchr_12=__builtin_strchr(coded, (signed int)slosh[(signed long int)1]);
          target = return_value___builtin_strchr_12;
          tmp_if_expr_13 = !(target != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_13)
        {
          struct String *return_value_str_append_11;
          return_value_str_append_11=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, quote_char);
          if(return_value_str_append_11 == ((struct String *)NULL))
          {
            str_release(decoded);
            return (struct String *)(void *)0;
          }

          goto __CPROVER_DUMP_L30;
        }

        struct String *return_value_str_append_14;
        return_value_str_append_14=str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start, uncoded[target - coded]);
        if(return_value_str_append_14 == ((struct String *)NULL))
        {
          str_release(decoded);
          return (struct String *)(void *)0;
        }

        slosh = slosh + 1l;

      __CPROVER_DUMP_L30:
        ;
      }
      struct String *return_value_str_append_15;
      return_value_str_append_15=str_append(decoded, "%s", start);
      if(return_value_str_append_15 == ((struct String *)NULL))
      {
        str_release(decoded);
        return (struct String *)(void *)0;
      }

      else
        return decoded;
    }
  }
}

// do_encode_with_locker
// file libslack/str.c line 5336
static struct String * do_encode_with_locker(struct Locker *locker, const char *str, unsigned long int length, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *encoded;
  const char *target;
  const char *s;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_8;
  char *return_value___builtin_strchr_7;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    encoded=str_create_with_locker_sized(locker, length * (unsigned long int)4 + (unsigned long int)1, "");
    if(encoded == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      s = str;
      for( ; !((unsigned long int)(s - str) >= length); s = s + 1l)
      {
        if(!(*s == 0))
        {
          return_value___builtin_strchr_7=__builtin_strchr(uncoded, (signed int)(unsigned char)*s);
          target = return_value___builtin_strchr_7;
          tmp_if_expr_8 = target != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
        {
          struct String *return_value_str_append_2;
          return_value_str_append_2=str_append(encoded, "%c%c", (unsigned char)quote_char, coded[target - uncoded]);
          if(return_value_str_append_2 == ((struct String *)NULL))
          {
            str_release(encoded);
            return (struct String *)(void *)0;
          }

        }

        else
        {
          if(!(printable == 0))
          {
            return_value___ctype_b_loc_5=__ctype_b_loc();
            tmp_if_expr_6 = !(((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)16384) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
          {
            struct String *return_value_str_append_3;
            static const char do_encode_with_locker__1__hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
            return_value_str_append_3=str_append(encoded, "%cx%c%c", (unsigned char)quote_char, do_encode_with_locker__1__hex[(signed long int)((signed int)(unsigned char)*s >> 4)], do_encode_with_locker__1__hex[(signed long int)((signed int)(unsigned char)*s & 0x0f)]);
            if(return_value_str_append_3 == ((struct String *)NULL))
            {
              str_release(encoded);
              return (struct String *)(void *)0;
            }

          }

          else
          {
            struct String *return_value_str_append_4;
            return_value_str_append_4=str_append(encoded, "%c", (unsigned char)*s);
            if(return_value_str_append_4 == ((struct String *)NULL))
            {
              str_release(encoded);
              return (struct String *)(void *)0;
            }

          }
        }
      }
      return encoded;
    }
  }
}

// do_exec
// file libslack/coproc.c line 159
static void do_exec(signed int has_meta, const char *cmd, char * const *argv, char * const *envv)
{
  char *return_value___builtin_strchr_9;
  unsigned int return_value_geteuid_2;
  unsigned long int return_value_strlen_3;
  if(!(has_meta == 0))
  {
    const char *do_exec__1__1__shargv[4l];
    do_exec__1__1__shargv[(signed long int)0] = "sh";
    do_exec__1__1__shargv[(signed long int)1] = "-c";
    do_exec__1__1__shargv[(signed long int)2] = cmd;
    do_exec__1__1__shargv[(signed long int)3] = (const char *)(void *)0;
    execve("/bin/sh", (char * const *)do_exec__1__1__shargv, envv != ((char * const *)NULL) ? envv : environ);
  }

  else
  {
    return_value___builtin_strchr_9=__builtin_strchr(cmd, 47);
    if(!(return_value___builtin_strchr_9 == ((char *)NULL)))
    {
      execve(cmd, argv, envv != ((char * const *)NULL) ? envv : environ);
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 8)
      {
        char * const *do_exec__1__2__1__shargv;
        do_exec__1__2__1__shargv=new_shargv(cmd, argv);
        execve("/bin/sh", do_exec__1__2__1__shargv, envv != ((char * const *)NULL) ? envv : environ);
        free((void *)do_exec__1__2__1__shargv);
      }

    }

    else
    {
      char *path;
      char *s;
      char *f;
      char cmdbuf[512l];
      path=getenv("PATH");
      if(path == ((char *)NULL))
      {
        return_value_geteuid_2=geteuid();
        path = return_value_geteuid_2 != 0u ? ":/bin:/usr/bin" : "/bin:/usr/bin";
      }

      s = path;
      for( ; !(s == ((char *)NULL)); s = *f != 0 ? f + (signed long int)1 : (char *)(void *)0)
      {
        char *return_value___builtin_strchr_4;
        return_value___builtin_strchr_4=__builtin_strchr(s, 58);
        f = return_value___builtin_strchr_4;
        if(f == ((char *)NULL))
        {
          return_value_strlen_3=strlen(s);
          f = s + (signed long int)return_value_strlen_3;
        }

        signed int return_value_snprintf_5;
        return_value_snprintf_5=snprintf(cmdbuf, (unsigned long int)512, "%.*s%s%s", (signed int)(f - s), s, f - s != 0l ? "/" : "", cmd);
        if(!(return_value_snprintf_5 >= 512))
        {
          signed int return_value_execve_8;
          return_value_execve_8=execve(cmdbuf, argv, envv != ((char * const *)NULL) ? envv : environ);
          if(return_value_execve_8 == -1)
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            if(*return_value___errno_location_6 == 13)
              goto __CPROVER_DUMP_L11;

            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            if(*return_value___errno_location_7 == 8)
            {
              char * const *shargv;
              shargv=new_shargv(cmdbuf, argv);
              execve("/bin/sh", shargv, envv != ((char * const *)NULL) ? envv : environ);
              free((void *)shargv);
              break;
            }

          }

        }


      __CPROVER_DUMP_L11:
        ;
      }
    }
  }
}

// do_split_with_locker
// file libslack/str.c line 3966
static struct List * do_split_with_locker(struct Locker *locker, const char *str, signed long int length, const char *delim)
{
  struct List *ret;
  const char *s;
  const char *r;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_8;
  _Bool tmp_if_expr_4;
  char *return_value___builtin_strchr_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  char *return_value___builtin_strchr_5;
  signed int tmp_if_expr_14;
  _Bool tmp_if_expr_10;
  char *return_value___builtin_strchr_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  char *return_value___builtin_strchr_11;
  signed int tmp_if_expr_16;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    ret=list_create_with_locker(locker, (void (*)(void *))str_release);
    if(ret == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      s = str;
      do
      {
        if(length == -1l)
          tmp_if_expr_2 = (signed int)*s;

        else
          tmp_if_expr_2 = (signed int)(s - str < length);
        if(tmp_if_expr_2 == 0)
          break;

        do
        {
          if(length == -1l)
          {
            if(!(*s == 0))
            {
              return_value___builtin_strchr_3=__builtin_strchr(delim, (signed int)*s);
              tmp_if_expr_4 = return_value___builtin_strchr_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_8 = (signed int)tmp_if_expr_4;
          }

          else
          {
            if(!(s - str >= length))
            {
              if(!(*s == 0))
              {
                return_value___builtin_strchr_5=__builtin_strchr(delim, (signed int)*s);
                tmp_if_expr_6 = return_value___builtin_strchr_5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_6 = (_Bool)0;
              tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_7 = (_Bool)0;
            tmp_if_expr_8 = (signed int)tmp_if_expr_7;
          }
          if(tmp_if_expr_8 == 0)
            break;

          s = s + 1l;
        }
        while((_Bool)1);
        if(*delim == 0)
          r = s + (signed long int)1;

        else
        {
          r = s;
          do
          {
            if(length == -1l)
            {
              if(!(*r == 0))
              {
                return_value___builtin_strchr_9=__builtin_strchr(delim, (signed int)*r);
                tmp_if_expr_10 = !(return_value___builtin_strchr_9 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_10 = (_Bool)0;
              tmp_if_expr_14 = (signed int)tmp_if_expr_10;
            }

            else
            {
              if(!(r - str >= length))
              {
                if(*r == 0)
                  tmp_if_expr_12 = (_Bool)1;

                else
                {
                  return_value___builtin_strchr_11=__builtin_strchr(delim, (signed int)*r);
                  tmp_if_expr_12 = !(return_value___builtin_strchr_11 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_13 = (_Bool)0;
              tmp_if_expr_14 = (signed int)tmp_if_expr_13;
            }
            if(tmp_if_expr_14 == 0)
              break;

            r = r + 1l;
          }
          while((_Bool)1);
        }
        if(!(s >= r))
        {
          struct String *token;
          token=substr(s, (signed long int)0, r - s);
          if(token == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append_15;
          return_value_list_append_15=list_append(ret, (void *)token);
          if(return_value_list_append_15 == ((struct List *)NULL))
          {
            str_release(token);
            list_release(ret);
            return (struct List *)(void *)0;
          }

          s = r;
          if(*delim == 0)
            s = s - 1l;

        }

        if(length == -1l)
          tmp_if_expr_16 = (signed int)!(*s != 0);

        else
          tmp_if_expr_16 = (signed int)(s - str == length);
        if(!(tmp_if_expr_16 == 0))
          break;

        s = s + 1l;
      }
      while((_Bool)1);
      return ret;
    }
  }
}

// do_tr_compile_table
// file libslack/str.c line 2680
static struct StringTR * do_tr_compile_table(struct StringTR *table, const char *from, signed long int fromlen, const char *to, signed long int tolen, signed int option)
{
  const char *f;
  const char *t;
  char *xf;
  char *xt;
  char xfrom[256l];
  char xto[256l];
  signed short int tbl[256l];
  signed int i;
  signed int j;
  signed int k;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  void *return_value_set_errnull_4;
  char *tmp_post_5;
  void *return_value_set_errnull_6;
  char *tmp_post_7;
  _Bool tmp_if_expr_9;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  void *return_value_set_errnull_12;
  char *tmp_post_13;
  void *return_value_set_errnull_14;
  signed int tmp_if_expr_16;
  signed int return_value;
  void *return_value_set_errnull_15;
  signed int tmp_if_expr_18;
  signed int return_value_1;
  void *return_value_set_errnull_17;
  if(from == ((const char *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct StringTR *)return_value_set_errnull_1;
  }

  else
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
      tbl[(signed long int)i] = (signed short int)-1;
    xf = xfrom;
    f = from;
    do
    {
      if(fromlen == -1l)
        tmp_if_expr_2 = (signed int)*f;

      else
        tmp_if_expr_2 = (signed int)(f - from < fromlen);
      if(!(tmp_if_expr_2 == 0))
        tmp_if_expr_3 = xf - xfrom < (signed long int)256 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      j = (signed int)*f;
      i = j;
      if((signed int)f[1l] == 45)
      {
        if(!(f[2l] == 0))
        {
          j = (signed int)f[(signed long int)2];
          f = f + (signed long int)2;
        }

      }

      if(!((signed int)(unsigned char)j >= (signed int)(unsigned char)i))
      {
        return_value_set_errnull_4=set_errnull(22);
        return (struct StringTR *)return_value_set_errnull_4;
      }

      k = (signed int)(unsigned char)i;
      for( ; (signed int)(unsigned char)j >= k; k = k + 1)
      {
        tmp_post_5 = xf;
        xf = xf + 1l;
        tbl[(signed long int)k] = (signed short int)k;
        *tmp_post_5 = (char)tbl[(signed long int)k];
      }
      f = f + 1l;
    }
    while((_Bool)1);
    if(xf - xfrom == 256l)
    {
      return_value_set_errnull_6=set_errnull(22);
      return (struct StringTR *)return_value_set_errnull_6;
    }

    else
    {
      if(!((1 & option) == 0))
      {
        char tmp[256l];
        xf = tmp;
        k = 0;
        for( ; !(k >= 256); k = k + 1)
          if((signed int)tbl[(signed long int)k] == -1)
          {
            tmp_post_7 = xf;
            xf = xf + 1l;
            *tmp_post_7 = (char)k;
          }

        memcpy((void *)xfrom, (const void *)tmp, (unsigned long int)(xf - tmp));
        xf = xfrom + (xf - tmp);
      }

      if(to == ((const char *)NULL))
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        if(tolen == -1l)
          tmp_if_expr_8 = (signed int)((signed int)*to == 0);

        else
          tmp_if_expr_8 = (signed int)(tolen == (signed long int)0);
        tmp_if_expr_9 = tmp_if_expr_8 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        to = (option & 2) != 0 ? "" : from;

      xt = xto;
      t = to;
      do
      {
        if(tolen == -1l)
          tmp_if_expr_10 = (signed int)*t;

        else
          tmp_if_expr_10 = (signed int)(t - to < tolen);
        if(!(tmp_if_expr_10 == 0))
          tmp_if_expr_11 = xt - xto < (signed long int)256 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(!tmp_if_expr_11)
          break;

        j = (signed int)*t;
        i = j;
        if((signed int)t[1l] == 45)
        {
          if(!(t[2l] == 0))
          {
            j = (signed int)t[(signed long int)2];
            t = t + (signed long int)2;
          }

        }

        if(!((signed int)(unsigned char)j >= (signed int)(unsigned char)i))
        {
          return_value_set_errnull_12=set_errnull(22);
          return (struct StringTR *)return_value_set_errnull_12;
        }

        k = (signed int)(unsigned char)i;
        for( ; (signed int)(unsigned char)j >= k; k = k + 1)
        {
          tmp_post_13 = xt;
          xt = xt + 1l;
          *tmp_post_13 = (char)k;
        }
        t = t + 1l;
      }
      while((_Bool)1);
      if(xt - xto == 256l)
      {
        return_value_set_errnull_14=set_errnull(22);
        return (struct StringTR *)return_value_set_errnull_14;
      }

      else
      {
        if((2 & option) == 0)
        {
          unsigned long int flen = (unsigned long int)(xf - xfrom);
          unsigned long int tlen = (unsigned long int)(xt - xto);
          if(!(tlen >= flen))
          {
            memset((void *)xt, (signed int)xt[(signed long int)-1], flen - tlen);
            xt = xt + (signed long int)(flen - tlen);
          }

        }

        if(!(table->locker == ((struct Locker *)NULL)))
        {
          return_value=table->locker->wrlock(table->locker->lock);
          tmp_if_expr_16 = return_value;
        }

        else
          tmp_if_expr_16 = 0;
        err = tmp_if_expr_16;
        if(!(err == 0))
        {
          return_value_set_errnull_15=set_errnull(err);
          return (struct StringTR *)return_value_set_errnull_15;
        }

        else
        {
          table->squash = option & 4;
          i = 0;
          for( ; !(i >= 256); i = i + 1)
            table->table[(signed long int)i] = (signed short int)-1;
          j = 0;
          i = j;
          for( ; !(xfrom + (signed long int)i >= xf); j = j + 1)
          {
            unsigned char fc = (unsigned char)xfrom[(signed long int)i];
            unsigned char tc = (unsigned char)xto[(signed long int)j];
            if((signed int)table->table[(signed long int)fc] == -1)
              table->table[(signed long int)fc] = (signed short int)(xto + (signed long int)j < xt ? (signed int)tc : -2);

            i = i + 1;
          }
          if(!(table->locker == ((struct Locker *)NULL)))
          {
            return_value_1=table->locker->unlock(table->locker->lock);
            tmp_if_expr_18 = return_value_1;
          }

          else
            tmp_if_expr_18 = 0;
          err = tmp_if_expr_18;
          if(!(err == 0))
          {
            return_value_set_errnull_17=set_errnull(err);
            return (struct StringTR *)return_value_set_errnull_17;
          }

          else
            return table;
        }
      }
    }
  }
}

// do_tr_compiled
// file libslack/str.c line 2866
static signed int do_tr_compiled(unsigned char *str, unsigned long int *length, struct StringTR *table)
{
  signed int ret = 0;
  signed int deleted = 0;
  unsigned char *r;
  unsigned char *s;
  signed short int t;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  unsigned char *tmp_post_5;
  _Bool tmp_if_expr_8;
  unsigned char *tmp_post_7;
  signed int tmp_if_expr_10;
  signed int return_value_1;
  signed int return_value_set_errno_9;
  if(table == ((struct StringTR *)NULL) || str == ((unsigned char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      s = str;
      r = s;
      do
      {
        if(!(length == ((unsigned long int *)NULL)))
          tmp_if_expr_4 = (signed int)((unsigned long int)(s - str) < *length - (unsigned long int)1);

        else
          tmp_if_expr_4 = (signed int)*s;
        if(tmp_if_expr_4 == 0)
          break;

        t = table->table[(signed long int)(signed int)*s];
        switch((signed int)t)
        {
          case -2:
          {
            deleted = deleted + 1;
            ret = ret + 1;
            break;
          }
          case -1:
          {
            if(table->squash == 0 || r == str)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = r[(signed long int)-1] != *s ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_6)
            {
              tmp_post_5 = r;
              r = r + 1l;
              *tmp_post_5 = *s;
            }

            else
              deleted = deleted + 1;
            break;
          }
          default:
          {
            if(table->squash == 0 || r == str)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = (signed int)r[(signed long int)-1] != (signed int)t ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
            {
              tmp_post_7 = r;
              r = r + 1l;
              *tmp_post_7 = (unsigned char)t;
            }

            else
              deleted = deleted + 1;
            ret = ret + 1;
          }
        }
        s = s + 1l;
      }
      while((_Bool)1);
      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_1=table->locker->unlock(table->locker->lock);
        tmp_if_expr_10 = return_value_1;
      }

      else
        tmp_if_expr_10 = 0;
      err = tmp_if_expr_10;
      if(!(err == 0))
      {
        return_value_set_errno_9=set_errno(err);
        return return_value_set_errno_9;
      }

      else
      {
        *r = (unsigned char)0;
        if(!(length == ((unsigned long int *)NULL)) && !(deleted == 0))
          *length = *length - (unsigned long int)deleted;

        return ret;
      }
    }
  }
}

// dump
// file libslack/err.c line 411
void dump(const char *format, ...)
{
  void **args = (void **)&format;
  vdump(format, args);
  args = ((void **)NULL);
}

// dumpsys
// file libslack/err.c line 638
void dumpsys(const char *format, ...)
{
  void **args = (void **)&format;
  vdumpsys(format, args);
  args = ((void **)NULL);
}

// encode
// file libslack/str.h line 224
struct String * encode(const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_encode_with_locker_1;
  return_value_encode_with_locker_1=encode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_encode_with_locker_1;
}

// encode_with_locker
// file libslack/str.c line 5704
struct String * encode_with_locker(struct Locker *locker, const char *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull_1;
  if(coded == ((const char *)NULL) || str == ((const char *)NULL) || uncoded == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    struct String *return_value_do_encode_with_locker_3;
    return_value_do_encode_with_locker_3=do_encode_with_locker(locker, str, return_value_strlen_2, uncoded, coded, quote_char, printable);
    return return_value_do_encode_with_locker_3;
  }
}

// error
// file libslack/err.c line 316
signed int error(const char *format, ...)
{
  void **args = (void **)&format;
  verror(format, args);
  args = ((void **)NULL);
  return -1;
}

// errorsys
// file libslack/err.c line 559
signed int errorsys(const char *format, ...)
{
  void **args = (void **)&format;
  verrorsys(format, args);
  args = ((void **)NULL);
  return -1;
}

// expand
// file libslack/list.c line 275
static signed int expand(struct List *list, signed long int index, unsigned long int range)
{
  signed int return_value_grow_1;
  return_value_grow_1=grow(list, range);
  if(return_value_grow_1 == -1)
    return -1;

  else
  {
    memmove((void *)(list->list + index + (signed long int)range), (const void *)(list->list + index), (list->length - (unsigned long int)index) * sizeof(void *) /*8ul*/ );
    list->length = list->length + range;
    return 0;
  }
}

// expand_link1
// file libslack/str.c line 454
static signed int expand_link1(struct String *str, signed long int index_link1, unsigned long int range_link1)
{
  signed int return_value_grow_1_link1;
  return_value_grow_1_link1=grow_link1(str, range_link1);
  if(return_value_grow_1_link1 == -1)
    return -1;

  else
  {
    memmove((void *)(str->str + index_link1 + (signed long int)range_link1), (const void *)(str->str + index_link1), (str->length - (unsigned long int)index_link1) * sizeof(char) /*1ul*/ );
    str->length = str->length + range_link1;
    return 0;
  }
}

// expire
// file libslack/agent.c line 1957
static signed int expire(struct Agent *agent)
{
  struct action_t *event;
  do
  {
    event = agent->timewheel->jiffies[(signed long int)agent->timewheel->jiffy];
    if(event == ((struct action_t *)NULL))
      break;

    signed int (*action)(struct Agent *, void *) = event->action;
    void *arg = event->arg;
    signed int return_value_agent_cancel_unlocked_1;
    return_value_agent_cancel_unlocked_1=agent_cancel_unlocked(agent, (void *)event);
    if(return_value_agent_cancel_unlocked_1 == -1)
      return -1;

    signed int return_value_act_2;
    return_value_act_2=act(action, agent, arg);
    if(return_value_act_2 == -1)
      return -1;

  }
  while((_Bool)1);
  return 0;
}

// fatal
// file libslack/err.c line 367
void fatal(const char *format, ...)
{
  void **args = (void **)&format;
  vfatal(format, args);
  args = ((void **)NULL);
}

// fatalsys
// file libslack/err.c line 599
void fatalsys(const char *format, ...)
{
  void **args = (void **)&format;
  vfatalsys(format, args);
  args = ((void **)NULL);
}

// fcntl_clear_flag
// file libslack/fio.c line 399
signed int fcntl_clear_flag(signed int fd, signed int flag)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    return -1;

  else
  {
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(fd, 4, flags & ~flag);
    return return_value_fcntl_1;
  }
}

// fcntl_lock
// file libslack/fio.h line 41
signed int fcntl_lock(signed int fd, signed int cmd, signed int type, signed int whence, signed int start, signed int len)
{
  struct flock lock[1l];
  lock[0l].l_type = (signed short int)type;
  lock[0l].l_whence = (signed short int)whence;
  lock[0l].l_start = (signed long int)start;
  lock[0l].l_len = (signed long int)len;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, cmd, (const void *)lock);
  return return_value_fcntl_1;
}

// fcntl_set_flag
// file libslack/fio.c line 376
signed int fcntl_set_flag(signed int fd, signed int flag)
{
  signed int flags;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    return -1;

  else
  {
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(fd, 4, flags | flag);
    return return_value_fcntl_1;
  }
}

// fgetline
// file libslack/fio.c line 122
char * fgetline(char *line, unsigned long int size, struct _IO_FILE *stream)
{
  char *ret;
  flockfile(stream);
  ret=fgetline_unlocked(line, size, stream);
  funlockfile(stream);
  return ret;
}

// fgetline_unlocked
// file libslack/fio.c line 143
char * fgetline_unlocked(char *line, unsigned long int size, struct _IO_FILE *stream)
{
  char *s = line;
  char *end = (line + (signed long int)size) - (signed long int)1;
  signed int c = 0;
  signed int c2;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  _Bool tmp_if_expr_5;
  signed int return_value_ferror_4;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    while(!(s >= end))
    {
      c=getc_unlocked(stream);
      if(c == -1)
        break;

      if(c == 10)
      {
        tmp_post_1 = s;
        s = s + 1l;
        *tmp_post_1 = (char)c;
        break;
      }

      else
        if(c == 13)
        {
          tmp_post_2 = s;
          s = s + 1l;
          *tmp_post_2 = (char)10;
          c2=getc_unlocked(stream);
          if(c2 == 10)
            break;

          ungetc(c2, stream);
          break;
        }

        else
        {
          tmp_post_3 = s;
          s = s + 1l;
          *tmp_post_3 = (char)c;
        }
    }
    *s = (char)0;
    if(c == -1)
    {
      if(s == line)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_ferror_4=ferror(stream);
        tmp_if_expr_5 = return_value_ferror_4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_5)
        goto __CPROVER_DUMP_L8;

      return (char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      return line;
    }
  }
}

// fifo_exists
// file libslack/fio.c line 503
signed int fifo_exists(const char *path, signed int prepare)
{
  struct stat status[1l];
  signed int return_value_stat_2;
  return_value_stat_2=stat_link1(path, status);
  signed int *return_value___errno_location_1;
  if(return_value_stat_2 == -1)
  {
    return_value___errno_location_1=__errno_location();
    return *return_value___errno_location_1 == 2 ? 0 : -1;
  }

  else
    if(!((61440u & status[0l].st_mode) == 4096u))
    {
      if(!(prepare == 0))
        unlink(path);

      return 0;
    }

    else
      return 1;
}

// fifo_has_reader
// file libslack/fio.c line 535
signed int fifo_has_reader(const char *path, signed int prepare)
{
  signed int fd;
  signed int return_value_fifo_exists_1;
  return_value_fifo_exists_1=fifo_exists(path, prepare);
  if(!(return_value_fifo_exists_1 == 0))
  {
    if(return_value_fifo_exists_1 == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    return 0;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  fd=open(path, 01 | 04000);
  signed int *return_value___errno_location_2;
  if(fd == -1)
  {
    return_value___errno_location_2=__errno_location();
    return *return_value___errno_location_2 == 6 ? 0 : -1;
  }

  else
  {
    signed int return_value_close_3;
    return_value_close_3=close(fd);
    if(return_value_close_3 == -1)
      return -1;

    else
      return 1;
  }
}

// fifo_open
// file libslack/fio.c line 598
signed int fifo_open(const char *path, unsigned int mode, signed int lock, signed int *writefd)
{
  struct stat status[1l];
  signed int rfd;
  signed int wfd;
  signed int mine = 0;
  signed int return_value_fifo_has_reader_1;
  return_value_fifo_has_reader_1=fifo_has_reader(path, 1);
  if(!(return_value_fifo_has_reader_1 == 1))
  {
    if(return_value_fifo_has_reader_1 == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    signed int return_value_set_errno_2;
    return_value_set_errno_2=set_errno(98);
    return return_value_set_errno_2;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  signed int return_value_mkfifo_4;
  return_value_mkfifo_4=mkfifo(path, mode);
  signed int *return_value___errno_location_3;
  if(!(return_value_mkfifo_4 == -1))
    mine = 1;

  else
  {
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 17))
      return -1;

  }
  rfd=open(path, 00 | 04000);
  _Bool tmp_if_expr_6;
  signed int return_value_fcntl_lock_13;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_11;
  signed int *return_value___errno_location_10;
  signed int tmp_if_expr_9;
  signed int return_value_set_errno_8;
  _Bool tmp_if_expr_15;
  if(rfd == -1)
  {
    if(!(mine == 0))
      unlink(path);

    return -1;
  }

  else
  {
    signed int return_value_fstat_5;
    return_value_fstat_5=fstat_link1(rfd, status);
    if(return_value_fstat_5 == -1)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0010000) == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      if(!(mine == 0))
        unlink(path);

      close(rfd);
      return -1;
    }

    else
    {
      wfd=open(path, 01);
      if(wfd == -1)
      {
        if(!(mine == 0))
          unlink(path);

        close(rfd);
        return -1;
      }

      else
      {
        if(!(lock == 0))
        {
          return_value_fcntl_lock_13=fcntl_lock(wfd, 6, 1, 0, 0, 0);
          if(return_value_fcntl_lock_13 == -1)
          {
            return_value___errno_location_12=__errno_location();
            if(!(*return_value___errno_location_12 == 95))
            {
              return_value___errno_location_11=__errno_location();
              if(!(*return_value___errno_location_11 == 95))
              {
                return_value___errno_location_10=__errno_location();
                if(!(*return_value___errno_location_10 == 9))
                {
                  if(!(mine == 0))
                    unlink(path);

                  close(rfd);
                  close(wfd);
                  signed int *return_value___errno_location_7;
                  return_value___errno_location_7=__errno_location();
                  if(*return_value___errno_location_7 == 13)
                  {
                    return_value_set_errno_8=set_errno(98);
                    tmp_if_expr_9 = return_value_set_errno_8;
                  }

                  else
                    tmp_if_expr_9 = -1;
                  return tmp_if_expr_9;
                }

              }

            }

          }

        }

        signed int return_value_fstat_14;
        return_value_fstat_14=fstat_link1(wfd, status);
        if(return_value_fstat_14 == -1)
          tmp_if_expr_15 = (_Bool)1;

        else
          tmp_if_expr_15 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0010000) == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_15)
        {
          if(!(mine == 0))
            unlink(path);

          close(rfd);
          close(wfd);
          return -1;
        }

        else
        {
          signed int return_value_nonblock_off_16;
          return_value_nonblock_off_16=nonblock_off(rfd);
          if(return_value_nonblock_off_16 == -1)
          {
            if(!(mine == 0))
              unlink(path);

            close(rfd);
            close(wfd);
            return -1;
          }

          else
          {
            if(!(writefd == ((signed int *)NULL)))
              *writefd = wfd;

            return rfd;
          }
        }
      }
    }
  }
}

// fmt
// file libslack/str.c line 3757
struct List * fmt(const char *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_fmt_with_locker_1;
  return_value_fmt_with_locker_1=fmt_with_locker((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_fmt_with_locker_1;
}

// fmt_with_locker
// file libslack/str.c line 3773
struct List * fmt_with_locker(struct Locker *locker, const char *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *para;
  struct String *line = (struct String *)(void *)0;
  const char *s;
  const char *r;
  signed long int len;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_3;
  struct List *return_value_list_append_5;
  struct String *return_value_str_append_6;
  signed long int return_value_str_length_8;
  struct List *return_value_list_append_7;
  signed int return_value_list_has_next_9;
  _Bool tmp_if_expr_13;
  signed int return_value_list_has_next_15;
  struct String *return_value_str_prepend_17;
  void *return_value_set_errnull_18;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    switch((signed int)alignment)
    {
      case ALIGN_LEFT:

      case ALIGN_RIGHT:

      case ALIGN_FULL:
      {
        para=list_create_with_locker(locker, (void (*)(void *))str_release);
        if(para == ((struct List *)NULL))
          return (struct List *)(void *)0;

        s = str;
        for( ; !(*s == 0); s = s + 1l)
        {
          do
          {
            return_value___ctype_b_loc_2=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
              break;

            s = s + 1l;
          }
          while((_Bool)1);
          r = s;
          do
          {
            if(!(*r == 0))
            {
              return_value___ctype_b_loc_3=__ctype_b_loc();
              tmp_if_expr_4 = !(((signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*r] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            if(!tmp_if_expr_4)
              break;

            r = r + 1l;
          }
          while((_Bool)1);
          if(!(s >= r))
          {
            len=str_length(line);
            if(len == -1l)
              len = len + 1l;

            if(!(line_width >= (unsigned long int)(r - s) + (unsigned long int)len + (unsigned long int)(signed long int)!(len == 0l)))
            {
              if(!(len == 0l))
              {
                return_value_list_append_5=list_append(para, (void *)line);
                if(return_value_list_append_5 == ((struct List *)NULL))
                {
                  str_release(line);
                  list_release(para);
                  return (struct List *)(void *)0;
                }

              }

              line = (struct String *)(void *)0;
            }

            if(line == ((struct String *)NULL))
            {
              line=str_create_sized(line_width, "%.*s", r - s, s);
              if(line == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

            else
            {
              return_value_str_append_6=str_append(line, " %.*s", r - s, s);
              if(return_value_str_append_6 == ((struct String *)NULL))
              {
                str_release(line);
                list_release(para);
                return (struct List *)(void *)0;
              }

            }
            s = r;
            if(*s == 0)
              s = s - 1l;

          }

        }
        return_value_str_length_8=str_length(line);
        if(return_value_str_length_8 >= 1l)
        {
          return_value_list_append_7=list_append(para, (void *)line);
          if(return_value_list_append_7 == ((struct List *)NULL))
          {
            str_release(line);
            list_release(para);
            return (struct List *)(void *)0;
          }

        }

        if((signed int)alignment == ALIGN_RIGHT)
          do
          {
            return_value_list_has_next_9=list_has_next(para);
            if(!(return_value_list_has_next_9 == 1))
              break;

            void *return_value_list_next_10;
            return_value_list_next_10=list_next(para);
            line = (struct String *)return_value_list_next_10;
            len=str_length(line);
            if(!((unsigned long int)len >= line_width))
            {
              struct String *return_value_str_prepend_11;
              return_value_str_prepend_11=str_prepend(line, "%*s", line_width - (unsigned long int)len, (const void *)"");
              if(return_value_str_prepend_11 == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

          }
          while((_Bool)1);

        else
          if((signed int)alignment == ALIGN_FULL)
          {
            signed long int lines;
            signed int i;
            lines=list_length(para);
            if(lines == -1l)
            {
              list_release(para);
              return (struct List *)(void *)0;
            }

            i = 0;
            for( ; !((signed long int)i >= lines + -1l); i = i + 1)
            {
              unsigned long int extra;
              unsigned long int gaps;
              void *return_value_list_item_12;
              return_value_list_item_12=list_item(para, (signed long int)i);
              line = (struct String *)return_value_list_item_12;
              len=str_length(line);
              if(!((unsigned long int)len >= line_width))
              {
                extra = line_width - (unsigned long int)len;
                gaps = (unsigned long int)0;
                s = line->str;
                for( ; !(*s == 0); s = s + 1l)
                  if((signed int)*s == 32)
                    gaps = gaps + 1ul;

                s = line->str;
                do
                {
                  if(!(gaps == 0ul))
                    tmp_if_expr_13 = *s != 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_13 = (_Bool)0;
                  if(!tmp_if_expr_13)
                    break;

                  if((signed int)*s == 32)
                  {
                    signed int gap = (signed int)(extra / gaps);
                    struct String *return_value_str_insert_14;
                    return_value_str_insert_14=str_insert(line, s - line->str, "%*s", gap, (const void *)"");
                    if(return_value_str_insert_14 == ((struct String *)NULL))
                    {
                      list_release(para);
                      return (struct List *)(void *)0;
                    }

                    extra = extra - (unsigned long int)gap;
                    gaps = gaps - 1ul;
                    s = s + (signed long int)gap;
                  }

                  s = s + 1l;
                }
                while((_Bool)1);
              }

            }
          }

        break;
      }
      case ALIGN_CENTRE:
      {
        para=split_with_locker(locker, str, "\n");
        if(para == ((struct List *)NULL))
          return (struct List *)(void *)0;

        do
        {
          return_value_list_has_next_15=list_has_next(para);
          if(!(return_value_list_has_next_15 == 1))
            break;

          unsigned long int fmt_with_locker__1__1__2__1__extra;
          void *return_value_list_next_16;
          return_value_list_next_16=list_next(para);
          line = (struct String *)return_value_list_next_16;
          str_squeeze(line);
          len=str_length(line);
          if(!((unsigned long int)len >= line_width))
          {
            fmt_with_locker__1__1__2__1__extra = (line_width - (unsigned long int)len) / (unsigned long int)2;
            if(!(fmt_with_locker__1__1__2__1__extra == 0ul))
            {
              return_value_str_prepend_17=str_prepend(line, "%*s", fmt_with_locker__1__1__2__1__extra, (const void *)"");
              if(return_value_str_prepend_17 == ((struct String *)NULL))
              {
                list_release(para);
                return (struct List *)(void *)0;
              }

            }

          }

        }
        while((_Bool)1);
        break;
      }
      default:
      {
        return_value_set_errnull_18=set_errnull(22);
        return (struct List *)return_value_set_errnull_18;
      }
    }
    return para;
  }
}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat_1;
  return_value___fxstat_1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat_1;
}

// fstat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat_link1(signed int __fd_link1, struct stat *__statbuf_link1)
{
  signed int return_value___fxstat_1_link1;
  return_value___fxstat_1_link1=__fxstat(1, __fd_link1, __statbuf_link1);
  return return_value___fxstat_1_link1;
}

// getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
static inline signed int getc_unlocked(struct _IO_FILE *__fp)
{
  signed int tmp_if_expr_3;
  signed int return_value___uflow_1;
  char *tmp_post_2;
  if(__fp->_IO_read_ptr >= __fp->_IO_read_end)
  {
    return_value___uflow_1=__uflow(__fp);
    tmp_if_expr_3 = return_value___uflow_1;
  }

  else
  {
    tmp_post_2 = __fp->_IO_read_ptr;
    __fp->_IO_read_ptr = __fp->_IO_read_ptr + 1l;
    tmp_if_expr_3 = (signed int)*((unsigned char *)tmp_post_2);
  }
  return tmp_if_expr_3;
}

// getprotonamebysocktype
// file libslack/net.c line 496
static const char * getprotonamebysocktype(signed int socktype)
{
  switch(socktype)
  {
    case 1:
      return "tcp";
    case 2:
      return "udp";
    default:
      return (const char *)(void *)0;
  }
}

// getservportbynameandtype
// file libslack/net.c line 506
static unsigned short int getservportbynameandtype(const char *name, signed int type)
{
  struct servent servbuf[1l];
  struct servent *serv;
  void *buf = (void *)0;
  unsigned long int getservportbynameandtype__1__size = (unsigned long int)0;
  unsigned short int port = (unsigned short int)0;
  const char *proto;
  proto=getprotonamebysocktype(type);
  serv=net_getservbyname(name, proto, servbuf, &buf, &getservportbynameandtype__1__size);
  if(!(serv == ((struct servent *)NULL)))
    port = (unsigned short int)serv->s_port;

  free(buf);
  return port;
}

// groupname2gid
// file libslack/pseudo.c line 174
static signed int groupname2gid(const char *groupname)
{
  struct _IO_FILE *group;
  group=fopen("/etc/group", "r");
  char line[8192l];
  char *gid;
  signed int ret = -1;
  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(line, 8192, group);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(line, "tty:", (unsigned long int)4);
    if(return_value_strncmp_3 == 0)
    {
      char *return_value___builtin_strchr_2;
      return_value___builtin_strchr_2=__builtin_strchr(line + (signed long int)4, 58);
      gid = return_value___builtin_strchr_2;
      if(!(gid == ((char *)NULL)))
        ret=atoi(gid + (signed long int)1);

      break;
    }

  }
  while((_Bool)1);
  fclose(group);
  return ret;
}

// grow
// file libslack/list.c line 218
static signed int grow(struct List *list, unsigned long int items)
{
  signed int grown = 0;
  for( ; !(list->size >= list->length + items); grown = 1)
    if(!(list->size == 0ul))
      list->size = list->size << 1;

    else
      list->size = MIN_LIST_SIZE;
  void *return_value_mem_resize_fn_1;
  if(!(grown == 0))
  {
    return_value_mem_resize_fn_1=mem_resize_fn((void **)&list->list, list->size * sizeof(void *) /*8ul*/ );
    return return_value_mem_resize_fn_1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// grow_link1
// file libslack/str.c line 397
static signed int grow_link1(struct String *str, unsigned long int bytes)
{
  signed int grown_link1 = 0;
  for( ; !(str->size >= str->length + bytes); grown_link1 = 1)
    if(!(str->size == 0ul))
      str->size = str->size << 1;

    else
      str->size = MIN_STRING_SIZE;
  void *return_value_mem_resize_fn_1_link1;
  if(!(grown_link1 == 0))
  {
    return_value_mem_resize_fn_1_link1=mem_resize_fn((void **)&str->str, str->size * sizeof(char) /*1ul*/ );
    return return_value_mem_resize_fn_1_link1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// handle_debug_option
// file libslack/prog.c line 1719
static void handle_debug_option(signed int *arg)
{
  signed int tmp_if_expr_1;
  if(!(arg == ((signed int *)NULL)))
    tmp_if_expr_1 = *arg;

  else
    tmp_if_expr_1 = 1;
  prog_set_debug_level((unsigned long int)tmp_if_expr_1);
}

// handle_verbose_option
// file libslack/prog.c line 1714
static void handle_verbose_option(signed int *arg)
{
  signed int tmp_if_expr_1;
  if(!(arg == ((signed int *)NULL)))
    tmp_if_expr_1 = *arg;

  else
    tmp_if_expr_1 = 1;
  prog_set_verbosity_level((unsigned long int)tmp_if_expr_1);
}

// hash
// file libslack/map.c line 217
static unsigned long int hash(unsigned long int size, const void *key)
{
  const unsigned char *k = (const unsigned char *)key;
  unsigned long int h = (unsigned long int)0;
  const unsigned char *tmp_post_1;
  for( ; !(*k == 0); h = h + (unsigned long int)*tmp_post_1)
  {
    h = h * (unsigned long int)31;
    tmp_post_1 = k;
    k = k + 1l;
  }
  return h % size;
}

// hex
// file libslack/str.c line 6370
signed int hex(const char *str)
{
  signed int ret = 0;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if((signed int)*str == 48)
    {
      if((signed int)str[1l] == 120)
        str = str + (signed long int)2;

    }

    for( ; !(*str == 0); str = str + 1l)
    {
      ret = ret << 4;
      switch((signed int)*str)
      {
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:

        case 56:

        case 57:
        {
          ret = ret | (signed int)*str - 48;
          break;
        }
        case 97:

        case 98:

        case 99:

        case 100:

        case 101:

        case 102:
        {
          ret = ret | ((signed int)*str - 97) + 10;
          break;
        }
        case 65:

        case 66:

        case 67:

        case 68:

        case 69:

        case 70:
        {
          ret = ret | ((signed int)*str - 65) + 10;
          break;
        }
        default:
        {
          return_value_set_errno_2=set_errno(22);
          return return_value_set_errno_2;
        }
      }
    }
    return ret;
  }
}

// hsort
// file libslack/hsort.c line 201
void hsort(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *))
{
  char *p;
  char *q;
  char *base0;
  char *hi;
  unsigned int gap;
  unsigned int hsort__1__g;
  signed int return_value;
  signed int return_value_2;
  if(n >= 2ul)
  {
    base0 = (char *)base - (signed long int)size;
    gap = (unsigned int)((n >> 1) * size);
    hi = base0 + (signed long int)gap + (signed long int)gap;
    if(!((1ul & n) == 0ul))
      hi = hi + (signed long int)size;

    for( ; !((unsigned long int)gap == size); gap = gap - (unsigned int)size)
    {
      hsort__1__g = gap;
      p = base0 + (signed long int)hsort__1__g;
      q = p + (signed long int)hsort__1__g;
      if(hi >= q)
      {
        hsort__1__g = hsort__1__g + hsort__1__g;
        if(!(q == hi))
        {
          return_value=cmp((const void *)(q + (signed long int)size), (const void *)q);
          if(return_value >= 1)
          {
            q = q + (signed long int)size;
            hsort__1__g = hsort__1__g + (unsigned int)size;
          }

        }

        signed int return_value_1;
        return_value_1=cmp((const void *)p, (const void *)q);
        if(!(return_value_1 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

    }
    for( ; !(hi == (char *)base); hi = hi - (signed long int)size)
    {
      p = (char *)base;
      hsort__1__g = (unsigned int)size;
      q = p + (signed long int)hsort__1__g;
      if(hi >= q)
      {
        hsort__1__g = hsort__1__g + hsort__1__g;
        if(!(q == hi))
        {
          return_value_2=cmp((const void *)(q + (signed long int)size), (const void *)q);
          if(return_value_2 >= 1)
          {
            q = q + (signed long int)size;
            hsort__1__g = hsort__1__g + (unsigned int)size;
          }

        }

        signed int return_value_3;
        return_value_3=cmp((const void *)p, (const void *)q);
        if(!(return_value_3 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

      swap((char *)base, hi, size);
    }
  }

}

// hsort_closure
// file libslack/hsort.c line 295
void hsort_closure(void *base, unsigned long int n, unsigned long int size, signed int (*cmp)(const void *, const void *, const void *), const void *data)
{
  char *p;
  char *q;
  char *base0;
  char *hi;
  unsigned int gap;
  unsigned int hsort_closure__1__g;
  signed int return_value;
  signed int return_value_2;
  if(n >= 2ul)
  {
    base0 = (char *)base - (signed long int)size;
    gap = (unsigned int)((n >> 1) * size);
    hi = base0 + (signed long int)gap + (signed long int)gap;
    if(!((1ul & n) == 0ul))
      hi = hi + (signed long int)size;

    for( ; !((unsigned long int)gap == size); gap = gap - (unsigned int)size)
    {
      hsort_closure__1__g = gap;
      p = base0 + (signed long int)hsort_closure__1__g;
      q = p + (signed long int)hsort_closure__1__g;
      if(hi >= q)
      {
        hsort_closure__1__g = hsort_closure__1__g + hsort_closure__1__g;
        if(!(q == hi))
        {
          return_value=cmp((const void *)(q + (signed long int)size), (const void *)q, data);
          if(return_value >= 1)
          {
            q = q + (signed long int)size;
            hsort_closure__1__g = hsort_closure__1__g + (unsigned int)size;
          }

        }

        signed int return_value_1;
        return_value_1=cmp((const void *)p, (const void *)q, data);
        if(!(return_value_1 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

    }
    for( ; !(hi == (char *)base); hi = hi - (signed long int)size)
    {
      p = (char *)base;
      hsort_closure__1__g = (unsigned int)size;
      q = p + (signed long int)hsort_closure__1__g;
      if(hi >= q)
      {
        hsort_closure__1__g = hsort_closure__1__g + hsort_closure__1__g;
        if(!(q == hi))
        {
          return_value_2=cmp((const void *)(q + (signed long int)size), (const void *)q, data);
          if(return_value_2 >= 1)
          {
            q = q + (signed long int)size;
            hsort_closure__1__g = hsort_closure__1__g + (unsigned int)size;
          }

        }

        signed int return_value_3;
        return_value_3=cmp((const void *)p, (const void *)q, data);
        if(!(return_value_3 >= 0))
        {
          swap(p, q, size);
          p = q;
        }

      }

      swap((char *)base, hi, size);
    }
  }

}

// iface_release
// file libslack/net.c line 2007
static void iface_release(struct net_interface_t *iface)
{
  if(!(iface == ((struct net_interface_t *)NULL)))
  {
    free((void *)iface->addr);
    free((void *)iface->brdaddr);
    free((void *)iface->dstaddr);
    free((void *)iface->hwaddr);
    free((void *)iface);
  }

}

// inet6_required
// file libslack/net.c line 468
static signed int inet6_required(void)
{
  char *res_options;
  struct _IO_FILE *resolv_conf;
  res_options=getenv("RES_OPTIONS");
  char *return_value_strstr_1;
  char *return_value_fgets_2;
  char *return_value_strstr_3;
  if(!(res_options == ((char *)NULL)))
  {
    return_value_strstr_1=strstr(res_options, "inet6");
    if(return_value_strstr_1 == ((char *)NULL))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    resolv_conf=fopen("/etc/resolv.conf", "r");
    if(!(resolv_conf == ((struct _IO_FILE *)NULL)))
    {
      char line[8192l];
      do
      {
        return_value_fgets_2=fgets(line, 8192, resolv_conf);
        if(return_value_fgets_2 == ((char *)NULL))
          break;

        signed int return_value_strncmp_4;
        return_value_strncmp_4=strncmp(line, "options", (unsigned long int)7);
        if(return_value_strncmp_4 == 0)
        {
          return_value_strstr_3=strstr(line + (signed long int)8, "inet6");
          if(!(return_value_strstr_3 == ((char *)NULL)))
          {
            fclose(resolv_conf);
            return 1;
          }

        }

      }
      while((_Bool)1);
      fclose(resolv_conf);
    }

    return 0;
  }
}

// install
// file libslack/agent.c line 1639
static void install(struct action_t **parent, struct action_t *action)
{
  void *return_value_dlink_insert_1;
  return_value_dlink_insert_1=dlink_insert((void *)*parent, (void *)action);
  *parent = (struct action_t *)return_value_dlink_insert_1;
  action->parent = parent;
}

// int_arg
// file libslack/prog.c line 1862
static signed int int_arg(const char *argument)
{
  char *endptr = (char *)(void *)0;
  signed long int val;
  val=strtol(argument, &endptr, 0);
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  if(val >= 2147483648l)
  {
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 34;
    return 0x7fffffff;
  }

  else
    if(!(val >= -2147483648l))
    {
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 34;
      return -0x7fffffff - 1;
    }

    else
    {
      if(endptr == argument)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 33;
        return 0;
      }

      else
        return (signed int)val;
    }
}

// is_multicast
// file libslack/net.c line 555
static signed int is_multicast(struct sockaddr *address)
{
  union sockaddr_any_t *addr = (union sockaddr_any_t *)address;
  signed long int *longptr;
  unsigned int return_value___bswap_32_1;
  switch((signed int)addr->any.sa_family)
  {
    case 2:
    {
      longptr = (signed long int *)&addr->in.sin_addr;
      return_value___bswap_32_1=__bswap_32((unsigned int)*longptr);
      return (signed int)(((unsigned int)return_value___bswap_32_1 & 0xf0000000) == 0xe0000000);
    }
    case 10:
      return (signed int)((signed int)((const unsigned char *)&addr->in6.sin6_addr)[(signed long int)0] == 0xff);
    default:
      return 0;
  }
}

// iterate_builtin
// file libslack/map.c line 2548
void * iterate_builtin(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  signed int broken = 0;
  if(!(debug == 0))
    printf("i%d: loop\n", t);

  i = 0;
  signed int return_value_map_has_next_1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    map_wrlock(mtmap);
    do
    {
      return_value_map_has_next_1=map_has_next(mtmap);
      if(!(return_value_map_has_next_1 == 1))
        break;

      signed int val;
      void *return_value_map_next_2;
      return_value_map_next_2=map_next(mtmap);
      val = (signed int)(signed long int)return_value_map_next_2;
      if(!(debug == 0))
        printf("i%d: loop %d/%d val %d\n", t, i, lim / 10, val);

      if(broken == 0)
      {
        map_break(mtmap);
        broken = 1;
        break;
      }

    }
    while((_Bool)1);
    map_unlock(mtmap);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// iterate_rdlocked
// file libslack/map.c line 2583
void * iterate_rdlocked(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("j%d: loop\n", t);

  i = 0;
  signed int return_value_mapper_has_next_1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    struct Mapper *mapper;
    mapper=mapper_create_rdlocked(mtmap);
    do
    {
      return_value_mapper_has_next_1=mapper_has_next(mapper);
      if(!(return_value_mapper_has_next_1 == 1))
        break;

      signed int val;
      void *return_value_mapper_next_2;
      return_value_mapper_next_2=mapper_next(mapper);
      val = (signed int)(signed long int)return_value_mapper_next_2;
      if(!(debug == 0))
        printf("j%d: loop %d/%d val %d\n", t, i, lim / 10, val);

    }
    while((_Bool)1);
    mapper_release(mapper);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// iterate_wrlocked
// file libslack/map.c line 2610
void * iterate_wrlocked(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("k%d: loop\n", t);

  i = 0;
  signed int return_value_mapper_has_next_1;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    struct Mapper *mapper;
    mapper=mapper_create_wrlocked(mtmap);
    do
    {
      return_value_mapper_has_next_1=mapper_has_next(mapper);
      if(!(return_value_mapper_has_next_1 == 1))
        break;

      signed int val;
      void *return_value_mapper_next_2;
      return_value_mapper_next_2=mapper_next(mapper);
      val = (signed int)(signed long int)return_value_mapper_next_2;
      if(!(debug == 0))
        printf("k%d: loop %d/%d val %d\n", t, i, lim / 10, val);

    }
    while((_Bool)1);
    mapper_release(mapper);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// join
// file libslack/str.c line 4465
struct String * join(const struct List *list, const char *delim)
{
  struct String *return_value_join_with_locker_1;
  return_value_join_with_locker_1=join_with_locker((struct Locker *)(void *)0, list, delim);
  return return_value_join_with_locker_1;
}

// join_with_locker
// file libslack/str.c line 4481
struct String * join_with_locker(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  struct String *del;
  struct Lister *lister;
  signed int i;
  void *return_value_set_errnull_1;
  signed int return_value_lister_has_next_2;
  struct String *return_value_str_append_str_4;
  struct String *return_value_str_append_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_create_with_locker(locker, (const char *)(void *)0);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      del=str_create(delim != ((const char *)NULL) ? "%s" : (char *)(void *)0, delim);
      if(del == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
      {
        lister=lister_create((struct List *)list);
        if(lister == ((struct Lister *)NULL))
        {
          str_release(ret);
          str_release(del);
          return (struct String *)(void *)0;
        }

        else
        {
          i = 0;
          do
          {
            return_value_lister_has_next_2=lister_has_next(lister);
            if(!(return_value_lister_has_next_2 == 1))
              break;

            char *s;
            void *return_value_lister_next_3;
            return_value_lister_next_3=lister_next(lister);
            s = (char *)return_value_lister_next_3;
            if(!(i == 0))
            {
              return_value_str_append_str_4=str_append_str(ret, del);
              if(return_value_str_append_str_4 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release(lister);
                return (struct String *)(void *)0;
              }

            }

            if(!(s == ((char *)NULL)))
            {
              return_value_str_append_5=str_append(ret, "%s", s);
              if(return_value_str_append_5 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release(lister);
                return (struct String *)(void *)0;
              }

            }

            i = i + 1;
          }
          while((_Bool)1);
          str_release(del);
          lister_release(lister);
          return ret;
        }
      }
    }
  }
}

// key_cmp
// file libslack/prop.c line 192
static signed int key_cmp(const char **a, const char **b)
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp(*a, *b);
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  return tmp_statement_expression_1;
}

// killitems
// file libslack/list.c line 337
static void killitems(struct List *list, unsigned long int index, unsigned long int range)
{
  unsigned long int tmp_post_1;
  unsigned long int tmp_post_2;
  do
  {
    tmp_post_1 = range;
    range = range - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if(!(list->destroy == ((void (*)(void *))NULL)))
      list->destroy(list->list[(signed long int)index]);

    tmp_post_2 = index;
    index = index + 1ul;
    list->list[(signed long int)tmp_post_2] = (void *)0;
  }
  while((_Bool)1);
}

// lc
// file libslack/str.c line 5810
char * lc(char *str)
{
  char *s;
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_tolower_loc_3;
  const signed int **return_value___ctype_tolower_loc_5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    s = str;
    for( ; !(*s == 0); s = s + 1l)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)*s);
      tmp_statement_expression_2 = __res;
      *s = (char)tmp_statement_expression_2;
    }
    return str;
  }
}

// lcfirst
// file libslack/str.c line 5885
char * lcfirst(char *str)
{
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_tolower_loc_3;
  const signed int **return_value___ctype_tolower_loc_5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    signed int __res;
    __res=tolower((signed int)(unsigned char)*str);
    tmp_statement_expression_2 = __res;
    *str = (char)tmp_statement_expression_2;
    return str;
  }
}

// limit_arg
// file libslack/lim.c line 238
signed long int limit_arg(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(0);
  return return_value_limit_sysconf_1;
}

// limit_canon
// file libslack/lim.c line 429
signed long int limit_canon(void)
{
  signed long int return_value_limit_pcanon_1;
  return_value_limit_pcanon_1=limit_pcanon("/dev/tty");
  return return_value_limit_pcanon_1;
}

// limit_child
// file libslack/lim.c line 254
signed long int limit_child(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(1);
  return return_value_limit_sysconf_1;
}

// limit_chown
// file libslack/lim.c line 801
signed long int limit_chown(void)
{
  signed long int return_value_limit_pchown_1;
  return_value_limit_pchown_1=limit_pchown("/");
  return return_value_limit_pchown_1;
}

// limit_fcanon
// file libslack/lim.c line 413
signed long int limit_fcanon(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(10, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fchown
// file libslack/lim.c line 785
signed long int limit_fchown(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(18, fd);
  return return_value_limit_fpathconf_1;
}

// limit_finput
// file libslack/lim.c line 461
signed long int limit_finput(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(11, fd);
  return return_value_limit_fpathconf_1;
}

// limit_flink
// file libslack/lim.c line 557
signed long int limit_flink(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(13, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fname
// file libslack/lim.c line 607
signed long int limit_fname(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(14, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fnotrunc
// file libslack/lim.c line 737
signed long int limit_fnotrunc(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(17, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fpath
// file libslack/lim.c line 657
signed long int limit_fpath(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(15, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fpathconf
// file libslack/lim.c line 217
static signed long int limit_fpathconf(signed int limit, signed int fd)
{
  signed long int value;
  value=fpathconf(fd, g_link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g_link1.conf[(signed long int)limit].value;

  else
    return value + g_link1.conf[(signed long int)limit].offset;
}

// limit_fpipe
// file libslack/lim.c line 705
signed long int limit_fpipe(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(16, fd);
  return return_value_limit_fpathconf_1;
}

// limit_fvdisable
// file libslack/lim.c line 509
signed long int limit_fvdisable(signed int fd)
{
  signed long int return_value_limit_fpathconf_1;
  return_value_limit_fpathconf_1=limit_fpathconf(12, fd);
  return return_value_limit_fpathconf_1;
}

// limit_group
// file libslack/lim.c line 286
signed long int limit_group(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(3);
  return return_value_limit_sysconf_1;
}

// limit_input
// file libslack/lim.c line 477
signed long int limit_input(void)
{
  signed long int return_value_limit_pinput_1;
  return_value_limit_pinput_1=limit_pinput("/dev/tty");
  return return_value_limit_pinput_1;
}

// limit_job
// file libslack/lim.c line 349
signed long int limit_job(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(7);
  return return_value_limit_sysconf_1;
}

// limit_link
// file libslack/lim.c line 573
signed long int limit_link(void)
{
  signed long int return_value_limit_plink_1;
  return_value_limit_plink_1=limit_plink("/");
  return return_value_limit_plink_1;
}

// limit_name
// file libslack/lim.c line 623
signed long int limit_name(void)
{
  signed long int return_value_limit_pname_1;
  return_value_limit_pname_1=limit_pname("/");
  return return_value_limit_pname_1;
}

// limit_notrunc
// file libslack/lim.c line 753
signed long int limit_notrunc(void)
{
  signed long int return_value_limit_pnotrunc_1;
  return_value_limit_pnotrunc_1=limit_pnotrunc("/");
  return return_value_limit_pnotrunc_1;
}

// limit_open
// file libslack/lim.h line 34
signed long int limit_open(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(4);
  return return_value_limit_sysconf_1;
}

// limit_path
// file libslack/lim.h line 57
signed long int limit_path(void)
{
  signed long int return_value_limit_ppath_1;
  return_value_limit_ppath_1=limit_ppath("/");
  return return_value_limit_ppath_1;
}

// limit_pathconf
// file libslack/lim.c line 193
static signed long int limit_pathconf(signed int limit, const char *path)
{
  signed long int value;
  value=pathconf(path, g_link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g_link1.conf[(signed long int)limit].value;

  else
    return value + g_link1.conf[(signed long int)limit].offset;
}

// limit_pcanon
// file libslack/lim.c line 397
signed long int limit_pcanon(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(10, path);
  return return_value_limit_pathconf_1;
}

// limit_pchown
// file libslack/lim.c line 769
signed long int limit_pchown(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(18, path);
  return return_value_limit_pathconf_1;
}

// limit_pinput
// file libslack/lim.c line 445
signed long int limit_pinput(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(11, path);
  return return_value_limit_pathconf_1;
}

// limit_plink
// file libslack/lim.c line 541
signed long int limit_plink(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(13, path);
  return return_value_limit_pathconf_1;
}

// limit_pname
// file libslack/lim.c line 590
signed long int limit_pname(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(14, path);
  return return_value_limit_pathconf_1;
}

// limit_pnotrunc
// file libslack/lim.c line 721
signed long int limit_pnotrunc(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(17, path);
  return return_value_limit_pathconf_1;
}

// limit_ppath
// file libslack/lim.c line 640
signed long int limit_ppath(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(15, path);
  return return_value_limit_pathconf_1;
}

// limit_ppipe
// file libslack/lim.c line 689
signed long int limit_ppipe(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(16, path);
  return return_value_limit_pathconf_1;
}

// limit_pvdisable
// file libslack/lim.c line 493
signed long int limit_pvdisable(const char *path)
{
  signed long int return_value_limit_pathconf_1;
  return_value_limit_pathconf_1=limit_pathconf(12, path);
  return return_value_limit_pathconf_1;
}

// limit_save_ids
// file libslack/lim.c line 365
signed long int limit_save_ids(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(8);
  return return_value_limit_sysconf_1;
}

// limit_stream
// file libslack/lim.c line 318
signed long int limit_stream(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(5);
  return return_value_limit_sysconf_1;
}

// limit_sysconf
// file libslack/lim.c line 169
static signed long int limit_sysconf(signed int limit)
{
  signed long int value;
  value=sysconf(g_link1.conf[(signed long int)limit].name);
  if(value == -1l)
    return g_link1.conf[(signed long int)limit].value;

  else
    return value;
}

// limit_tick
// file libslack/lim.c line 270
signed long int limit_tick(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(2);
  return return_value_limit_sysconf_1;
}

// limit_tzname
// file libslack/lim.c line 334
signed long int limit_tzname(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(6);
  return return_value_limit_sysconf_1;
}

// limit_vdisable
// file libslack/lim.c line 525
signed long int limit_vdisable(void)
{
  signed long int return_value_limit_pvdisable_1;
  return_value_limit_pvdisable_1=limit_pvdisable("/dev/tty");
  return return_value_limit_pvdisable_1;
}

// limit_version
// file libslack/lim.c line 381
signed long int limit_version(void)
{
  signed long int return_value_limit_sysconf_1;
  return_value_limit_sysconf_1=limit_sysconf(9);
  return return_value_limit_sysconf_1;
}

// list_append
// file libslack/slack/list.h line 81
struct List * list_append(struct List *list, void *item)
{
  struct List *return_value_list_insert_1;
  return_value_list_insert_1=list_insert(list, (signed long int)-1, item);
  return return_value_list_insert_1;
}

// list_append_int
// file libslack/list.c line 1307
struct List * list_append_int(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_1;
  return_value_list_insert_int_1=list_insert_int(list, (signed long int)-1, item);
  return return_value_list_insert_int_1;
}

// list_append_int_unlocked
// file libslack/list.c line 1322
struct List * list_append_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_unlocked_1;
  return_value_list_insert_int_unlocked_1=list_insert_int_unlocked(list, (signed long int)-1, item);
  return return_value_list_insert_int_unlocked_1;
}

// list_append_list
// file libslack/list.c line 1339
struct List * list_append_list(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_1;
  return_value_list_insert_list_1=list_insert_list(list, (signed long int)-1, src, copy);
  return return_value_list_insert_list_1;
}

// list_append_list_unlocked
// file libslack/list.c line 1355
struct List * list_append_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_unlocked_1;
  return_value_list_insert_list_unlocked_1=list_insert_list_unlocked(list, (signed long int)-1, src, copy);
  return return_value_list_insert_list_unlocked_1;
}

// list_append_unlocked
// file libslack/list.c line 1292
struct List * list_append_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_insert_unlocked_1;
  return_value_list_insert_unlocked_1=list_insert_unlocked(list, (signed long int)-1, item);
  return return_value_list_insert_unlocked_1;
}

// list_apply
// file libslack/list.c line 2245
void list_apply(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  list_apply_wrlocked(list, action, data);
}

// list_apply_rdlocked
// file libslack/list.c line 2262
void list_apply_rdlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      list_apply_unlocked(list, action, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_3 = return_value_1;
        }

        else
          tmp_if_expr_3 = 0;
        tmp_if_expr_4 = tmp_if_expr_3;
      }

      else
        tmp_if_expr_4 = 22;
      err = tmp_if_expr_4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// list_apply_unlocked
// file libslack/list.c line 2327
void list_apply_unlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  unsigned long int i;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    i = (unsigned long int)0;
    if(!(i >= list->length))
    {
      action(list->list[(signed long int)i], &i, data);
      i = i + 1ul;
    }

  }
}

// list_apply_wrlocked
// file libslack/list.c line 2295
void list_apply_wrlocked(struct List *list, void (*action)(void *, unsigned long int *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  if(action == ((void (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
    set_errno(22);

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      list_apply_unlocked(list, action, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_3 = return_value_1;
        }

        else
          tmp_if_expr_3 = 0;
        tmp_if_expr_4 = tmp_if_expr_3;
      }

      else
        tmp_if_expr_4 = 22;
      err = tmp_if_expr_4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// list_break
// file libslack/list.c line 2950
void list_break(struct List *list)
{
  if(list == ((struct List *)NULL))
    set_errno(22);

  else
    lister_destroy_unlocked(&list->lister);
}

// list_copy
// file libslack/list.c line 418
struct List * list_copy(const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_copy_with_locker_1;
  return_value_list_copy_with_locker_1=list_copy_with_locker((struct Locker *)(void *)0, src, copy);
  return return_value_list_copy_with_locker_1;
}

// list_copy_with_locker
// file libslack/list.c line 513
struct List * list_copy_with_locker(struct Locker *locker, const struct List *src, void * (*copy)(const void *))
{
  struct List *list;
  void *return_value_set_errnull_1;
  if(src == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    list=list_extract(src, (signed long int)0, (signed long int)src->length, copy);
    if(list == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      list->locker = locker;
      return list;
    }
  }
}

// list_create
// file libslack/slack/list.h line 44
struct List * list_create(void (*destroy)(void *))
{
  struct List *return_value_list_create_with_locker_1;
  return_value_list_create_with_locker_1=list_create_with_locker((struct Locker *)(void *)0, destroy);
  return return_value_list_create_with_locker_1;
}

// list_create_with_locker
// file libslack/list.c line 434
struct List * list_create_with_locker(struct Locker *locker, void (*destroy)(void *))
{
  struct List *list;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct List) /*48ul*/ );
  list = (struct List *)return_value_malloc_1;
  if(list == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    list->length = (unsigned long int)0;
    list->size = list->length;
    list->list = (void **)(void *)0;
    list->destroy = destroy;
    list->lister = (struct Lister *)(void *)0;
    list->locker = locker;
    return list;
  }
}

// list_destroy
// file libslack/slack/list.h line 56
void * list_destroy(struct List **list)
{
  if(!(list == ((struct List **)NULL)))
  {
    if(!(*list == ((struct List *)NULL)))
    {
      list_release(*list);
      *list = (struct List *)(void *)0;
    }

  }

  return (void *)0;
}

// list_disown
// file libslack/list.c line 703
void (*list_disown(struct List *list))(void *)
{
  void (*destroy)(void *);
  signed int err;
  void (*return_value_set_errnullf_1)();
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void (*return_value_set_errnullf_2)();
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void (*return_value_set_errnullf_5)();
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnullf_1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnullf_2=set_errnullf(err);
      return (void (*)(void *))return_value_set_errnullf_2;
    }

    else
    {
      destroy=list_disown_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnullf_5=set_errnullf(err);
        return (void (*)(void *))return_value_set_errnullf_5;
      }

      else
        return destroy;
    }
  }
}

// list_disown_unlocked
// file libslack/list.c line 732
void (*list_disown_unlocked(struct List *list))(void *)
{
  void (*destroy)(void *);
  void (*return_value_set_errnullf_1)();
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnullf_1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf_1;
  }

  else
  {
    destroy = list->destroy;
    list->destroy = (void (*)(void *))(void *)0;
    return destroy;
  }
}

// list_empty
// file libslack/list.c line 846
signed int list_empty(const struct List *list)
{
  signed int empty;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      empty = (signed int)(list->length == (unsigned long int)0);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return empty;
    }
  }
}

// list_empty_unlocked
// file libslack/list.c line 875
signed int list_empty_unlocked(const struct List *list)
{
  signed int return_value_set_errno_1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)(list->length == (unsigned long int)0);
}

// list_extract
// file libslack/list.c line 1669
struct List * list_extract(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_extract_with_locker_1;
  return_value_list_extract_with_locker_1=list_extract_with_locker((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_extract_with_locker_1;
}

// list_extract_unlocked
// file libslack/list.c line 1684
struct List * list_extract_unlocked(const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_extract_with_locker_unlocked_1;
  return_value_list_extract_with_locker_unlocked_1=list_extract_with_locker_unlocked((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_extract_with_locker_unlocked_1;
}

// list_extract_with_locker
// file libslack/list.c line 1700
struct List * list_extract_with_locker(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_extract_with_locker_unlocked(locker, list, index, range, copy);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// list_extract_with_locker_unlocked
// file libslack/list.c line 1730
struct List * list_extract_with_locker_unlocked(struct Locker *locker, const struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  _Bool tmp_if_expr_5;
  void *return_value_set_errnull_4;
  void (*tmp_if_expr_6)(void *);
  signed long int tmp_post_7;
  void *tmp_if_expr_10;
  signed long int tmp_post_8;
  void *return_value;
  signed long int tmp_post_9;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
      {
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct List *)return_value_set_errnull_4;
        }

        else
        {
          if(!(copy == ((void * (*)(const void *))NULL)))
            tmp_if_expr_6 = list->destroy;

          else
            tmp_if_expr_6 = (void (*)(void *))(void *)0;
          ret=list_create_with_locker(locker, tmp_if_expr_6);
          if(ret == ((struct List *)NULL))
            return (struct List *)(void *)0;

          else
          {
            do
            {
              tmp_post_7 = range;
              range = range - 1l;
              if(tmp_post_7 == 0l)
                break;

              if(!(copy == ((void * (*)(const void *))NULL)))
              {
                tmp_post_8 = index;
                index = index + 1l;
                return_value=copy(list->list[tmp_post_8]);
                tmp_if_expr_10 = return_value;
              }

              else
              {
                tmp_post_9 = index;
                index = index + 1l;
                tmp_if_expr_10 = list->list[tmp_post_9];
              }
              struct List *return_value_list_append_11;
              return_value_list_append_11=list_append(ret, tmp_if_expr_10);
              if(return_value_list_append_11 == ((struct List *)NULL))
              {
                list_release(ret);
                return (struct List *)(void *)0;
              }

            }
            while((_Bool)1);
            return ret;
          }
        }
      }
    }
  }
}

// list_grep
// file libslack/list.c line 2461
struct List * list_grep(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_grep_with_locker_1;
  return_value_list_grep_with_locker_1=list_grep_with_locker((struct Locker *)(void *)0, list, grep, data);
  return return_value_list_grep_with_locker_1;
}

// list_grep_unlocked
// file libslack/list.c line 2476
struct List * list_grep_unlocked(struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_grep_with_locker_unlocked_1;
  return_value_list_grep_with_locker_unlocked_1=list_grep_with_locker_unlocked((struct Locker *)(void *)0, list, grep, data);
  return return_value_list_grep_with_locker_unlocked_1;
}

// list_grep_with_locker
// file libslack/list.c line 2492
struct List * list_grep_with_locker(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *grepping;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      grepping=list_grep_with_locker_unlocked(locker, list, grep, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(grepping);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return grepping;
    }
  }
}

// list_grep_with_locker_unlocked
// file libslack/list.c line 2525
struct List * list_grep_with_locker_unlocked(struct Locker *locker, struct List *list, signed int (*grep)(void *, unsigned long int *, void *), void *data)
{
  struct List *grepping;
  unsigned long int i;
  void *return_value_set_errnull_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    grepping=list_create((void (*)(void *))(void *)0);
    if(grepping == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      if(!(i >= list->length))
      {
        signed int return_value;
        return_value=grep(list->list[(signed long int)i], &i, data);
        if(!(return_value == 0))
        {
          struct List *return_value_list_append_2;
          return_value_list_append_2=list_append(grepping, list->list[(signed long int)i]);
          if(return_value_list_append_2 == ((struct List *)NULL))
          {
            list_release(grepping);
            return (struct List *)(void *)0;
          }

        }

        i = i + 1ul;
      }

      return grepping;
    }
  }
}

// list_has_next
// file libslack/list.c line 2922
signed int list_has_next(struct List *list)
{
  signed int has;
  signed int return_value_set_errno_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if(list->lister == ((struct Lister *)NULL))
    {
      list->lister=lister_create_unlocked(list);
      if(!(list->lister == ((struct Lister *)NULL)))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      has=lister_has_next(list->lister);
      if(!(has == 1))
        list_break(list);

      return has;
    }
}

// list_insert
// file libslack/list.c line 1099
struct List * list_insert(struct List *list, signed long int index, void *item)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_insert_unlocked(list, index, item);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// list_insert_int
// file libslack/list.c line 1160
struct List * list_insert_int(struct List *list, signed long int index, signed int item)
{
  struct List *return_value_list_insert_1;
  return_value_list_insert_1=list_insert(list, index, (void *)(signed long int)item);
  return return_value_list_insert_1;
}

// list_insert_int_unlocked
// file libslack/list.c line 1175
struct List * list_insert_int_unlocked(struct List *list, signed long int index, signed int item)
{
  struct List *return_value_list_insert_unlocked_1;
  return_value_list_insert_unlocked_1=list_insert_unlocked(list, index, (void *)(signed long int)item);
  return return_value_list_insert_unlocked_1;
}

// list_insert_list
// file libslack/list.c line 1195
struct List * list_insert_list(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  signed int return_value_2;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  signed int return_value_3;
  void *return_value_set_errnull_11;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_1=src->locker->rdlock(src->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      ret=list_insert_list_unlocked(list, index, src, copy);
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_2=src->locker->unlock(src->locker->lock);
          tmp_if_expr_9 = return_value_2;
        }

        else
          tmp_if_expr_9 = 0;
        tmp_if_expr_10 = tmp_if_expr_9;
      }

      else
        tmp_if_expr_10 = 22;
      err = tmp_if_expr_10;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_8;
        return_value_set_errnull_8=set_errnull(err);
        return (struct List *)return_value_set_errnull_8;
      }

      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_3=list->locker->unlock(list->locker->lock);
          tmp_if_expr_12 = return_value_3;
        }

        else
          tmp_if_expr_12 = 0;
        tmp_if_expr_13 = tmp_if_expr_12;
      }

      else
        tmp_if_expr_13 = 22;
      err = tmp_if_expr_13;
      if(!(err == 0))
      {
        return_value_set_errnull_11=set_errnull(err);
        return (struct List *)return_value_set_errnull_11;
      }

      else
        return ret;
    }
  }
}

// list_insert_list_unlocked
// file libslack/list.c line 1241
struct List * list_insert_list_unlocked(struct List *list, signed long int index, const struct List *src, void * (*copy)(const void *))
{
  unsigned long int i;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  _Bool tmp_if_expr_4;
  void *return_value_set_errnull_3;
  void *tmp_if_expr_6;
  void *return_value;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(list->length >= (unsigned long int)index))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
      {
        signed int return_value_expand_5;
        return_value_expand_5=expand(list, index, src->length);
        if(return_value_expand_5 == -1)
          return (struct List *)(void *)0;

        else
        {
          i = (unsigned long int)0;
          for( ; !(i >= src->length); i = i + 1ul)
          {
            if(!(copy == ((void * (*)(const void *))NULL)))
            {
              return_value=copy(src->list[(signed long int)i]);
              tmp_if_expr_6 = return_value;
            }

            else
              tmp_if_expr_6 = src->list[(signed long int)i];
            list->list[(signed long int)((unsigned long int)index + i)] = tmp_if_expr_6;
          }
          return list;
        }
      }
    }
  }
}

// list_insert_unlocked
// file libslack/list.c line 1128
struct List * list_insert_unlocked(struct List *list, signed long int index, void *item)
{
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
      if(!(list->length >= (unsigned long int)index))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
      {
        signed int return_value_expand_4;
        return_value_expand_4=expand(list, index, (unsigned long int)1);
        if(return_value_expand_4 == -1)
          return (struct List *)(void *)0;

        else
        {
          list->list[index] = item;
          return list;
        }
      }
  }
}

// list_item
// file libslack/slack/list.h line 61
void * list_item(const struct List *list, signed long int index)
{
  void *item;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      item=list_item_unlocked(list, index);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return return_value_set_errnull_5;
      }

      else
        return item;
    }
  }
}

// list_item_int
// file libslack/list.c line 815
signed int list_item_int(const struct List *list, signed long int index)
{
  void *return_value_list_item_1;
  return_value_list_item_1=list_item(list, index);
  return (signed int)(signed long int)return_value_list_item_1;
}

// list_item_int_unlocked
// file libslack/list.c line 830
signed int list_item_int_unlocked(const struct List *list, signed long int index)
{
  void *return_value_list_item_unlocked_1;
  return_value_list_item_unlocked_1=list_item_unlocked(list, index);
  return (signed int)(signed long int)return_value_list_item_unlocked_1;
}

// list_item_unlocked
// file libslack/list.c line 787
void * list_item_unlocked(const struct List *list, signed long int index)
{
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return return_value_set_errnull_2;
    }

    else
      if((unsigned long int)index >= list->length)
      {
        return_value_set_errnull_3=set_errnull(22);
        return return_value_set_errnull_3;
      }

      else
        return list->list[index];
  }
}

// list_last
// file libslack/list.c line 942
signed long int list_last(const struct List *list)
{
  signed long int last;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      last = (signed long int)(list->length - (unsigned long int)1);
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return last;
    }
  }
}

// list_last_unlocked
// file libslack/list.c line 971
signed long int list_last_unlocked(const struct List *list)
{
  signed int return_value_set_errno_1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
    return (signed long int)(list->length - (unsigned long int)1);
}

// list_length
// file libslack/slack/list.h line 67
signed long int list_length(const struct List *list)
{
  unsigned long int length;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(list == ((const struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      length = list->length;
      if(!(list == ((const struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return (signed long int)length;
    }
  }
}

// list_length_unlocked
// file libslack/list.c line 923
signed long int list_length_unlocked(const struct List *list)
{
  signed int return_value_set_errno_1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
    return (signed long int)list->length;
}

// list_make
// file libslack/list.c line 379
struct List * list_make(void (*destroy)(void *), ...)
{
  struct List *list;
  void **args = (void **)&destroy;
  list=list_vmake_with_locker((struct Locker *)(void *)0, destroy, args);
  args = ((void **)NULL);
  return list;
}

// list_make_with_locker
// file libslack/list.c line 461
struct List * list_make_with_locker(struct Locker *locker, void (*destroy)(void *), ...)
{
  struct List *list;
  void **args = (void **)&destroy;
  list=list_vmake_with_locker(locker, destroy, args);
  args = ((void **)NULL);
  return list;
}

// list_map
// file libslack/list.c line 2357
struct List * list_map(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_map_with_locker_1;
  return_value_list_map_with_locker_1=list_map_with_locker((struct Locker *)(void *)0, list, destroy, map, data);
  return return_value_list_map_with_locker_1;
}

// list_map_unlocked
// file libslack/list.c line 2372
struct List * list_map_unlocked(struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *return_value_list_map_with_locker_unlocked_1;
  return_value_list_map_with_locker_unlocked_1=list_map_with_locker_unlocked((struct Locker *)(void *)0, list, destroy, map, data);
  return return_value_list_map_with_locker_unlocked_1;
}

// list_map_with_locker
// file libslack/list.c line 2388
struct List * list_map_with_locker(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *mapping;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(map == ((void * (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      mapping=list_map_with_locker_unlocked(locker, list, destroy, map, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(mapping);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return mapping;
    }
  }
}

// list_map_with_locker_unlocked
// file libslack/list.c line 2421
struct List * list_map_with_locker_unlocked(struct Locker *locker, struct List *list, void (*destroy)(void *), void * (*map)(void *, unsigned long int *, void *), void *data)
{
  struct List *mapping;
  unsigned long int i;
  void *return_value_set_errnull_1;
  if(map == ((void * (*)(void *, unsigned long int *, void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    mapping=list_create_with_locker(locker, destroy);
    if(mapping == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      if(!(i >= list->length))
      {
        void *return_value;
        return_value=map(list->list[(signed long int)i], &i, data);
        struct List *return_value_list_append_2;
        return_value_list_append_2=list_append(mapping, return_value);
        if(return_value_list_append_2 == ((struct List *)NULL))
        {
          list_release(mapping);
          return (struct List *)(void *)0;
        }

        i = i + 1ul;
      }

      return mapping;
    }
  }
}

// list_next
// file libslack/list.c line 2972
void * list_next(struct List *list)
{
  _Bool tmp_if_expr_2;
  if(list == ((struct List *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    void *return_value_lister_next_3;
    return_value_lister_next_3=lister_next(list->lister);
    return return_value_lister_next_3;
  }
}

// list_next_int
// file libslack/list.c line 2990
signed int list_next_int(struct List *list)
{
  _Bool tmp_if_expr_2;
  if(list == ((struct List *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_lister_next_int_3;
    return_value_lister_next_int_3=lister_next_int(list->lister);
    return return_value_lister_next_int_3;
  }
}

// list_own
// file libslack/list.c line 652
signed int list_own(struct List *list, void (*destroy)(void *))
{
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(destroy == ((void (*)(void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      list->destroy = destroy;
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return 0;
    }
  }
}

// list_own_unlocked
// file libslack/list.c line 680
signed int list_own_unlocked(struct List *list, void (*destroy)(void *))
{
  signed int return_value_set_errno_1;
  if(destroy == ((void (*)(void *))NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    list->destroy = destroy;
    return 0;
  }
}

// list_pop
// file libslack/list.c line 1841
void * list_pop(struct List *list)
{
  void *item;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      item=list_pop_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return return_value_set_errnull_5;
      }

      else
        return item;
    }
  }
}

// list_pop_int
// file libslack/list.c line 1903
signed int list_pop_int(struct List *list)
{
  void *return_value_list_pop_1;
  return_value_list_pop_1=list_pop(list);
  return (signed int)(signed long int)return_value_list_pop_1;
}

// list_pop_int_unlocked
// file libslack/list.c line 1918
signed int list_pop_int_unlocked(struct List *list)
{
  void *return_value_list_pop_unlocked_1;
  return_value_list_pop_unlocked_1=list_pop_unlocked(list);
  return (signed int)(signed long int)return_value_list_pop_unlocked_1;
}

// list_pop_unlocked
// file libslack/list.c line 1870
void * list_pop_unlocked(struct List *list)
{
  void *item;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    if(list->length == 0ul)
    {
      return_value_set_errnull_2=set_errnull(22);
      return return_value_set_errnull_2;
    }

    else
    {
      item = list->list[(signed long int)(list->length - (unsigned long int)1)];
      list->list[(signed long int)(list->length - (unsigned long int)1)] = (void *)0;
      struct List *return_value_list_remove_unlocked_3;
      return_value_list_remove_unlocked_3=list_remove_unlocked(list, (signed long int)(list->length - (unsigned long int)1));
      if(return_value_list_remove_unlocked_3 == ((struct List *)NULL))
      {
        list->list[(signed long int)(list->length - (unsigned long int)1)] = item;
        return (void *)0;
      }

      else
        return item;
    }
}

// list_prepend
// file libslack/list.c line 1371
struct List * list_prepend(struct List *list, void *item)
{
  struct List *return_value_list_insert_1;
  return_value_list_insert_1=list_insert(list, (signed long int)0, item);
  return return_value_list_insert_1;
}

// list_prepend_int
// file libslack/list.c line 1401
struct List * list_prepend_int(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_1;
  return_value_list_insert_int_1=list_insert_int(list, (signed long int)0, item);
  return return_value_list_insert_int_1;
}

// list_prepend_int_unlocked
// file libslack/list.c line 1417
struct List * list_prepend_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_insert_int_unlocked_1;
  return_value_list_insert_int_unlocked_1=list_insert_int_unlocked(list, (signed long int)0, item);
  return return_value_list_insert_int_unlocked_1;
}

// list_prepend_list
// file libslack/list.c line 1434
struct List * list_prepend_list(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_1;
  return_value_list_insert_list_1=list_insert_list(list, (signed long int)0, src, copy);
  return return_value_list_insert_list_1;
}

// list_prepend_list_unlocked
// file libslack/list.c line 1450
struct List * list_prepend_list_unlocked(struct List *list, const struct List *src, void * (*copy)(const void *))
{
  struct List *return_value_list_insert_list_unlocked_1;
  return_value_list_insert_list_unlocked_1=list_insert_list_unlocked(list, (signed long int)0, src, copy);
  return return_value_list_insert_list_unlocked_1;
}

// list_prepend_unlocked
// file libslack/list.c line 1386
struct List * list_prepend_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_insert_unlocked_1;
  return_value_list_insert_unlocked_1=list_insert_unlocked(list, (signed long int)0, item);
  return return_value_list_insert_unlocked_1;
}

// list_push
// file libslack/list.c line 1780
struct List * list_push(struct List *list, void *item)
{
  struct List *return_value_list_append_1;
  return_value_list_append_1=list_append(list, item);
  return return_value_list_append_1;
}

// list_push_int
// file libslack/list.c line 1810
struct List * list_push_int(struct List *list, signed int item)
{
  struct List *return_value_list_append_int_1;
  return_value_list_append_int_1=list_append_int(list, item);
  return return_value_list_append_int_1;
}

// list_push_int_unlocked
// file libslack/list.c line 1825
struct List * list_push_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_append_int_unlocked_1;
  return_value_list_append_int_unlocked_1=list_append_int_unlocked(list, item);
  return return_value_list_append_int_unlocked_1;
}

// list_push_unlocked
// file libslack/list.c line 1795
struct List * list_push_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_append_unlocked_1;
  return_value_list_append_unlocked_1=list_append_unlocked(list, item);
  return return_value_list_append_unlocked_1;
}

// list_query
// file libslack/list.c line 2566
signed long int list_query(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data)
{
  signed long int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(query == ((signed int (*)(void *, unsigned long int *, void *))NULL) || index == ((signed long int *)NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      ret=list_query_unlocked(list, index, query, data);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// list_query_unlocked
// file libslack/list.c line 2595
signed long int list_query_unlocked(struct List *list, signed long int *index, signed int (*query)(void *, unsigned long int *, void *), void *data)
{
  unsigned long int i;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(query == ((signed int (*)(void *, unsigned long int *, void *))NULL) || index == ((signed long int *)NULL) || list == ((struct List *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
    if((unsigned long int)*index >= list->length)
    {
      return_value_set_errno_2=set_errno(22);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      i = (unsigned long int)*index;
      if(!(i >= list->length))
      {
        signed int return_value;
        return_value=query(list->list[(signed long int)i], (unsigned long int *)index, data);
        if(!(return_value == 0))
        {
          *index = (signed long int)i;
          return *index;
        }

        i = i + 1ul;
      }

      *index = (signed long int)-1;
      return *index;
    }
}

// list_rdlock
// file libslack/list.c line 548
signed int list_rdlock(const struct List *list)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->rdlock(list->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// list_release
// file libslack/list.c line 602
void list_release(struct List *list)
{
  if(!(list == ((struct List *)NULL)))
  {
    if(!(list->list == ((void **)NULL)))
    {
      killitems(list, (unsigned long int)0, list->length);
      free((void *)list->list);
    }

    free((void *)list);
  }

}

// list_remove
// file libslack/list.c line 993
struct List * list_remove(struct List *list, signed long int index)
{
  struct List *return_value_list_remove_range_1;
  return_value_list_remove_range_1=list_remove_range(list, index, (signed long int)1);
  return return_value_list_remove_range_1;
}

// list_remove_current
// file libslack/list.c line 3010
void list_remove_current(struct List *list)
{
  _Bool tmp_if_expr_1;
  if(list == ((struct List *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(list->lister != ((struct Lister *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    set_errno(22);

  else
    lister_remove(list->lister);
}

// list_remove_range
// file libslack/list.c line 1027
struct List * list_remove_range(struct List *list, signed long int index, signed long int range)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_remove_range_unlocked(list, index, range);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// list_remove_range_unlocked
// file libslack/list.c line 1057
struct List * list_remove_range_unlocked(struct List *list, signed long int index, signed long int range)
{
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct List *)return_value_set_errnull_4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          signed int return_value_contract_5;
          return_value_contract_5=contract(list, index, (unsigned long int)range);
          if(return_value_contract_5 == -1)
            return (struct List *)(void *)0;

          else
            return list;
        }
    }
  }
}

// list_remove_unlocked
// file libslack/list.c line 1008
struct List * list_remove_unlocked(struct List *list, signed long int index)
{
  struct List *return_value_list_remove_range_unlocked_1;
  return_value_list_remove_range_unlocked_1=list_remove_range_unlocked(list, index, (signed long int)1);
  return return_value_list_remove_range_unlocked_1;
}

// list_replace
// file libslack/list.c line 1469
struct List * list_replace(struct List *list, signed long int index, signed long int range, void *item)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_replace_unlocked(list, index, range, item);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// list_replace_int
// file libslack/list.c line 1538
struct List * list_replace_int(struct List *list, signed long int index, signed long int range, signed int item)
{
  struct List *return_value_list_replace_1;
  return_value_list_replace_1=list_replace(list, index, range, (void *)(signed long int)item);
  return return_value_list_replace_1;
}

// list_replace_int_unlocked
// file libslack/list.c line 1553
struct List * list_replace_int_unlocked(struct List *list, signed long int index, signed long int range, signed int item)
{
  struct List *return_value_list_replace_unlocked_1;
  return_value_list_replace_unlocked_1=list_replace_unlocked(list, index, range, (void *)(signed long int)item);
  return return_value_list_replace_unlocked_1;
}

// list_replace_list
// file libslack/list.c line 1573
struct List * list_replace_list(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  signed int return_value_2;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  signed int return_value_3;
  void *return_value_set_errnull_11;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_1=src->locker->rdlock(src->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      ret=list_replace_list_unlocked(list, index, range, src, copy);
      if(!(src == ((const struct List *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_2=src->locker->unlock(src->locker->lock);
          tmp_if_expr_9 = return_value_2;
        }

        else
          tmp_if_expr_9 = 0;
        tmp_if_expr_10 = tmp_if_expr_9;
      }

      else
        tmp_if_expr_10 = 22;
      err = tmp_if_expr_10;
      if(!(err == 0))
      {
        if(!(list == ((struct List *)NULL)))
        {
          if(!(list->locker == ((struct Locker *)NULL)))
            list->locker->unlock(list->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_8;
        return_value_set_errnull_8=set_errnull(err);
        return (struct List *)return_value_set_errnull_8;
      }

      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_3=list->locker->unlock(list->locker->lock);
          tmp_if_expr_12 = return_value_3;
        }

        else
          tmp_if_expr_12 = 0;
        tmp_if_expr_13 = tmp_if_expr_12;
      }

      else
        tmp_if_expr_13 = 22;
      err = tmp_if_expr_13;
      if(!(err == 0))
      {
        return_value_set_errnull_11=set_errnull(err);
        return (struct List *)return_value_set_errnull_11;
      }

      else
        return ret;
    }
  }
}

// list_replace_list_unlocked
// file libslack/list.c line 1617
struct List * list_replace_list_unlocked(struct List *list, signed long int index, signed long int range, const struct List *src, void * (*copy)(const void *))
{
  signed long int length;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  _Bool tmp_if_expr_5;
  void *return_value_set_errnull_4;
  signed long int tmp_post_7;
  void *tmp_if_expr_8;
  void *return_value;
  if(list == ((struct List *)NULL) || src == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
      {
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = ((signed int)!(list->destroy != ((void (*)(void *))NULL)) ^ (signed int)!(copy != ((void * (*)(const void *))NULL))) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct List *)return_value_set_errnull_4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          length = (signed long int)src->length;
          signed int return_value_adjust_6;
          return_value_adjust_6=adjust(list, index, (unsigned long int)range, (unsigned long int)length);
          if(return_value_adjust_6 == -1)
            return (struct List *)(void *)0;

          else
          {
            do
            {
              tmp_post_7 = length;
              length = length - 1l;
              if(tmp_post_7 == 0l)
                break;

              if(!(copy == ((void * (*)(const void *))NULL)))
              {
                return_value=copy(src->list[length]);
                tmp_if_expr_8 = return_value;
              }

              else
                tmp_if_expr_8 = src->list[length];
              list->list[index + length] = tmp_if_expr_8;
            }
            while((_Bool)1);
            return list;
          }
        }
      }
    }
  }
}

// list_replace_unlocked
// file libslack/list.c line 1498
struct List * list_replace_unlocked(struct List *list, signed long int index, signed long int range, void *item)
{
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(list->length + (unsigned long int)1 + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((list->length + (unsigned long int)1 + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct List *)return_value_set_errnull_3;
      }

      else
        if(!(list->length >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct List *)return_value_set_errnull_4;
        }

        else
        {
          killitems(list, (unsigned long int)index, (unsigned long int)range);
          signed int return_value_adjust_5;
          return_value_adjust_5=adjust(list, index, (unsigned long int)range, (unsigned long int)1);
          if(return_value_adjust_5 == -1)
            return (struct List *)(void *)0;

          else
          {
            list->list[index] = item;
            return list;
          }
        }
    }
  }
}

// list_shift
// file libslack/list.c line 1934
void * list_shift(struct List *list)
{
  void *item;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      item=list_shift_unlocked(list);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return return_value_set_errnull_5;
      }

      else
        return item;
    }
  }
}

// list_shift_int
// file libslack/list.c line 1996
signed int list_shift_int(struct List *list)
{
  void *return_value_list_shift_1;
  return_value_list_shift_1=list_shift(list);
  return (signed int)(signed long int)return_value_list_shift_1;
}

// list_shift_int_unlocked
// file libslack/list.c line 2011
signed int list_shift_int_unlocked(struct List *list)
{
  void *return_value_list_shift_unlocked_1;
  return_value_list_shift_unlocked_1=list_shift_unlocked(list);
  return (signed int)(signed long int)return_value_list_shift_unlocked_1;
}

// list_shift_unlocked
// file libslack/list.c line 1963
void * list_shift_unlocked(struct List *list)
{
  void *item;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    if(list->length == 0ul)
    {
      return_value_set_errnull_2=set_errnull(22);
      return return_value_set_errnull_2;
    }

    else
    {
      item = list->list[(signed long int)0];
      list->list[(signed long int)0] = (void *)0;
      struct List *return_value_list_remove_unlocked_3;
      return_value_list_remove_unlocked_3=list_remove_unlocked(list, (signed long int)0);
      if(return_value_list_remove_unlocked_3 == ((struct List *)NULL))
      {
        list->list[(signed long int)0] = item;
        return (void *)0;
      }

      else
        return item;
    }
}

// list_sort
// file libslack/slack/list.h line 123
struct List * list_sort(struct List *list, signed int (*cmp)(const void *, const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_sort_unlocked(list, cmp);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// list_sort_unlocked
// file libslack/list.c line 2220
struct List * list_sort_unlocked(struct List *list, signed int (*cmp)(const void *, const void *))
{
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_3;
  void *return_value_set_errnull_2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(list->list == ((void **)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(list->length != 0ul) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      (list->length >= (unsigned long int)10000 ? hsort : qsort)((void *)list->list, list->length, sizeof(void *) /*8ul*/ , cmp);
      return list;
    }
  }
}

// list_splice
// file libslack/list.c line 2095
struct List * list_splice(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_splice_with_locker_1;
  return_value_list_splice_with_locker_1=list_splice_with_locker((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_splice_with_locker_1;
}

// list_splice_unlocked
// file libslack/list.c line 2110
struct List * list_splice_unlocked(struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *return_value_list_splice_with_locker_unlocked_1;
  return_value_list_splice_with_locker_unlocked_1=list_splice_with_locker_unlocked((struct Locker *)(void *)0, list, index, range, copy);
  return return_value_list_splice_with_locker_unlocked_1;
}

// list_splice_with_locker
// file libslack/list.c line 2126
struct List * list_splice_with_locker(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_splice_with_locker_unlocked(locker, list, index, range, copy);
      if(!(list == ((struct List *)NULL)))
      {
        if(!(list->locker == ((struct Locker *)NULL)))
        {
          return_value_1=list->locker->unlock(list->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// list_splice_with_locker_unlocked
// file libslack/list.c line 2159
struct List * list_splice_with_locker_unlocked(struct Locker *locker, struct List *list, signed long int index, signed long int range, void * (*copy)(const void *))
{
  struct List *ret;
  void *return_value_set_errnull_1;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    ret=list_extract_with_locker_unlocked(locker, list, index, range, copy);
    if(ret == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      struct List *return_value_list_remove_range_unlocked_2;
      return_value_list_remove_range_unlocked_2=list_remove_range_unlocked(list, index, range);
      if(return_value_list_remove_range_unlocked_2 == ((struct List *)NULL))
      {
        list_release(ret);
        return (struct List *)(void *)0;
      }

      else
        return ret;
    }
  }
}

// list_unlock
// file libslack/list.c line 586
signed int list_unlock(const struct List *list)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->unlock(list->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// list_unshift
// file libslack/list.c line 2027
struct List * list_unshift(struct List *list, void *item)
{
  struct List *return_value_list_prepend_1;
  return_value_list_prepend_1=list_prepend(list, item);
  return return_value_list_prepend_1;
}

// list_unshift_int
// file libslack/list.c line 2057
struct List * list_unshift_int(struct List *list, signed int item)
{
  struct List *return_value_list_prepend_int_1;
  return_value_list_prepend_int_1=list_prepend_int(list, item);
  return return_value_list_prepend_int_1;
}

// list_unshift_int_unlocked
// file libslack/list.c line 2073
struct List * list_unshift_int_unlocked(struct List *list, signed int item)
{
  struct List *return_value_list_prepend_int_unlocked_1;
  return_value_list_prepend_int_unlocked_1=list_prepend_int_unlocked(list, item);
  return return_value_list_prepend_int_unlocked_1;
}

// list_unshift_unlocked
// file libslack/list.c line 2042
struct List * list_unshift_unlocked(struct List *list, void *item)
{
  struct List *return_value_list_prepend_unlocked_1;
  return_value_list_prepend_unlocked_1=list_prepend_unlocked(list, item);
  return return_value_list_prepend_unlocked_1;
}

// list_vmake
// file libslack/list.c line 400
struct List * list_vmake(void (*destroy)(void *), void **args)
{
  struct List *return_value_list_vmake_with_locker_1;
  return_value_list_vmake_with_locker_1=list_vmake_with_locker((struct Locker *)(void *)0, destroy, args);
  return return_value_list_vmake_with_locker_1;
}

// list_vmake_with_locker
// file libslack/list.c line 482
struct List * list_vmake_with_locker(struct Locker *locker, void (*destroy)(void *), __builtin_va_list args)
{
  struct List *list;
  void *item;
  list=list_create_with_locker(locker, destroy);
  if(list == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    do
    {
      item=va_arg(args, __typeof__(item));
      if(item == NULL)
        break;

      struct List *return_value_list_append_1;
      return_value_list_append_1=list_append(list, item);
      if(return_value_list_append_1 == ((struct List *)NULL))
      {
        list_release(list);
        return (struct List *)(void *)0;
      }

    }
    while((_Bool)1);
    return list;
  }
}

// list_wrlock
// file libslack/list.c line 569
signed int list_wrlock(const struct List *list)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(list == ((const struct List *)NULL)))
  {
    if(!(list->locker == ((struct Locker *)NULL)))
    {
      return_value=list->locker->wrlock(list->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// lister_create
// file libslack/list.c line 2629
struct Lister * lister_create(struct List *list)
{
  struct Lister *return_value_lister_create_wrlocked_1;
  return_value_lister_create_wrlocked_1=lister_create_wrlocked(list);
  return return_value_lister_create_wrlocked_1;
}

// lister_create_rdlocked
// file libslack/list.c line 2646
struct Lister * lister_create_rdlocked(struct List *list)
{
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->rdlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Lister *)return_value_set_errnull_2;
    }

    else
    {
      struct Lister *return_value_lister_create_unlocked_5;
      return_value_lister_create_unlocked_5=lister_create_unlocked(list);
      return return_value_lister_create_unlocked_5;
    }
  }
}

// lister_create_unlocked
// file libslack/list.c line 2693
struct Lister * lister_create_unlocked(const struct List *list)
{
  struct Lister *lister;
  void *return_value_set_errnull_1;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull_1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct Lister) /*16ul*/ );
    lister = (struct Lister *)return_value_malloc_2;
    if(lister == ((struct Lister *)NULL))
      return (struct Lister *)(void *)0;

    else
    {
      lister->list = (struct List *)list;
      lister->index = (signed long int)-1;
      return lister;
    }
  }
}

// lister_create_wrlocked
// file libslack/list.c line 2670
struct Lister * lister_create_wrlocked(struct List *list)
{
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  if(list == ((struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Lister *)return_value_set_errnull_1;
  }

  else
  {
    if(!(list == ((struct List *)NULL)))
    {
      if(!(list->locker == ((struct Locker *)NULL)))
      {
        return_value=list->locker->wrlock(list->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Lister *)return_value_set_errnull_2;
    }

    else
    {
      struct Lister *return_value_lister_create_unlocked_5;
      return_value_lister_create_unlocked_5=lister_create_unlocked(list);
      return return_value_lister_create_unlocked_5;
    }
  }
}

// lister_destroy
// file libslack/list.c line 2765
void * lister_destroy(struct Lister **lister)
{
  if(!(lister == ((struct Lister **)NULL)))
  {
    if(!(*lister == ((struct Lister *)NULL)))
    {
      lister_release(*lister);
      *lister = (struct Lister *)(void *)0;
    }

  }

  return (void *)0;
}

// lister_destroy_unlocked
// file libslack/list.c line 2787
void * lister_destroy_unlocked(struct Lister **lister)
{
  if(!(lister == ((struct Lister **)NULL)))
  {
    if(!(*lister == ((struct Lister *)NULL)))
    {
      lister_release_unlocked(*lister);
      *lister = (struct Lister *)(void *)0;
    }

  }

  return (void *)0;
}

// lister_has_next
// file libslack/list.c line 2810
signed int lister_has_next(struct Lister *lister)
{
  signed int return_value_set_errno_1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)((unsigned long int)(lister->index + (signed long int)1) < lister->list->length);
}

// lister_next
// file libslack/list.c line 2829
void * lister_next(struct Lister *lister)
{
  void *return_value_set_errnull_1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    lister->index = lister->index + 1l;
    void *return_value_list_item_unlocked_2;
    return_value_list_item_unlocked_2=list_item_unlocked(lister->list, (signed long int)(unsigned long int)lister->index);
    return return_value_list_item_unlocked_2;
  }
}

// lister_next_int
// file libslack/list.c line 2847
signed int lister_next_int(struct Lister *lister)
{
  signed int return_value_set_errno_1;
  if(lister == ((struct Lister *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    lister->index = lister->index + 1l;
    signed int return_value_list_item_int_unlocked_2;
    return_value_list_item_int_unlocked_2=list_item_int_unlocked(lister->list, (signed long int)(unsigned long int)lister->index);
    return return_value_list_item_int_unlocked_2;
  }
}

// lister_release
// file libslack/list.c line 2719
void lister_release(struct Lister *lister)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(lister == ((struct Lister *)NULL)))
  {
    if(!(lister->list == ((struct List *)NULL)))
    {
      if(!(lister->list->locker == ((struct Locker *)NULL)))
      {
        return_value=lister->list->locker->unlock(lister->list->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
      free((void *)lister);
  }

}

// lister_release_unlocked
// file libslack/list.c line 2746
void lister_release_unlocked(struct Lister *lister)
{
  if(!(lister == ((struct Lister *)NULL)))
    free((void *)lister);

}

// lister_remove
// file libslack/list.c line 2868
void lister_remove(struct Lister *lister)
{
  signed long int tmp_post_1;
  if(lister == ((struct Lister *)NULL))
    set_errno(22);

  else
    if(lister->index == -1l)
      set_errno(22);

    else
    {
      tmp_post_1 = lister->index;
      lister->index = lister->index - 1l;
      list_remove_unlocked(lister->list, (signed long int)(unsigned long int)tmp_post_1);
    }
}

// locker_create
// file libslack/locker.c line 359
struct Locker * locker_create(void *lock, signed int (*tryrdlock)(void *), signed int (*rdlock)(void *), signed int (*trywrlock)(void *), signed int (*wrlock)(void *), signed int (*unlock)(void *))
{
  struct Locker *locker_create__1__locker;
  void *return_value_set_errnull_1;
  if(rdlock == ((signed int (*)(void *))NULL) || tryrdlock == ((signed int (*)(void *))NULL) || trywrlock == ((signed int (*)(void *))NULL) || unlock == ((signed int (*)(void *))NULL) || wrlock == ((signed int (*)(void *))NULL) || lock == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Locker *)return_value_set_errnull_1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct Locker) /*48ul*/ );
    locker_create__1__locker = (struct Locker *)return_value_malloc_2;
    if(locker_create__1__locker == ((struct Locker *)NULL))
      return (struct Locker *)(void *)0;

    else
    {
      locker_create__1__locker->lock = lock;
      locker_create__1__locker->tryrdlock = tryrdlock;
      locker_create__1__locker->rdlock = rdlock;
      locker_create__1__locker->trywrlock = trywrlock;
      locker_create__1__locker->wrlock = wrlock;
      locker_create__1__locker->unlock = unlock;
      return locker_create__1__locker;
    }
  }
}

// locker_create_debug_mutex
// file libslack/slack/locker.h line 66
struct Locker * locker_create_debug_mutex(union anonymous_11 *mutex)
{
  struct Locker *return_value_locker_create_1;
  return_value_locker_create_1=locker_create((void *)mutex, (signed int (*)(void *))debug_pthread_mutex_trylock, (signed int (*)(void *))debug_pthread_mutex_lock, (signed int (*)(void *))debug_pthread_mutex_trylock, (signed int (*)(void *))debug_pthread_mutex_lock, (signed int (*)(void *))debug_pthread_mutex_unlock);
  return return_value_locker_create_1;
}

// locker_create_debug_rwlock
// file libslack/slack/locker.h line 67
struct Locker * locker_create_debug_rwlock(union anonymous_12 *rwlock)
{
  struct Locker *return_value_locker_create_1;
  return_value_locker_create_1=locker_create((void *)rwlock, (signed int (*)(void *))debug_pthread_rwlock_tryrdlock, (signed int (*)(void *))debug_pthread_rwlock_rdlock, (signed int (*)(void *))debug_pthread_rwlock_trywrlock, (signed int (*)(void *))debug_pthread_rwlock_wrlock, (signed int (*)(void *))debug_pthread_rwlock_unlock);
  return return_value_locker_create_1;
}

// locker_create_mutex
// file libslack/slack/locker.h line 64
struct Locker * locker_create_mutex(union anonymous_11 *mutex)
{
  struct Locker *return_value_locker_create_1;
  return_value_locker_create_1=locker_create((void *)mutex, (signed int (*)(void *))pthread_mutex_trylock, (signed int (*)(void *))pthread_mutex_lock, (signed int (*)(void *))pthread_mutex_trylock, (signed int (*)(void *))pthread_mutex_lock, (signed int (*)(void *))pthread_mutex_unlock);
  return return_value_locker_create_1;
}

// locker_create_rwlock
// file libslack/slack/locker.h line 65
struct Locker * locker_create_rwlock(union anonymous_12 *rwlock)
{
  struct Locker *return_value_locker_create_1;
  return_value_locker_create_1=locker_create((void *)rwlock, (signed int (*)(void *))pthread_rwlock_tryrdlock, (signed int (*)(void *))pthread_rwlock_rdlock, (signed int (*)(void *))pthread_rwlock_trywrlock, (signed int (*)(void *))pthread_rwlock_wrlock, (signed int (*)(void *))pthread_rwlock_unlock);
  return return_value_locker_create_1;
}

// locker_destroy
// file libslack/slack/locker.h line 70
void * locker_destroy(struct Locker **locker)
{
  if(!(locker == ((struct Locker **)NULL)))
  {
    if(!(*locker == ((struct Locker *)NULL)))
    {
      locker_release(*locker);
      *locker = (struct Locker *)(void *)0;
    }

  }

  return (void *)0;
}

// locker_rdlock
// file libslack/locker.c line 453
signed int locker_rdlock(struct Locker *locker)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->rdlock(locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// locker_release
// file libslack/locker.c line 390
void locker_release(struct Locker *locker)
{
  if(!(locker == ((struct Locker *)NULL)))
    free((void *)locker);

}

// locker_tryrdlock
// file libslack/locker.c line 435
signed int locker_tryrdlock(struct Locker *locker)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->tryrdlock(locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// locker_trywrlock
// file libslack/locker.c line 472
signed int locker_trywrlock(struct Locker *locker)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->trywrlock(locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// locker_unlock
// file libslack/locker.c line 508
signed int locker_unlock(struct Locker *locker)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->unlock(locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// locker_wrlock
// file libslack/locker.c line 490
signed int locker_wrlock(struct Locker *locker)
{
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(locker == ((struct Locker *)NULL)))
  {
    return_value=locker->wrlock(locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 459
static inline signed int lstat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___lxstat_1;
  return_value___lxstat_1=__lxstat(1, __path, __statbuf);
  return return_value___lxstat_1;
}

// mail
// file libslack/net.c line 4142
signed int mail(const char *server, const char *sender, const char *recipients, const char *subject, const char *message)
{
  signed int smtp;
  signed int code;
  signed int rc;
  char c;
  signed int return_value_set_errno_1;
  signed long int return_value_net_expect_4;
  if(recipients == ((const char *)NULL) || sender == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    smtp=net_client(server, "smtp", (unsigned short int)25, (signed long int)5, 0, 0, (struct sockaddr *)(void *)0, (unsigned long int *)(void *)0);
    if(smtp == -1)
      return -1;

    else
    {
      net_tos_lowdelay(smtp);
      signed long int return_value_net_expect_2;
      return_value_net_expect_2=net_expect(smtp, (signed long int)10, "%d%c", &code, &c);
      rc = (signed int)return_value_net_expect_2;
      if(rc == -1)
      {
        close(smtp);
        return -1;
      }

      else
      {
        if(!(code == 220) || !(rc == 2))
        {
          close(smtp);
          signed int return_value_set_errno_3;
          return_value_set_errno_3=set_errno(71);
          return return_value_set_errno_3;
        }

        while((signed int)c == 45)
        {
          return_value_net_expect_4=net_expect(smtp, (signed long int)10, "%d%c", &code, &c);
          rc = (signed int)return_value_net_expect_4;
          if(rc == -1)
          {
            close(smtp);
            return -1;
          }

        }
        if(!(code == 220) || !(rc == 2))
        {
          close(smtp);
          signed int return_value_set_errno_5;
          return_value_set_errno_5=set_errno(71);
          return return_value_set_errno_5;
        }

        signed long int return_value_net_send_6;
        return_value_net_send_6=net_send(smtp, (signed long int)10, "HELO localhost\r\n");
        if(return_value_net_send_6 == -1l)
        {
          close(smtp);
          return -1;
        }

        else
        {
          signed long int return_value_net_expect_7;
          return_value_net_expect_7=net_expect(smtp, (signed long int)10, "%d", &code);
          rc = (signed int)return_value_net_expect_7;
          if(rc == -1)
          {
            close(smtp);
            return -1;
          }

          else
          {
            if(!(code == 250) || !(rc == 1))
            {
              close(smtp);
              signed int return_value_set_errno_8;
              return_value_set_errno_8=set_errno(71);
              return return_value_set_errno_8;
            }

            signed long int return_value_net_send_9;
            return_value_net_send_9=net_send(smtp, (signed long int)10, "MAIL FROM: <%s>\r\n", sender);
            if(return_value_net_send_9 == -1l)
            {
              close(smtp);
              return -1;
            }

            else
            {
              signed long int return_value_net_expect_10;
              return_value_net_expect_10=net_expect(smtp, (signed long int)10, "%d", &code);
              rc = (signed int)return_value_net_expect_10;
              if(rc == -1)
              {
                close(smtp);
                return -1;
              }

              else
              {
                if(!(code == 250) || !(rc == 1))
                {
                  close(smtp);
                  signed int return_value_set_errno_11;
                  return_value_set_errno_11=set_errno(71);
                  return return_value_set_errno_11;
                }

                signed int return_value_rcpt_12;
                return_value_rcpt_12=rcpt(smtp, recipients);
                if(return_value_rcpt_12 == -1)
                {
                  close(smtp);
                  return -1;
                }

                else
                {
                  signed long int return_value_net_send_13;
                  return_value_net_send_13=net_send(smtp, (signed long int)10, "DATA\r\n");
                  if(return_value_net_send_13 == -1l)
                  {
                    close(smtp);
                    return -1;
                  }

                  else
                  {
                    signed long int return_value_net_expect_14;
                    return_value_net_expect_14=net_expect(smtp, (signed long int)10, "%d", &code);
                    rc = (signed int)return_value_net_expect_14;
                    if(rc == -1)
                    {
                      close(smtp);
                      return -1;
                    }

                    else
                    {
                      if(!(code == 354) || !(rc == 1))
                      {
                        close(smtp);
                        signed int return_value_set_errno_15;
                        return_value_set_errno_15=set_errno(71);
                        return return_value_set_errno_15;
                      }

                      net_tos_throughput(smtp);
                      signed long int return_value_net_send_16;
                      return_value_net_send_16=net_send(smtp, (signed long int)10, "From: %s\r\n", sender);
                      if(return_value_net_send_16 == -1l)
                      {
                        close(smtp);
                        return -1;
                      }

                      else
                      {
                        signed long int return_value_net_send_17;
                        return_value_net_send_17=net_send(smtp, (signed long int)10, "To: %s\r\n", recipients);
                        if(return_value_net_send_17 == -1l)
                        {
                          close(smtp);
                          return -1;
                        }

                        else
                        {
                          signed long int return_value_net_send_18;
                          return_value_net_send_18=net_send(smtp, (signed long int)10, "Subject: %s\r\n\r\n", subject != ((const char *)NULL) ? subject : "");
                          if(return_value_net_send_18 == -1l)
                          {
                            close(smtp);
                            return -1;
                          }

                          else
                          {
                            signed long int return_value_net_send_19;
                            return_value_net_send_19=net_send(smtp, (signed long int)10, "%s\r\n.\r\n", message != ((const char *)NULL) ? message : "");
                            if(return_value_net_send_19 == -1l)
                            {
                              close(smtp);
                              return -1;
                            }

                            else
                            {
                              signed long int return_value_net_expect_20;
                              return_value_net_expect_20=net_expect(smtp, (signed long int)10, "%d", &code);
                              rc = (signed int)return_value_net_expect_20;
                              if(rc == -1)
                              {
                                close(smtp);
                                return -1;
                              }

                              else
                              {
                                if(!(code == 250) || !(rc == 1))
                                {
                                  close(smtp);
                                  signed int return_value_set_errno_21;
                                  return_value_set_errno_21=set_errno(71);
                                  return return_value_set_errno_21;
                                }

                                net_tos_lowdelay(smtp);
                                signed long int return_value_net_send_22;
                                return_value_net_send_22=net_send(smtp, (signed long int)10, "QUIT\r\n");
                                if(return_value_net_send_22 == -1l)
                                {
                                  close(smtp);
                                  return -1;
                                }

                                else
                                {
                                  signed long int return_value_net_expect_23;
                                  return_value_net_expect_23=net_expect(smtp, (signed long int)10, "%d", &code);
                                  rc = (signed int)return_value_net_expect_23;
                                  if(rc == -1)
                                  {
                                    close(smtp);
                                    return -1;
                                  }

                                  else
                                  {
                                    if(!(code == 221) || !(rc == 1))
                                    {
                                      close(smtp);
                                      signed int return_value_set_errno_24;
                                      return_value_set_errno_24=set_errno(71);
                                      return return_value_set_errno_24;
                                    }

                                    close(smtp);
                                    return 0;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// main
// file libslack/map.c line 2765
signed int main(signed int ac, char **av)
{
  struct Map *map;
  struct Mapper *mapper;
  struct List *keys;
  struct List *values;
  const void *ckey;
  const char *cvalue;
  char *value;
  char cat[8192l];
  void *ptr;
  signed int val;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  _Bool tmp_if_expr_15;
  signed int return_value_strcmp_14;
  _Bool tmp_if_expr_18;
  signed int return_value_strcmp_17;
  signed int return_value_mapper_has_next_20;
  struct List *return_value_list_append_21;
  signed long int return_value_list_length_22;
  _Bool tmp_if_expr_28;
  void *return_value_list_item_26;
  signed int return_value_strcmp_27;
  void *return_value_list_item_24;
  _Bool tmp_if_expr_33;
  void *return_value_list_item_31;
  signed int return_value_strcmp_32;
  void *return_value_list_item_29;
  _Bool tmp_if_expr_38;
  void *return_value_list_item_36;
  signed int return_value_strcmp_37;
  void *return_value_list_item_34;
  _Bool tmp_if_expr_43;
  void *return_value_list_item_41;
  signed int return_value_strcmp_42;
  void *return_value_list_item_39;
  signed int return_value_mapper_has_next_45;
  struct List *return_value_list_append_46;
  struct List *return_value_list_append_47;
  signed long int return_value_list_length_49;
  _Bool tmp_if_expr_55;
  void *return_value_list_item_53;
  signed int return_value_strcmp_54;
  void *return_value_list_item_51;
  _Bool tmp_if_expr_60;
  void *return_value_list_item_58;
  signed int return_value_strcmp_59;
  void *return_value_list_item_56;
  _Bool tmp_if_expr_65;
  void *return_value_list_item_63;
  signed int return_value_strcmp_64;
  void *return_value_list_item_61;
  _Bool tmp_if_expr_70;
  void *return_value_list_item_68;
  signed int return_value_strcmp_69;
  void *return_value_list_item_66;
  signed long int return_value_list_length_72;
  _Bool tmp_if_expr_78;
  void *return_value_list_item_76;
  signed int return_value_strcmp_77;
  void *return_value_list_item_74;
  _Bool tmp_if_expr_83;
  void *return_value_list_item_81;
  signed int return_value_strcmp_82;
  void *return_value_list_item_79;
  _Bool tmp_if_expr_88;
  void *return_value_list_item_86;
  signed int return_value_strcmp_87;
  void *return_value_list_item_84;
  _Bool tmp_if_expr_93;
  void *return_value_list_item_91;
  signed int return_value_strcmp_92;
  void *return_value_list_item_89;
  signed int return_value_map_has_next_95;
  struct List *return_value_list_append_96;
  signed long int return_value_list_length_97;
  _Bool tmp_if_expr_103;
  void *return_value_list_item_101;
  signed int return_value_strcmp_102;
  void *return_value_list_item_99;
  _Bool tmp_if_expr_108;
  void *return_value_list_item_106;
  signed int return_value_strcmp_107;
  void *return_value_list_item_104;
  _Bool tmp_if_expr_113;
  void *return_value_list_item_111;
  signed int return_value_strcmp_112;
  void *return_value_list_item_109;
  _Bool tmp_if_expr_118;
  void *return_value_list_item_116;
  signed int return_value_strcmp_117;
  void *return_value_list_item_114;
  signed int return_value_map_has_next_120;
  struct List *return_value_list_append_121;
  struct List *return_value_list_append_122;
  signed long int return_value_list_length_124;
  _Bool tmp_if_expr_130;
  void *return_value_list_item_128;
  signed int return_value_strcmp_129;
  void *return_value_list_item_126;
  _Bool tmp_if_expr_135;
  void *return_value_list_item_133;
  signed int return_value_strcmp_134;
  void *return_value_list_item_131;
  _Bool tmp_if_expr_140;
  void *return_value_list_item_138;
  signed int return_value_strcmp_139;
  void *return_value_list_item_136;
  _Bool tmp_if_expr_145;
  void *return_value_list_item_143;
  signed int return_value_strcmp_144;
  void *return_value_list_item_141;
  signed long int return_value_list_length_147;
  _Bool tmp_if_expr_153;
  void *return_value_list_item_151;
  signed int return_value_strcmp_152;
  void *return_value_list_item_149;
  _Bool tmp_if_expr_158;
  void *return_value_list_item_156;
  signed int return_value_strcmp_157;
  void *return_value_list_item_154;
  _Bool tmp_if_expr_163;
  void *return_value_list_item_161;
  signed int return_value_strcmp_162;
  void *return_value_list_item_159;
  _Bool tmp_if_expr_168;
  void *return_value_list_item_166;
  signed int return_value_strcmp_167;
  void *return_value_list_item_164;
  signed long int return_value_list_length_170;
  _Bool tmp_if_expr_176;
  void *return_value_list_item_174;
  signed int return_value_strcmp_175;
  void *return_value_list_item_172;
  _Bool tmp_if_expr_181;
  void *return_value_list_item_179;
  signed int return_value_strcmp_180;
  void *return_value_list_item_177;
  _Bool tmp_if_expr_186;
  void *return_value_list_item_184;
  signed int return_value_strcmp_185;
  void *return_value_list_item_182;
  _Bool tmp_if_expr_191;
  void *return_value_list_item_189;
  signed int return_value_strcmp_190;
  void *return_value_list_item_187;
  signed long int return_value_list_length_193;
  _Bool tmp_if_expr_199;
  void *return_value_list_item_197;
  signed int return_value_strcmp_198;
  void *return_value_list_item_195;
  _Bool tmp_if_expr_204;
  void *return_value_list_item_202;
  signed int return_value_strcmp_203;
  void *return_value_list_item_200;
  _Bool tmp_if_expr_209;
  void *return_value_list_item_207;
  signed int return_value_strcmp_208;
  void *return_value_list_item_205;
  _Bool tmp_if_expr_214;
  void *return_value_list_item_212;
  signed int return_value_strcmp_213;
  void *return_value_list_item_210;
  _Bool tmp_if_expr_230;
  signed int return_value_strcmp_229;
  _Bool tmp_if_expr_233;
  signed int return_value_strcmp_232;
  _Bool tmp_if_expr_236;
  signed int return_value_strcmp_235;
  _Bool tmp_if_expr_239;
  signed int return_value_strcmp_238;
  _Bool tmp_if_expr_242;
  signed int return_value_strcmp_241;
  _Bool tmp_if_expr_245;
  signed int return_value_strcmp_244;
  _Bool tmp_if_expr_248;
  signed int return_value_strcmp_247;
  signed int return_value_mapper_has_next_257;
  signed int return_value_map_has_next_263;
  signed int return_value_strcmp_280;
  signed int return_value_strcmp_282;
  signed int return_value_strcmp_284;
  signed int return_value_strcmp_286;
  signed int return_value_strcmp_288;
  signed int return_value_strcmp_290;
  signed int return_value_strcmp_292;
  signed int return_value_strcmp_294;
  signed int return_value_strcmp_296;
  signed int return_value_strcmp_298;
  signed int return_value_strcmp_300;
  signed int return_value_strcmp_302;
  signed int return_value_strcmp_304;
  _Bool tmp_if_expr_359;
  signed int return_value_strcmp_358;
  if(ac == 2)
  {
    return_value_strcmp_1=strcmp(av[(signed long int)1], "help");
    if(!(return_value_strcmp_1 == 0))
      goto __CPROVER_DUMP_L1;

    printf("usage: %s [debug|hash]\n", *av);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(ac == 2)
    {
      return_value_strcmp_2=strcmp(av[(signed long int)1], "hash");
      if(return_value_strcmp_2 == 0)
        test_hash();

    }

    printf("Testing: %s\n", (const void *)"map");
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 1, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add_3;
      return_value_map_add_3=map_add(map, (const void *)"abc", (void *)"abc");
      if(return_value_map_add_3 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 2, (const void *)"map_add(map, \"abc\", \"abc\")");
      }

      signed int return_value_map_add_4;
      return_value_map_add_4=map_add(map, (const void *)"def", (void *)"def");
      if(return_value_map_add_4 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 3, (const void *)"map_add(map, \"def\", \"def\")");
      }

      signed int return_value_map_add_5;
      return_value_map_add_5=map_add(map, (const void *)"ghi", (void *)"ghi");
      if(return_value_map_add_5 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 4, (const void *)"map_add(map, \"ghi\", \"ghi\")");
      }

      signed int return_value_map_add_6;
      return_value_map_add_6=map_add(map, (const void *)"jkl", (void *)"jkl");
      if(return_value_map_add_6 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 5, (const void *)"map_add(map, \"jkl\", \"jkl\")");
      }

      void *return_value_map_get_7;
      return_value_map_get_7=map_get(map, (const void *)"abc");
      value = (char *)return_value_map_get_7;
      if(value == ((char *)NULL))
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_strcmp_8=strcmp(value, "abc");
        tmp_if_expr_9 = return_value_strcmp_8 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 6, (const void *)"map_get(map, \"abc\")", (const void *)"abc", value, (const void *)"abc");
      }

      void *return_value_map_get_10;
      return_value_map_get_10=map_get(map, (const void *)"def");
      value = (char *)return_value_map_get_10;
      if(value == ((char *)NULL))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strcmp_11=strcmp(value, "def");
        tmp_if_expr_12 = return_value_strcmp_11 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 7, (const void *)"map_get(map, \"def\")", (const void *)"def", value, (const void *)"def");
      }

      void *return_value_map_get_13;
      return_value_map_get_13=map_get(map, (const void *)"ghi");
      value = (char *)return_value_map_get_13;
      if(value == ((char *)NULL))
        tmp_if_expr_15 = (_Bool)1;

      else
      {
        return_value_strcmp_14=strcmp(value, "ghi");
        tmp_if_expr_15 = return_value_strcmp_14 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_15)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 8, (const void *)"map_get(map, \"ghi\")", (const void *)"ghi", value, (const void *)"ghi");
      }

      void *return_value_map_get_16;
      return_value_map_get_16=map_get(map, (const void *)"jkl");
      value = (char *)return_value_map_get_16;
      if(value == ((char *)NULL))
        tmp_if_expr_18 = (_Bool)1;

      else
      {
        return_value_strcmp_17=strcmp(value, "jkl");
        tmp_if_expr_18 = return_value_strcmp_17 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_18)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 9, (const void *)"map_get(map, \"jkl\")", (const void *)"jkl", value, (const void *)"jkl");
      }

      void *return_value_map_get_19;
      return_value_map_get_19=map_get(map, (const void *)"zzz");
      value = (char *)return_value_map_get_19;
      if(!(value == ((char *)NULL)))
      {
        errors = errors + 1;
        printf("Test10: map_get(\"zzz\") failed\n");
      }

      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 11, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        keys=list_create((void (*)(void *))(void *)0);
        if(keys == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 12, (const void *)"keys = list_create(NULL)");
        }

        do
        {
          return_value_mapper_has_next_20=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next_20 == 1))
            break;

          void *item;
          item=mapper_next(mapper);
          if(item == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 13, (const void *)"item");
          }

          else
          {
            return_value_list_append_21=list_append(keys, item);
            if(return_value_list_append_21 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 13, (const void *)"list_append(keys, item)");
            }

          }
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test14: mapper_destroy(&mapper) failed (%p, not NULL)", (void *)mapper);
        }

        signed long int return_value_list_length_44;
        return_value_list_length_44=list_length(keys);
        if(!(return_value_list_length_44 == 4l))
        {
          errors = errors + 1;
          return_value_list_length_22=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 15, (const void *)"mapper_has_next/mapper_next", (signed int)return_value_list_length_22);
        }

        else
        {
          struct List *return_value_list_sort_23;
          return_value_list_sort_23=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort_23 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 15, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item_25;
          return_value_list_item_25=list_item(keys, (signed long int)0);
          if(return_value_list_item_25 == NULL)
            tmp_if_expr_28 = (_Bool)1;

          else
          {
            return_value_list_item_26=list_item(keys, (signed long int)0);
            return_value_strcmp_27=strcmp((const char *)return_value_list_item_26, "abc");
            tmp_if_expr_28 = return_value_strcmp_27 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_28)
          {
            errors = errors + 1;
            return_value_list_item_24=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item_24, (const void *)"abc");
          }

          void *return_value_list_item_30;
          return_value_list_item_30=list_item(keys, (signed long int)1);
          if(return_value_list_item_30 == NULL)
            tmp_if_expr_33 = (_Bool)1;

          else
          {
            return_value_list_item_31=list_item(keys, (signed long int)1);
            return_value_strcmp_32=strcmp((const char *)return_value_list_item_31, "def");
            tmp_if_expr_33 = return_value_strcmp_32 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_33)
          {
            errors = errors + 1;
            return_value_list_item_29=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item_29, (const void *)"def");
          }

          void *return_value_list_item_35;
          return_value_list_item_35=list_item(keys, (signed long int)2);
          if(return_value_list_item_35 == NULL)
            tmp_if_expr_38 = (_Bool)1;

          else
          {
            return_value_list_item_36=list_item(keys, (signed long int)2);
            return_value_strcmp_37=strcmp((const char *)return_value_list_item_36, "ghi");
            tmp_if_expr_38 = return_value_strcmp_37 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_38)
          {
            errors = errors + 1;
            return_value_list_item_34=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item_34, (const void *)"ghi");
          }

          void *return_value_list_item_40;
          return_value_list_item_40=list_item(keys, (signed long int)3);
          if(return_value_list_item_40 == NULL)
            tmp_if_expr_43 = (_Bool)1;

          else
          {
            return_value_list_item_41=list_item(keys, (signed long int)3);
            return_value_strcmp_42=strcmp((const char *)return_value_list_item_41, "jkl");
            tmp_if_expr_43 = return_value_strcmp_42 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_43)
          {
            errors = errors + 1;
            return_value_list_item_39=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 15, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item_39, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
      }
      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 16, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        keys=list_create((void (*)(void *))(void *)0);
        if(keys == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 16, (const void *)"keys = list_create(NULL)");
        }

        values=list_create((void (*)(void *))(void *)0);
        if(values == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 16, (const void *)"values = list_create(NULL)");
        }

        do
        {
          return_value_mapper_has_next_45=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next_45 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          if(mapping == ((const struct Mapping *)NULL))
          {
            errors = errors + 1;
            printf("Test17: mapper_next_mapping() failed\n");
          }

          else
          {
            ckey=mapping_key((const struct Mapping *)(void *)mapping);
            if(ckey == NULL)
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 17, (const void *)"ckey = mapping_key((void *)mapping)");
            }

            else
            {
              return_value_list_append_46=list_append(keys, (void *)ckey);
              if(return_value_list_append_46 == ((struct List *)NULL))
              {
                errors = errors + 1;
                printf("Test%d: %s failed\n", 17, (const void *)"list_append(keys, (void *)ckey)");
              }

            }
            const void *return_value_mapping_value_48;
            return_value_mapping_value_48=mapping_value(mapping);
            cvalue = (const char *)return_value_mapping_value_48;
            if(cvalue == ((const char *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 17, (const void *)"cvalue = mapping_value(mapping)");
            }

            else
            {
              return_value_list_append_47=list_append(values, (void *)cvalue);
              if(return_value_list_append_47 == ((struct List *)NULL))
              {
                errors = errors + 1;
                printf("Test%d: %s failed\n", 17, (const void *)"list_append(values, (void *)cvalue)");
              }

            }
          }
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test18: mapper_destroy(&mapper) failed (%p, not NULL)", (void *)mapper);
        }

        signed long int return_value_list_length_71;
        return_value_list_length_71=list_length(keys);
        if(!(return_value_list_length_71 == 4l))
        {
          errors = errors + 1;
          return_value_list_length_49=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 19, (const void *)"mapper_has_next/mapper_next_mapping", (signed int)return_value_list_length_49);
        }

        else
        {
          struct List *return_value_list_sort_50;
          return_value_list_sort_50=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort_50 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 19, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item_52;
          return_value_list_item_52=list_item(keys, (signed long int)0);
          if(return_value_list_item_52 == NULL)
            tmp_if_expr_55 = (_Bool)1;

          else
          {
            return_value_list_item_53=list_item(keys, (signed long int)0);
            return_value_strcmp_54=strcmp((const char *)return_value_list_item_53, "abc");
            tmp_if_expr_55 = return_value_strcmp_54 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_55)
          {
            errors = errors + 1;
            return_value_list_item_51=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item_51, (const void *)"abc");
          }

          void *return_value_list_item_57;
          return_value_list_item_57=list_item(keys, (signed long int)1);
          if(return_value_list_item_57 == NULL)
            tmp_if_expr_60 = (_Bool)1;

          else
          {
            return_value_list_item_58=list_item(keys, (signed long int)1);
            return_value_strcmp_59=strcmp((const char *)return_value_list_item_58, "def");
            tmp_if_expr_60 = return_value_strcmp_59 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_60)
          {
            errors = errors + 1;
            return_value_list_item_56=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item_56, (const void *)"def");
          }

          void *return_value_list_item_62;
          return_value_list_item_62=list_item(keys, (signed long int)2);
          if(return_value_list_item_62 == NULL)
            tmp_if_expr_65 = (_Bool)1;

          else
          {
            return_value_list_item_63=list_item(keys, (signed long int)2);
            return_value_strcmp_64=strcmp((const char *)return_value_list_item_63, "ghi");
            tmp_if_expr_65 = return_value_strcmp_64 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_65)
          {
            errors = errors + 1;
            return_value_list_item_61=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item_61, (const void *)"ghi");
          }

          void *return_value_list_item_67;
          return_value_list_item_67=list_item(keys, (signed long int)3);
          if(return_value_list_item_67 == NULL)
            tmp_if_expr_70 = (_Bool)1;

          else
          {
            return_value_list_item_68=list_item(keys, (signed long int)3);
            return_value_strcmp_69=strcmp((const char *)return_value_list_item_68, "jkl");
            tmp_if_expr_70 = return_value_strcmp_69 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_70)
          {
            errors = errors + 1;
            return_value_list_item_66=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 19, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item_66, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
        signed long int return_value_list_length_94;
        return_value_list_length_94=list_length(values);
        if(!(return_value_list_length_94 == 4l))
        {
          errors = errors + 1;
          return_value_list_length_72=list_length(values);
          printf("Test%d: %s failed (%d items, not 4)\n", 20, (const void *)"mapper_has_next/mapper_next_mapping", (signed int)return_value_list_length_72);
        }

        else
        {
          struct List *return_value_list_sort_73;
          return_value_list_sort_73=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort_73 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 20, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item_75;
          return_value_list_item_75=list_item(values, (signed long int)0);
          if(return_value_list_item_75 == NULL)
            tmp_if_expr_78 = (_Bool)1;

          else
          {
            return_value_list_item_76=list_item(values, (signed long int)0);
            return_value_strcmp_77=strcmp((const char *)return_value_list_item_76, "abc");
            tmp_if_expr_78 = return_value_strcmp_77 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_78)
          {
            errors = errors + 1;
            return_value_list_item_74=list_item(values, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item_74, (const void *)"abc");
          }

          void *return_value_list_item_80;
          return_value_list_item_80=list_item(values, (signed long int)1);
          if(return_value_list_item_80 == NULL)
            tmp_if_expr_83 = (_Bool)1;

          else
          {
            return_value_list_item_81=list_item(values, (signed long int)1);
            return_value_strcmp_82=strcmp((const char *)return_value_list_item_81, "def");
            tmp_if_expr_83 = return_value_strcmp_82 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_83)
          {
            errors = errors + 1;
            return_value_list_item_79=list_item(values, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item_79, (const void *)"def");
          }

          void *return_value_list_item_85;
          return_value_list_item_85=list_item(values, (signed long int)2);
          if(return_value_list_item_85 == NULL)
            tmp_if_expr_88 = (_Bool)1;

          else
          {
            return_value_list_item_86=list_item(values, (signed long int)2);
            return_value_strcmp_87=strcmp((const char *)return_value_list_item_86, "ghi");
            tmp_if_expr_88 = return_value_strcmp_87 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_88)
          {
            errors = errors + 1;
            return_value_list_item_84=list_item(values, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item_84, (const void *)"ghi");
          }

          void *return_value_list_item_90;
          return_value_list_item_90=list_item(values, (signed long int)3);
          if(return_value_list_item_90 == NULL)
            tmp_if_expr_93 = (_Bool)1;

          else
          {
            return_value_list_item_91=list_item(values, (signed long int)3);
            return_value_strcmp_92=strcmp((const char *)return_value_list_item_91, "jkl");
            tmp_if_expr_93 = return_value_strcmp_92 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_93)
          {
            errors = errors + 1;
            return_value_list_item_89=list_item(values, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 20, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item_89, (const void *)"jkl");
          }

        }
        list_destroy(&values);
      }
      keys=list_create((void (*)(void *))(void *)0);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 21, (const void *)"keys = list_create(NULL)");
      }

      do
      {
        return_value_map_has_next_95=map_has_next(map);
        if(!(return_value_map_has_next_95 == 1))
          break;

        void *main__1__2__3__item;
        main__1__2__3__item=map_next(map);
        if(main__1__2__3__item == NULL)
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 22, (const void *)"item = map_next(map)");
        }

        else
        {
          return_value_list_append_96=list_append(keys, main__1__2__3__item);
          if(return_value_list_append_96 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 22, (const void *)"list_append(keys, item)");
          }

        }
      }
      while((_Bool)1);
      signed long int return_value_list_length_119;
      return_value_list_length_119=list_length(keys);
      if(!(return_value_list_length_119 == 4l))
      {
        errors = errors + 1;
        return_value_list_length_97=list_length(keys);
        printf("Test%d: %s failed (%d items, not 4)\n", 23, (const void *)"map_has_next/map_next", (signed int)return_value_list_length_97);
      }

      else
      {
        struct List *return_value_list_sort_98;
        return_value_list_sort_98=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort_98 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 23, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item_100;
        return_value_list_item_100=list_item(keys, (signed long int)0);
        if(return_value_list_item_100 == NULL)
          tmp_if_expr_103 = (_Bool)1;

        else
        {
          return_value_list_item_101=list_item(keys, (signed long int)0);
          return_value_strcmp_102=strcmp((const char *)return_value_list_item_101, "abc");
          tmp_if_expr_103 = return_value_strcmp_102 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_103)
        {
          errors = errors + 1;
          return_value_list_item_99=list_item(keys, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item_99, (const void *)"abc");
        }

        void *return_value_list_item_105;
        return_value_list_item_105=list_item(keys, (signed long int)1);
        if(return_value_list_item_105 == NULL)
          tmp_if_expr_108 = (_Bool)1;

        else
        {
          return_value_list_item_106=list_item(keys, (signed long int)1);
          return_value_strcmp_107=strcmp((const char *)return_value_list_item_106, "def");
          tmp_if_expr_108 = return_value_strcmp_107 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_108)
        {
          errors = errors + 1;
          return_value_list_item_104=list_item(keys, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item_104, (const void *)"def");
        }

        void *return_value_list_item_110;
        return_value_list_item_110=list_item(keys, (signed long int)2);
        if(return_value_list_item_110 == NULL)
          tmp_if_expr_113 = (_Bool)1;

        else
        {
          return_value_list_item_111=list_item(keys, (signed long int)2);
          return_value_strcmp_112=strcmp((const char *)return_value_list_item_111, "ghi");
          tmp_if_expr_113 = return_value_strcmp_112 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_113)
        {
          errors = errors + 1;
          return_value_list_item_109=list_item(keys, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item_109, (const void *)"ghi");
        }

        void *return_value_list_item_115;
        return_value_list_item_115=list_item(keys, (signed long int)3);
        if(return_value_list_item_115 == NULL)
          tmp_if_expr_118 = (_Bool)1;

        else
        {
          return_value_list_item_116=list_item(keys, (signed long int)3);
          return_value_strcmp_117=strcmp((const char *)return_value_list_item_116, "jkl");
          tmp_if_expr_118 = return_value_strcmp_117 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_118)
        {
          errors = errors + 1;
          return_value_list_item_114=list_item(keys, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 23, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item_114, (const void *)"jkl");
        }

      }
      list_destroy(&keys);
      keys=list_create((void (*)(void *))(void *)0);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 24, (const void *)"keys = list_create(NULL)");
      }

      values=list_create((void (*)(void *))(void *)0);
      if(values == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 24, (const void *)"values = list_create(NULL)");
      }

      do
      {
        return_value_map_has_next_120=map_has_next(map);
        if(!(return_value_map_has_next_120 == 1))
          break;

        const struct Mapping *main__1__2__5__mapping;
        main__1__2__5__mapping=map_next_mapping(map);
        if(main__1__2__5__mapping == ((const struct Mapping *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 25, (const void *)"mapping = map_next_mapping(map)");
        }

        else
        {
          ckey=mapping_key(main__1__2__5__mapping);
          if(ckey == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 25, (const void *)"ckey = mapping_key(mapping)");
          }

          else
          {
            return_value_list_append_121=list_append(keys, (void *)ckey);
            if(return_value_list_append_121 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 25, (const void *)"list_append(keys, (void *)ckey)");
            }

          }
          const void *return_value_mapping_value_123;
          return_value_mapping_value_123=mapping_value(main__1__2__5__mapping);
          cvalue = (const char *)return_value_mapping_value_123;
          if(cvalue == ((const char *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 25, (const void *)"cvalue = mapping_value(mapping)");
          }

          else
          {
            return_value_list_append_122=list_append(values, (void *)cvalue);
            if(return_value_list_append_122 == ((struct List *)NULL))
            {
              errors = errors + 1;
              printf("Test%d: %s failed\n", 25, (const void *)"list_append(values, (void *)cvalue)");
            }

          }
        }
      }
      while((_Bool)1);
      signed long int return_value_list_length_146;
      return_value_list_length_146=list_length(keys);
      if(!(return_value_list_length_146 == 4l))
      {
        errors = errors + 1;
        return_value_list_length_124=list_length(keys);
        printf("Test%d: %s failed (%d items, not 4)\n", 26, (const void *)"map_has_next/map_next_mapping", (signed int)return_value_list_length_124);
      }

      else
      {
        struct List *return_value_list_sort_125;
        return_value_list_sort_125=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort_125 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 26, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item_127;
        return_value_list_item_127=list_item(keys, (signed long int)0);
        if(return_value_list_item_127 == NULL)
          tmp_if_expr_130 = (_Bool)1;

        else
        {
          return_value_list_item_128=list_item(keys, (signed long int)0);
          return_value_strcmp_129=strcmp((const char *)return_value_list_item_128, "abc");
          tmp_if_expr_130 = return_value_strcmp_129 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_130)
        {
          errors = errors + 1;
          return_value_list_item_126=list_item(keys, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item_126, (const void *)"abc");
        }

        void *return_value_list_item_132;
        return_value_list_item_132=list_item(keys, (signed long int)1);
        if(return_value_list_item_132 == NULL)
          tmp_if_expr_135 = (_Bool)1;

        else
        {
          return_value_list_item_133=list_item(keys, (signed long int)1);
          return_value_strcmp_134=strcmp((const char *)return_value_list_item_133, "def");
          tmp_if_expr_135 = return_value_strcmp_134 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_135)
        {
          errors = errors + 1;
          return_value_list_item_131=list_item(keys, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item_131, (const void *)"def");
        }

        void *return_value_list_item_137;
        return_value_list_item_137=list_item(keys, (signed long int)2);
        if(return_value_list_item_137 == NULL)
          tmp_if_expr_140 = (_Bool)1;

        else
        {
          return_value_list_item_138=list_item(keys, (signed long int)2);
          return_value_strcmp_139=strcmp((const char *)return_value_list_item_138, "ghi");
          tmp_if_expr_140 = return_value_strcmp_139 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_140)
        {
          errors = errors + 1;
          return_value_list_item_136=list_item(keys, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item_136, (const void *)"ghi");
        }

        void *return_value_list_item_142;
        return_value_list_item_142=list_item(keys, (signed long int)3);
        if(return_value_list_item_142 == NULL)
          tmp_if_expr_145 = (_Bool)1;

        else
        {
          return_value_list_item_143=list_item(keys, (signed long int)3);
          return_value_strcmp_144=strcmp((const char *)return_value_list_item_143, "jkl");
          tmp_if_expr_145 = return_value_strcmp_144 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_145)
        {
          errors = errors + 1;
          return_value_list_item_141=list_item(keys, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 26, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item_141, (const void *)"jkl");
        }

      }
      list_destroy(&keys);
      signed long int return_value_list_length_169;
      return_value_list_length_169=list_length(values);
      if(!(return_value_list_length_169 == 4l))
      {
        errors = errors + 1;
        return_value_list_length_147=list_length(values);
        printf("Test%d: %s failed (%d items, not 4)\n", 27, (const void *)"map_has_next/map_next_mapping", (signed int)return_value_list_length_147);
      }

      else
      {
        struct List *return_value_list_sort_148;
        return_value_list_sort_148=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
        if(return_value_list_sort_148 == ((struct List *)NULL))
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 27, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
        }

        void *return_value_list_item_150;
        return_value_list_item_150=list_item(values, (signed long int)0);
        if(return_value_list_item_150 == NULL)
          tmp_if_expr_153 = (_Bool)1;

        else
        {
          return_value_list_item_151=list_item(values, (signed long int)0);
          return_value_strcmp_152=strcmp((const char *)return_value_list_item_151, "abc");
          tmp_if_expr_153 = return_value_strcmp_152 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_153)
        {
          errors = errors + 1;
          return_value_list_item_149=list_item(values, (signed long int)0);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item_149, (const void *)"abc");
        }

        void *return_value_list_item_155;
        return_value_list_item_155=list_item(values, (signed long int)1);
        if(return_value_list_item_155 == NULL)
          tmp_if_expr_158 = (_Bool)1;

        else
        {
          return_value_list_item_156=list_item(values, (signed long int)1);
          return_value_strcmp_157=strcmp((const char *)return_value_list_item_156, "def");
          tmp_if_expr_158 = return_value_strcmp_157 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_158)
        {
          errors = errors + 1;
          return_value_list_item_154=list_item(values, (signed long int)1);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item_154, (const void *)"def");
        }

        void *return_value_list_item_160;
        return_value_list_item_160=list_item(values, (signed long int)2);
        if(return_value_list_item_160 == NULL)
          tmp_if_expr_163 = (_Bool)1;

        else
        {
          return_value_list_item_161=list_item(values, (signed long int)2);
          return_value_strcmp_162=strcmp((const char *)return_value_list_item_161, "ghi");
          tmp_if_expr_163 = return_value_strcmp_162 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_163)
        {
          errors = errors + 1;
          return_value_list_item_159=list_item(values, (signed long int)2);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item_159, (const void *)"ghi");
        }

        void *return_value_list_item_165;
        return_value_list_item_165=list_item(values, (signed long int)3);
        if(return_value_list_item_165 == NULL)
          tmp_if_expr_168 = (_Bool)1;

        else
        {
          return_value_list_item_166=list_item(values, (signed long int)3);
          return_value_strcmp_167=strcmp((const char *)return_value_list_item_166, "jkl");
          tmp_if_expr_168 = return_value_strcmp_167 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_168)
        {
          errors = errors + 1;
          return_value_list_item_164=list_item(values, (signed long int)3);
          printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 27, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item_164, (const void *)"jkl");
        }

      }
      list_destroy(&values);
      keys=map_keys(map);
      if(keys == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 28, (const void *)"keys = map_keys(map)");
      }

      else
      {
        signed long int return_value_list_length_192;
        return_value_list_length_192=list_length(keys);
        if(!(return_value_list_length_192 == 4l))
        {
          errors = errors + 1;
          return_value_list_length_170=list_length(keys);
          printf("Test%d: %s failed (%d items, not 4)\n", 29, (const void *)"map_keys", (signed int)return_value_list_length_170);
        }

        else
        {
          struct List *return_value_list_sort_171;
          return_value_list_sort_171=list_sort(keys, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort_171 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 29, (const void *)"list_sort((keys), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item_173;
          return_value_list_item_173=list_item(keys, (signed long int)0);
          if(return_value_list_item_173 == NULL)
            tmp_if_expr_176 = (_Bool)1;

          else
          {
            return_value_list_item_174=list_item(keys, (signed long int)0);
            return_value_strcmp_175=strcmp((const char *)return_value_list_item_174, "abc");
            tmp_if_expr_176 = return_value_strcmp_175 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_176)
          {
            errors = errors + 1;
            return_value_list_item_172=list_item(keys, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 0, (char *)return_value_list_item_172, (const void *)"abc");
          }

          void *return_value_list_item_178;
          return_value_list_item_178=list_item(keys, (signed long int)1);
          if(return_value_list_item_178 == NULL)
            tmp_if_expr_181 = (_Bool)1;

          else
          {
            return_value_list_item_179=list_item(keys, (signed long int)1);
            return_value_strcmp_180=strcmp((const char *)return_value_list_item_179, "def");
            tmp_if_expr_181 = return_value_strcmp_180 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_181)
          {
            errors = errors + 1;
            return_value_list_item_177=list_item(keys, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 1, (char *)return_value_list_item_177, (const void *)"def");
          }

          void *return_value_list_item_183;
          return_value_list_item_183=list_item(keys, (signed long int)2);
          if(return_value_list_item_183 == NULL)
            tmp_if_expr_186 = (_Bool)1;

          else
          {
            return_value_list_item_184=list_item(keys, (signed long int)2);
            return_value_strcmp_185=strcmp((const char *)return_value_list_item_184, "ghi");
            tmp_if_expr_186 = return_value_strcmp_185 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_186)
          {
            errors = errors + 1;
            return_value_list_item_182=list_item(keys, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 2, (char *)return_value_list_item_182, (const void *)"ghi");
          }

          void *return_value_list_item_188;
          return_value_list_item_188=list_item(keys, (signed long int)3);
          if(return_value_list_item_188 == NULL)
            tmp_if_expr_191 = (_Bool)1;

          else
          {
            return_value_list_item_189=list_item(keys, (signed long int)3);
            return_value_strcmp_190=strcmp((const char *)return_value_list_item_189, "jkl");
            tmp_if_expr_191 = return_value_strcmp_190 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_191)
          {
            errors = errors + 1;
            return_value_list_item_187=list_item(keys, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 29, (const void *)"list_sort((keys), sort_cmp)", 3, (char *)return_value_list_item_187, (const void *)"jkl");
          }

        }
        list_destroy(&keys);
      }
      values=map_values(map);
      if(values == ((struct List *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 30, (const void *)"values = map_values(map)");
      }

      else
      {
        signed long int return_value_list_length_215;
        return_value_list_length_215=list_length(values);
        if(!(return_value_list_length_215 == 4l))
        {
          errors = errors + 1;
          return_value_list_length_193=list_length(values);
          printf("Test%d: %s failed (%d items, not 4)\n", 31, (const void *)"map_values", (signed int)return_value_list_length_193);
        }

        else
        {
          struct List *return_value_list_sort_194;
          return_value_list_sort_194=list_sort(values, (signed int (*)(const void *, const void *))sort_cmp);
          if(return_value_list_sort_194 == ((struct List *)NULL))
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 31, (const void *)"list_sort((values), (list_cmp_t *)sort_cmp)");
          }

          void *return_value_list_item_196;
          return_value_list_item_196=list_item(values, (signed long int)0);
          if(return_value_list_item_196 == NULL)
            tmp_if_expr_199 = (_Bool)1;

          else
          {
            return_value_list_item_197=list_item(values, (signed long int)0);
            return_value_strcmp_198=strcmp((const char *)return_value_list_item_197, "abc");
            tmp_if_expr_199 = return_value_strcmp_198 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_199)
          {
            errors = errors + 1;
            return_value_list_item_195=list_item(values, (signed long int)0);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 0, (char *)return_value_list_item_195, (const void *)"abc");
          }

          void *return_value_list_item_201;
          return_value_list_item_201=list_item(values, (signed long int)1);
          if(return_value_list_item_201 == NULL)
            tmp_if_expr_204 = (_Bool)1;

          else
          {
            return_value_list_item_202=list_item(values, (signed long int)1);
            return_value_strcmp_203=strcmp((const char *)return_value_list_item_202, "def");
            tmp_if_expr_204 = return_value_strcmp_203 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_204)
          {
            errors = errors + 1;
            return_value_list_item_200=list_item(values, (signed long int)1);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 1, (char *)return_value_list_item_200, (const void *)"def");
          }

          void *return_value_list_item_206;
          return_value_list_item_206=list_item(values, (signed long int)2);
          if(return_value_list_item_206 == NULL)
            tmp_if_expr_209 = (_Bool)1;

          else
          {
            return_value_list_item_207=list_item(values, (signed long int)2);
            return_value_strcmp_208=strcmp((const char *)return_value_list_item_207, "ghi");
            tmp_if_expr_209 = return_value_strcmp_208 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_209)
          {
            errors = errors + 1;
            return_value_list_item_205=list_item(values, (signed long int)2);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 2, (char *)return_value_list_item_205, (const void *)"ghi");
          }

          void *return_value_list_item_211;
          return_value_list_item_211=list_item(values, (signed long int)3);
          if(return_value_list_item_211 == NULL)
            tmp_if_expr_214 = (_Bool)1;

          else
          {
            return_value_list_item_212=list_item(values, (signed long int)3);
            return_value_strcmp_213=strcmp((const char *)return_value_list_item_212, "jkl");
            tmp_if_expr_214 = return_value_strcmp_213 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_214)
          {
            errors = errors + 1;
            return_value_list_item_210=list_item(values, (signed long int)3);
            printf("Test%d: %s failed (item %d is \"%s\", not \"%s\")\n", 31, (const void *)"list_sort((values), sort_cmp)", 3, (char *)return_value_list_item_210, (const void *)"jkl");
          }

        }
        list_destroy(&values);
      }
      signed int return_value_map_remove_216;
      return_value_map_remove_216=map_remove(map, (const void *)"zzz");
      if(!(return_value_map_remove_216 == -1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 32, (const void *)"map_remove(map, \"zzz\") == -1");
      }

      signed int return_value_map_remove_217;
      return_value_map_remove_217=map_remove(map, (const void *)"abc");
      if(return_value_map_remove_217 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 33, (const void *)"map_remove(map, \"abc\") != -1");
      }

      signed int return_value_map_remove_218;
      return_value_map_remove_218=map_remove(map, (const void *)"def");
      if(return_value_map_remove_218 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 34, (const void *)"map_remove(map, \"def\") != -1");
      }

      signed int return_value_map_remove_219;
      return_value_map_remove_219=map_remove(map, (const void *)"ghi");
      if(return_value_map_remove_219 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 35, (const void *)"map_remove(map, \"ghi\") != -1");
      }

      signed int return_value_map_remove_220;
      return_value_map_remove_220=map_remove(map, (const void *)"jkl");
      if(return_value_map_remove_220 == -1)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 36, (const void *)"map_remove(map, \"jkl\") != -1");
      }

      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test37: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 38, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add_221;
      return_value_map_add_221=map_add(map, (const void *)"1", (void *)"7");
      if(!(return_value_map_add_221 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 39, (const void *)"map_add(map, \"1\", \"7\") == 0");
      }

      signed int return_value_map_add_222;
      return_value_map_add_222=map_add(map, (const void *)"2", (void *)"6");
      if(!(return_value_map_add_222 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 40, (const void *)"map_add(map, \"2\", \"6\") == 0");
      }

      signed int return_value_map_add_223;
      return_value_map_add_223=map_add(map, (const void *)"3", (void *)"5");
      if(!(return_value_map_add_223 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 41, (const void *)"map_add(map, \"3\", \"5\") == 0");
      }

      signed int return_value_map_add_224;
      return_value_map_add_224=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add_224 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 42, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      signed int return_value_map_add_225;
      return_value_map_add_225=map_add(map, (const void *)"5", (void *)"3");
      if(!(return_value_map_add_225 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 43, (const void *)"map_add(map, \"5\", \"3\") == 0");
      }

      signed int return_value_map_add_226;
      return_value_map_add_226=map_add(map, (const void *)"6", (void *)"2");
      if(!(return_value_map_add_226 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 44, (const void *)"map_add(map, \"6\", \"2\") == 0");
      }

      signed int return_value_map_add_227;
      return_value_map_add_227=map_add(map, (const void *)"7", (void *)"1");
      if(!(return_value_map_add_227 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 45, (const void *)"map_add(map, \"7\", \"1\") == 0");
      }

      void *return_value_map_get_228;
      return_value_map_get_228=map_get(map, (const void *)"1");
      value = (char *)return_value_map_get_228;
      if(value == ((char *)NULL))
        tmp_if_expr_230 = (_Bool)1;

      else
      {
        return_value_strcmp_229=strcmp(value, "7");
        tmp_if_expr_230 = return_value_strcmp_229 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_230)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 46, (const void *)"map_get(map, \"1\")", (const void *)"1", value, (const void *)"7");
      }

      void *return_value_map_get_231;
      return_value_map_get_231=map_get(map, (const void *)"2");
      value = (char *)return_value_map_get_231;
      if(value == ((char *)NULL))
        tmp_if_expr_233 = (_Bool)1;

      else
      {
        return_value_strcmp_232=strcmp(value, "6");
        tmp_if_expr_233 = return_value_strcmp_232 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_233)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 47, (const void *)"map_get(map, \"2\")", (const void *)"2", value, (const void *)"6");
      }

      void *return_value_map_get_234;
      return_value_map_get_234=map_get(map, (const void *)"3");
      value = (char *)return_value_map_get_234;
      if(value == ((char *)NULL))
        tmp_if_expr_236 = (_Bool)1;

      else
      {
        return_value_strcmp_235=strcmp(value, "5");
        tmp_if_expr_236 = return_value_strcmp_235 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_236)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 48, (const void *)"map_get(map, \"3\")", (const void *)"3", value, (const void *)"5");
      }

      void *return_value_map_get_237;
      return_value_map_get_237=map_get(map, (const void *)"4");
      value = (char *)return_value_map_get_237;
      if(value == ((char *)NULL))
        tmp_if_expr_239 = (_Bool)1;

      else
      {
        return_value_strcmp_238=strcmp(value, "4");
        tmp_if_expr_239 = return_value_strcmp_238 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_239)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 49, (const void *)"map_get(map, \"4\")", (const void *)"4", value, (const void *)"4");
      }

      void *return_value_map_get_240;
      return_value_map_get_240=map_get(map, (const void *)"5");
      value = (char *)return_value_map_get_240;
      if(value == ((char *)NULL))
        tmp_if_expr_242 = (_Bool)1;

      else
      {
        return_value_strcmp_241=strcmp(value, "3");
        tmp_if_expr_242 = return_value_strcmp_241 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_242)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 50, (const void *)"map_get(map, \"5\")", (const void *)"5", value, (const void *)"3");
      }

      void *return_value_map_get_243;
      return_value_map_get_243=map_get(map, (const void *)"6");
      value = (char *)return_value_map_get_243;
      if(value == ((char *)NULL))
        tmp_if_expr_245 = (_Bool)1;

      else
      {
        return_value_strcmp_244=strcmp(value, "2");
        tmp_if_expr_245 = return_value_strcmp_244 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_245)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 51, (const void *)"map_get(map, \"6\")", (const void *)"6", value, (const void *)"2");
      }

      void *return_value_map_get_246;
      return_value_map_get_246=map_get(map, (const void *)"7");
      value = (char *)return_value_map_get_246;
      if(value == ((char *)NULL))
        tmp_if_expr_248 = (_Bool)1;

      else
      {
        return_value_strcmp_247=strcmp(value, "1");
        tmp_if_expr_248 = return_value_strcmp_247 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_248)
      {
        errors = errors + 1;
        printf("Test%d: %s failed (mapping \"%s\" is \"%s\", not \"%s\")\n", 52, (const void *)"map_get(map, \"7\")", (const void *)"7", value, (const void *)"1");
      }

      cat[(signed long int)0] = (char)0;
      map_apply(map, (void (*)(void *, void *, void *))test_action, (void *)cat);
      signed int return_value_strcmp_249;
      return_value_strcmp_249=strcmp(cat, "7=1, 1=7, 2=6, 3=5, 4=4, 5=3, 6=2");
      if(!(return_value_strcmp_249 == 0))
      {
        errors = errors + 1;
        printf("Test53: map_apply(cat) failed (cat = \"%s\", not \"%s\")\n", (const void *)cat, (const void *)"7=1, 1=7, 2=6, 3=5, 4=4, 5=3, 6=2");
      }

      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test54: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 55, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add_250;
      return_value_map_add_250=map_add(map, (const void *)"1", (void *)"7");
      if(!(return_value_map_add_250 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 56, (const void *)"map_add(map, \"1\", \"7\") == 0");
      }

      signed int return_value_map_add_251;
      return_value_map_add_251=map_add(map, (const void *)"2", (void *)"6");
      if(!(return_value_map_add_251 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 57, (const void *)"map_add(map, \"2\", \"6\") == 0");
      }

      signed int return_value_map_add_252;
      return_value_map_add_252=map_add(map, (const void *)"3", (void *)"5");
      if(!(return_value_map_add_252 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 58, (const void *)"map_add(map, \"3\", \"5\") == 0");
      }

      signed int return_value_map_add_253;
      return_value_map_add_253=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add_253 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 59, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      signed int return_value_map_add_254;
      return_value_map_add_254=map_add(map, (const void *)"5", (void *)"3");
      if(!(return_value_map_add_254 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 60, (const void *)"map_add(map, \"5\", \"3\") == 0");
      }

      signed int return_value_map_add_255;
      return_value_map_add_255=map_add(map, (const void *)"6", (void *)"2");
      if(!(return_value_map_add_255 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 61, (const void *)"map_add(map, \"6\", \"2\") == 0");
      }

      signed int return_value_map_add_256;
      return_value_map_add_256=map_add(map, (const void *)"7", (void *)"1");
      if(!(return_value_map_add_256 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 62, (const void *)"map_add(map, \"7\", \"1\") == 0");
      }

      mapper=mapper_create(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 63, (const void *)"mapper = mapper_create(map)");
      }

      else
      {
        do
        {
          return_value_mapper_has_next_257=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next_257 == 1))
            break;

          void *main__1__4__1__1__item;
          main__1__4__1__1__item=mapper_next(mapper);
          if(main__1__4__1__1__item == NULL)
          {
            errors = errors + 1;
            printf("Test%d: %s failed\n", 64, (const void *)"item = mapper_next(mapper)");
          }

          mapper_remove(mapper);
        }
        while((_Bool)1);
        mapper_destroy(&mapper);
        if(!(mapper == ((struct Mapper *)NULL)))
        {
          errors = errors + 1;
          printf("Test65: mapper_destroy(&mapper) failed (%p, not NULL)\n", (void *)mapper);
        }

        signed long int return_value_map_size_258;
        return_value_map_size_258=map_size(map);
        val = (signed int)return_value_map_size_258;
        if(!(val == 0))
        {
          errors = errors + 1;
          printf("Test%d: %s failed (returned %d, not %d)\n", 66, (const void *)"map_size(map)", val, 0);
        }

      }
      map_destroy(&map);
      if(!(map == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test67: map_destroy(&map) failed (%p, not NULL)\n", (void *)map);
      }

    }
    map=map_create((void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 68, (const void *)"map = map_create(NULL)");
    }

    else
    {
      signed int return_value_map_add_259;
      return_value_map_add_259=map_add(map, (const void *)"1", (void *)"1");
      if(!(return_value_map_add_259 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 69, (const void *)"map_add(map, \"1\", \"1\") == 0");
      }

      signed int return_value_map_add_260;
      return_value_map_add_260=map_add(map, (const void *)"2", (void *)"2");
      if(!(return_value_map_add_260 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 70, (const void *)"map_add(map, \"2\", \"2\") == 0");
      }

      signed int return_value_map_add_261;
      return_value_map_add_261=map_add(map, (const void *)"3", (void *)"3");
      if(!(return_value_map_add_261 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 71, (const void *)"map_add(map, \"3\", \"3\") == 0");
      }

      signed int return_value_map_add_262;
      return_value_map_add_262=map_add(map, (const void *)"4", (void *)"4");
      if(!(return_value_map_add_262 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 72, (const void *)"map_add(map, \"4\", \"4\") == 0");
      }

      do
      {
        return_value_map_has_next_263=map_has_next(map);
        if(!(return_value_map_has_next_263 == 1))
          break;

        void *main__1__5__1__item;
        main__1__5__1__item=map_next(map);
        if(main__1__5__1__item == NULL)
        {
          errors = errors + 1;
          printf("Test%d: %s failed\n", 73, (const void *)"item = map_next(map)");
        }

        map_remove_current(map);
      }
      while((_Bool)1);
      signed long int return_value_map_size_264;
      return_value_map_size_264=map_size(map);
      val = (signed int)return_value_map_size_264;
      if(!(val == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 74, (const void *)"map_size(map)", val, 0);
      }

      mapper_destroy(&mapper);
      map_destroy(&map);
    }
    map=map_create_generic((void * (*)(const void *))point_copy, (signed int (*)(const void *, const void *))point_cmp, (unsigned long int (*)(unsigned long int, const void *))point_hash, (void (*)(void *))point_release, (void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 75, (const void *)"map = map_create_generic((map_copy_t *)point_copy, (map_cmp_t *)point_cmp, (map_hash_t *)point_hash, (map_release_t *)point_release, NULL)");
    }

    else
    {
      struct Point *point;
      point=point_create(0, 0);
      point->x = 0;
      point->y = 0;
      signed int return_value_map_add_265;
      return_value_map_add_265=map_add(map, (const void *)point, (void *)"(0, 0)");
      if(!(return_value_map_add_265 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 76, (const void *)"map_add(map, point, (\"(0, 0)\")) == (0)");
      }

      point->x = 1;
      point->y = 0;
      signed int return_value_map_add_266;
      return_value_map_add_266=map_add(map, (const void *)point, (void *)"(1, 0)");
      if(!(return_value_map_add_266 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 77, (const void *)"map_add(map, point, (\"(1, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = 1;
      signed int return_value_map_add_267;
      return_value_map_add_267=map_add(map, (const void *)point, (void *)"(0, 1)");
      if(!(return_value_map_add_267 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 78, (const void *)"map_add(map, point, (\"(0, 1)\")) == (0)");
      }

      point->x = 1;
      point->y = 1;
      signed int return_value_map_add_268;
      return_value_map_add_268=map_add(map, (const void *)point, (void *)"(1, 1)");
      if(!(return_value_map_add_268 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 79, (const void *)"map_add(map, point, (\"(1, 1)\")) == (0)");
      }

      point->x = -1;
      point->y = 0;
      signed int return_value_map_add_269;
      return_value_map_add_269=map_add(map, (const void *)point, (void *)"(-1, 0)");
      if(!(return_value_map_add_269 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 80, (const void *)"map_add(map, point, (\"(-1, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = -1;
      signed int return_value_map_add_270;
      return_value_map_add_270=map_add(map, (const void *)point, (void *)"(0, -1)");
      if(!(return_value_map_add_270 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 81, (const void *)"map_add(map, point, (\"(0, -1)\")) == (0)");
      }

      point->x = -1;
      point->y = -1;
      signed int return_value_map_add_271;
      return_value_map_add_271=map_add(map, (const void *)point, (void *)"(-1, -1)");
      if(!(return_value_map_add_271 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 82, (const void *)"map_add(map, point, (\"(-1, -1)\")) == (0)");
      }

      point->x = 2;
      point->y = 0;
      signed int return_value_map_add_272;
      return_value_map_add_272=map_add(map, (const void *)point, (void *)"(2, 0)");
      if(!(return_value_map_add_272 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 83, (const void *)"map_add(map, point, (\"(2, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = 2;
      signed int return_value_map_add_273;
      return_value_map_add_273=map_add(map, (const void *)point, (void *)"(0, 2)");
      if(!(return_value_map_add_273 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 84, (const void *)"map_add(map, point, (\"(0, 2)\")) == (0)");
      }

      point->x = 2;
      point->y = 2;
      signed int return_value_map_add_274;
      return_value_map_add_274=map_add(map, (const void *)point, (void *)"(2, 2)");
      if(!(return_value_map_add_274 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 85, (const void *)"map_add(map, point, (\"(2, 2)\")) == (0)");
      }

      point->x = -2;
      point->y = 0;
      signed int return_value_map_add_275;
      return_value_map_add_275=map_add(map, (const void *)point, (void *)"(-2, 0)");
      if(!(return_value_map_add_275 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 86, (const void *)"map_add(map, point, (\"(-2, 0)\")) == (0)");
      }

      point->x = 0;
      point->y = -2;
      signed int return_value_map_add_276;
      return_value_map_add_276=map_add(map, (const void *)point, (void *)"(0, -2)");
      if(!(return_value_map_add_276 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 87, (const void *)"map_add(map, point, (\"(0, -2)\")) == (0)");
      }

      point->x = -2;
      point->y = -2;
      signed int return_value_map_add_277;
      return_value_map_add_277=map_add(map, (const void *)point, (void *)"(-2, -2)");
      if(!(return_value_map_add_277 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 88, (const void *)"map_add(map, point, (\"(-2, -2)\")) == (0)");
      }

      point->x = 0;
      point->y = 0;
      signed int return_value_map_add_278;
      return_value_map_add_278=map_add(map, (const void *)point, (void *)"(0, 0)");
      if(!(return_value_map_add_278 == -1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 89, (const void *)"map_add(map, point, (\"(0, 0)\")) == (-1)");
      }

      signed long int return_value_map_size_279;
      return_value_map_size_279=map_size(map);
      val = (signed int)return_value_map_size_279;
      if(!(val == 13))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 90, (const void *)"map_size(map)", val, 13);
      }

      point->x = 0;
      point->y = 0;
      void *return_value_map_get_281;
      return_value_map_get_281=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_281;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 91);
      }

      else
      {
        return_value_strcmp_280=strcmp(value, "(0, 0)");
        if(!(return_value_strcmp_280 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 91, value, (const void *)"(0, 0)");
        }

      }
      point->x = 1;
      point->y = 0;
      void *return_value_map_get_283;
      return_value_map_get_283=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_283;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 92);
      }

      else
      {
        return_value_strcmp_282=strcmp(value, "(1, 0)");
        if(!(return_value_strcmp_282 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 92, value, (const void *)"(1, 0)");
        }

      }
      point->x = 0;
      point->y = 1;
      void *return_value_map_get_285;
      return_value_map_get_285=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_285;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 93);
      }

      else
      {
        return_value_strcmp_284=strcmp(value, "(0, 1)");
        if(!(return_value_strcmp_284 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 93, value, (const void *)"(0, 1)");
        }

      }
      point->x = 1;
      point->y = 1;
      void *return_value_map_get_287;
      return_value_map_get_287=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_287;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 94);
      }

      else
      {
        return_value_strcmp_286=strcmp(value, "(1, 1)");
        if(!(return_value_strcmp_286 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 94, value, (const void *)"(1, 1)");
        }

      }
      point->x = -1;
      point->y = 0;
      void *return_value_map_get_289;
      return_value_map_get_289=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_289;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 95);
      }

      else
      {
        return_value_strcmp_288=strcmp(value, "(-1, 0)");
        if(!(return_value_strcmp_288 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 95, value, (const void *)"(-1, 0)");
        }

      }
      point->x = 0;
      point->y = -1;
      void *return_value_map_get_291;
      return_value_map_get_291=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_291;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 96);
      }

      else
      {
        return_value_strcmp_290=strcmp(value, "(0, -1)");
        if(!(return_value_strcmp_290 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 96, value, (const void *)"(0, -1)");
        }

      }
      point->x = -1;
      point->y = -1;
      void *return_value_map_get_293;
      return_value_map_get_293=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_293;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 97);
      }

      else
      {
        return_value_strcmp_292=strcmp(value, "(-1, -1)");
        if(!(return_value_strcmp_292 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 97, value, (const void *)"(-1, -1)");
        }

      }
      point->x = 2;
      point->y = 0;
      void *return_value_map_get_295;
      return_value_map_get_295=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_295;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 98);
      }

      else
      {
        return_value_strcmp_294=strcmp(value, "(2, 0)");
        if(!(return_value_strcmp_294 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 98, value, (const void *)"(2, 0)");
        }

      }
      point->x = 0;
      point->y = 2;
      void *return_value_map_get_297;
      return_value_map_get_297=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_297;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 99);
      }

      else
      {
        return_value_strcmp_296=strcmp(value, "(0, 2)");
        if(!(return_value_strcmp_296 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 99, value, (const void *)"(0, 2)");
        }

      }
      point->x = 2;
      point->y = 2;
      void *return_value_map_get_299;
      return_value_map_get_299=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_299;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 100);
      }

      else
      {
        return_value_strcmp_298=strcmp(value, "(2, 2)");
        if(!(return_value_strcmp_298 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 100, value, (const void *)"(2, 2)");
        }

      }
      point->x = -2;
      point->y = 0;
      void *return_value_map_get_301;
      return_value_map_get_301=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_301;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 101);
      }

      else
      {
        return_value_strcmp_300=strcmp(value, "(-2, 0)");
        if(!(return_value_strcmp_300 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 101, value, (const void *)"(-2, 0)");
        }

      }
      point->x = 0;
      point->y = -2;
      void *return_value_map_get_303;
      return_value_map_get_303=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_303;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 102);
      }

      else
      {
        return_value_strcmp_302=strcmp(value, "(0, -2)");
        if(!(return_value_strcmp_302 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 102, value, (const void *)"(0, -2)");
        }

      }
      point->x = -2;
      point->y = -2;
      void *return_value_map_get_305;
      return_value_map_get_305=map_get(map, (const void *)point);
      value = (char *)return_value_map_get_305;
      if(value == ((char *)NULL))
      {
        errors = errors + 1;
        printf("Test%d: map_get(generic) failed\n", 103);
      }

      else
      {
        return_value_strcmp_304=strcmp(value, "(-2, -2)");
        if(!(return_value_strcmp_304 == 0))
        {
          errors = errors + 1;
          printf("Test%d: map_get(generic) failed (\"%s\", not \"%s\")\n", 103, value, (const void *)"(-2, -2)");
        }

      }
      point_release(point);
      map_destroy(&map);
    }
    map=map_create_generic((void * (*)(const void *))direct_copy, (signed int (*)(const void *, const void *))direct_cmp, (unsigned long int (*)(unsigned long int, const void *))direct_hash, (void (*)(void *))(void *)0, (void (*)(void *))(void *)0);
    if(map == ((struct Map *)NULL))
    {
      errors = errors + 1;
      printf("Test%d: %s failed\n", 104, (const void *)"map = map_create_generic((map_copy_t *)direct_copy, (map_cmp_t *)direct_cmp, (map_hash_t *)direct_hash, NULL, NULL)");
    }

    else
    {
      signed int return_value_map_add_306;
      return_value_map_add_306=map_add(map, (void *)1, (void *)1);
      if(!(return_value_map_add_306 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 105, (const void *)"map_add(map, (void *)1, (void *)1) == 0");
      }

      signed int return_value_map_add_307;
      return_value_map_add_307=map_add(map, (void *)2, (void *)2);
      if(!(return_value_map_add_307 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 106, (const void *)"map_add(map, (void *)2, (void *)2) == 0");
      }

      signed int return_value_map_add_308;
      return_value_map_add_308=map_add(map, (void *)3, (void *)3);
      if(!(return_value_map_add_308 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 107, (const void *)"map_add(map, (void *)3, (void *)3) == 0");
      }

      signed int return_value_map_add_309;
      return_value_map_add_309=map_add(map, (void *)4, (void *)4);
      if(!(return_value_map_add_309 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 108, (const void *)"map_add(map, (void *)4, (void *)4) == 0");
      }

      signed int return_value_map_add_310;
      return_value_map_add_310=map_add(map, (void *)5, (void *)5);
      if(!(return_value_map_add_310 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 109, (const void *)"map_add(map, (void *)5, (void *)5) == 0");
      }

      signed int return_value_map_add_311;
      return_value_map_add_311=map_add(map, (void *)6, (void *)6);
      if(!(return_value_map_add_311 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 110, (const void *)"map_add(map, (void *)6, (void *)6) == 0");
      }

      signed int return_value_map_add_312;
      return_value_map_add_312=map_add(map, (void *)7, (void *)7);
      if(!(return_value_map_add_312 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 111, (const void *)"map_add(map, (void *)7, (void *)7) == 0");
      }

      signed int return_value_map_add_313;
      return_value_map_add_313=map_add(map, (void *)8, (void *)8);
      if(!(return_value_map_add_313 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 112, (const void *)"map_add(map, (void *)8, (void *)8) == 0");
      }

      signed int return_value_map_add_314;
      return_value_map_add_314=map_add(map, (void *)9, (void *)9);
      if(!(return_value_map_add_314 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 113, (const void *)"map_add(map, (void *)9, (void *)9) == 0");
      }

      signed int return_value_map_add_315;
      return_value_map_add_315=map_add(map, (void *)10, (void *)10);
      if(!(return_value_map_add_315 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 114, (const void *)"map_add(map, (void *)10, (void *)10) == 0");
      }

      signed int return_value_map_add_316;
      return_value_map_add_316=map_add(map, (void *)11, (void *)11);
      if(!(return_value_map_add_316 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 115, (const void *)"map_add(map, (void *)11, (void *)11) == 0");
      }

      signed int return_value_map_add_317;
      return_value_map_add_317=map_add(map, (void *)12, (void *)12);
      if(!(return_value_map_add_317 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 116, (const void *)"map_add(map, (void *)12, (void *)12) == 0");
      }

      signed int return_value_map_add_318;
      return_value_map_add_318=map_add(map, (void *)13, (void *)13);
      if(!(return_value_map_add_318 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 117, (const void *)"map_add(map, (void *)13, (void *)13) == 0");
      }

      signed int return_value_map_add_319;
      return_value_map_add_319=map_add(map, (void *)14, (void *)14);
      if(!(return_value_map_add_319 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 118, (const void *)"map_add(map, (void *)14, (void *)14) == 0");
      }

      signed int return_value_map_add_320;
      return_value_map_add_320=map_add(map, (void *)15, (void *)15);
      if(!(return_value_map_add_320 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 119, (const void *)"map_add(map, (void *)15, (void *)15) == 0");
      }

      signed int return_value_map_add_321;
      return_value_map_add_321=map_add(map, (void *)16, (void *)16);
      if(!(return_value_map_add_321 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 120, (const void *)"map_add(map, (void *)16, (void *)16) == 0");
      }

      signed int return_value_map_add_322;
      return_value_map_add_322=map_add(map, (void *)17, (void *)17);
      if(!(return_value_map_add_322 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 121, (const void *)"map_add(map, (void *)17, (void *)17) == 0");
      }

      signed int return_value_map_add_323;
      return_value_map_add_323=map_add(map, (void *)18, (void *)18);
      if(!(return_value_map_add_323 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 122, (const void *)"map_add(map, (void *)18, (void *)18) == 0");
      }

      signed int return_value_map_add_324;
      return_value_map_add_324=map_add(map, (void *)19, (void *)19);
      if(!(return_value_map_add_324 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 123, (const void *)"map_add(map, (void *)19, (void *)19) == 0");
      }

      signed int return_value_map_add_325;
      return_value_map_add_325=map_add(map, (void *)20, (void *)20);
      if(!(return_value_map_add_325 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 124, (const void *)"map_add(map, (void *)20, (void *)20) == 0");
      }

      signed int return_value_map_add_326;
      return_value_map_add_326=map_add(map, (void *)21, (void *)21);
      if(!(return_value_map_add_326 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 125, (const void *)"map_add(map, (void *)21, (void *)21) == 0");
      }

      signed int return_value_map_add_327;
      return_value_map_add_327=map_add(map, (void *)22, (void *)22);
      if(!(return_value_map_add_327 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 126, (const void *)"map_add(map, (void *)22, (void *)22) == 0");
      }

      signed int return_value_map_add_328;
      return_value_map_add_328=map_add(map, (void *)23, (void *)23);
      if(!(return_value_map_add_328 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 127, (const void *)"map_add(map, (void *)23, (void *)23) == 0");
      }

      signed int return_value_map_add_329;
      return_value_map_add_329=map_add(map, (void *)24, (void *)24);
      if(!(return_value_map_add_329 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 128, (const void *)"map_add(map, (void *)24, (void *)24) == 0");
      }

      signed int return_value_map_add_330;
      return_value_map_add_330=map_add(map, (void *)25, (void *)25);
      if(!(return_value_map_add_330 == 0))
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 129, (const void *)"map_add(map, (void *)25, (void *)25) == 0");
      }

      signed int return_value_map_add_331;
      return_value_map_add_331=map_add(map, (void *)25, (void *)25);
      if(return_value_map_add_331 == 0)
      {
        errors = errors + 1;
        printf("Test%d: %s failed\n", 130, (const void *)"map_add(map, (void *)25, (void *)25) != 0");
      }

      signed long int return_value_map_size_332;
      return_value_map_size_332=map_size(map);
      val = (signed int)return_value_map_size_332;
      if(!(val == 25))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 130, (const void *)"map_size(map)", val, 25);
      }

      void *return_value_map_get_333;
      return_value_map_get_333=map_get(map, (void *)1);
      val = (signed int)(signed long int)return_value_map_get_333;
      if(!(val == 1))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 131, (const void *)"(int)(long)map_get(map, (void *)1)", val, 1);
      }

      void *return_value_map_get_334;
      return_value_map_get_334=map_get(map, (void *)2);
      val = (signed int)(signed long int)return_value_map_get_334;
      if(!(val == 2))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 132, (const void *)"(int)(long)map_get(map, (void *)2)", val, 2);
      }

      void *return_value_map_get_335;
      return_value_map_get_335=map_get(map, (void *)3);
      val = (signed int)(signed long int)return_value_map_get_335;
      if(!(val == 3))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 133, (const void *)"(int)(long)map_get(map, (void *)3)", val, 3);
      }

      void *return_value_map_get_336;
      return_value_map_get_336=map_get(map, (void *)4);
      val = (signed int)(signed long int)return_value_map_get_336;
      if(!(val == 4))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 134, (const void *)"(int)(long)map_get(map, (void *)4)", val, 4);
      }

      void *return_value_map_get_337;
      return_value_map_get_337=map_get(map, (void *)5);
      val = (signed int)(signed long int)return_value_map_get_337;
      if(!(val == 5))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 135, (const void *)"(int)(long)map_get(map, (void *)5)", val, 5);
      }

      void *return_value_map_get_338;
      return_value_map_get_338=map_get(map, (void *)6);
      val = (signed int)(signed long int)return_value_map_get_338;
      if(!(val == 6))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 136, (const void *)"(int)(long)map_get(map, (void *)6)", val, 6);
      }

      void *return_value_map_get_339;
      return_value_map_get_339=map_get(map, (void *)7);
      val = (signed int)(signed long int)return_value_map_get_339;
      if(!(val == 7))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 137, (const void *)"(int)(long)map_get(map, (void *)7)", val, 7);
      }

      void *return_value_map_get_340;
      return_value_map_get_340=map_get(map, (void *)8);
      val = (signed int)(signed long int)return_value_map_get_340;
      if(!(val == 8))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 138, (const void *)"(int)(long)map_get(map, (void *)8)", val, 8);
      }

      void *return_value_map_get_341;
      return_value_map_get_341=map_get(map, (void *)9);
      val = (signed int)(signed long int)return_value_map_get_341;
      if(!(val == 9))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 139, (const void *)"(int)(long)map_get(map, (void *)9)", val, 9);
      }

      void *return_value_map_get_342;
      return_value_map_get_342=map_get(map, (void *)10);
      val = (signed int)(signed long int)return_value_map_get_342;
      if(!(val == 10))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 140, (const void *)"(int)(long)map_get(map, (void *)10)", val, 10);
      }

      void *return_value_map_get_343;
      return_value_map_get_343=map_get(map, (void *)11);
      val = (signed int)(signed long int)return_value_map_get_343;
      if(!(val == 11))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 141, (const void *)"(int)(long)map_get(map, (void *)11)", val, 11);
      }

      void *return_value_map_get_344;
      return_value_map_get_344=map_get(map, (void *)12);
      val = (signed int)(signed long int)return_value_map_get_344;
      if(!(val == 12))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 142, (const void *)"(int)(long)map_get(map, (void *)12)", val, 12);
      }

      void *return_value_map_get_345;
      return_value_map_get_345=map_get(map, (void *)13);
      val = (signed int)(signed long int)return_value_map_get_345;
      if(!(val == 13))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 143, (const void *)"(int)(long)map_get(map, (void *)13)", val, 13);
      }

      void *return_value_map_get_346;
      return_value_map_get_346=map_get(map, (void *)14);
      val = (signed int)(signed long int)return_value_map_get_346;
      if(!(val == 14))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 144, (const void *)"(int)(long)map_get(map, (void *)14)", val, 14);
      }

      void *return_value_map_get_347;
      return_value_map_get_347=map_get(map, (void *)15);
      val = (signed int)(signed long int)return_value_map_get_347;
      if(!(val == 15))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 145, (const void *)"(int)(long)map_get(map, (void *)15)", val, 15);
      }

      void *return_value_map_get_348;
      return_value_map_get_348=map_get(map, (void *)16);
      val = (signed int)(signed long int)return_value_map_get_348;
      if(!(val == 16))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 146, (const void *)"(int)(long)map_get(map, (void *)16)", val, 16);
      }

      void *return_value_map_get_349;
      return_value_map_get_349=map_get(map, (void *)17);
      val = (signed int)(signed long int)return_value_map_get_349;
      if(!(val == 17))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 147, (const void *)"(int)(long)map_get(map, (void *)17)", val, 17);
      }

      void *return_value_map_get_350;
      return_value_map_get_350=map_get(map, (void *)18);
      val = (signed int)(signed long int)return_value_map_get_350;
      if(!(val == 18))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 148, (const void *)"(int)(long)map_get(map, (void *)18)", val, 18);
      }

      void *return_value_map_get_351;
      return_value_map_get_351=map_get(map, (void *)19);
      val = (signed int)(signed long int)return_value_map_get_351;
      if(!(val == 19))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 149, (const void *)"(int)(long)map_get(map, (void *)19)", val, 19);
      }

      void *return_value_map_get_352;
      return_value_map_get_352=map_get(map, (void *)20);
      val = (signed int)(signed long int)return_value_map_get_352;
      if(!(val == 20))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 150, (const void *)"(int)(long)map_get(map, (void *)20)", val, 20);
      }

      void *return_value_map_get_353;
      return_value_map_get_353=map_get(map, (void *)21);
      val = (signed int)(signed long int)return_value_map_get_353;
      if(!(val == 21))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 151, (const void *)"(int)(long)map_get(map, (void *)21)", val, 21);
      }

      void *return_value_map_get_354;
      return_value_map_get_354=map_get(map, (void *)22);
      val = (signed int)(signed long int)return_value_map_get_354;
      if(!(val == 22))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 152, (const void *)"(int)(long)map_get(map, (void *)22)", val, 22);
      }

      void *return_value_map_get_355;
      return_value_map_get_355=map_get(map, (void *)23);
      val = (signed int)(signed long int)return_value_map_get_355;
      if(!(val == 23))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 153, (const void *)"(int)(long)map_get(map, (void *)23)", val, 23);
      }

      void *return_value_map_get_356;
      return_value_map_get_356=map_get(map, (void *)24);
      val = (signed int)(signed long int)return_value_map_get_356;
      if(!(val == 24))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 154, (const void *)"(int)(long)map_get(map, (void *)24)", val, 24);
      }

      void *return_value_map_get_357;
      return_value_map_get_357=map_get(map, (void *)25);
      val = (signed int)(signed long int)return_value_map_get_357;
      if(!(val == 25))
      {
        errors = errors + 1;
        printf("Test%d: %s failed (returned %d, not %d)\n", 155, (const void *)"(int)(long)map_get(map, (void *)25)", val, 25);
      }

      map_destroy(&map);
    }
    if(ac == 2)
    {
      return_value_strcmp_358=strcmp(av[(signed long int)1], "debug");
      tmp_if_expr_359 = !(return_value_strcmp_358 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_359 = (_Bool)0;
    debug = (signed int)tmp_if_expr_359;
    if(!(debug == 0))
      setbuf(stdout, (char *)(void *)0);

    if(!(debug == 0))
      locker=locker_create_debug_rwlock(&rwlock);

    else
      locker=locker_create_rwlock(&rwlock);
    if(locker == ((struct Locker *)NULL))
    {
      errors = errors + 1;
      printf("Test220: locker_create_rwlock() failed\n");
    }

    else
    {
      mt_test(220, locker);
      locker_destroy(&locker);
    }
    if(!(debug == 0))
      locker=locker_create_debug_mutex(&mutex);

    else
      locker=locker_create_mutex(&mutex);
    if(locker == ((struct Locker *)NULL))
    {
      errors = errors + 1;
      printf("Test221: locker_create_mutex() failed\n");
    }

    else
    {
      mt_test(221, locker);
      locker_destroy(&locker);
    }
    memset((void *)&ptr, 0, sizeof(void *) /*8ul*/ );
    if(!(ptr == NULL))
    {
      errors = errors + 1;
      printf("Test223: assumption failed: memset(&ptr, 0, sizeof(void *)) not same as NULL\n");
    }

    if(!(errors == 0))
      printf("%d/223 tests failed\n", errors);

    else
      printf("All tests passed\n");
    return errors == 0 ? 0 : 1;
  }
}

// map_add
// file libslack/map.h line 62
signed int map_add(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_1;
  return_value_map_insert_1=map_insert(map, key, value, 0);
  return return_value_map_insert_1;
}

// map_add_unlocked
// file libslack/map.c line 887
signed int map_add_unlocked(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_unlocked_1;
  return_value_map_insert_unlocked_1=map_insert_unlocked(map, key, value, 0);
  return return_value_map_insert_unlocked_1;
}

// map_apply
// file libslack/map.h line 99
void map_apply(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  map_apply_wrlocked(map, action, data);
}

// map_apply_rdlocked
// file libslack/map.c line 1907
void map_apply_rdlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      map_apply_unlocked(map, action, data);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_3 = return_value_1;
        }

        else
          tmp_if_expr_3 = 0;
        tmp_if_expr_4 = tmp_if_expr_3;
      }

      else
        tmp_if_expr_4 = 22;
      err = tmp_if_expr_4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// map_apply_unlocked
// file libslack/map.c line 1978
void map_apply_unlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  struct Mapper *mapper;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    mapper=mapper_create_unlocked(map);
    if(!(mapper == ((struct Mapper *)NULL)))
    {
      signed int return_value_mapper_has_next_1;
      return_value_mapper_has_next_1=mapper_has_next(mapper);
      if(return_value_mapper_has_next_1 == 1)
      {
        const struct Mapping *mapping;
        mapping=mapper_next_mapping(mapper);
        action(mapping->key, mapping->value, data);
      }

      mapper_release_unlocked(mapper);
    }

  }
}

// map_apply_wrlocked
// file libslack/map.c line 1943
void map_apply_wrlocked(struct Map *map, void (*action)(void *, void *, void *), void *data)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  if(action == ((void (*)(void *, void *, void *))NULL) || map == ((struct Map *)NULL))
    set_errno(22);

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      map_apply_unlocked(map, action, data);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_3 = return_value_1;
        }

        else
          tmp_if_expr_3 = 0;
        tmp_if_expr_4 = tmp_if_expr_3;
      }

      else
        tmp_if_expr_4 = 22;
      err = tmp_if_expr_4;
      if(!(err == 0))
        set_errno(err);

    }
  }
}

// map_break
// file libslack/map.h line 85
void map_break(struct Map *map)
{
  if(map == ((struct Map *)NULL))
    set_errno(22);

  else
    mapper_destroy_unlocked(&map->mapper);
}

// map_create
// file libslack/map.h line 41
struct Map * map_create(void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash_1;
  return_value_map_create_sized_with_hash_1=map_create_sized_with_hash(table_sizes[(signed long int)0], (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_sized_with_hash_1;
}

// map_create_generic
// file libslack/map.h line 49
struct Map * map_create_generic(void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized_1;
  return_value_map_create_generic_with_locker_sized_1=map_create_generic_with_locker_sized((struct Locker *)(void *)0, table_sizes[(signed long int)0], copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized_1;
}

// map_create_generic_sized
// file libslack/map.c line 450
struct Map * map_create_generic_sized(unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized_1;
  return_value_map_create_generic_with_locker_sized_1=map_create_generic_with_locker_sized((struct Locker *)(void *)0, size, copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized_1;
}

// map_create_generic_with_locker
// file libslack/map.h line 51
struct Map * map_create_generic_with_locker(struct Locker *locker, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized_1;
  return_value_map_create_generic_with_locker_sized_1=map_create_generic_with_locker_sized(locker, table_sizes[(signed long int)0], copy, cmp, hash, key_destroy, value_destroy);
  return return_value_map_create_generic_with_locker_sized_1;
}

// map_create_generic_with_locker_sized
// file libslack/map.c line 482
struct Map * map_create_generic_with_locker_sized(struct Locker *locker, unsigned long int size, void * (*copy)(const void *), signed int (*cmp)(const void *, const void *), unsigned long int (*hash)(unsigned long int, const void *), void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Map *map;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= num_table_sizes); i = i + 1ul)
    if(table_sizes[(signed long int)i] >= size)
    {
      size = table_sizes[(signed long int)i];
      break;
    }

  void *return_value_set_errnull_1;
  if(i == num_table_sizes)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Map *)return_value_set_errnull_1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct Map) /*80ul*/ );
    map = (struct Map *)return_value_malloc_2;
    if(map == ((struct Map *)NULL))
      return (struct Map *)(void *)0;

    else
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(size * sizeof(struct List *) /*8ul*/ );
      map->chain = (struct List **)return_value_malloc_3;
      if(map->chain == ((struct List **)NULL))
      {
        free((void *)map);
        return (struct Map *)(void *)0;
      }

      else
      {
        map->size = size;
        map->items = (unsigned long int)0;
        memset((void *)map->chain, 0, map->size * sizeof(struct List *) /*8ul*/ );
        map->hash = hash;
        map->copy = copy;
        map->cmp = cmp;
        map->key_destroy = key_destroy;
        map->value_destroy = value_destroy;
        map->mapper = (struct Mapper *)(void *)0;
        map->locker = locker;
        return map;
      }
    }
  }
}

// map_create_sized
// file libslack/map.c line 306
struct Map * map_create_sized(unsigned long int size, void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash_1;
  return_value_map_create_sized_with_hash_1=map_create_sized_with_hash(size, (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_sized_with_hash_1;
}

// map_create_sized_with_hash
// file libslack/map.c line 342
struct Map * map_create_sized_with_hash(unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_generic_sized_1;
  return_value_map_create_generic_sized_1=map_create_generic_sized(size, (void * (*)(const void *))mem_strdup, (signed int (*)(const void *, const void *))strcmp, hash, (void (*)(void *))free, destroy);
  return return_value_map_create_generic_sized_1;
}

// map_create_with_hash
// file libslack/map.c line 324
struct Map * map_create_with_hash(unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_sized_with_hash_1;
  return_value_map_create_sized_with_hash_1=map_create_sized_with_hash(table_sizes[(signed long int)0], hash, destroy);
  return return_value_map_create_sized_with_hash_1;
}

// map_create_with_locker
// file libslack/map.c line 358
struct Map * map_create_with_locker(struct Locker *locker, void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash_1;
  return_value_map_create_with_locker_sized_with_hash_1=map_create_with_locker_sized_with_hash(locker, table_sizes[(signed long int)0], (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash_1;
}

// map_create_with_locker_sized
// file libslack/map.c line 374
struct Map * map_create_with_locker_sized(struct Locker *locker, unsigned long int size, void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash_1;
  return_value_map_create_with_locker_sized_with_hash_1=map_create_with_locker_sized_with_hash(locker, size, (unsigned long int (*)(unsigned long int, const void *))hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash_1;
}

// map_create_with_locker_sized_with_hash
// file libslack/map.c line 406
struct Map * map_create_with_locker_sized_with_hash(struct Locker *locker, unsigned long int size, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_generic_with_locker_sized_1;
  return_value_map_create_generic_with_locker_sized_1=map_create_generic_with_locker_sized(locker, size, (void * (*)(const void *))mem_strdup, (signed int (*)(const void *, const void *))strcmp, hash, (void (*)(void *))free, destroy);
  return return_value_map_create_generic_with_locker_sized_1;
}

// map_create_with_locker_with_hash
// file libslack/map.c line 390
struct Map * map_create_with_locker_with_hash(struct Locker *locker, unsigned long int (*hash)(unsigned long int, const void *), void (*destroy)(void *))
{
  struct Map *return_value_map_create_with_locker_sized_with_hash_1;
  return_value_map_create_with_locker_sized_with_hash_1=map_create_with_locker_sized_with_hash(locker, table_sizes[(signed long int)0], hash, destroy);
  return return_value_map_create_with_locker_sized_with_hash_1;
}

// map_destroy
// file libslack/map.h line 57
void * map_destroy(struct Map **map)
{
  if(!(map == ((struct Map **)NULL)))
  {
    if(!(*map == ((struct Map *)NULL)))
    {
      map_release(*map);
      *map = (struct Map *)(void *)0;
    }

  }

  return (void *)0;
}

// map_disown
// file libslack/map.c line 721
void (*map_disown(struct Map *map))(void *)
{
  void (*ret)(void *);
  signed int err;
  void (*return_value_set_errnullf_1)();
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void (*return_value_set_errnullf_2)();
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void (*return_value_set_errnullf_5)();
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnullf_1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnullf_2=set_errnullf(err);
      return (void (*)(void *))return_value_set_errnullf_2;
    }

    else
    {
      ret=map_disown_unlocked(map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnullf_5=set_errnullf(err);
        return (void (*)(void *))return_value_set_errnullf_5;
      }

      else
        return ret;
    }
  }
}

// map_disown_unlocked
// file libslack/map.c line 750
void (*map_disown_unlocked(struct Map *map))(void *)
{
  signed long int length;
  unsigned long int c;
  unsigned long int i;
  void (*destroy)(void *);
  void (*return_value_set_errnullf_1)();
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnullf_1=set_errnullf(22);
    return (void (*)(void *))return_value_set_errnullf_1;
  }

  else
    if(map->value_destroy == ((void (*)(void *))NULL))
      return (void (*)(void *))(void *)0;

    else
    {
      destroy = map->value_destroy;
      map->value_destroy = (void (*)(void *))(void *)0;
      c = (unsigned long int)0;
      for( ; !(c >= map->size); c = c + 1ul)
      {
        struct List *chain = map->chain[(signed long int)c];
        if(!(chain == ((struct List *)NULL)))
        {
          length=list_length_unlocked(chain);
          if(length == -1l)
            return (void (*)(void *))(void *)0;

          i = (unsigned long int)0;
          for( ; !(i >= (unsigned long int)length); i = i + 1ul)
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked_2;
            return_value_list_item_unlocked_2=list_item_unlocked(chain, (signed long int)i);
            mapping = (struct Mapping *)return_value_list_item_unlocked_2;
            mapping->value_destroy = (void (*)(void *))(void *)0;
          }
        }

      }
      return destroy;
    }
}

// map_get
// file libslack/map.h line 70
void * map_get(struct Map *map, const void *key)
{
  void *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      ret=map_get_unlocked(map, key);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// map_get_unlocked
// file libslack/map.h line 71
void * map_get_unlocked(const struct Map *map, const void *key)
{
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(key == NULL || map == ((const struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    h=map->hash(map->size, key);
    if(h >= map->size)
    {
      return_value_set_errnull_2=set_errnull(22);
      return return_value_set_errnull_2;
    }

    else
    {
      chain = map->chain[(signed long int)h];
      if(chain == ((struct List *)NULL))
      {
        return_value_set_errnull_3=set_errnull(2);
        return return_value_set_errnull_3;
      }

      else
      {
        length=list_length_unlocked(chain);
        if(length == -1l)
          return (void *)0;

        else
        {
          c = (unsigned long int)0;
          if(!(c >= (unsigned long int)length))
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked_4;
            return_value_list_item_unlocked_4=list_item_unlocked(chain, (signed long int)c);
            mapping = (struct Mapping *)return_value_list_item_unlocked_4;
            signed int return_value;
            return_value=map->cmp(mapping->key, key);
            if(return_value == 0)
              return mapping->value;

            c = c + 1ul;
          }

          void *return_value_set_errnull_5;
          return_value_set_errnull_5=set_errnull(2);
          return return_value_set_errnull_5;
        }
      }
    }
  }
}

// map_has_next
// file libslack/map.h line 84
signed int map_has_next(struct Map *map)
{
  signed int has;
  signed int return_value_set_errno_1;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if(map->mapper == ((struct Mapper *)NULL))
    {
      map->mapper=mapper_create_unlocked(map);
      if(!(map->mapper == ((struct Mapper *)NULL)))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      has=mapper_has_next(map->mapper);
      if(!(has == 1))
        map_break(map);

      return has;
    }
}

// map_histogram
// file libslack/map.c line 2306
static void map_histogram(const char *name, struct Map *map)
{
  unsigned long int i;
  signed int *histogram;
  if(map == ((struct Map *)NULL))
    printf("%s = nil\n", name);

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(map->items * sizeof(signed int) /*4ul*/ );
    histogram = (signed int *)return_value_malloc_1;
    if(histogram == ((signed int *)NULL))
      printf("Failed to allocate histogram for map %s\n", name);

    else
    {
      memset((void *)histogram, 0, map->items * sizeof(signed int) /*4ul*/ );
      i = (unsigned long int)0;
      for( ; !(i >= map->size); i = i + 1ul)
      {
        unsigned long int length;
        signed long int return_value_list_length_2;
        return_value_list_length_2=list_length(map->chain[(signed long int)i]);
        length = (unsigned long int)return_value_list_length_2;
        if(length == 18446744073709551615ul)
          printf("  length[%d] = -1\n", (signed int)i);

        else
          histogram[(signed long int)length] = histogram[(signed long int)length] + 1;
      }
      printf("\nhistogram %s =\n{\n", name);
      i = (unsigned long int)0;
      for( ; !(i >= map->items); i = i + 1ul)
        if(!(histogram[(signed long int)i] == 0))
          printf("    %d chain%s of length %d\n", histogram[(signed long int)i], histogram[(signed long int)i] == 1 ? "" : "s", (signed int)i);

      printf("}\n");
    }
  }
}

// map_insert
// file libslack/map.c line 938
signed int map_insert(struct Map *map, const void *key, void *value, signed int replace)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=map_insert_unlocked(map, key, value, replace);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// map_insert_unlocked
// file libslack/map.c line 967
signed int map_insert_unlocked(struct Map *map, const void *key, void *value, signed int replace)
{
  struct Mapping *mapping;
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  signed int return_value_set_errno_1;
  signed int return_value_map_resize_2;
  signed int return_value_set_errno_3;
  struct List *return_value_list_remove_unlocked_5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if((double)map->items / (double)map->size >= table_resize_factor)
    {
      return_value_map_resize_2=map_resize(map);
      if(!(return_value_map_resize_2 == -1))
        goto __CPROVER_DUMP_L2;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h=map->hash(map->size, key);
      if(h >= map->size)
      {
        return_value_set_errno_3=set_errno(22);
        return return_value_set_errno_3;
      }

      else
        if(map->chain[(signed long int)h] == ((struct List *)NULL))
        {
          map->chain[(signed long int)h]=list_create((void (*)(void *))mapping_release);
          return -1;
        }

        else
        {
          chain = map->chain[(signed long int)h];
          length=list_length_unlocked(chain);
          if(length == -1l)
            return -1;

          else
          {
            c = (unsigned long int)0;
            if(!(c >= (unsigned long int)length))
            {
              void *return_value_list_item_unlocked_4;
              return_value_list_item_unlocked_4=list_item_unlocked(chain, (signed long int)c);
              mapping = (struct Mapping *)return_value_list_item_unlocked_4;
              signed int return_value;
              return_value=map->cmp(mapping->key, key);
              if(return_value == 0)
              {
                if(!(replace == 0))
                  return_value_list_remove_unlocked_5=list_remove_unlocked(chain, (signed long int)c);

                return -1;
              }

              c = c + 1ul;
            }

            void *return_value_1;
            return_value_1=map->copy(key);
            mapping=mapping_create(return_value_1, value, map->key_destroy, map->value_destroy);
            if(mapping == ((struct Mapping *)NULL))
              return -1;

            else
            {
              struct List *return_value_list_append_unlocked_6;
              return_value_list_append_unlocked_6=list_append_unlocked(chain, (void *)mapping);
              if(return_value_list_append_unlocked_6 == ((struct List *)NULL))
              {
                mapping_release(mapping);
                return -1;
              }

              else
              {
                map->items = map->items + 1ul;
                return 0;
              }
            }
          }
        }
    }
}

// map_keys
// file libslack/map.h line 91
struct List * map_keys(struct Map *map)
{
  struct List *return_value_map_keys_with_locker_1;
  return_value_map_keys_with_locker_1=map_keys_with_locker((struct Locker *)(void *)0, map);
  return return_value_map_keys_with_locker_1;
}

// map_keys_unlocked
// file libslack/map.c line 1691
struct List * map_keys_unlocked(struct Map *map)
{
  struct List *return_value_map_keys_with_locker_unlocked_1;
  return_value_map_keys_with_locker_unlocked_1=map_keys_with_locker_unlocked((struct Locker *)(void *)0, map);
  return return_value_map_keys_with_locker_unlocked_1;
}

// map_keys_with_locker
// file libslack/map.c line 1707
struct List * map_keys_with_locker(struct Locker *locker, struct Map *map)
{
  struct List *keys;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      keys=map_keys_with_locker_unlocked(locker, map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return keys;
    }
  }
}

// map_keys_with_locker_unlocked
// file libslack/map.c line 1737
struct List * map_keys_with_locker_unlocked(struct Locker *locker, struct Map *map)
{
  struct Mapper *mapper;
  struct List *keys;
  void *return_value_set_errnull_1;
  signed int return_value_mapper_has_next_2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    keys=list_create_with_locker(locker, (void (*)(void *))(void *)0);
    if(keys == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      mapper=mapper_create_unlocked(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        list_release(keys);
        return (struct List *)(void *)0;
      }

      else
      {
        do
        {
          return_value_mapper_has_next_2=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next_2 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          struct List *return_value_list_append_3;
          return_value_list_append_3=list_append(keys, mapping->key);
          if(return_value_list_append_3 == ((struct List *)NULL))
          {
            list_destroy(&keys);
            break;
          }

        }
        while((_Bool)1);
        mapper_release_unlocked(mapper);
        return keys;
      }
    }
  }
}

// map_next
// file libslack/map.h line 86
void * map_next(struct Map *map)
{
  _Bool tmp_if_expr_2;
  if(map == ((struct Map *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    void *return_value_mapper_next_3;
    return_value_mapper_next_3=mapper_next(map->mapper);
    return return_value_mapper_next_3;
  }
}

// map_next_mapping
// file libslack/map.h line 87
const struct Mapping * map_next_mapping(struct Map *map)
{
  _Bool tmp_if_expr_2;
  if(map == ((struct Map *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (const struct Mapping *)return_value_set_errnull_1;
  }

  else
  {
    const struct Mapping *return_value_mapper_next_mapping_3;
    return_value_mapper_next_mapping_3=mapper_next_mapping(map->mapper);
    return return_value_mapper_next_mapping_3;
  }
}

// map_own
// file libslack/map.c line 646
signed int map_own(struct Map *map, void (*destroy)(void *))
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(destroy == ((void (*)(void *))NULL) || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=map_own_unlocked(map, destroy);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// map_own_unlocked
// file libslack/map.c line 675
signed int map_own_unlocked(struct Map *map, void (*destroy)(void *))
{
  signed long int length;
  unsigned long int c;
  unsigned long int i;
  signed int return_value_set_errno_1;
  if(destroy == ((void (*)(void *))NULL) || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if(destroy == map->value_destroy)
      return 0;

    else
    {
      map->value_destroy = destroy;
      c = (unsigned long int)0;
      for( ; !(c >= map->size); c = c + 1ul)
      {
        struct List *chain = map->chain[(signed long int)c];
        if(!(chain == ((struct List *)NULL)))
        {
          length=list_length_unlocked(chain);
          if(length == -1l)
            return -1;

          i = (unsigned long int)0;
          for( ; !(i >= (unsigned long int)length); i = i + 1ul)
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked_2;
            return_value_list_item_unlocked_2=list_item_unlocked(chain, (signed long int)i);
            mapping = (struct Mapping *)return_value_list_item_unlocked_2;
            mapping->value_destroy = destroy;
          }
        }

      }
      return 0;
    }
}

// map_put
// file libslack/map.c line 904
signed int map_put(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_1;
  return_value_map_insert_1=map_insert(map, key, value, 1);
  return return_value_map_insert_1;
}

// map_put_unlocked
// file libslack/map.c line 919
signed int map_put_unlocked(struct Map *map, const void *key, void *value)
{
  signed int return_value_map_insert_unlocked_1;
  return_value_map_insert_unlocked_1=map_insert_unlocked(map, key, value, 1);
  return return_value_map_insert_unlocked_1;
}

// map_rdlock
// file libslack/map.h line 53
signed int map_rdlock(const struct Map *map)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->rdlock(map->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// map_release
// file libslack/map.h line 56
void map_release(struct Map *map)
{
  unsigned long int i;
  if(!(map == ((struct Map *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= map->size); i = i + 1ul)
      list_release(map->chain[(signed long int)i]);
    free((void *)map->chain);
    free((void *)map);
  }

}

// map_remove
// file libslack/map.h line 68
signed int map_remove(struct Map *map, const void *key)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=map_remove_unlocked(map, key);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// map_remove_current
// file libslack/map.h line 88
void map_remove_current(struct Map *map)
{
  _Bool tmp_if_expr_1;
  if(map == ((struct Map *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(map->mapper != ((struct Mapper *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    set_errno(22);

  else
    mapper_remove(map->mapper);
}

// map_remove_unlocked
// file libslack/map.c line 1061
signed int map_remove_unlocked(struct Map *map, const void *key)
{
  struct List *chain;
  signed long int length;
  unsigned long int h;
  unsigned long int c;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  signed int return_value_set_errno_3;
  if(key == NULL || map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    h=map->hash(map->size, key);
    if(h >= map->size)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      chain = map->chain[(signed long int)h];
      if(chain == ((struct List *)NULL))
      {
        return_value_set_errno_3=set_errno(2);
        return return_value_set_errno_3;
      }

      else
      {
        length=list_length_unlocked(chain);
        if(length == -1l)
          return -1;

        else
        {
          c = (unsigned long int)0;
          if(!(c >= (unsigned long int)length))
          {
            struct Mapping *mapping;
            void *return_value_list_item_unlocked_4;
            return_value_list_item_unlocked_4=list_item_unlocked(chain, (signed long int)c);
            mapping = (struct Mapping *)return_value_list_item_unlocked_4;
            signed int return_value;
            return_value=map->cmp(mapping->key, key);
            if(return_value == 0)
            {
              struct List *return_value_list_remove_unlocked_5;
              return_value_list_remove_unlocked_5=list_remove_unlocked(chain, (signed long int)c);
              if(return_value_list_remove_unlocked_5 == ((struct List *)NULL))
                return -1;

              map->items = map->items - 1ul;
              return 0;
            }

            c = c + 1ul;
          }

          signed int return_value_set_errno_6;
          return_value_set_errno_6=set_errno(2);
          return return_value_set_errno_6;
        }
      }
    }
  }
}

// map_resize
// file libslack/map.c line 795
static signed int map_resize(struct Map *map)
{
  unsigned long int map_resize__1__size = (unsigned long int)0;
  unsigned long int i;
  struct Mapper *mapper;
  struct Map *new_map;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  signed int return_value_mapper_has_next_3;
  signed int *return_value___errno_location_6;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    i = (unsigned long int)1;
    for( ; !(i >= num_table_sizes); i = i + 1ul)
      if(!(map->size >= table_sizes[(signed long int)i]))
      {
        map_resize__1__size = table_sizes[(signed long int)i];
        break;
      }

    if(i == num_table_sizes || map_resize__1__size == 0ul)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      new_map=map_create_generic_sized(map_resize__1__size, map->copy, map->cmp, map->hash, map->key_destroy, map->value_destroy);
      if(new_map == ((struct Map *)NULL))
        return -1;

      else
      {
        mapper=mapper_create_unlocked(map);
        if(mapper == ((struct Mapper *)NULL))
        {
          map_release(new_map);
          return -1;
        }

        else
        {
          do
          {
            return_value_mapper_has_next_3=mapper_has_next(mapper);
            if(!(return_value_mapper_has_next_3 == 1))
              break;

            const struct Mapping *mapping;
            mapping=mapper_next_mapping(mapper);
            signed int return_value_map_add_unlocked_4;
            return_value_map_add_unlocked_4=map_add_unlocked(new_map, mapping->key, mapping->value);
            if(return_value_map_add_unlocked_4 == -1)
            {
              mapper_release_unlocked(mapper);
              map_release(new_map);
              return -1;
            }

          }
          while((_Bool)1);
          mapper_release_unlocked(mapper);
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = 0;
          void (*return_value_map_disown_unlocked_7)(void *);
          return_value_map_disown_unlocked_7=map_disown_unlocked(map);
          if(return_value_map_disown_unlocked_7 == ((void (*)(void *))NULL))
          {
            return_value___errno_location_6=__errno_location();
            if(*return_value___errno_location_6 == 0)
              goto __CPROVER_DUMP_L10;

            map_release(new_map);
            return -1;
          }

          else
          {

          __CPROVER_DUMP_L10:
            ;
            i = (unsigned long int)0;
            for( ; !(i >= map->size); i = i + 1ul)
              list_release(map->chain[(signed long int)i]);
            free((void *)map->chain);
            map->size = new_map->size;
            map->items = new_map->items;
            map->chain = new_map->chain;
            map->value_destroy = new_map->value_destroy;
            free((void *)new_map);
            return 0;
          }
        }
      }
    }
  }
}

// map_size
// file libslack/map.h line 103
signed long int map_size(struct Map *map)
{
  unsigned long int map_size__1__size;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      map_size__1__size = map->items;
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return (signed long int)map_size__1__size;
    }
  }
}

// map_size_unlocked
// file libslack/map.h line 104
signed long int map_size_unlocked(const struct Map *map)
{
  signed int return_value_set_errno_1;
  if(map == ((const struct Map *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
    return (signed long int)map->items;
}

// map_unlock
// file libslack/map.h line 55
signed int map_unlock(const struct Map *map)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->unlock(map->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// map_values
// file libslack/map.h line 95
struct List * map_values(struct Map *map)
{
  struct List *return_value_map_values_with_locker_1;
  return_value_map_values_with_locker_1=map_values_with_locker((struct Locker *)(void *)0, map);
  return return_value_map_values_with_locker_1;
}

// map_values_unlocked
// file libslack/map.c line 1799
struct List * map_values_unlocked(struct Map *map)
{
  struct List *return_value_map_values_with_locker_unlocked_1;
  return_value_map_values_with_locker_unlocked_1=map_values_with_locker_unlocked((struct Locker *)(void *)0, map);
  return return_value_map_values_with_locker_unlocked_1;
}

// map_values_with_locker
// file libslack/map.c line 1815
struct List * map_values_with_locker(struct Locker *locker, struct Map *map)
{
  struct List *values;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      values=map_values_with_locker_unlocked(locker, map);
      if(!(map == ((struct Map *)NULL)))
      {
        if(!(map->locker == ((struct Locker *)NULL)))
        {
          return_value_1=map->locker->unlock(map->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      else
        return values;
    }
  }
}

// map_values_with_locker_unlocked
// file libslack/map.c line 1845
struct List * map_values_with_locker_unlocked(struct Locker *locker, struct Map *map)
{
  struct Mapper *mapper;
  struct List *values;
  void *return_value_set_errnull_1;
  signed int return_value_mapper_has_next_2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    values=list_create_with_locker(locker, (void (*)(void *))(void *)0);
    if(values == ((struct List *)NULL))
      return (struct List *)(void *)0;

    else
    {
      mapper=mapper_create_unlocked(map);
      if(mapper == ((struct Mapper *)NULL))
      {
        list_release(values);
        return (struct List *)(void *)0;
      }

      else
      {
        do
        {
          return_value_mapper_has_next_2=mapper_has_next(mapper);
          if(!(return_value_mapper_has_next_2 == 1))
            break;

          const struct Mapping *mapping;
          mapping=mapper_next_mapping(mapper);
          struct List *return_value_list_append_3;
          return_value_list_append_3=list_append(values, mapping->value);
          if(return_value_list_append_3 == ((struct List *)NULL))
          {
            list_destroy(&values);
            break;
          }

        }
        while((_Bool)1);
        mapper_release_unlocked(mapper);
        return values;
      }
    }
  }
}

// map_wrlock
// file libslack/map.h line 54
signed int map_wrlock(const struct Map *map)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(map == ((const struct Map *)NULL)))
  {
    if(!(map->locker == ((struct Locker *)NULL)))
    {
      return_value=map->locker->wrlock(map->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// mapper_create
// file libslack/map.h line 72
struct Mapper * mapper_create(struct Map *map)
{
  struct Mapper *return_value_mapper_create_wrlocked_1;
  return_value_mapper_create_wrlocked_1=mapper_create_wrlocked(map);
  return return_value_mapper_create_wrlocked_1;
}

// mapper_create_rdlocked
// file libslack/map.h line 73
struct Mapper * mapper_create_rdlocked(struct Map *map)
{
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->rdlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Mapper *)return_value_set_errnull_2;
    }

    else
    {
      struct Mapper *return_value_mapper_create_unlocked_5;
      return_value_mapper_create_unlocked_5=mapper_create_unlocked(map);
      return return_value_mapper_create_unlocked_5;
    }
  }
}

// mapper_create_unlocked
// file libslack/map.c line 1244
struct Mapper * mapper_create_unlocked(struct Map *map)
{
  struct Mapper *mapper;
  void *return_value_set_errnull_1;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull_1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct Mapper) /*40ul*/ );
    mapper = (struct Mapper *)return_value_malloc_2;
    if(mapper == ((struct Mapper *)NULL))
      return (struct Mapper *)(void *)0;

    else
    {
      mapper->map = map;
      mapper->chain_index = (signed long int)-1;
      mapper->item_index = (signed long int)-1;
      mapper->next_chain_index = (signed long int)-1;
      mapper->next_item_index = (signed long int)-1;
      return mapper;
    }
  }
}

// mapper_create_wrlocked
// file libslack/map.h line 74
struct Mapper * mapper_create_wrlocked(struct Map *map)
{
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  if(map == ((struct Map *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Mapper *)return_value_set_errnull_1;
  }

  else
  {
    if(!(map == ((struct Map *)NULL)))
    {
      if(!(map->locker == ((struct Locker *)NULL)))
      {
        return_value=map->locker->wrlock(map->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Mapper *)return_value_set_errnull_2;
    }

    else
    {
      struct Mapper *return_value_mapper_create_unlocked_5;
      return_value_mapper_create_unlocked_5=mapper_create_unlocked(map);
      return return_value_mapper_create_unlocked_5;
    }
  }
}

// mapper_destroy
// file libslack/map.h line 78
void * mapper_destroy(struct Mapper **mapper)
{
  if(!(mapper == ((struct Mapper **)NULL)))
  {
    if(!(*mapper == ((struct Mapper *)NULL)))
    {
      mapper_release(*mapper);
      *mapper = (struct Mapper *)(void *)0;
    }

  }

  return (void *)0;
}

// mapper_destroy_unlocked
// file libslack/map.c line 1341
void * mapper_destroy_unlocked(struct Mapper **mapper)
{
  if(!(mapper == ((struct Mapper **)NULL)))
  {
    if(!(*mapper == ((struct Mapper *)NULL)))
    {
      mapper_release_unlocked(*mapper);
      *mapper = (struct Mapper *)(void *)0;
    }

  }

  return (void *)0;
}

// mapper_has_next
// file libslack/map.h line 80
signed int mapper_has_next(struct Mapper *mapper)
{
  struct List *chain;
  signed long int length;
  signed int return_value_set_errno_1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    mapper->next_chain_index = mapper->chain_index;
    mapper->next_item_index = mapper->item_index;
    if(mapper->next_chain_index == -1l)
      mapper->next_chain_index = mapper->next_chain_index + 1l;

    for( ; !((unsigned long int)mapper->next_chain_index >= mapper->map->size); mapper->next_chain_index = mapper->next_chain_index + 1l)
      if(!(mapper->map->chain[mapper->next_chain_index] == ((struct List *)NULL)))
        break;

    if((unsigned long int)mapper->next_chain_index == mapper->map->size)
      return 0;

    else
    {
      chain = mapper->map->chain[mapper->next_chain_index];
      length=list_length_unlocked(chain);
      if(length == -1l)
        return -1;

      else
      {
        mapper->next_item_index = mapper->next_item_index + 1l;
        if(!(mapper->next_item_index >= length))
          return 1;

        else
        {
          do
          {
            mapper->next_chain_index = mapper->next_chain_index + 1l;
            for( ; !((unsigned long int)mapper->next_chain_index >= mapper->map->size); mapper->next_chain_index = mapper->next_chain_index + 1l)
              if(!(mapper->map->chain[mapper->next_chain_index] == ((struct List *)NULL)))
                break;

            if((unsigned long int)mapper->next_chain_index == mapper->map->size)
              return 0;

            chain = mapper->map->chain[mapper->next_chain_index];
            length=list_length_unlocked(chain);
            if(length == -1l)
              return -1;

          }
          while(length == 0l);
          mapper->next_item_index = (signed long int)0;
          return 1;
        }
      }
    }
  }
}

// mapper_next
// file libslack/map.h line 81
void * mapper_next(struct Mapper *mapper)
{
  void *return_value_set_errnull_1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    const struct Mapping *return_value_mapper_next_mapping_2;
    return_value_mapper_next_mapping_2=mapper_next_mapping(mapper);
    return return_value_mapper_next_mapping_2->value;
  }
}

// mapper_next_mapping
// file libslack/map.h line 82
const struct Mapping * mapper_next_mapping(struct Mapper *mapper)
{
  void *return_value_set_errnull_1;
  if(mapper == ((struct Mapper *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (const struct Mapping *)return_value_set_errnull_1;
  }

  else
  {
    mapper->chain_index = mapper->next_chain_index;
    mapper->item_index = mapper->next_item_index;
    void *return_value_list_item_unlocked_2;
    return_value_list_item_unlocked_2=list_item_unlocked(mapper->map->chain[mapper->chain_index], mapper->item_index);
    return (struct Mapping *)return_value_list_item_unlocked_2;
  }
}

// mapper_release
// file libslack/map.h line 76
void mapper_release(struct Mapper *mapper)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(mapper == ((struct Mapper *)NULL)))
  {
    if(!(mapper->map == ((struct Map *)NULL)))
    {
      if(!(mapper->map->locker == ((struct Locker *)NULL)))
      {
        return_value=mapper->map->locker->unlock(mapper->map->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
      free((void *)mapper);
  }

}

// mapper_release_unlocked
// file libslack/map.c line 1300
void mapper_release_unlocked(struct Mapper *mapper)
{
  if(!(mapper == ((struct Mapper *)NULL)))
    free((void *)mapper);

}

// mapper_remove
// file libslack/map.h line 83
void mapper_remove(struct Mapper *mapper)
{
  signed long int tmp_post_1;
  if(mapper == ((struct Mapper *)NULL))
    set_errno(22);

  else
    if(mapper->item_index == -1l)
      set_errno(22);

    else
    {
      tmp_post_1 = mapper->item_index;
      mapper->item_index = mapper->item_index - 1l;
      list_remove_unlocked(mapper->map->chain[mapper->chain_index], (signed long int)(unsigned long int)tmp_post_1);
      mapper->map->items = mapper->map->items - 1ul;
    }
}

// mapping_create
// file libslack/map.c line 238
static struct Mapping * mapping_create(void *key, void *value, void (*key_destroy)(void *), void (*value_destroy)(void *))
{
  struct Mapping *mapping;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Mapping) /*32ul*/ );
  mapping = (struct Mapping *)return_value_malloc_1;
  if(mapping == ((struct Mapping *)NULL))
    return (struct Mapping *)(void *)0;

  else
  {
    mapping->key = key;
    mapping->value = value;
    mapping->key_destroy = key_destroy;
    mapping->value_destroy = value_destroy;
    return mapping;
  }
}

// mapping_key
// file libslack/map.h line 89
const void * mapping_key(const struct Mapping *mapping)
{
  void *return_value_set_errnull_1;
  if(mapping == ((const struct Mapping *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    return mapping->key;
}

// mapping_release
// file libslack/map.c line 261
static void mapping_release(struct Mapping *mapping)
{
  if(!(mapping == ((struct Mapping *)NULL)))
  {
    if(!(mapping->key_destroy == ((void (*)(void *))NULL)))
      mapping->key_destroy(mapping->key);

    if(!(mapping->value_destroy == ((void (*)(void *))NULL)))
      mapping->value_destroy(mapping->value);

    free((void *)mapping);
  }

}

// mapping_value
// file libslack/map.h line 90
const void * mapping_value(const struct Mapping *mapping)
{
  void *return_value_set_errnull_1;
  if(mapping == ((const struct Mapping *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    return mapping->value;
}

// measure
// file libslack/agent.c line 2017
static void measure(struct Agent *agent, signed int fd, struct timeval *now)
{
  struct activity_t *activity;
  struct timeval delta[1l];
  signed int msec;
  signed int prev_dt;
  signed int prev_ddt;
  struct activity_t *tmp_if_expr_1;
  if(fd == -1)
    tmp_if_expr_1 = agent->tempo;

  else
    tmp_if_expr_1 = &agent->activity[agent->ids[(signed long int)fd]];
  activity = tmp_if_expr_1;
  switch(activity->detail)
  {
    case (unsigned long int)0:
    {
      activity->since = *now;
      activity->detail = (unsigned long int)1;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)1:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      activity->dt = msec;
      activity->since = *now;
      activity->detail = (unsigned long int)2;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)2:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      prev_dt = activity->dt;
      activity->dt = msec;
      activity->ddt = activity->dt - prev_dt;
      activity->since = *now;
      activity->detail = (unsigned long int)3;
      goto __CPROVER_DUMP_L7;
    }
    case (unsigned long int)3:

    case (unsigned long int)4:
    {
      timeval_diff(&activity->since, now, delta);
      msec = (signed int)(delta[0l].tv_sec * (signed long int)1000 + delta[0l].tv_usec / (signed long int)1000);
      prev_dt = activity->dt;
      activity->dt = msec;
      prev_ddt = activity->ddt;
      activity->ddt = activity->dt - prev_dt;
      activity->dddt = activity->ddt - prev_ddt;
      activity->since = *now;
      activity->detail = (unsigned long int)4;
    }
    default:

      __CPROVER_DUMP_L7:
        ;
  }
}

// mem_create_secure
// file libslack/mem.c line 270
void * mem_create_secure(unsigned long int size)
{
  char *addr;
  char *lock;
  size = size + sizeof(unsigned long int) /*8ul*/ ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  addr = (char *)return_value_malloc_1;
  if(addr == ((char *)NULL))
    return (void *)0;

  else
  {
    lock = addr;
    signed int return_value_mlock_2;
    return_value_mlock_2=mlock((const void *)lock, size);
    if(return_value_mlock_2 == -1)
    {
      free((void *)addr);
      return (void *)0;
    }

    else
    {
      *((unsigned long int *)lock) = size;
      lock = lock + (signed long int)sizeof(unsigned long int) /*8ul*/ ;
      return (void *)lock;
    }
  }
}

// mem_create_space
// file libslack/mem.c line 469
void * mem_create_space(unsigned long int size, ...)
{
  unsigned long int dim[32l];
  unsigned long int d;
  unsigned long int i;
  unsigned long int j;
  unsigned long int lengths[32l];
  unsigned long int starts[32l];
  unsigned long int sizes[32l];
  char *space;
  unsigned long int arg;
  unsigned long int length;
  __builtin_va_list args;
  va_start(args, size);
  d = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(d >= 32ul))
    {
      arg=va_arg(args, __typeof__(arg));
      tmp_if_expr_1 = arg != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    dim[(signed long int)d] = arg;
    d = d + 1ul;
  }
  while((_Bool)1);
  va_end(args);
  i = (unsigned long int)0;
  length = i;
  for( ; !(i >= d); i = i + 1ul)
  {
    starts[(signed long int)i] = length;
    sizes[(signed long int)i] = i == d - (unsigned long int)1 ? size : sizeof(void *) /*8ul*/ ;
    lengths[(signed long int)i] = sizes[(signed long int)i];
    j = (unsigned long int)0;
    for( ; i >= j; j = j + 1ul)
      lengths[(signed long int)i] = lengths[(signed long int)i] * dim[(signed long int)j];
    length = length + lengths[(signed long int)i];
  }
  void *return_value_calloc_2;
  return_value_calloc_2=calloc(length, (unsigned long int)1);
  space = (char *)return_value_calloc_2;
  if(space == ((char *)NULL))
    return (void *)0;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= d + 18446744073709551615ul); i = i + 1ul)
    {
      unsigned long int num = dim[(signed long int)i];
      j = (unsigned long int)0;
      for( ; !(j >= i); j = j + 1ul)
        num = num * dim[(signed long int)j];
      j = (unsigned long int)0;
      for( ; !(j >= num); j = j + 1ul)
        *((char **)(space + (signed long int)starts[(signed long int)i] + (signed long int)(j * sizes[(signed long int)i]))) = space + (signed long int)starts[(signed long int)(i + (unsigned long int)1)] + (signed long int)(j * dim[(signed long int)(i + (unsigned long int)1)] * sizes[(signed long int)(i + (unsigned long int)1)]);
    }
    return (void *)space;
  }
}

// mem_destroy
// file libslack/mem.h line 48
void * mem_destroy(void **mem)
{
  if(!(mem == ((void **)NULL)))
  {
    if(!(*mem == NULL))
    {
      free(*mem);
      *mem = (void *)0;
    }

  }

  return (void *)0;
}

// mem_destroy_secure
// file libslack/mem.c line 373
void * mem_destroy_secure(void **mem)
{
  if(!(mem == ((void **)NULL)))
  {
    if(!(*mem == NULL))
    {
      mem_release_secure(*mem);
      *mem = (void *)0;
    }

  }

  return (void *)0;
}

// mem_release_secure
// file libslack/mem.c line 333
void mem_release_secure(void *mem)
{
  char *addr;
  char *lock;
  unsigned long int mem_release_secure__1__size;
  if(!(mem == NULL))
  {
    lock = (char *)mem;
    lock = lock - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
    mem_release_secure__1__size = *((unsigned long int *)lock);
    addr = lock;
    memset((void *)lock, 0xff, mem_release_secure__1__size);
    memset((void *)lock, 0xaa, mem_release_secure__1__size);
    memset((void *)lock, 0x55, mem_release_secure__1__size);
    memset((void *)lock, 0x00, mem_release_secure__1__size);
    munlock((const void *)lock, mem_release_secure__1__size);
    free((void *)addr);
  }

}

// mem_resize_fn
// file libslack/mem.h line 46
void * mem_resize_fn(void **mem, unsigned long int size)
{
  void *ptr;
  void *return_value_set_errnull_1;
  if(mem == ((void **)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    ptr=realloc(*mem, size);
    if(ptr == NULL && !(size == 0ul))
      return (void *)0;

    else
    {
      *mem = ptr;
      return *mem;
    }
  }
}

// mem_space_start
// file libslack/mem.c line 526
unsigned long int mem_space_start(unsigned long int size, ...)
{
  unsigned long int dim[32l];
  unsigned long int d;
  unsigned long int i;
  unsigned long int j;
  unsigned long int lengths[32l];
  unsigned long int arg;
  unsigned long int length;
  __builtin_va_list args;
  va_start(args, size);
  d = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(d >= 32ul))
    {
      arg=va_arg(args, __typeof__(arg));
      tmp_if_expr_1 = arg != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    dim[(signed long int)d] = arg;
    d = d + 1ul;
  }
  while((_Bool)1);
  va_end(args);
  i = (unsigned long int)0;
  length = i;
  for( ; !(i >= d); i = i + 1ul)
  {
    lengths[(signed long int)i] = i == d - (unsigned long int)1 ? size : sizeof(void *) /*8ul*/ ;
    j = (unsigned long int)0;
    for( ; i >= j; j = j + 1ul)
      lengths[(signed long int)i] = lengths[(signed long int)i] * dim[(signed long int)j];
    length = length + lengths[(signed long int)i];
  }
  return length - lengths[(signed long int)(d - (unsigned long int)1)];
}

// mem_strdup
// file libslack/mem.h line 54
char * mem_strdup(const char *str)
{
  unsigned long int mem_strdup__1__size;
  char *copy;
  void *return_value_set_errnull_1;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    mem_strdup__1__size = return_value_strlen_2 + (unsigned long int)1;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(mem_strdup__1__size * sizeof(char) /*1ul*/ );
    copy = (char *)return_value_malloc_3;
    if(copy == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      void *return_value_memcpy_4;
      return_value_memcpy_4=memcpy((void *)copy, (const void *)str, mem_strdup__1__size);
      return (char *)return_value_memcpy_4;
    }
  }
}

// msg
// file libslack/err.c line 149
void msg(const char *format, ...)
{
  void **args = (void **)&format;
  vmsg(format, args);
  args = ((void **)NULL);
}

// msg_add_plex
// file libslack/msg.c line 1222
signed int msg_add_plex(struct Msg *mesg, struct Msg *item)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=msg_add_plex_unlocked(mesg, item);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// msg_add_plex_unlocked
// file libslack/msg.c line 1251
signed int msg_add_plex_unlocked(struct Msg *mesg, struct Msg *item)
{
  _Bool tmp_if_expr_2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = mesg->type != 4 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_msg_plexdata_add_3;
    return_value_msg_plexdata_add_3=msg_plexdata_add((struct MsgPlexData *)mesg->data, item);
    return return_value_msg_plexdata_add_3;
  }
}

// msg_create
// file libslack/msg.c line 230
struct Msg * msg_create(signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *))
{
  struct Msg *return_value_msg_create_with_locker_1;
  return_value_msg_create_with_locker_1=msg_create_with_locker((struct Locker *)(void *)0, type, out, data, destroy);
  return return_value_msg_create_with_locker_1;
}

// msg_create_fd
// file libslack/msg.c line 533
struct Msg * msg_create_fd(signed int fd)
{
  struct Msg *return_value_msg_create_fd_with_locker_1;
  return_value_msg_create_fd_with_locker_1=msg_create_fd_with_locker((struct Locker *)(void *)0, fd);
  return return_value_msg_create_fd_with_locker_1;
}

// msg_create_fd_with_locker
// file libslack/msg.c line 549
struct Msg * msg_create_fd_with_locker(struct Locker *locker, signed int fd)
{
  signed int *data;
  struct Msg *mesg;
  data=msg_fddata_create(fd);
  if(data == ((signed int *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 1, msg_out_fd, (void *)data, (void (*)(void *))msg_fddata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_fddata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_file
// file libslack/msg.c line 763
struct Msg * msg_create_file(const char *path)
{
  struct Msg *return_value_msg_create_file_with_locker_1;
  return_value_msg_create_file_with_locker_1=msg_create_file_with_locker((struct Locker *)(void *)0, path);
  return return_value_msg_create_file_with_locker_1;
}

// msg_create_file_with_locker
// file libslack/msg.c line 779
struct Msg * msg_create_file_with_locker(struct Locker *locker, const char *path)
{
  struct MsgFileData *data;
  struct Msg *mesg;
  data=msg_filedata_create(path);
  if(data == ((struct MsgFileData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 2, msg_out_file, (void *)data, (void (*)(void *))msg_filedata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_filedata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_plex
// file libslack/msg.c line 1177
struct Msg * msg_create_plex(struct Msg *msg1, struct Msg *msg2)
{
  struct Msg *return_value_msg_create_plex_with_locker_1;
  return_value_msg_create_plex_with_locker_1=msg_create_plex_with_locker((struct Locker *)(void *)0, msg1, msg2);
  return return_value_msg_create_plex_with_locker_1;
}

// msg_create_plex_with_locker
// file libslack/msg.c line 1193
struct Msg * msg_create_plex_with_locker(struct Locker *locker, struct Msg *msg1, struct Msg *msg2)
{
  struct MsgPlexData *data;
  struct Msg *mesg;
  data=msg_plexdata_create(msg1, msg2);
  if(data == ((struct MsgPlexData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 4, msg_out_plex, (void *)data, (void (*)(void *))msg_plexdata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_plexdata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_stderr
// file libslack/msg.c line 579
struct Msg * msg_create_stderr(void)
{
  struct Msg *return_value_msg_create_fd_with_locker_1;
  return_value_msg_create_fd_with_locker_1=msg_create_fd_with_locker((struct Locker *)(void *)0, 2);
  return return_value_msg_create_fd_with_locker_1;
}

// msg_create_stderr_with_locker
// file libslack/msg.c line 595
struct Msg * msg_create_stderr_with_locker(struct Locker *locker)
{
  struct Msg *return_value_msg_create_fd_with_locker_1;
  return_value_msg_create_fd_with_locker_1=msg_create_fd_with_locker(locker, 2);
  return return_value_msg_create_fd_with_locker_1;
}

// msg_create_stdout
// file libslack/msg.c line 613
struct Msg * msg_create_stdout(void)
{
  struct Msg *return_value_msg_create_fd_with_locker_1;
  return_value_msg_create_fd_with_locker_1=msg_create_fd_with_locker((struct Locker *)(void *)0, 1);
  return return_value_msg_create_fd_with_locker_1;
}

// msg_create_stdout_with_locker
// file libslack/msg.c line 629
struct Msg * msg_create_stdout_with_locker(struct Locker *locker)
{
  struct Msg *return_value_msg_create_fd_with_locker_1;
  return_value_msg_create_fd_with_locker_1=msg_create_fd_with_locker(locker, 1);
  return return_value_msg_create_fd_with_locker_1;
}

// msg_create_syslog
// file libslack/msg.c line 897
struct Msg * msg_create_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *return_value_msg_create_syslog_with_locker_1;
  return_value_msg_create_syslog_with_locker_1=msg_create_syslog_with_locker((struct Locker *)(void *)0, ident, option, facility, priority);
  return return_value_msg_create_syslog_with_locker_1;
}

// msg_create_syslog_with_locker
// file libslack/msg.c line 913
struct Msg * msg_create_syslog_with_locker(struct Locker *locker, const char *ident, signed int option, signed int facility, signed int priority)
{
  struct MsgSyslogData *data;
  struct Msg *mesg;
  data=msg_sysdata_create(ident, option, facility, priority);
  if(data == ((struct MsgSyslogData *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg=msg_create_with_locker(locker, 3, msg_out_syslog, (void *)data, (void (*)(void *))msg_sysdata_release);
    if(mesg == ((struct Msg *)NULL))
    {
      msg_sysdata_release(data);
      return (struct Msg *)(void *)0;
    }

    else
      return mesg;
  }
}

// msg_create_with_locker
// file libslack/msg.c line 246
struct Msg * msg_create_with_locker(struct Locker *locker, signed int type, void (*out)(void *, const void *, unsigned long int), void *data, void (*destroy)(void *))
{
  struct Msg *mesg;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Msg) /*40ul*/ );
  mesg = (struct Msg *)return_value_malloc_1;
  if(mesg == ((struct Msg *)NULL))
    return (struct Msg *)(void *)0;

  else
  {
    mesg->type = type;
    mesg->out = out;
    mesg->data = data;
    mesg->destroy = destroy;
    mesg->locker = locker;
    return mesg;
  }
}

// msg_destroy
// file libslack/msg.c line 358
void * msg_destroy(struct Msg **mesg)
{
  if(!(mesg == ((struct Msg **)NULL)))
  {
    if(!(*mesg == ((struct Msg *)NULL)))
    {
      msg_release(*mesg);
      *mesg = (struct Msg *)(void *)0;
    }

  }

  return (void *)0;
}

// msg_fddata_create
// file libslack/msg.c line 478
static signed int * msg_fddata_create(signed int fd)
{
  signed int *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(signed int) /*4ul*/ );
  data = (signed int *)return_value_malloc_1;
  if(data == ((signed int *)NULL))
    return (signed int *)(void *)0;

  else
  {
    *data = fd;
    return data;
  }
}

// msg_fddata_release
// file libslack/msg.c line 499
static void msg_fddata_release(signed int *data)
{
  free((void *)data);
}

// msg_filedata_create
// file libslack/msg.c line 671
static struct MsgFileData * msg_filedata_create(const char *path)
{
  struct MsgFileData *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct MsgFileData) /*4ul*/ );
  data = (struct MsgFileData *)return_value_malloc_1;
  if(data == ((struct MsgFileData *)NULL))
    return (struct MsgFileData *)(void *)0;

  else
  {
    signed int return_value_msg_filedata_init_2;
    return_value_msg_filedata_init_2=msg_filedata_init(data, path);
    if(return_value_msg_filedata_init_2 == -1)
    {
      free((void *)data);
      return (struct MsgFileData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_filedata_init
// file libslack/msg.c line 646
static signed int msg_filedata_init(struct MsgFileData *data, const char *path)
{
  unsigned int mode;
  signed int return_value_set_errno_1;
  if(path == ((const char *)NULL) || data == ((struct MsgFileData *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    mode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
    data->fd=open(path, 01 | 0100 | 02000, mode);
    if(data->fd == -1)
      return -1;

    else
      return 0;
  }
}

// msg_filedata_release
// file libslack/msg.c line 696
static void msg_filedata_release(struct MsgFileData *data)
{
  if(!(data == ((struct MsgFileData *)NULL)))
  {
    if(!(data->fd == -1))
      close(data->fd);

    free((void *)data);
  }

}

// msg_out
// file libslack/msg.h line 50
void msg_out(struct Msg *dst, const char *format, ...)
{
  void **args = (void **)&format;
  vmsg_out(dst, format, args);
  args = ((void **)NULL);
}

// msg_out_fd
// file libslack/msg.c line 513
static void msg_out_fd(void *data, const void *mesg, unsigned long int mesglen)
{
  signed long int return_value_write_1;
  if(!(data == NULL) && !(mesg == NULL))
    return_value_write_1=write(*((signed int *)data), mesg, mesglen);

}

// msg_out_file
// file libslack/msg.c line 717
static void msg_out_file(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgFileData *dst = (struct MsgFileData *)data;
  char buf[8192l];
  unsigned long int buflen;
  signed int err;
  signed long int t;
  t=time((signed long int *)(void *)0);
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(timestamp_format_locker == ((struct Locker *)NULL)))
  {
    return_value=timestamp_format_locker->rdlock(timestamp_format_locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  err = tmp_if_expr_1;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  signed long int return_value_write_4;
  if(!(err == 0))
    set_errno(err);

  else
  {
    struct tm *return_value_localtime_2;
    return_value_localtime_2=localtime(&t);
    strftime(buf, (unsigned long int)8192, timestamp_format, return_value_localtime_2);
    if(!(timestamp_format_locker == ((struct Locker *)NULL)))
    {
      return_value_1=timestamp_format_locker->unlock(timestamp_format_locker->lock);
      tmp_if_expr_3 = return_value_1;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
      set_errno(err);

    else
    {
      buflen=strlen(buf);
      if(buflen + mesglen >= 8192ul)
        mesglen = mesglen - ((unsigned long int)8192 - buflen);

      memmove((void *)(buf + (signed long int)buflen), mesg, mesglen);
      if(!(mesg == NULL) && !(dst == ((struct MsgFileData *)NULL)))
      {
        if(!(dst->fd == -1))
          return_value_write_4=write(dst->fd, (const void *)buf, buflen + mesglen);

      }

    }
  }
}

// msg_out_plex
// file libslack/msg.c line 1147
static void msg_out_plex(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgPlexData *dst = (struct MsgPlexData *)data;
  unsigned long int i;
  if(!(mesg == NULL) && !(dst == ((struct MsgPlexData *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= dst->length); i = i + 1ul)
    {
      struct Msg *out = dst->list[(signed long int)i];
      if(!(out == ((struct Msg *)NULL)))
      {
        if(!(out->out == ((void (*)(void *, const void *, unsigned long int))NULL)))
          out->out(out->data, mesg, mesglen);

      }

    }
  }

}

// msg_out_syslog
// file libslack/msg.c line 875
static void msg_out_syslog(void *data, const void *mesg, unsigned long int mesglen)
{
  struct MsgSyslogData *dst = (struct MsgSyslogData *)data;
  if(!(mesg == NULL) && !(dst == ((struct MsgSyslogData *)NULL)))
  {
    if(!(dst->facility == -1))
      syslog(dst->facility | dst->priority, "%*.*s", (signed int)mesglen, (signed int)mesglen, (char *)mesg);

  }

}

// msg_out_unlocked
// file libslack/msg.h line 51
void msg_out_unlocked(struct Msg *dst, const char *format, ...)
{
  void **args = (void **)&format;
  vmsg_out_unlocked(dst, format, args);
  args = ((void **)NULL);
}

// msg_plexdata_add
// file libslack/msg.c line 1070
static signed int msg_plexdata_add(struct MsgPlexData *data, struct Msg *mesg)
{
  if(data->length == data->size)
  {
    unsigned long int new_size = data->size << 1;
    struct Msg **new_list;
    void *return_value_mem_resize_fn_1;
    return_value_mem_resize_fn_1=mem_resize_fn((void **)&data->list, new_size * sizeof(struct Msg *) /*8ul*/ );
    new_list = (struct Msg **)return_value_mem_resize_fn_1;
    if(new_list == ((struct Msg **)NULL))
      return -1;

    data->size = new_size;
    data->list = new_list;
  }

  unsigned long int tmp_post_2 = data->length;
  data->length = data->length + 1ul;
  data->list[(signed long int)tmp_post_2] = mesg;
  return 0;
}

// msg_plexdata_create
// file libslack/msg.c line 1099
static struct MsgPlexData * msg_plexdata_create(struct Msg *msg1, struct Msg *msg2)
{
  struct MsgPlexData *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct MsgPlexData) /*24ul*/ );
  data = (struct MsgPlexData *)return_value_malloc_1;
  if(data == ((struct MsgPlexData *)NULL))
    return (struct MsgPlexData *)(void *)0;

  else
  {
    signed int return_value_msg_plexdata_init_2;
    return_value_msg_plexdata_init_2=msg_plexdata_init(data, msg1, msg2);
    if(return_value_msg_plexdata_init_2 == -1)
    {
      free((void *)data);
      return (struct MsgPlexData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_plexdata_init
// file libslack/msg.c line 1048
static signed int msg_plexdata_init(struct MsgPlexData *data, struct Msg *msg1, struct Msg *msg2)
{
  data->size = (unsigned long int)2;
  data->length = data->size;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(data->size * sizeof(struct Msg *) /*8ul*/ );
  data->list = (struct Msg **)return_value_malloc_1;
  if(data->list == ((struct Msg **)NULL))
    return -1;

  else
  {
    data->list[(signed long int)0] = msg1;
    data->list[(signed long int)1] = msg2;
    return 0;
  }
}

// msg_plexdata_release
// file libslack/msg.c line 1124
static void msg_plexdata_release(struct MsgPlexData *data)
{
  unsigned long int i;
  if(!(data == ((struct MsgPlexData *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= data->length); i = i + 1ul)
      msg_destroy(data->list + (signed long int)i);
    free((void *)data->list);
    free((void *)data);
  }

}

// msg_rdlock
// file libslack/msg.c line 282
signed int msg_rdlock(struct Msg *mesg)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->rdlock(mesg->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// msg_release
// file libslack/msg.c line 337
void msg_release(struct Msg *mesg)
{
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->destroy == ((void (*)(void *))NULL)))
      mesg->destroy(mesg->data);

    free((void *)mesg);
  }

}

// msg_set_timestamp_format
// file libslack/msg.c line 1271
const char * msg_set_timestamp_format(const char *format)
{
  const char *save;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  void *return_value_set_errnull_4;
  if(format == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (const char *)return_value_set_errnull_1;
  }

  else
  {
    if(!(timestamp_format_locker == ((struct Locker *)NULL)))
    {
      return_value=timestamp_format_locker->wrlock(timestamp_format_locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (const char *)return_value_set_errnull_2;
    }

    else
    {
      save = timestamp_format;
      timestamp_format = format;
      if(!(timestamp_format_locker == ((struct Locker *)NULL)))
      {
        return_value_1=timestamp_format_locker->unlock(timestamp_format_locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errnull_4=set_errnull(err);
        return (const char *)return_value_set_errnull_4;
      }

      else
        return save;
    }
  }
}

// msg_set_timestamp_format_locker
// file libslack/msg.c line 1304
signed int msg_set_timestamp_format_locker(struct Locker *locker)
{
  signed int return_value_set_errno_1;
  if(!(timestamp_format_locker == ((struct Locker *)NULL)))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    timestamp_format_locker = locker;
    return 0;
  }
}

// msg_sysdata_create
// file libslack/msg.c line 832
static struct MsgSyslogData * msg_sysdata_create(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct MsgSyslogData *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct MsgSyslogData) /*8ul*/ );
  data = (struct MsgSyslogData *)return_value_malloc_1;
  if(data == ((struct MsgSyslogData *)NULL))
    return (struct MsgSyslogData *)(void *)0;

  else
  {
    signed int return_value_msg_sysdata_init_2;
    return_value_msg_sysdata_init_2=msg_sysdata_init(data, ident, option, facility, priority);
    if(return_value_msg_sysdata_init_2 == -1)
    {
      free((void *)data);
      return (struct MsgSyslogData *)(void *)0;
    }

    else
      return data;
  }
}

// msg_sysdata_init
// file libslack/msg.c line 808
static signed int msg_sysdata_init(struct MsgSyslogData *data, const char *ident, signed int option, signed int facility, signed int priority)
{
  signed int return_value_set_errno_1;
  if(data == ((struct MsgSyslogData *)NULL) || facility == -1)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    data->facility = facility & 0x03f8;
    data->priority = priority & 0x07;
    openlog(ident, option, 0);
    return 0;
  }
}

// msg_sysdata_release
// file libslack/msg.c line 857
static void msg_sysdata_release(struct MsgSyslogData *data)
{
  if(!(data == ((struct MsgSyslogData *)NULL)))
  {
    free((void *)data);
    closelog();
  }

}

// msg_syslog_set_facility
// file libslack/msg.c line 941
struct Msg * msg_syslog_set_facility(struct Msg *mesg, signed int facility)
{
  struct Msg *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull_1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Msg *)return_value_set_errnull_2;
    }

    else
    {
      ret=msg_syslog_set_facility_unlocked(mesg, facility);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct Msg *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// msg_syslog_set_facility_unlocked
// file libslack/msg.c line 971
struct Msg * msg_syslog_set_facility_unlocked(struct Msg *mesg, signed int facility)
{
  struct MsgSyslogData *data;
  _Bool tmp_if_expr_2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = mesg->type != 3 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull_1;
  }

  else
  {
    data = (struct MsgSyslogData *)mesg->data;
    data->facility = facility;
    return mesg;
  }
}

// msg_syslog_set_priority
// file libslack/msg.c line 995
struct Msg * msg_syslog_set_priority(struct Msg *mesg, signed int priority)
{
  struct Msg *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(mesg == ((struct Msg *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull_1;
  }

  else
  {
    if(!(mesg == ((struct Msg *)NULL)))
    {
      if(!(mesg->locker == ((struct Locker *)NULL)))
      {
        return_value=mesg->locker->wrlock(mesg->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct Msg *)return_value_set_errnull_2;
    }

    else
    {
      ret=msg_syslog_set_priority_unlocked(mesg, priority);
      if(!(mesg == ((struct Msg *)NULL)))
      {
        if(!(mesg->locker == ((struct Locker *)NULL)))
        {
          return_value_1=mesg->locker->unlock(mesg->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct Msg *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// msg_syslog_set_priority_unlocked
// file libslack/msg.h line 67
struct Msg * msg_syslog_set_priority_unlocked(struct Msg *mesg, signed int priority)
{
  struct MsgSyslogData *data;
  _Bool tmp_if_expr_2;
  if(mesg == ((struct Msg *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = mesg->type != 3 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct Msg *)return_value_set_errnull_1;
  }

  else
  {
    data = (struct MsgSyslogData *)mesg->data;
    data->priority = priority;
    return mesg;
  }
}

// msg_unlock
// file libslack/msg.h line 47
signed int msg_unlock(struct Msg *mesg)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->unlock(mesg->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// msg_wrlock
// file libslack/msg.h line 46
signed int msg_wrlock(struct Msg *mesg)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(mesg == ((struct Msg *)NULL)))
  {
    if(!(mesg->locker == ((struct Locker *)NULL)))
    {
      return_value=mesg->locker->wrlock(mesg->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// mt_test
// file libslack/map.c line 2675
void mt_test(signed int test, struct Locker *locker)
{
  mtmap=map_create_generic_with_locker(locker, (void * (*)(const void *))direct_copy, (signed int (*)(const void *, const void *))direct_cmp, (unsigned long int (*)(unsigned long int, const void *))direct_hash, (void (*)(void *))(void *)0, (void (*)(void *))(void *)0);
  _Bool tmp_if_expr_3;
  signed int return_value_pipe_2;
  signed long int return_value_read_6;
  signed int *return_value___errno_location_7;
  if(mtmap == ((struct Map *)NULL))
  {
    errors = errors + 1;
    printf("Test%d: map_create_generic_with_locker(NULL) failed\n", test);
  }

  else
  {
    union pthread_attr_t attr;
    unsigned long int id;
    signed int i;
    char ack;
    signed int return_value_pipe_1;
    return_value_pipe_1=pipe(size);
    if(return_value_pipe_1 == -1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_pipe_2=pipe(barrier);
      tmp_if_expr_3 = return_value_pipe_2 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      errors = errors + 1;
      printf("Test%d: failed to perform test: pipe() failed\n", test);
    }

    else
    {
      signed int return_value_getpid_4;
      return_value_getpid_4=getpid();
      signed long int return_value_time_5;
      return_value_time_5=time((signed long int *)(void *)0);
      srand((unsigned int)((signed long int)return_value_getpid_4 ^ return_value_time_5));
      pthread_attr_init(&attr);
      pthread_attr_setdetachstate(&attr, 1);
      pthread_create(&id, &attr, produce, (void *)&test);
      pthread_create(&id, &attr, consume, (void *)&test);
      static signed int iid[13l] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)0));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)1));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)2));
      pthread_create(&id, &attr, iterate_builtin, (void *)(iid + (signed long int)3));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)4));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)5));
      pthread_create(&id, &attr, iterate_rdlocked, (void *)(iid + (signed long int)6));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)7));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)8));
      pthread_create(&id, &attr, iterate_wrlocked, (void *)(iid + (signed long int)9));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)10));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)11));
      pthread_create(&id, &attr, reader, (void *)(iid + (signed long int)12));
      pthread_attr_destroy(&attr);
      i = 0;
      for( ; !(i >= 15); i = i + 1)
        do
        {
          return_value_read_6=read(barrier[(signed long int)0], (void *)&ack, (unsigned long int)1);
          if(!(return_value_read_6 == -1l))
            break;

          return_value___errno_location_7=__errno_location();
          if(!(*return_value___errno_location_7 == 4))
            break;

        }
        while((_Bool)1);
      map_destroy(&mtmap);
      if(!(mtmap == ((struct Map *)NULL)))
      {
        errors = errors + 1;
        printf("Test%d: map_destroy(&mtmap) failed\n", test);
      }

      close(size[(signed long int)0]);
      close(size[(signed long int)1]);
      close(barrier[(signed long int)0]);
      close(barrier[(signed long int)1]);
    }
  }
}

// nap
// file libslack/fio.c line 350
signed int nap(signed long int sec, signed long int usec)
{
  struct timeval tv[1l];
  signed int return_value_set_errno_1;
  if(!(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    tv[0l].tv_sec = sec;
    tv[0l].tv_usec = usec;
    signed int return_value_select_2;
    return_value_select_2=select(0, (struct anonymous_10 *)(void *)0, (struct anonymous_10 *)(void *)0, (struct anonymous_10 *)(void *)0, tv);
    return return_value_select_2;
  }
}

// net_client
// file libslack/net.c line 369
signed int net_client(const char *host, const char *service, unsigned short int port, signed long int timeout, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_client_1;
  return_value_net_create_client_1=net_create_client(host, service, port, (unsigned short int)0, 1, 0, timeout, sockopts, addr, addrsize);
  return return_value_net_create_client_1;
}

// net_client_connect
// file libslack/net.c line 709
static signed int net_client_connect(struct sockaddr *remoteaddr, unsigned long int remotesize, unsigned short int localport, signed int type, signed int protocol, signed int timeout, struct sockopt_t *sockopts)
{
  signed int sockfd;
  signed int rc;
  sockfd=socket((signed int)remoteaddr->sa_family, type, protocol);
  signed int return_value_net_options_1;
  _Bool tmp_if_expr_7;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_4;
  signed int return_value_nonblock_on_8;
  signed int *return_value___errno_location_11;
  signed int return_value_set_errno_13;
  signed int return_value_nonblock_off_14;
  if(sockfd == -1)
    return -1;

  else
    if(!(sockopts == ((struct sockopt_t *)NULL)))
    {
      return_value_net_options_1=net_options(sockfd, sockopts);
      if(!(return_value_net_options_1 == -1))
        goto __CPROVER_DUMP_L2;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(type == 2)
      {
        if(!(localport == 0))
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (signed int)remoteaddr->sa_family == 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_7)
        {
          union sockaddr_any_t localany;
          struct sockaddr *localaddr;
          unsigned long int localsize;
          if((signed int)remoteaddr->sa_family == 1)
          {
            localaddr=net_unaddr(&localany.un, (unsigned long int)1, "");
            localsize = sizeof(struct sockaddr_un) /*110ul*/ ;
          }

          else
          {
            signed int return_value_inet6_required_5;
            return_value_inet6_required_5=inet6_required();
            if(!(return_value_inet6_required_5 == 0))
            {
              unsigned short int __v;
              unsigned short int __x = (unsigned short int)localport;
              asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
              tmp_statement_expression_2 = __v;
              localaddr=net_in6addr(&localany.in6, (unsigned long int)10, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ , tmp_statement_expression_2);
              localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
            }

            else
            {
              unsigned long int inaddr_any;
              unsigned int return_value___bswap_32_3;
              return_value___bswap_32_3=__bswap_32((unsigned int)0x00000000);
              inaddr_any = (unsigned long int)return_value___bswap_32_3;
              unsigned short int net_client_connect__1__1__2__2__1____v;
              unsigned short int net_client_connect__1__1__2__2__1____x = (unsigned short int)localport;
              asm("rorw _8, %w0" : "=r"(net_client_connect__1__1__2__2__1____v) : "0"(net_client_connect__1__1__2__2__1____x) : "cc");
              tmp_statement_expression_4 = net_client_connect__1__1__2__2__1____v;
              localaddr=net_inaddr(&localany.in, (unsigned long int)2, (const void *)&inaddr_any, sizeof(unsigned long int) /*8ul*/ , tmp_statement_expression_4);
              localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
            }
          }
          signed int return_value_bind_6;
          return_value_bind_6=bind(sockfd, localaddr, (unsigned int)localsize);
          if(return_value_bind_6 == -1)
          {
            close(sockfd);
            return -1;
          }

        }

      }

      if(!(timeout == 0))
      {
        return_value_nonblock_on_8=nonblock_on(sockfd);
        if(!(return_value_nonblock_on_8 == -1))
          goto __CPROVER_DUMP_L15;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        rc=connect(sockfd, remoteaddr, (unsigned int)remotesize);
        if(rc == -1)
        {
          return_value___errno_location_11=__errno_location();
          if(!(*return_value___errno_location_11 == 115))
          {
            signed int saved_errno;
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            saved_errno = *return_value___errno_location_9;
            close(sockfd);
            signed int return_value_set_errno_10;
            return_value_set_errno_10=set_errno(saved_errno);
            return return_value_set_errno_10;
          }

        }

        if(rc == -1)
        {
          signed int access;
          signed int err = 0;
          unsigned long int net_client_connect__1__3__size = sizeof(signed int) /*4ul*/ ;
          access=rw_timeout(sockfd, (signed long int)timeout, (signed long int)0);
          if(access == -1)
          {
            close(sockfd);
            return -1;
          }

          if((2 & access) == 0 && (4 & access) == 0)
          {
            close(sockfd);
            return -1;
          }

          signed int return_value_getsockopt_12;
          return_value_getsockopt_12=getsockopt(sockfd, 1, 4, (void *)&err, (unsigned int *)(void *)&net_client_connect__1__3__size);
          if(return_value_getsockopt_12 == -1)
          {
            close(sockfd);
            return -1;
          }

          if(!(err == 0))
          {
            close(sockfd);
            return_value_set_errno_13=set_errno(err);
            return return_value_set_errno_13;
          }

        }

        if(!(timeout == 0))
        {
          return_value_nonblock_off_14=nonblock_off(sockfd);
          if(!(return_value_nonblock_off_14 == -1))
            goto __CPROVER_DUMP_L22;

          close(sockfd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L22:
          ;
          return sockfd;
        }
      }
    }
}

// net_create_client
// file libslack/net.c line 825
signed int net_create_client(const char *host, const char *service, unsigned short int port, unsigned short int localport, signed int type, signed int protocol, signed long int timeout, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize)
{
  signed int sockfd;
  union sockaddr_any_t remoteany;
  struct sockaddr *remoteaddr;
  unsigned long int remotesize;
  struct hostent *hostent = (struct hostent *)(void *)0;
  struct hostent hostbuf[1l];
  void *buf = (void *)0;
  unsigned long int net_create_client__1__size = (unsigned long int)0;
  signed int herrno;
  unsigned long int h = (unsigned long int)0;
  _Bool tmp_if_expr_12;
  signed int tmp_statement_expression_10;
  if(!(host == ((const char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_11;
    return_value___builtin_strcmp_11=__builtin_strcmp(host, "/unix");
    tmp_statement_expression_10 = return_value___builtin_strcmp_11;
    tmp_if_expr_12 = !(tmp_statement_expression_10 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_12 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_12)
  {
    if(service == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*service != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(service[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strlen_4=strlen(service);
      tmp_if_expr_5 = return_value_strlen_4 >= sizeof(char [108l]) /*108ul*/  ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      return_value_set_errno_1=set_errno(22);
      return return_value_set_errno_1;
    }

    remoteaddr=net_unaddr(&remoteany.un, (unsigned long int)1, service);
    remotesize = sizeof(struct sockaddr_un) /*110ul*/ ;
  }

  else
  {
    port=service_port(service, type, (signed int)port);
    if(!(host == ((const char *)NULL)))
    {
      hostent=net_gethostbyname(host, hostbuf, &buf, &net_create_client__1__size, &herrno);
      if(hostent == ((struct hostent *)NULL))
      {
        free(buf);
        signed int return_value_set_errno_6;
        return_value_set_errno_6=set_errno(2);
        return return_value_set_errno_6;
      }

      if(hostent->h_addrtype == 2)
      {
        remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
        remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }

      else
        if(hostent->h_addrtype == 10)
        {
          remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
          remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
        }

        else
        {
          free(buf);
          signed int return_value_set_errno_7;
          return_value_set_errno_7=set_errno(38);
          return return_value_set_errno_7;
        }
    }

    else
    {
      signed int return_value_inet6_required_9;
      return_value_inet6_required_9=inet6_required();
      if(!(return_value_inet6_required_9 == 0))
      {
        remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)10, (const void *)&in6addr_loopback, sizeof(struct in6_addr) /*16ul*/ , port);
        remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

      else
      {
        unsigned long int inaddr_loopback;
        unsigned int return_value___bswap_32_8;
        return_value___bswap_32_8=__bswap_32((unsigned int)0x7f000001);
        inaddr_loopback = (unsigned long int)return_value___bswap_32_8;
        remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)2, (const void *)&inaddr_loopback, sizeof(unsigned long int) /*8ul*/ , port);
        remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }
    }
  }
  _Bool tmp_if_expr_13;
  do
  {
    sockfd=net_client_connect(remoteaddr, remotesize, localport, type, protocol, (signed int)timeout, sockopts);
    if(!(sockfd == -1))
      break;

    if(hostent == ((struct hostent *)NULL))
      tmp_if_expr_13 = (_Bool)1;

    else
    {
      h = h + 1ul;
      tmp_if_expr_13 = !(hostent->h_addr_list[(signed long int)h] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_13)
      break;

    if(hostent->h_addrtype == 2)
    {
      remoteaddr=net_inaddr(&remoteany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)h], (unsigned long int)hostent->h_length, port);
      remotesize = sizeof(struct sockaddr_in) /*16ul*/ ;
    }

    else
      if(hostent->h_addrtype == 10)
      {
        remoteaddr=net_in6addr(&remoteany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)h], (unsigned long int)hostent->h_length, port);
        remotesize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

  }
  while((_Bool)1);
  free(buf);
  if(sockfd == -1)
    return -1;

  else
  {
    if(!(addr == ((struct sockaddr *)NULL)) && !(addrsize == ((unsigned long int *)NULL)))
    {
      if(*addrsize >= remotesize)
        memcpy((void *)addr, (const void *)remoteaddr, remotesize);

    }

    if(!(addrsize == ((unsigned long int *)NULL)))
      *addrsize = remotesize;

    return sockfd;
  }
}

// net_create_server
// file libslack/net.c line 577
signed int net_create_server(const char *interface, const char *service, unsigned short int port, signed int type, signed int protocol, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize)
{
  signed int sockfd;
  union sockaddr_any_t localany;
  struct sockaddr *localaddr;
  unsigned long int localsize;
  struct hostent *hostent;
  signed int reuse_addr = 1;
  _Bool tmp_if_expr_12;
  signed int tmp_statement_expression_10;
  if(!(interface == ((const char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_11;
    return_value___builtin_strcmp_11=__builtin_strcmp(interface, "/unix");
    tmp_statement_expression_10 = return_value___builtin_strcmp_11;
    tmp_if_expr_12 = !(tmp_statement_expression_10 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_12 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_12)
  {
    if(service == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*service != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(service[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strlen_4=strlen(service);
      tmp_if_expr_5 = return_value_strlen_4 >= sizeof(char [108l]) /*108ul*/  ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      return_value_set_errno_1=set_errno(22);
      return return_value_set_errno_1;
    }

    localaddr=net_unaddr(&localany.un, (unsigned long int)1, service);
    localsize = sizeof(struct sockaddr_un) /*110ul*/ ;
    unlink(localany.un.sun_path);
  }

  else
  {
    port=service_port(service, type, (signed int)port);
    if(!(interface == ((const char *)NULL)))
    {
      struct hostent hostbuf[1l];
      void *buf = (void *)0;
      unsigned long int net_create_server__1__3__1__size = (unsigned long int)0;
      signed int herrno;
      hostent=net_gethostbyname(interface, hostbuf, &buf, &net_create_server__1__3__1__size, &herrno);
      if(hostent == ((struct hostent *)NULL))
      {
        free(buf);
        signed int return_value_set_errno_6;
        return_value_set_errno_6=set_errno(2);
        return return_value_set_errno_6;
      }

      if(hostent->h_addrtype == 2)
      {
        localaddr=net_inaddr(&localany.in, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
        localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }

      else
        if(hostent->h_addrtype == 10)
        {
          localaddr=net_in6addr(&localany.in6, (unsigned long int)hostent->h_addrtype, (const void *)hostent->h_addr_list[(signed long int)0], (unsigned long int)hostent->h_length, port);
          localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
        }

        else
        {
          free(buf);
          signed int return_value_set_errno_7;
          return_value_set_errno_7=set_errno(38);
          return return_value_set_errno_7;
        }
      free(buf);
    }

    else
    {
      signed int return_value_inet6_required_9;
      return_value_inet6_required_9=inet6_required();
      if(!(return_value_inet6_required_9 == 0))
      {
        localaddr=net_in6addr(&localany.in6, (unsigned long int)10, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ , port);
        localsize = sizeof(struct sockaddr_in6) /*28ul*/ ;
      }

      else
      {
        unsigned long int inaddr_any;
        unsigned int return_value___bswap_32_8;
        return_value___bswap_32_8=__bswap_32((unsigned int)0x00000000);
        inaddr_any = (unsigned long int)return_value___bswap_32_8;
        localaddr=net_inaddr(&localany.in, (unsigned long int)2, (const void *)&inaddr_any, sizeof(unsigned long int) /*8ul*/ , port);
        localsize = sizeof(struct sockaddr_in) /*16ul*/ ;
      }
    }
  }
  sockfd=socket((signed int)localaddr->sa_family, type, protocol);
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  signed int return_value_is_multicast_15;
  signed int return_value_setsockopt_13;
  signed int return_value_net_options_18;
  signed int return_value_listen_20;
  if(sockfd == -1)
    return -1;

  else
  {
    if(type == 1)
      tmp_if_expr_14 = (signed int)localaddr->sa_family != 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_14 = (_Bool)0;
    if(tmp_if_expr_14)
      tmp_if_expr_17 = (_Bool)1;

    else
    {
      if(type == 2)
      {
        return_value_is_multicast_15=is_multicast(localaddr);
        tmp_if_expr_16 = return_value_is_multicast_15 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_16 = (_Bool)0;
      tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_17)
    {
      return_value_setsockopt_13=setsockopt(sockfd, 1, 2, (const void *)&reuse_addr, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_13 == -1))
        goto __CPROVER_DUMP_L26;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L26:
      ;
      if(!(sockopts == ((struct sockopt_t *)NULL)))
      {
        return_value_net_options_18=net_options(sockfd, sockopts);
        if(!(return_value_net_options_18 == -1))
          goto __CPROVER_DUMP_L27;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L27:
        ;
        signed int return_value_bind_19;
        return_value_bind_19=bind(sockfd, localaddr, (unsigned int)localsize);
        if(return_value_bind_19 == -1)
        {
          close(sockfd);
          return -1;
        }

        else
          if(type == 1)
          {
            return_value_listen_20=listen(sockfd, 1024);
            if(!(return_value_listen_20 == -1))
              goto __CPROVER_DUMP_L29;

            close(sockfd);
            return -1;
          }

          else
          {

          __CPROVER_DUMP_L29:
            ;
            if(!(addr == ((struct sockaddr *)NULL)) && !(addrsize == ((unsigned long int *)NULL)))
            {
              if(*addrsize >= localsize)
                memcpy((void *)addr, (const void *)localaddr, localsize);

            }

            if(!(addrsize == ((unsigned long int *)NULL)))
              *addrsize = localsize;

            return sockfd;
          }
      }
    }
  }
}

// net_expect
// file libslack/net.c line 3761
signed long int net_expect(signed int sockfd, signed long int timeout, const char *format, ...)
{
  void **args;
  signed long int rc;
  args = (void **)&format;
  rc=net_vexpect(sockfd, timeout, format, args);
  args = ((void **)NULL);
  return rc;
}

// net_gethostbyname
// file libslack/net.c line 1779
struct hostent * net_gethostbyname(const char *name, struct hostent *hostbuf, void **buf, unsigned long int *size, signed int *herrno)
{
  _Bool tmp_if_expr_2;
  if(buf == ((void **)NULL) || name == ((const char *)NULL) || hostbuf == ((struct hostent *)NULL) || size == ((unsigned long int *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = ((signed int)!(*buf != NULL) ^ (signed int)!(*size != 0ul)) != 0 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  signed int *return_value___errno_location_3;
  void *return_value_mem_resize_fn_4;
  if(herrno == ((signed int *)NULL) || tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct hostent *)return_value_set_errnull_1;
  }

  else
  {
    struct hostent *ret;
    signed int err;
    if(*size == 0ul)
    {
      *size = (unsigned long int)1024;
      *buf=malloc(*size);
      if(!(*buf == NULL))
        goto __CPROVER_DUMP_L4;

      return (struct hostent *)(void *)0;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L4:
        ;
        err=gethostbyname_r(name, hostbuf, (char *)*buf, *size, &ret, herrno);
        if(err == 0)
          break;

        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 34))
          break;

        *size = *size << 1;
        return_value_mem_resize_fn_4=mem_resize_fn((void **)(char **)buf, *size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn_4 == NULL)
          return (struct hostent *)(void *)0;

      }
      while((_Bool)1);
      return err != 0 ? (struct hostent *)(void *)0 : ret;
    }
  }
}

// net_getservbyname
// file libslack/net.c line 1895
struct servent * net_getservbyname(const char *name, const char *proto, struct servent *servbuf, void **buf, unsigned long int *size)
{
  _Bool tmp_if_expr_2;
  if(buf == ((void **)NULL) || name == ((const char *)NULL) || servbuf == ((struct servent *)NULL) || size == ((unsigned long int *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = ((signed int)!(*buf != NULL) ^ (signed int)!(*size != 0ul)) != 0 ? (_Bool)1 : (_Bool)0;
  void *return_value_set_errnull_1;
  signed int *return_value___errno_location_3;
  void *return_value_mem_resize_fn_4;
  if(tmp_if_expr_2)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct servent *)return_value_set_errnull_1;
  }

  else
  {
    struct servent *ret;
    signed int err;
    if(*size == 0ul)
    {
      *size = (unsigned long int)128;
      *buf=malloc(*size);
      if(!(*buf == NULL))
        goto __CPROVER_DUMP_L4;

      return (struct servent *)(void *)0;
    }

    else
    {
      do
      {

      __CPROVER_DUMP_L4:
        ;
        err=getservbyname_r(name, proto, servbuf, (char *)*buf, *size, &ret);
        if(err == 0)
          break;

        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 34))
          break;

        *size = *size << 1;
        return_value_mem_resize_fn_4=mem_resize_fn((void **)(char **)buf, *size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn_4 == NULL)
          return (struct servent *)(void *)0;

      }
      while((_Bool)1);
      return err != 0 ? (struct servent *)(void *)0 : ret;
    }
  }
}

// net_in6addr
// file libslack/net.c line 457
static struct sockaddr * net_in6addr(struct sockaddr_in6 *in6, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port)
{
  memset((void *)in6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
  in6->sin6_family = (unsigned short int)family;
  memcpy((void *)&in6->sin6_addr, addr, addrsize);
  in6->sin6_port = port;
  return (struct sockaddr *)in6;
}

// net_inaddr
// file libslack/net.c line 447
static struct sockaddr * net_inaddr(struct sockaddr_in *in, unsigned long int family, const void *addr, unsigned long int addrsize, unsigned short int port)
{
  memset((void *)in, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  in->sin_family = (unsigned short int)family;
  memcpy((void *)&in->sin_addr, addr, addrsize);
  in->sin_port = port;
  return (struct sockaddr *)in;
}

// net_interfaces
// file libslack/net.c line 2039
struct List * net_interfaces(void)
{
  struct List *return_value_net_interfaces_with_locker_1;
  return_value_net_interfaces_with_locker_1=net_interfaces_with_locker((struct Locker *)(void *)0);
  return return_value_net_interfaces_with_locker_1;
}

// net_interfaces_by_family
// file libslack/net.c line 2080
struct List * net_interfaces_by_family(signed int family)
{
  struct List *return_value_net_interfaces_by_family_with_locker_1;
  return_value_net_interfaces_by_family_with_locker_1=net_interfaces_by_family_with_locker(family, (struct Locker *)(void *)0);
  return return_value_net_interfaces_by_family_with_locker_1;
}

// net_interfaces_by_family_with_locker
// file libslack/net.c line 2096
struct List * net_interfaces_by_family_with_locker(signed int family, struct Locker *locker)
{
  struct List *ret;
  signed int sockfd;
  unsigned long int net_interfaces_by_family_with_locker__1__size;
  unsigned long int lastsize = (unsigned long int)0;
  char *buf = (char *)(void *)0;
  char *ptr;
  struct ifconf ifc[1l];
  signed int index = 0;
  ret=list_create_with_locker(locker, (void (*)(void *))iface_release);
  if(ret == ((struct List *)NULL))
    return (struct List *)(void *)0;

  else
  {
    sockfd=socket(family, 2, 0);
    if(sockfd == -1)
    {
      list_release(ret);
      return (struct List *)(void *)0;
    }

    else
    {
      net_interfaces_by_family_with_locker__1__size = (unsigned long int)100 * sizeof(struct ifreq) /*40ul*/ ;
      do
      {
        void *return_value_mem_resize_fn_1;
        return_value_mem_resize_fn_1=mem_resize_fn((void **)&buf, net_interfaces_by_family_with_locker__1__size * sizeof(char) /*1ul*/ );
        if(return_value_mem_resize_fn_1 == NULL)
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        ifc[0l].ifc_len = (signed int)net_interfaces_by_family_with_locker__1__size;
        ifc[0l].ifc_ifcu.ifcu_buf = buf;
        signed int return_value_ioctl_3;
        return_value_ioctl_3=ioctl(sockfd, (unsigned long int)0x8912, (const void *)ifc);
        if(return_value_ioctl_3 == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          if(!(*return_value___errno_location_2 == 22) || !(lastsize == 0ul))
          {
            list_release(ret);
            free((void *)buf);
            close(sockfd);
            return (struct List *)(void *)0;
          }

        }

        else
        {
          if((unsigned long int)ifc[0l].ifc_len == lastsize)
            break;

          lastsize = (unsigned long int)ifc[0l].ifc_len;
        }
        net_interfaces_by_family_with_locker__1__size = net_interfaces_by_family_with_locker__1__size + (unsigned long int)10 * sizeof(struct ifreq) /*40ul*/ ;
      }
      while((_Bool)1);
      ptr = buf;
      while(!(ptr >= buf + (signed long int)lastsize))
      {
        struct ifreq *ifr = (struct ifreq *)ptr;
        struct ifreq ifrcopy[1l];
        struct net_interface_t *iface;
        void *return_value_calloc_4;
        return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct net_interface_t) /*64ul*/ );
        iface = (struct net_interface_t *)return_value_calloc_4;
        if(iface == ((struct net_interface_t *)NULL))
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        struct List *return_value_list_append_5;
        return_value_list_append_5=list_append(ret, (void *)iface);
        if(return_value_list_append_5 == ((struct List *)NULL))
        {
          list_release(ret);
          free((void *)buf);
          free((void *)iface);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        if(!((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 10))
        {
          if((signed int)ifr->ifr_ifru.ifru_addr.sa_family == 2)
            goto __CPROVER_DUMP_L14;

        }

        else
        {
          net_interfaces_by_family_with_locker__1__size = sizeof(struct sockaddr_in6) /*28ul*/ ;
          goto __CPROVER_DUMP_L15;
        }

      __CPROVER_DUMP_L14:
        ;
        net_interfaces_by_family_with_locker__1__size = sizeof(struct sockaddr) /*16ul*/ ;

      __CPROVER_DUMP_L15:
        ;
        ptr = ptr + (signed long int)(sizeof(char [16l]) /*16ul*/  + net_interfaces_by_family_with_locker__1__size);
        ifrcopy[0l] = *ifr;
        signed int return_value_ioctl_6;
        return_value_ioctl_6=ioctl(sockfd, (unsigned long int)0x8913, (const void *)ifrcopy);
        if(return_value_ioctl_6 == -1)
        {
          list_release(ret);
          free((void *)buf);
          close(sockfd);
          return (struct List *)(void *)0;
        }

        iface->flags = ifrcopy[0l].ifr_ifru.ifru_flags;
        strlcpy(iface->name, ifr->ifr_ifrn.ifrn_name, (unsigned long int)16);
        if(!((1 & (signed int)iface->flags) == 0))
        {
          void *return_value_calloc_7;
          return_value_calloc_7=calloc((unsigned long int)1, net_interfaces_by_family_with_locker__1__size);
          iface->addr = (union sockaddr_any_t *)return_value_calloc_7;
          if(iface->addr == ((union sockaddr_any_t *)NULL))
          {
            list_release(ret);
            free((void *)buf);
            close(sockfd);
            return (struct List *)(void *)0;
          }

          memcpy((void *)iface->addr, (const void *)&ifr->ifr_ifru.ifru_addr, net_interfaces_by_family_with_locker__1__size);
          signed int return_value_ioctl_9;
          return_value_ioctl_9=ioctl(sockfd, (unsigned long int)0x8927, (const void *)ifrcopy);
          if(return_value_ioctl_9 == 0)
          {
            void *return_value_malloc_8;
            return_value_malloc_8=malloc(sizeof(struct sockaddr) /*16ul*/ );
            iface->hwaddr = (union sockaddr_any_t *)return_value_malloc_8;
            if(iface->hwaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->hwaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_hwaddr, sizeof(struct sockaddr) /*16ul*/ );
          }

          if(!((2 & (signed int)iface->flags) == 0))
          {
            signed int return_value_ioctl_10;
            return_value_ioctl_10=ioctl(sockfd, (unsigned long int)0x8919, (const void *)ifrcopy);
            if(return_value_ioctl_10 == -1)
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            void *return_value_calloc_11;
            return_value_calloc_11=calloc((unsigned long int)1, net_interfaces_by_family_with_locker__1__size);
            iface->brdaddr = (union sockaddr_any_t *)return_value_calloc_11;
            if(iface->brdaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->brdaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_broadaddr, net_interfaces_by_family_with_locker__1__size);
          }

          if(!((16 & (signed int)iface->flags) == 0))
          {
            signed int return_value_ioctl_12;
            return_value_ioctl_12=ioctl(sockfd, (unsigned long int)0x8917, (const void *)ifrcopy);
            if(return_value_ioctl_12 == -1)
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            void *return_value_calloc_13;
            return_value_calloc_13=calloc((unsigned long int)1, net_interfaces_by_family_with_locker__1__size);
            iface->dstaddr = (union sockaddr_any_t *)return_value_calloc_13;
            if(iface->dstaddr == ((union sockaddr_any_t *)NULL))
            {
              list_release(ret);
              free((void *)buf);
              close(sockfd);
              return (struct List *)(void *)0;
            }

            memcpy((void *)iface->dstaddr, (const void *)&ifrcopy[0l].ifr_ifru.ifru_dstaddr, net_interfaces_by_family_with_locker__1__size);
          }

        }

        signed int return_value_ioctl_14;
        return_value_ioctl_14=ioctl(sockfd, (unsigned long int)0x8921, (const void *)ifrcopy);
        if(!(return_value_ioctl_14 == -1))
          iface->mtu = ifrcopy[0l].ifr_ifru.ifru_mtu;

        else
          iface->mtu = -1;
        signed int return_value_ioctl_15;
        return_value_ioctl_15=ioctl(sockfd, (unsigned long int)0x8933, (const void *)ifrcopy);
        if(!(return_value_ioctl_15 == -1))
          iface->index = (unsigned int)ifrcopy[0l].ifr_ifru.ifru_ivalue;

        else
        {
          index = index + 1;
          iface->index = (unsigned int)index;
        }
      }
      free((void *)buf);
      close(sockfd);
      return ret;
    }
  }
}

// net_interfaces_with_locker
// file libslack/net.c line 2055
struct List * net_interfaces_with_locker(struct Locker *locker)
{
  signed int family;
  signed int return_value_inet6_required_1;
  return_value_inet6_required_1=inet6_required();
  if(!(return_value_inet6_required_1 == 0))
    family = 10;

  else
    family = 2;
  struct List *return_value_net_interfaces_by_family_with_locker_2;
  return_value_net_interfaces_by_family_with_locker_2=net_interfaces_by_family_with_locker(family, locker);
  return return_value_net_interfaces_by_family_with_locker_2;
}

// net_multicast_get_interface
// file libslack/net.c line 1389
signed int net_multicast_get_interface(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_interface__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_interface__1__size);
  struct in_addr inaddr;
  unsigned long int net_multicast_get_interface__1__1__1__size;
  unsigned int net_multicast_get_interface__1__1__1__index;
  struct List *ifaces;
  signed int return_value_getsockopt_2;
  signed int return_value_list_has_next_3;
  signed int return_value_memcmp_5;
  unsigned int index;
  unsigned long int net_multicast_get_interface__1__1__2__size;
  signed int return_value_getsockopt_6;
  signed int return_value_set_errno_7;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_interface__1__1__1__size = sizeof(struct in_addr) /*4ul*/ ;
        net_multicast_get_interface__1__1__1__index = (unsigned int)0;
        return_value_getsockopt_2=getsockopt(sockfd, 0, 32, (void *)&inaddr, (unsigned int *)(void *)&net_multicast_get_interface__1__1__1__size);
        if(return_value_getsockopt_2 == -1)
          return -1;

        ifaces=net_interfaces_by_family(2);
        if(ifaces == ((struct List *)NULL))
          return -1;

        do
        {
          return_value_list_has_next_3=list_has_next(ifaces);
          if(return_value_list_has_next_3 == 0)
            break;

          struct net_interface_t *iface;
          void *return_value_list_next_4;
          return_value_list_next_4=list_next(ifaces);
          iface = (struct net_interface_t *)return_value_list_next_4;
          if(!((1 & (signed int)iface->flags) == 0))
          {
            if((signed int)iface->addr->any.sa_family == 2)
            {
              return_value_memcmp_5=memcmp((const void *)&inaddr, (const void *)&iface->addr->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
              if(return_value_memcmp_5 == 0)
              {
                net_multicast_get_interface__1__1__1__index = iface->index;
                list_break(ifaces);
                break;
              }

            }

          }

        }
        while((_Bool)1);
        list_release(ifaces);
        return (signed int)net_multicast_get_interface__1__1__1__index;
      }
      case 10:
      {
        net_multicast_get_interface__1__1__2__size = sizeof(unsigned int) /*4ul*/ ;
        return_value_getsockopt_6=getsockopt(sockfd, 41, 17, (void *)&index, (unsigned int *)(void *)&net_multicast_get_interface__1__1__2__size);
        if(return_value_getsockopt_6 == -1)
          return -1;

        return (signed int)index;
      }
      default:
      {
        return_value_set_errno_7=set_errno(93);
        return return_value_set_errno_7;
      }
    }
}

// net_multicast_get_loopback
// file libslack/net.c line 1509
signed int net_multicast_get_loopback(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_loopback__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_loopback__1__size);
  unsigned char flag;
  unsigned long int net_multicast_get_loopback__1__1__1__size;
  signed int return_value_getsockopt_2;
  unsigned int net_multicast_get_loopback__1__1__2__flag;
  unsigned long int net_multicast_get_loopback__1__1__2__size;
  signed int return_value_getsockopt_3;
  signed int return_value_set_errno_4;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_loopback__1__1__1__size = sizeof(unsigned char) /*1ul*/ ;
        return_value_getsockopt_2=getsockopt(sockfd, 0, 34, (void *)&flag, (unsigned int *)(void *)&net_multicast_get_loopback__1__1__1__size);
        if(return_value_getsockopt_2 == -1)
          return -1;

        return (signed int)flag;
      }
      case 10:
      {
        net_multicast_get_loopback__1__1__2__size = sizeof(unsigned int) /*4ul*/ ;
        return_value_getsockopt_3=getsockopt(sockfd, 41, 19, (void *)&net_multicast_get_loopback__1__1__2__flag, (unsigned int *)(void *)&net_multicast_get_loopback__1__1__2__size);
        if(return_value_getsockopt_3 == -1)
          return -1;

        return (signed int)net_multicast_get_loopback__1__1__2__flag;
      }
      default:
      {
        return_value_set_errno_4=set_errno(93);
        return return_value_set_errno_4;
      }
    }
}

// net_multicast_get_ttl
// file libslack/net.c line 1603
signed int net_multicast_get_ttl(signed int sockfd)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_get_ttl__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_get_ttl__1__size);
  unsigned char hops;
  unsigned long int net_multicast_get_ttl__1__1__1__size;
  signed int return_value_getsockopt_2;
  signed int net_multicast_get_ttl__1__1__2__hops;
  unsigned long int net_multicast_get_ttl__1__1__2__size;
  signed int return_value_getsockopt_3;
  signed int return_value_set_errno_4;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        net_multicast_get_ttl__1__1__1__size = sizeof(unsigned char) /*1ul*/ ;
        return_value_getsockopt_2=getsockopt(sockfd, 0, 33, (void *)&hops, (unsigned int *)(void *)&net_multicast_get_ttl__1__1__1__size);
        if(return_value_getsockopt_2 == -1)
          return -1;

        return (signed int)hops;
      }
      case 10:
      {
        net_multicast_get_ttl__1__1__2__size = sizeof(signed int) /*4ul*/ ;
        return_value_getsockopt_3=getsockopt(sockfd, 41, 18, (void *)&net_multicast_get_ttl__1__1__2__hops, (unsigned int *)(void *)&net_multicast_get_ttl__1__1__2__size);
        if(return_value_getsockopt_3 == -1)
          return -1;

        return net_multicast_get_ttl__1__1__2__hops;
      }
      default:
      {
        return_value_set_errno_4=set_errno(93);
        return return_value_set_errno_4;
      }
    }
}

// net_multicast_join
// file libslack/net.c line 1158
signed int net_multicast_join(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t *any = (union sockaddr_any_t *)addr;
  struct ip_mreq mreq[1l];
  struct ifreq ifreq[1l];
  signed int return_value_set_errno_1;
  signed int return_value_setsockopt_4;
  struct ipv6_mreq net_multicast_join__1__1__2__mreq[1l];
  signed int return_value_set_errno_5;
  signed int return_value_setsockopt_6;
  signed int return_value_set_errno_7;
  switch((signed int)any->any.sa_family)
  {
    case 2:
    {
      memcpy((void *)&mreq[0l].imr_multiaddr, (const void *)&any->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      if(ifname == ((const char *)NULL) && ifindex == 0u)
        mreq[0l].imr_interface.s_addr=__bswap_32((unsigned int)0x00000000);

      else
      {
        if(!(ifname == ((const char *)NULL)))
          strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

        else
          if(!(ifindex == 0u))
          {
            char *return_value_if_indextoname_2;
            return_value_if_indextoname_2=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
            if(return_value_if_indextoname_2 == ((char *)NULL))
            {
              return_value_set_errno_1=set_errno(6);
              return return_value_set_errno_1;
            }

          }

        signed int return_value_ioctl_3;
        return_value_ioctl_3=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
        if(return_value_ioctl_3 == -1)
          return -1;

        memcpy((void *)&mreq[0l].imr_interface, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
      }
      return_value_setsockopt_4=setsockopt(sockfd, 0, 35, (const void *)mreq, (unsigned int)sizeof(struct ip_mreq [1l]) /*8ul*/ );
      return return_value_setsockopt_4;
    }
    case 10:
    {
      memcpy((void *)&net_multicast_join__1__1__2__mreq[0l].ipv6mr_multiaddr, (const void *)&any->in6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
      if(!(ifname == ((const char *)NULL)))
      {
        net_multicast_join__1__1__2__mreq[0l].ipv6mr_interface=if_nametoindex(ifname);
        if(net_multicast_join__1__1__2__mreq[0l].ipv6mr_interface == 0u)
        {
          return_value_set_errno_5=set_errno(6);
          return return_value_set_errno_5;
        }

      }

      else
        net_multicast_join__1__1__2__mreq[0l].ipv6mr_interface = ifindex;
      return_value_setsockopt_6=setsockopt(sockfd, 41, 20, (const void *)net_multicast_join__1__1__2__mreq, (unsigned int)sizeof(struct ipv6_mreq [1l]) /*20ul*/ );
      return return_value_setsockopt_6;
    }
    default:
    {
      return_value_set_errno_7=set_errno(93);
      return return_value_set_errno_7;
    }
  }
}

// net_multicast_leave
// file libslack/net.c line 1238
signed int net_multicast_leave(signed int sockfd, const struct sockaddr *addr, unsigned long int addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t *any = (union sockaddr_any_t *)addr;
  struct ip_mreq mreq[1l];
  struct ifreq ifreq[1l];
  signed int return_value_set_errno_1;
  signed int return_value_setsockopt_4;
  struct ipv6_mreq net_multicast_leave__1__1__2__mreq[1l];
  signed int return_value_set_errno_5;
  signed int return_value_setsockopt_6;
  signed int return_value_set_errno_7;
  switch((signed int)any->any.sa_family)
  {
    case 2:
    {
      memcpy((void *)&mreq[0l].imr_multiaddr, (const void *)&any->in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      if(ifname == ((const char *)NULL) && ifindex == 0u)
        mreq[0l].imr_interface.s_addr=__bswap_32((unsigned int)0x00000000);

      else
      {
        if(!(ifname == ((const char *)NULL)))
          strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

        else
          if(!(ifindex == 0u))
          {
            char *return_value_if_indextoname_2;
            return_value_if_indextoname_2=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
            if(return_value_if_indextoname_2 == ((char *)NULL))
            {
              return_value_set_errno_1=set_errno(6);
              return return_value_set_errno_1;
            }

          }

        signed int return_value_ioctl_3;
        return_value_ioctl_3=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
        if(return_value_ioctl_3 == -1)
          return -1;

        memcpy((void *)&mreq[0l].imr_interface, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
      }
      return_value_setsockopt_4=setsockopt(sockfd, 0, 36, (const void *)mreq, (unsigned int)sizeof(struct ip_mreq [1l]) /*8ul*/ );
      return return_value_setsockopt_4;
    }
    case 10:
    {
      memcpy((void *)&net_multicast_leave__1__1__2__mreq[0l].ipv6mr_multiaddr, (const void *)&any->in6.sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
      if(!(ifname == ((const char *)NULL)))
      {
        net_multicast_leave__1__1__2__mreq[0l].ipv6mr_interface=if_nametoindex(ifname);
        if(net_multicast_leave__1__1__2__mreq[0l].ipv6mr_interface == 0u)
        {
          return_value_set_errno_5=set_errno(6);
          return return_value_set_errno_5;
        }

      }

      else
        net_multicast_leave__1__1__2__mreq[0l].ipv6mr_interface = ifindex;
      return_value_setsockopt_6=setsockopt(sockfd, 41, 21, (const void *)net_multicast_leave__1__1__2__mreq, (unsigned int)sizeof(struct ipv6_mreq [1l]) /*20ul*/ );
      return return_value_setsockopt_6;
    }
    default:
    {
      return_value_set_errno_7=set_errno(93);
      return return_value_set_errno_7;
    }
  }
}

// net_multicast_receiver
// file libslack/net.c line 1054
signed int net_multicast_receiver(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t any[1l];
  unsigned long int anysize = sizeof(union sockaddr_any_t [1l]) /*112ul*/ ;
  signed int sockfd;
  if(addr == ((struct sockaddr *)NULL))
    addr = (struct sockaddr *)any;

  if(addrsize == ((unsigned long int *)NULL))
    addrsize = &anysize;

  sockfd=net_create_server(group, service, port, 2, 0, sockopts, addr, addrsize);
  if(sockfd == -1)
    return -1;

  else
  {
    signed int return_value_net_multicast_join_1;
    return_value_net_multicast_join_1=net_multicast_join(sockfd, addr, *addrsize, ifname, ifindex);
    if(return_value_net_multicast_join_1 == -1)
    {
      close(sockfd);
      return -1;
    }

    else
      return sockfd;
  }
}

// net_multicast_sender
// file libslack/net.c line 995
signed int net_multicast_sender(const char *group, const char *service, unsigned short int port, struct sockopt_t *sockopts, struct sockaddr *addr, unsigned long int *addrsize, const char *ifname, unsigned int ifindex, signed int ttl, unsigned int noloopback)
{
  signed int sockfd;
  unsigned int loopback = (unsigned int)0;
  sockfd=net_create_client(group, service, port, (unsigned short int)0, 2, 0, (signed long int)0, sockopts, addr, addrsize);
  signed int return_value_net_multicast_set_interface_1;
  signed int return_value_net_multicast_set_ttl_2;
  signed int return_value_net_multicast_set_loopback_3;
  if(sockfd == -1)
    return -1;

  else
    if(!(ifname == ((const char *)NULL)) || !(ifindex == 0u))
    {
      return_value_net_multicast_set_interface_1=net_multicast_set_interface(sockfd, ifname, ifindex);
      if(!(return_value_net_multicast_set_interface_1 == -1))
        goto __CPROVER_DUMP_L2;

      close(sockfd);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(ttl >= 2)
      {
        return_value_net_multicast_set_ttl_2=net_multicast_set_ttl(sockfd, ttl);
        if(!(return_value_net_multicast_set_ttl_2 == -1))
          goto __CPROVER_DUMP_L3;

        close(sockfd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!(noloopback == 0u))
        {
          return_value_net_multicast_set_loopback_3=net_multicast_set_loopback(sockfd, loopback);
          if(!(return_value_net_multicast_set_loopback_3 == -1))
            goto __CPROVER_DUMP_L4;

          close(sockfd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          return sockfd;
        }
      }
    }
}

// net_multicast_set_interface
// file libslack/net.c line 1319
signed int net_multicast_set_interface(signed int sockfd, const char *ifname, unsigned int ifindex)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_interface__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_interface__1__size);
  struct ifreq ifreq[1l];
  struct in_addr inaddr;
  signed int return_value_set_errno_2;
  signed int return_value_setsockopt_5;
  unsigned int index;
  signed int return_value_set_errno_6;
  signed int return_value_setsockopt_7;
  signed int return_value_set_errno_8;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        if(ifname == ((const char *)NULL) && ifindex == 0u)
          inaddr.s_addr=__bswap_32((unsigned int)0x00000000);

        else
        {
          if(!(ifname == ((const char *)NULL)))
            strlcpy(ifreq[0l].ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);

          else
            if(!(ifindex == 0u))
            {
              char *return_value_if_indextoname_3;
              return_value_if_indextoname_3=if_indextoname(ifindex, ifreq[0l].ifr_ifrn.ifrn_name);
              if(return_value_if_indextoname_3 == ((char *)NULL))
              {
                return_value_set_errno_2=set_errno(6);
                return return_value_set_errno_2;
              }

            }

          signed int return_value_ioctl_4;
          return_value_ioctl_4=ioctl(sockfd, (unsigned long int)0x8915, (const void *)ifreq);
          if(return_value_ioctl_4 == -1)
            return -1;

          memcpy((void *)&inaddr, (const void *)&((struct sockaddr_in *)&ifreq[0l].ifr_ifru.ifru_addr)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
        }
        return_value_setsockopt_5=setsockopt(sockfd, 0, 32, (const void *)&inaddr, (unsigned int)sizeof(struct in_addr) /*4ul*/ );
        return return_value_setsockopt_5;
      }
      case 10:
      {
        if(!(ifname == ((const char *)NULL)))
        {
          index=if_nametoindex(ifname);
          if(index == 0u)
          {
            return_value_set_errno_6=set_errno(6);
            return return_value_set_errno_6;
          }

        }

        index = ifindex;
        return_value_setsockopt_7=setsockopt(sockfd, 41, 17, (const void *)&index, (unsigned int)sizeof(unsigned int) /*4ul*/ );
        return return_value_setsockopt_7;
      }
      default:
      {
        return_value_set_errno_8=set_errno(93);
        return return_value_set_errno_8;
      }
    }
}

// net_multicast_set_loopback
// file libslack/net.c line 1465
signed int net_multicast_set_loopback(signed int sockfd, unsigned int loopback)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_loopback__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_loopback__1__size);
  unsigned char flag;
  signed int return_value_setsockopt_2;
  unsigned int net_multicast_set_loopback__1__1__2__flag;
  signed int return_value_setsockopt_3;
  signed int return_value_set_errno_4;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        flag = (unsigned char)loopback;
        return_value_setsockopt_2=setsockopt(sockfd, 0, 34, (const void *)&flag, (unsigned int)sizeof(unsigned char) /*1ul*/ );
        return return_value_setsockopt_2;
      }
      case 10:
      {
        net_multicast_set_loopback__1__1__2__flag = loopback;
        return_value_setsockopt_3=setsockopt(sockfd, 41, 19, (const void *)&net_multicast_set_loopback__1__1__2__flag, (unsigned int)sizeof(unsigned int) /*4ul*/ );
        return return_value_setsockopt_3;
      }
      default:
      {
        return_value_set_errno_4=set_errno(93);
        return return_value_set_errno_4;
      }
    }
}

// net_multicast_set_ttl
// file libslack/net.c line 1561
signed int net_multicast_set_ttl(signed int sockfd, signed int ttl)
{
  union sockaddr_any_t any;
  unsigned long int net_multicast_set_ttl__1__size = sizeof(union sockaddr_any_t) /*112ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(sockfd, (struct sockaddr *)(void *)&any, (unsigned int *)(void *)&net_multicast_set_ttl__1__size);
  unsigned char hops;
  signed int return_value_setsockopt_2;
  signed int net_multicast_set_ttl__1__1__2__hops;
  signed int return_value_setsockopt_3;
  signed int return_value_set_errno_4;
  if(return_value_getsockname_1 == -1)
    return -1;

  else
    switch((signed int)any.any.sa_family)
    {
      case 2:
      {
        hops = (unsigned char)ttl;
        return_value_setsockopt_2=setsockopt(sockfd, 0, 33, (const void *)&hops, (unsigned int)sizeof(unsigned char) /*1ul*/ );
        return return_value_setsockopt_2;
      }
      case 10:
      {
        net_multicast_set_ttl__1__1__2__hops = ttl;
        return_value_setsockopt_3=setsockopt(sockfd, 41, 18, (const void *)&net_multicast_set_ttl__1__1__2__hops, (unsigned int)sizeof(signed int) /*4ul*/ );
        return return_value_setsockopt_3;
      }
      default:
      {
        return_value_set_errno_4=set_errno(93);
        return return_value_set_errno_4;
      }
    }
}

// net_options
// file libslack/net.c line 1989
signed int net_options(signed int sockfd, struct sockopt_t *sockopts)
{
  struct sockopt_t *so;
  signed int err = 0;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  signed int return_value_setsockopt_3;
  if(sockfd == -1)
  {
    return_value_set_errno_1=set_errno(9);
    return return_value_set_errno_1;
  }

  else
    if(sockopts == ((struct sockopt_t *)NULL))
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      so = sockopts;
      for( ; !(so->optval == NULL); so = so + 1l)
      {
        return_value_setsockopt_3=setsockopt(sockfd, so->level, so->optname, so->optval, (unsigned int)so->optlen);
        if(return_value_setsockopt_3 == -1)
          err = -1;

      }
      return err;
    }
}

// net_pack
// file libslack/net.c line 2706
signed long int net_pack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vpack_1;
  return_value_net_vpack_1=net_vpack(sockfd, timeout, flags, format, args);
  rc = (signed int)return_value_net_vpack_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_packto
// file libslack/net.c line 2760
signed long int net_packto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vpackto_1;
  return_value_net_vpackto_1=net_vpackto(sockfd, timeout, flags, to, tosize, format, args);
  rc = (signed int)return_value_net_vpackto_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_read
// file libslack/net.c line 3687
signed long int net_read(signed int sockfd, signed long int timeout, char *buf, unsigned long int count)
{
  char *b;
  signed long int bytes;
  b = buf;
  for( ; !(count == 0ul); b = b + bytes)
  {
    signed int return_value_read_timeout_1;
    return_value_read_timeout_1=read_timeout(sockfd, timeout, (signed long int)0);
    if(return_value_read_timeout_1 == -1)
      return (signed long int)-1;

    bytes=read(sockfd, (void *)b, count);
    if(bytes == -1l)
      return (signed long int)-1;

    if(bytes == 0l)
      break;

    count = count - (unsigned long int)bytes;
  }
  return b - buf;
}

// net_rudp_transact
// file libslack/net.c line 2557
signed long int net_rudp_transact(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, void *ibuf, unsigned long int isize)
{
  signed long int return_value_net_rudp_transactwith_1;
  return_value_net_rudp_transactwith_1=net_rudp_transactwith(sockfd, rudp, obuf, osize, 0, ibuf, isize, 0, (union sockaddr_any_t *)(void *)0, (unsigned long int)0);
  return return_value_net_rudp_transactwith_1;
}

// net_rudp_transactwith
// file libslack/net.c line 2582
signed long int net_rudp_transactwith(signed int sockfd, struct rudp_t *rudp, const void *obuf, unsigned long int osize, signed int oflags, void *ibuf, unsigned long int isize, signed int iflags, union sockaddr_any_t *addr, unsigned long int addrsize)
{
  /* tag-#anon#lST[U32'sequence'||U32'timestamp'|] */
struct anonymous_4
{
  // sequence
  unsigned int sequence;
  // timestamp
  unsigned int timestamp;
};

/* */
  ;
  struct anonymous_4 ohdr[1l];
  struct anonymous_4 ihdr[1l];
  struct msghdr omsg[1l];
  struct msghdr imsg[1l];
  struct iovec ovec[2l];
  struct iovec ivec[2l];
  signed int sequence;
  unsigned int timestamp;
  double net_rudp_transactwith__1__timeout;
  signed long int timeout_sec;
  signed long int timeout_usec;
  signed long int bytes;
  signed int return_value_set_errno_1;
  signed int return_value_read_timeout_7;
  signed int *return_value___errno_location_6;
  signed int return_value_rudp_timeout_5;
  _Bool tmp_if_expr_8;
  if(ibuf == NULL || obuf == NULL || rudp == ((struct rudp_t *)NULL) || isize == 0ul || osize == 0ul || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(addr == ((union sockaddr_any_t *)NULL)))
    {
      memset((void *)omsg, 0, sizeof(struct msghdr [1l]) /*56ul*/ );
      omsg[0l].msg_name = (void *)addr;
      omsg[0l].msg_namelen = (unsigned int)addrsize;
      omsg[0l].msg_iov = ovec;
      omsg[0l].msg_iovlen = (unsigned long int)2;
      memset((void *)imsg, 0, sizeof(struct msghdr [1l]) /*56ul*/ );
      imsg[0l].msg_iov = ivec;
      imsg[0l].msg_iovlen = (unsigned long int)2;
    }

    ovec[(signed long int)0].iov_base = (void *)ohdr;
    ovec[(signed long int)0].iov_len = sizeof(struct anonymous_4 [1l]) /*8ul*/ ;
    ovec[(signed long int)1].iov_base = (void *)obuf;
    ovec[(signed long int)1].iov_len = osize;
    ivec[(signed long int)0].iov_base = (void *)ihdr;
    ivec[(signed long int)0].iov_len = sizeof(struct anonymous_4 [1l]) /*8ul*/ ;
    ivec[(signed long int)1].iov_base = ibuf;
    ivec[(signed long int)1].iov_len = isize;
    unsigned int return_value_rudp_newpack_2;
    return_value_rudp_newpack_2=rudp_newpack(rudp);
    sequence = (signed int)return_value_rudp_newpack_2;
    if(sequence == -1)
      return (signed long int)-1;

    else
    {
      ohdr[0l].sequence = (unsigned int)sequence;
      do
      {

      sendagain:
        ;
        timestamp=rudp_timestamp(rudp);
        if(timestamp == 4294967295u)
          return (signed long int)-1;

        ohdr[0l].timestamp = timestamp;
        if(!(addr == ((union sockaddr_any_t *)NULL)))
        {
          signed long int return_value_sendmsg_3;
          return_value_sendmsg_3=sendmsg(sockfd, omsg, oflags);
          if(return_value_sendmsg_3 == -1l)
            return (signed long int)-1;

        }

        else
        {
          signed long int return_value_writev_4;
          return_value_writev_4=writev(sockfd, ovec, 2);
          if(return_value_writev_4 == -1l)
            return (signed long int)-1;

        }
        net_rudp_transactwith__1__timeout=rudp_start(rudp);
        if(IEEE_FLOAT_EQUAL(net_rudp_transactwith__1__timeout, -1.000000))
          return (signed long int)-1;

        timeout_sec = (signed long int)net_rudp_transactwith__1__timeout;
        timeout_usec = (signed long int)((net_rudp_transactwith__1__timeout - (double)timeout_sec) * (double)1000000);

      recvagain:
        ;
        return_value_read_timeout_7=read_timeout(sockfd, timeout_sec, timeout_usec);
        if(!(return_value_read_timeout_7 == -1))
          goto __CPROVER_DUMP_L13;

        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 110))
          break;

        return_value_rudp_timeout_5=rudp_timeout(rudp);
      }
      while(!(return_value_rudp_timeout_5 == -1));
      rudp_init(rudp);
      return (signed long int)-1;

    __CPROVER_DUMP_L13:
      ;
      if(!(addr == ((union sockaddr_any_t *)NULL)))
      {
        bytes=recvmsg(sockfd, imsg, iflags);
        if(bytes == -1l)
          return (signed long int)-1;

      }

      else
      {
        bytes=readv(sockfd, ivec, 2);
        if(bytes == -1l)
          return (signed long int)-1;

      }
      if(!((unsigned long int)bytes >= sizeof(struct anonymous_4 [1l]) /*8ul*/ ))
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = ihdr[0l].sequence != ohdr[0l].sequence ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        goto recvagain;

      unsigned int return_value_rudp_timestamp_9;
      return_value_rudp_timestamp_9=rudp_timestamp(rudp);
      signed int return_value_rudp_stop_10;
      return_value_rudp_stop_10=rudp_stop(rudp, return_value_rudp_timestamp_9 - ihdr[0l].timestamp);
      if(return_value_rudp_stop_10 == -1)
        return (signed long int)-1;

      else
        return (signed long int)((unsigned long int)bytes - sizeof(struct anonymous_4 [1l]) /*8ul*/ );
    }
  }
}

// net_send
// file libslack/net.c line 3813
signed long int net_send(signed int sockfd, signed long int timeout, const char *format, ...)
{
  void **args;
  signed long int rc;
  args = (void **)&format;
  rc=net_vsend(sockfd, timeout, format, args);
  args = ((void **)NULL);
  return rc;
}

// net_server
// file libslack/net.c line 313
signed int net_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_server_1;
  return_value_net_create_server_1=net_create_server(interface, service, port, 1, 0, sockopts, addr, addrsize);
  return return_value_net_create_server_1;
}

// net_tos_lowcost
// file libslack/net.c line 1718
signed int net_tos_lowcost(signed int sockfd)
{
  signed int tos = 0x02;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// net_tos_lowdelay
// file libslack/net.c line 1655
signed int net_tos_lowdelay(signed int sockfd)
{
  signed int tos = 0x10;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// net_tos_normal
// file libslack/net.c line 1736
signed int net_tos_normal(signed int sockfd)
{
  signed int tos = 0x00;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// net_tos_reliability
// file libslack/net.c line 1695
signed int net_tos_reliability(signed int sockfd)
{
  signed int tos = 0x04;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// net_tos_throughput
// file libslack/net.c line 1675
signed int net_tos_throughput(signed int sockfd)
{
  signed int tos = 0x08;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sockfd, 0, 1, (const void *)&tos, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// net_udp_client
// file libslack/net.c line 415
signed int net_udp_client(const char *host, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_client_1;
  return_value_net_create_client_1=net_create_client(host, service, port, (unsigned short int)0, 2, 0, (signed long int)0, sockopts, addr, addrsize);
  return return_value_net_create_client_1;
}

// net_udp_server
// file libslack/net.c line 392
signed int net_udp_server(const char *interface, const char *service, unsigned short int port, signed int rcvbufsz, signed int sndbufsz, struct sockaddr *addr, unsigned long int *addrsize)
{
  struct sockopt_t sockopts[3l];
  build_sockopts(sockopts, &rcvbufsz, &sndbufsz);
  signed int return_value_net_create_server_1;
  return_value_net_create_server_1=net_create_server(interface, service, port, 2, 0, sockopts, addr, addrsize);
  return return_value_net_create_server_1;
}

// net_unaddr
// file libslack/net.c line 439
static struct sockaddr * net_unaddr(struct sockaddr_un *un, unsigned long int family, const char *path)
{
  memset((void *)un, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  un->sun_family = (unsigned short int)family;
  strlcpy(un->sun_path, path, sizeof(char [108l]) /*108ul*/ );
  return (struct sockaddr *)un;
}

// net_unpack
// file libslack/net.c line 2818
signed long int net_unpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vunpack_1;
  return_value_net_vunpack_1=net_vunpack(sockfd, timeout, flags, format, args);
  rc = (signed int)return_value_net_vunpack_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_unpackfrom
// file libslack/net.c line 2873
signed long int net_unpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_net_vunpackfrom_1;
  return_value_net_vunpackfrom_1=net_vunpackfrom(sockfd, timeout, flags, from, fromsize, format, args);
  rc = (signed int)return_value_net_vunpackfrom_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// net_vexpect
// file libslack/net.c line 3784
signed long int net_vexpect(signed int sockfd, signed long int timeout, const char *format, void **args)
{
  char buf[8193l];
  signed long int bytes;
  signed int return_value_read_timeout_1;
  return_value_read_timeout_1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout_1 == -1)
    return (signed long int)-1;

  else
  {
    bytes=read(sockfd, (void *)buf, (unsigned long int)8192);
    if(!(bytes >= 1l))
      return bytes;

    else
    {
      buf[bytes] = (char)0;
      signed int return_value_vsscanf_2;
      return_value_vsscanf_2=vsscanf(buf, format, args);
      return (signed long int)return_value_vsscanf_2;
    }
  }
}

// net_vpack
// file libslack/net.c line 2729
signed long int net_vpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed long int return_value_vpack_1;
  return_value_vpack_1=vpack((void *)buf, (unsigned long int)8192, format, args);
  rc = (signed int)return_value_vpack_1;
  signed int return_value_write_timeout_2;
  if(rc == -1)
    return (signed long int)-1;

  else
    if(!(timeout == 0l))
    {
      return_value_write_timeout_2=write_timeout(sockfd, timeout, (signed long int)0);
      if(!(return_value_write_timeout_2 == -1))
        goto __CPROVER_DUMP_L2;

      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed long int return_value_send_3;
      return_value_send_3=send(sockfd, (const void *)buf, (unsigned long int)rc, flags);
      return return_value_send_3;
    }
}

// net_vpackto
// file libslack/net.c line 2783
signed long int net_vpackto(signed int sockfd, signed long int timeout, signed int flags, const struct sockaddr *to, unsigned long int tosize, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed long int return_value_vpack_1;
  return_value_vpack_1=vpack((void *)buf, (unsigned long int)8192, format, args);
  rc = (signed int)return_value_vpack_1;
  signed int return_value_write_timeout_2;
  if(rc == -1)
    return (signed long int)-1;

  else
    if(!(timeout == 0l))
    {
      return_value_write_timeout_2=write_timeout(sockfd, timeout, (signed long int)0);
      if(!(return_value_write_timeout_2 == -1))
        goto __CPROVER_DUMP_L2;

      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed long int return_value_sendto_3;
      return_value_sendto_3=sendto(sockfd, (const void *)buf, (unsigned long int)rc, flags, to, (unsigned int)tosize);
      return return_value_sendto_3;
    }
}

// net_vsend
// file libslack/net.c line 3836
signed long int net_vsend(signed int sockfd, signed long int timeout, const char *format, void **args)
{
  char buf[8193l];
  signed long int bytes;
  signed int return_value_vsnprintf_1;
  return_value_vsnprintf_1=vsnprintf(buf, (unsigned long int)(8192 + 1), format, args);
  bytes = (signed long int)return_value_vsnprintf_1;
  signed int return_value_set_errno_2;
  if(bytes == -1l || bytes >= 8193l)
  {
    return_value_set_errno_2=set_errno(28);
    return (signed long int)return_value_set_errno_2;
  }

  else
  {
    signed long int return_value_net_write_3;
    return_value_net_write_3=net_write(sockfd, timeout, buf, (unsigned long int)bytes);
    return return_value_net_write_3;
  }
}

// net_vunpack
// file libslack/net.c line 2841
signed long int net_vunpack(signed int sockfd, signed long int timeout, signed int flags, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed int return_value_read_timeout_1;
  return_value_read_timeout_1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout_1 == -1)
    return (signed long int)-1;

  else
  {
    signed long int return_value_recv_2;
    return_value_recv_2=recv(sockfd, (void *)buf, (unsigned long int)8192, flags);
    rc = (signed int)return_value_recv_2;
    if(rc == -1)
      return (signed long int)-1;

    else
    {
      signed long int return_value_vunpack_3;
      return_value_vunpack_3=vunpack((void *)buf, (unsigned long int)rc, format, args);
      return return_value_vunpack_3;
    }
  }
}

// net_vunpackfrom
// file libslack/net.c line 2896
signed long int net_vunpackfrom(signed int sockfd, signed long int timeout, signed int flags, struct sockaddr *from, unsigned long int *fromsize, const char *format, void **args)
{
  char buf[8192l];
  signed int rc;
  signed int return_value_read_timeout_1;
  return_value_read_timeout_1=read_timeout(sockfd, timeout, (signed long int)0);
  if(return_value_read_timeout_1 == -1)
    return (signed long int)-1;

  else
  {
    signed long int return_value_recvfrom_2;
    return_value_recvfrom_2=recvfrom(sockfd, (void *)buf, (unsigned long int)8192, flags, from, (unsigned int *)(void *)fromsize);
    rc = (signed int)return_value_recvfrom_2;
    if(rc == -1)
      return (signed long int)-1;

    else
    {
      signed long int return_value_vunpack_3;
      return_value_vunpack_3=vunpack((void *)buf, (unsigned long int)rc, format, args);
      return return_value_vunpack_3;
    }
  }
}

// net_write
// file libslack/net.c line 3720
signed long int net_write(signed int sockfd, signed long int timeout, const char *buf, unsigned long int count)
{
  const char *b;
  signed long int bytes;
  b = buf;
  for( ; !(count == 0ul); b = b + bytes)
  {
    signed int return_value_write_timeout_1;
    return_value_write_timeout_1=write_timeout(sockfd, timeout, (signed long int)0);
    if(return_value_write_timeout_1 == -1)
      return (signed long int)-1;

    bytes=write(sockfd, (const void *)b, count);
    if(!(bytes >= 1l))
      return bytes;

    count = count - (unsigned long int)bytes;
  }
  return b - buf;
}

// new_shargv
// file libslack/coproc.c line 137
static char * const * new_shargv(const char *cmd, char * const *argv)
{
  char **shargv;
  signed int nargs = 0;
  for( ; !(argv[(signed long int)nargs] == ((char *)NULL)); nargs = nargs + 1)
    ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(nargs + 2) * sizeof(char **) /*8ul*/ );
  shargv = (char **)return_value_malloc_1;
  if(shargv == ((char **)NULL))
    return (char * const *)(void *)0;

  else
  {
    shargv[(signed long int)0] = "/bin/sh";
    shargv[(signed long int)1] = (char *)cmd;
    nargs = 1;
    for( ; !(argv[(signed long int)nargs] == ((char *)NULL)); nargs = nargs + 1)
      shargv[(signed long int)(nargs + 1)] = argv[(signed long int)nargs];
    shargv[(signed long int)(nargs + 1)] = (char *)(void *)0;
    return (char * const *)shargv;
  }
}

// next_day
// file libslack/agent.c line 1809
static void next_day(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->hour = (unsigned long int)0;
  agent->timewheel->day = agent->timewheel->day + 1ul;
  void *return_value_dlink_next_1;
  if(agent->timewheel->day == 10ul)
  {
    unsigned long int i;
    agent->timewheel->day = (unsigned long int)0;
    i = (unsigned long int)0;
    for( ; !(i >= 10ul); i = i + 1ul)
    {
      action = agent->timewheel->days[(signed long int)i];
      for( ; !(action == ((struct action_t *)NULL)); action = (struct action_t *)return_value_dlink_next_1)
      {
        action->day = action->day - (unsigned long int)10;
        return_value_dlink_next_1=dlink_next((void *)action);
      }
    }
  }

  next = agent->timewheel->days[(signed long int)agent->timewheel->day];
  action = next;
  void *return_value_dlink_next_3;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
    if(action->day == agent->timewheel->day)
    {
      void *return_value_dlink_remove_2;
      return_value_dlink_remove_2=dlink_remove((void *)action);
      next = (struct action_t *)return_value_dlink_remove_2;
      if(*action->parent == action)
        *action->parent = next;

      install(&agent->timewheel->hours[(signed long int)action->hour], action);
    }

    else
    {
      return_value_dlink_next_3=dlink_next((void *)action);
      next = (struct action_t *)return_value_dlink_next_3;
    }
}

// next_hour
// file libslack/agent.c line 1846
static void next_hour(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->minute = (unsigned long int)0;
  agent->timewheel->hour = agent->timewheel->hour + 1ul;
  if(agent->timewheel->hour == 24ul)
    next_day(agent);

  next = agent->timewheel->hours[(signed long int)agent->timewheel->hour];
  agent->timewheel->hours[(signed long int)agent->timewheel->hour] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove_1;
    return_value_dlink_remove_1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove_1;
    install(&agent->timewheel->minutes[(signed long int)action->minute], action);
  }
}

// next_minute
// file libslack/agent.c line 1867
static void next_minute(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->second = (unsigned long int)0;
  agent->timewheel->minute = agent->timewheel->minute + 1ul;
  if(agent->timewheel->minute == 60ul)
    next_hour(agent);

  next = agent->timewheel->minutes[(signed long int)agent->timewheel->minute];
  agent->timewheel->minutes[(signed long int)agent->timewheel->minute] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove_1;
    return_value_dlink_remove_1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove_1;
    install(&agent->timewheel->seconds[(signed long int)action->second], action);
  }
}

// next_second
// file libslack/agent.c line 1888
static void next_second(struct Agent *agent)
{
  struct action_t *next;
  struct action_t *action;
  agent->timewheel->jiffy = (unsigned long int)0;
  agent->timewheel->second = agent->timewheel->second + 1ul;
  if(agent->timewheel->second == 60ul)
    next_minute(agent);

  next = agent->timewheel->seconds[(signed long int)agent->timewheel->second];
  agent->timewheel->seconds[(signed long int)agent->timewheel->second] = (struct action_t *)(void *)0;
  action = next;
  for( ; !(action == ((struct action_t *)NULL)); action = next)
  {
    void *return_value_dlink_remove_1;
    return_value_dlink_remove_1=dlink_remove((void *)action);
    next = (struct action_t *)return_value_dlink_remove_1;
    install(&agent->timewheel->jiffies[(signed long int)action->jiffy], action);
  }
}

// nonblock_off
// file libslack/fio.c line 485
signed int nonblock_off(signed int fd)
{
  signed int return_value_fcntl_clear_flag_1;
  return_value_fcntl_clear_flag_1=fcntl_clear_flag(fd, 04000);
  return return_value_fcntl_clear_flag_1;
}

// nonblock_on
// file libslack/fio.c line 468
signed int nonblock_on(signed int fd)
{
  signed int return_value_fcntl_set_flag_1;
  return_value_fcntl_set_flag_1=fcntl_set_flag(fd, 04000);
  return return_value_fcntl_set_flag_1;
}

// nonblock_set
// file libslack/fio.c line 451
signed int nonblock_set(signed int fd, signed int arg)
{
  signed int tmp_if_expr_3;
  signed int return_value_nonblock_on_1;
  signed int return_value_nonblock_off_2;
  if(!(arg == 0))
  {
    return_value_nonblock_on_1=nonblock_on(fd);
    tmp_if_expr_3 = return_value_nonblock_on_1;
  }

  else
  {
    return_value_nonblock_off_2=nonblock_off(fd);
    tmp_if_expr_3 = return_value_nonblock_off_2;
  }
  return tmp_if_expr_3;
}

// oct
// file libslack/str.c line 6469
signed int oct(const char *str)
{
  signed int ret = 0;
  _Bool tmp_if_expr_2;
  if(str == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)str[(signed long int)0] != 48 ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  signed int return_value_bin_3;
  signed int return_value_hex_4;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if((signed int)str[1l] == 98)
    {
      return_value_bin_3=bin(str);
      return return_value_bin_3;
    }

    else
      if((signed int)str[1l] == 120)
      {
        return_value_hex_4=hex(str);
        return return_value_hex_4;
      }

      else
      {
        str = str + 1l;
        for( ; !(*str == 0); str = str + 1l)
        {
          ret = ret << 3;
          if((signed int)*str == 48 || (signed int)*str == 49 || (signed int)*str == 50 || (signed int)*str == 51 || (signed int)*str == 52 || (signed int)*str == 53 || (signed int)*str == 54 || (signed int)*str == 55)
          {
            ret = ret | (signed int)*str - 48;
            goto __CPROVER_DUMP_L9;
          }

          signed int return_value_set_errno_5;
          return_value_set_errno_5=set_errno(22);
          return return_value_set_errno_5;

        __CPROVER_DUMP_L9:
          ;
        }
        return ret;
      }
}

// opt_action
// file libslack/prog.c line 1889
static void opt_action(struct Options *options, signed int rc, signed int longindex, const char *argument)
{
  struct Option *option;
  signed int i = -1;
  _Bool tmp_if_expr_1;
  if(longindex == -1 && !(rc == 0))
    for( ; !(options == ((struct Options *)NULL)); options = options->parent)
    {
      i = 0;
      for( ; !((options->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
        if((signed int)(options->options + (signed long int)i)->short_name == rc)
          break;

      if((signed int)(options->options + (signed long int)i)->short_name == rc)
        break;

    }

  else
    if(rc == 0 && !(longindex == -1))
    {
      i = 0;
      for( ; !(options == ((struct Options *)NULL)); options = options->parent)
      {
        i = 0;
        do
        {
          if(!(longindex == 0))
            tmp_if_expr_1 = (options->options + (signed long int)i)->name != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          longindex = longindex - 1;
          i = i + 1;
        }
        while((_Bool)1);
        if(!((options->options + (signed long int)i)->name == ((const char *)NULL)))
        {
          if(longindex == 0)
            break;

        }

      }
    }

    else
      goto __CPROVER_DUMP_L38;
  signed int arg;
  if(!(options == ((struct Options *)NULL)) && !(i == -1))
  {
    option = options->options + (signed long int)i;
    if(option->has_arg == 1)
    {
      if(!(argument == ((const char *)NULL)))
        goto __CPROVER_DUMP_L16;

    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      if(option->has_arg == 0)
      {
        if(argument == ((const char *)NULL))
          goto __CPROVER_DUMP_L17;

      }

      else
      {

      __CPROVER_DUMP_L17:
        ;
        if(!(argument == ((const char *)NULL)))
          switch((signed int)option->arg_type)
          {
            case OPT_NONE:
              break;
            case OPT_INTEGER:
            {
              switch((signed int)option->action)
              {
                case OPT_NOTHING:
                  break;
                case OPT_VARIABLE:
                {
                  *((signed int *)option->object)=int_arg(argument);
                  break;
                }
                case OPT_FUNCTION:
                {
                  arg=int_arg(argument);
                  if(option->has_arg == 1)
                    ((void (*)(signed int))option->function)(arg);

                  else
                    ((void (*)(signed int *))option->function)(&arg);
                }
              }
              break;
            }
            case OPT_STRING:
              switch((signed int)option->action)
              {
                case OPT_NOTHING:
                  break;
                case OPT_VARIABLE:
                {
                  *((const char **)option->object) = argument;
                  break;
                }
                case OPT_FUNCTION:
                  ((void (*)(const char *))option->function)(argument);
              }
          }

        else
          switch((signed int)option->action)
          {
            case OPT_NOTHING:
              break;
            case OPT_VARIABLE:
            {
              if(!((signed int)option->arg_type == OPT_STRING))
                *((signed int *)option->object) = *((signed int *)option->object) + 1;

              break;
            }
            case OPT_FUNCTION:
              if((signed int)option->action == 2)
                ((void (*)(signed int *))option->function)((signed int *)(void *)0);

              else
                ((void (*)(void))option->function)();
          }
      }
    }
  }


__CPROVER_DUMP_L38:
  ;
}

// opt_convert
// file libslack/prog.c line 1762
static struct option * opt_convert(struct Options *options)
{
  struct Options *opts;
  unsigned long int opt_convert__1__size = (unsigned long int)0;
  unsigned long int opt_convert__1__i;
  struct option *ret;
  signed int index = 0;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
  {
    opt_convert__1__i = (unsigned long int)0;
    for( ; !((opts->options + (signed long int)opt_convert__1__i)->name == ((const char *)NULL)); opt_convert__1__i = opt_convert__1__i + 1ul)
      opt_convert__1__size = opt_convert__1__size + 1ul;
  }
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((opt_convert__1__size + (unsigned long int)1) * sizeof(struct option) /*32ul*/ );
  ret = (struct option *)return_value_malloc_1;
  if(ret == ((struct option *)NULL))
    return (struct option *)(void *)0;

  else
  {
    opts = options;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      signed int i = 0;
      for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); index = index + 1)
      {
        (ret + (signed long int)index)->name = (char *)(opts->options + (signed long int)i)->name;
        (ret + (signed long int)index)->has_arg = (opts->options + (signed long int)i)->has_arg;
        (ret + (signed long int)index)->flag = (signed int *)(void *)0;
        (ret + (signed long int)index)->val = 0;
        i = i + 1;
      }
    }
    memset((void *)(ret + (signed long int)index), 0, sizeof(struct option) /*32ul*/ );
    return ret;
  }
}

// opt_optstring
// file libslack/prog.c line 1806
static char * opt_optstring(struct Options *options)
{
  struct Options *opts;
  unsigned long int opt_optstring__1__size = (unsigned long int)0;
  unsigned long int i;
  char *optstring;
  char *p;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
  {
    i = (unsigned long int)0;
    for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1ul)
      if(!((opts->options + (signed long int)i)->short_name == 0))
        opt_optstring__1__size = opt_optstring__1__size + 1ul;

  }
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((opt_optstring__1__size * (unsigned long int)3 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
  optstring = (char *)return_value_malloc_1;
  p = optstring;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  if(p == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    opts = options;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      signed int opt_optstring__1__2__1__i = 0;
      for( ; !((opts->options + (signed long int)opt_optstring__1__2__1__i)->name == ((const char *)NULL)); opt_optstring__1__2__1__i = opt_optstring__1__2__1__i + 1)
        if(!((opts->options + (signed long int)opt_optstring__1__2__1__i)->short_name == 0))
        {
          char short_name = (opts->options + (signed long int)opt_optstring__1__2__1__i)->short_name;
          if((signed int)short_name == 63)
            short_name = (char)1;

          tmp_post_2 = p;
          p = p + 1l;
          *tmp_post_2 = short_name;
          switch((opts->options + (signed long int)opt_optstring__1__2__1__i)->has_arg)
          {
            case 2:
            {
              tmp_post_3 = p;
              p = p + 1l;
              *tmp_post_3 = (char)58;
            }
            case 1:
            {
              tmp_post_4 = p;
              p = p + 1l;
              *tmp_post_4 = (char)58;
            }
          }
        }

    }
    *p = (char)0;
    return optstring;
  }
}

// opt_process
// file libslack/prog.c line 2051
signed int opt_process(signed int argc, char **argv, struct Options *options, char *msgbuf, unsigned long int bufsize)
{
  struct option *long_options;
  char *optstring;
  long_options=opt_convert(options);
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  if(long_options == ((struct option *)NULL))
    return optind;

  else
  {
    optstring=opt_optstring(options);
    if(optstring == ((char *)NULL))
    {
      free((void *)long_options);
      return optind;
    }

    else
    {
      do
      {
        signed int longindex = -1;
        signed int rc;
        rc=getopt_long(argc, argv, optstring, long_options, &longindex);
        if(rc == -1)
          break;

        if(rc == 58 || rc == 63)
        {
          free((void *)long_options);
          free((void *)optstring);
          signed int return_value_set_errno_1;
          return_value_set_errno_1=set_errno(22);
          return return_value_set_errno_1;
        }

        if(rc == 1)
          rc = 63;

        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 0;
        opt_action(options, rc, longindex, optarg);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 34)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value___errno_location_5=__errno_location();
          tmp_if_expr_6 = *return_value___errno_location_5 == 33 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          if(!(msgbuf == ((char *)NULL)))
          {
            char optname[256l];
            if(longindex == -1 && !(rc == 0))
              snprintf(optname, (unsigned long int)256, "-%c", rc);

            else
              if(rc == 0 && !(longindex == -1))
                snprintf(optname, (unsigned long int)256, "--%s", (long_options + (signed long int)longindex)->name);

            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            snprintf(msgbuf, bufsize, "%s: invalid %s argument: %s", *argv, (const void *)optname, *return_value___errno_location_3 == 33 ? "not an integer" : "integer out of range");
          }

          free((void *)long_options);
          free((void *)optstring);
          return -1;
        }

      }
      while((_Bool)1);
      free((void *)long_options);
      free((void *)optstring);
      return optind;
    }
  }
}

// opt_usage
// file libslack/prog.c line 2139
char * opt_usage(char *buf, unsigned long int size, struct Options *options)
{
  const signed int total_width = 80;
  const char * const indent = "      ";
  unsigned long int indent_width;
  indent_width=strlen(indent);
  const char * const leader = " - ";
  unsigned long int leader_width;
  leader_width=strlen(leader);
  struct Options *opts;
  struct Options **stack;
  unsigned long int max_width = (unsigned long int)0;
  unsigned long int depth = (unsigned long int)0;
  unsigned long int length = (unsigned long int)0;
  unsigned long int remainder = (unsigned long int)0;
  signed int i;
  opts = options;
  for( ; !(opts == ((struct Options *)NULL)); depth = depth + 1ul)
  {
    i = 0;
    for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    {
      struct Option *opt = opts->options + (signed long int)i;
      unsigned long int width;
      width=strlen(opt->name);
      if(!(opt->argname == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(opt->argname);
        width = width + (unsigned long int)1 + return_value_strlen_1;
        if(opt->has_arg == 2)
          width = width + (unsigned long int)2;

      }

      if(!(max_width >= width))
        max_width = width;

    }
    opts = opts->parent;
  }
  max_width = max_width + (unsigned long int)6;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(depth * sizeof(struct Options *) /*8ul*/ );
  stack = (struct Options **)return_value_malloc_2;
  signed int tmp_post_3;
  unsigned long int tmp_post_4;
  signed int tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  const unsigned short int **return_value___ctype_b_loc_6;
  const unsigned short int **return_value___ctype_b_loc_8;
  const unsigned short int **return_value___ctype_b_loc_10;
  const unsigned short int **return_value___ctype_b_loc_11;
  if(stack == ((struct Options **)NULL))
    return (char *)(void *)0;

  else
  {
    opts = options;
    i = 0;
    for( ; !(opts == ((struct Options *)NULL)); opts = opts->parent)
    {
      tmp_post_3 = i;
      i = i + 1;
      stack[(signed long int)tmp_post_3] = opts;
    }
    do
    {
      tmp_post_4 = depth;
      depth = depth - 1ul;
      if(tmp_post_4 == 0ul)
        break;

      opts = stack[(signed long int)depth];
      snprintf(buf + (signed long int)length, size - length, "\n");
      length=strlen(buf);
      i = 0;
      for( ; !((opts->options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
      {
        struct Option *opt_usage__1__3__1__1__opt = opts->options + (signed long int)i;
        char help[8192l];
        const char *desc;
        const char *next = (const char *)(void *)0;
        unsigned long int desc_length;
        unsigned long int help_length;
        if(!(opt_usage__1__3__1__1__opt->short_name == 0))
          tmp_if_expr_5 = (signed int)opt_usage__1__3__1__1__opt->short_name;

        else
          tmp_if_expr_5 = 32;
        snprintf(help, (unsigned long int)8192, "%s%c%c%c --%s", indent, opt_usage__1__3__1__1__opt->short_name != 0 ? 45 : 32, tmp_if_expr_5, opt_usage__1__3__1__1__opt->short_name != 0 ? 44 : 32, opt_usage__1__3__1__1__opt->name);
        help_length=strlen(help);
        if(!(opt_usage__1__3__1__1__opt->argname == ((const char *)NULL)))
        {
          signed int optional = (signed int)(opt_usage__1__3__1__1__opt->has_arg == 2);
          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%s%s%s", optional != 0 ? "[=" : "=", opt_usage__1__3__1__1__opt->argname, optional != 0 ? "]" : "");
          help_length=strlen(help);
        }

        snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%s", (signed int)((max_width - help_length) + indent_width), (const void *)"", leader);
        help_length=strlen(help);
        remainder = (unsigned long int)total_width - help_length;
        desc = opt_usage__1__3__1__1__opt->desc;
        do
        {
          desc_length=strlen(desc);
          if(remainder >= desc_length)
            break;

          if(!(desc == opt_usage__1__3__1__1__opt->desc))
          {
            snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%*.*s", (signed int)(indent_width + max_width), (const void *)"", (signed int)leader_width, (signed int)leader_width, (const void *)"");
            help_length=strlen(help);
          }

          next = desc + (signed long int)remainder;
          do
          {
            if(!(desc >= next))
            {
              return_value___ctype_b_loc_6=__ctype_b_loc();
              tmp_if_expr_7 = !(((signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned int)*next] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_7 = (_Bool)0;
            if(!tmp_if_expr_7)
              break;

            next = next - 1l;
          }
          while((_Bool)1);
          if(next == desc)
          {
            do
            {
              return_value___ctype_b_loc_8=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned int)*next]) == 0)
                break;

              next = next + 1l;
            }
            while((_Bool)1);
            char *return_value___builtin_strchr_9;
            return_value___builtin_strchr_9=__builtin_strchr(desc, 32);
            next = return_value___builtin_strchr_9;
            if(next == ((const char *)NULL))
              next = desc + (signed long int)desc_length;

          }

          for( ; !(next == desc); next = next - 1l)
          {
            return_value___ctype_b_loc_10=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)(unsigned int)next[-1l]]) == 0)
              break;

          }
          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*.*s\n", (signed int)(next - desc), (signed int)(next - desc), desc);
          help_length=strlen(help);
          do
          {
            return_value___ctype_b_loc_11=__ctype_b_loc();
            if((8192 & (signed int)(*return_value___ctype_b_loc_11)[(signed long int)(signed int)(unsigned int)*next]) == 0)
              break;

            next = next + 1l;
          }
          while((_Bool)1);
          desc = next;
        }
        while((_Bool)1);
        if(!(desc_length == 0ul))
        {
          if(!(desc == opt_usage__1__3__1__1__opt->desc))
          {
            snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%*s%*.*s", (signed int)(indent_width + max_width), (const void *)"", (signed int)leader_width, (signed int)leader_width, (const void *)"");
            help_length=strlen(help);
          }

          snprintf(help + (signed long int)help_length, (unsigned long int)8192 - help_length, "%s\n", desc);
        }

        snprintf(buf + (signed long int)length, size - length, "%s", (const void *)help);
        length=strlen(buf);
      }
    }
    while((_Bool)1);
    free((void *)stack);
    return buf;
  }
}

// pack
// file libslack/net.c line 3000
signed long int pack(void *buf, unsigned long int size, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_vpack_1;
  return_value_vpack_1=vpack(buf, size, format, args);
  rc = (signed int)return_value_vpack_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// point_cmp
// file libslack/map.c line 2445
static signed int point_cmp(struct Point *a, struct Point *b)
{
  if(!(b->x >= a->x))
    return 1;

  else
    if(!(b->y >= a->y))
      return 1;

    else
      if(a->x == b->x)
      {
        if(!(a->y == b->y))
          goto __CPROVER_DUMP_L3;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return -1;
      }
}

// point_copy
// file libslack/map.c line 2440
static struct Point * point_copy(struct Point *point)
{
  struct Point *return_value_point_create_1;
  return_value_point_create_1=point_create(point->x, point->y);
  return return_value_point_create_1;
}

// point_create
// file libslack/map.c line 2427
static struct Point * point_create(signed int x, signed int y)
{
  struct Point *point;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)1 * sizeof(struct Point) /*8ul*/ );
  point = (struct Point *)return_value_malloc_1;
  if(point == ((struct Point *)NULL))
    return (struct Point *)(void *)0;

  else
  {
    point->x = x;
    point->y = y;
    return point;
  }
}

// point_hash
// file libslack/map.c line 2456
static unsigned long int point_hash(unsigned long int size, struct Point *point)
{
  return (unsigned long int)(point->x * 31 + point->y * 37) % size;
}

// point_release
// file libslack/map.c line 2461
static void point_release(struct Point *point)
{
  free((void *)point);
}

// pool_alloc
// file libslack/mem.c line 919
void * pool_alloc(struct Pool *pool, unsigned long int size)
{
  void *addr;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(pool == ((struct Pool *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return return_value_set_errnull_2;
    }

    else
    {
      if(!(pool->size >= pool->used + size))
      {
        if(!(pool->locker == ((struct Locker *)NULL)))
          pool->locker->unlock(pool->locker->lock);

        else
          0;
        void *return_value_set_errnull_4;
        return_value_set_errnull_4=set_errnull(28);
        return return_value_set_errnull_4;
      }

      addr = (void *)(pool->pool + (signed long int)pool->used);
      pool->used = pool->used + size;
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool->locker->unlock(pool->locker->lock);
        tmp_if_expr_6 = return_value_1;
      }

      else
        tmp_if_expr_6 = 0;
      err = tmp_if_expr_6;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return return_value_set_errnull_5;
      }

      else
        return addr;
    }
  }
}

// pool_clear
// file libslack/mem.c line 980
void pool_clear(struct Pool *pool)
{
  pool_clear_with_locker(pool, 1);
}

// pool_clear_secure
// file libslack/mem.c line 859
void pool_clear_secure(struct Pool *pool)
{
  signed int err;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    err = tmp_if_expr_1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_clear_unlocked(pool);
      memset((void *)pool->pool, 0xff, pool->size);
      memset((void *)pool->pool, 0xaa, pool->size);
      memset((void *)pool->pool, 0x55, pool->size);
      memset((void *)pool->pool, 0x00, pool->size);
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool->locker->unlock(pool->locker->lock);
        tmp_if_expr_2 = return_value_1;
      }

      else
        tmp_if_expr_2 = 0;
      err = tmp_if_expr_2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// pool_clear_unlocked
// file libslack/mem.c line 975
static void pool_clear_unlocked(struct Pool *pool)
{
  pool_clear_with_locker(pool, 0);
}

// pool_clear_with_locker
// file libslack/mem.c line 956
static void pool_clear_with_locker(struct Pool *pool, signed int lock_pool)
{
  signed int err;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(lock_pool == 0))
    {
      if(!(pool->locker == ((struct Locker *)NULL)))
      {
        return_value=pool->locker->wrlock(pool->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      err = tmp_if_expr_1;
      if(err == 0)
        goto __CPROVER_DUMP_L4;

      set_errno(err);
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      pool->used = (unsigned long int)0;
      if(!(lock_pool == 0))
      {
        if(!(pool->locker == ((struct Locker *)NULL)))
        {
          return_value_1=pool->locker->unlock(pool->locker->lock);
          tmp_if_expr_2 = return_value_1;
        }

        else
          tmp_if_expr_2 = 0;
        err = tmp_if_expr_2;
        if(!(err == 0))
          set_errno(err);

      }

    }
  }

}

// pool_create
// file libslack/mem.c line 616
struct Pool * pool_create(unsigned long int size)
{
  struct Pool *return_value_pool_create_with_locker_1;
  return_value_pool_create_with_locker_1=pool_create_with_locker((struct Locker *)(void *)0, size);
  return return_value_pool_create_with_locker_1;
}

// pool_create_secure
// file libslack/mem.c line 743
struct Pool * pool_create_secure(unsigned long int size)
{
  struct Pool *return_value_pool_create_secure_with_locker_1;
  return_value_pool_create_secure_with_locker_1=pool_create_secure_with_locker((struct Locker *)(void *)0, size);
  return return_value_pool_create_secure_with_locker_1;
}

// pool_create_secure_with_locker
// file libslack/mem.c line 759
struct Pool * pool_create_secure_with_locker(struct Locker *locker, unsigned long int size)
{
  struct Pool *pool;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)1 * sizeof(struct Pool) /*32ul*/ );
  pool = (struct Pool *)return_value_malloc_1;
  if(pool == ((struct Pool *)NULL))
    return (struct Pool *)(void *)0;

  else
  {
    void *return_value_mem_create_secure_2;
    return_value_mem_create_secure_2=mem_create_secure(size);
    pool->pool = (char *)return_value_mem_create_secure_2;
    if(pool->pool == ((char *)NULL))
    {
      free((void *)pool);
      return (struct Pool *)(void *)0;
    }

    else
    {
      pool->size = size;
      pool->used = (unsigned long int)0;
      pool->locker = locker;
      return pool;
    }
  }
}

// pool_create_with_locker
// file libslack/mem.c line 632
struct Pool * pool_create_with_locker(struct Locker *locker, unsigned long int size)
{
  struct Pool *pool;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)1 * sizeof(struct Pool) /*32ul*/ );
  pool = (struct Pool *)return_value_malloc_1;
  if(pool == ((struct Pool *)NULL))
    return (struct Pool *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(size);
    pool->pool = (char *)return_value_malloc_2;
    if(pool->pool == ((char *)NULL))
    {
      free((void *)pool);
      return (struct Pool *)(void *)0;
    }

    else
    {
      pool->size = size;
      pool->used = (unsigned long int)0;
      pool->locker = locker;
      return pool;
    }
  }
}

// pool_destroy
// file libslack/mem.c line 714
void * pool_destroy(struct Pool **pool)
{
  if(!(pool == ((struct Pool **)NULL)))
  {
    if(!(*pool == ((struct Pool *)NULL)))
    {
      pool_release(*pool);
      *pool = (struct Pool *)(void *)0;
    }

  }

  return (void *)0;
}

// pool_destroy_secure
// file libslack/mem.c line 834
void * pool_destroy_secure(struct Pool **pool)
{
  if(!(pool == ((struct Pool **)NULL)))
  {
    if(!(*pool == ((struct Pool *)NULL)))
    {
      pool_release_secure(*pool);
      *pool = (struct Pool *)(void *)0;
    }

  }

  return (void *)0;
}

// pool_release
// file libslack/mem.c line 680
void pool_release(struct Pool *pool)
{
  struct Locker *pool_release__1__locker;
  signed int err;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    err = tmp_if_expr_1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_release__1__locker = pool->locker;
      free((void *)pool->pool);
      free((void *)pool);
      if(!(pool_release__1__locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool_release__1__locker->unlock(pool_release__1__locker->lock);
        tmp_if_expr_2 = return_value_1;
      }

      else
        tmp_if_expr_2 = 0;
      err = tmp_if_expr_2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// pool_release_secure
// file libslack/mem.c line 797
void pool_release_secure(struct Pool *pool)
{
  struct Locker *pool_release_secure__1__locker;
  signed int err;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(pool == ((struct Pool *)NULL)))
  {
    if(!(pool->locker == ((struct Locker *)NULL)))
    {
      return_value=pool->locker->wrlock(pool->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    err = tmp_if_expr_1;
    if(!(err == 0))
      set_errno(err);

    else
    {
      pool_release_secure__1__locker = pool->locker;
      mem_release_secure((void *)pool->pool);
      free((void *)pool);
      if(!(pool_release_secure__1__locker == ((struct Locker *)NULL)))
      {
        return_value_1=pool_release_secure__1__locker->unlock(pool_release_secure__1__locker->lock);
        tmp_if_expr_2 = return_value_1;
      }

      else
        tmp_if_expr_2 = 0;
      err = tmp_if_expr_2;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// produce
// file libslack/map.c line 2497
void * produce(void *arg)
{
  signed int i;
  signed int test = *((signed int *)arg);
  i = 1;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  for( ; lim >= i; i = i + 1)
  {
    if(!(debug == 0))
      printf("p: add %d\n", i);

    signed int return_value_map_add_3;
    return_value_map_add_3=map_add(mtmap, (void *)(signed long int)i, (void *)(signed long int)i);
    if(return_value_map_add_3 == -1)
    {
      errors = errors + 1;
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      printf("Test%d: map_add(mtmap, %d), failed (%s)\n", test, i, return_value_strerror_2);
    }

    write(size[(signed long int)1], (const void *)"", (unsigned long int)1);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// prog_alert
// file libslack/prog.h line 123
struct Msg * prog_alert(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.log;
    signed int prog_alert__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_alert__1__2__rc = tmp_if_expr_2;
    if(!(prog_alert__1__2__rc == 0))
    {
      set_errno(prog_alert__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_alert_fd
// file libslack/prog.c line 1305
signed int prog_alert_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g_link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert_1;
    return_value_prog_set_alert_1=prog_set_alert(mesg);
    if(return_value_prog_set_alert_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_alert_file
// file libslack/prog.c line 1367
signed int prog_alert_file(const char *path)
{
  struct Msg *prog_alert_file__1__alert;
  prog_alert_file__1__alert=msg_create_file_with_locker(g_link2.locker, path);
  if(prog_alert_file__1__alert == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert_1;
    return_value_prog_set_alert_1=prog_set_alert(prog_alert_file__1__alert);
    if(return_value_prog_set_alert_1 == ((struct Msg *)NULL))
    {
      msg_release(prog_alert_file__1__alert);
      return -1;
    }

    else
      return 0;
  }
}

// prog_alert_none
// file libslack/prog.c line 1423
signed int prog_alert_none(void)
{
  struct Msg *return_value_prog_set_alert_1;
  return_value_prog_set_alert_1=prog_set_alert((struct Msg *)(void *)0);
  return return_value_prog_set_alert_1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_alert_stderr
// file libslack/prog.c line 1350
signed int prog_alert_stderr(void)
{
  signed int return_value_prog_alert_fd_1;
  return_value_prog_alert_fd_1=prog_alert_fd(2);
  return return_value_prog_alert_fd_1;
}

// prog_alert_stdout
// file libslack/prog.c line 1333
signed int prog_alert_stdout(void)
{
  signed int return_value_prog_alert_fd_1;
  return_value_prog_alert_fd_1=prog_alert_fd(1);
  return return_value_prog_alert_fd_1;
}

// prog_alert_syslog
// file libslack/prog.c line 1395
signed int prog_alert_syslog(const char *id, signed int option, signed int facility, signed int priority)
{
  struct Msg *prog_alert_syslog__1__alert;
  prog_alert_syslog__1__alert=msg_create_syslog_with_locker(g_link2.locker, id, option, facility, priority);
  if(prog_alert_syslog__1__alert == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_alert_1;
    return_value_prog_set_alert_1=prog_set_alert(prog_alert_syslog__1__alert);
    if(return_value_prog_set_alert_1 == ((struct Msg *)NULL))
    {
      msg_release(prog_alert_syslog__1__alert);
      return -1;
    }

    else
      return 0;
  }
}

// prog_author
// file libslack/prog.c line 757
const char * prog_author(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.author;
    signed int prog_author__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_author__1__2__rc = tmp_if_expr_2;
    if(!(prog_author__1__2__rc == 0))
    {
      set_errno(prog_author__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_basename
// file libslack/prog.c line 1668
const char * prog_basename(const char *path)
{
  const char *name;
  void *return_value_set_errnull_1;
  if(path == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (const char *)return_value_set_errnull_1;
  }

  else
  {
    name=strrchr(path, 47);
    return name != ((const char *)NULL) ? name + (signed long int)1 : path;
  }
}

// prog_contact
// file libslack/prog.c line 773
const char * prog_contact(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.contact;
    signed int prog_contact__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_contact__1__2__rc = tmp_if_expr_2;
    if(!(prog_contact__1__2__rc == 0))
    {
      set_errno(prog_contact__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_date
// file libslack/prog.c line 741
const char * prog_date(void)
{
  void *value;
  signed int prog_date__1__1__rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  prog_date__1__1__rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(prog_date__1__1__rc == 0))
  {
    set_errno(prog_date__1__1__rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.date;
    signed int rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    rc = tmp_if_expr_2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_dbg
// file libslack/prog.h line 122
struct Msg * prog_dbg(void)
{
  void *value;
  signed int prog_dbg__1__1__rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  prog_dbg__1__1__rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(prog_dbg__1__1__rc == 0))
  {
    set_errno(prog_dbg__1__1__rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.dbg;
    signed int rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    rc = tmp_if_expr_2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_dbg_fd
// file libslack/prog.c line 1170
signed int prog_dbg_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g_link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg_1;
    return_value_prog_set_dbg_1=prog_set_dbg(mesg);
    if(return_value_prog_set_dbg_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_dbg_file
// file libslack/prog.c line 1232
signed int prog_dbg_file(const char *path)
{
  struct Msg *dbg;
  dbg=msg_create_file_with_locker(g_link2.locker, path);
  if(dbg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg_1;
    return_value_prog_set_dbg_1=prog_set_dbg(dbg);
    if(return_value_prog_set_dbg_1 == ((struct Msg *)NULL))
    {
      msg_release(dbg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_dbg_none
// file libslack/prog.c line 1288
signed int prog_dbg_none(void)
{
  struct Msg *return_value_prog_set_dbg_1;
  return_value_prog_set_dbg_1=prog_set_dbg((struct Msg *)(void *)0);
  return return_value_prog_set_dbg_1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_dbg_stderr
// file libslack/prog.c line 1215
signed int prog_dbg_stderr(void)
{
  signed int return_value_prog_dbg_fd_1;
  return_value_prog_dbg_fd_1=prog_dbg_fd(2);
  return return_value_prog_dbg_fd_1;
}

// prog_dbg_stdout
// file libslack/prog.c line 1198
signed int prog_dbg_stdout(void)
{
  signed int return_value_prog_dbg_fd_1;
  return_value_prog_dbg_fd_1=prog_dbg_fd(1);
  return return_value_prog_dbg_fd_1;
}

// prog_dbg_syslog
// file libslack/prog.c line 1260
signed int prog_dbg_syslog(const char *id, signed int option, signed int facility, signed int priority)
{
  struct Msg *dbg;
  dbg=msg_create_syslog_with_locker(g_link2.locker, id, option, facility, priority);
  if(dbg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_dbg_1;
    return_value_prog_set_dbg_1=prog_set_dbg(dbg);
    if(return_value_prog_set_dbg_1 == ((struct Msg *)NULL))
    {
      msg_release(dbg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_debug_level
// file libslack/prog.h line 124
unsigned long int prog_debug_level(void)
{
  signed int value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (unsigned long int)0;
  }

  else
  {
    value = (signed int)g_link2.debug_level;
    signed int prog_debug_level__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_debug_level__1__2__rc = tmp_if_expr_2;
    if(!(prog_debug_level__1__2__rc == 0))
    {
      set_errno(prog_debug_level__1__2__rc);
      return (unsigned long int)0;
    }

    else
      return (unsigned long int)value;
  }
}

// prog_desc
// file libslack/prog.c line 709
const char * prog_desc(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.desc;
    signed int prog_desc__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_desc__1__2__rc = tmp_if_expr_2;
    if(!(prog_desc__1__2__rc == 0))
    {
      set_errno(prog_desc__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_err
// file libslack/prog.h line 121
struct Msg * prog_err(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.err;
    signed int prog_err__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_err__1__2__rc = tmp_if_expr_2;
    if(!(prog_err__1__2__rc == 0))
    {
      set_errno(prog_err__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_err_fd
// file libslack/prog.c line 1052
signed int prog_err_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g_link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err_1;
    return_value_prog_set_err_1=prog_set_err(mesg);
    if(return_value_prog_set_err_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_err_file
// file libslack/prog.c line 1097
signed int prog_err_file(const char *path)
{
  struct Msg *mesg;
  mesg=msg_create_file_with_locker(g_link2.locker, path);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err_1;
    return_value_prog_set_err_1=prog_set_err(mesg);
    if(return_value_prog_set_err_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_err_none
// file libslack/prog.c line 1153
signed int prog_err_none(void)
{
  struct Msg *return_value_prog_set_err_1;
  return_value_prog_set_err_1=prog_set_err((struct Msg *)(void *)0);
  return return_value_prog_set_err_1 != ((struct Msg *)NULL) ? 0 : -1;
}

// prog_err_stderr
// file libslack/prog.c line 1080
signed int prog_err_stderr(void)
{
  signed int return_value_prog_err_fd_1;
  return_value_prog_err_fd_1=prog_err_fd(2);
  return return_value_prog_err_fd_1;
}

// prog_err_syslog
// file libslack/prog.c line 1125
signed int prog_err_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *mesg;
  mesg=msg_create_syslog_with_locker(g_link2.locker, ident, option, facility, priority);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_err_1;
    return_value_prog_set_err_1=prog_set_err(mesg);
    if(return_value_prog_set_err_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_help_msg
// file libslack/prog.c line 1540
void prog_help_msg(void)
{
  char buf[8192l];
  unsigned long int length = (unsigned long int)0;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  if(!(tmp_if_expr_1 == 0))
    exit(1);

  snprintf(buf, (unsigned long int)8192, "usage: %s %s\n", g_link2.name != ((const char *)NULL) ? g_link2.name : "", g_link2.syntax != ((const char *)NULL) ? g_link2.syntax : "");
  if(!(g_link2.options == ((struct Options *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "options:\n");
    length=strlen(buf);
    opt_usage(buf + (signed long int)length, (unsigned long int)8192 - length, g_link2.options);
  }

  if(!(g_link2.desc == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "\n%s\n", g_link2.desc);
  }

  if(!(g_link2.name == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Name: %s\n", g_link2.name);
  }

  if(!(g_link2.version == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Version: %s\n", g_link2.version);
  }

  if(!(g_link2.date == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Date: %s\n", g_link2.date);
  }

  if(!(g_link2.author == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Author: %s\n", g_link2.author);
  }

  if(!(g_link2.vendor == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Vendor: %s\n", g_link2.vendor);
  }

  if(!(g_link2.url == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "URL: %s\n", g_link2.url);
  }

  if(!(g_link2.legal == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "\n%s\n", g_link2.legal);
  }

  if(!(g_link2.contact == ((const char *)NULL)))
  {
    length=strlen(buf);
    snprintf(buf + (signed long int)length, (unsigned long int)8192 - length, "Report bugs to %s\n", g_link2.contact);
  }

  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
    tmp_if_expr_2 = return_value_1;
  }

  else
    tmp_if_expr_2 = 0;
  if(!(tmp_if_expr_2 == 0))
    exit(1);

  msg("%s", (const void *)buf);
  exit(0);
}

// prog_init
// file libslack/prog.c line 245
void prog_init(void)
{
  prog_out_stdout();
  prog_err_stderr();
  prog_dbg_stderr();
  prog_alert_stderr();
}

// prog_legal
// file libslack/prog.c line 821
const char * prog_legal(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.legal;
    signed int prog_legal__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_legal__1__2__rc = tmp_if_expr_2;
    if(!(prog_legal__1__2__rc == 0))
    {
      set_errno(prog_legal__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_name
// file libslack/prog.h line 109
const char * prog_name(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.name;
    signed int prog_name__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_name__1__2__rc = tmp_if_expr_2;
    if(!(prog_name__1__2__rc == 0))
    {
      set_errno(prog_name__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_opt_process
// file libslack/prog.c line 1452
signed int prog_opt_process(signed int ac, char **av)
{
  char msgbuf[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int err;
  signed int rc;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_set_errno_3;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    rc=opt_process(ac, av, g_link2.options, msgbuf, (unsigned long int)256);
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_4 = return_value_1;
    }

    else
      tmp_if_expr_4 = 0;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_3=set_errno(err);
      return return_value_set_errno_3;
    }

    else
    {
      if(rc == -1)
        prog_usage_msg(msgbuf);

      return rc;
    }
  }
}

// prog_options
// file libslack/prog.c line 677
const struct Options * prog_options(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const struct Options *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.options;
    signed int prog_options__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_options__1__2__rc = tmp_if_expr_2;
    if(!(prog_options__1__2__rc == 0))
    {
      set_errno(prog_options__1__2__rc);
      return (const struct Options *)(void *)0;
    }

    else
      return (const struct Options *)value;
  }
}

// prog_out
// file libslack/prog.h line 120
struct Msg * prog_out(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.out;
    signed int prog_out__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_out__1__2__rc = tmp_if_expr_2;
    if(!(prog_out__1__2__rc == 0))
    {
      set_errno(prog_out__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return (struct Msg *)value;
  }
}

// prog_out_fd
// file libslack/prog.c line 934
signed int prog_out_fd(signed int fd)
{
  struct Msg *mesg;
  mesg=msg_create_fd_with_locker(g_link2.locker, fd);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out_1;
    return_value_prog_set_out_1=prog_set_out(mesg);
    if(return_value_prog_set_out_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_out_file
// file libslack/prog.c line 978
signed int prog_out_file(const char *path)
{
  struct Msg *mesg;
  mesg=msg_create_file_with_locker(g_link2.locker, path);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out_1;
    return_value_prog_set_out_1=prog_set_out(mesg);
    if(return_value_prog_set_out_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_out_none
// file libslack/prog.c line 1033
signed int prog_out_none(void)
{
  prog_set_out((struct Msg *)(void *)0);
  return 0;
}

// prog_out_stdout
// file libslack/prog.c line 961
signed int prog_out_stdout(void)
{
  signed int return_value_prog_out_fd_1;
  return_value_prog_out_fd_1=prog_out_fd(1);
  return return_value_prog_out_fd_1;
}

// prog_out_syslog
// file libslack/prog.c line 1006
signed int prog_out_syslog(const char *ident, signed int option, signed int facility, signed int priority)
{
  struct Msg *mesg;
  mesg=msg_create_syslog_with_locker(g_link2.locker, ident, option, facility, priority);
  if(mesg == ((struct Msg *)NULL))
    return -1;

  else
  {
    struct Msg *return_value_prog_set_out_1;
    return_value_prog_set_out_1=prog_set_out(mesg);
    if(return_value_prog_set_out_1 == ((struct Msg *)NULL))
    {
      msg_release(mesg);
      return -1;
    }

    else
      return 0;
  }
}

// prog_set_alert
// file libslack/prog.c line 555
struct Msg * prog_set_alert(struct Msg *alert)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g_link2.log == ((struct Msg *)NULL)) && !(g_link2.log == alert))
      msg_release(g_link2.log);

    g_link2.log = alert;
    signed int prog_set_alert__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_alert__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_alert__1__2__rc == 0))
    {
      set_errno(prog_set_alert__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return alert;
  }
}

// prog_set_author
// file libslack/prog.c line 408
const char * prog_set_author(const char *author)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.author = author;
    signed int prog_set_author__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_author__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_author__1__2__rc == 0))
    {
      set_errno(prog_set_author__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.author;
  }
}

// prog_set_contact
// file libslack/prog.c line 426
const char * prog_set_contact(const char *contact)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.contact = contact;
    signed int prog_set_contact__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_contact__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_contact__1__2__rc == 0))
    {
      set_errno(prog_set_contact__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.contact;
  }
}

// prog_set_date
// file libslack/prog.c line 391
const char * prog_set_date(const char *date)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.date = date;
    signed int prog_set_date__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_date__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_date__1__2__rc == 0))
    {
      set_errno(prog_set_date__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.date;
  }
}

// prog_set_dbg
// file libslack/prog.c line 537
struct Msg * prog_set_dbg(struct Msg *dbg)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g_link2.dbg == ((struct Msg *)NULL)) && !(g_link2.dbg == dbg))
      msg_release(g_link2.dbg);

    g_link2.dbg = dbg;
    signed int prog_set_dbg__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_dbg__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_dbg__1__2__rc == 0))
    {
      set_errno(prog_set_dbg__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return dbg;
  }
}

// prog_set_debug_level
// file libslack/prog.c line 603
signed long int prog_set_debug_level(unsigned long int debug_level)
{
  unsigned long int prev;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (signed long int)-1;
  }

  else
  {
    prev = g_link2.debug_level;
    g_link2.debug_level = debug_level;
    signed int prog_set_debug_level__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_debug_level__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_debug_level__1__2__rc == 0))
    {
      set_errno(prog_set_debug_level__1__2__rc);
      return (signed long int)-1;
    }

    else
      return (signed long int)prev;
  }
}

// prog_set_desc
// file libslack/prog.c line 357
const char * prog_set_desc(const char *desc)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.desc = desc;
    signed int prog_set_desc__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_desc__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_desc__1__2__rc == 0))
    {
      set_errno(prog_set_desc__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.desc;
  }
}

// prog_set_err
// file libslack/prog.c line 519
struct Msg * prog_set_err(struct Msg *err)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g_link2.err == ((struct Msg *)NULL)) && !(g_link2.err == err))
      msg_release(g_link2.err);

    g_link2.err = err;
    signed int prog_set_err__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_err__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_err__1__2__rc == 0))
    {
      set_errno(prog_set_err__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return err;
  }
}

// prog_set_legal
// file libslack/prog.c line 478
const char * prog_set_legal(const char *legal)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.legal = legal;
    signed int prog_set_legal__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_legal__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_legal__1__2__rc == 0))
    {
      set_errno(prog_set_legal__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.legal;
  }
}

// prog_set_locker
// file libslack/prog.c line 640
signed int prog_set_locker(struct Locker *locker)
{
  if(!(g_link2.locker == ((struct Locker *)NULL)))
    return -1;

  else
  {
    g_link2.locker = locker;
    return 0;
  }
}

// prog_set_name
// file libslack/prog.c line 305
const char * prog_set_name(const char *name)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.name = name;
    signed int prog_set_name__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_name__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_name__1__2__rc == 0))
    {
      set_errno(prog_set_name__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.name;
  }
}

// prog_set_options
// file libslack/prog.c line 322
struct Options * prog_set_options(struct Options *options)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Options *)(void *)0;
  }

  else
  {
    g_link2.options = options;
    signed int prog_set_options__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_options__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_options__1__2__rc == 0))
    {
      set_errno(prog_set_options__1__2__rc);
      return (struct Options *)(void *)0;
    }

    else
      return g_link2.options;
  }
}

// prog_set_out
// file libslack/prog.c line 499
struct Msg * prog_set_out(struct Msg *out)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (struct Msg *)(void *)0;
  }

  else
  {
    if(!(g_link2.out == ((struct Msg *)NULL)) && !(g_link2.out == out))
      msg_release(g_link2.out);

    g_link2.out = out;
    signed int prog_set_out__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_out__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_out__1__2__rc == 0))
    {
      set_errno(prog_set_out__1__2__rc);
      return (struct Msg *)(void *)0;
    }

    else
      return out;
  }
}

// prog_set_syntax
// file libslack/prog.c line 340
const char * prog_set_syntax(const char *syntax)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.syntax = syntax;
    signed int prog_set_syntax__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_syntax__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_syntax__1__2__rc == 0))
    {
      set_errno(prog_set_syntax__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.syntax;
  }
}

// prog_set_url
// file libslack/prog.c line 460
const char * prog_set_url(const char *url)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.url = url;
    signed int prog_set_url__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_url__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_url__1__2__rc == 0))
    {
      set_errno(prog_set_url__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.url;
  }
}

// prog_set_vendor
// file libslack/prog.c line 443
const char * prog_set_vendor(const char *vendor)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.vendor = vendor;
    signed int prog_set_vendor__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_vendor__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_vendor__1__2__rc == 0))
    {
      set_errno(prog_set_vendor__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.vendor;
  }
}

// prog_set_verbosity_level
// file libslack/prog.c line 622
signed long int prog_set_verbosity_level(unsigned long int verbosity_level)
{
  unsigned long int prev;
  signed int prog_set_verbosity_level__1__1__rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  prog_set_verbosity_level__1__1__rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(prog_set_verbosity_level__1__1__rc == 0))
  {
    set_errno(prog_set_verbosity_level__1__1__rc);
    return (signed long int)-1;
  }

  else
  {
    prev = g_link2.verbosity_level;
    g_link2.verbosity_level = verbosity_level;
    signed int rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    rc = tmp_if_expr_2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (signed long int)-1;
    }

    else
      return (signed long int)prev;
  }
}

// prog_set_version
// file libslack/prog.c line 374
const char * prog_set_version(const char *version)
{
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->wrlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    g_link2.version = version;
    signed int prog_set_version__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_set_version__1__2__rc = tmp_if_expr_2;
    if(!(prog_set_version__1__2__rc == 0))
    {
      set_errno(prog_set_version__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return g_link2.version;
  }
}

// prog_syntax
// file libslack/prog.c line 693
const char * prog_syntax(void)
{
  void *value;
  signed int prog_syntax__1__1__rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  prog_syntax__1__1__rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(prog_syntax__1__1__rc == 0))
  {
    set_errno(prog_syntax__1__1__rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.syntax;
    signed int rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    rc = tmp_if_expr_2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_url
// file libslack/prog.c line 805
const char * prog_url(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.url;
    signed int prog_url__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_url__1__2__rc = tmp_if_expr_2;
    if(!(prog_url__1__2__rc == 0))
    {
      set_errno(prog_url__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_usage_msg
// file libslack/prog.c line 1495
void prog_usage_msg(const char *format, ...)
{
  char msg_buf[8192l];
  char opt_buf[8192l];
  signed int msg_length;
  void **args = (void **)&format;
  vsnprintf(msg_buf, (unsigned long int)8192, format, args);
  args = ((void **)NULL);
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  if(!(tmp_if_expr_1 == 0))
    exit(1);

  opt_usage(opt_buf, (unsigned long int)8192, g_link2.options);
  fflush(stderr);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(msg_buf);
  msg_length = (signed int)return_value_strlen_2;
  _Bool tmp_if_expr_3;
  if(!(msg_length == 0))
    tmp_if_expr_3 = (signed int)msg_buf[(signed long int)(msg_length - 1)] != 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  msg_out(g_link2.err, "%s%susage: %s%s%s\n%s%s", (const void *)msg_buf, tmp_if_expr_3 ? "\n" : "", g_link2.name != ((const char *)NULL) ? g_link2.name : "", g_link2.name != ((const char *)NULL) ? " " : "", g_link2.syntax != ((const char *)NULL) ? g_link2.syntax : "", opt_buf[0l] != 0 ? "options:\n" : "", (const void *)opt_buf);
  if(!(g_link2.locker == ((struct Locker *)NULL)))
    g_link2.locker->unlock(g_link2.locker->lock);

  else
    0;
  exit(1);
}

// prog_vendor
// file libslack/prog.c line 789
const char * prog_vendor(void)
{
  void *value;
  signed int prog_vendor__1__1__rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  prog_vendor__1__1__rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(prog_vendor__1__1__rc == 0))
  {
    set_errno(prog_vendor__1__1__rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.vendor;
    signed int rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    rc = tmp_if_expr_2;
    if(!(rc == 0))
    {
      set_errno(rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_verbosity_level
// file libslack/prog.h line 125
unsigned long int prog_verbosity_level(void)
{
  signed int value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (unsigned long int)0;
  }

  else
  {
    value = (signed int)g_link2.verbosity_level;
    signed int prog_verbosity_level__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_verbosity_level__1__2__rc = tmp_if_expr_2;
    if(!(prog_verbosity_level__1__2__rc == 0))
    {
      set_errno(prog_verbosity_level__1__2__rc);
      return (unsigned long int)0;
    }

    else
      return (unsigned long int)value;
  }
}

// prog_version
// file libslack/prog.c line 725
const char * prog_version(void)
{
  void *value;
  signed int rc;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  rc = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(rc == 0))
  {
    set_errno(rc);
    return (const char *)(void *)0;
  }

  else
  {
    value = (void *)g_link2.version;
    signed int prog_version__1__2__rc;
    if(!(g_link2.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
      tmp_if_expr_2 = return_value_1;
    }

    else
      tmp_if_expr_2 = 0;
    prog_version__1__2__rc = tmp_if_expr_2;
    if(!(prog_version__1__2__rc == 0))
    {
      set_errno(prog_version__1__2__rc);
      return (const char *)(void *)0;
    }

    else
      return (const char *)value;
  }
}

// prog_version_msg
// file libslack/prog.c line 1634
void prog_version_msg(void)
{
  char buf[8192l];
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link2.locker->rdlock(g_link2.locker->lock);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = 0;
  if(!(tmp_if_expr_1 == 0))
    exit(1);

  if(!(g_link2.name == ((const char *)NULL)) && !(g_link2.version == ((const char *)NULL)))
    snprintf(buf, (unsigned long int)8192, "%s-%s\n", g_link2.name, g_link2.version);

  else
    if(!(g_link2.name == ((const char *)NULL)))
      snprintf(buf, (unsigned long int)8192, "%s\n", g_link2.name);

    else
      if(!(g_link2.version == ((const char *)NULL)))
        snprintf(buf, (unsigned long int)8192, "%s\n", g_link2.version);

      else
        buf[0l] = (char)0;
  signed int tmp_if_expr_2;
  signed int return_value_1;
  if(!(g_link2.locker == ((struct Locker *)NULL)))
  {
    return_value_1=g_link2.locker->unlock(g_link2.locker->lock);
    tmp_if_expr_2 = return_value_1;
  }

  else
    tmp_if_expr_2 = 0;
  if(!(tmp_if_expr_2 == 0))
    exit(1);

  msg("%s", (const void *)buf);
  exit(0);
}

// prop_clear
// file libslack/prop.c line 1121
signed int prop_clear(void)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(g_link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link3.locker->wrlock(g_link3.locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_set_errno_3;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    prop_release(g_link3.prop);
    g_link3.prop = (struct Prop *)(void *)0;
    g_link3.init = 0;
    g_link3.dirty = 0;
    if(!(g_link3.locker == ((struct Locker *)NULL)))
    {
      return_value_1=g_link3.locker->unlock(g_link3.locker->lock);
      tmp_if_expr_4 = return_value_1;
    }

    else
      tmp_if_expr_4 = 0;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_3=set_errno(err);
      return return_value_set_errno_3;
    }

    else
      return 0;
  }
}

// prop_create
// file libslack/prop.c line 153
static struct Prop * prop_create(struct Map *map, struct Prop *defaults)
{
  struct Prop *prop;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct Prop) /*16ul*/ );
  prop = (struct Prop *)return_value_malloc_1;
  if(prop == ((struct Prop *)NULL))
    return (struct Prop *)(void *)0;

  else
  {
    prop->map = map;
    prop->defaults = defaults;
    return prop;
  }
}

// prop_get
// file libslack/prop.c line 540
const char * prop_get(const char *name)
{
  struct Prop *p;
  const char *value = (const char *)(void *)0;
  signed int err;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(g_link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link3.locker->wrlock(g_link3.locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  void *return_value_set_errnull_1;
  signed int return_value_prop_init_3;
  void *return_value_map_get_4;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(!(err == 0))
  {
    return_value_set_errnull_1=set_errnull(err);
    return (const char *)return_value_set_errnull_1;
  }

  else
    if(g_link3.init == 0)
    {
      return_value_prop_init_3=prop_init();
      if(!(return_value_prop_init_3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g_link3.locker == ((struct Locker *)NULL)))
        g_link3.locker->unlock(g_link3.locker->lock);

      else
        0;
      return (const char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      p = g_link3.prop;
      for( ; !(p == ((struct Prop *)NULL)); p = p->defaults)
      {
        return_value_map_get_4=map_get(p->map, (const void *)name);
        value = (const char *)return_value_map_get_4;
        if(!(value == ((const char *)NULL)))
          break;

      }
      if(!(g_link3.locker == ((struct Locker *)NULL)))
      {
        return_value_1=g_link3.locker->unlock(g_link3.locker->lock);
        tmp_if_expr_6 = return_value_1;
      }

      else
        tmp_if_expr_6 = 0;
      err = tmp_if_expr_6;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (const char *)return_value_set_errnull_5;
      }

      else
        return value;
    }
}

// prop_get_bool
// file libslack/prop.c line 759
signed int prop_get_bool(const char *name)
{
  signed int return_value_prop_get_bool_or_1;
  return_value_prop_get_bool_or_1=prop_get_bool_or(name, 0);
  return return_value_prop_get_bool_or_1;
}

// prop_get_bool_or
// file libslack/prop.c line 779
signed int prop_get_bool_or(const char *name, signed int default_value)
{
  const char *prop;
  prop=prop_get(name);
  char buf[128l];
  signed int val;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  if(prop == ((const char *)NULL))
    return default_value;

  else
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(prop, " %d ", &val);
    if(!(return_value_sscanf_1 == 0))
      return val;

    else
    {
      signed int return_value_sscanf_21;
      return_value_sscanf_21=sscanf(prop, " %s ", (const void *)buf);
      if(!(return_value_sscanf_21 == 0))
      {
        if((signed int)buf[0l] == 116)
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (signed int)buf[(signed long int)0] == 84 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          if((signed int)buf[1l] == 114)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)buf[(signed long int)1] == 82 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
          {
            if((signed int)buf[2l] == 117)
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = (signed int)buf[(signed long int)2] == 85 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_3)
            {
              if((signed int)buf[3l] == 101)
                tmp_if_expr_2 = (_Bool)1;

              else
                tmp_if_expr_2 = (signed int)buf[(signed long int)3] == 69 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_2)
              {
                if((signed int)buf[4l] == 0)
                  return 1;

              }

            }

          }

        }

        if((signed int)buf[0l] == 102)
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = (signed int)buf[(signed long int)0] == 70 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_10)
        {
          if((signed int)buf[1l] == 97)
            tmp_if_expr_9 = (_Bool)1;

          else
            tmp_if_expr_9 = (signed int)buf[(signed long int)1] == 65 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_9)
          {
            if((signed int)buf[2l] == 108)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = (signed int)buf[(signed long int)2] == 76 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
            {
              if((signed int)buf[3l] == 115)
                tmp_if_expr_7 = (_Bool)1;

              else
                tmp_if_expr_7 = (signed int)buf[(signed long int)3] == 83 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_7)
              {
                if((signed int)buf[4l] == 101)
                  tmp_if_expr_6 = (_Bool)1;

                else
                  tmp_if_expr_6 = (signed int)buf[(signed long int)4] == 69 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_6)
                {
                  if((signed int)buf[5l] == 0)
                    return 0;

                }

              }

            }

          }

        }

        if((signed int)buf[0l] == 121)
          tmp_if_expr_13 = (_Bool)1;

        else
          tmp_if_expr_13 = (signed int)buf[(signed long int)0] == 89 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_13)
        {
          if((signed int)buf[1l] == 101)
            tmp_if_expr_12 = (_Bool)1;

          else
            tmp_if_expr_12 = (signed int)buf[(signed long int)1] == 69 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_12)
          {
            if((signed int)buf[2l] == 115)
              tmp_if_expr_11 = (_Bool)1;

            else
              tmp_if_expr_11 = (signed int)buf[(signed long int)2] == 83 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_11)
            {
              if((signed int)buf[3l] == 0)
                return 1;

            }

          }

        }

        if((signed int)buf[0l] == 110)
          tmp_if_expr_15 = (_Bool)1;

        else
          tmp_if_expr_15 = (signed int)buf[(signed long int)0] == 78 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_15)
        {
          if((signed int)buf[1l] == 111)
            tmp_if_expr_14 = (_Bool)1;

          else
            tmp_if_expr_14 = (signed int)buf[(signed long int)1] == 79 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_14)
          {
            if((signed int)buf[2l] == 0)
              return 0;

          }

        }

        if((signed int)buf[0l] == 111)
          tmp_if_expr_17 = (_Bool)1;

        else
          tmp_if_expr_17 = (signed int)buf[(signed long int)0] == 79 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_17)
        {
          if((signed int)buf[1l] == 110)
            tmp_if_expr_16 = (_Bool)1;

          else
            tmp_if_expr_16 = (signed int)buf[(signed long int)1] == 78 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_16)
          {
            if((signed int)buf[2l] == 0)
              return 1;

          }

        }

        if((signed int)buf[0l] == 111)
          tmp_if_expr_20 = (_Bool)1;

        else
          tmp_if_expr_20 = (signed int)buf[(signed long int)0] == 79 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_20)
          goto __CPROVER_DUMP_L46;

        if((signed int)buf[1l] == 102)
          tmp_if_expr_19 = (_Bool)1;

        else
          tmp_if_expr_19 = (signed int)buf[(signed long int)1] == 70 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_19)
          goto __CPROVER_DUMP_L46;

        if((signed int)buf[2l] == 102)
          tmp_if_expr_18 = (_Bool)1;

        else
          tmp_if_expr_18 = (signed int)buf[(signed long int)2] == 70 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_18)
          goto __CPROVER_DUMP_L46;

        if(!((signed int)buf[3l] == 0))
          goto __CPROVER_DUMP_L46;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L46:
        ;
        return default_value;
      }
    }
  }
}

// prop_get_double
// file libslack/prop.c line 701
double prop_get_double(const char *name)
{
  double return_value_prop_get_double_or_1;
  return_value_prop_get_double_or_1=prop_get_double_or(name, 0.0);
  return return_value_prop_get_double_or_1;
}

// prop_get_double_or
// file libslack/prop.c line 718
double prop_get_double_or(const char *name, double default_value)
{
  const char *prop;
  prop=prop_get(name);
  double val;
  _Bool tmp_if_expr_2;
  signed int return_value_sscanf_1;
  if(!(prop == ((const char *)NULL)))
  {
    return_value_sscanf_1=sscanf(prop, "%lg", &val);
    tmp_if_expr_2 = return_value_sscanf_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return tmp_if_expr_2 ? val : default_value;
}

// prop_get_int
// file libslack/prop.c line 644
signed int prop_get_int(const char *name)
{
  signed int return_value_prop_get_int_or_1;
  return_value_prop_get_int_or_1=prop_get_int_or(name, 0);
  return return_value_prop_get_int_or_1;
}

// prop_get_int_or
// file libslack/prop.c line 661
signed int prop_get_int_or(const char *name, signed int default_value)
{
  const char *prop;
  prop=prop_get(name);
  signed int val;
  _Bool tmp_if_expr_2;
  signed int return_value_sscanf_1;
  if(!(prop == ((const char *)NULL)))
  {
    return_value_sscanf_1=sscanf(prop, " %d ", &val);
    tmp_if_expr_2 = return_value_sscanf_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return tmp_if_expr_2 ? val : default_value;
}

// prop_get_or
// file libslack/prop.c line 576
const char * prop_get_or(const char *name, const char *default_value)
{
  const char *prop;
  prop=prop_get(name);
  return prop != ((const char *)NULL) ? prop : default_value;
}

// prop_init
// file libslack/prop.c line 434
static signed int prop_init(void)
{
  char *path;
  struct Prop *prop = (struct Prop *)(void *)0;
  struct Prop *prop_next;
  char *home;
  signed int writable = 0;
  unsigned long int path_len;
  signed long int return_value_limit_path_1;
  return_value_limit_path_1=limit_path();
  path_len = (unsigned long int)return_value_limit_path_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(path_len * sizeof(char) /*1ul*/ );
  path = (char *)return_value_malloc_2;
  char *tmp_post_6;
  char *return_value___builtin_strchr_5;
  if(path == ((char *)NULL))
    return -1;

  else
  {
    snprintf(path, path_len, "%s%cproperties%capp", (const void *)"/etc", 47, 47);
    prop_next=prop_load(path, prop);
    if(!(prop_next == ((struct Prop *)NULL)))
      prop = prop_next;

    home=user_home();
    if(!(home == ((char *)NULL)))
    {
      snprintf(path, path_len, "%s%c.properties%capp", home, 47, 47);
      prop_next=prop_load(path, prop);
      if(!(prop_next == ((struct Prop *)NULL)))
        prop = prop_next;

    }

    const char *return_value_prog_name_7;
    return_value_prog_name_7=prog_name();
    if(!(return_value_prog_name_7 == ((const char *)NULL)))
    {
      char *progname;
      char *sep;
      const char *return_value_prog_name_3;
      return_value_prog_name_3=prog_name();
      progname=mem_strdup(return_value_prog_name_3);
      if(progname == ((char *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        return -1;
      }

      char *return_value___builtin_strchr_4;
      return_value___builtin_strchr_4=__builtin_strchr(progname, 47);
      sep = return_value___builtin_strchr_4;
      for( ; !(sep == ((char *)NULL)); sep = return_value___builtin_strchr_5)
      {
        tmp_post_6 = sep;
        sep = sep + 1l;
        *tmp_post_6 = (char)45;
        return_value___builtin_strchr_5=__builtin_strchr(sep, 47);
      }
      snprintf(path, path_len, "%s%cproperties%capp.%s", (const void *)"/etc", 47, 47, progname);
      prop_next=prop_load(path, prop);
      if(!(prop_next == ((struct Prop *)NULL)))
        prop = prop_next;

      if(!(home == ((char *)NULL)))
      {
        snprintf(path, path_len, "%s%c.properties%capp.%s", home, 47, 47, progname);
        prop_next=prop_load(path, prop);
        if(!(prop_next == ((struct Prop *)NULL)))
        {
          prop = prop_next;
          writable = 1;
        }

      }

      free((void *)progname);
    }

    if(writable == 0)
    {
      struct Map *map;
      map=map_create((void (*)(void *))free);
      if(map == ((struct Map *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        return -1;
      }

      prop_next=prop_create(map, prop);
      if(prop_next == ((struct Prop *)NULL))
      {
        free((void *)path);
        prop_release(prop);
        map_release(map);
        return -1;
      }

      prop = prop_next;
    }

    free((void *)path);
    g_link3.prop = prop;
    g_link3.init = 1;
    return 0;
  }
}

// prop_load
// file libslack/prop.c line 392
static struct Prop * prop_load(const char *path, struct Prop *defaults)
{
  struct Prop *prop;
  struct Map *map;
  map=map_create((void (*)(void *))free);
  if(map == ((struct Map *)NULL))
    return (struct Prop *)(void *)0;

  else
  {
    void *return_value_daemon_parse_config_1;
    return_value_daemon_parse_config_1=daemon_parse_config(path, (void *)map, (void (*)(void *, const char *, char *, unsigned long int))prop_parse);
    if(return_value_daemon_parse_config_1 == NULL)
    {
      map_release(map);
      return (struct Prop *)(void *)0;
    }

    else
    {
      prop=prop_create(map, defaults);
      if(prop == ((struct Prop *)NULL))
      {
        map_release(map);
        return (struct Prop *)(void *)0;
      }

      else
        return prop;
    }
  }
}

// prop_locker
// file libslack/prop.c line 1152
signed int prop_locker(struct Locker *locker)
{
  signed int return_value_set_errno_1;
  if(!(g_link3.locker == ((struct Locker *)NULL)))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    g_link3.locker = locker;
    return 0;
  }
}

// prop_parse
// file libslack/prop.c line 299
static void prop_parse(struct Map *map, const char *path, char *line, unsigned long int lineno)
{
  struct String *prop;
  struct String *name;
  char *p;
  char *prop_parse__1__eq;
  char *value;
  char *val;
  char *key;
  prop=unquote_special(line);
  _Bool tmp_if_expr_3;
  char *return_value___builtin_strchr_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  const unsigned short int **return_value___ctype_b_loc_5;
  const unsigned short int **return_value___ctype_b_loc_6;
  if(prop == ((struct String *)NULL))
    error("prop: Out of memory");

  else
  {
    p=cstr(prop);
    char *return_value___builtin_strchr_1;
    return_value___builtin_strchr_1=__builtin_strchr(p, 61);
    prop_parse__1__eq = return_value___builtin_strchr_1;
    for( ; !(prop_parse__1__eq == ((char *)NULL)); prop_parse__1__eq = return_value___builtin_strchr_2)
    {
      if(prop_parse__1__eq == p)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)prop_parse__1__eq[(signed long int)-1] != 92 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        break;

      return_value___builtin_strchr_2=__builtin_strchr(prop_parse__1__eq + (signed long int)1, 61);
    }
    if(prop_parse__1__eq == ((char *)NULL))
    {
      error("prop: %s line %d: Expected '='\n%s", path, lineno, line);
      str_release(prop);
      set_errno(22);
    }

    else
    {
      value = prop_parse__1__eq + (signed long int)1;
      do
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*value]) == 0)
          break;

        value = value + 1l;
      }
      while((_Bool)1);
      for( ; !(p >= prop_parse__1__eq); prop_parse__1__eq = prop_parse__1__eq - 1l)
      {
        return_value___ctype_b_loc_5=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)prop_parse__1__eq[-1l]]) == 0)
          break;

        if(!(prop_parse__1__eq == p + 1l))
        {
          if((signed int)prop_parse__1__eq[-2l] == 92)
            break;

        }

      }
      *prop_parse__1__eq = (char)0;
      if(!(p + 1l >= prop_parse__1__eq))
      {
        return_value___ctype_b_loc_6=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)prop_parse__1__eq[-1l]]) == 0))
        {
          if((signed int)prop_parse__1__eq[-2l] == 92)
          {
            prop_parse__1__eq[(signed long int)-2] = prop_parse__1__eq[(signed long int)-1];
            prop_parse__1__eq[(signed long int)-1] = (char)0;
          }

        }

      }

      name=unquote_equals(p);
      if(name == ((struct String *)NULL))
      {
        error("prop: Out of memory");
        str_release(prop);
      }

      else
      {
        key=cstr(name);
        if((signed int)*value == 92)
          value = value + 1l;

        val=mem_strdup(value);
        if(val == ((char *)NULL))
        {
          error("prop: Out of memory");
          str_release(prop);
          str_release(name);
        }

        else
        {
          signed int return_value_map_add_7;
          return_value_map_add_7=map_add(map, (const void *)key, (void *)val);
          if(return_value_map_add_7 == -1)
          {
            error("prop: %s line %d: Property %s already defined\n%s", path, lineno, name, line);
            free((void *)val);
          }

          str_release(prop);
          str_release(name);
        }
      }
    }
  }
}

// prop_release
// file libslack/prop.c line 174
static void prop_release(struct Prop *prop)
{
  if(!(prop == ((struct Prop *)NULL)))
  {
    map_release(prop->map);
    prop_release(prop->defaults);
    free((void *)prop);
  }

}

// prop_save
// file libslack/prop.c line 914
signed int prop_save(void)
{
  char *path;
  unsigned long int path_len;
  unsigned long int len;
  char *home;
  char *progname;
  char *sep;
  struct stat status[1l];
  struct List *keys;
  struct Lister *k;
  struct _IO_FILE *file;
  signed int err;
  signed int return_value_prop_get_bool_or_1;
  return_value_prop_get_bool_or_1=prop_get_bool_or("save", 1);
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  signed int return_value_mkdir_11;
  _Bool tmp_if_expr_15;
  char *tmp_post_19;
  char *return_value___builtin_strchr_18;
  signed int return_value_lister_has_next_21;
  const unsigned short int **return_value___ctype_b_loc_27;
  char *return_value_cstr_28;
  signed long int return_value_str_length_29;
  signed int tmp_if_expr_37;
  signed int return_value_2;
  signed int return_value_set_errno_36;
  if(return_value_prop_get_bool_or_1 == 0)
    return 0;

  else
  {
    if(!(g_link3.locker == ((struct Locker *)NULL)))
    {
      return_value=g_link3.locker->wrlock(g_link3.locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      if(g_link3.dirty == 0)
      {
        if(!(g_link3.locker == ((struct Locker *)NULL)))
        {
          return_value_1=g_link3.locker->unlock(g_link3.locker->lock);
          tmp_if_expr_5 = return_value_1;
        }

        else
          tmp_if_expr_5 = 0;
        err = tmp_if_expr_5;
        if(!(err == 0))
        {
          return_value_set_errno_4=set_errno(err);
          return return_value_set_errno_4;
        }

        return 0;
      }

      const char *return_value_prog_name_7;
      return_value_prog_name_7=prog_name();
      if(return_value_prog_name_7 == ((const char *)NULL))
      {
        if(!(g_link3.locker == ((struct Locker *)NULL)))
          g_link3.locker->unlock(g_link3.locker->lock);

        else
          0;
        signed int return_value_set_errno_6;
        return_value_set_errno_6=set_errno(22);
        return return_value_set_errno_6;
      }

      home=user_home();
      if(home == ((char *)NULL))
      {
        if(!(g_link3.locker == ((struct Locker *)NULL)))
          g_link3.locker->unlock(g_link3.locker->lock);

        else
          0;
        signed int return_value_set_errno_8;
        return_value_set_errno_8=set_errno(22);
        return return_value_set_errno_8;
      }

      signed long int return_value_limit_path_9;
      return_value_limit_path_9=limit_path();
      path_len = (unsigned long int)return_value_limit_path_9;
      void *return_value_malloc_10;
      return_value_malloc_10=malloc(path_len * sizeof(char) /*1ul*/ );
      path = (char *)return_value_malloc_10;
      if(path == ((char *)NULL))
      {
        if(!(g_link3.locker == ((struct Locker *)NULL)))
          g_link3.locker->unlock(g_link3.locker->lock);

        else
          0;
        return -1;
      }

      else
      {
        snprintf(path, path_len, "%s%c.properties", home, 47);
        signed int return_value_stat_12;
        return_value_stat_12=stat_link2(path, status);
        if(return_value_stat_12 == -1)
        {
          return_value_mkdir_11=mkdir(path, (unsigned int)(0400 | 0200 | 0100));
          if(!(return_value_mkdir_11 == -1))
            goto __CPROVER_DUMP_L20;

          free((void *)path);
          if(!(g_link3.locker == ((struct Locker *)NULL)))
            g_link3.locker->unlock(g_link3.locker->lock);

          else
            0;
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L20:
          ;
          signed int return_value_stat_14;
          return_value_stat_14=stat_link2(path, status);
          if(return_value_stat_14 == -1)
            tmp_if_expr_15 = (_Bool)1;

          else
            tmp_if_expr_15 = (signed int)((status[0l].st_mode & (unsigned int)0170000) == (unsigned int)0040000) == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_15)
          {
            free((void *)path);
            if(!(g_link3.locker == ((struct Locker *)NULL)))
              g_link3.locker->unlock(g_link3.locker->lock);

            else
              0;
            signed int return_value_set_errno_13;
            return_value_set_errno_13=set_errno(22);
            return return_value_set_errno_13;
          }

          const char *return_value_prog_name_16;
          return_value_prog_name_16=prog_name();
          progname=mem_strdup(return_value_prog_name_16);
          if(progname == ((char *)NULL))
          {
            free((void *)path);
            if(!(g_link3.locker == ((struct Locker *)NULL)))
              g_link3.locker->unlock(g_link3.locker->lock);

            else
              0;
            return -1;
          }

          else
          {
            char *return_value___builtin_strchr_17;
            return_value___builtin_strchr_17=__builtin_strchr(progname, 47);
            sep = return_value___builtin_strchr_17;
            for( ; !(sep == ((char *)NULL)); sep = return_value___builtin_strchr_18)
            {
              tmp_post_19 = sep;
              sep = sep + 1l;
              *tmp_post_19 = (char)45;
              return_value___builtin_strchr_18=__builtin_strchr(sep, 47);
            }
            len=strlen(path);
            snprintf(path + (signed long int)len, path_len - len, "%capp.%s", 47, progname);
            free((void *)progname);
            file=fopen(path, "w");
            free((void *)path);
            if(file == ((struct _IO_FILE *)NULL))
            {
              if(!(g_link3.locker == ((struct Locker *)NULL)))
                g_link3.locker->unlock(g_link3.locker->lock);

              else
                0;
              return -1;
            }

            else
            {
              keys=map_keys(g_link3.prop->map);
              if(keys == ((struct List *)NULL))
              {
                if(!(g_link3.locker == ((struct Locker *)NULL)))
                  g_link3.locker->unlock(g_link3.locker->lock);

                else
                  0;
                return -1;
              }

              else
              {
                struct List *return_value_list_sort_20;
                return_value_list_sort_20=list_sort(keys, (signed int (*)(const void *, const void *))key_cmp);
                if(return_value_list_sort_20 == ((struct List *)NULL))
                {
                  list_release(keys);
                  if(!(g_link3.locker == ((struct Locker *)NULL)))
                    g_link3.locker->unlock(g_link3.locker->lock);

                  else
                    0;
                  return -1;
                }

                else
                {
                  k=lister_create(keys);
                  if(k == ((struct Lister *)NULL))
                  {
                    list_release(keys);
                    if(!(g_link3.locker == ((struct Locker *)NULL)))
                      g_link3.locker->unlock(g_link3.locker->lock);

                    else
                      0;
                    return -1;
                  }

                  else
                  {
                    do
                    {
                      return_value_lister_has_next_21=lister_has_next(k);
                      if(!(return_value_lister_has_next_21 == 1))
                        break;

                      const char *key;
                      void *return_value_lister_next_22;
                      return_value_lister_next_22=lister_next(k);
                      key = (const char *)return_value_lister_next_22;
                      const char *value;
                      void *return_value_map_get_23;
                      return_value_map_get_23=map_get(g_link3.prop->map, (const void *)key);
                      value = (const char *)return_value_map_get_23;
                      struct String *lhs;
                      struct String *rhs;
                      struct String *lhs2;
                      lhs=quote_equals(key);
                      if(lhs == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        if(!(g_link3.locker == ((struct Locker *)NULL)))
                          g_link3.locker->unlock(g_link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      char *return_value_cstr_24;
                      return_value_cstr_24=cstr(lhs);
                      lhs2=quote_special(return_value_cstr_24);
                      if(lhs2 == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        str_release(lhs);
                        if(!(g_link3.locker == ((struct Locker *)NULL)))
                          g_link3.locker->unlock(g_link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      str_release(lhs);
                      lhs = lhs2;
                      signed long int return_value_str_length_30;
                      return_value_str_length_30=str_length(lhs);
                      if(!(return_value_str_length_30 == 0l))
                      {
                        return_value___ctype_b_loc_27=__ctype_b_loc();
                        return_value_cstr_28=cstr(lhs);
                        return_value_str_length_29=str_length(lhs);
                        if(!((8192 & (signed int)(*return_value___ctype_b_loc_27)[(signed long int)(signed int)(unsigned char)return_value_cstr_28[return_value_str_length_29 + -1l]]) == 0))
                        {
                          signed long int return_value_str_length_25;
                          return_value_str_length_25=str_length(lhs);
                          struct String *return_value_str_insert_26;
                          return_value_str_insert_26=str_insert(lhs, return_value_str_length_25 - (signed long int)1, "\\");
                          if(return_value_str_insert_26 == ((struct String *)NULL))
                          {
                            fclose(file);
                            lister_release(k);
                            list_release(keys);
                            str_release(lhs);
                            if(!(g_link3.locker == ((struct Locker *)NULL)))
                              g_link3.locker->unlock(g_link3.locker->lock);

                            else
                              0;
                            return -1;
                          }

                        }

                      }

                      rhs=quote_special(value);
                      if(rhs == ((struct String *)NULL))
                      {
                        fclose(file);
                        lister_release(k);
                        list_release(keys);
                        str_release(lhs);
                        if(!(g_link3.locker == ((struct Locker *)NULL)))
                          g_link3.locker->unlock(g_link3.locker->lock);

                        else
                          0;
                        return -1;
                      }

                      const unsigned short int **return_value___ctype_b_loc_32;
                      return_value___ctype_b_loc_32=__ctype_b_loc();
                      char *return_value_cstr_33;
                      return_value_cstr_33=cstr(rhs);
                      if(!((8192 & (signed int)(*return_value___ctype_b_loc_32)[(signed long int)(signed int)(unsigned char)*return_value_cstr_33]) == 0))
                      {
                        struct String *return_value_str_insert_31;
                        return_value_str_insert_31=str_insert(rhs, (signed long int)0, "\\");
                        if(return_value_str_insert_31 == ((struct String *)NULL))
                        {
                          fclose(file);
                          lister_release(k);
                          list_release(keys);
                          str_release(lhs);
                          if(!(g_link3.locker == ((struct Locker *)NULL)))
                            g_link3.locker->unlock(g_link3.locker->lock);

                          else
                            0;
                          return -1;
                        }

                      }

                      char *return_value_cstr_34;
                      return_value_cstr_34=cstr(lhs);
                      char *return_value_cstr_35;
                      return_value_cstr_35=cstr(rhs);
                      fprintf(file, "%s=%s\n", return_value_cstr_34, return_value_cstr_35);
                      str_release(lhs);
                      str_release(rhs);
                    }
                    while((_Bool)1);
                    fclose(file);
                    lister_release(k);
                    list_release(keys);
                    g_link3.dirty = 0;
                    if(!(g_link3.locker == ((struct Locker *)NULL)))
                    {
                      return_value_2=g_link3.locker->unlock(g_link3.locker->lock);
                      tmp_if_expr_37 = return_value_2;
                    }

                    else
                      tmp_if_expr_37 = 0;
                    err = tmp_if_expr_37;
                    if(!(err == 0))
                    {
                      return_value_set_errno_36=set_errno(err);
                      return return_value_set_errno_36;
                    }

                    else
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// prop_set
// file libslack/prop.c line 597
const char * prop_set(const char *name, const char *value)
{
  char *val;
  signed int err;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(g_link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link3.locker->wrlock(g_link3.locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  void *return_value_set_errnull_1;
  signed int return_value_prop_init_3;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(!(err == 0))
  {
    return_value_set_errnull_1=set_errnull(err);
    return (const char *)return_value_set_errnull_1;
  }

  else
    if(g_link3.init == 0)
    {
      return_value_prop_init_3=prop_init();
      if(!(return_value_prop_init_3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g_link3.locker == ((struct Locker *)NULL)))
        g_link3.locker->unlock(g_link3.locker->lock);

      else
        0;
      return (const char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      val=mem_strdup(value);
      if(val == ((char *)NULL))
      {
        if(!(g_link3.locker == ((struct Locker *)NULL)))
          g_link3.locker->unlock(g_link3.locker->lock);

        else
          0;
        return (const char *)(void *)0;
      }

      else
      {
        signed int return_value_map_put_4;
        return_value_map_put_4=map_put(g_link3.prop->map, (const void *)name, (void *)val);
        if(return_value_map_put_4 == -1)
        {
          free((void *)val);
          if(!(g_link3.locker == ((struct Locker *)NULL)))
            g_link3.locker->unlock(g_link3.locker->lock);

          else
            0;
          return (const char *)(void *)0;
        }

        else
        {
          g_link3.dirty = 1;
          if(!(g_link3.locker == ((struct Locker *)NULL)))
          {
            return_value_1=g_link3.locker->unlock(g_link3.locker->lock);
            tmp_if_expr_6 = return_value_1;
          }

          else
            tmp_if_expr_6 = 0;
          err = tmp_if_expr_6;
          if(!(err == 0))
          {
            return_value_set_errnull_5=set_errnull(err);
            return (const char *)return_value_set_errnull_5;
          }

          else
            return val;
        }
      }
    }
}

// prop_set_bool
// file libslack/prop.c line 847
signed int prop_set_bool(const char *name, signed int value)
{
  signed int return_value_prop_set_int_1;
  return_value_prop_set_int_1=prop_set_int(name, value);
  return return_value_prop_set_int_1;
}

// prop_set_double
// file libslack/prop.c line 739
double prop_set_double(const char *name, double value)
{
  char buf[128l];
  snprintf(buf, (unsigned long int)128, "%g", value);
  const char *return_value_prop_set_1;
  return_value_prop_set_1=prop_set(name, buf);
  return return_value_prop_set_1 != ((const char *)NULL) ? value : (double)-1;
}

// prop_set_int
// file libslack/prop.c line 682
signed int prop_set_int(const char *name, signed int value)
{
  char buf[128l];
  snprintf(buf, (unsigned long int)128, "%d", value);
  const char *return_value_prop_set_1;
  return_value_prop_set_1=prop_set(name, buf);
  return return_value_prop_set_1 != ((const char *)NULL) ? value : 0;
}

// prop_unset
// file libslack/prop.c line 866
signed int prop_unset(const char *name)
{
  struct Prop *p;
  signed int err;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(g_link3.locker == ((struct Locker *)NULL)))
  {
    return_value=g_link3.locker->wrlock(g_link3.locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  signed int return_value_set_errno_1;
  signed int return_value_prop_init_3;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
    if(g_link3.init == 0)
    {
      return_value_prop_init_3=prop_init();
      if(!(return_value_prop_init_3 == -1))
        goto __CPROVER_DUMP_L6;

      if(!(g_link3.locker == ((struct Locker *)NULL)))
        g_link3.locker->unlock(g_link3.locker->lock);

      else
        0;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      p = g_link3.prop;
      for( ; !(p == ((struct Prop *)NULL)); p = p->defaults)
        map_remove(p->map, (const void *)name);
      g_link3.dirty = 1;
      if(!(g_link3.locker == ((struct Locker *)NULL)))
      {
        return_value_1=g_link3.locker->unlock(g_link3.locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return 0;
    }
}

// pty_change_window_size
// file libslack/pseudo.c line 716
signed int pty_change_window_size(signed int masterfd, signed int row, signed int col, signed int xpixel, signed int ypixel)
{
  struct winsize win;
  signed int *return_value___errno_location_1;
  if(!(col >= 0) || !(masterfd >= 0) || !(row >= 0) || !(xpixel >= 0) || !(ypixel >= 0))
  {
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  else
  {
    win.ws_row = (unsigned short int)row;
    win.ws_col = (unsigned short int)col;
    win.ws_xpixel = (unsigned short int)xpixel;
    win.ws_ypixel = (unsigned short int)ypixel;
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(masterfd, (unsigned long int)0x5414, &win);
    return return_value_ioctl_2;
  }
}

// pty_fork
// file libslack/pseudo.h line 54
signed int pty_fork(signed int *masterfd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize)
{
  signed int slavefd;
  signed int pid;
  signed int return_value_pty_open_1;
  return_value_pty_open_1=pty_open(masterfd, &slavefd, slavename, slavenamesize, slave_termios, slave_winsize);
  signed int return_value_dup2_3;
  signed int return_value_dup2_4;
  signed int return_value_dup2_5;
  if(return_value_pty_open_1 == -1)
    return -1;

  else
  {
    pid=fork();
    if(!(pid == -1))
    {
      if(pid == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      pty_release(slavename);
      close(slavefd);
      close(*masterfd);
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_pty_make_controlling_tty_2;
      return_value_pty_make_controlling_tty_2=pty_make_controlling_tty(&slavefd, slavename);
      if(return_value_pty_make_controlling_tty_2 == -1)
        _exit(1);

      if(!(slavefd == 0))
      {
        return_value_dup2_3=dup2(slavefd, 0);
        if(return_value_dup2_3 == -1)
          _exit(1);

      }

      if(!(slavefd == 1))
      {
        return_value_dup2_4=dup2(slavefd, 1);
        if(return_value_dup2_4 == -1)
          _exit(1);

      }

      if(!(slavefd == 2))
      {
        return_value_dup2_5=dup2(slavefd, 2);
        if(return_value_dup2_5 == -1)
          _exit(1);

      }

      if(!(slavefd == 0) && !(slavefd == 1) && !(slavefd == 2))
        close(slavefd);

      close(*masterfd);
      return 0;
    }
    close(slavefd);
    return pid;
  }
}

// pty_make_controlling_tty
// file libslack/pseudo.c line 637
signed int pty_make_controlling_tty(signed int *slavefd, const char *slavename)
{
  signed int fd;
  void (*old)(signed int);
  _Bool tmp_if_expr_2;
  if(slavefd == ((signed int *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = *slavefd < 0 ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location_1;
  if(slavename == ((const char *)NULL) || tmp_if_expr_2)
  {
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  else
  {
    fd=open("/dev/tty", 02 | 0400);
    if(fd >= 0)
    {
      ioctl(fd, (unsigned long int)0x5422, (void *)0);
      close(fd);
    }

    setsid();
    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(*slavefd, (unsigned long int)0x540E, (void *)0);
    if(return_value_ioctl_3 == -1)
      return -1;

    else
    {
      old=signal(1, (void (*)(signed int))1);
      vhangup();
      signal(1, old);
      fd=open(slavename, 02);
      if(fd >= 0)
      {
        close(*slavefd);
        *slavefd = fd;
      }

      fd=open("/dev/tty", 02);
      if(fd == -1)
        return -1;

      else
      {
        close(fd);
        return 0;
      }
    }
  }
}

// pty_open
// file libslack/pseudo.c line 217
signed int pty_open(signed int *masterfd, signed int *slavefd, char *slavename, unsigned long int slavenamesize, struct termios *slave_termios, struct winsize *slave_winsize)
{
  struct termios master_termios[1l];
  char buf[64l];
  char *name = buf;
  signed int err;
  signed int *return_value___errno_location_1;
  signed int return_value_tcsetattr_8;
  signed int return_value_ioctl_9;
  if(masterfd == ((signed int *)NULL) || slavefd == ((signed int *)NULL) || slavename == ((char *)NULL) || !(slavenamesize >= 64ul))
  {
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  else
  {
    signed int return_value_openpty_2;
    return_value_openpty_2=openpty(masterfd, slavefd, (char *)(void *)0, (struct termios *)(void *)0, (struct winsize *)(void *)0);
    if(return_value_openpty_2 == -1)
      return -1;

    else
    {
      err=ttyname_r(*slavefd, buf, (unsigned long int)64);
      if(!(err == 0))
      {
        close(*masterfd);
        close(*slavefd);
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = err;
        return -1;
      }

      unsigned long int return_value_strlcpy_5;
      return_value_strlcpy_5=strlcpy(slavename, name, slavenamesize);
      if(return_value_strlcpy_5 >= slavenamesize)
      {
        close(*masterfd);
        close(*slavefd);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 28;
        return -1;
      }

      signed int return_value_tcgetattr_7;
      return_value_tcgetattr_7=tcgetattr(*masterfd, master_termios);
      if(!(return_value_tcgetattr_7 == -1))
      {
        if(!((8u & master_termios[0l].c_lflag) == 0u))
        {
          master_termios[0l].c_lflag = master_termios[0l].c_lflag & (unsigned int)~0000010;
          signed int return_value_tcsetattr_6;
          return_value_tcsetattr_6=tcsetattr(*masterfd, 0, master_termios);
          if(return_value_tcsetattr_6 == -1)
          {
            close(*masterfd);
            close(*slavefd);
            return -1;
          }

        }

      }

      if(!(slave_termios == ((struct termios *)NULL)))
      {
        return_value_tcsetattr_8=tcsetattr(*slavefd, 0, slave_termios);
        if(!(return_value_tcsetattr_8 == -1))
          goto __CPROVER_DUMP_L7;

        close(*masterfd);
        close(*slavefd);
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(slave_winsize == ((struct winsize *)NULL)))
        {
          return_value_ioctl_9=ioctl(*slavefd, (unsigned long int)0x5414, slave_winsize);
          if(!(return_value_ioctl_9 == -1))
            goto __CPROVER_DUMP_L8;

          close(*masterfd);
          close(*slavefd);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          return 0;
        }
      }
    }
  }
}

// pty_release
// file libslack/pseudo.h line 50
signed int pty_release(const char *slavename)
{
  signed int *return_value___errno_location_1;
  if(slavename == ((const char *)NULL))
  {
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  else
  {
    signed int return_value_chown_2;
    return_value_chown_2=chown(slavename, (unsigned int)0, (unsigned int)0);
    if(return_value_chown_2 == -1)
      return -1;

    else
    {
      signed int return_value_chmod_3;
      return_value_chmod_3=chmod(slavename, (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3));
      if(return_value_chmod_3 == -1)
        return -1;

      else
        return 0;
    }
  }
}

// pty_set_owner
// file libslack/pseudo.c line 595
signed int pty_set_owner(const char *slavename, unsigned int uid)
{
  unsigned int mode = (unsigned int)(0400 | 0200 | 0200 >> 3);
  struct stat status[1l];
  signed int gid;
  signed int return_value_stat_1;
  return_value_stat_1=stat_link3(slavename, status);
  _Bool tmp_if_expr_5;
  signed int return_value_chown_4;
  signed int *return_value___errno_location_2;
  _Bool tmp_if_expr_3;
  signed int return_value_chmod_8;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_7;
  if(return_value_stat_1 == -1)
    return -1;

  else
  {
    gid=groupname2gid("tty");
    if(gid == -1)
    {
      gid=uid2gid(uid);
      mode = mode | (unsigned int)((0200 >> 3) >> 3);
    }

    if(!(status[0l].st_uid == uid))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = status[0l].st_gid != (unsigned int)gid ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      return_value_chown_4=chown(slavename, uid, (unsigned int)gid);
      if(!(return_value_chown_4 == -1))
        goto __CPROVER_DUMP_L7;

      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 30))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = status[0l].st_uid != uid ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
        goto __CPROVER_DUMP_L7;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      if(!((511u & status[0l].st_mode) == mode))
      {
        return_value_chmod_8=chmod(slavename, mode);
        if(!(return_value_chmod_8 == -1))
          goto __CPROVER_DUMP_L10;

        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 30))
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (status[0l].st_mode & (unsigned int)(0400 >> 3 | (0400 >> 3) >> 3)) != 0u ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_7)
          goto __CPROVER_DUMP_L10;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        return 0;
      }
    }
  }
}

// quote
// file libslack/str.c line 5126
struct String * quote(const char *str, const char *quotable, char quote_char)
{
  struct String *return_value_quote_with_locker_1;
  return_value_quote_with_locker_1=quote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_quote_with_locker_1;
}

// quote_equals
// file libslack/prop.c line 244
static struct String * quote_equals(const char *src)
{
  struct String *return_value_encode_1;
  return_value_encode_1=encode(src, eq, eq, (char)92, 0);
  return return_value_encode_1;
}

// quote_special
// file libslack/prop.c line 213
static struct String * quote_special(const char *src)
{
  struct String *return_value_encode_1;
  return_value_encode_1=encode(src, special_char, special_code, (char)92, 1);
  return return_value_encode_1;
}

// quote_with_locker
// file libslack/str.c line 5142
struct String * quote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull_1;
  unsigned long int tmp_post_2;
  if(quotable == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_create_with_locker(locker, "%s", str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
      {
        char *return_value___builtin_strchr_4;
        return_value___builtin_strchr_4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
        if(!(return_value___builtin_strchr_4 == ((char *)NULL)))
        {
          tmp_post_2 = i;
          i = i + 1ul;
          struct String *return_value_str_insert_3;
          return_value_str_insert_3=str_insert(ret, (signed long int)tmp_post_2, "%c", quote_char);
          if(return_value_str_insert_3 == ((struct String *)NULL))
          {
            str_release(ret);
            return (struct String *)(void *)0;
          }

        }

      }
      return ret;
    }
  }
}

// rcpt
// file libslack/net.c line 4112
static signed int rcpt(signed int smtp, const char *recipients)
{
  struct List *list;
  list=split(recipients, ", ");
  _Bool tmp_if_expr_2;
  signed long int return_value_list_length_1;
  if(list == ((struct List *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_list_length_1=list_length(list);
    tmp_if_expr_2 = return_value_list_length_1 <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_list_has_next_3;
  _Bool tmp_if_expr_7;
  signed long int return_value_net_expect_6;
  if(tmp_if_expr_2)
    return -1;

  else
  {
    do
    {
      return_value_list_has_next_3=list_has_next(list);
      if(!(return_value_list_has_next_3 == 1))
        break;

      char *recipient;
      void *return_value_list_next_4;
      return_value_list_next_4=list_next(list);
      recipient=cstr((struct String *)return_value_list_next_4);
      signed int rc;
      signed int code;
      signed long int return_value_net_send_5;
      return_value_net_send_5=net_send(smtp, (signed long int)10, "RCPT TO: <%s>\r\n", recipient);
      if(return_value_net_send_5 == -1l)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_net_expect_6=net_expect(smtp, (signed long int)10, "%d", &code);
        rc = (signed int)return_value_net_expect_6;
        tmp_if_expr_7 = rc == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        list_release(list);
        return -1;
      }

      if(!(code == 250) || !(rc == 1))
      {
        list_release(list);
        signed int return_value_set_errno_8;
        return_value_set_errno_8=set_errno(71);
        return return_value_set_errno_8;
      }

    }
    while((_Bool)1);
    list_release(list);
    return 0;
  }
}

// react
// file libslack/agent.c line 1942
static signed int react(signed int (*reaction)(struct Agent *, signed int, signed int, void *), struct Agent *agent, signed int fd, signed int revents, void *arg)
{
  signed int err;
  signed int ret;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(agent->locker == ((struct Locker *)NULL)))
  {
    return_value=agent->locker->unlock(agent->locker->lock);
    tmp_if_expr_2 = return_value;
  }

  else
    tmp_if_expr_2 = 0;
  err = tmp_if_expr_2;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_set_errno_3;
  if(!(err == 0))
  {
    return_value_set_errno_1=set_errno(err);
    return return_value_set_errno_1;
  }

  else
  {
    ret=reaction(agent, fd, revents, arg);
    if(!(agent->locker == ((struct Locker *)NULL)))
    {
      return_value_1=agent->locker->wrlock(agent->locker->lock);
      tmp_if_expr_4 = return_value_1;
    }

    else
      tmp_if_expr_4 = 0;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_3=set_errno(err);
      return return_value_set_errno_3;
    }

    else
      return ret;
  }
}

// read_timeout
// file libslack/fio.c line 201
signed int read_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous_10 readfds[1l];
  struct anonymous_10 exceptfds[1l];
  struct timeval read_timeout__1__timeout[1l];
  signed int return_value_set_errno_1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&readfds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    exceptfds[0l] = readfds[0l];
    read_timeout__1__timeout[0l].tv_sec = sec;
    read_timeout__1__timeout[0l].tv_usec = usec;
    signed int return_value_select_2;
    return_value_select_2=select(fd + 1, readfds, (struct anonymous_10 *)(void *)0, exceptfds, read_timeout__1__timeout);
    if(!(return_value_select_2 == -1))
    {
      if(return_value_select_2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno_3;
      return_value_set_errno_3=set_errno(110);
      return return_value_set_errno_3;
    }
    return 0;
  }
}

// reader
// file libslack/map.c line 2639
void * reader(void *arg)
{
  signed int i;
  signed int t = *((signed int *)arg);
  if(!(debug == 0))
    printf("r%d: loop\n", t);

  i = 0;
  signed long int return_value_list_length_3;
  signed long int return_value_list_length_4;
  for( ; !(i >= lim / 10); i = i + 1)
  {
    signed int key;
    signed int value;
    signed int r;
    struct List *keys;
    struct List *values;
    pthread_mutex_lock(rand_mutex);
    r=rand();
    pthread_mutex_unlock(rand_mutex);
    map_rdlock(mtmap);
    signed long int return_value_map_size_unlocked_1;
    return_value_map_size_unlocked_1=map_size_unlocked(mtmap);
    key = 1 + (signed int)(((double)(return_value_map_size_unlocked_1 - (signed long int)1) * (double)r) / ((double)2147483647 + 1.0));
    void *return_value_map_get_unlocked_2;
    return_value_map_get_unlocked_2=map_get_unlocked(mtmap, (void *)(signed long int)key);
    value = (signed int)(signed long int)return_value_map_get_unlocked_2;
    map_unlock(mtmap);
    keys=map_keys(mtmap);
    values=map_values(mtmap);
    if(!(debug == 0))
    {
      return_value_list_length_3=list_length(keys);
      return_value_list_length_4=list_length(values);
      printf("r%d: loop %d/%d key/val %d/%d, #keys %d, #values %d\n", t, i, lim / 10, key, value, (signed int)return_value_list_length_3, (signed int)return_value_list_length_4);
    }

    list_destroy(&keys);
    list_destroy(&values);
  }
  write(barrier[(signed long int)1], (const void *)"", (unsigned long int)1);
  return (void *)0;
}

// recvfd
// file libslack/net.h line 142
signed long int recvfd(signed int sockfd, void *buf, unsigned long int nbytes, signed int flags, signed int *fd)
{
  struct msghdr mesg[1l];
  struct iovec iov[1l];
  signed long int rc;
  /* tag-#anon#lUN[lSYM#tag-cmsghdr#'align'||lARR24{S8}_S8_'control'|] */
union anonymous_3
{
  // align
  struct cmsghdr align;
  // control
  char control[24l];
};

/* */
  ;
  union anonymous_3 control;
  struct cmsghdr *cmsg;
  mesg[0l].msg_control = (void *)control.control;
  mesg[0l].msg_controllen = sizeof(char [24l]) /*24ul*/ ;
  signed int return_value_set_errno_1;
  struct cmsghdr *tmp_if_expr_2;
  if(fd == ((signed int *)NULL) || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    mesg[0l].msg_name = (void *)0;
    mesg[0l].msg_namelen = (unsigned int)0;
    mesg[0l].msg_iov = iov;
    mesg[0l].msg_iovlen = (unsigned long int)1;
    iov[0l].iov_base = buf;
    iov[0l].iov_len = nbytes;
    rc=recvmsg(sockfd, mesg, flags);
    if(!(rc >= 1l))
      return (signed long int)-1;

    else
    {
      *fd = -1;
      if(mesg[0l].msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
        tmp_if_expr_2 = (struct cmsghdr *)mesg[0l].msg_control;

      else
        tmp_if_expr_2 = (struct cmsghdr *)0;
      cmsg = tmp_if_expr_2;
      if(!(cmsg == ((struct cmsghdr *)NULL)))
      {
        if(cmsg->cmsg_len == sizeof(signed int) * 5 /*20ul*/ )
        {
          if(cmsg->cmsg_level == 1)
          {
            if(cmsg->cmsg_type == 1)
              *fd = *((signed int *)cmsg->__cmsg_data);

          }

        }

      }

      return rc;
    }
  }
}

// regexpr
// file libslack/str.c line 3117
struct List * regexpr(const char *pattern, const char *text, signed int cflags, signed int eflags)
{
  struct List *return_value_regexpr_with_locker_1;
  return_value_regexpr_with_locker_1=regexpr_with_locker((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_regexpr_with_locker_1;
}

// regexpr_compile
// file libslack/str.c line 3166
signed int regexpr_compile(struct re_pattern_buffer *compiled, const char *pattern, signed int cflags)
{
  if(pattern == ((const char *)NULL) || compiled == ((struct re_pattern_buffer *)NULL))
    return 2;

  else
  {
    signed int return_value_regcomp_1;
    return_value_regcomp_1=regcomp(compiled, pattern, cflags | 1);
    return return_value_regcomp_1;
  }
}

// regexpr_compiled
// file libslack/str.c line 3291
struct List * regexpr_compiled(const struct re_pattern_buffer *compiled, const char *text, signed int eflags)
{
  struct List *return_value_regexpr_compiled_with_locker_1;
  return_value_regexpr_compiled_with_locker_1=regexpr_compiled_with_locker((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_regexpr_compiled_with_locker_1;
}

// regexpr_compiled_with_locker
// file libslack/str.c line 3307
struct List * regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const char *text, signed int eflags)
{
  struct anonymous_7 match[33l];
  struct List *ret;
  signed int i;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  _Bool tmp_if_expr_3;
  if(text == ((const char *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    err=regexec(compiled, text, (unsigned long int)33, match, eflags);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_create_with_locker(locker, (void (*)(void *))str_release);
      if(ret == ((struct List *)NULL))
        return (struct List *)(void *)0;

      else
      {
        i = 0;
        do
        {
          if(!(i >= 33))
            tmp_if_expr_3 = match[(signed long int)i].rm_so != -1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          struct String *m;
          m=substr(text, (signed long int)match[(signed long int)i].rm_so, (signed long int)(match[(signed long int)i].rm_eo - match[(signed long int)i].rm_so));
          if(m == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append_4;
          return_value_list_append_4=list_append(ret, (void *)m);
          if(return_value_list_append_4 == ((struct List *)NULL))
          {
            str_release(m);
            list_release(ret);
            return (struct List *)(void *)0;
          }

          i = i + 1;
        }
        while((_Bool)1);
        return ret;
      }
    }
  }
}

// regexpr_release
// file libslack/str.c line 3184
void regexpr_release(struct re_pattern_buffer *compiled)
{
  if(!(compiled == ((struct re_pattern_buffer *)NULL)))
    regfree(compiled);

}

// regexpr_split
// file libslack/str.c line 4236
struct List * regexpr_split(const char *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_regexpr_split_with_locker_1;
  return_value_regexpr_split_with_locker_1=regexpr_split_with_locker((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_regexpr_split_with_locker_1;
}

// regexpr_split_with_locker
// file libslack/str.c line 4252
struct List * regexpr_split_with_locker(struct Locker *locker, const char *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *ret;
  struct String *token;
  struct re_pattern_buffer compiled[1l];
  struct anonymous_7 match[1l];
  signed int start;
  signed int matches;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    err=regexpr_compile(compiled, delim, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=list_create_with_locker(locker, (void (*)(void *))str_release);
      if(ret == ((struct List *)NULL))
        return (struct List *)(void *)0;

      else
      {
        start = 0;
        matches = 0;
        for( ; !(str[(signed long int)start] == 0); matches = matches + 1)
        {
          signed int return_value_regexec_3;
          return_value_regexec_3=regexec(compiled, str + (signed long int)start, (unsigned long int)1, match, eflags);
          if(!(return_value_regexec_3 == 0))
            break;

          if(match[0l].rm_so == 0)
          {
            if(match[0l].rm_eo == 0)
            {
              match[(signed long int)0].rm_so = match[(signed long int)0].rm_so + 1;
              match[(signed long int)0].rm_eo = match[(signed long int)0].rm_eo + 1;
            }

          }

          if(!(match[0l].rm_so == 0))
          {
            token=substr(str, (signed long int)start, (signed long int)match[(signed long int)0].rm_so);
            if(token == ((struct String *)NULL))
            {
              list_release(ret);
              return (struct List *)(void *)0;
            }

            struct List *return_value_list_append_4;
            return_value_list_append_4=list_append(ret, (void *)token);
            if(return_value_list_append_4 == ((struct List *)NULL))
            {
              str_release(token);
              list_release(ret);
              return (struct List *)(void *)0;
            }

          }

          start = start + match[(signed long int)0].rm_eo;
        }
        if(!(str[(signed long int)start] == 0))
        {
          token=str_create("%s", str + (signed long int)start);
          if(token == ((struct String *)NULL))
          {
            list_release(ret);
            return (struct List *)(void *)0;
          }

          struct List *return_value_list_append_5;
          return_value_list_append_5=list_append(ret, (void *)token);
          if(return_value_list_append_5 == ((struct List *)NULL))
          {
            str_release(token);
            list_release(ret);
            return (struct List *)(void *)0;
          }

        }

        return ret;
      }
    }
  }
}

// regexpr_with_locker
// file libslack/str.c line 3133
struct List * regexpr_with_locker(struct Locker *locker, const char *pattern, const char *text, signed int cflags, signed int eflags)
{
  struct re_pattern_buffer compiled[1l];
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(pattern == ((const char *)NULL) || text == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=regexpr_compiled_with_locker(locker, compiled, text, eflags);
      regfree(compiled);
      return ret;
    }
  }
}

// release_action
// file libslack/agent.c line 273
static struct action_t * release_action(struct action_t *action)
{
  struct action_t *next;
  void *return_value_dlink_next_1;
  return_value_dlink_next_1=dlink_next((void *)action);
  next = (struct action_t *)return_value_dlink_next_1;
  free((void *)action);
  return next;
}

// release_actions
// file libslack/agent.c line 282
static void release_actions(struct action_t *action)
{
  while(!(action == ((struct action_t *)NULL)))
    action=release_action(action);
}

// rudp_create
// file libslack/net.c line 2363
struct rudp_t * rudp_create(void)
{
  struct rudp_t *rudp;
  struct timeval now[1l];
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(now, (struct timezone *)(void *)0);
  if(return_value_gettimeofday_1 == -1)
    return (struct rudp_t *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct rudp_t) /*48ul*/ );
    rudp = (struct rudp_t *)return_value_malloc_2;
    if(rudp == ((struct rudp_t *)NULL))
      return (struct rudp_t *)(void *)0;

    else
    {
      rudp->base = (unsigned int)now[0l].tv_sec;
      rudp_init(rudp);
      return rudp;
    }
  }
}

// rudp_destroy
// file libslack/net.c line 2406
void * rudp_destroy(struct rudp_t **rudp)
{
  if(!(rudp == ((struct rudp_t **)NULL)))
  {
    if(!(*rudp == ((struct rudp_t *)NULL)))
    {
      rudp_release(*rudp);
      *rudp = (struct rudp_t *)(void *)0;
    }

  }

  return (void *)0;
}

// rudp_init
// file libslack/net.c line 2342
static signed int rudp_init(struct rudp_t *rudp)
{
  signed int return_value_set_errno_1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    rudp->rtt = 0.0;
    rudp->srtt = 0.0;
    rudp->rttvar = 0.75;
    rudp->rto=rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
    rudp->sequence = (unsigned int)0;
    return 0;
  }
}

// rudp_minmax
// file libslack/net.c line 2331
static double rudp_minmax(double rto)
{
  if(rto < 2.000000)
    return (double)2;

  else
    if(rto > 60.000000)
      return (double)60;

    else
      return rto;
}

// rudp_newpack
// file libslack/net.c line 2453
static unsigned int rudp_newpack(struct rudp_t *rudp)
{
  signed int return_value_set_errno_1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (unsigned int)return_value_set_errno_1;
  }

  else
  {
    rudp->nrexmt = 0;
    rudp->sequence = rudp->sequence + 1u;
    return rudp->sequence;
  }
}

// rudp_release
// file libslack/net.c line 2390
void rudp_release(struct rudp_t *rudp)
{
  free((void *)rudp);
}

// rudp_start
// file libslack/net.c line 2473
static double rudp_start(struct rudp_t *rudp)
{
  signed int return_value_set_errno_1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (double)return_value_set_errno_1;
  }

  else
    return rudp->rto;
}

// rudp_stop
// file libslack/net.c line 2492
static signed int rudp_stop(struct rudp_t *rudp, unsigned int rtt)
{
  double delta;
  signed int return_value_set_errno_1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    rudp->rtt = (double)rtt / 1000.0;
    delta = rudp->rtt - rudp->srtt;
    rudp->srtt = rudp->srtt + delta / (double)8;
    double return_value_fabs_2;
    return_value_fabs_2=fabs(delta);
    rudp->rttvar = rudp->rttvar + (return_value_fabs_2 - rudp->rttvar) / (double)4;
    rudp->rto=rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
    return 0;
  }
}

// rudp_timeout
// file libslack/net.c line 2520
static signed int rudp_timeout(struct rudp_t *rudp)
{
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    rudp->rto = rudp->rto * (double)2;
    rudp->nrexmt = rudp->nrexmt + 1;
    if(rudp->nrexmt >= 4)
    {
      return_value_set_errno_2=set_errno(110);
      return return_value_set_errno_2;
    }

    else
      return 0;
  }
}

// rudp_timestamp
// file libslack/net.c line 2428
static unsigned int rudp_timestamp(struct rudp_t *rudp)
{
  struct timeval now[1l];
  signed int return_value_set_errno_1;
  if(rudp == ((struct rudp_t *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (unsigned int)return_value_set_errno_1;
  }

  else
  {
    signed int return_value_gettimeofday_2;
    return_value_gettimeofday_2=gettimeofday(now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday_2 == -1)
      return (unsigned int)-1;

    else
      return (unsigned int)((signed long int)(unsigned int)((now[0l].tv_sec - (signed long int)rudp->base) * (signed long int)1000) + now[0l].tv_usec / (signed long int)1000);
  }
}

// rw_timeout
// file libslack/fio.c line 297
signed int rw_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous_10 readfds[1l];
  struct anonymous_10 writefds[1l];
  struct anonymous_10 exceptfds[1l];
  struct timeval rw_timeout__1__timeout[1l];
  signed int rc = 0;
  signed int return_value_set_errno_1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&readfds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = readfds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    writefds[0l] = readfds[0l];
    exceptfds[0l] = readfds[0l];
    rw_timeout__1__timeout[0l].tv_sec = sec;
    rw_timeout__1__timeout[0l].tv_usec = usec;
    signed int return_value_select_2;
    return_value_select_2=select(fd + 1, readfds, writefds, exceptfds, rw_timeout__1__timeout);
    if(!(return_value_select_2 == -1))
    {
      if(return_value_select_2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno_3;
      return_value_set_errno_3=set_errno(110);
      return return_value_set_errno_3;
    }
    if(!((readfds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 4;

    if(!((writefds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 2;

    if(!((exceptfds[0l].fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      rc = rc | 1;

    return rc;
  }
}

// sendfd
// file libslack/net.h line 141
signed long int sendfd(signed int sockfd, const void *buf, unsigned long int nbytes, signed int flags, signed int fd)
{
  struct msghdr mesg[1l];
  struct iovec iov[1l];
  /* tag-#anon#lUN[lSYM#tag-cmsghdr#'align'||lARR24{S8}_S8_'control'|] */
union anonymous_3
{
  // align
  struct cmsghdr align;
  // control
  char control[24l];
};

/* */
  ;
  union anonymous_3 control;
  struct cmsghdr *cmsg;
  signed int return_value_set_errno_1;
  struct cmsghdr *tmp_if_expr_2;
  if(!(fd >= 0) || !(sockfd >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    mesg[0l].msg_control = (void *)control.control;
    mesg[0l].msg_controllen = sizeof(char [24l]) /*24ul*/ ;
    if(mesg[0l].msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
      tmp_if_expr_2 = (struct cmsghdr *)mesg[0l].msg_control;

    else
      tmp_if_expr_2 = (struct cmsghdr *)0;
    cmsg = tmp_if_expr_2;
    cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(signed int) /*4ul*/ ;
    cmsg->cmsg_level = 1;
    cmsg->cmsg_type = 1;
    *((signed int *)cmsg->__cmsg_data) = fd;
    mesg[0l].msg_name = (void *)0;
    mesg[0l].msg_namelen = (unsigned int)0;
    mesg[0l].msg_iov = iov;
    mesg[0l].msg_iovlen = (unsigned long int)1;
    iov[0l].iov_base = (void *)buf;
    iov[0l].iov_len = nbytes;
    signed long int return_value_sendmsg_3;
    return_value_sendmsg_3=sendmsg(sockfd, mesg, flags);
    return return_value_sendmsg_3;
  }
}

// service_number
// file libslack/net.c line 525
static signed int service_number(const char *service)
{
  char *endptr = (char *)(void *)0;
  unsigned long int val;
  val=strtoul(service, &endptr, 10);
  val=strtoul(service, &endptr, 10);
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_3;
  signed int return_value_set_errno_2;
  if(val >= 65536ul)
  {
    return_value_set_errno_1=set_errno(34);
    return return_value_set_errno_1;
  }

  else
  {
    if(endptr == service)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*endptr != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_set_errno_2=set_errno(33);
      return return_value_set_errno_2;
    }

    else
      return (signed int)val;
  }
}

// service_port
// file libslack/net.c line 539
static unsigned short int service_port(const char *service, signed int type, signed int port)
{
  unsigned short int tmp_statement_expression_1;
  if(!(service == ((const char *)NULL)))
  {
    signed int ret;
    ret=service_number(service);
    if(!(ret == -1))
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)ret;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_1 = __v;
      return tmp_statement_expression_1;
    }

    unsigned short int return_value_getservportbynameandtype_2;
    return_value_getservportbynameandtype_2=getservportbynameandtype(service, type);
    ret = (signed int)return_value_getservportbynameandtype_2;
    if(!(ret == 0))
      return (unsigned short int)ret;

  }

  unsigned short int tmp_statement_expression_3;
  unsigned short int service_port__1__2____v;
  unsigned short int service_port__1__2____x = (unsigned short int)port;
  asm("rorw _8, %w0" : "=r"(service_port__1__2____v) : "0"(service_port__1__2____x) : "cc");
  tmp_statement_expression_3 = service_port__1__2____v;
  return tmp_statement_expression_3;
}

// set_errno
// file libslack/err.h line 83
signed int set_errno(signed int errnum)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = errnum;
  return -1;
}

// set_errnull
// file libslack/err.h line 84
void * set_errnull(signed int errnum)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = errnum;
  return (void *)0;
}

// set_errnullf
// file libslack/err.c line 748
void (*set_errnullf(signed int errnum))()
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = errnum;
  return (void (*)())(void *)0;
}

// shrink
// file libslack/list.c line 247
static signed int shrink(struct List *list, unsigned long int items)
{
  signed int shrunk = 0;
  for( ; !(list->length + -items >= list->size >> 1); shrunk = 1)
  {
    if(list->size == MIN_LIST_SIZE)
      break;

    list->size = list->size >> 1;
  }
  void *return_value_mem_resize_fn_1;
  if(!(shrunk == 0))
  {
    return_value_mem_resize_fn_1=mem_resize_fn((void **)&list->list, list->size * sizeof(void *) /*8ul*/ );
    return return_value_mem_resize_fn_1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// shrink_link1
// file libslack/str.c line 426
static signed int shrink_link1(struct String *str, unsigned long int bytes)
{
  signed int shrunk_link1 = 0;
  for( ; !(str->length + -bytes >= str->size >> 1); shrunk_link1 = 1)
  {
    if(MIN_EMPTY_STRING_SIZE >= str->size)
      break;

    str->size = str->size >> 1;
  }
  void *return_value_mem_resize_fn_1_link1;
  if(!(shrunk_link1 == 0))
  {
    return_value_mem_resize_fn_1_link1=mem_resize_fn((void **)&str->str, str->size * sizeof(char) /*1ul*/ );
    return return_value_mem_resize_fn_1_link1 != NULL ? 0 : -1;
  }

  else
    return 0;
}

// signal_addset
// file libslack/sig.c line 201
signed int signal_addset(signed int signo_handled, signed int signo_blocked)
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo_handled];
  signed int return_value_sigaddset_1;
  return_value_sigaddset_1=sigaddset(&h->action[0l].sa_mask, signo_blocked);
  return return_value_sigaddset_1;
}

// signal_catcher
// file libslack/sig.c line 120
static void signal_catcher(signed int signo)
{
  g_received[(signed long int)signo] = g_received[(signed long int)signo] + 1;
}

// signal_handle
// file libslack/sig.c line 264
signed int signal_handle(signed int signo)
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo];
  struct anonymous_6 origmask[1l];
  signed int return_value_sigprocmask_1;
  return_value_sigprocmask_1=sigprocmask(0, &h->action[0l].sa_mask, origmask);
  if(return_value_sigprocmask_1 == -1)
    return -1;

  else
  {
    g_handler[(signed long int)signo].handler(signo);
    g_received[(signed long int)signo] = 0;
    signed int return_value_sigprocmask_2;
    return_value_sigprocmask_2=sigprocmask(2, origmask, (struct anonymous_6 *)(void *)0);
    return return_value_sigprocmask_2;
  }
}

// signal_handle_all
// file libslack/sig.c line 292
void signal_handle_all(void)
{
  signed int signo = 0;
  signed int return_value_signal_received_1;
  for( ; !(signo >= 65); signo = signo + 1)
  {
    return_value_signal_received_1=signal_received(signo);
    if(!(return_value_signal_received_1 == 0))
      signal_handle(signo);

  }
}

// signal_raise
// file libslack/sig.c line 242
signed int signal_raise(signed int signo)
{
  signed int return_value_set_errno_1;
  if(signo >= 65 || !(signo >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    g_received[(signed long int)signo] = g_received[(signed long int)signo] + 1;
    return g_received[(signed long int)signo];
  }
}

// signal_received
// file libslack/sig.c line 221
signed int signal_received(signed int signo)
{
  signed int return_value_set_errno_1;
  if(signo >= 65 || !(signo >= 0))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return g_received[(signed long int)signo];
}

// signal_set_handler
// file libslack/sig.c line 149
signed int signal_set_handler(signed int signo, signed int flags, void (*handler)(signed int))
{
  struct real_signal_handler_t *h = &g_handler[(signed long int)signo];
  sigemptyset(&h->action[0l].sa_mask);
  sigaddset(&h->action[0l].sa_mask, signo);
  h->action[0l].sa_flags = flags;
  if(handler == ((void (*)(signed int))NULL) || handler == (void (*)(signed int))1)
    h->action[0l].__sigaction_handler.sa_handler = handler;

  else
  {
    if(signo == 4 || signo == 6 || signo == 7 || signo == 8 || signo == 11 || signo == 31)
    {
      h->action[0l].__sigaction_handler.sa_handler = handler;
      goto __CPROVER_DUMP_L4;
    }

    h->action[0l].__sigaction_handler.sa_handler = signal_catcher;
  }

__CPROVER_DUMP_L4:
  ;
  h->handler = handler;
  g_received[(signed long int)signo] = 0;
  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(signo, h->action, (struct sigaction *)(void *)0);
  return return_value_sigaction_1;
}

// slink_alloc
// file libslack/link.c line 460
void * slink_alloc(void **freelist)
{
  void *alloc;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(freelist == ((void **)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    if(*freelist == NULL)
    {
      return_value_set_errnull_2=set_errnull(28);
      return return_value_set_errnull_2;
    }

    else
    {
      alloc = *freelist;
      *freelist=slink_remove(*freelist);
      return alloc;
    }
}

// slink_free
// file libslack/link.c line 518
void * slink_free(void **freelist, void *item)
{
  void *return_value_set_errnull_1;
  if(item == NULL || freelist == ((void **)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    *freelist=slink_insert(*freelist, item);
    return *freelist;
  }
}

// slink_freelist_attach
// file libslack/link.c line 396
void * slink_freelist_attach(void *freelist1, void *freelist2)
{
  char *freelist;
  void *return_value_set_errnull_1;
  signed int return_value_slink_has_next_2;
  void *return_value_slink_next_3;
  if(freelist2 == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    freelist = (char *)freelist1;
    if(freelist == ((char *)NULL))
      return freelist2;

    else
    {
      do
      {
        return_value_slink_has_next_2=slink_has_next((void *)freelist);
        if(!(return_value_slink_has_next_2 == 1))
          break;

        return_value_slink_next_3=slink_next((void *)freelist);
        freelist = (char *)return_value_slink_next_3;
      }
      while((_Bool)1);
      ((struct slink_t *)freelist)->next = freelist2;
      return freelist1;
    }
  }
}

// slink_freelist_init
// file libslack/link.c line 334
void * slink_freelist_init(void *freelist, unsigned long int nelem, unsigned long int size)
{
  char *link;
  void *return_value_set_errnull_1;
  if(freelist == NULL || nelem == 0ul || size == 0ul)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    link = (char *)freelist;
    do
    {
      nelem = nelem - 1ul;
      if(nelem == 0ul)
        break;

      ((struct slink_t *)link)->next = (void *)(link + (signed long int)size);
      link = link + (signed long int)size;
    }
    while((_Bool)1);
    ((struct slink_t *)link)->next = (void *)0;
    return freelist;
  }
}

// slink_has_next
// file libslack/link.c line 105
signed int slink_has_next(void *link)
{
  signed int return_value_set_errno_1;
  if(link == NULL)
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)(((struct slink_t *)link)->next != (void *)0);
}

// slink_insert
// file libslack/link.c line 220
void * slink_insert(void *link, void *item)
{
  struct slink_t *insert;
  void *return_value_set_errnull_1;
  if(item == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    insert = (struct slink_t *)item;
    insert->next = link;
    return (void *)insert;
  }
}

// slink_next
// file libslack/link.c line 124
void * slink_next(void *link)
{
  void *return_value_set_errnull_1;
  if(link == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
    return ((struct slink_t *)link)->next;
}

// slink_remove
// file libslack/link.c line 280
void * slink_remove(void *link)
{
  struct slink_t *remove;
  void *return_value_set_errnull_1;
  if(link == NULL)
  {
    return_value_set_errnull_1=set_errnull(22);
    return return_value_set_errnull_1;
  }

  else
  {
    remove = (struct slink_t *)link;
    return remove->next;
  }
}

// sort_cmp
// file libslack/map.c line 2409
static signed int sort_cmp(const char **a, const char **b)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(*a, *b);
  return return_value_strcmp_1;
}

// soundex
// file libslack/str.c line 4592
signed int soundex(const char *str)
{
  const char * const soundex_table = "S\n\0-\001\002\002";
  /* tag-#anon#lUN[lARR4{S8}_S8_'c'||S32'i'|] */
union anonymous_8
{
  // c
  char c[4l];
  // i
  signed int i;
};

/* */
  ;
  union anonymous_8 soundex__1__soundex;
  signed int last;
  signed int small;
  signed int return_value_set_errno_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_9;
  if(str == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    soundex__1__soundex.i = 0;
    last = -1;
    small = 0;
    for( ; !(*str == 0) && !(small >= 4); str = str + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_8;
      return_value___ctype_b_loc_8=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*str]) == 0))
      {
        signed int code;
        signed int __res;
        __res=toupper((signed int)(unsigned char)*str);
        tmp_statement_expression_2 = __res;
        code = tmp_statement_expression_2;
        if(small == 0)
        {
          tmp_post_6 = small;
          small = small + 1;
          soundex__1__soundex.c[(signed long int)tmp_post_6] = (char)code;
          last = (signed int)soundex_table[(signed long int)(code - 65)];
        }

        else
        {
          code = (signed int)soundex_table[(signed long int)(code - 65)];
          if(!(code == last))
          {
            if(!(code == 0))
            {
              tmp_post_7 = small;
              small = small + 1;
              soundex__1__soundex.c[(signed long int)tmp_post_7] = (char)code;
            }

            last = code;
          }

        }
      }

    }
    for( ; !(small >= 4); soundex__1__soundex.c[(signed long int)tmp_post_9] = (char)48)
    {
      tmp_post_9 = small;
      small = small + 1;
    }
    unsigned int return_value___bswap_32_10;
    return_value___bswap_32_10=__bswap_32_link1((unsigned int)soundex__1__soundex.i);
    return (signed int)return_value___bswap_32_10;
  }
}

// split
// file libslack/str.h line 175
struct List * split(const char *str, const char *delim)
{
  struct List *return_value_split_with_locker_1;
  return_value_split_with_locker_1=split_with_locker((struct Locker *)(void *)0, str, delim);
  return return_value_split_with_locker_1;
}

// split_with_locker
// file libslack/str.c line 4128
struct List * split_with_locker(struct Locker *locker, const char *str, const char *delim)
{
  void *return_value_set_errnull_1;
  if(delim == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_do_split_with_locker_2;
    return_value_do_split_with_locker_2=do_split_with_locker(locker, str, (signed long int)-1, delim);
    return return_value_do_split_with_locker_2;
  }
}

// squeeze
// file libslack/str.c line 4982
char * squeeze(char *str)
{
  char *s;
  char *r;
  signed int started = 0;
  signed int was_space = 0;
  void *return_value_set_errnull_1;
  char *tmp_post_2;
  char *tmp_post_3;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    s = str;
    r = s;
    for( ; !(*s == 0); s = s + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*s]) == 0)
      {
        if(!(started == 0) && !(was_space == 0))
        {
          tmp_post_2 = r;
          r = r + 1l;
          *tmp_post_2 = (char)32;
        }

        tmp_post_3 = r;
        r = r + 1l;
        *tmp_post_3 = *s;
        started = 1;
      }

      const unsigned short int **return_value___ctype_b_loc_5;
      return_value___ctype_b_loc_5=__ctype_b_loc();
      was_space = (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192;
    }
    *r = (char)0;
    return str;
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// stat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link1(const char *__path_link1, struct stat *__statbuf_link1)
{
  signed int return_value___xstat_1_link1;
  return_value___xstat_1_link1=__xstat(1, __path_link1, __statbuf_link1);
  return return_value___xstat_1_link1;
}

// stat_link2
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link2(const char *__path_link2, struct stat *__statbuf_link2)
{
  signed int return_value___xstat_1_link2;
  return_value___xstat_1_link2=__xstat(1, __path_link2, __statbuf_link2);
  return return_value___xstat_1_link2;
}

// stat_link3
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat_link3(const char *__path_link3, struct stat *__statbuf_link3)
{
  signed int return_value___xstat_1_link3;
  return_value___xstat_1_link3=__xstat(1, __path_link3, __statbuf_link3);
  return return_value___xstat_1_link3;
}

// str_append
// file libslack/str.c line 1538
struct String * str_append(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, (signed long int)-1, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_append_str
// file libslack/str.c line 1610
struct String * str_append_str(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_1;
  return_value_str_insert_str_1=str_insert_str(str, (signed long int)-1, src);
  return return_value_str_insert_str_1;
}

// str_append_str_unlocked
// file libslack/str.c line 1628
struct String * str_append_str_unlocked(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_unlocked_1;
  return_value_str_insert_str_unlocked_1=str_insert_str_unlocked(str, (signed long int)-1, src);
  return return_value_str_insert_str_unlocked_1;
}

// str_append_unlocked
// file libslack/str.c line 1558
struct String * str_append_unlocked(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, (signed long int)-1, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_bin
// file libslack/str.c line 6235
signed int str_bin(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_bin_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_bin_unlocked
// file libslack/str.c line 6264
signed int str_bin_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_bin_2;
    return_value_bin_2=bin(str->str);
    return return_value_bin_2;
  }
}

// str_chomp
// file libslack/str.c line 6141
signed int str_chomp(struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_chomp_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_chomp_unlocked
// file libslack/str.c line 6170
signed int str_chomp_unlocked(struct String *str)
{
  char *s;
  unsigned long int length;
  signed int return_value_set_errno_1;
  _Bool tmp_if_expr_2;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if(str->length == 1ul)
      return 0;

    else
    {
      length = str->length;
      s = (str->str + (signed long int)str->length) - (signed long int)2;
      do
      {
        if((signed int)*s == 10)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*s == 13 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        signed int return_value_contract_3;
        return_value_contract_3=contract_link1(str, (signed long int)(str->length - (unsigned long int)2), (unsigned long int)1);
        if(return_value_contract_3 == -1)
          return -1;

        s = s - 1l;
      }
      while((_Bool)1);
      return (signed int)(length - str->length);
    }
}

// str_chop
// file libslack/str.c line 6055
signed int str_chop(struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_chop_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_chop_unlocked
// file libslack/str.c line 6084
signed int str_chop_unlocked(struct String *str)
{
  signed int ret;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    if(str->length == 1ul)
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      ret = (signed int)str->str[(signed long int)(str->length - (unsigned long int)2)];
      signed int return_value_contract_3;
      return_value_contract_3=contract_link1(str, (signed long int)(str->length - (unsigned long int)2), (unsigned long int)1);
      if(return_value_contract_3 == -1)
        return -1;

      else
        return ret;
    }
}

// str_clear
// file libslack/str.c line 1212
struct String * str_clear(struct String *str)
{
  struct String *return_value_str_remove_range_1;
  return_value_str_remove_range_1=str_remove_range(str, (signed long int)0, (signed long int)-1);
  return return_value_str_remove_range_1;
}

// str_clear_unlocked
// file libslack/str.c line 1227
struct String * str_clear_unlocked(struct String *str)
{
  struct String *return_value_str_remove_range_unlocked_1;
  return_value_str_remove_range_unlocked_1=str_remove_range_unlocked(str, (signed long int)0, (signed long int)-1);
  return return_value_str_remove_range_unlocked_1;
}

// str_copy
// file libslack/str.c line 740
struct String * str_copy(const struct String *str)
{
  struct String *return_value_str_copy_with_locker_1;
  return_value_str_copy_with_locker_1=str_copy_with_locker((struct Locker *)(void *)0, str);
  return return_value_str_copy_with_locker_1;
}

// str_copy_unlocked
// file libslack/str.c line 755
struct String * str_copy_unlocked(const struct String *str)
{
  struct String *return_value_str_copy_with_locker_unlocked_1;
  return_value_str_copy_with_locker_unlocked_1=str_copy_with_locker_unlocked((struct Locker *)(void *)0, str);
  return return_value_str_copy_with_locker_unlocked_1;
}

// str_copy_with_locker
// file libslack/str.c line 771
struct String * str_copy_with_locker(struct Locker *locker, const struct String *str)
{
  struct String *return_value_str_substr_with_locker_1;
  return_value_str_substr_with_locker_1=str_substr_with_locker(locker, str, (signed long int)0, (signed long int)-1);
  return return_value_str_substr_with_locker_1;
}

// str_copy_with_locker_unlocked
// file libslack/str.c line 787
struct String * str_copy_with_locker_unlocked(struct Locker *locker, const struct String *str)
{
  struct String *return_value_str_substr_with_locker_unlocked_1;
  return_value_str_substr_with_locker_unlocked_1=str_substr_with_locker_unlocked(locker, str, (signed long int)0, (signed long int)-1);
  return return_value_str_substr_with_locker_unlocked_1;
}

// str_create
// file libslack/str.c line 531
struct String * str_create(const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized((struct Locker *)(void *)0, MIN_STRING_SIZE, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_sized
// file libslack/str.c line 609
struct String * str_create_sized(unsigned long int size, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized((struct Locker *)(void *)0, size, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_with_locker
// file libslack/str.c line 552
struct String * str_create_with_locker(struct Locker *locker, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized(locker, MIN_STRING_SIZE, format, args);
  args = ((void **)NULL);
  return str;
}

// str_create_with_locker_sized
// file libslack/str.c line 630
struct String * str_create_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, ...)
{
  struct String *str;
  void **args = (void **)&format;
  str=str_vcreate_with_locker_sized(locker, size, format, args);
  args = ((void **)NULL);
  return str;
}

// str_decode
// file libslack/str.c line 5606
struct String * str_decode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_decode_with_locker_1;
  return_value_str_decode_with_locker_1=str_decode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_decode_with_locker_1;
}

// str_decode_unlocked
// file libslack/str.c line 5621
struct String * str_decode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_decode_with_locker_unlocked_1;
  return_value_str_decode_with_locker_unlocked_1=str_decode_with_locker_unlocked((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_decode_with_locker_unlocked_1;
}

// str_decode_with_locker
// file libslack/str.c line 5637
struct String * str_decode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_decode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_decode_with_locker_unlocked
// file libslack/str.c line 5670
struct String * str_decode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    struct String *return_value_do_decode_with_locker_2;
    return_value_do_decode_with_locker_2=do_decode_with_locker(locker, str->str, str->length - (unsigned long int)1, uncoded, coded, quote_char, printable);
    return return_value_do_decode_with_locker_2;
  }
}

// str_destroy
// file libslack/str.c line 894
void * str_destroy(struct String **str)
{
  if(!(str == ((struct String **)NULL)))
  {
    if(!(*str == ((struct String *)NULL)))
    {
      str_release(*str);
      *str = (struct String *)(void *)0;
    }

  }

  return (void *)0;
}

// str_empty
// file libslack/str.c line 987
signed int str_empty(const struct String *str)
{
  signed int empty;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      empty=str_empty_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return empty;
    }
  }
}

// str_empty_unlocked
// file libslack/str.c line 1016
signed int str_empty_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
    return (signed int)(str->length == (unsigned long int)1);
}

// str_encode
// file libslack/str.c line 5517
struct String * str_encode(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_encode_with_locker_1;
  return_value_str_encode_with_locker_1=str_encode_with_locker((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_encode_with_locker_1;
}

// str_encode_unlocked
// file libslack/str.c line 5532
struct String * str_encode_unlocked(const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *return_value_str_encode_with_locker_unlocked_1;
  return_value_str_encode_with_locker_unlocked_1=str_encode_with_locker_unlocked((struct Locker *)(void *)0, str, uncoded, coded, quote_char, printable);
  return return_value_str_encode_with_locker_unlocked_1;
}

// str_encode_with_locker
// file libslack/str.c line 5548
struct String * str_encode_with_locker(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_encode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_encode_with_locker_unlocked
// file libslack/str.c line 5581
struct String * str_encode_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *uncoded, const char *coded, char quote_char, signed int printable)
{
  void *return_value_set_errnull_1;
  if(coded == ((const char *)NULL) || uncoded == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    struct String *return_value_do_encode_with_locker_2;
    return_value_do_encode_with_locker_2=do_encode_with_locker(locker, str->str, str->length - (unsigned long int)1, uncoded, coded, quote_char, printable);
    return return_value_do_encode_with_locker_2;
  }
}

// str_fgetline
// file libslack/str.c line 812
struct String * str_fgetline(struct _IO_FILE *stream)
{
  struct String *return_value_str_fgetline_with_locker_1;
  return_value_str_fgetline_with_locker_1=str_fgetline_with_locker((struct Locker *)(void *)0, stream);
  return return_value_str_fgetline_with_locker_1;
}

// str_fgetline_with_locker
// file libslack/str.c line 828
struct String * str_fgetline_with_locker(struct Locker *locker, struct _IO_FILE *stream)
{
  struct String *ret = (struct String *)(void *)0;
  char buf[8192l];
  flockfile(stream);
  char *return_value_fgetline_unlocked_1;
  struct String *return_value_str_append_2;
  do
  {
    return_value_fgetline_unlocked_1=fgetline_unlocked(buf, (unsigned long int)8192, stream);
    if(return_value_fgetline_unlocked_1 == ((char *)NULL))
      break;

    if(ret == ((struct String *)NULL))
    {
      ret=str_create_with_locker(locker, "%s", (const void *)buf);
      if(ret == ((struct String *)NULL))
        break;

    }

    else
    {
      return_value_str_append_2=str_append(ret, "%s", (const void *)buf);
      if(return_value_str_append_2 == ((struct String *)NULL))
      {
        str_destroy(&ret);
        break;
      }

    }
    char *return_value_cstr_3;
    return_value_cstr_3=cstr(ret);
    if((signed int)return_value_cstr_3[-2l + (signed long int)ret->length] == 10)
      break;

  }
  while((_Bool)1);
  funlockfile(stream);
  return ret;
}

// str_fmt
// file libslack/str.c line 3675
struct List * str_fmt(const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_str_fmt_with_locker_1;
  return_value_str_fmt_with_locker_1=str_fmt_with_locker((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_str_fmt_with_locker_1;
}

// str_fmt_unlocked
// file libslack/str.c line 3690
struct List * str_fmt_unlocked(const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *return_value_str_fmt_with_locker_unlocked_1;
  return_value_str_fmt_with_locker_unlocked_1=str_fmt_with_locker_unlocked((struct Locker *)(void *)0, str, line_width, alignment);
  return return_value_str_fmt_with_locker_unlocked_1;
}

// str_fmt_with_locker
// file libslack/str.c line 3706
struct List * str_fmt_with_locker(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_fmt_with_locker_unlocked(locker, str, line_width, alignment);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_fmt_with_locker_unlocked
// file libslack/str.c line 3739
struct List * str_fmt_with_locker_unlocked(struct Locker *locker, const struct String *str, unsigned long int line_width, enum StringAlignment alignment)
{
  void *return_value_set_errnull_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_fmt_with_locker_2;
    return_value_fmt_with_locker_2=fmt_with_locker(locker, str->str, line_width, alignment);
    return return_value_fmt_with_locker_2;
  }
}

// str_hex
// file libslack/str.c line 6321
signed int str_hex(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_hex_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_hex_unlocked
// file libslack/str.c line 6350
signed int str_hex_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_hex_2;
    return_value_hex_2=hex(str->str);
    return return_value_hex_2;
  }
}

// str_insert
// file libslack/str.h line 93
struct String * str_insert(struct String *str, signed long int index, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, index, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_insert_str
// file libslack/str.c line 1457
struct String * str_insert_str(struct String *str, signed long int index, const struct String *src)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  signed int return_value_2;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  signed int return_value_3;
  void *return_value_set_errnull_11;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(src == ((const struct String *)NULL)))
    {
      if(!(src->locker == ((struct Locker *)NULL)))
      {
        return_value=src->locker->rdlock(src->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      ret=str_insert_str_unlocked(str, index, src);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr_9 = return_value_2;
        }

        else
          tmp_if_expr_9 = 0;
        tmp_if_expr_10 = tmp_if_expr_9;
      }

      else
        tmp_if_expr_10 = 22;
      err = tmp_if_expr_10;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_8;
        return_value_set_errnull_8=set_errnull(err);
        return (struct String *)return_value_set_errnull_8;
      }

      if(!(src == ((const struct String *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_3=src->locker->unlock(src->locker->lock);
          tmp_if_expr_12 = return_value_3;
        }

        else
          tmp_if_expr_12 = 0;
        tmp_if_expr_13 = tmp_if_expr_12;
      }

      else
        tmp_if_expr_13 = 22;
      err = tmp_if_expr_13;
      if(!(err == 0))
      {
        return_value_set_errnull_11=set_errnull(err);
        return (struct String *)return_value_set_errnull_11;
      }

      else
        return ret;
    }
  }
}

// str_insert_str_unlocked
// file libslack/str.c line 1501
struct String * str_insert_str_unlocked(struct String *str, signed long int index, const struct String *src)
{
  unsigned long int length;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct String *)return_value_set_errnull_2;
    }

    else
      if(!(str->length + 18446744073709551615ul >= (unsigned long int)index))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct String *)return_value_set_errnull_3;
      }

      else
      {
        length = src->length - (unsigned long int)1;
        signed int return_value_expand_4;
        return_value_expand_4=expand_link1(str, index, length);
        if(return_value_expand_4 == -1)
          return (struct String *)(void *)0;

        else
        {
          memcpy((void *)(str->str + index), (const void *)src->str, length);
          return str;
        }
      }
  }
}

// str_insert_unlocked
// file libslack/str.c line 1368
struct String * str_insert_unlocked(struct String *str, signed long int index, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, index, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_join
// file libslack/str.c line 4341
struct String * str_join(const struct List *list, const char *delim)
{
  struct String *return_value_str_join_with_locker_1;
  return_value_str_join_with_locker_1=str_join_with_locker((struct Locker *)(void *)0, list, delim);
  return return_value_str_join_with_locker_1;
}

// str_join_unlocked
// file libslack/str.c line 4356
struct String * str_join_unlocked(const struct List *list, const char *delim)
{
  struct String *return_value_str_join_with_locker_unlocked_1;
  return_value_str_join_with_locker_unlocked_1=str_join_with_locker_unlocked((struct Locker *)(void *)0, list, delim);
  return return_value_str_join_with_locker_unlocked_1;
}

// str_join_with_locker
// file libslack/str.c line 4372
struct String * str_join_with_locker(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    err=list_rdlock(list);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_join_with_locker_unlocked(locker, list, delim);
      err=list_unlock(list);
      if(!(err == 0))
      {
        return_value_set_errnull_3=set_errnull(err);
        return (struct String *)return_value_set_errnull_3;
      }

      else
        return ret;
    }
  }
}

// str_join_with_locker_unlocked
// file libslack/str.c line 4402
struct String * str_join_with_locker_unlocked(struct Locker *locker, const struct List *list, const char *delim)
{
  struct String *ret;
  struct String *del;
  struct Lister *lister;
  signed int i;
  void *return_value_set_errnull_1;
  signed int return_value_lister_has_next_2;
  struct String *return_value_str_append_str_4;
  struct String *return_value_str_append_str_5;
  if(list == ((const struct List *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_create_with_locker(locker, (const char *)(void *)0);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      del=str_create(delim != ((const char *)NULL) ? "%s" : (char *)(void *)0, delim);
      if(del == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
      {
        lister=lister_create_unlocked(list);
        if(lister == ((struct Lister *)NULL))
        {
          str_release(ret);
          str_release(del);
          return (struct String *)(void *)0;
        }

        else
        {
          i = 0;
          do
          {
            return_value_lister_has_next_2=lister_has_next(lister);
            if(!(return_value_lister_has_next_2 == 1))
              break;

            struct String *s;
            void *return_value_lister_next_3;
            return_value_lister_next_3=lister_next(lister);
            s = (struct String *)return_value_lister_next_3;
            if(!(i == 0))
            {
              return_value_str_append_str_4=str_append_str(ret, del);
              if(return_value_str_append_str_4 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release_unlocked(lister);
                return (struct String *)(void *)0;
              }

            }

            if(!(s == ((struct String *)NULL)))
            {
              return_value_str_append_str_5=str_append_str(ret, s);
              if(return_value_str_append_str_5 == ((struct String *)NULL))
              {
                str_release(ret);
                str_release(del);
                lister_release_unlocked(lister);
                return (struct String *)(void *)0;
              }

            }

            i = i + 1;
          }
          while((_Bool)1);
          str_release(del);
          lister_release_unlocked(lister);
          return ret;
        }
      }
    }
  }
}

// str_lc
// file libslack/str.c line 5757
struct String * str_lc(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_lc_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_lc_unlocked
// file libslack/str.c line 5786
struct String * str_lc_unlocked(struct String *str)
{
  unsigned long int i;
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_tolower_loc_3;
  const signed int **return_value___ctype_tolower_loc_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= str->length + 18446744073709551615ul); i = i + 1ul)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)str->str[(signed long int)i]);
      tmp_statement_expression_2 = __res;
      str->str[(signed long int)i] = (char)tmp_statement_expression_2;
    }
    return str;
  }
}

// str_lcfirst
// file libslack/str.c line 5834
struct String * str_lcfirst(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_lcfirst_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_lcfirst_unlocked
// file libslack/str.c line 5863
struct String * str_lcfirst_unlocked(struct String *str)
{
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_tolower_loc_3;
  const signed int **return_value___ctype_tolower_loc_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(str->length >= 2ul)
    {
      signed int __res;
      __res=tolower((signed int)(unsigned char)*str->str);
      tmp_statement_expression_2 = __res;
      *str->str = (char)tmp_statement_expression_2;
    }

    return str;
  }
}

// str_length
// file libslack/str.h line 80
signed long int str_length(const struct String *str)
{
  unsigned long int length;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_7;
  signed int return_value_1;
  signed int return_value_set_errno_6;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      signed long int return_value_str_length_unlocked_5;
      return_value_str_length_unlocked_5=str_length_unlocked(str);
      length = (unsigned long int)return_value_str_length_unlocked_5;
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_7 = return_value_1;
        }

        else
          tmp_if_expr_7 = 0;
        tmp_if_expr_8 = tmp_if_expr_7;
      }

      else
        tmp_if_expr_8 = 22;
      err = tmp_if_expr_8;
      if(!(err == 0))
      {
        return_value_set_errno_6=set_errno(err);
        return (signed long int)return_value_set_errno_6;
      }

      else
        return (signed long int)length;
    }
  }
}

// str_length_unlocked
// file libslack/str.c line 1063
signed long int str_length_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
    return (signed long int)(str->length - (unsigned long int)1);
}

// str_oct
// file libslack/str.c line 6418
signed int str_oct(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_oct_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_oct_unlocked
// file libslack/str.c line 6447
signed int str_oct_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_oct_2;
    return_value_oct_2=oct(str->str);
    return return_value_oct_2;
  }
}

// str_prepend
// file libslack/str.c line 1644
struct String * str_prepend(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert(str, (signed long int)0, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_prepend_str
// file libslack/str.c line 1716
struct String * str_prepend_str(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_1;
  return_value_str_insert_str_1=str_insert_str(str, (signed long int)0, src);
  return return_value_str_insert_str_1;
}

// str_prepend_str_unlocked
// file libslack/str.c line 1734
struct String * str_prepend_str_unlocked(struct String *str, const struct String *src)
{
  struct String *return_value_str_insert_str_unlocked_1;
  return_value_str_insert_str_unlocked_1=str_insert_str_unlocked(str, (signed long int)0, src);
  return return_value_str_insert_str_unlocked_1;
}

// str_prepend_unlocked
// file libslack/str.c line 1664
struct String * str_prepend_unlocked(struct String *str, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vinsert_unlocked(str, (signed long int)0, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_quote
// file libslack/str.c line 5023
struct String * str_quote(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_quote_with_locker_1;
  return_value_str_quote_with_locker_1=str_quote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_quote_with_locker_1;
}

// str_quote_unlocked
// file libslack/str.c line 5038
struct String * str_quote_unlocked(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_quote_with_locker_unlocked_1;
  return_value_str_quote_with_locker_unlocked_1=str_quote_with_locker_unlocked((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_quote_with_locker_unlocked_1;
}

// str_quote_with_locker
// file libslack/str.c line 5054
struct String * str_quote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull_1;
  char *return_value___builtin_strchr_4;
  unsigned long int tmp_post_2;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_copy_with_locker(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
        if(!(ret->str[(signed long int)i] == 0))
        {
          return_value___builtin_strchr_4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
          if(!(return_value___builtin_strchr_4 == ((char *)NULL)))
          {
            tmp_post_2 = i;
            i = i + 1ul;
            struct String *return_value_str_insert_3;
            return_value_str_insert_3=str_insert(ret, (signed long int)tmp_post_2, "%c", quote_char);
            if(return_value_str_insert_3 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// str_quote_with_locker_unlocked
// file libslack/str.c line 5090
struct String * str_quote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  unsigned long int i;
  void *return_value_set_errnull_1;
  char *return_value___builtin_strchr_4;
  unsigned long int tmp_post_2;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_copy_with_locker_unlocked(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= ret->length + 18446744073709551615ul); i = i + 1ul)
        if(!(ret->str[(signed long int)i] == 0))
        {
          return_value___builtin_strchr_4=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)i]);
          if(!(return_value___builtin_strchr_4 == ((char *)NULL)))
          {
            tmp_post_2 = i;
            i = i + 1ul;
            struct String *return_value_str_insert_3;
            return_value_str_insert_3=str_insert(ret, (signed long int)tmp_post_2, "%c", quote_char);
            if(return_value_str_insert_3 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// str_rdlock
// file libslack/str.c line 929
signed int str_rdlock(const struct String *str)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->rdlock(str->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// str_recalc_length
// file libslack/str.c line 1161
signed long int str_recalc_length(struct String *str)
{
  signed long int len;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      len=str_recalc_length_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return len;
    }
  }
}

// str_recalc_length_unlocked
// file libslack/str.c line 1191
signed long int str_recalc_length_unlocked(struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str->str);
    str->length = return_value_strlen_2 + (unsigned long int)1;
    return (signed long int)(str->length - (unsigned long int)1);
  }
}

// str_regexpr
// file libslack/str.c line 3035
struct List * str_regexpr(const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_with_locker_1;
  return_value_str_regexpr_with_locker_1=str_regexpr_with_locker((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_str_regexpr_with_locker_1;
}

// str_regexpr_compiled
// file libslack/str.c line 3208
struct List * str_regexpr_compiled(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *return_value_str_regexpr_compiled_with_locker_1;
  return_value_str_regexpr_compiled_with_locker_1=str_regexpr_compiled_with_locker((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_str_regexpr_compiled_with_locker_1;
}

// str_regexpr_compiled_unlocked
// file libslack/str.c line 3224
struct List * str_regexpr_compiled_unlocked(const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *return_value_str_regexpr_compiled_with_locker_unlocked_1;
  return_value_str_regexpr_compiled_with_locker_unlocked_1=str_regexpr_compiled_with_locker_unlocked((struct Locker *)(void *)0, compiled, text, eflags);
  return return_value_str_regexpr_compiled_with_locker_unlocked_1;
}

// str_regexpr_compiled_with_locker
// file libslack/str.c line 3240
struct List * str_regexpr_compiled_with_locker(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(text == ((const struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(text == ((const struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->rdlock(text->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regexpr_compiled_with_locker_unlocked(locker, compiled, text, eflags);
      if(!(text == ((const struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_regexpr_compiled_with_locker_unlocked
// file libslack/str.c line 3273
struct List * str_regexpr_compiled_with_locker_unlocked(struct Locker *locker, const struct re_pattern_buffer *compiled, const struct String *text, signed int eflags)
{
  void *return_value_set_errnull_1;
  if(text == ((const struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_regexpr_compiled_with_locker_2;
    return_value_regexpr_compiled_with_locker_2=regexpr_compiled_with_locker(locker, compiled, text->str, eflags);
    return return_value_regexpr_compiled_with_locker_2;
  }
}

// str_regexpr_split
// file libslack/str.c line 4154
struct List * str_regexpr_split(const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_split_with_locker_1;
  return_value_str_regexpr_split_with_locker_1=str_regexpr_split_with_locker((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_str_regexpr_split_with_locker_1;
}

// str_regexpr_split_unlocked
// file libslack/str.c line 4169
struct List * str_regexpr_split_unlocked(const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_split_with_locker_unlocked_1;
  return_value_str_regexpr_split_with_locker_unlocked_1=str_regexpr_split_with_locker_unlocked((struct Locker *)(void *)0, str, delim, cflags, eflags);
  return return_value_str_regexpr_split_with_locker_unlocked_1;
}

// str_regexpr_split_with_locker
// file libslack/str.c line 4185
struct List * str_regexpr_split_with_locker(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regexpr_split_with_locker_unlocked(locker, str, delim, cflags, eflags);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_regexpr_split_with_locker_unlocked
// file libslack/str.c line 4218
struct List * str_regexpr_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim, signed int cflags, signed int eflags)
{
  void *return_value_set_errnull_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_regexpr_split_with_locker_2;
    return_value_regexpr_split_with_locker_2=regexpr_split_with_locker(locker, str->str, delim, cflags, eflags);
    return return_value_regexpr_split_with_locker_2;
  }
}

// str_regexpr_unlocked
// file libslack/str.c line 3050
struct List * str_regexpr_unlocked(const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *return_value_str_regexpr_with_locker_unlocked_1;
  return_value_str_regexpr_with_locker_unlocked_1=str_regexpr_with_locker_unlocked((struct Locker *)(void *)0, pattern, text, cflags, eflags);
  return return_value_str_regexpr_with_locker_unlocked_1;
}

// str_regexpr_with_locker
// file libslack/str.c line 3066
struct List * str_regexpr_with_locker(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(pattern == ((const char *)NULL) || text == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(text == ((const struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->rdlock(text->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regexpr_with_locker_unlocked(locker, pattern, text, cflags, eflags);
      if(!(text == ((const struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_regexpr_with_locker_unlocked
// file libslack/str.c line 3099
struct List * str_regexpr_with_locker_unlocked(struct Locker *locker, const char *pattern, const struct String *text, signed int cflags, signed int eflags)
{
  void *return_value_set_errnull_1;
  if(pattern == ((const char *)NULL) || text == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_regexpr_with_locker_2;
    return_value_regexpr_with_locker_2=regexpr_with_locker(locker, pattern, text->str, cflags, eflags);
    return return_value_regexpr_with_locker_2;
  }
}

// str_regsub
// file libslack/str.c line 3382
struct String * str_regsub(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all)
{
  struct re_pattern_buffer compiled[1l];
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(pattern == ((const char *)NULL) || replacement == ((const char *)NULL) || text == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regsub_compiled(compiled, replacement, text, eflags, all);
      regfree(compiled);
      return ret;
    }
  }
}

// str_regsub_compiled
// file libslack/str.c line 3439
struct String * str_regsub_compiled(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(replacement == ((const char *)NULL) || text == ((struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(text == ((struct String *)NULL)))
    {
      if(!(text->locker == ((struct Locker *)NULL)))
      {
        return_value=text->locker->wrlock(text->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regsub_compiled_unlocked(compiled, replacement, text, eflags, all);
      if(!(text == ((struct String *)NULL)))
      {
        if(!(text->locker == ((struct Locker *)NULL)))
        {
          return_value_1=text->locker->unlock(text->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_regsub_compiled_unlocked
// file libslack/str.c line 3469
struct String * str_regsub_compiled_unlocked(const struct re_pattern_buffer *compiled, const char *replacement, struct String *text, signed int eflags, signed int all)
{
  struct anonymous_7 match[33l];
  struct String *rep;
  signed int matches;
  unsigned long int start;
  signed int states[33l];
  signed int i;
  signed int s;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_4;
  const unsigned short int **return_value___ctype_b_loc_7;
  _Bool tmp_if_expr_9;
  struct String *return_value_str_remove_30;
  signed int tmp_statement_expression_31;
  signed int tmp_if_expr_33;
  const signed int **return_value___ctype_tolower_loc_32;
  const signed int **return_value___ctype_tolower_loc_34;
  signed int tmp_statement_expression_35;
  signed int tmp_if_expr_37;
  const signed int **return_value___ctype_toupper_loc_36;
  const signed int **return_value___ctype_toupper_loc_38;
  const unsigned short int **return_value___ctype_b_loc_42;
  signed int tmp_post_40;
  struct String *return_value_str_insert_41;
  if(replacement == ((const char *)NULL) || text == ((struct String *)NULL) || compiled == ((const struct re_pattern_buffer *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    start = (unsigned long int)0;
    matches = 0;
    for( ; text->length + 18446744073709551615ul >= start; matches = matches + 1)
    {
      signed int return_value_regexec_2;
      return_value_regexec_2=regexec(compiled, text->str + (signed long int)start, (unsigned long int)33, match, eflags);
      if(!(return_value_regexec_2 == 0))
        return matches != 0 ? text : (struct String *)(void *)0;

      rep=str_create("%s", replacement);
      if(rep == ((struct String *)NULL))
        return (struct String *)(void *)0;

      i = 0;
      for( ; !((unsigned long int)i >= rep->length + 18446744073709551615ul); i = i + 1)
        if((signed int)rep->str[(signed long int)i] == 36)
        {
          if((signed int)rep->str[(signed long int)(1 + i)] == 36)
          {
            struct String *return_value_str_remove_3;
            return_value_str_remove_3=str_remove(rep, (signed long int)i);
            if(return_value_str_remove_3 == ((struct String *)NULL))
            {
              str_release(rep);
              return (struct String *)(void *)0;
            }

          }

          else
          {
            signed int ref;
            signed int j = i + 1;
            if((signed int)rep->str[(signed long int)j] == 123)
            {
              j = j + 1;
              ref = 0;
              do
              {
                return_value___ctype_b_loc_4=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)j]]) == 0)
                  break;

                ref = ref * 10;
                ref = ref + ((signed int)rep->str[(signed long int)j] - 48);
                j = j + 1;
              }
              while((_Bool)1);
              if(!((signed int)rep->str[(signed long int)j] == 125))
              {
                str_release(rep);
                void *return_value_set_errnull_5;
                return_value_set_errnull_5=set_errnull(22);
                return (struct String *)return_value_set_errnull_5;
              }

            }

            else
            {
              return_value___ctype_b_loc_7=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)(1 + i)]]) == 0))
                ref = (signed int)rep->str[(signed long int)j] - 48;

              else
              {
                str_release(rep);
                void *return_value_set_errnull_6;
                return_value_set_errnull_6=set_errnull(22);
                return (struct String *)return_value_set_errnull_6;
              }
            }
            if(ref >= 33 || !(ref >= 0))
              tmp_if_expr_9 = (_Bool)1;

            else
              tmp_if_expr_9 = match[(signed long int)ref].rm_so == -1 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_9)
            {
              str_release(rep);
              void *return_value_set_errnull_8;
              return_value_set_errnull_8=set_errnull(22);
              return (struct String *)return_value_set_errnull_8;
            }

            struct String *return_value_str_replace_10;
            return_value_str_replace_10=str_replace(rep, (signed long int)i, (signed long int)((j + 1) - i), "%.*s", (signed int)(match[(signed long int)ref].rm_eo - match[(signed long int)ref].rm_so), text->str + (signed long int)match[(signed long int)ref].rm_so);
            if(return_value_str_replace_10 == ((struct String *)NULL))
            {
              str_release(rep);
              return (struct String *)(void *)0;
            }

            i = i + ((match[(signed long int)ref].rm_eo - match[(signed long int)ref].rm_so) - 1);
          }
        }

      s = 0;
      states[(signed long int)s] = 0;
      i = 0;
      for( ; !((unsigned long int)i >= rep->length + 18446744073709551615ul); i = i + 1)
        if((signed int)rep->str[(signed long int)i] == 92)
          switch((signed int)rep->str[(signed long int)(i + 1)])
          {
            case 108:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull_11;
                return_value_set_errnull_11=set_errnull(22);
                return (struct String *)return_value_set_errnull_11;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 9;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~2;
              struct String *return_value_str_remove_range_13;
              return_value_str_remove_range_13=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_13 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_12;
                return_value_set_errnull_12=set_errnull(22);
                return (struct String *)return_value_set_errnull_12;
              }

              i = i - 1;
              break;
            }
            case 76:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull_14;
                return_value_set_errnull_14=set_errnull(22);
                return (struct String *)return_value_set_errnull_14;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 1;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~2;
              struct String *return_value_str_remove_range_16;
              return_value_str_remove_range_16=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_16 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_15;
                return_value_set_errnull_15=set_errnull(22);
                return (struct String *)return_value_set_errnull_15;
              }

              i = i - 1;
              break;
            }
            case 117:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull_17;
                return_value_set_errnull_17=set_errnull(22);
                return (struct String *)return_value_set_errnull_17;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 10;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~1;
              struct String *return_value_str_remove_range_19;
              return_value_str_remove_range_19=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_19 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_18;
                return_value_set_errnull_18=set_errnull(22);
                return (struct String *)return_value_set_errnull_18;
              }

              i = i - 1;
              break;
            }
            case 85:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull_20;
                return_value_set_errnull_20=set_errnull(22);
                return (struct String *)return_value_set_errnull_20;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 2;
              s = s + 1;
              states[(signed long int)s] = states[(signed long int)s] & ~1;
              struct String *return_value_str_remove_range_22;
              return_value_str_remove_range_22=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_22 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_21;
                return_value_set_errnull_21=set_errnull(22);
                return (struct String *)return_value_set_errnull_21;
              }

              i = i - 1;
              break;
            }
            case 81:
            {
              if(s >= 33)
              {
                str_release(rep);
                void *return_value_set_errnull_23;
                return_value_set_errnull_23=set_errnull(22);
                return (struct String *)return_value_set_errnull_23;
              }

              states[(signed long int)(s + 1)] = states[(signed long int)s] | 4;
              s = s + 1;
              struct String *return_value_str_remove_range_25;
              return_value_str_remove_range_25=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_25 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_24;
                return_value_set_errnull_24=set_errnull(22);
                return (struct String *)return_value_set_errnull_24;
              }

              i = i - 1;
              break;
            }
            case 69:
            {
              if(s == 0)
              {
                str_release(rep);
                void *return_value_set_errnull_26;
                return_value_set_errnull_26=set_errnull(22);
                return (struct String *)return_value_set_errnull_26;
              }

              s = s - 1;
              struct String *return_value_str_remove_range_28;
              return_value_str_remove_range_28=str_remove_range(rep, (signed long int)i, (signed long int)2);
              if(return_value_str_remove_range_28 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_27;
                return_value_set_errnull_27=set_errnull(22);
                return (struct String *)return_value_set_errnull_27;
              }

              i = i - 1;
              break;
            }
            case 92:
            {
              return_value_str_remove_30=str_remove(rep, (signed long int)i);
              if(return_value_str_remove_30 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_29;
                return_value_set_errnull_29=set_errnull(22);
                return (struct String *)return_value_set_errnull_29;
              }

            }
          }

        else
        {
          if(!((1 & states[(signed long int)s]) == 0))
          {
            signed int __res;
            __res=tolower((signed int)(unsigned char)rep->str[(signed long int)i]);
            tmp_statement_expression_31 = __res;
            rep->str[(signed long int)i] = (char)tmp_statement_expression_31;
          }

          if(!((2 & states[(signed long int)s]) == 0))
          {
            signed int str_regsub_compiled_unlocked__1__1__1__2__1__2__2____res;
            str_regsub_compiled_unlocked__1__1__1__2__1__2__2____res=toupper((signed int)(unsigned char)rep->str[(signed long int)i]);
            tmp_statement_expression_35 = str_regsub_compiled_unlocked__1__1__1__2__1__2__2____res;
            rep->str[(signed long int)i] = (char)tmp_statement_expression_35;
          }

          if(!((4 & states[(signed long int)s]) == 0))
          {
            return_value___ctype_b_loc_42=__ctype_b_loc();
            if((8 & (signed int)(*return_value___ctype_b_loc_42)[(signed long int)(signed int)(unsigned char)rep->str[(signed long int)i]]) == 0)
            {
              tmp_post_40 = i;
              i = i + 1;
              return_value_str_insert_41=str_insert(rep, (signed long int)tmp_post_40, "\\");
              if(return_value_str_insert_41 == ((struct String *)NULL))
              {
                str_release(rep);
                void *return_value_set_errnull_39;
                return_value_set_errnull_39=set_errnull(22);
                return (struct String *)return_value_set_errnull_39;
              }

            }

          }

          if(!((8 & states[(signed long int)s]) == 0))
          {
            if(s == 0)
            {
              str_release(rep);
              void *return_value_set_errnull_43;
              return_value_set_errnull_43=set_errnull(22);
              return (struct String *)return_value_set_errnull_43;
            }

            s = s - 1;
          }

        }
      struct String *return_value_str_replace_str_unlocked_44;
      return_value_str_replace_str_unlocked_44=str_replace_str_unlocked(text, (signed long int)(start + (unsigned long int)match[(signed long int)0].rm_so), (signed long int)(match[(signed long int)0].rm_eo - match[(signed long int)0].rm_so), rep);
      if(return_value_str_replace_str_unlocked_44 == ((struct String *)NULL))
      {
        str_release(rep);
        return (struct String *)(void *)0;
      }

      if(match[0l].rm_so == 0)
      {
        if(match[0l].rm_eo == 0)
        {
          match[(signed long int)0].rm_so = match[(signed long int)0].rm_so + 1;
          match[(signed long int)0].rm_eo = match[(signed long int)0].rm_eo + 1;
        }

      }

      start = start + (((unsigned long int)match[(signed long int)0].rm_so + rep->length) - (unsigned long int)1);
      str_release(rep);
      if(all == 0)
        break;

    }
    return text;
  }
}

// str_regsub_unlocked
// file libslack/str.c line 3410
struct String * str_regsub_unlocked(const char *pattern, const char *replacement, struct String *text, signed int cflags, signed int eflags, signed int all)
{
  struct re_pattern_buffer compiled[1l];
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  if(pattern == ((const char *)NULL) || replacement == ((const char *)NULL) || text == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    err=regexpr_compile(compiled, pattern, cflags);
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_regsub_compiled_unlocked(compiled, replacement, text, eflags, all);
      regfree(compiled);
      return ret;
    }
  }
}

// str_release
// file libslack/str.h line 73
void str_release(struct String *str)
{
  struct Locker *str_release__1__locker;
  if(!(str == ((struct String *)NULL)))
  {
    signed int return_value_str_wrlock_1;
    return_value_str_wrlock_1=str_wrlock(str);
    if(return_value_str_wrlock_1 == 0)
    {
      str_release__1__locker = str->locker;
      free((void *)str->str);
      free((void *)str);
      if(!(str_release__1__locker == ((struct Locker *)NULL)))
        str_release__1__locker->unlock(str_release__1__locker->lock);

      else
        0;
    }

  }

}

// str_remove
// file libslack/str.c line 1246
struct String * str_remove(struct String *str, signed long int index)
{
  struct String *return_value_str_remove_range_1;
  return_value_str_remove_range_1=str_remove_range(str, index, (signed long int)1);
  return return_value_str_remove_range_1;
}

// str_remove_range
// file libslack/str.c line 1280
struct String * str_remove_range(struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_remove_range_unlocked(str, index, range);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_remove_range_unlocked
// file libslack/str.c line 1309
struct String * str_remove_range_unlocked(struct String *str, signed long int index, signed long int range)
{
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct String *)return_value_set_errnull_3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct String *)return_value_set_errnull_4;
        }

        else
        {
          contract_link1(str, index, (unsigned long int)range);
          return str;
        }
    }
  }
}

// str_remove_unlocked
// file libslack/str.c line 1261
struct String * str_remove_unlocked(struct String *str, signed long int index)
{
  struct String *return_value_str_remove_range_unlocked_1;
  return_value_str_remove_range_unlocked_1=str_remove_range_unlocked(str, index, (signed long int)1);
  return return_value_str_remove_range_unlocked_1;
}

// str_repeat
// file libslack/str.c line 2211
struct String * str_repeat(unsigned long int count, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vrepeat_with_locker((struct Locker *)(void *)0, count, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_repeat_with_locker
// file libslack/str.c line 2232
struct String * str_repeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vrepeat_with_locker(locker, count, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_replace
// file libslack/str.c line 1754
struct String * str_replace(struct String *str, signed long int index, signed long int range, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vreplace(str, index, range, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_replace_str
// file libslack/str.c line 1852
struct String * str_replace_str(struct String *str, signed long int index, signed long int range, const struct String *src)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  signed int return_value_2;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  signed int return_value_3;
  void *return_value_set_errnull_11;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(src == ((const struct String *)NULL)))
    {
      if(!(src->locker == ((struct Locker *)NULL)))
      {
        return_value=src->locker->rdlock(src->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      ret=str_replace_str_unlocked(str, index, range, src);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr_9 = return_value_2;
        }

        else
          tmp_if_expr_9 = 0;
        tmp_if_expr_10 = tmp_if_expr_9;
      }

      else
        tmp_if_expr_10 = 22;
      err = tmp_if_expr_10;
      if(!(err == 0))
      {
        if(!(src == ((const struct String *)NULL)))
        {
          if(!(src->locker == ((struct Locker *)NULL)))
            src->locker->unlock(src->locker->lock);

          else
            0;
        }

        else
          22;
        void *return_value_set_errnull_8;
        return_value_set_errnull_8=set_errnull(err);
        return (struct String *)return_value_set_errnull_8;
      }

      if(!(src == ((const struct String *)NULL)))
      {
        if(!(src->locker == ((struct Locker *)NULL)))
        {
          return_value_3=src->locker->unlock(src->locker->lock);
          tmp_if_expr_12 = return_value_3;
        }

        else
          tmp_if_expr_12 = 0;
        tmp_if_expr_13 = tmp_if_expr_12;
      }

      else
        tmp_if_expr_13 = 22;
      err = tmp_if_expr_13;
      if(!(err == 0))
      {
        return_value_set_errnull_11=set_errnull(err);
        return (struct String *)return_value_set_errnull_11;
      }

      else
        return ret;
    }
  }
}

// str_replace_str_unlocked
// file libslack/str.c line 1896
struct String * str_replace_str_unlocked(struct String *str, signed long int index, signed long int range, const struct String *src)
{
  unsigned long int length;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(src == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct String *)return_value_set_errnull_3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct String *)return_value_set_errnull_4;
        }

        else
        {
          length = src->length - (unsigned long int)1;
          signed int return_value_adjust_5;
          return_value_adjust_5=adjust_link1(str, index, (unsigned long int)range, length);
          if(return_value_adjust_5 == -1)
            return (struct String *)(void *)0;

          else
          {
            memcpy((void *)(str->str + index), (const void *)src->str, length);
            return str;
          }
        }
    }
  }
}

// str_replace_unlocked
// file libslack/str.c line 1774
struct String * str_replace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, ...)
{
  struct String *ret;
  void **args = (void **)&format;
  ret=str_vreplace_unlocked(str, index, range, format, args);
  args = ((void **)NULL);
  return ret;
}

// str_set_length
// file libslack/str.c line 1107
signed long int str_set_length(struct String *str, unsigned long int length)
{
  signed long int len;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return (signed long int)return_value_set_errno_2;
    }

    else
    {
      len=str_set_length_unlocked(str, length);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return (signed long int)return_value_set_errno_5;
      }

      else
        return len;
    }
  }
}

// str_set_length_unlocked
// file libslack/str.c line 1136
signed long int str_set_length_unlocked(struct String *str, unsigned long int length)
{
  _Bool tmp_if_expr_2;
  if(str == ((struct String *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = length >= str->length ? (_Bool)1 : (_Bool)0;
  signed int return_value_set_errno_1;
  if(tmp_if_expr_2)
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    str->length = length + (unsigned long int)1;
    str->str[(signed long int)(str->length - (unsigned long int)1)] = (char)0;
    return (signed long int)(str->length - (unsigned long int)1);
  }
}

// str_soundex
// file libslack/str.c line 4545
signed int str_soundex(const struct String *str)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  signed int return_value_set_errno_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=str_soundex_unlocked(str);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errno_5=set_errno(err);
        return return_value_set_errno_5;
      }

      else
        return ret;
    }
  }
}

// str_soundex_unlocked
// file libslack/str.c line 4574
signed int str_soundex_unlocked(const struct String *str)
{
  signed int return_value_set_errno_1;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_soundex_2;
    return_value_soundex_2=soundex(str->str);
    return return_value_soundex_2;
  }
}

// str_splice
// file libslack/str.c line 2114
struct String * str_splice(struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_splice_with_locker_1;
  return_value_str_splice_with_locker_1=str_splice_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_str_splice_with_locker_1;
}

// str_splice_unlocked
// file libslack/str.c line 2129
struct String * str_splice_unlocked(struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_splice_with_locker_unlocked_1;
  return_value_str_splice_with_locker_unlocked_1=str_splice_with_locker_unlocked((struct Locker *)(void *)0, str, index, range);
  return return_value_str_splice_with_locker_unlocked_1;
}

// str_splice_with_locker
// file libslack/str.c line 2145
struct String * str_splice_with_locker(struct Locker *locker, struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_splice_with_locker_unlocked(locker, str, index, range);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        str_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_splice_with_locker_unlocked
// file libslack/str.c line 2178
struct String * str_splice_with_locker_unlocked(struct Locker *locker, struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  void *return_value_set_errnull_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_substr_with_locker_unlocked(locker, str, index, range);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      struct String *return_value_str_remove_range_unlocked_2;
      return_value_str_remove_range_unlocked_2=str_remove_range_unlocked(str, index, range);
      if(return_value_str_remove_range_unlocked_2 == ((struct String *)NULL))
      {
        str_release(ret);
        return (struct String *)(void *)0;
      }

      else
        return ret;
    }
  }
}

// str_split
// file libslack/str.c line 4030
struct List * str_split(const struct String *str, const char *delim)
{
  struct List *return_value_str_split_with_locker_1;
  return_value_str_split_with_locker_1=str_split_with_locker((struct Locker *)(void *)0, str, delim);
  return return_value_str_split_with_locker_1;
}

// str_split_unlocked
// file libslack/str.c line 4045
struct List * str_split_unlocked(const struct String *str, const char *delim)
{
  struct List *return_value_str_split_with_locker_unlocked_1;
  return_value_str_split_with_locker_unlocked_1=str_split_with_locker_unlocked((struct Locker *)(void *)0, str, delim);
  return return_value_str_split_with_locker_unlocked_1;
}

// str_split_with_locker
// file libslack/str.c line 4061
struct List * str_split_with_locker(struct Locker *locker, const struct String *str, const char *delim)
{
  struct List *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct List *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_split_with_locker_unlocked(locker, str, delim);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        list_release(ret);
        void *return_value_set_errnull_5;
        return_value_set_errnull_5=set_errnull(err);
        return (struct List *)return_value_set_errnull_5;
      }

      return ret;
    }
  }
}

// str_split_with_locker_unlocked
// file libslack/str.c line 4094
struct List * str_split_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *delim)
{
  void *return_value_set_errnull_1;
  if(delim == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct List *)return_value_set_errnull_1;
  }

  else
  {
    struct List *return_value_do_split_with_locker_2;
    return_value_do_split_with_locker_2=do_split_with_locker(locker, str->str, (signed long int)(str->length - (unsigned long int)1), delim);
    return return_value_do_split_with_locker_2;
  }
}

// str_squeeze
// file libslack/str.c line 4914
struct String * str_squeeze(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_squeeze_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_squeeze_unlocked
// file libslack/str.c line 4943
struct String * str_squeeze_unlocked(struct String *str)
{
  char *s;
  char *r;
  signed int started = 0;
  signed int was_space = 0;
  void *return_value_set_errnull_1;
  char *tmp_post_2;
  char *tmp_post_3;
  struct String *return_value_str_remove_range_unlocked_6;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    s = str->str;
    r = s;
    for( ; !((unsigned long int)(s - str->str) >= str->length + 18446744073709551615ul); s = s + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*s]) == 0)
      {
        if(!(started == 0) && !(was_space == 0))
        {
          tmp_post_2 = r;
          r = r + 1l;
          *tmp_post_2 = (char)32;
        }

        tmp_post_3 = r;
        r = r + 1l;
        *tmp_post_3 = *s;
        started = 1;
      }

      const unsigned short int **return_value___ctype_b_loc_5;
      return_value___ctype_b_loc_5=__ctype_b_loc();
      was_space = (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192;
    }
    if(!((unsigned long int)(r - str->str) >= str->length))
    {
      return_value_str_remove_range_unlocked_6=str_remove_range_unlocked(str, r - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(r - str->str)));
      if(!(return_value_str_remove_range_unlocked_6 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L6;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return str;
    }
  }
}

// str_substr
// file libslack/str.c line 1945
struct String * str_substr(const struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_substr_with_locker_1;
  return_value_str_substr_with_locker_1=str_substr_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_str_substr_with_locker_1;
}

// str_substr_unlocked
// file libslack/str.c line 1960
struct String * str_substr_unlocked(const struct String *str, signed long int index, signed long int range)
{
  struct String *return_value_str_substr_with_locker_unlocked_1;
  return_value_str_substr_with_locker_unlocked_1=str_substr_with_locker_unlocked((struct Locker *)(void *)0, str, index, range);
  return return_value_str_substr_with_locker_unlocked_1;
}

// str_substr_with_locker
// file libslack/str.c line 1976
struct String * str_substr_with_locker(struct Locker *locker, const struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((const struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->rdlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_substr_with_locker_unlocked(locker, str, index, range);
      if(!(str == ((const struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_substr_with_locker_unlocked
// file libslack/str.c line 2006
struct String * str_substr_with_locker_unlocked(struct Locker *locker, const struct String *str, signed long int index, signed long int range)
{
  struct String *ret;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((str->length + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct String *)return_value_set_errnull_3;
      }

      else
        if(!(str->length + 18446744073709551615ul >= (unsigned long int)index + (unsigned long int)range))
        {
          return_value_set_errnull_4=set_errnull(22);
          return (struct String *)return_value_set_errnull_4;
        }

        else
        {
          ret=str_create_with_locker_sized(locker, (unsigned long int)(range + (signed long int)1), (const char *)(void *)0);
          if(ret == ((struct String *)NULL))
            return (struct String *)(void *)0;

          else
          {
            memcpy((void *)ret->str, (const void *)(str->str + index), (unsigned long int)range);
            ret->length = (unsigned long int)(range + (signed long int)1);
            ret->str[(signed long int)(ret->length - (unsigned long int)1)] = (char)0;
            return ret;
          }
        }
    }
  }
}

// str_tr
// file libslack/str.c line 2371
signed int str_tr(struct String *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno_1;
  if(from == ((const char *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table_2;
    return_value_tr_compile_table_2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table_2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_3;
      return_value_str_tr_compiled_3=str_tr_compiled(str, table);
      return return_value_str_tr_compiled_3;
    }
  }
}

// str_tr_compile
// file libslack/str.c line 2549
struct StringTR * str_tr_compile(const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *return_value_str_tr_compile_with_locker_1;
  return_value_str_tr_compile_with_locker_1=str_tr_compile_with_locker((struct Locker *)(void *)0, from, to, option);
  return return_value_str_tr_compile_with_locker_1;
}

// str_tr_compile_table
// file libslack/str.c line 2808
static struct StringTR * str_tr_compile_table(struct StringTR *table, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  signed int err;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_2;
  signed int return_value;
  if(!(from == ((const struct String *)NULL)))
  {
    if(!(from->locker == ((struct Locker *)NULL)))
    {
      return_value=from->locker->rdlock(from->locker->lock);
      tmp_if_expr_2 = return_value;
    }

    else
      tmp_if_expr_2 = 0;
    tmp_if_expr_3 = tmp_if_expr_2;
  }

  else
    tmp_if_expr_3 = 22;
  err = tmp_if_expr_3;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_8;
  signed int return_value_2;
  signed int tmp_if_expr_12;
  signed int tmp_if_expr_11;
  signed int return_value_3;
  void *return_value_set_errnull_10;
  if(!(err == 0))
  {
    return_value_set_errnull_1=set_errnull(err);
    return (struct StringTR *)return_value_set_errnull_1;
  }

  else
  {
    if(!(to == ((const struct String *)NULL)))
    {
      if(!(to->locker == ((struct Locker *)NULL)))
      {
        return_value_1=to->locker->rdlock(to->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      tmp_if_expr_6 = tmp_if_expr_5;
    }

    else
      tmp_if_expr_6 = 22;
    err = tmp_if_expr_6;
    if(!(err == 0))
    {
      if(!(from == ((const struct String *)NULL)))
      {
        if(!(from->locker == ((struct Locker *)NULL)))
          from->locker->unlock(from->locker->lock);

        else
          0;
      }

      else
        22;
      void *return_value_set_errnull_4;
      return_value_set_errnull_4=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull_4;
    }

    ret=str_tr_compile_table_unlocked(table, from, to, option);
    if(!(from == ((const struct String *)NULL)))
    {
      if(!(from->locker == ((struct Locker *)NULL)))
      {
        return_value_2=from->locker->unlock(from->locker->lock);
        tmp_if_expr_8 = return_value_2;
      }

      else
        tmp_if_expr_8 = 0;
      tmp_if_expr_9 = tmp_if_expr_8;
    }

    else
      tmp_if_expr_9 = 22;
    err = tmp_if_expr_9;
    if(!(err == 0))
    {
      if(!(to == ((const struct String *)NULL)))
      {
        if(!(to->locker == ((struct Locker *)NULL)))
          to->locker->unlock(to->locker->lock);

        else
          0;
      }

      else
        22;
      void *return_value_set_errnull_7;
      return_value_set_errnull_7=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull_7;
    }

    if(!(to == ((const struct String *)NULL)))
    {
      if(!(to->locker == ((struct Locker *)NULL)))
      {
        return_value_3=to->locker->unlock(to->locker->lock);
        tmp_if_expr_11 = return_value_3;
      }

      else
        tmp_if_expr_11 = 0;
      tmp_if_expr_12 = tmp_if_expr_11;
    }

    else
      tmp_if_expr_12 = 22;
    err = tmp_if_expr_12;
    if(!(err == 0))
    {
      return_value_set_errnull_10=set_errnull(err);
      return (struct StringTR *)return_value_set_errnull_10;
    }

    else
      return ret;
  }
}

// str_tr_compile_table_unlocked
// file libslack/str.c line 2845
static struct StringTR * str_tr_compile_table_unlocked(struct StringTR *table, const struct String *from, const struct String *to, signed int option)
{
  signed long int return_value_str_length_unlocked_1;
  return_value_str_length_unlocked_1=str_length_unlocked(from);
  signed long int return_value_str_length_unlocked_2;
  return_value_str_length_unlocked_2=str_length_unlocked(to);
  struct StringTR *return_value_do_tr_compile_table_3;
  return_value_do_tr_compile_table_3=do_tr_compile_table(table, from->str, return_value_str_length_unlocked_1, to->str, return_value_str_length_unlocked_2, option);
  return return_value_do_tr_compile_table_3;
}

// str_tr_compile_unlocked
// file libslack/str.c line 2565
struct StringTR * str_tr_compile_unlocked(const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *return_value_str_tr_compile_with_locker_unlocked_1;
  return_value_str_tr_compile_with_locker_unlocked_1=str_tr_compile_with_locker_unlocked((struct Locker *)(void *)0, from, to, option);
  return return_value_str_tr_compile_with_locker_unlocked_1;
}

// str_tr_compile_with_locker
// file libslack/str.c line 2581
struct StringTR * str_tr_compile_with_locker(struct Locker *locker, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc_1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_str_tr_compile_table_2;
    return_value_str_tr_compile_table_2=str_tr_compile_table(ret, from, to, option);
    return return_value_str_tr_compile_table_2;
  }
}

// str_tr_compile_with_locker_unlocked
// file libslack/str.c line 2606
struct StringTR * str_tr_compile_with_locker_unlocked(struct Locker *locker, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc_1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_str_tr_compile_table_unlocked_2;
    return_value_str_tr_compile_table_unlocked_2=str_tr_compile_table_unlocked(ret, from, to, option);
    return return_value_str_tr_compile_table_unlocked_2;
  }
}

// str_tr_compiled
// file libslack/str.c line 2930
signed int str_tr_compiled(struct String *str, struct StringTR *table)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_8;
  signed int return_value_2;
  signed int tmp_if_expr_11;
  signed int return_value_3;
  signed int return_value_set_errno_10;
  if(str == ((struct String *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->wrlock(str->locker->lock);
          tmp_if_expr_5 = return_value_1;
        }

        else
          tmp_if_expr_5 = 0;
        tmp_if_expr_6 = tmp_if_expr_5;
      }

      else
        tmp_if_expr_6 = 22;
      err = tmp_if_expr_6;
      if(!(err == 0))
      {
        if(!(table->locker == ((struct Locker *)NULL)))
          table->locker->unlock(table->locker->lock);

        else
          0;
        signed int return_value_set_errno_4;
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      ret=str_tr_compiled_unlocked(str, table);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_2=str->locker->unlock(str->locker->lock);
          tmp_if_expr_8 = return_value_2;
        }

        else
          tmp_if_expr_8 = 0;
        tmp_if_expr_9 = tmp_if_expr_8;
      }

      else
        tmp_if_expr_9 = 22;
      err = tmp_if_expr_9;
      if(!(err == 0))
      {
        if(!(table->locker == ((struct Locker *)NULL)))
          table->locker->unlock(table->locker->lock);

        else
          0;
        signed int return_value_set_errno_7;
        return_value_set_errno_7=set_errno(err);
        return return_value_set_errno_7;
      }

      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_3=table->locker->unlock(table->locker->lock);
        tmp_if_expr_11 = return_value_3;
      }

      else
        tmp_if_expr_11 = 0;
      err = tmp_if_expr_11;
      if(!(err == 0))
      {
        return_value_set_errno_10=set_errno(err);
        return return_value_set_errno_10;
      }

      else
        return ret;
    }
  }
}

// str_tr_compiled_unlocked
// file libslack/str.c line 2971
signed int str_tr_compiled_unlocked(struct String *str, struct StringTR *table)
{
  signed int return_value_set_errno_1;
  if(str == ((struct String *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    signed int return_value_do_tr_compiled_2;
    return_value_do_tr_compiled_2=do_tr_compiled((unsigned char *)str->str, &str->length, table);
    return return_value_do_tr_compiled_2;
  }
}

// str_tr_str
// file libslack/str.c line 2425
signed int str_tr_str(struct String *str, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno_1;
  if(from == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_str_tr_compile_table_2;
    return_value_str_tr_compile_table_2=str_tr_compile_table(table, from, to, option);
    if(return_value_str_tr_compile_table_2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_3;
      return_value_str_tr_compiled_3=str_tr_compiled(str, table);
      return return_value_str_tr_compiled_3;
    }
  }
}

// str_tr_str_unlocked
// file libslack/str.c line 2455
signed int str_tr_str_unlocked(struct String *str, const struct String *from, const struct String *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno_1;
  if(from == ((const struct String *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_str_tr_compile_table_unlocked_2;
    return_value_str_tr_compile_table_unlocked_2=str_tr_compile_table_unlocked(table, from, to, option);
    if(return_value_str_tr_compile_table_unlocked_2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_unlocked_3;
      return_value_str_tr_compiled_unlocked_3=str_tr_compiled_unlocked(str, table);
      return return_value_str_tr_compiled_unlocked_3;
    }
  }
}

// str_tr_unlocked
// file libslack/str.c line 2396
signed int str_tr_unlocked(struct String *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno_1;
  if(from == ((const char *)NULL) || str == ((struct String *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table_2;
    return_value_tr_compile_table_2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table_2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_str_tr_compiled_unlocked_3;
      return_value_str_tr_compiled_unlocked_3=str_tr_compiled_unlocked(str, table);
      return return_value_str_tr_compiled_unlocked_3;
    }
  }
}

// str_trim
// file libslack/str.c line 4644
struct String * str_trim(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_trim_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_trim_left
// file libslack/str.c line 4744
struct String * str_trim_left(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_trim_left_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_trim_left_unlocked
// file libslack/str.c line 4773
struct String * str_trim_left_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  struct String *return_value_str_remove_range_unlocked_3;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    s = str->str;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if(!(str->str >= s))
    {
      return_value_str_remove_range_unlocked_3=str_remove_range_unlocked(str, (signed long int)0, s - str->str);
      if(!(return_value_str_remove_range_unlocked_3 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L4;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      return str;
    }
  }
}

// str_trim_right
// file libslack/str.c line 4830
struct String * str_trim_right(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_trim_right_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_trim_right_unlocked
// file libslack/str.c line 4859
struct String * str_trim_right_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  struct String *return_value_str_remove_range_unlocked_4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    s = (str->str + (signed long int)str->length) - (signed long int)1;
    do
    {
      if(!(str->str >= s))
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        tmp_if_expr_3 = ((signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)s[(signed long int)-1]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      s = s - 1l;
    }
    while((_Bool)1);
    const unsigned short int **return_value___ctype_b_loc_5;
    return_value___ctype_b_loc_5=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*s]) == 0))
    {
      return_value_str_remove_range_unlocked_4=str_remove_range_unlocked(str, s - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(s - str->str)));
      if(!(return_value_str_remove_range_unlocked_4 == ((struct String *)NULL)))
        goto __CPROVER_DUMP_L6;

      return (struct String *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return str;
    }
  }
}

// str_trim_unlocked
// file libslack/str.c line 4673
struct String * str_trim_unlocked(struct String *str)
{
  char *s;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    s = str->str;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if(!(str->str >= s))
    {
      struct String *return_value_str_remove_range_unlocked_3;
      return_value_str_remove_range_unlocked_3=str_remove_range_unlocked(str, (signed long int)0, s - str->str);
      if(return_value_str_remove_range_unlocked_3 == ((struct String *)NULL))
        return (struct String *)(void *)0;

    }

    s = (str->str + (signed long int)str->length) - (signed long int)1;
    do
    {
      if(!(str->str >= s))
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        tmp_if_expr_5 = ((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)s[(signed long int)-1]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(!tmp_if_expr_5)
        break;

      s = s - 1l;
    }
    while((_Bool)1);
    const unsigned short int **return_value___ctype_b_loc_7;
    return_value___ctype_b_loc_7=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)*s]) == 0))
    {
      struct String *return_value_str_remove_range_unlocked_6;
      return_value_str_remove_range_unlocked_6=str_remove_range_unlocked(str, s - str->str, (signed long int)((str->length - (unsigned long int)1) - (unsigned long int)(s - str->str)));
      if(return_value_str_remove_range_unlocked_6 == ((struct String *)NULL))
        return (struct String *)(void *)0;

    }

    return str;
  }
}

// str_uc
// file libslack/str.c line 5906
struct String * str_uc(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_uc_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_uc_unlocked
// file libslack/str.c line 5935
struct String * str_uc_unlocked(struct String *str)
{
  unsigned long int i;
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= str->length + 18446744073709551615ul); i = i + 1ul)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)str->str[(signed long int)i]);
      tmp_statement_expression_2 = __res;
      str->str[(signed long int)i] = (char)tmp_statement_expression_2;
    }
    return str;
  }
}

// str_ucfirst
// file libslack/str.c line 5983
struct String * str_ucfirst(struct String *str)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_ucfirst_unlocked(str);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_ucfirst_unlocked
// file libslack/str.c line 6012
struct String * str_ucfirst_unlocked(struct String *str)
{
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(str->length >= 2ul)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)*str->str);
      tmp_statement_expression_2 = __res;
      *str->str = (char)tmp_statement_expression_2;
    }

    return str;
  }
}

// str_unlock
// file libslack/str.c line 971
signed int str_unlock(const struct String *str)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->unlock(str->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// str_unquote
// file libslack/str.c line 5182
struct String * str_unquote(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_unquote_with_locker_1;
  return_value_str_unquote_with_locker_1=str_unquote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_unquote_with_locker_1;
}

// str_unquote_unlocked
// file libslack/str.c line 5197
struct String * str_unquote_unlocked(const struct String *str, const char *quotable, char quote_char)
{
  struct String *return_value_str_unquote_with_locker_unlocked_1;
  return_value_str_unquote_with_locker_unlocked_1=str_unquote_with_locker_unlocked((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_str_unquote_with_locker_unlocked_1;
}

// str_unquote_with_locker
// file libslack/str.c line 5213
struct String * str_unquote_with_locker(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull_1;
  char *return_value___builtin_strchr_3;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_copy_with_locker(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          if(!(ret->str[(signed long int)(1 + i)] == 0))
          {
            return_value___builtin_strchr_3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
            if(!(return_value___builtin_strchr_3 == ((char *)NULL)))
            {
              struct String *return_value_str_remove_2;
              return_value_str_remove_2=str_remove(ret, (signed long int)i);
              if(return_value_str_remove_2 == ((struct String *)NULL))
              {
                str_release(ret);
                return (struct String *)(void *)0;
              }

            }

          }

        }

      return ret;
    }
  }
}

// str_unquote_with_locker_unlocked
// file libslack/str.c line 5250
struct String * str_unquote_with_locker_unlocked(struct Locker *locker, const struct String *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull_1;
  char *return_value___builtin_strchr_3;
  if(quotable == ((const char *)NULL) || str == ((const struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_copy_with_locker_unlocked(locker, str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          if(!(ret->str[(signed long int)(1 + i)] == 0))
          {
            return_value___builtin_strchr_3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
            if(!(return_value___builtin_strchr_3 == ((char *)NULL)))
            {
              struct String *return_value_str_remove_2;
              return_value_str_remove_2=str_remove(ret, (signed long int)i);
              if(return_value_str_remove_2 == ((struct String *)NULL))
              {
                str_release(ret);
                return (struct String *)(void *)0;
              }

            }

          }

        }

      return ret;
    }
  }
}

// str_vappend
// file libslack/str.c line 1579
struct String * str_vappend(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_1;
  return_value_str_vinsert_1=str_vinsert(str, (signed long int)-1, format, args);
  return return_value_str_vinsert_1;
}

// str_vappend_unlocked
// file libslack/str.c line 1594
struct String * str_vappend_unlocked(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_unlocked_1;
  return_value_str_vinsert_unlocked_1=str_vinsert_unlocked(str, (signed long int)-1, format, args);
  return return_value_str_vinsert_unlocked_1;
}

// str_vcreate
// file libslack/str.c line 573
struct String * str_vcreate(const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized_1;
  return_value_str_vcreate_with_locker_sized_1=str_vcreate_with_locker_sized((struct Locker *)(void *)0, MIN_STRING_SIZE, format, args);
  return return_value_str_vcreate_with_locker_sized_1;
}

// str_vcreate_sized
// file libslack/str.c line 651
struct String * str_vcreate_sized(unsigned long int size, const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized_1;
  return_value_str_vcreate_with_locker_sized_1=str_vcreate_with_locker_sized((struct Locker *)(void *)0, size, format, args);
  return return_value_str_vcreate_with_locker_sized_1;
}

// str_vcreate_with_locker
// file libslack/str.c line 589
struct String * str_vcreate_with_locker(struct Locker *locker, const char *format, void **args)
{
  struct String *return_value_str_vcreate_with_locker_sized_1;
  return_value_str_vcreate_with_locker_sized_1=str_vcreate_with_locker_sized(locker, MIN_STRING_SIZE, format, args);
  return return_value_str_vcreate_with_locker_sized_1;
}

// str_vcreate_with_locker_sized
// file libslack/str.c line 671
struct String * str_vcreate_with_locker_sized(struct Locker *locker, unsigned long int size, const char *format, void **args)
{
  struct String *str;
  char *buf = (char *)(void *)0;
  signed long int length;
  unsigned int bit;
  void **args_copy;
  bit = (unsigned int)1;
  for( ; !(bit == 0u); bit = bit << 1)
    if((unsigned long int)bit >= size)
    {
      size = (unsigned long int)bit;
      break;
    }

  void *return_value_set_errnull_1;
  if(bit == 0u)
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(format == ((const char *)NULL))
      format = "";

    do
    {
      void *return_value_mem_resize_fn_2;
      return_value_mem_resize_fn_2=mem_resize_fn((void **)&buf, size * sizeof(char) /*1ul*/ );
      if(return_value_mem_resize_fn_2 == NULL)
      {
        free((void *)buf);
        return (struct String *)(void *)0;
      }

      args_copy = (void **)args;
      signed int return_value_vsnprintf_3;
      return_value_vsnprintf_3=vsnprintf(buf, size, format, args_copy);
      length = (signed long int)return_value_vsnprintf_3;
      args_copy = ((void **)NULL);
      if(!(length == -1l) && !((unsigned long int)length >= size))
        break;

      size = size << 1;
    }
    while((_Bool)1);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct String) /*32ul*/ );
    str = (struct String *)return_value_malloc_4;
    if(str == ((struct String *)NULL))
    {
      free((void *)buf);
      return (struct String *)(void *)0;
    }

    else
    {
      str->size = size;
      str->length = (unsigned long int)(length + (signed long int)1);
      str->str = buf;
      str->locker = locker;
      return str;
    }
  }
}

// str_vinsert
// file libslack/str.c line 1389
struct String * str_vinsert(struct String *str, signed long int index, const char *format, void **args)
{
  struct String *ret;
  signed int err;
  void *return_value_set_errnull_1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value;
  void *return_value_set_errnull_2;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_6;
  signed int return_value_1;
  void *return_value_set_errnull_5;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(str == ((struct String *)NULL)))
    {
      if(!(str->locker == ((struct Locker *)NULL)))
      {
        return_value=str->locker->wrlock(str->locker->lock);
        tmp_if_expr_3 = return_value;
      }

      else
        tmp_if_expr_3 = 0;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = 22;
    err = tmp_if_expr_4;
    if(!(err == 0))
    {
      return_value_set_errnull_2=set_errnull(err);
      return (struct String *)return_value_set_errnull_2;
    }

    else
    {
      ret=str_vinsert_unlocked(str, index, format, args);
      if(!(str == ((struct String *)NULL)))
      {
        if(!(str->locker == ((struct Locker *)NULL)))
        {
          return_value_1=str->locker->unlock(str->locker->lock);
          tmp_if_expr_6 = return_value_1;
        }

        else
          tmp_if_expr_6 = 0;
        tmp_if_expr_7 = tmp_if_expr_6;
      }

      else
        tmp_if_expr_7 = 22;
      err = tmp_if_expr_7;
      if(!(err == 0))
      {
        return_value_set_errnull_5=set_errnull(err);
        return (struct String *)return_value_set_errnull_5;
      }

      else
        return ret;
    }
  }
}

// str_vinsert_unlocked
// file libslack/str.c line 1418
struct String * str_vinsert_unlocked(struct String *str, signed long int index, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull_1;
  void *return_value_set_errnull_2;
  void *return_value_set_errnull_3;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l))
      index = (signed long int)(str->length + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_2=set_errnull(22);
      return (struct String *)return_value_set_errnull_2;
    }

    else
      if(!(str->length + 18446744073709551615ul >= (unsigned long int)index))
      {
        return_value_set_errnull_3=set_errnull(22);
        return (struct String *)return_value_set_errnull_3;
      }

      else
      {
        tmp=str_vcreate(format, args);
        if(tmp == ((struct String *)NULL))
          return (struct String *)(void *)0;

        else
        {
          ret=str_insert_str_unlocked(str, index, tmp);
          str_release(tmp);
          return ret;
        }
      }
  }
}

// str_vprepend
// file libslack/str.c line 1685
struct String * str_vprepend(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_1;
  return_value_str_vinsert_1=str_vinsert(str, (signed long int)0, format, args);
  return return_value_str_vinsert_1;
}

// str_vprepend_unlocked
// file libslack/str.c line 1700
struct String * str_vprepend_unlocked(struct String *str, const char *format, void **args)
{
  struct String *return_value_str_vinsert_unlocked_1;
  return_value_str_vinsert_unlocked_1=str_vinsert_unlocked(str, (signed long int)0, format, args);
  return return_value_str_vinsert_unlocked_1;
}

// str_vrepeat
// file libslack/str.c line 2253
struct String * str_vrepeat(unsigned long int count, const char *format, void **args)
{
  struct String *return_value_str_vrepeat_with_locker_1;
  return_value_str_vrepeat_with_locker_1=str_vrepeat_with_locker((struct Locker *)(void *)0, count, format, args);
  return return_value_str_vrepeat_with_locker_1;
}

// str_vrepeat_with_locker
// file libslack/str.c line 2269
struct String * str_vrepeat_with_locker(struct Locker *locker, unsigned long int count, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  signed long int length;
  unsigned long int i;
  tmp=str_vcreate(format, args);
  if(tmp == ((struct String *)NULL))
    return (struct String *)(void *)0;

  else
  {
    length=str_length(tmp);
    if(length == -1l)
      return (struct String *)(void *)0;

    else
    {
      ret=str_create_with_locker_sized(locker, (unsigned long int)length * count + (unsigned long int)1, (const char *)(void *)0);
      if(ret == ((struct String *)NULL))
      {
        str_release(tmp);
        return (struct String *)(void *)0;
      }

      else
      {
        i = (unsigned long int)0;
        for( ; !(i >= count); i = i + 1ul)
        {
          struct String *return_value_str_append_str_1;
          return_value_str_append_str_1=str_append_str(ret, tmp);
          if(return_value_str_append_str_1 == ((struct String *)NULL))
          {
            str_release(tmp);
            str_release(ret);
            return (struct String *)(void *)0;
          }

        }
        str_release(tmp);
        return ret;
      }
    }
  }
}

// str_vreplace
// file libslack/str.c line 1795
struct String * str_vreplace(struct String *str, signed long int index, signed long int range, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    tmp=str_vcreate(format, args);
    if(tmp == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      ret=str_replace_str(str, index, range, tmp);
      str_release(tmp);
      return ret;
    }
  }
}

// str_vreplace_unlocked
// file libslack/str.c line 1821
struct String * str_vreplace_unlocked(struct String *str, signed long int index, signed long int range, const char *format, void **args)
{
  struct String *tmp;
  struct String *ret;
  void *return_value_set_errnull_1;
  if(str == ((struct String *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    tmp=str_vcreate(format, args);
    if(tmp == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      ret=str_replace_str_unlocked(str, index, range, tmp);
      str_release(tmp);
      return ret;
    }
  }
}

// str_wrlock
// file libslack/str.c line 954
signed int str_wrlock(const struct String *str)
{
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(str == ((const struct String *)NULL)))
  {
    if(!(str->locker == ((struct Locker *)NULL)))
    {
      return_value=str->locker->wrlock(str->locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = 22;
  return tmp_if_expr_2;
}

// strlcat
// file libslack/str.c line 6619
unsigned long int strlcat(char *dst, const char *src, unsigned long int size)
{
  const char *s = src;
  char *d = dst;
  unsigned long int n = size;
  unsigned long int dlen = (unsigned long int)0;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if(*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = n + 1ul;
  const char *tmp_post_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    do
    {
      tmp_post_2 = s;
      s = s + 1l;
      if(*tmp_post_2 == 0)
        break;

    }
    while((_Bool)1);
    return (unsigned long int)((((signed long int)dlen + s) - src) - (signed long int)1);
  }

  else
  {
    for( ; !(*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        n = n - 1ul;
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
      }

    *d = (char)0;
    return (unsigned long int)(((signed long int)dlen + s) - src);
  }
}

// strlcpy
// file libslack/str.h line 257
unsigned long int strlcpy(char *dst, const char *src, unsigned long int size)
{
  const char *s = src;
  char *d = dst;
  unsigned long int n = size;
  char *tmp_post_1;
  const char *tmp_post_2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post_1 = d;
      d = d + 1l;
      tmp_post_2 = s;
      s = s + 1l;
      *tmp_post_1 = *tmp_post_2;
      if(*tmp_post_1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post_3;
  if(n == 0ul)
  {
    if(!(size == 0ul))
      *d = (char)0;

    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      if(*tmp_post_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// substr
// file libslack/str.c line 2048
struct String * substr(const char *str, signed long int index, signed long int range)
{
  struct String *return_value_substr_with_locker_1;
  return_value_substr_with_locker_1=substr_with_locker((struct Locker *)(void *)0, str, index, range);
  return return_value_substr_with_locker_1;
}

// substr_with_locker
// file libslack/str.c line 2065
struct String * substr_with_locker(struct Locker *locker, const char *str, signed long int index, signed long int range)
{
  struct String *ret;
  unsigned long int len = (unsigned long int)0;
  void *return_value_set_errnull_1;
  unsigned long int return_value_strlen_2;
  void *return_value_set_errnull_3;
  void *return_value_set_errnull_4;
  if(str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    if(!(index >= 0l) || !(range >= 0l))
    {
      return_value_strlen_2=strlen(str);
      len = return_value_strlen_2 + (unsigned long int)1;
    }

    if(!(index >= 0l))
      index = (signed long int)(len + (unsigned long int)index);

    if(!(index >= 0l))
    {
      return_value_set_errnull_3=set_errnull(22);
      return (struct String *)return_value_set_errnull_3;
    }

    else
    {
      if(!(range >= 0l))
        range = (signed long int)((len + (unsigned long int)range) - (unsigned long int)index);

      if(!(range >= 0l))
      {
        return_value_set_errnull_4=set_errnull(22);
        return (struct String *)return_value_set_errnull_4;
      }

      else
      {
        ret=str_create_with_locker_sized(locker, (unsigned long int)(range + (signed long int)1), (const char *)(void *)0);
        if(ret == ((struct String *)NULL))
          return (struct String *)(void *)0;

        else
        {
          memcpy((void *)ret->str, (const void *)(str + index), (unsigned long int)range);
          ret->length = (unsigned long int)(range + (signed long int)1);
          ret->str[(signed long int)(ret->length - (unsigned long int)1)] = (char)0;
          return ret;
        }
      }
    }
  }
}

// swap
// file libslack/hsort.c line 156
static void swap(char *p1, char *p2, unsigned long int n)
{
  char ctmp;
  unsigned long int tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    ctmp = *p1;
    tmp_post_2 = p1;
    p1 = p1 + 1l;
    *tmp_post_2 = *p2;
    tmp_post_3 = p2;
    p2 = p2 + 1l;
    *tmp_post_3 = ctmp;
  }
  while((_Bool)1);
}

// syslog_facility_str
// file libslack/msg.c line 1395
const char * syslog_facility_str(signed int spec)
{
  const char *return_value_syslog_lookup_str_1;
  return_value_syslog_lookup_str_1=syslog_lookup_str(syslog_facility_map, spec, 0x03f8);
  return return_value_syslog_lookup_str_1;
}

// syslog_lookup
// file libslack/msg.c line 1323
static signed int syslog_lookup(const struct syslog_map_t *map, const char *name)
{
  signed int i = 0;
  signed int tmp_statement_expression_1;
  for( ; !((map + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(name, (map + (signed long int)i)->name);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      break;

  }
  return (map + (signed long int)i)->val;
}

// syslog_lookup_facility
// file libslack/msg.c line 1364
signed int syslog_lookup_facility(const char *facility)
{
  signed int return_value_syslog_lookup_1;
  return_value_syslog_lookup_1=syslog_lookup(syslog_facility_map, facility);
  return return_value_syslog_lookup_1;
}

// syslog_lookup_priority
// file libslack/msg.c line 1379
signed int syslog_lookup_priority(const char *priority)
{
  signed int return_value_syslog_lookup_1;
  return_value_syslog_lookup_1=syslog_lookup(syslog_priority_map, priority);
  return return_value_syslog_lookup_1;
}

// syslog_lookup_str
// file libslack/msg.c line 1343
static const char * syslog_lookup_str(const struct syslog_map_t *map, signed int spec, signed int mask)
{
  signed int i = 0;
  for( ; !((map + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    if((mask & spec) == (map + (signed long int)i)->val)
      break;

  return (map + (signed long int)i)->name;
}

// syslog_parse
// file libslack/msg.c line 1451
signed int syslog_parse(const char *spec, signed int *facility, signed int *priority)
{
  char fac[64l];
  char *pri;
  signed int f;
  signed int p;
  signed int return_value_set_errno_1;
  signed int return_value_set_errno_2;
  char *tmp_post_4;
  signed int return_value_set_errno_5;
  signed int return_value_set_errno_6;
  if(spec == ((const char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    strlcpy(fac, spec, (unsigned long int)64);
    char *return_value___builtin_strchr_3;
    return_value___builtin_strchr_3=__builtin_strchr(fac, 46);
    pri = return_value___builtin_strchr_3;
    if(pri == ((char *)NULL))
    {
      return_value_set_errno_2=set_errno(22);
      return return_value_set_errno_2;
    }

    else
    {
      tmp_post_4 = pri;
      pri = pri + 1l;
      *tmp_post_4 = (char)0;
      f=syslog_lookup_facility(fac);
      if(f == -1)
      {
        return_value_set_errno_5=set_errno(22);
        return return_value_set_errno_5;
      }

      else
      {
        p=syslog_lookup_priority(pri);
        if(p == -1)
        {
          return_value_set_errno_6=set_errno(22);
          return return_value_set_errno_6;
        }

        else
        {
          if(!(facility == ((signed int *)NULL)))
            *facility = f;

          if(!(priority == ((signed int *)NULL)))
            *priority = p;

          return 0;
        }
      }
    }
  }
}

// syslog_priority_str
// file libslack/msg.c line 1411
const char * syslog_priority_str(signed int spec)
{
  const char *return_value_syslog_lookup_str_1;
  return_value_syslog_lookup_str_1=syslog_lookup_str(syslog_priority_map, spec, 0x07);
  return return_value_syslog_lookup_str_1;
}

// test_action
// file libslack/map.c line 2414
static void test_action(char *key, char *value, char *cat)
{
  unsigned long int len;
  len=strlen(cat);
  snprintf(cat + (signed long int)len, (unsigned long int)8192, "%s%s=%s", len != 0ul ? ", " : "", key, value);
}

// test_hash
// file libslack/map.c line 2345
static void test_hash(void)
{
  struct _IO_FILE *words;
  words=fopen("/usr/dict/words", "r");
  char word[8192l];
  struct Map *map;
  unsigned long int c;
  unsigned long int min = (unsigned long int)0xffffffff;
  unsigned long int max = (unsigned long int)0x00000000;
  signed int sum = 0;
  if(words == ((struct _IO_FILE *)NULL))
  {
    printf("Failed to open /usr/dict/words\n");
    exit(1);
  }

  map=map_create(free);
  if(map == ((struct Map *)NULL))
  {
    printf("Failed to create map\n");
    exit(1);
  }

  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(word, 8192, words);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    char *eow;
    eow=strchr(word, 10);
    if(!(eow == ((char *)NULL)))
      *eow = (char)0;

    char *return_value_mem_strdup_2;
    return_value_mem_strdup_2=mem_strdup(word);
    map_add(map, (const void *)word, (void *)return_value_mem_strdup_2);
  }
  while((_Bool)1);
  fclose(words);
  printf("%d entries into %d buckets:\n\n", (signed int)map->items, (signed int)map->size);
  c = (unsigned long int)0;
  for( ; !(c >= map->size); c = c + 1ul)
  {
    unsigned long int length;
    if(!(map->chain[(signed long int)c] == ((struct List *)NULL)))
    {
      signed long int return_value_list_length_3;
      return_value_list_length_3=list_length(map->chain[(signed long int)c]);
      length = (unsigned long int)return_value_list_length_3;
      if(length == 18446744073709551615ul)
        printf(" length[%d] == -1\n", (signed int)c);

      else
      {
        if(!(max >= length))
          max = length;

        if(!(length >= min))
          min = length;

        sum = sum + (signed int)length;
      }
    }

  }
  printf("avg = %g\n", (double)sum / (double)map->size);
  printf("min = %d\n", (signed int)min);
  printf("max = %d\n", (signed int)max);
  map_histogram("dict", map);
  map_release(map);
  exit(0);
}

// timeout
// file libslack/agent.c line 1909
static signed int timeout(struct Agent *agent)
{
  signed int i;
  if(agent->timers == 0ul)
    return -1;

  else
  {
    i = (signed int)agent->timewheel->jiffy;
    for( ; !(i >= 100); i = i + 1)
      if(!(agent->timewheel->jiffies[(signed long int)i] == ((struct action_t *)NULL)))
        break;

    return (signed int)(((unsigned long int)i - agent->timewheel->jiffy) * (unsigned long int)10);
  }
}

// timeval_add
// file libslack/agent.c line 1624
static void timeval_add(struct timeval *absolute, struct timeval *relative, struct timeval *result)
{
  result->tv_sec = absolute->tv_sec + relative->tv_sec;
  result->tv_usec = absolute->tv_usec + relative->tv_usec;
  if(result->tv_usec >= 1000000l)
  {
    result->tv_sec = result->tv_sec + 1l;
    result->tv_usec = result->tv_usec - (signed long int)1000000;
  }

}

// timeval_diff
// file libslack/agent.c line 1614
static void timeval_diff(struct timeval *start, struct timeval *end, struct timeval *diff)
{
  diff->tv_sec = end->tv_sec - start->tv_sec;
  if(!(end->tv_usec >= start->tv_usec))
  {
    diff->tv_usec = ((signed long int)1000000 + end->tv_usec) - start->tv_usec;
    diff->tv_sec = diff->tv_sec - 1l;
  }

  else
    diff->tv_usec = end->tv_usec - start->tv_usec;
}

// timeval_set
// file libslack/agent.c line 1633
static void timeval_set(struct timeval *tv, signed long int tv_sec, signed long int tv_usec)
{
  tv->tv_sec = tv_sec;
  tv->tv_usec = tv_usec;
}

// timewheel_create
// file libslack/agent.c line 250
static struct timewheel_t * timewheel_create()
{
  struct timewheel_t *timewheel;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct timewheel_t) /*2088ul*/ );
  timewheel = (struct timewheel_t *)return_value_malloc_1;
  if(timewheel == ((struct timewheel_t *)NULL))
    return (struct timewheel_t *)(void *)0;

  else
  {
    memset((void *)timewheel, 0, sizeof(struct timewheel_t) /*2088ul*/ );
    signed int return_value_gettimeofday_2;
    return_value_gettimeofday_2=gettimeofday(timewheel->now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday_2 == -1)
      return (struct timewheel_t *)(void *)0;

    else
      return timewheel;
  }
}

// timewheel_release
// file libslack/agent.c line 288
static void timewheel_release(struct timewheel_t *timewheel)
{
  unsigned long int i;
  if(!(timewheel == ((struct timewheel_t *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= 10ul); i = i + 1ul)
      release_actions(timewheel->days[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 24ul); i = i + 1ul)
      release_actions(timewheel->hours[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 60ul); i = i + 1ul)
      release_actions(timewheel->minutes[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 60ul); i = i + 1ul)
      release_actions(timewheel->seconds[(signed long int)i]);
    i = (unsigned long int)0;
    for( ; !(i >= 100ul); i = i + 1ul)
      release_actions(timewheel->jiffies[(signed long int)i]);
    free((void *)timewheel);
  }

}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr_2;
  const signed int **return_value___ctype_tolower_loc_1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc_1=__ctype_tolower_loc();
    tmp_if_expr_2 = (*return_value___ctype_tolower_loc_1)[(signed long int)__c];
  }

  else
    tmp_if_expr_2 = __c;
  return tmp_if_expr_2;
}

// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c)
{
  signed int tmp_if_expr_2;
  const signed int **return_value___ctype_toupper_loc_1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_toupper_loc_1=__ctype_toupper_loc();
    tmp_if_expr_2 = (*return_value___ctype_toupper_loc_1)[(signed long int)__c];
  }

  else
    tmp_if_expr_2 = __c;
  return tmp_if_expr_2;
}

// tr
// file libslack/str.c line 2480
signed int tr(char *str, const char *from, const char *to, signed int option)
{
  struct StringTR table[1l];
  signed int return_value_set_errno_1;
  if(from == ((const char *)NULL) || str == ((char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    table[0l].locker = (struct Locker *)(void *)0;
    struct StringTR *return_value_tr_compile_table_2;
    return_value_tr_compile_table_2=tr_compile_table(table, from, to, option);
    if(return_value_tr_compile_table_2 == ((struct StringTR *)NULL))
      return -1;

    else
    {
      signed int return_value_tr_compiled_3;
      return_value_tr_compiled_3=tr_compiled(str, table);
      return return_value_tr_compiled_3;
    }
  }
}

// tr_compile
// file libslack/str.c line 2509
struct StringTR * tr_compile(const char *from, const char *to, signed int option)
{
  struct StringTR *return_value_tr_compile_with_locker_1;
  return_value_tr_compile_with_locker_1=tr_compile_with_locker((struct Locker *)(void *)0, from, to, option);
  return return_value_tr_compile_with_locker_1;
}

// tr_compile_table
// file libslack/str.c line 2793
static struct StringTR * tr_compile_table(struct StringTR *table, const char *from, const char *to, signed int option)
{
  struct StringTR *return_value_do_tr_compile_table_1;
  return_value_do_tr_compile_table_1=do_tr_compile_table(table, from, (signed long int)-1, to, (signed long int)-1, option);
  return return_value_do_tr_compile_table_1;
}

// tr_compile_with_locker
// file libslack/str.c line 2525
struct StringTR * tr_compile_with_locker(struct Locker *locker, const char *from, const char *to, signed int option)
{
  struct StringTR *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct StringTR) /*528ul*/ );
  ret = (struct StringTR *)return_value_malloc_1;
  if(ret == ((struct StringTR *)NULL))
    return (struct StringTR *)(void *)0;

  else
  {
    ret->locker = locker;
    struct StringTR *return_value_tr_compile_table_2;
    return_value_tr_compile_table_2=tr_compile_table(ret, from, to, option);
    return return_value_tr_compile_table_2;
  }
}

// tr_compiled
// file libslack/str.c line 2989
signed int tr_compiled(char *str, struct StringTR *table)
{
  signed int ret;
  signed int err;
  signed int return_value_set_errno_1;
  signed int tmp_if_expr_3;
  signed int return_value;
  signed int return_value_set_errno_2;
  signed int tmp_if_expr_5;
  signed int return_value_1;
  signed int return_value_set_errno_4;
  if(str == ((char *)NULL) || table == ((struct StringTR *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    if(!(table->locker == ((struct Locker *)NULL)))
    {
      return_value=table->locker->rdlock(table->locker->lock);
      tmp_if_expr_3 = return_value;
    }

    else
      tmp_if_expr_3 = 0;
    err = tmp_if_expr_3;
    if(!(err == 0))
    {
      return_value_set_errno_2=set_errno(err);
      return return_value_set_errno_2;
    }

    else
    {
      ret=do_tr_compiled((unsigned char *)str, (unsigned long int *)(void *)0, table);
      if(!(table->locker == ((struct Locker *)NULL)))
      {
        return_value_1=table->locker->unlock(table->locker->lock);
        tmp_if_expr_5 = return_value_1;
      }

      else
        tmp_if_expr_5 = 0;
      err = tmp_if_expr_5;
      if(!(err == 0))
      {
        return_value_set_errno_4=set_errno(err);
        return return_value_set_errno_4;
      }

      else
        return ret;
    }
  }
}

// tr_destroy
// file libslack/str.c line 2655
void * tr_destroy(struct StringTR **table)
{
  if(!(table == ((struct StringTR **)NULL)))
  {
    if(!(*table == ((struct StringTR *)NULL)))
    {
      tr_release(*table);
      *table = (struct StringTR *)(void *)0;
    }

  }

  return (void *)0;
}

// tr_release
// file libslack/str.c line 2628
void tr_release(struct StringTR *table)
{
  struct Locker *tr_release__1__locker;
  signed int tmp_if_expr_1;
  signed int return_value;
  if(!(table == ((struct StringTR *)NULL)))
  {
    tr_release__1__locker = table->locker;
    if(!(tr_release__1__locker == ((struct Locker *)NULL)))
    {
      return_value=tr_release__1__locker->wrlock(tr_release__1__locker->lock);
      tmp_if_expr_1 = return_value;
    }

    else
      tmp_if_expr_1 = 0;
    if(tmp_if_expr_1 == 0)
    {
      free((void *)table);
      if(!(tr_release__1__locker == ((struct Locker *)NULL)))
        tr_release__1__locker->unlock(tr_release__1__locker->lock);

      else
        0;
    }

  }

}

// translate
// file libslack/agent.c line 2065
static signed int translate(signed int revents)
{
  signed int ret = 0;
  if(!((0x001 & revents) == 0))
    ret = ret | 4;

  if(!((0x002 & revents) == 0))
    ret = ret | 1;

  if(!((0x004 & revents) == 0))
    ret = ret | 2;

  return ret;
}

// trim
// file libslack/str.c line 4711
char * trim(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    s = str;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    len=strlen(s);
    if(!(str >= s))
      memmove((void *)str, (const void *)s, len + (unsigned long int)1);

    s = str + (signed long int)len;
    do
    {
      if(!(str >= s))
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        s = s - 1l;
        tmp_if_expr_4 = ((signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      *s = (char)0;
    }
    while((_Bool)1);
    return str;
  }
}

// trim_left
// file libslack/str.c line 4800
char * trim_left(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    s = str;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    len=strlen(s);
    if(!(str >= s))
      memmove((void *)str, (const void *)s, len + (unsigned long int)1);

    return str;
  }
}

// trim_right
// file libslack/str.c line 4886
char * trim_right(char *str)
{
  char *s;
  unsigned long int len;
  void *return_value_set_errnull_1;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    len=strlen(str);
    s = str + (signed long int)len;
    do
    {
      if(!(str >= s))
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        s = s - 1l;
        tmp_if_expr_3 = ((signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*s] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      *s = (char)0;
    }
    while((_Bool)1);
    return str;
  }
}

// uc
// file libslack/str.c line 5959
char * uc(char *str)
{
  char *s;
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    s = str;
    for( ; !(*s == 0); s = s + 1l)
    {
      signed int __res;
      __res=toupper((signed int)(unsigned char)*s);
      tmp_statement_expression_2 = __res;
      *s = (char)tmp_statement_expression_2;
    }
    return str;
  }
}

// ucfirst
// file libslack/str.c line 6034
char * ucfirst(char *str)
{
  void *return_value_set_errnull_1;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_toupper_loc_3;
  const signed int **return_value___ctype_toupper_loc_5;
  if(str == ((char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (char *)return_value_set_errnull_1;
  }

  else
  {
    signed int __res;
    __res=toupper((signed int)(unsigned char)*str);
    tmp_statement_expression_2 = __res;
    *str = (char)tmp_statement_expression_2;
    return str;
  }
}

// uid2gid
// file libslack/pseudo.c line 196
static signed int uid2gid(unsigned int uid)
{
  struct _IO_FILE *passwd;
  passwd=fopen("/etc/passwd", "r");
  char line[8192l];
  char *ptr;
  signed int ret = -1;
  char *return_value_fgets_1;
  char *return_value___builtin_strchr_4;
  signed int return_value_atoi_3;
  char *return_value___builtin_strchr_2;
  do
  {
    return_value_fgets_1=fgets(line, 8192, passwd);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    char *return_value___builtin_strchr_5;
    return_value___builtin_strchr_5=__builtin_strchr(line, 58);
    ptr = return_value___builtin_strchr_5;
    if(!(ptr == ((char *)NULL)))
    {
      return_value___builtin_strchr_4=__builtin_strchr(ptr + (signed long int)1, 58);
      ptr = return_value___builtin_strchr_4;
      if(!(ptr == ((char *)NULL)))
      {
        return_value_atoi_3=atoi(ptr + (signed long int)1);
        if(return_value_atoi_3 == (signed int)uid)
        {
          return_value___builtin_strchr_2=__builtin_strchr(ptr + (signed long int)1, 58);
          ptr = return_value___builtin_strchr_2;
          if(!(ptr == ((char *)NULL)))
          {
            ret=atoi(ptr + (signed long int)1);
            break;
          }

        }

      }

    }

  }
  while((_Bool)1);
  fclose(passwd);
  return ret;
}

// unpack
// file libslack/net.c line 3346
signed long int unpack(void *buf, unsigned long int size, const char *format, ...)
{
  void **args;
  signed int rc;
  args = (void **)&format;
  signed long int return_value_vunpack_1;
  return_value_vunpack_1=vunpack(buf, size, format, args);
  rc = (signed int)return_value_vunpack_1;
  args = ((void **)NULL);
  return (signed long int)rc;
}

// unquote
// file libslack/str.c line 5286
struct String * unquote(const char *str, const char *quotable, char quote_char)
{
  struct String *return_value_unquote_with_locker_1;
  return_value_unquote_with_locker_1=unquote_with_locker((struct Locker *)(void *)0, str, quotable, quote_char);
  return return_value_unquote_with_locker_1;
}

// unquote_equals
// file libslack/prop.c line 258
static struct String * unquote_equals(const char *src)
{
  struct String *return_value_decode_1;
  return_value_decode_1=decode(src, eq, eq, (char)92, 0);
  return return_value_decode_1;
}

// unquote_special
// file libslack/prop.c line 230
static struct String * unquote_special(const char *src)
{
  struct String *return_value_decode_1;
  return_value_decode_1=decode(src, special_char, special_code, (char)92, 1);
  return return_value_decode_1;
}

// unquote_with_locker
// file libslack/str.c line 5302
struct String * unquote_with_locker(struct Locker *locker, const char *str, const char *quotable, char quote_char)
{
  struct String *ret;
  signed int i;
  void *return_value_set_errnull_1;
  char *return_value___builtin_strchr_3;
  if(quotable == ((const char *)NULL) || str == ((const char *)NULL))
  {
    return_value_set_errnull_1=set_errnull(22);
    return (struct String *)return_value_set_errnull_1;
  }

  else
  {
    ret=str_create_with_locker(locker, "%s", str);
    if(ret == ((struct String *)NULL))
      return (struct String *)(void *)0;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ret->length + -2); i = i + 1)
        if(ret->str[(signed long int)i] == quote_char)
        {
          return_value___builtin_strchr_3=__builtin_strchr(quotable, (signed int)ret->str[(signed long int)(i + 1)]);
          if(!(return_value___builtin_strchr_3 == ((char *)NULL)))
          {
            struct String *return_value_str_remove_2;
            return_value_str_remove_2=str_remove(ret, (signed long int)i);
            if(return_value_str_remove_2 == ((struct String *)NULL))
            {
              str_release(ret);
              return (struct String *)(void *)0;
            }

          }

        }

      return ret;
    }
  }
}

// update
// file libslack/agent.c line 1976
static signed int update(struct Agent *agent)
{
  struct timeval now[1l];
  struct timeval delta[1l];
  signed int check = 1;
  signed int tmp_if_expr_2;
  while(!(check == 0))
  {
    check = 0;
    signed int return_value_gettimeofday_1;
    return_value_gettimeofday_1=gettimeofday(now, (struct timezone *)(void *)0);
    if(return_value_gettimeofday_1 == -1)
      return -1;

    if(now[0l].tv_sec == agent->timewheel->now[0l].tv_sec)
      tmp_if_expr_2 = (signed int)(now[0l].tv_usec < agent->timewheel->now[0l].tv_usec);

    else
      tmp_if_expr_2 = (signed int)(now[0l].tv_sec < agent->timewheel->now[0l].tv_sec);
    if(!(tmp_if_expr_2 == 0))
      agent->timewheel->now[0l] = now[0l];

    timeval_diff(agent->timewheel->now, now, delta);
    delta[0l].tv_usec = delta[0l].tv_usec / (signed long int)10000;
    agent->timewheel->now[0l] = now[0l];
    while((_Bool)1)
    {
      if(delta[0l].tv_sec == 0l)
      {
        if(delta[0l].tv_usec == 0l)
          goto __CPROVER_DUMP_L12;

      }

      if(delta[0l].tv_usec == 0l)
      {
        delta[0l].tv_sec = delta[0l].tv_sec - 1l;
        delta[0l].tv_usec = (signed long int)100;
      }

      delta[0l].tv_usec = delta[0l].tv_usec - 1l;
      agent->timewheel->jiffy = agent->timewheel->jiffy + 1ul;
      if(agent->timewheel->jiffy == 100ul)
        next_second(agent);

      if(!(agent->timewheel->jiffies[(signed long int)agent->timewheel->jiffy] == ((struct action_t *)NULL)))
      {
        check = check + 1;
        signed int return_value_expire_3;
        return_value_expire_3=expire(agent);
        if(return_value_expire_3 == -1)
          return -1;

      }

    }

  __CPROVER_DUMP_L12:
    ;
  }
  return 0;
}

// user_home
// file libslack/prop.c line 272
static char * user_home(void)
{
  struct passwd *pwent;
  char *home = (char *)(void *)0;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  char *tmp_if_expr_5;
  char *return_value_mem_strdup_4;
  if(!(g_link3.home == ((char *)NULL)))
    return g_link3.home;

  else
  {
    unsigned int return_value_getuid_1;
    return_value_getuid_1=getuid();
    pwent=getpwuid(return_value_getuid_1);
    if(!(pwent == ((struct passwd *)NULL)))
      home = pwent->pw_dir;

    if(!(home == ((char *)NULL)))
    {
      return_value_strlen_2=strlen(home);
      tmp_if_expr_3 = return_value_strlen_2 != 0ul ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_mem_strdup_4=mem_strdup(home);
      tmp_if_expr_5 = return_value_mem_strdup_4;
    }

    else
      tmp_if_expr_5 = (char *)(void *)0;
    g_link3.home = tmp_if_expr_5;
    return g_link3.home;
  }
}

// valert
// file libslack/err.c line 475
void valert(signed int priority, const char *format, void **args)
{
  struct Msg *valert__1__alert;
  char mesg[8192l];
  signed int err;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  valert__1__alert=prog_alert();
  err=msg_wrlock(valert__1__alert);
  const char *return_value_prog_name_1;
  if(!(err == 0))
    set_errno(err);

  else
  {
    msg_syslog_set_priority_unlocked(valert__1__alert, priority);
    const char *return_value_prog_name_2;
    return_value_prog_name_2=prog_name();
    if(!(return_value_prog_name_2 == ((const char *)NULL)))
    {
      return_value_prog_name_1=prog_name();
      msg_out_unlocked(valert__1__alert, "%s: %s\n", return_value_prog_name_1, (const void *)mesg);
    }

    else
      msg_out_unlocked(valert__1__alert, "%s\n", (const void *)mesg);
    err=msg_unlock(valert__1__alert);
    if(!(err == 0))
      set_errno(err);

  }
}

// valertsys
// file libslack/err.c line 696
void valertsys(signed int priority, const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errno_saved = *return_value___errno_location_1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(errno_saved);
  alert(priority, "%s: %s", (const void *)mesg, return_value_strerror_2);
}

// vasprintf
// file libslack/str.c line 6852
signed int vasprintf(char **str, const char *format, void **args)
{
  struct String *tmp;
  signed int len;
  tmp=str_vcreate(format, args);
  if(tmp == ((struct String *)NULL))
  {
    *str = (char *)(void *)0;
    return -1;
  }

  else
  {
    if(!(str == ((char **)NULL)))
      *str=cstr(tmp);

    signed long int return_value_str_length_1;
    return_value_str_length_1=str_length(tmp);
    len = (signed int)return_value_str_length_1;
    free((void *)tmp);
    return len;
  }
}

// vdebugf
// file libslack/err.c line 285
void vdebugf(unsigned long int level, const char *format, void **args)
{
  signed int return_value_debug_level_match_5;
  return_value_debug_level_match_5=debug_level_match(level);
  struct Msg *return_value_prog_dbg_1;
  const char *return_value_prog_name_2;
  struct Msg *return_value_prog_dbg_3;
  if(!(return_value_debug_level_match_5 == 0))
  {
    char mesg[8192l];
    char prefix[32l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    if(!((4294967040ul & level) == 0ul))
      snprintf(prefix, (unsigned long int)32, " [%d]", (signed int)((level & (unsigned long int)0xffffff00) >> 8));

    const char *return_value_prog_name_4;
    return_value_prog_name_4=prog_name();
    if(!(return_value_prog_name_4 == ((const char *)NULL)))
    {
      return_value_prog_dbg_1=prog_dbg();
      return_value_prog_name_2=prog_name();
      msg_out(return_value_prog_dbg_1, "%s: debug:%s%*s%s\n", return_value_prog_name_2, (const void *)prefix, level & (unsigned long int)0xff, (const void *)"", (const void *)mesg);
    }

    else
    {
      return_value_prog_dbg_3=prog_dbg();
      msg_out(return_value_prog_dbg_3, "debug:%s%*s%s\n", (const void *)prefix, level & (unsigned long int)0xff, (const void *)"", (const void *)mesg);
    }
  }

}

// vdebugsysf
// file libslack/err.c line 536
void vdebugsysf(unsigned long int level, const char *format, void **args)
{
  signed int return_value_debug_level_match_3;
  return_value_debug_level_match_3=debug_level_match(level);
  if(!(return_value_debug_level_match_3 == 0))
  {
    char mesg[8192l];
    signed int errno_saved;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    errno_saved = *return_value___errno_location_1;
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(errno_saved);
    debugf(level, "%s: %s", (const void *)mesg, return_value_strerror_2);
  }

}

// vdump
// file libslack/err.c line 430
void vdump(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  error("dump: %s", (const void *)mesg);
  abort();
}

// vdumpsys
// file libslack/err.c line 657
void vdumpsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errno_saved = *return_value___errno_location_1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(errno_saved);
  dump("%s: %s", (const void *)mesg, return_value_strerror_2);
}

// verbose
// file libslack/err.c line 190
void verbose(unsigned long int level, const char *format, ...)
{
  unsigned long int return_value_prog_verbosity_level_1;
  return_value_prog_verbosity_level_1=prog_verbosity_level();
  if(return_value_prog_verbosity_level_1 >= level)
  {
    void **args = (void **)&format;
    vverbose(level, format, args);
    args = ((void **)NULL);
  }

}

// verror
// file libslack/err.c line 337
signed int verror(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  const char *return_value_prog_name_4;
  return_value_prog_name_4=prog_name();
  struct Msg *return_value_prog_err_1;
  const char *return_value_prog_name_2;
  struct Msg *return_value_prog_err_3;
  if(!(return_value_prog_name_4 == ((const char *)NULL)))
  {
    return_value_prog_err_1=prog_err();
    return_value_prog_name_2=prog_name();
    msg_out(return_value_prog_err_1, "%s: %s\n", return_value_prog_name_2, (const void *)mesg);
  }

  else
  {
    return_value_prog_err_3=prog_err();
    msg_out(return_value_prog_err_3, "%s\n", (const void *)mesg);
  }
  return -1;
}

// verrorsys
// file libslack/err.c line 579
signed int verrorsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errno_saved = *return_value___errno_location_1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(errno_saved);
  signed int return_value_error_3;
  return_value_error_3=error("%s: %s", (const void *)mesg, return_value_strerror_2);
  return return_value_error_3;
}

// vfatal
// file libslack/err.c line 386
void vfatal(const char *format, void **args)
{
  char mesg[8192l];
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  error("fatal: %s", (const void *)mesg);
  exit(1);
}

// vfatalsys
// file libslack/err.c line 618
void vfatalsys(const char *format, void **args)
{
  char mesg[8192l];
  signed int errno_saved;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errno_saved = *return_value___errno_location_1;
  vsnprintf(mesg, (unsigned long int)8192, format, args);
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(errno_saved);
  fatal("%s: %s", (const void *)mesg, return_value_strerror_2);
}

// vmsg
// file libslack/err.c line 168
void vmsg(const char *format, void **args)
{
  struct Msg *return_value_prog_out_1;
  return_value_prog_out_1=prog_out();
  vmsg_out(return_value_prog_out_1, format, args);
}

// vmsg_out
// file libslack/msg.h line 52
void vmsg_out(struct Msg *dst, const char *format, void **args)
{
  signed int err;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int return_value_1;
  if(!(dst == ((struct Msg *)NULL)))
  {
    if(!(dst == ((struct Msg *)NULL)))
    {
      if(!(dst->locker == ((struct Locker *)NULL)))
      {
        return_value=dst->locker->rdlock(dst->locker->lock);
        tmp_if_expr_1 = return_value;
      }

      else
        tmp_if_expr_1 = 0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }

    else
      tmp_if_expr_2 = 22;
    err = tmp_if_expr_2;
    if(!(err == 0))
      set_errno(err);

    else
    {
      vmsg_out_unlocked(dst, format, args);
      if(!(dst == ((struct Msg *)NULL)))
      {
        if(!(dst->locker == ((struct Locker *)NULL)))
        {
          return_value_1=dst->locker->unlock(dst->locker->lock);
          tmp_if_expr_3 = return_value_1;
        }

        else
          tmp_if_expr_3 = 0;
        tmp_if_expr_4 = tmp_if_expr_3;
      }

      else
        tmp_if_expr_4 = 22;
      err = tmp_if_expr_4;
      if(!(err == 0))
        set_errno(err);

    }
  }

}

// vmsg_out_unlocked
// file libslack/msg.c line 455
void vmsg_out_unlocked(struct Msg *dst, const char *format, void **args)
{
  if(!(dst == ((struct Msg *)NULL)))
  {
    if(!(dst->out == ((void (*)(void *, const void *, unsigned long int))NULL)))
    {
      char mesg[8192l];
      vsnprintf(mesg, (unsigned long int)8192, format, args);
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(mesg);
      dst->out(dst->data, (const void *)mesg, return_value_strlen_1);
    }

  }

}

// vpack
// file libslack/net.c line 3037
signed long int vpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args)
{
  unsigned long int count;
  unsigned char *pkt = (unsigned char *)buf;
  unsigned char *p = pkt;
  char tmp[128l];
  signed int return_value_set_errno_1;
  const char *tmp_post_2;
  void *vpack__1__1__1__1__data;
  signed int return_value_gcc_builtin_va_arg_3;
  const unsigned short int **return_value___ctype_b_loc_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  signed int return_value_set_errno_6;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  char *vpack__1__1__1__2__data;
  unsigned long int vpack__1__1__1__2__len;
  signed int return_value_gcc_builtin_va_arg_9;
  const unsigned short int **return_value___ctype_b_loc_11;
  const unsigned short int **return_value___ctype_b_loc_10;
  signed int return_value_set_errno_12;
  signed int return_value_set_errno_13;
  signed int return_value_set_errno_14;
  char *vpack__1__1__1__3__data;
  unsigned char byte;
  signed int shift;
  signed int return_value_gcc_builtin_va_arg_15;
  const unsigned short int **return_value___ctype_b_loc_17;
  const unsigned short int **return_value___ctype_b_loc_16;
  signed int return_value_set_errno_18;
  signed int return_value_set_errno_19;
  signed int return_value_set_errno_20;
  unsigned long int tmp_post_21;
  char *tmp_post_22;
  signed int return_value_set_errno_23;
  unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  char *vpack__1__1__1__4__data;
  unsigned char vpack__1__1__1__4__byte;
  signed int vpack__1__1__1__4__shift;
  signed int return_value_gcc_builtin_va_arg_26;
  const unsigned short int **return_value___ctype_b_loc_28;
  const unsigned short int **return_value___ctype_b_loc_27;
  signed int return_value_set_errno_29;
  signed int return_value_set_errno_30;
  signed int return_value_set_errno_31;
  unsigned long int tmp_post_32;
  char *tmp_post_33;
  signed int return_value_set_errno_34;
  unsigned char *tmp_post_35;
  unsigned char *tmp_post_36;
  signed int return_value_gcc_builtin_va_arg_37;
  const unsigned short int **return_value___ctype_b_loc_39;
  const unsigned short int **return_value___ctype_b_loc_38;
  signed int return_value_set_errno_40;
  signed int return_value_set_errno_41;
  unsigned long int tmp_post_42;
  unsigned char *tmp_post_43;
  signed int return_value_gcc_builtin_va_arg_44;
  signed int return_value_gcc_builtin_va_arg_45;
  const unsigned short int **return_value___ctype_b_loc_47;
  const unsigned short int **return_value___ctype_b_loc_46;
  signed int return_value_set_errno_48;
  signed int return_value_set_errno_49;
  unsigned long int tmp_post_50;
  unsigned char *tmp_post_52;
  unsigned char *tmp_post_53;
  signed int return_value_gcc_builtin_va_arg_54;
  const unsigned short int **return_value___ctype_b_loc_56;
  const unsigned short int **return_value___ctype_b_loc_55;
  signed int return_value_set_errno_57;
  signed int return_value_set_errno_58;
  unsigned long int tmp_post_59;
  unsigned char *tmp_post_61;
  unsigned char *tmp_post_62;
  unsigned char *tmp_post_63;
  unsigned char *tmp_post_64;
  signed int return_value_gcc_builtin_va_arg_65;
  const unsigned short int **return_value___ctype_b_loc_67;
  const unsigned short int **return_value___ctype_b_loc_66;
  signed int return_value_set_errno_68;
  signed int return_value_set_errno_69;
  unsigned long int tmp_post_70;
  unsigned char *tmp_post_72;
  unsigned char *tmp_post_73;
  unsigned char *tmp_post_74;
  unsigned char *tmp_post_75;
  unsigned char *tmp_post_76;
  unsigned char *tmp_post_77;
  unsigned char *tmp_post_78;
  unsigned char *tmp_post_79;
  signed int return_value_gcc_builtin_va_arg_80;
  const unsigned short int **return_value___ctype_b_loc_82;
  const unsigned short int **return_value___ctype_b_loc_81;
  signed int return_value_set_errno_83;
  unsigned long int tmp_post_84;
  signed int return_value_set_errno_85;
  signed int return_value_set_errno_87;
  unsigned char *tmp_post_88;
  signed int return_value_gcc_builtin_va_arg_89;
  const unsigned short int **return_value___ctype_b_loc_91;
  const unsigned short int **return_value___ctype_b_loc_90;
  signed int return_value_set_errno_92;
  signed int return_value_set_errno_93;
  unsigned long int tmp_post_94;
  unsigned char *tmp_post_96;
  unsigned char *tmp_post_97;
  signed int return_value_gcc_builtin_va_arg_98;
  const unsigned short int **return_value___ctype_b_loc_100;
  const unsigned short int **return_value___ctype_b_loc_99;
  signed int return_value_set_errno_101;
  signed int return_value_set_errno_102;
  unsigned long int tmp_post_103;
  unsigned char *tmp_post_105;
  unsigned char *tmp_post_106;
  unsigned char *tmp_post_107;
  unsigned char *tmp_post_108;
  signed int return_value_gcc_builtin_va_arg_109;
  const unsigned short int **return_value___ctype_b_loc_111;
  const unsigned short int **return_value___ctype_b_loc_110;
  signed int return_value_set_errno_112;
  signed int return_value_set_errno_113;
  signed int return_value_gcc_builtin_va_arg_114;
  const unsigned short int **return_value___ctype_b_loc_116;
  const unsigned short int **return_value___ctype_b_loc_115;
  signed int return_value_set_errno_117;
  signed int return_value_set_errno_118;
  signed int return_value_gcc_builtin_va_arg_119;
  const unsigned short int **return_value___ctype_b_loc_121;
  const unsigned short int **return_value___ctype_b_loc_120;
  signed int return_value_set_errno_122;
  signed int return_value_set_errno_123;
  signed int return_value_set_errno_124;
  signed int return_value_set_errno_125;
  if(format == ((const char *)NULL) || pkt == ((unsigned char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    while(!(*format == 0))
    {
      char f;
      tmp_post_2 = format;
      format = format + 1l;
      f = *tmp_post_2;
      if((signed int)f == 112)
        f = (char)80;

      switch((signed int)f)
      {
        case 97:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_3=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_3));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_3;
          }

          else
          {
            return_value___ctype_b_loc_5=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_4=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_6=set_errno(22);
            return (signed long int)return_value_set_errno_6;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_7=set_errno(28);
            return (signed long int)return_value_set_errno_7;
          }

          vpack__1__1__1__1__data=va_arg(args, __typeof__(vpack__1__1__1__1__data));
          if(vpack__1__1__1__1__data == NULL)
          {
            return_value_set_errno_8=set_errno(22);
            return (signed long int)return_value_set_errno_8;
          }

          memcpy((void *)p, vpack__1__1__1__1__data, count);
          p = p + (signed long int)count;
          break;
        }
        case 122:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_9=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_9));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_9;
          }

          else
          {
            return_value___ctype_b_loc_11=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_11)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_10=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_12=set_errno(22);
            return (signed long int)return_value_set_errno_12;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_13=set_errno(28);
            return (signed long int)return_value_set_errno_13;
          }

          vpack__1__1__1__2__data=va_arg(args, __typeof__(vpack__1__1__1__2__data));
          if(vpack__1__1__1__2__data == ((char *)NULL))
          {
            return_value_set_errno_14=set_errno(22);
            return (signed long int)return_value_set_errno_14;
          }

          vpack__1__1__1__2__len=strlen(vpack__1__1__1__2__data);
          if(!(count >= vpack__1__1__1__2__len))
            vpack__1__1__1__2__len = count;

          memcpy((void *)p, (const void *)vpack__1__1__1__2__data, vpack__1__1__1__2__len);
          p = p + (signed long int)vpack__1__1__1__2__len;
          count = count - vpack__1__1__1__2__len;
          if(!(count == 0ul))
            memset((void *)p, 0, count);

          p = p + (signed long int)count;
          break;
        }
        case 98:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_15=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_15));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_15;
          }

          else
          {
            return_value___ctype_b_loc_17=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_17)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_16=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_18=set_errno(22);
            return (signed long int)return_value_set_errno_18;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(7ul + count >> 3)))
          {
            return_value_set_errno_19=set_errno(28);
            return (signed long int)return_value_set_errno_19;
          }

          vpack__1__1__1__3__data=va_arg(args, __typeof__(vpack__1__1__1__3__data));
          if(vpack__1__1__1__3__data == ((char *)NULL))
          {
            return_value_set_errno_20=set_errno(22);
            return (signed long int)return_value_set_errno_20;
          }

          byte = (unsigned char)0x00;
          shift = 7;
          do
          {
            tmp_post_21 = count;
            count = count - 1ul;
            if(tmp_post_21 == 0ul)
              break;

            tmp_post_22 = vpack__1__1__1__3__data;
            vpack__1__1__1__3__data = vpack__1__1__1__3__data + 1l;
            switch((signed int)*tmp_post_22)
            {
              case 48:
                break;
              case 49:
              {
                byte = byte | (unsigned char)(1 << shift);
                break;
              }
              default:
              {
                return_value_set_errno_23=set_errno(22);
                return (signed long int)return_value_set_errno_23;
              }
            }
            shift = shift - 1;
            if(shift == -1)
            {
              tmp_post_24 = p;
              p = p + 1l;
              *tmp_post_24 = byte;
              byte = (unsigned char)0x00;
              shift = 7;
            }

          }
          while((_Bool)1);
          if(!(shift == 7))
          {
            tmp_post_25 = p;
            p = p + 1l;
            *tmp_post_25 = byte;
          }

          break;
        }
        case 104:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_26=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_26));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_26;
          }

          else
          {
            return_value___ctype_b_loc_28=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_28)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_27=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_27)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_29=set_errno(22);
            return (signed long int)return_value_set_errno_29;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(1ul + count >> 1)))
          {
            return_value_set_errno_30=set_errno(28);
            return (signed long int)return_value_set_errno_30;
          }

          vpack__1__1__1__4__data=va_arg(args, __typeof__(vpack__1__1__1__4__data));
          if(vpack__1__1__1__4__data == ((char *)NULL))
          {
            return_value_set_errno_31=set_errno(22);
            return (signed long int)return_value_set_errno_31;
          }

          vpack__1__1__1__4__byte = (unsigned char)0x00;
          vpack__1__1__1__4__shift = 4;
          do
          {
            tmp_post_32 = count;
            count = count - 1ul;
            if(tmp_post_32 == 0ul)
              break;

            unsigned char nybble;
            tmp_post_33 = vpack__1__1__1__4__data;
            vpack__1__1__1__4__data = vpack__1__1__1__4__data + 1l;
            nybble = (unsigned char)*tmp_post_33;
            switch((signed int)nybble)
            {
              case 48:

              case 49:

              case 50:

              case 51:

              case 52:

              case 53:

              case 54:

              case 55:

              case 56:

              case 57:
              {
                vpack__1__1__1__4__byte = vpack__1__1__1__4__byte | (unsigned char)((signed int)nybble - 48 << vpack__1__1__1__4__shift);
                break;
              }
              case 97:

              case 98:

              case 99:

              case 100:

              case 101:

              case 102:
              {
                vpack__1__1__1__4__byte = vpack__1__1__1__4__byte | (unsigned char)(((signed int)nybble - 97) + 10 << vpack__1__1__1__4__shift);
                break;
              }
              case 65:

              case 66:

              case 67:

              case 68:

              case 69:

              case 70:
              {
                vpack__1__1__1__4__byte = vpack__1__1__1__4__byte | (unsigned char)(((signed int)nybble - 65) + 10 << vpack__1__1__1__4__shift);
                break;
              }
              default:
              {
                return_value_set_errno_34=set_errno(22);
                return (signed long int)return_value_set_errno_34;
              }
            }
            vpack__1__1__1__4__shift = vpack__1__1__1__4__shift - 4;
            if(vpack__1__1__1__4__shift == -4)
            {
              tmp_post_35 = p;
              p = p + 1l;
              *tmp_post_35 = vpack__1__1__1__4__byte;
              vpack__1__1__1__4__byte = (unsigned char)0x00;
              vpack__1__1__1__4__shift = 4;
            }

          }
          while((_Bool)1);
          if(!(vpack__1__1__1__4__shift == 4))
          {
            tmp_post_36 = p;
            p = p + 1l;
            *tmp_post_36 = vpack__1__1__1__4__byte;
          }

          break;
        }
        case 99:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_37=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_37));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_37;
          }

          else
          {
            return_value___ctype_b_loc_39=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_39)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_38=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_38)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_40=set_errno(22);
            return (signed long int)return_value_set_errno_40;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_41=set_errno(28);
            return (signed long int)return_value_set_errno_41;
          }

          do
          {
            tmp_post_42 = count;
            count = count - 1ul;
            if(tmp_post_42 == 0ul)
              break;

            tmp_post_43 = p;
            p = p + 1l;
            return_value_gcc_builtin_va_arg_44=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_44));
            *tmp_post_43 = (unsigned char)return_value_gcc_builtin_va_arg_44;
          }
          while((_Bool)1);
          break;
        }
        case 115:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_45=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_45));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_45;
          }

          else
          {
            return_value___ctype_b_loc_47=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_47)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_46=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_46)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_48=set_errno(22);
            return (signed long int)return_value_set_errno_48;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno_49=set_errno(28);
            return (signed long int)return_value_set_errno_49;
          }

          do
          {
            tmp_post_50 = count;
            count = count - 1ul;
            if(tmp_post_50 == 0ul)
              break;

            unsigned short int data;
            signed int return_value_gcc_builtin_va_arg_51;
            return_value_gcc_builtin_va_arg_51=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_51));
            data = (unsigned short int)return_value_gcc_builtin_va_arg_51;
            tmp_post_52 = p;
            p = p + 1l;
            *tmp_post_52 = (unsigned char)((signed int)data >> 8 & 0xff);
            tmp_post_53 = p;
            p = p + 1l;
            *tmp_post_53 = (unsigned char)((signed int)data & 0xff);
          }
          while((_Bool)1);
          break;
        }
        case 105:

        case 112:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_54=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_54));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_54;
          }

          else
          {
            return_value___ctype_b_loc_56=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_56)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_55=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_55)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_57=set_errno(22);
            return (signed long int)return_value_set_errno_57;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno_58=set_errno(28);
            return (signed long int)return_value_set_errno_58;
          }

          do
          {
            tmp_post_59 = count;
            count = count - 1ul;
            if(tmp_post_59 == 0ul)
              break;

            unsigned long int vpack__1__1__1__7__2__data;
            signed int return_value_gcc_builtin_va_arg_60;
            return_value_gcc_builtin_va_arg_60=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_60));
            vpack__1__1__1__7__2__data = (unsigned long int)return_value_gcc_builtin_va_arg_60;
            tmp_post_61 = p;
            p = p + 1l;
            *tmp_post_61 = (unsigned char)(vpack__1__1__1__7__2__data >> 24 & (unsigned long int)0xff);
            tmp_post_62 = p;
            p = p + 1l;
            *tmp_post_62 = (unsigned char)(vpack__1__1__1__7__2__data >> 16 & (unsigned long int)0xff);
            tmp_post_63 = p;
            p = p + 1l;
            *tmp_post_63 = (unsigned char)(vpack__1__1__1__7__2__data >> 8 & (unsigned long int)0xff);
            tmp_post_64 = p;
            p = p + 1l;
            *tmp_post_64 = (unsigned char)(vpack__1__1__1__7__2__data & (unsigned long int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 108:

        case 80:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_65=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_65));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_65;
          }

          else
          {
            return_value___ctype_b_loc_67=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_67)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_66=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_66)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_68=set_errno(22);
            return (signed long int)return_value_set_errno_68;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 3)))
          {
            return_value_set_errno_69=set_errno(28);
            return (signed long int)return_value_set_errno_69;
          }

          do
          {
            tmp_post_70 = count;
            count = count - 1ul;
            if(tmp_post_70 == 0ul)
              break;

            unsigned long long int vpack__1__1__1__8__2__data;
            signed long long int return_value_gcc_builtin_va_arg_71;
            return_value_gcc_builtin_va_arg_71=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_71));
            vpack__1__1__1__8__2__data = (unsigned long long int)return_value_gcc_builtin_va_arg_71;
            tmp_post_72 = p;
            p = p + 1l;
            *tmp_post_72 = (unsigned char)(vpack__1__1__1__8__2__data >> 56 & (unsigned long int)0xff);
            tmp_post_73 = p;
            p = p + 1l;
            *tmp_post_73 = (unsigned char)(vpack__1__1__1__8__2__data >> 48 & (unsigned long int)0xff);
            tmp_post_74 = p;
            p = p + 1l;
            *tmp_post_74 = (unsigned char)(vpack__1__1__1__8__2__data >> 40 & (unsigned long int)0xff);
            tmp_post_75 = p;
            p = p + 1l;
            *tmp_post_75 = (unsigned char)(vpack__1__1__1__8__2__data >> 32 & (unsigned long int)0xff);
            tmp_post_76 = p;
            p = p + 1l;
            *tmp_post_76 = (unsigned char)(vpack__1__1__1__8__2__data >> 24 & (unsigned long int)0xff);
            tmp_post_77 = p;
            p = p + 1l;
            *tmp_post_77 = (unsigned char)(vpack__1__1__1__8__2__data >> 16 & (unsigned long int)0xff);
            tmp_post_78 = p;
            p = p + 1l;
            *tmp_post_78 = (unsigned char)(vpack__1__1__1__8__2__data >> 8 & (unsigned long int)0xff);
            tmp_post_79 = p;
            p = p + 1l;
            *tmp_post_79 = (unsigned char)(vpack__1__1__1__8__2__data & (unsigned long int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 102:

        case 100:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_80=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_80));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_80;
          }

          else
          {
            return_value___ctype_b_loc_82=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_82)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_81=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_81)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_83=set_errno(22);
            return (signed long int)return_value_set_errno_83;
          }

          do
          {
            tmp_post_84 = count;
            count = count - 1ul;
            if(tmp_post_84 == 0ul)
              break;

            double vpack__1__1__1__9__2__data;
            vpack__1__1__1__9__2__data=va_arg(args, __typeof__(vpack__1__1__1__9__2__data));
            signed int rc;
            rc=snprintf(tmp, (unsigned long int)128, "%g", vpack__1__1__1__9__2__data);
            unsigned long int len;
            if(rc == -1 || rc >= 128)
            {
              return_value_set_errno_85=set_errno(28);
              return (signed long int)return_value_set_errno_85;
            }

            unsigned long int return_value_strlen_86;
            return_value_strlen_86=strlen(tmp);
            len = return_value_strlen_86 + (unsigned long int)1;
            if(!(pkt + (signed long int)size >= p + 1l + (signed long int)len))
            {
              return_value_set_errno_87=set_errno(28);
              return (signed long int)return_value_set_errno_87;
            }

            tmp_post_88 = p;
            p = p + 1l;
            *tmp_post_88 = (unsigned char)(len & (unsigned long int)0xff);
            memcpy((void *)p, (const void *)tmp, len);
            p = p + (signed long int)len;
          }
          while((_Bool)1);
          break;
        }
        case 118:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_89=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_89));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_89;
          }

          else
          {
            return_value___ctype_b_loc_91=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_91)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_90=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_90)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_92=set_errno(22);
            return (signed long int)return_value_set_errno_92;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno_93=set_errno(28);
            return (signed long int)return_value_set_errno_93;
          }

          do
          {
            tmp_post_94 = count;
            count = count - 1ul;
            if(tmp_post_94 == 0ul)
              break;

            unsigned short int vpack__1__1__1__10__2__data;
            signed int return_value_gcc_builtin_va_arg_95;
            return_value_gcc_builtin_va_arg_95=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_95));
            vpack__1__1__1__10__2__data = (unsigned short int)return_value_gcc_builtin_va_arg_95;
            tmp_post_96 = p;
            p = p + 1l;
            *tmp_post_96 = (unsigned char)((signed int)vpack__1__1__1__10__2__data & 0xff);
            tmp_post_97 = p;
            p = p + 1l;
            *tmp_post_97 = (unsigned char)((signed int)vpack__1__1__1__10__2__data >> 8 & 0xff);
          }
          while((_Bool)1);
          break;
        }
        case 119:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_98=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_98));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_98;
          }

          else
          {
            return_value___ctype_b_loc_100=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_100)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_99=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_99)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_101=set_errno(22);
            return (signed long int)return_value_set_errno_101;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno_102=set_errno(28);
            return (signed long int)return_value_set_errno_102;
          }

          do
          {
            tmp_post_103 = count;
            count = count - 1ul;
            if(tmp_post_103 == 0ul)
              break;

            unsigned int vpack__1__1__1__11__2__data;
            signed int return_value_gcc_builtin_va_arg_104;
            return_value_gcc_builtin_va_arg_104=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_104));
            vpack__1__1__1__11__2__data = (unsigned int)return_value_gcc_builtin_va_arg_104;
            tmp_post_105 = p;
            p = p + 1l;
            *tmp_post_105 = (unsigned char)(vpack__1__1__1__11__2__data & (unsigned int)0xff);
            tmp_post_106 = p;
            p = p + 1l;
            *tmp_post_106 = (unsigned char)(vpack__1__1__1__11__2__data >> 8 & (unsigned int)0xff);
            tmp_post_107 = p;
            p = p + 1l;
            *tmp_post_107 = (unsigned char)(vpack__1__1__1__11__2__data >> 16 & (unsigned int)0xff);
            tmp_post_108 = p;
            p = p + 1l;
            *tmp_post_108 = (unsigned char)(vpack__1__1__1__11__2__data >> 24 & (unsigned int)0xff);
          }
          while((_Bool)1);
          break;
        }
        case 120:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_109=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_109));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_109;
          }

          else
          {
            return_value___ctype_b_loc_111=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_111)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_110=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_110)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_112=set_errno(22);
            return (signed long int)return_value_set_errno_112;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_113=set_errno(28);
            return (signed long int)return_value_set_errno_113;
          }

          memset((void *)p, 0, count);
          p = p + (signed long int)count;
          break;
        }
        case 88:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_114=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_114));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_114;
          }

          else
          {
            return_value___ctype_b_loc_116=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_116)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_115=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_115)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_117=set_errno(22);
            return (signed long int)return_value_set_errno_117;
          }

          if(!(p + -((signed long int)count) >= pkt))
          {
            return_value_set_errno_118=set_errno(22);
            return (signed long int)return_value_set_errno_118;
          }

          p = p - (signed long int)count;
          break;
        }
        case 64:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_119=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_119));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_119;
          }

          else
          {
            return_value___ctype_b_loc_121=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_121)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_120=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_120)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_122=set_errno(22);
            return (signed long int)return_value_set_errno_122;
          }

          if(!(size >= count))
          {
            return_value_set_errno_123=set_errno(28);
            return (signed long int)return_value_set_errno_123;
          }

          if(!(pkt + (signed long int)count >= p))
          {
            return_value_set_errno_124=set_errno(22);
            return (signed long int)return_value_set_errno_124;
          }

          memset((void *)p, 0, count - (unsigned long int)(p - pkt));
          p = p + (signed long int)(count - (unsigned long int)(p - pkt));
          break;
        }
        default:
        {
          return_value_set_errno_125=set_errno(22);
          return (signed long int)return_value_set_errno_125;
        }
      }
    }
    return p - pkt;
  }
}

// vunpack
// file libslack/net.c line 3400
signed long int vunpack(void *buf, unsigned long int size, const char *format, __builtin_va_list args)
{
  unsigned char *pkt = (unsigned char *)buf;
  unsigned char *p = pkt;
  unsigned long int count;
  unsigned long int limit;
  signed int return_value_set_errno_1;
  const char *tmp_post_2;
  void *data;
  signed int return_value_gcc_builtin_va_arg_3;
  signed int return_value_set_errno_4;
  const unsigned short int **return_value___ctype_b_loc_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  signed int return_value_set_errno_7;
  signed int return_value_set_errno_8;
  signed int return_value_set_errno_9;
  char *vunpack__1__1__1__2__data;
  unsigned long int len;
  signed int return_value_gcc_builtin_va_arg_10;
  signed int return_value_set_errno_11;
  const unsigned short int **return_value___ctype_b_loc_13;
  const unsigned short int **return_value___ctype_b_loc_12;
  signed int return_value_set_errno_14;
  signed int return_value_set_errno_15;
  signed int return_value_set_errno_16;
  _Bool tmp_if_expr_17;
  char vunpack__1__1__1__3__bin[3l];
  char *vunpack__1__1__1__3__data;
  signed int vunpack__1__1__1__3__shift;
  signed int return_value_gcc_builtin_va_arg_18;
  signed int return_value_set_errno_19;
  const unsigned short int **return_value___ctype_b_loc_21;
  const unsigned short int **return_value___ctype_b_loc_20;
  signed int return_value_set_errno_22;
  signed int return_value_set_errno_23;
  signed int return_value_set_errno_24;
  unsigned long int tmp_post_25;
  char *tmp_post_26;
  char vunpack__1__1__1__4__hex[17l];
  char *vunpack__1__1__1__4__data;
  signed int shift;
  signed int return_value_gcc_builtin_va_arg_27;
  signed int return_value_set_errno_28;
  const unsigned short int **return_value___ctype_b_loc_30;
  const unsigned short int **return_value___ctype_b_loc_29;
  signed int return_value_set_errno_31;
  signed int return_value_set_errno_32;
  signed int return_value_set_errno_33;
  unsigned long int tmp_post_34;
  char *tmp_post_35;
  signed int return_value_gcc_builtin_va_arg_36;
  const unsigned short int **return_value___ctype_b_loc_38;
  const unsigned short int **return_value___ctype_b_loc_37;
  signed int return_value_set_errno_39;
  signed int return_value_set_errno_40;
  unsigned long int tmp_post_41;
  unsigned char *tmp_post_42;
  signed int return_value_gcc_builtin_va_arg_43;
  const unsigned short int **return_value___ctype_b_loc_45;
  const unsigned short int **return_value___ctype_b_loc_44;
  signed int return_value_set_errno_46;
  signed int return_value_set_errno_47;
  unsigned long int tmp_post_48;
  unsigned char *tmp_post_49;
  unsigned char *tmp_post_50;
  signed int return_value_gcc_builtin_va_arg_51;
  const unsigned short int **return_value___ctype_b_loc_53;
  const unsigned short int **return_value___ctype_b_loc_52;
  signed int return_value_set_errno_54;
  signed int return_value_set_errno_55;
  unsigned long int tmp_post_56;
  unsigned char *tmp_post_57;
  unsigned char *tmp_post_58;
  unsigned char *tmp_post_59;
  unsigned char *tmp_post_60;
  signed int return_value_gcc_builtin_va_arg_61;
  const unsigned short int **return_value___ctype_b_loc_63;
  const unsigned short int **return_value___ctype_b_loc_62;
  signed int return_value_set_errno_64;
  signed int return_value_set_errno_65;
  unsigned long int tmp_post_66;
  unsigned char *tmp_post_67;
  unsigned char *tmp_post_68;
  signed int return_value_gcc_builtin_va_arg_69;
  const unsigned short int **return_value___ctype_b_loc_71;
  const unsigned short int **return_value___ctype_b_loc_70;
  signed int return_value_set_errno_72;
  signed int return_value_set_errno_73;
  unsigned long int tmp_post_74;
  unsigned char *tmp_post_75;
  unsigned char *tmp_post_76;
  unsigned char *tmp_post_77;
  unsigned char *tmp_post_78;
  signed int return_value_gcc_builtin_va_arg_79;
  const unsigned short int **return_value___ctype_b_loc_81;
  const unsigned short int **return_value___ctype_b_loc_80;
  signed int return_value_set_errno_82;
  signed int return_value_set_errno_83;
  unsigned long int tmp_post_84;
  unsigned char *tmp_post_85;
  unsigned char *tmp_post_86;
  unsigned char *tmp_post_87;
  unsigned char *tmp_post_88;
  unsigned char *tmp_post_89;
  unsigned char *tmp_post_90;
  unsigned char *tmp_post_91;
  unsigned char *tmp_post_92;
  signed int return_value_gcc_builtin_va_arg_93;
  const unsigned short int **return_value___ctype_b_loc_95;
  const unsigned short int **return_value___ctype_b_loc_94;
  signed int return_value_set_errno_96;
  unsigned long int tmp_post_97;
  signed int return_value_set_errno_98;
  unsigned char *tmp_post_99;
  signed int return_value_set_errno_100;
  signed int return_value_gcc_builtin_va_arg_101;
  const unsigned short int **return_value___ctype_b_loc_103;
  const unsigned short int **return_value___ctype_b_loc_102;
  signed int return_value_set_errno_104;
  unsigned long int tmp_post_105;
  signed int return_value_set_errno_106;
  unsigned char *tmp_post_107;
  signed int return_value_set_errno_108;
  signed int return_value_gcc_builtin_va_arg_109;
  const unsigned short int **return_value___ctype_b_loc_111;
  const unsigned short int **return_value___ctype_b_loc_110;
  signed int return_value_set_errno_112;
  signed int return_value_set_errno_113;
  signed int return_value_gcc_builtin_va_arg_114;
  const unsigned short int **return_value___ctype_b_loc_116;
  const unsigned short int **return_value___ctype_b_loc_115;
  signed int return_value_set_errno_117;
  signed int return_value_set_errno_118;
  signed int return_value_gcc_builtin_va_arg_119;
  const unsigned short int **return_value___ctype_b_loc_121;
  const unsigned short int **return_value___ctype_b_loc_120;
  signed int return_value_set_errno_122;
  signed int return_value_set_errno_123;
  signed int return_value_set_errno_124;
  signed int return_value_set_errno_125;
  if(format == ((const char *)NULL) || pkt == ((unsigned char *)NULL))
  {
    return_value_set_errno_1=set_errno(22);
    return (signed long int)return_value_set_errno_1;
  }

  else
  {
    while(!(*format == 0))
    {
      char f;
      tmp_post_2 = format;
      format = format + 1l;
      f = *tmp_post_2;
      if((signed int)f == 112)
        f = (char)80;

      switch((signed int)f)
      {
        case 97:
        {
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_3=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_3));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_3;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack__1__1__1__1__1__countp;
              vunpack__1__1__1__1__1__countp=va_arg(args, __typeof__(vunpack__1__1__1__1__1__countp));
              if(vunpack__1__1__1__1__1__countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno_4=set_errno(22);
                return (signed long int)return_value_set_errno_4;
              }

              count = *vunpack__1__1__1__1__1__countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc_6=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc_5=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno_7=set_errno(22);
            return (signed long int)return_value_set_errno_7;
          }

          if(!(limit >= count))
          {
            return_value_set_errno_8=set_errno(28);
            return (signed long int)return_value_set_errno_8;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_9=set_errno(28);
            return (signed long int)return_value_set_errno_9;
          }

          data=va_arg(args, __typeof__(data));
          if(data == NULL)
          {
            p = p + (signed long int)count;
            break;
          }

          memcpy(data, (const void *)p, count);
          p = p + (signed long int)count;
          break;
        }
        case 122:
        {
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_10=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_10));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_10;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack__1__1__1__2__1__countp;
              vunpack__1__1__1__2__1__countp=va_arg(args, __typeof__(vunpack__1__1__1__2__1__countp));
              if(vunpack__1__1__1__2__1__countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno_11=set_errno(22);
                return (signed long int)return_value_set_errno_11;
              }

              count = *vunpack__1__1__1__2__1__countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc_13=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc_12=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno_14=set_errno(22);
            return (signed long int)return_value_set_errno_14;
          }

          if(!(limit >= count))
          {
            return_value_set_errno_15=set_errno(28);
            return (signed long int)return_value_set_errno_15;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_16=set_errno(28);
            return (signed long int)return_value_set_errno_16;
          }

          vunpack__1__1__1__2__data=va_arg(args, __typeof__(vunpack__1__1__1__2__data));
          if(vunpack__1__1__1__2__data == ((char *)NULL))
          {
            p = p + (signed long int)count;
            break;
          }

          len = (unsigned long int)0;
          do
          {
            if(!(p + (signed long int)len >= pkt + (signed long int)size))
              tmp_if_expr_17 = p[(signed long int)len] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_17 = (_Bool)0;
            if(!tmp_if_expr_17)
              break;

            len = len + 1ul;
          }
          while((_Bool)1);
          if(!(count >= len))
            len = count;

          memcpy((void *)vunpack__1__1__1__2__data, (const void *)p, len);
          p = p + (signed long int)len;
          count = count - len;
          memset((void *)(vunpack__1__1__1__2__data + (signed long int)len), 0, count != 0ul ? count : (unsigned long int)1);
          p = p + (signed long int)count;
          break;
        }
        case 98:
        {
          vunpack__1__1__1__3__bin[0] = '0';
          vunpack__1__1__1__3__bin[1] = '1';
          vunpack__1__1__1__3__bin[2] = 0;
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_18=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_18));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_18;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *vunpack__1__1__1__3__1__countp;
              vunpack__1__1__1__3__1__countp=va_arg(args, __typeof__(vunpack__1__1__1__3__1__countp));
              if(vunpack__1__1__1__3__1__countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno_19=set_errno(22);
                return (signed long int)return_value_set_errno_19;
              }

              count = *vunpack__1__1__1__3__1__countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc_21=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_21)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc_20=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc_20)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno_22=set_errno(22);
            return (signed long int)return_value_set_errno_22;
          }

          if(!(limit >= count))
          {
            return_value_set_errno_23=set_errno(28);
            return (signed long int)return_value_set_errno_23;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(7ul + count >> 3)))
          {
            return_value_set_errno_24=set_errno(28);
            return (signed long int)return_value_set_errno_24;
          }

          vunpack__1__1__1__3__data=va_arg(args, __typeof__(vunpack__1__1__1__3__data));
          if(vunpack__1__1__1__3__data == ((char *)NULL))
          {
            p = p + (signed long int)(count + (unsigned long int)7 >> 3);
            break;
          }

          vunpack__1__1__1__3__shift = 7;
          do
          {
            tmp_post_25 = count;
            count = count - 1ul;
            if(tmp_post_25 == 0ul)
              break;

            tmp_post_26 = vunpack__1__1__1__3__data;
            vunpack__1__1__1__3__data = vunpack__1__1__1__3__data + 1l;
            *tmp_post_26 = vunpack__1__1__1__3__bin[(signed long int)(((signed int)*p & 0x01 << vunpack__1__1__1__3__shift) >> vunpack__1__1__1__3__shift)];
            vunpack__1__1__1__3__shift = vunpack__1__1__1__3__shift - 1;
            if(vunpack__1__1__1__3__shift == -1)
            {
              p = p + 1l;
              vunpack__1__1__1__3__shift = 7;
            }

          }
          while((_Bool)1);
          if(!(vunpack__1__1__1__3__shift == 7))
            p = p + 1l;

          *vunpack__1__1__1__3__data = (char)0;
          break;
        }
        case 104:
        {
          vunpack__1__1__1__4__hex[0] = '0';
          vunpack__1__1__1__4__hex[1] = '1';
          vunpack__1__1__1__4__hex[2] = '2';
          vunpack__1__1__1__4__hex[3] = '3';
          vunpack__1__1__1__4__hex[4] = '4';
          vunpack__1__1__1__4__hex[5] = '5';
          vunpack__1__1__1__4__hex[6] = '6';
          vunpack__1__1__1__4__hex[7] = '7';
          vunpack__1__1__1__4__hex[8] = '8';
          vunpack__1__1__1__4__hex[9] = '9';
          vunpack__1__1__1__4__hex[10] = 'a';
          vunpack__1__1__1__4__hex[11] = 'b';
          vunpack__1__1__1__4__hex[12] = 'c';
          vunpack__1__1__1__4__hex[13] = 'd';
          vunpack__1__1__1__4__hex[14] = 'e';
          vunpack__1__1__1__4__hex[15] = 'f';
          vunpack__1__1__1__4__hex[16] = 0;
          count = (unsigned long int)1;
          limit = count;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_27=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_27));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_27;
            limit = count;
          }

          else
            if((signed int)*format == 63)
            {
              unsigned long int *countp;
              countp=va_arg(args, __typeof__(countp));
              if(countp == ((unsigned long int *)NULL))
              {
                return_value_set_errno_28=set_errno(22);
                return (signed long int)return_value_set_errno_28;
              }

              count = *countp;
              limit=va_arg(args, __typeof__(limit));
              format = format + 1l;
            }

            else
            {
              return_value___ctype_b_loc_30=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_30)[(signed long int)(signed int)(unsigned int)*format]) == 0))
              {
                count = (unsigned long int)0;
                do
                {
                  return_value___ctype_b_loc_29=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc_29)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                    break;

                  count = count * (unsigned long int)10;
                  count = count + (unsigned long int)((signed int)*format - 48);
                  format = format + 1l;
                }
                while((_Bool)1);
                limit = count;
              }

            }
          if(!((signed long int)count >= 1l) || !((signed long int)limit >= 1l))
          {
            return_value_set_errno_31=set_errno(22);
            return (signed long int)return_value_set_errno_31;
          }

          if(!(limit >= count))
          {
            return_value_set_errno_32=set_errno(28);
            return (signed long int)return_value_set_errno_32;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(1ul + count >> 1)))
          {
            return_value_set_errno_33=set_errno(28);
            return (signed long int)return_value_set_errno_33;
          }

          vunpack__1__1__1__4__data=va_arg(args, __typeof__(vunpack__1__1__1__4__data));
          if(vunpack__1__1__1__4__data == ((char *)NULL))
          {
            p = p + (signed long int)(count + (unsigned long int)1 >> 1);
            break;
          }

          shift = 4;
          do
          {
            tmp_post_34 = count;
            count = count - 1ul;
            if(tmp_post_34 == 0ul)
              break;

            tmp_post_35 = vunpack__1__1__1__4__data;
            vunpack__1__1__1__4__data = vunpack__1__1__1__4__data + 1l;
            *tmp_post_35 = vunpack__1__1__1__4__hex[(signed long int)(((signed int)*p & 0x0f << shift) >> shift)];
            shift = shift - 4;
            if(shift == -4)
            {
              p = p + 1l;
              shift = 4;
            }

          }
          while((_Bool)1);
          if(!(shift == 4))
            p = p + 1l;

          *vunpack__1__1__1__4__data = (char)0;
          break;
        }
        case 99:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_36=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_36));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_36;
          }

          else
          {
            return_value___ctype_b_loc_38=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_38)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_37=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_37)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_39=set_errno(22);
            return (signed long int)return_value_set_errno_39;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_40=set_errno(28);
            return (signed long int)return_value_set_errno_40;
          }

          do
          {
            tmp_post_41 = count;
            count = count - 1ul;
            if(tmp_post_41 == 0ul)
              break;

            signed char *vunpack__1__1__1__5__2__data;
            vunpack__1__1__1__5__2__data=va_arg(args, __typeof__(vunpack__1__1__1__5__2__data));
            if(vunpack__1__1__1__5__2__data == ((signed char *)NULL))
              p = p + (signed long int)1;

            else
            {
              tmp_post_42 = p;
              p = p + 1l;
              *vunpack__1__1__1__5__2__data = (signed char)*tmp_post_42;
            }
          }
          while((_Bool)1);
          break;
        }
        case 115:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_43=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_43));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_43;
          }

          else
          {
            return_value___ctype_b_loc_45=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_45)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_44=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_44)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_46=set_errno(22);
            return (signed long int)return_value_set_errno_46;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno_47=set_errno(28);
            return (signed long int)return_value_set_errno_47;
          }

          do
          {
            tmp_post_48 = count;
            count = count - 1ul;
            if(tmp_post_48 == 0ul)
              break;

            signed short int *vunpack__1__1__1__6__2__data;
            vunpack__1__1__1__6__2__data=va_arg(args, __typeof__(vunpack__1__1__1__6__2__data));
            if(vunpack__1__1__1__6__2__data == ((signed short int *)NULL))
              p = p + (signed long int)2;

            else
            {
              tmp_post_49 = p;
              p = p + 1l;
              *vunpack__1__1__1__6__2__data = (signed short int)((signed int)(signed short int)*tmp_post_49 << 8);
              tmp_post_50 = p;
              p = p + 1l;
              *vunpack__1__1__1__6__2__data = *vunpack__1__1__1__6__2__data | (signed short int)*tmp_post_50;
            }
          }
          while((_Bool)1);
          break;
        }
        case 105:

        case 112:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_51=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_51));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_51;
          }

          else
          {
            return_value___ctype_b_loc_53=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_53)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_52=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_52)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_54=set_errno(22);
            return (signed long int)return_value_set_errno_54;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno_55=set_errno(28);
            return (signed long int)return_value_set_errno_55;
          }

          do
          {
            tmp_post_56 = count;
            count = count - 1ul;
            if(tmp_post_56 == 0ul)
              break;

            signed int *vunpack__1__1__1__7__2__data;
            vunpack__1__1__1__7__2__data=va_arg(args, __typeof__(vunpack__1__1__1__7__2__data));
            if(vunpack__1__1__1__7__2__data == ((signed int *)NULL))
              p = p + (signed long int)4;

            else
            {
              tmp_post_57 = p;
              p = p + 1l;
              *vunpack__1__1__1__7__2__data = (signed int)*tmp_post_57 << 24;
              tmp_post_58 = p;
              p = p + 1l;
              *vunpack__1__1__1__7__2__data = *vunpack__1__1__1__7__2__data | (signed int)*tmp_post_58 << 16;
              tmp_post_59 = p;
              p = p + 1l;
              *vunpack__1__1__1__7__2__data = *vunpack__1__1__1__7__2__data | (signed int)*tmp_post_59 << 8;
              tmp_post_60 = p;
              p = p + 1l;
              *vunpack__1__1__1__7__2__data = *vunpack__1__1__1__7__2__data | (signed int)*tmp_post_60;
            }
          }
          while((_Bool)1);
          break;
        }
        case 118:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_61=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_61));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_61;
          }

          else
          {
            return_value___ctype_b_loc_63=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_63)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_62=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_62)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_64=set_errno(22);
            return (signed long int)return_value_set_errno_64;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 1)))
          {
            return_value_set_errno_65=set_errno(28);
            return (signed long int)return_value_set_errno_65;
          }

          do
          {
            tmp_post_66 = count;
            count = count - 1ul;
            if(tmp_post_66 == 0ul)
              break;

            signed short int *vunpack__1__1__1__8__2__data;
            vunpack__1__1__1__8__2__data=va_arg(args, __typeof__(vunpack__1__1__1__8__2__data));
            if(vunpack__1__1__1__8__2__data == ((signed short int *)NULL))
              p = p + (signed long int)2;

            else
            {
              tmp_post_67 = p;
              p = p + 1l;
              *vunpack__1__1__1__8__2__data = (signed short int)*tmp_post_67;
              tmp_post_68 = p;
              p = p + 1l;
              *vunpack__1__1__1__8__2__data = *vunpack__1__1__1__8__2__data | (signed short int)((signed int)(unsigned short int)*tmp_post_68 << 8);
            }
          }
          while((_Bool)1);
          break;
        }
        case 119:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_69=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_69));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_69;
          }

          else
          {
            return_value___ctype_b_loc_71=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_71)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_70=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_70)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_72=set_errno(22);
            return (signed long int)return_value_set_errno_72;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 2)))
          {
            return_value_set_errno_73=set_errno(28);
            return (signed long int)return_value_set_errno_73;
          }

          do
          {
            tmp_post_74 = count;
            count = count - 1ul;
            if(tmp_post_74 == 0ul)
              break;

            signed int *vunpack__1__1__1__9__2__data;
            vunpack__1__1__1__9__2__data=va_arg(args, __typeof__(vunpack__1__1__1__9__2__data));
            if(vunpack__1__1__1__9__2__data == ((signed int *)NULL))
              p = p + (signed long int)4;

            else
            {
              tmp_post_75 = p;
              p = p + 1l;
              *vunpack__1__1__1__9__2__data = (signed int)(signed long int)*tmp_post_75;
              tmp_post_76 = p;
              p = p + 1l;
              *vunpack__1__1__1__9__2__data = *vunpack__1__1__1__9__2__data | (signed int)((signed long int)*tmp_post_76 << 8);
              tmp_post_77 = p;
              p = p + 1l;
              *vunpack__1__1__1__9__2__data = *vunpack__1__1__1__9__2__data | (signed int)((signed long int)*tmp_post_77 << 16);
              tmp_post_78 = p;
              p = p + 1l;
              *vunpack__1__1__1__9__2__data = *vunpack__1__1__1__9__2__data | (signed int)((signed long int)*tmp_post_78 << 24);
            }
          }
          while((_Bool)1);
          break;
        }
        case 108:

        case 80:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_79=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_79));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_79;
          }

          else
          {
            return_value___ctype_b_loc_81=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_81)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_80=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_80)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_82=set_errno(22);
            return (signed long int)return_value_set_errno_82;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)(count << 3)))
          {
            return_value_set_errno_83=set_errno(28);
            return (signed long int)return_value_set_errno_83;
          }

          do
          {
            tmp_post_84 = count;
            count = count - 1ul;
            if(tmp_post_84 == 0ul)
              break;

            signed long long int *vunpack__1__1__1__10__2__data;
            vunpack__1__1__1__10__2__data=va_arg(args, __typeof__(vunpack__1__1__1__10__2__data));
            if(vunpack__1__1__1__10__2__data == ((signed long long int *)NULL))
              p = p + (signed long int)8;

            else
            {
              tmp_post_85 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = (signed long long int)*tmp_post_85 << 56;
              tmp_post_86 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_86 << 48;
              tmp_post_87 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_87 << 40;
              tmp_post_88 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_88 << 32;
              tmp_post_89 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_89 << 24;
              tmp_post_90 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_90 << 16;
              tmp_post_91 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_91 << 8;
              tmp_post_92 = p;
              p = p + 1l;
              *vunpack__1__1__1__10__2__data = *vunpack__1__1__1__10__2__data | (signed long long int)*tmp_post_92;
            }
          }
          while((_Bool)1);
          break;
        }
        case 102:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_93=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_93));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_93;
          }

          else
          {
            return_value___ctype_b_loc_95=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_95)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_94=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_94)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_96=set_errno(22);
            return (signed long int)return_value_set_errno_96;
          }

          do
          {
            tmp_post_97 = count;
            count = count - 1ul;
            if(tmp_post_97 == 0ul)
              break;

            float *vunpack__1__1__1__11__2__data;
            vunpack__1__1__1__11__2__data=va_arg(args, __typeof__(vunpack__1__1__1__11__2__data));
            unsigned long int vunpack__1__1__1__11__2__len;
            if(!(pkt + (signed long int)size >= p + 1l))
            {
              return_value_set_errno_98=set_errno(28);
              return (signed long int)return_value_set_errno_98;
            }

            tmp_post_99 = p;
            p = p + 1l;
            vunpack__1__1__1__11__2__len = (unsigned long int)*tmp_post_99;
            if(!(pkt + (signed long int)size >= p + (signed long int)vunpack__1__1__1__11__2__len))
            {
              return_value_set_errno_100=set_errno(28);
              return (signed long int)return_value_set_errno_100;
            }

            if(vunpack__1__1__1__11__2__data == ((float *)NULL))
              p = p + (signed long int)vunpack__1__1__1__11__2__len;

            else
            {
              sscanf((const char *)p, "%g", vunpack__1__1__1__11__2__data);
              p = p + (signed long int)vunpack__1__1__1__11__2__len;
            }
          }
          while((_Bool)1);
          break;
        }
        case 100:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_101=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_101));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_101;
          }

          else
          {
            return_value___ctype_b_loc_103=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_103)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_102=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_102)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_104=set_errno(22);
            return (signed long int)return_value_set_errno_104;
          }

          do
          {
            tmp_post_105 = count;
            count = count - 1ul;
            if(tmp_post_105 == 0ul)
              break;

            double *vunpack__1__1__1__12__2__data;
            vunpack__1__1__1__12__2__data=va_arg(args, __typeof__(vunpack__1__1__1__12__2__data));
            unsigned long int vunpack__1__1__1__12__2__len;
            if(!(pkt + (signed long int)size >= p + 1l))
            {
              return_value_set_errno_106=set_errno(28);
              return (signed long int)return_value_set_errno_106;
            }

            tmp_post_107 = p;
            p = p + 1l;
            vunpack__1__1__1__12__2__len = (unsigned long int)*tmp_post_107;
            if(!(pkt + (signed long int)size >= p + (signed long int)vunpack__1__1__1__12__2__len))
            {
              return_value_set_errno_108=set_errno(28);
              return (signed long int)return_value_set_errno_108;
            }

            if(vunpack__1__1__1__12__2__data == ((double *)NULL))
              p = p + (signed long int)vunpack__1__1__1__12__2__len;

            else
            {
              sscanf((const char *)p, "%lg", vunpack__1__1__1__12__2__data);
              p = p + (signed long int)vunpack__1__1__1__12__2__len;
            }
          }
          while((_Bool)1);
          break;
        }
        case 120:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_109=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_109));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_109;
          }

          else
          {
            return_value___ctype_b_loc_111=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_111)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_110=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_110)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_112=set_errno(22);
            return (signed long int)return_value_set_errno_112;
          }

          if(!(pkt + (signed long int)size >= p + (signed long int)count))
          {
            return_value_set_errno_113=set_errno(28);
            return (signed long int)return_value_set_errno_113;
          }

          p = p + (signed long int)count;
          break;
        }
        case 88:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_114=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_114));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_114;
          }

          else
          {
            return_value___ctype_b_loc_116=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_116)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_115=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_115)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_117=set_errno(22);
            return (signed long int)return_value_set_errno_117;
          }

          if(!(p + -((signed long int)count) >= pkt))
          {
            return_value_set_errno_118=set_errno(22);
            return (signed long int)return_value_set_errno_118;
          }

          p = p - (signed long int)count;
          break;
        }
        case 64:
        {
          count = (unsigned long int)1;
          if((signed int)*format == 42)
          {
            format = format + 1l;
            return_value_gcc_builtin_va_arg_119=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg_119));
            count = (unsigned long int)return_value_gcc_builtin_va_arg_119;
          }

          else
          {
            return_value___ctype_b_loc_121=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_121)[(signed long int)(signed int)(unsigned int)*format]) == 0))
            {
              count = (unsigned long int)0;
              do
              {
                return_value___ctype_b_loc_120=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_120)[(signed long int)(signed int)(unsigned int)*format]) == 0)
                  break;

                count = count * (unsigned long int)10;
                count = count + (unsigned long int)((signed int)*format - 48);
                format = format + 1l;
              }
              while((_Bool)1);
            }

          }
          if(!((signed long int)count >= 1l))
          {
            return_value_set_errno_122=set_errno(22);
            return (signed long int)return_value_set_errno_122;
          }

          if(!(size >= count))
          {
            return_value_set_errno_123=set_errno(28);
            return (signed long int)return_value_set_errno_123;
          }

          if(!(pkt + (signed long int)count >= p))
          {
            return_value_set_errno_124=set_errno(22);
            return (signed long int)return_value_set_errno_124;
          }

          p = p + (signed long int)(count - (unsigned long int)(p - pkt));
          break;
        }
        default:
        {
          return_value_set_errno_125=set_errno(22);
          return (signed long int)return_value_set_errno_125;
        }
      }
    }
    return p - pkt;
  }
}

// vverbose
// file libslack/err.c line 212
void vverbose(unsigned long int level, const char *format, void **args)
{
  unsigned long int return_value_prog_verbosity_level_5;
  return_value_prog_verbosity_level_5=prog_verbosity_level();
  struct Msg *return_value_prog_out_1;
  const char *return_value_prog_name_2;
  struct Msg *return_value_prog_out_3;
  if(return_value_prog_verbosity_level_5 >= level)
  {
    char mesg[8192l];
    vsnprintf(mesg, (unsigned long int)8192, format, args);
    const char *return_value_prog_name_4;
    return_value_prog_name_4=prog_name();
    if(!(return_value_prog_name_4 == ((const char *)NULL)))
    {
      return_value_prog_out_1=prog_out();
      return_value_prog_name_2=prog_name();
      msg_out(return_value_prog_out_1, "%s: %*s%s\n", return_value_prog_name_2, level, (const void *)"", (const void *)mesg);
    }

    else
    {
      return_value_prog_out_3=prog_out();
      msg_out(return_value_prog_out_3, "%*s%s\n", level, (const void *)"", (const void *)mesg);
    }
  }

}

// write_timeout
// file libslack/fio.c line 246
signed int write_timeout(signed int fd, signed long int sec, signed long int usec)
{
  struct anonymous_10 writefds[1l];
  struct timeval write_timeout__1__timeout[1l];
  signed int return_value_set_errno_1;
  if(!(fd >= 0) || !(sec >= 0l) || !(usec >= 0l))
  {
    return_value_set_errno_1=set_errno(22);
    return return_value_set_errno_1;
  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&writefds[0l].fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    writefds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = writefds[0l].fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    write_timeout__1__timeout[0l].tv_sec = sec;
    write_timeout__1__timeout[0l].tv_usec = usec;
    signed int return_value_select_2;
    return_value_select_2=select(fd + 1, (struct anonymous_10 *)(void *)0, writefds, (struct anonymous_10 *)(void *)0, write_timeout__1__timeout);
    if(!(return_value_select_2 == -1))
    {
      if(return_value_select_2 == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return -1;

    __CPROVER_DUMP_L3:
      ;
      signed int return_value_set_errno_3;
      return_value_set_errno_3=set_errno(110);
      return return_value_set_errno_3;
    }
    return 0;
  }
}

