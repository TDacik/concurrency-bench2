// tag-#anon#ST[ARR16{U64}_U64_'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous_6;

// tag-#anon#ST[ARR2{S32}_S32_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/types.h line 134
struct anonymous_4;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_5;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-blk_io_trace
// file blktrace_api.h line 96
struct blk_io_trace;

// tag-blk_user_trace_setup
// file blktrace_api.h line 122
struct blk_user_trace_setup;

// tag-blktrace_net_hdr
// file blktrace.c line 182
struct blktrace_net_hdr;

// tag-cl_conn
// file blktrace.c line 215
struct cl_conn;

// tag-cl_host
// file blktrace.c line 112
struct cl_host;

// tag-devpath
// file blktrace.c line 91
struct devpath;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-io_info
// file blktrace.c line 115
struct io_info;

// tag-list_head
// file btt/list.h line 34
struct list_head;

// tag-mask_map
// file act_mask.c line 9
struct mask_map;

// tag-mmap_info
// file blktrace.c line 150
struct mmap_info;

// tag-net_server_s
// file blktrace.c line 204
struct net_server_s;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pdc_stats
// file blktrace.c line 86
struct pdc_stats;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statfs
// file /usr/include/x86_64-linux-gnu/bits/statfs.h line 24
struct statfs;

// tag-thread_status
// file blktrace.c line 74
enum thread_status { Th_running=0, Th_leaving=1, Th_error=2 };

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-trace_buf
// file blktrace.c line 134
struct trace_buf;

// tag-tracer
// file blktrace.c line 163
struct tracer;

// tag-tracer_devpath_head
// file blktrace.c line 107
struct tracer_devpath_head;

#ifndef NULL
#define NULL ((void*)0)
#endif

// INIT_LIST_HEAD
// file btt/list.h line 43
static inline void INIT_LIST_HEAD(struct list_head *list);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __h_errno_location
// file /usr/include/netdb.h line 61
extern signed int * __h_errno_location(void);
// __list_add
// file btt/list.h line 55
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_del
// file btt/list.h line 98
static inline void __list_del(struct list_head *prev, struct list_head *next);
// __net_recv_data
// file blktrace.c line 822
static signed int __net_recv_data(signed int fd, void *buf, unsigned int len);
// __process_trace_bufs
// file blktrace.c line 1418
static void __process_trace_bufs(void);
// __sched_cpualloc
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 205
extern struct anonymous_6 * __sched_cpualloc(unsigned long int);
// __sched_cpufree
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 206
extern void __sched_cpufree(struct anonymous_6 *);
// __stop_trace
// file blktrace.c line 783
static signed int __stop_trace(signed int fd);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous, unsigned int *);
// ack_open_close
// file blktrace.c line 921
static void ack_open_close(signed int fd, char *buts_name);
// add_devpath
// file blktrace.c line 1232
static signed int add_devpath(char *path);
// add_trace_buf
// file blktrace.c line 1191
static inline void add_trace_buf(struct devpath *dpp, signed int cpu, struct trace_buf **tbpp);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// alloc_trace_buf
// file blktrace.c line 1139
static inline struct trace_buf * alloc_trace_buf(signed int cpu, signed int bufsize);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// ch_add_connection
// file blktrace.c line 2210
static void ch_add_connection(struct net_server_s *ns, struct cl_host *ch, signed int fd);
// ch_rem_connection
// file blktrace.c line 2231
static void ch_rem_connection(struct net_server_s *ns, struct cl_host *ch, struct cl_conn *nc);
// check_data_endianness
// file blktrace.h line 126
static inline signed int check_data_endianness(unsigned int magic);
// clean_trace_bufs
// file blktrace.c line 1453
static void clean_trace_bufs(void);
// clear_events
// file blktrace.c line 473
static void clear_events(struct pollfd *pfd);
// clearerr
// file /usr/include/stdio.h line 826
extern void clearerr(struct _IO_FILE *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_client_connections
// file blktrace.c line 1045
static void close_client_connections(void);
// close_iop
// file blktrace.c line 1583
static void close_iop(struct io_info *iop);
// close_ios
// file blktrace.c line 1604
static void close_ios(struct tracer *tp);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous, unsigned int);
// decr_entries
// file blktrace.c line 1215
static void decr_entries(signed int handled);
// del_tracers
// file blktrace.c line 1919
static void del_tracers(void);
// device_done
// file blktrace.c line 2283
static void device_done(struct devpath *dpp, signed int ncpus);
// dpp_free
// file blktrace.c line 609
static void dpp_free(struct devpath *dpp);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_tracing
// file blktrace.c line 1956
static void exit_tracing(void);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill_ofname
// file blktrace.c line 1496
static signed int fill_ofname(struct io_info *iop, signed int cpu);
// find_mask_map
// file blktrace.h line 147
extern signed int find_mask_map(char *string);
// flush_subbuf_net
// file blktrace.c line 1285
static signed int flush_subbuf_net(struct trace_buf *tbp);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_tracer_heads
// file blktrace.c line 1153
static void free_tracer_heads(struct devpath *dpp);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_all_drops
// file blktrace.c line 1128
static void get_all_drops(void);
// get_drops
// file blktrace.c line 1100
static signed int get_drops(struct devpath *dpp);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 54
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// handle_args
// file blktrace.c line 2043
static signed int handle_args(signed int argc, char **argv);
// handle_client_data
// file blktrace.c line 2504
static void handle_client_data(struct net_server_s *ns, signed int events);
// handle_list_object
//
signed int handle_list_object(struct tracer_devpath_head *, struct list_head *);
// handle_list_file
// file blktrace.c line 1353
static signed int handle_list_file(struct tracer_devpath_head *hd, struct list_head *list);
// handle_list_net
// file blktrace.c line 1299
static signed int handle_list_net(struct tracer_devpath_head *hd, struct list_head *list);
// handle_mem_failure
// file blktrace.c line 665
static signed int handle_mem_failure(unsigned long int length);
// handle_open_failure
// file blktrace.c line 658
static signed int handle_open_failure(void);
// handle_pfds_object
//
signed int handle_pfds_object(struct tracer *, signed int, signed int);
// handle_pfds_entries
// file blktrace.c line 1770
static signed int handle_pfds_entries(struct tracer *tp, signed int nevs, signed int force_read);
// handle_pfds_file
// file blktrace.c line 1693
static signed int handle_pfds_file(struct tracer *tp, signed int nevs, signed int force_read);
// handle_pfds_netclient
// file blktrace.c line 1736
static signed int handle_pfds_netclient(struct tracer *tp, signed int nevs, signed int force_read);
// handle_sigint
// file blktrace.c line 1969
static void handle_sigint(signed int sig);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// in_addr_eq
// file blktrace.c line 494
static inline signed int in_addr_eq(struct in_addr a, struct in_addr b);
// incr_entries
// file blktrace.c line 1206
static inline void incr_entries(signed int entries_handled);
// increase_limit
// file blktrace.c line 640
static signed int increase_limit(signed int resource, unsigned long int increase);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// init_mmap_info
// file blktrace.c line 595
static void init_mmap_info(struct mmap_info *mip);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// iop_open
// file blktrace.c line 1559
static signed int iop_open(struct io_info *iop, signed int cpu);
// list_add_tail
// file btt/list.h line 86
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_del
// file btt/list.h line 110
static inline void list_del(struct list_head *entry);
// list_empty
// file btt/list.h line 165
static inline signed int list_empty(struct list_head *head);
// list_replace
// file btt/list.h line 223
static inline void list_replace(struct list_head *old, struct list_head *new);
// list_replace_init
// file btt/list.h line 232
static inline void list_replace_init(struct list_head *old, struct list_head *new);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lock_on_cpu
// file blktrace.c line 622
static signed int lock_on_cpu(signed int cpu);
// make_timespec
// file blktrace.c line 517
static inline void make_timespec(struct timespec *tsp, signed long int delta_msec);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 103
extern signed int mlock(const void *, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munlock
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 106
extern signed int munlock(const void *, unsigned long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// my_accept
// file blktrace.c line 707
static signed int my_accept(signed int sockfd, struct sockaddr *addr, unsigned int *addrlen);
// my_fopen
// file blktrace.c line 674
static struct _IO_FILE * my_fopen(const char *path, const char *mode);
// my_mlock
// file blktrace.c line 730
static signed int my_mlock(struct tracer *tp, const void *addr, unsigned long int len);
// my_mmap
// file blktrace.c line 718
static void * my_mmap(void *addr, unsigned long int length, signed int prot, signed int flags, signed int fd, signed long int offset);
// my_open
// file blktrace.c line 685
static signed int my_open(const char *path, signed int flags);
// my_socket
// file blktrace.c line 696
static signed int my_socket(signed int domain, signed int type, signed int protocol);
// nc_add_dpp
// file blktrace.c line 2341
static struct devpath * nc_add_dpp(struct cl_conn *nc, struct blktrace_net_hdr *bnh, signed long int connect_time);
// nc_find_dpp
// file blktrace.c line 2390
static struct devpath * nc_find_dpp(struct cl_conn *nc, struct blktrace_net_hdr *bnh);
// net_add_client_host
// file blktrace.c line 2261
static struct cl_host * net_add_client_host(struct net_server_s *ns, struct sockaddr_in *addr);
// net_add_connection
// file blktrace.c line 2319
static void net_add_connection(struct net_server_s *ns);
// net_ch_remove
// file blktrace.c line 2295
static void net_ch_remove(struct cl_host *ch, signed int ncpus);
// net_client_data
// file blktrace.c line 2435
static signed int net_client_data(struct cl_conn *nc);
// net_client_read_data
// file blktrace.c line 2409
static void net_client_read_data(struct cl_conn *nc, struct devpath *dpp, struct blktrace_net_hdr *bnh);
// net_client_use_send
// file blktrace.c line 484
static inline signed int net_client_use_send(void);
// net_client_use_sendfile
// file blktrace.c line 479
static inline signed int net_client_use_sendfile(void);
// net_close_connection
// file blktrace.c line 602
static void net_close_connection(signed int *fd);
// net_find_client_host
// file blktrace.c line 2246
static struct cl_host * net_find_client_host(struct net_server_s *ns, struct in_addr cl_in_addr);
// net_get_header
// file blktrace.c line 943
static signed int net_get_header(struct cl_conn *nc, struct blktrace_net_hdr *bnh);
// net_recv_data
// file blktrace.c line 847
static signed int net_recv_data(signed int fd, void *buf, unsigned int len);
// net_send_close
// file blktrace.c line 908
static void net_send_close(signed int fd, char *buts_name, signed int drops);
// net_send_data
// file blktrace.c line 855
static signed int net_send_data(signed int fd, void *buf, unsigned int buf_len);
// net_send_drops
// file blktrace.c line 926
static void net_send_drops(signed int fd);
// net_send_header
// file blktrace.c line 874
static signed int net_send_header(signed int fd, signed int cpu, char *buts_name, signed int len);
// net_send_open
// file blktrace.c line 903
static void net_send_open(signed int fd, signed int cpu, char *buts_name);
// net_send_open_close
// file blktrace.c line 895
static void net_send_open_close(signed int fd, signed int cpu, char *buts_name, signed int len);
// net_sendfile
// file blktrace.c line 1470
static signed int net_sendfile(struct io_info *iop);
// net_sendfile_data
// file blktrace.c line 1487
static inline signed int net_sendfile_data(struct tracer *tp, struct io_info *iop);
// net_server
// file blktrace.c line 2568
static signed int net_server(void);
// net_server_handle_connections
// file blktrace.c line 2540
static signed int net_server_handle_connections(struct net_server_s *ns);
// net_setup_addr
// file blktrace.c line 960
static signed int net_setup_addr(void);
// net_setup_client
// file blktrace.c line 999
static signed int net_setup_client(void);
// net_setup_pfds
// file blktrace.c line 2522
static void net_setup_pfds(struct net_server_s *ns);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// open_client_connections
// file blktrace.c line 1026
static signed int open_client_connections(void);
// open_ios
// file blktrace.c line 1627
static signed int open_ios(struct tracer *tp);
// pdc_dr_update
// file blktrace.c line 499
static inline void pdc_dr_update(struct devpath *dpp, signed int cpu, signed int data_read);
// pdc_nev_update
// file blktrace.c line 504
static inline void pdc_nev_update(struct devpath *dpp, signed int cpu, signed int nevents);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_trace_bufs
// file blktrace.c line 1447
static void process_trace_bufs(void);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_3 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_3 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_3 *, union anonymous_0 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_3 *, union anonymous_0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_err
// file blktrace.c line 1463
static inline void read_err(signed int cpu, char *ifn);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// rel_devpaths
// file blktrace.c line 1266
static void rel_devpaths(void);
// run_tracers
// file blktrace.c line 2621
static signed int run_tracers(void);
// sched_setaffinity
// file /usr/include/sched.h line 118
extern signed int sched_setaffinity(signed int, unsigned long int, const struct anonymous_6 *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendfile
// file /usr/include/x86_64-linux-gnu/sys/sendfile.h line 37
extern signed long int sendfile(signed int, signed int, signed long int *, unsigned long int);
// set_vbuf
// file blktrace.c line 1545
static signed int set_vbuf(struct io_info *iop, signed int mode, unsigned long int size);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 73
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_buts
// file blktrace.c line 1060
static void setup_buts(void);
// setup_mmap
// file blktrace.c line 745
static signed int setup_mmap(signed int fd, unsigned int maxlen, struct mmap_info *mip, struct tracer *tp);
// setup_tracer_devpaths
// file blktrace.c line 1167
static signed int setup_tracer_devpaths(void);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// show_stats
// file blktrace.c line 1975
static void show_stats(struct list_head *devpaths);
// show_usage
// file blktrace.c line 509
static void show_usage(char *prog);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_buts
// file blktrace.c line 1086
static void start_buts(void);
// start_tracer
// file blktrace.c line 1855
static signed int start_tracer(signed int cpu);
// start_tracers
// file blktrace.c line 1877
static void start_tracers(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// statfs
// file /usr/include/x86_64-linux-gnu/sys/statfs.h line 35
extern signed int statfs(const char *, struct statfs *);
// stop_tracers
// file blktrace.c line 1897
static void stop_tracers(void);
// strcasecmp
// file /usr/include/strings.h line 116
extern signed int strcasecmp(const char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// t_pthread_cond_wait
// file blktrace.c line 537
static void t_pthread_cond_wait(union anonymous_3 *cond, union anonymous_0 *mutex);
// tb_combine
// file blktrace.c line 1328
static struct trace_buf * tb_combine(struct trace_buf *prev, struct trace_buf *tbp);
// thread_main
// file blktrace.c line 1809
static void * thread_main(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tracer_signal_ready
// file blktrace.c line 561
static void tracer_signal_ready(struct tracer *tp, enum thread_status th_status, signed int status);
// tracer_wait_unblock
// file blktrace.c line 553
static void tracer_wait_unblock(struct tracer *tp);
// unblock_tracers
// file blktrace.c line 545
static void unblock_tracers(void);
// use_tracer_devpaths
// file blktrace.c line 489
static inline signed int use_tracer_devpaths(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// valid_act_opt
// file blktrace.h line 146
extern signed int valid_act_opt(signed int x);
// wait_empty_entries
// file blktrace.c line 1222
static signed int wait_empty_entries(void);
// wait_tracers
// file blktrace.c line 1931
static void wait_tracers(void);
// wait_tracers_leaving
// file blktrace.c line 587
static void wait_tracers_leaving(void);
// wait_tracers_ready
// file blktrace.c line 579
static void wait_tracers_ready(signed int ncpus_started);
// write_data
// file blktrace.c line 792
static signed int write_data(char *buf, signed int len);

struct anonymous_6
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous_4
{
  // __val
  signed int __val[2l];
};

struct anonymous_2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_5
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_3
{
  // __data
  struct anonymous_2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct blk_io_trace
{
  // magic
  unsigned int magic;
  // sequence
  unsigned int sequence;
  // time
  unsigned long long int time;
  // sector
  unsigned long long int sector;
  // bytes
  unsigned int bytes;
  // action
  unsigned int action;
  // pid
  unsigned int pid;
  // device
  unsigned int device;
  // cpu
  unsigned int cpu;
  // error
  unsigned short int error;
  // pdu_len
  unsigned short int pdu_len;
};

struct blk_user_trace_setup
{
  // name
  char name[32l];
  // act_mask
  unsigned short int act_mask;
  // buf_size
  unsigned int buf_size;
  // buf_nr
  unsigned int buf_nr;
  // start_lba
  unsigned long long int start_lba;
  // end_lba
  unsigned long long int end_lba;
  // pid
  unsigned int pid;
};

struct blktrace_net_hdr
{
  // magic
  unsigned int magic;
  // buts_name
  char buts_name[32l];
  // cpu
  unsigned int cpu;
  // max_cpus
  unsigned int max_cpus;
  // len
  unsigned int len;
  // cl_id
  unsigned int cl_id;
  // buf_size
  unsigned int buf_size;
  // buf_nr
  unsigned int buf_nr;
  // page_size
  unsigned int page_size;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct cl_conn
{
  // ch_head
  struct list_head ch_head;
  // ns_head
  struct list_head ns_head;
  // ch
  struct cl_host *ch;
  // fd
  signed int fd;
  // ncpus
  signed int ncpus;
  // connect_time
  signed long int connect_time;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct cl_host
{
  // head
  struct list_head head;
  // conn_list
  struct list_head conn_list;
  // devpaths
  struct list_head devpaths;
  // ns
  struct net_server_s *ns;
  // hostname
  char *hostname;
  // cl_in_addr
  struct in_addr cl_in_addr;
  // connects
  signed int connects;
  // ndevs
  signed int ndevs;
  // cl_opens
  signed int cl_opens;
};

struct devpath
{
  // head
  struct list_head head;
  // path
  char *path;
  // buts_name
  char *buts_name;
  // stats
  struct pdc_stats *stats;
  // fd
  signed int fd;
  // ncpus
  signed int ncpus;
  // drops
  unsigned long long int drops;
  // heads
  struct tracer_devpath_head *heads;
  // ch
  struct cl_host *ch;
  // cl_id
  unsigned int cl_id;
  // cl_connect_time
  signed long int cl_connect_time;
  // ios
  struct io_info *ios;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous_5 __in6_u;
};

struct mmap_info
{
  // fs_buf
  void *fs_buf;
  // fs_size
  unsigned long long int fs_size;
  // fs_max_size
  unsigned long long int fs_max_size;
  // fs_off
  unsigned long long int fs_off;
  // fs_buf_len
  unsigned long long int fs_buf_len;
  // buf_size
  unsigned long int buf_size;
  // buf_nr
  unsigned long int buf_nr;
  // pagesize
  signed int pagesize;
};

struct io_info
{
  // dpp
  struct devpath *dpp;
  // ofp
  struct _IO_FILE *ofp;
  // obuf
  char *obuf;
  // nc
  struct cl_conn *nc;
  // mmap_info
  struct mmap_info mmap_info;
  // ready
  unsigned int ready;
  // data_queued
  unsigned long long int data_queued;
  // ifd
  signed int ifd;
  // ofd
  signed int ofd;
  // ifn
  char ifn[4160l];
  // ofn
  char ofn[4160l];
};

struct mask_map
{
  // mask
  signed int mask;
  // short_form
  char *short_form;
  // long_form
  char *long_form;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct net_server_s
{
  // conn_list
  struct list_head conn_list;
  // ch_list
  struct list_head ch_list;
  // pfds
  struct pollfd *pfds;
  // listen_fd
  signed int listen_fd;
  // connects
  signed int connects;
  // nchs
  signed int nchs;
  // addr
  struct sockaddr_in addr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct pdc_stats
{
  // data_read
  unsigned long long int data_read;
  // nevents
  unsigned long long int nevents;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statfs
{
  // f_type
  signed long int f_type;
  // f_bsize
  signed long int f_bsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_fsid
  struct anonymous_4 f_fsid;
  // f_namelen
  signed long int f_namelen;
  // f_frsize
  signed long int f_frsize;
  // f_flags
  signed long int f_flags;
  // f_spare
  signed long int f_spare[4l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct trace_buf
{
  // head
  struct list_head head;
  // dpp
  struct devpath *dpp;
  // buf
  void *buf;
  // cpu
  signed int cpu;
  // len
  signed int len;
};

struct tracer
{
  // head
  struct list_head head;
  // ios
  struct io_info *ios;
  // pfds
  struct pollfd *pfds;
  // thread
  unsigned long int thread;
  // cpu
  signed int cpu;
  // nios
  signed int nios;
  // status
  volatile signed int status;
  // is_done
  volatile signed int is_done;
};

struct tracer_devpath_head
{
  // mutex
  union anonymous_0 mutex;
  // head
  struct list_head head;
  // prev
  struct trace_buf *prev;
};


// act_mask
// file blktrace.c line 279
static signed int act_mask = (signed int)~0U;
// blktrace_version
// file blktrace.c line 269
static char blktrace_version[6l] = { '2', '.', '0', '.', '0', 0 };
// buf_nr
// file blktrace.c line 289
static unsigned long int buf_nr = (unsigned long int)4;
// buf_size
// file blktrace.c line 288
static unsigned long int buf_size = (unsigned long int)(512 * 1024);
// cl_fds
// file blktrace.c line 324
static signed int *cl_fds;
// data_is_native
// file blktrace.c line 274
signed int data_is_native = -1;
// debugfs_path
// file blktrace.c line 284
static char *debugfs_path = "/sys/kernel/debug";
// devpaths
// file blktrace.c line 293
static struct list_head devpaths;
// devpaths
// file blktrace.c line 293
static struct list_head devpaths = { .next=&devpaths, .prev=&devpaths };
// done
// file blktrace.c line 296
static volatile signed int done;
// dp_cond
// file blktrace.c line 302
static union anonymous_3 dp_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// dp_entries
// file blktrace.c line 304
static volatile signed int dp_entries;
// dp_mutex
// file blktrace.c line 303
static union anonymous_0 dp_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// handle_list
// file blktrace.c line 327
static signed int (*handle_list)(struct tracer_devpath_head *, struct list_head *);
// handle_pfds
// file blktrace.c line 326
static signed int (*handle_pfds)(struct tracer *, signed int, signed int);
// hostname
// file blktrace.c line 320
static char hostname[64l];
// hostname_addr
// file blktrace.c line 319
static struct sockaddr_in hostname_addr;
// kill_running_trace
// file blktrace.c line 280
static signed int kill_running_trace;
// l_opts
// file blktrace.c line 330
static struct option l_opts[18l] = { { .name="dev", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="input-devs", .has_arg=1, .flag=(signed int *)(void *)0, .val=73 },
    { .name="act-mask", .has_arg=1, .flag=(signed int *)(void *)0, .val=97 },
    { .name="set-mask", .has_arg=1, .flag=(signed int *)(void *)0, .val=65 },
    { .name="relay", .has_arg=1, .flag=(signed int *)(void *)0, .val=114 },
    { .name="output", .has_arg=1, .flag=(signed int *)(void *)0, .val=111 },
    { .name="kill", .has_arg=0, .flag=(signed int *)(void *)0, .val=107 },
    { .name="stopwatch", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name="buffer-size", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="num-sub-buffers", .has_arg=1, .flag=(signed int *)(void *)0, .val=110 },
    { .name="output-dir", .has_arg=1, .flag=(signed int *)(void *)0, .val=68 },
    { .name="listen", .has_arg=0, .flag=(signed int *)(void *)0, .val=108 },
    { .name="host", .has_arg=1, .flag=(signed int *)(void *)0, .val=104 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="no-sendfile", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// mask_maps
// file act_mask.c line 15
static struct mask_map mask_maps[16l] = { { .mask=1, .short_form="READ", .long_form="BLK_TC_READ" },
    { .mask=2, .short_form="WRITE", .long_form="BLK_TC_WRITE" },
    { .mask=4, .short_form="FLUSH", .long_form="BLK_TC_FLUSH" },
    { .mask=8, .short_form="SYNC", .long_form="BLK_TC_SYNC" },
    { .mask=16, .short_form="QUEUE", .long_form="BLK_TC_QUEUE" },
    { .mask=32, .short_form="REQUEUE", .long_form="BLK_TC_REQUEUE" },
    { .mask=64, .short_form="ISSUE", .long_form="BLK_TC_ISSUE" },
    { .mask=128, .short_form="COMPLETE", .long_form="BLK_TC_COMPLETE" },
    { .mask=256, .short_form="FS", .long_form="BLK_TC_FS" },
    { .mask=512, .short_form="PC", .long_form="BLK_TC_PC" },
    { .mask=1024, .short_form="NOTIFY", .long_form="BLK_TC_NOTIFY" },
    { .mask=2048, .short_form="AHEAD", .long_form="BLK_TC_AHEAD" },
    { .mask=4096, .short_form="META", .long_form="BLK_TC_META" },
    { .mask=8192, .short_form="DISCARD", .long_form="BLK_TC_DISCARD" },
    { .mask=16384, .short_form="DRV_DATA", .long_form="BLK_TC_DRV_DATA" },
    { .mask=32768, .short_form="FUA", .long_form="BLK_TC_FUA" } };
// mt_cond
// file blktrace.c line 309
static union anonymous_3 mt_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mt_mutex
// file blktrace.c line 310
static union anonymous_0 mt_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ncpus
// file blktrace.c line 277
static signed int ncpus;
// ndevs
// file blktrace.c line 276
static signed int ndevs;
// net_mode
// file blktrace.c line 323
static signed int net_mode;
// net_port
// file blktrace.c line 321
static signed int net_port = 8462;
// net_use_sendfile
// file blktrace.c line 322
static signed int net_use_sendfile = 1;
// nthreads_error
// file blktrace.c line 313
static volatile signed int nthreads_error;
// nthreads_leaving
// file blktrace.c line 312
static volatile signed int nthreads_leaving;
// nthreads_running
// file blktrace.c line 311
static volatile signed int nthreads_running;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// output_dir
// file blktrace.c line 286
static char *output_dir;
// output_name
// file blktrace.c line 285
static char *output_name;
// pagesize
// file blktrace.c line 278
static signed int pagesize;
// pfp
// file blktrace.c line 291
static struct _IO_FILE *pfp;
// piped_output
// file blktrace.c line 282
static signed int piped_output;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stop_watch
// file blktrace.c line 281
static signed int stop_watch;
// tracers
// file blktrace.c line 294
static struct list_head tracers;
// tracers
// file blktrace.c line 294
static struct list_head tracers = { .next=&tracers, .prev=&tracers };
// tracers_run
// file blktrace.c line 314
static volatile signed int tracers_run;
// usage_str
// file blktrace.c line 438
static char usage_str[1413l] = { '\n', '\n', '-', 'd', ' ', '<', 'd', 'e', 'v', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'd', 'e', 'v', '=', '<', 'd', 'e', 'v', '>', '\n', '[', ' ', '-', 'r', ' ', '<', 'd', 'e', 'b', 'u', 'g', 'f', 's', ' ', 'p', 'a', 't', 'h', '>', ' ', ' ', '|', ' ', '-', '-', 'r', 'e', 'l', 'a', 'y', '=', '<', 'd', 'e', 'b', 'u', 'g', 'f', 's', ' ', 'p', 'a', 't', 'h', '>', ' ', ']', '\n', '[', ' ', '-', 'o', ' ', '<', 'f', 'i', 'l', 'e', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'o', 'u', 't', 'p', 'u', 't', '=', '<', 'f', 'i', 'l', 'e', '>', ']', '\n', '[', ' ', '-', 'D', ' ', '<', 'd', 'i', 'r', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'o', 'u', 't', 'p', 'u', 't', '-', 'd', 'i', 'r', '=', '<', 'd', 'i', 'r', '>', '\n', '[', ' ', '-', 'w', ' ', '<', 't', 'i', 'm', 'e', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 's', 't', 'o', 'p', 'w', 'a', 't', 'c', 'h', '=', '<', 't', 'i', 'm', 'e', '>', ']', '\n', '[', ' ', '-', 'a', ' ', '<', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'f', 'i', 'e', 'l', 'd', '>', ' ', ' ', '|', ' ', '-', '-', 'a', 'c', 't', '-', 'm', 'a', 's', 'k', '=', '<', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'f', 'i', 'e', 'l', 'd', '>', ']', '\n', '[', ' ', '-', 'A', ' ', '<', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'm', 'a', 's', 'k', '>', ' ', ' ', ' ', '|', ' ', '-', '-', 's', 'e', 't', '-', 'm', 'a', 's', 'k', '=', '<', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'm', 'a', 's', 'k', '>', ']', '\n', '[', ' ', '-', 'b', ' ', '<', 's', 'i', 'z', 'e', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'b', 'u', 'f', 'f', 'e', 'r', '-', 's', 'i', 'z', 'e', ']', '\n', '[', ' ', '-', 'n', ' ', '<', 'n', 'u', 'm', 'b', 'e', 'r', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'n', 'u', 'm', '-', 's', 'u', 'b', '-', 'b', 'u', 'f', 'f', 'e', 'r', 's', '=', '<', 'n', 'u', 'm', 'b', 'e', 'r', '>', ']', '\n', '[', ' ', '-', 'l', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'l', 'i', 's', 't', 'e', 'n', ']', '\n', '[', ' ', '-', 'h', ' ', '<', 'h', 'o', 's', 't', 'n', 'a', 'm', 'e', '>', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'h', 'o', 's', 't', '=', '<', 'h', 'o', 's', 't', 'n', 'a', 'm', 'e', '>', ']', '\n', '[', ' ', '-', 'p', ' ', '<', 'p', 'o', 'r', 't', ' ', 'n', 'u', 'm', 'b', 'e', 'r', '>', ' ', ' ', ' ', '|', ' ', '-', '-', 'p', 'o', 'r', 't', '=', '<', 'p', 'o', 'r', 't', ' ', 'n', 'u', 'm', 'b', 'e', 'r', '>', ']', '\n', '[', ' ', '-', 's', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'n', 'o', '-', 's', 'e', 'n', 'd', 'f', 'i', 'l', 'e', ']', '\n', '[', ' ', '-', 'I', ' ', '<', 'd', 'e', 'v', 's', ' ', 'f', 'i', 'l', 'e', '>', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'i', 'n', 'p', 'u', 't', '-', 'd', 'e', 'v', 's', '=', '<', 'd', 'e', 'v', 's', ' ', 'f', 'i', 'l', 'e', '>', ']', '\n', '[', ' ', '-', 'v', ' ', '<', 'v', 'e', 'r', 's', 'i', 'o', 'n', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', ']', '\n', '[', ' ', '-', 'V', ' ', '<', 'v', 'e', 'r', 's', 'i', 'o', 'n', '>', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '|', ' ', '-', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', ']', '\n', '\t', '-', 'd', ' ', 'U', 's', 'e', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'd', 'e', 'v', 'i', 'c', 'e', '.', ' ', 'M', 'a', 'y', ' ', 'a', 'l', 's', 'o', ' ', 'b', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 'l', 'a', 's', 't', ' ', 'a', 'f', 't', 'e', 'r', ' ', 'o', 'p', 't', 'i', 'o', 'n', 's', '\n', '\t', '-', 'r', ' ', 'P', 'a', 't', 'h', ' ', 't', 'o', ' ', 'm', 'o', 'u', 'n', 't', 'e', 'd', ' ', 'd', 'e', 'b', 'u', 'g', 'f', 's', ',', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', 's', ' ', 't', 'o', ' ', '/', 's', 'y', 's', '/', 'k', 'e', 'r', 'n', 'e', 'l', '/', 'd', 'e', 'b', 'u', 'g', '\n', '\t', '-', 'o', ' ', 'F', 'i', 'l', 'e', '(', 's', ')', ' ', 't', 'o', ' ', 's', 'e', 'n', 'd', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 't', 'o', '\n', '\t', '-', 'D', ' ', 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 't', 'o', ' ', 'p', 'r', 'e', 'p', 'e', 'n', 'd', ' ', 't', 'o', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 'f', 'i', 'l', 'e', ' ', 'n', 'a', 'm', 'e', 's', '\n', '\t', '-', 'w', ' ', 'S', 't', 'o', 'p', ' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 't', 'i', 'm', 'e', ',', ' ', 'i', 'n', ' ', 's', 'e', 'c', 'o', 'n', 'd', 's', '\n', '\t', '-', 'a', ' ', 'O', 'n', 'l', 'y', ' ', 't', 'r', 'a', 'c', 'e', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'a', 'c', 't', 'i', 'o', 'n', 's', '.', ' ', 'S', 'e', 'e', ' ', 'd', 'o', 'c', 'u', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', '\n', '\t', '-', 'A', ' ', 'G', 'i', 'v', 'e', ' ', 't', 'r', 'a', 'c', 'e', ' ', 'm', 'a', 's', 'k', ' ', 'a', 's', ' ', 'a', ' ', 's', 'i', 'n', 'g', 'l', 'e', ' ', 'v', 'a', 'l', 'u', 'e', '.', ' ', 'S', 'e', 'e', ' ', 'd', 'o', 'c', 'u', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', '\n', '\t', '-', 'b', ' ', 'S', 'u', 'b', ' ', 'b', 'u', 'f', 'f', 'e', 'r', ' ', 's', 'i', 'z', 'e', ' ', 'i', 'n', ' ', 'K', 'i', 'B', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', '5', '1', '2', ')', '\n', '\t', '-', 'n', ' ', 'N', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 's', 'u', 'b', ' ', 'b', 'u', 'f', 'f', 'e', 'r', 's', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', '4', ')', '\n', '\t', '-', 'l', ' ', 'R', 'u', 'n', ' ', 'i', 'n', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'l', 'i', 's', 't', 'e', 'n', ' ', 'm', 'o', 'd', 'e', ' ', '(', 'b', 'l', 'k', 't', 'r', 'a', 'c', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', ')', '\n', '\t', '-', 'h', ' ', 'R', 'u', 'n', ' ', 'i', 'n', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'm', 'o', 'd', 'e', ',', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 'h', 'o', 's', 't', '\n', '\t', '-', 'p', ' ', 'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'p', 'o', 'r', 't', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', '8', '4', '6', '2', ')', '\n', '\t', '-', 's', ' ', 'M', 'a', 'k', 'e', ' ', 't', 'h', 'e', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'N', 'O', 'T', ' ', 'u', 's', 'e', ' ', 's', 'e', 'n', 'd', 'f', 'i', 'l', 'e', '(', ')', ' ', 't', 'o', ' ', 't', 'r', 'a', 'n', 's', 'f', 'e', 'r', ' ', 'd', 'a', 't', 'a', '\n', '\t', '-', 'I', ' ', 'A', 'd', 'd', ' ', 'd', 'e', 'v', 'i', 'c', 'e', 's', ' ', 'f', 'o', 'u', 'n', 'd', ' ', 'i', 'n', ' ', '<', 'd', 'e', 'v', 's', ' ', 'f', 'i', 'l', 'e', '>', '\n', '\t', '-', 'v', ' ', 'P', 'r', 'i', 'n', 't', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'i', 'n', 'f', 'o', '\n', '\t', '-', 'V', ' ', 'P', 'r', 'i', 'n', 't', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'i', 'n', 'f', 'o', '\n', '\n', 0 };

// INIT_LIST_HEAD
// file btt/list.h line 43
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->next = list;
  list->prev = list;
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __list_add
// file btt/list.h line 55
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_del
// file btt/list.h line 98
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// __net_recv_data
// file blktrace.c line 822
static signed int __net_recv_data(signed int fd, void *buf, unsigned int len)
{
  unsigned int bytes_left = len;
  while(done == 0 && !(bytes_left == 0u))
  {
    signed int ret;
    signed long int return_value_recv_1;
    return_value_recv_1=recv(fd, buf, (unsigned long int)bytes_left, 256);
    ret = (signed int)return_value_recv_1;
    if(ret == 0)
      break;

    else
      if(!(ret >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 11)
        {
          usleep((unsigned int)50);
          continue;
        }

        perror("server: net_recv_data: recv failed");
        break;
      }

      else
      {
        buf = buf + (signed long int)ret;
        bytes_left = bytes_left - (unsigned int)ret;
      }
  }
  return (signed int)(len - bytes_left);
}

// __process_trace_bufs
// file blktrace.c line 1418
static void __process_trace_bufs(void)
{
  signed int cpu;
  struct list_head *p;
  struct list_head list;
  signed int handled = 0;
  p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    struct tracer_devpath_head *hd = dpp->heads;
    cpu = 0;
    for( ; !(cpu >= ncpus); hd = hd + 1l)
    {
      pthread_mutex_lock(&hd->mutex);
      signed int return_value_list_empty_2;
      return_value_list_empty_2=list_empty(&hd->head);
      if(!(return_value_list_empty_2 == 0))
        pthread_mutex_unlock(&hd->mutex);

      else
      {
        list_replace_init(&hd->head, &list);
        pthread_mutex_unlock(&hd->mutex);
        signed int return_value;
        return_value=handle_list(hd, &list);
        handled = handled + return_value;
      }
      cpu = cpu + 1;
    }
  }
  if(!(handled == 0))
    decr_entries(handled);

}

// __stop_trace
// file blktrace.c line 783
static signed int __stop_trace(signed int fd)
{
  ioctl(fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(117 << 0) | (unsigned int)(0 << 0 + 8 + 8)));
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(118 << 0) | (unsigned int)(0 << 0 + 8 + 8)));
  return return_value_ioctl_1;
}

// ack_open_close
// file blktrace.c line 921
static void ack_open_close(signed int fd, char *buts_name)
{
  net_send_header(fd, 0, buts_name, 2);
}

// add_devpath
// file blktrace.c line 1232
static signed int add_devpath(char *path)
{
  signed int fd;
  struct devpath *dpp;
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *tmp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    tmp = tmp_statement_expression_1;
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(tmp->path, path);
    if(return_value_strcmp_2 == 0)
      return 0;

  }
  fd=my_open(path, 00 | 04000);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    fprintf(stderr, "Invalid path %s specified: %d/%s\n", path, *return_value___errno_location_3, return_value_strerror_5);
    return 1;
  }

  void *return_value_malloc_6;
  return_value_malloc_6=malloc(sizeof(struct devpath) /*96ul*/ );
  dpp = (struct devpath *)return_value_malloc_6;
  memset((void *)dpp, 0, sizeof(struct devpath) /*96ul*/ );
  dpp->path=strdup(path);
  dpp->fd = fd;
  ndevs = ndevs + 1;
  list_add_tail(&dpp->head, &devpaths);
  return 0;
}

// add_trace_buf
// file blktrace.c line 1191
static inline void add_trace_buf(struct devpath *dpp, signed int cpu, struct trace_buf **tbpp)
{
  struct trace_buf *tbp = *tbpp;
  struct tracer_devpath_head *hd = &dpp->heads[(signed long int)cpu];
  tbp->dpp = dpp;
  pthread_mutex_lock(&hd->mutex);
  list_add_tail(&tbp->head, &hd->head);
  pthread_mutex_unlock(&hd->mutex);
  *tbpp=alloc_trace_buf(cpu, (signed int)buf_size);
}

// alloc_trace_buf
// file blktrace.c line 1139
static inline struct trace_buf * alloc_trace_buf(signed int cpu, signed int bufsize)
{
  struct trace_buf *tbp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct trace_buf) /*40ul*/  + (unsigned long int)bufsize);
  tbp = (struct trace_buf *)return_value_malloc_1;
  INIT_LIST_HEAD(&tbp->head);
  tbp->len = 0;
  tbp->buf = (void *)(tbp + (signed long int)1);
  tbp->cpu = cpu;
  tbp->dpp = (struct devpath *)(void *)0;
  return tbp;
}

// ch_add_connection
// file blktrace.c line 2210
static void ch_add_connection(struct net_server_s *ns, struct cl_host *ch, signed int fd)
{
  struct cl_conn *nc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cl_conn) /*56ul*/ );
  nc = (struct cl_conn *)return_value_malloc_1;
  memset((void *)nc, 0, sizeof(struct cl_conn) /*56ul*/ );
  time(&nc->connect_time);
  nc->ch = ch;
  nc->fd = fd;
  nc->ncpus = -1;
  list_add_tail(&nc->ch_head, &ch->conn_list);
  ch->connects = ch->connects + 1;
  list_add_tail(&nc->ns_head, &ns->conn_list);
  ns->connects = ns->connects + 1;
  void *return_value_realloc_2;
  return_value_realloc_2=realloc((void *)ns->pfds, (unsigned long int)(ns->connects + 1) * sizeof(struct pollfd) /*8ul*/ );
  ns->pfds = (struct pollfd *)return_value_realloc_2;
}

// ch_rem_connection
// file blktrace.c line 2231
static void ch_rem_connection(struct net_server_s *ns, struct cl_host *ch, struct cl_conn *nc)
{
  net_close_connection(&nc->fd);
  list_del(&nc->ch_head);
  ch->connects = ch->connects - 1;
  list_del(&nc->ns_head);
  ns->connects = ns->connects - 1;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)ns->pfds, (unsigned long int)(ns->connects + 1) * sizeof(struct pollfd) /*8ul*/ );
  ns->pfds = (struct pollfd *)return_value_realloc_1;
  free((void *)nc);
}

// check_data_endianness
// file blktrace.h line 126
static inline signed int check_data_endianness(unsigned int magic)
{
  if((0xffffff00 & magic) == 1700885504u)
  {
    data_is_native = 1;
    return 0;
  }

  else
  {
    magic=__bswap_32(magic);
    if((0xffffff00 & magic) == 1700885504u)
    {
      data_is_native = 0;
      return 0;
    }

    else
      return 1;
  }
}

// clean_trace_bufs
// file blktrace.c line 1453
static void clean_trace_bufs(void)
{
  while(!(dp_entries == 0))
    __process_trace_bufs();
}

// clear_events
// file blktrace.c line 473
static void clear_events(struct pollfd *pfd)
{
  pfd->events = (signed short int)0;
  pfd->revents = (signed short int)0;
}

// close_client_connections
// file blktrace.c line 1045
static void close_client_connections(void)
{
  if(!(cl_fds == ((signed int *)NULL)))
  {
    signed int cpu;
    signed int *fdp;
    cpu = 0;
    fdp = cl_fds;
    for( ; !(cpu >= ncpus); fdp = fdp + 1l)
    {
      if(*fdp >= 0)
      {
        net_send_drops(*fdp);
        net_close_connection(fdp);
      }

      cpu = cpu + 1;
    }
    free((void *)cl_fds);
  }

}

// close_iop
// file blktrace.c line 1583
static void close_iop(struct io_info *iop)
{
  struct mmap_info *mip = &iop->mmap_info;
  if(!(mip->fs_buf == NULL))
    munmap(mip->fs_buf, mip->fs_buf_len);

  if(piped_output == 0)
  {
    signed int return_value_fileno_4;
    return_value_fileno_4=fileno(iop->ofp);
    signed int return_value_ftruncate_5;
    return_value_ftruncate_5=ftruncate(return_value_fileno_4, (signed long int)mip->fs_size);
    if(!(return_value_ftruncate_5 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "Ignoring err: ftruncate(%s): %d/%s\n", (const void *)iop->ofn, *return_value___errno_location_1, return_value_strerror_3);
    }

  }

  if(!(iop->ofp == ((struct _IO_FILE *)NULL)))
    fclose(iop->ofp);

  if(!(iop->obuf == ((char *)NULL)))
    free((void *)iop->obuf);

}

// close_ios
// file blktrace.c line 1604
static void close_ios(struct tracer *tp)
{
  while(tp->nios >= 1)
  {
    struct io_info *iop;
    tp->nios = tp->nios - 1;
    iop = &tp->ios[(signed long int)tp->nios];
    signed int return_value_get_drops_1;
    return_value_get_drops_1=get_drops(iop->dpp);
    iop->dpp->drops = (unsigned long long int)return_value_get_drops_1;
    if(iop->ifd >= 0)
      close(iop->ifd);

    if(!(iop->ofp == ((struct _IO_FILE *)NULL)))
      close_iop(iop);

    else
      if(iop->ofd >= 0)
      {
        struct devpath *dpp = iop->dpp;
        net_send_close(iop->ofd, dpp->buts_name, (signed int)dpp->drops);
        net_close_connection(&iop->ofd);
      }

  }
  free((void *)tp->ios);
  free((void *)tp->pfds);
}

// decr_entries
// file blktrace.c line 1215
static void decr_entries(signed int handled)
{
  pthread_mutex_lock(&dp_mutex);
  dp_entries = dp_entries - handled;
  pthread_mutex_unlock(&dp_mutex);
}

// del_tracers
// file blktrace.c line 1919
static void del_tracers(void)
{
  struct list_head *p;
  struct list_head *q;
  p = (&tracers)->next;
  q = p->next;
  struct tracer *tmp_statement_expression_1;
  for( ; !(p == &tracers); q = p->next)
  {
    struct tracer *tp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct tracer *)((char *)__mptr - (signed long int)(unsigned long int)&((struct tracer *)0)->head);
    tp = tmp_statement_expression_1;
    list_del(&tp->head);
    free((void *)tp);
    p = q;
  }
}

// device_done
// file blktrace.c line 2283
static void device_done(struct devpath *dpp, signed int ncpus)
{
  signed int cpu;
  struct io_info *iop;
  cpu = 0;
  iop = dpp->ios;
  for( ; !(cpu >= ncpus); iop = iop + 1l)
  {
    close_iop(iop);
    cpu = cpu + 1;
  }
  list_del(&dpp->head);
  dpp_free(dpp);
}

// dpp_free
// file blktrace.c line 609
static void dpp_free(struct devpath *dpp)
{
  if(!(dpp->stats == ((struct pdc_stats *)NULL)))
    free((void *)dpp->stats);

  if(!(dpp->ios == ((struct io_info *)NULL)))
    free((void *)dpp->ios);

  if(!(dpp->path == ((char *)NULL)))
    free((void *)dpp->path);

  if(!(dpp->buts_name == ((char *)NULL)))
    free((void *)dpp->buts_name);

  free((void *)dpp);
}

// exit_tracing
// file blktrace.c line 1956
static void exit_tracing(void)
{
  signal(2, (void (*)(signed int))1);
  signal(1, (void (*)(signed int))1);
  signal(15, (void (*)(signed int))1);
  signal(14, (void (*)(signed int))1);
  stop_tracers();
  wait_tracers();
  del_tracers();
  rel_devpaths();
}

// fill_ofname
// file blktrace.c line 1496
static signed int fill_ofname(struct io_info *iop, signed int cpu)
{
  signed int len;
  struct stat sb;
  char *dst = iop->ofn;
  if(!(output_dir == ((char *)NULL)))
    len=snprintf(iop->ofn, sizeof(char [4160l]) /*4160ul*/ , "%s/", output_dir);

  else
    len=snprintf(iop->ofn, sizeof(char [4160l]) /*4160ul*/ , "./");
  if(net_mode == 1)
  {
    struct cl_conn *nc = iop->nc;
    signed int return_value_sprintf_1;
    return_value_sprintf_1=sprintf(dst + (signed long int)len, "%s-", nc->ch->hostname);
    len = len + return_value_sprintf_1;
    struct tm *return_value_gmtime_2;
    return_value_gmtime_2=gmtime(&iop->dpp->cl_connect_time);
    unsigned long int return_value_strftime_3;
    return_value_strftime_3=strftime(dst + (signed long int)len, (unsigned long int)64, "%F-%T/", return_value_gmtime_2);
    len = len + (signed int)return_value_strftime_3;
  }

  signed int return_value_stat_13;
  return_value_stat_13=stat(iop->ofn, &sb);
  signed int *return_value___errno_location_11;
  if(!(return_value_stat_13 >= 0))
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    if(!(*return_value___errno_location_7 == 2))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      fprintf(stderr, "Destination dir %s stat failed: %d/%s\n", (const void *)iop->ofn, *return_value___errno_location_4, return_value_strerror_6);
      return 1;
    }

    signed int return_value_mkdir_12;
    return_value_mkdir_12=mkdir(iop->ofn, (unsigned int)0755);
    if(!(return_value_mkdir_12 >= 0))
    {
      return_value___errno_location_11=__errno_location();
      if(!(*return_value___errno_location_11 == 17))
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        char *return_value_strerror_10;
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        fprintf(stderr, "Destination dir %s can't be made: %d/%s\n", (const void *)iop->ofn, *return_value___errno_location_8, return_value_strerror_10);
        return 1;
      }

    }

  }

  if(!(output_name == ((char *)NULL)))
    snprintf(iop->ofn + (signed long int)len, sizeof(char [4160l]) /*4160ul*/ , "%s.blktrace.%d", output_name, cpu);

  else
    snprintf(iop->ofn + (signed long int)len, sizeof(char [4160l]) /*4160ul*/ , "%s.blktrace.%d", iop->dpp->buts_name, cpu);
  return 0;
}

// find_mask_map
// file blktrace.h line 147
extern signed int find_mask_map(char *string)
{
  unsigned int i = (unsigned int)0;
  signed int return_value_strcasecmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  for( ; !((unsigned long int)i >= 16ul); i = i + 1u)
  {
    return_value_strcasecmp_1=strcasecmp((&mask_maps[(signed long int)i])->short_form, string);
    if(return_value_strcasecmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcasecmp_2=strcasecmp((&mask_maps[(signed long int)i])->long_form, string);
      tmp_if_expr_3 = !(return_value_strcasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return mask_maps[(signed long int)i].mask;

  }
  return -1;
}

// flush_subbuf_net
// file blktrace.c line 1285
static signed int flush_subbuf_net(struct trace_buf *tbp)
{
  signed int fd = cl_fds[(signed long int)tbp->cpu];
  struct devpath *dpp = tbp->dpp;
  signed int return_value_net_send_header_2;
  return_value_net_send_header_2=net_send_header(fd, tbp->cpu, dpp->buts_name, tbp->len);
  signed int return_value_net_send_data_1;
  if(!(return_value_net_send_header_2 == 0))
    return 1;

  else
  {
    return_value_net_send_data_1=net_send_data(fd, tbp->buf, (unsigned int)tbp->len);
    if(!(return_value_net_send_data_1 == tbp->len))
      return 1;

  }
  return 0;
}

// free_tracer_heads
// file blktrace.c line 1153
static void free_tracer_heads(struct devpath *dpp)
{
  signed int cpu;
  struct tracer_devpath_head *hd;
  cpu = 0;
  hd = dpp->heads;
  for( ; !(cpu >= ncpus); hd = hd + 1l)
  {
    if(!(hd->prev == ((struct trace_buf *)NULL)))
      free((void *)hd->prev);

    pthread_mutex_destroy(&hd->mutex);
    cpu = cpu + 1;
  }
  free((void *)dpp->heads);
}

// get_all_drops
// file blktrace.c line 1128
static void get_all_drops(void)
{
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    signed int return_value_get_drops_2;
    return_value_get_drops_2=get_drops(dpp);
    dpp->drops = (unsigned long long int)return_value_get_drops_2;
  }
}

// get_drops
// file blktrace.c line 1100
static signed int get_drops(struct devpath *dpp)
{
  signed int fd;
  signed int drops = 0;
  char fn[4160l];
  char tmp[256l];
  snprintf(fn, sizeof(char [4160l]) /*4160ul*/ , "%s/block/%s/dropped", debugfs_path, dpp->buts_name);
  fd=my_open(fn, 00);
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  signed long int return_value_read_8;
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(!(*return_value___errno_location_4 == 2))
    {
      return_value___errno_location_1=__errno_location();
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      fprintf(stderr, "Could not open %s: %d/%s\n", (const void *)fn, *return_value___errno_location_1, return_value_strerror_3);
    }

    return 0;
  }

  else
  {
    return_value_read_8=read(fd, (void *)tmp, sizeof(char [256l]) /*256ul*/ );
    if(!(return_value_read_8 >= 0l))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      fprintf(stderr, "Could not read %s: %d/%s\n", (const void *)fn, *return_value___errno_location_5, return_value_strerror_7);
    }

    else
      drops=atoi(tmp);
  }
  close(fd);
  return drops;
}

// handle_args
// file blktrace.c line 2043
static signed int handle_args(signed int argc, char **argv)
{
  signed int c;
  signed int i;
  struct statfs st;
  signed int act_mask_tmp = 0;
  signed int return_value_sscanf_1;
  _Bool tmp_if_expr_3;
  signed int return_value_valid_act_opt_2;
  signed int return_value_add_devpath_4;
  char dev_line[256l];
  struct _IO_FILE *ifp;
  signed int return_value_fscanf_5;
  do
  {
    c=getopt_long(argc, argv, "d:a:A:r:o:kw:vVb:n:D:lh:p:sI:", l_opts, (signed int *)(void *)0);
    if(!(c >= 0))
      break;

    switch(c)
    {
      case 97:
      {
        i=find_mask_map(optarg);
        if(!(i >= 0))
        {
          fprintf(stderr, "Invalid action mask %s\n", optarg);
          return 1;
        }

        act_mask_tmp = act_mask_tmp | i;
        break;
      }
      case 65:
      {
        return_value_sscanf_1=sscanf(optarg, "%x", &i);
        if(!(return_value_sscanf_1 == 1))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_valid_act_opt_2=valid_act_opt(i);
          tmp_if_expr_3 = !(return_value_valid_act_opt_2 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          fprintf(stderr, "Invalid set action mask %s/0x%x\n", optarg, i);
          return 1;
        }

        act_mask_tmp = i;
        break;
      }
      case 100:
      {
        return_value_add_devpath_4=add_devpath(optarg);
        if(!(return_value_add_devpath_4 == 0))
          return 1;

        break;
      }
      case 73:
      {
        ifp=my_fopen(optarg, "r");
        if(ifp == ((struct _IO_FILE *)NULL))
        {
          fprintf(stderr, "Invalid file for devices %s\n", optarg);
          return 1;
        }

        do
        {
          return_value_fscanf_5=fscanf(ifp, "%s\n", (const void *)dev_line);
          if(!(return_value_fscanf_5 == 1))
            break;

          signed int return_value_add_devpath_6;
          return_value_add_devpath_6=add_devpath(dev_line);
          if(!(return_value_add_devpath_6 == 0))
          {
            fclose(ifp);
            return 1;
          }

        }
        while((_Bool)1);
        fclose(ifp);
        break;
      }
      case 114:
      {
        debugfs_path = optarg;
        break;
      }
      case 111:
      {
        output_name = optarg;
        break;
      }
      case 107:
      {
        kill_running_trace = 1;
        break;
      }
      case 119:
      {
        stop_watch=atoi(optarg);
        if(!(stop_watch >= 1))
        {
          fprintf(stderr, "Invalid stopwatch value (%d secs)\n", stop_watch);
          return 1;
        }

        break;
      }
      case 86:

      case 118:
      {
        printf("%s version %s\n", argv[(signed long int)0], (const void *)blktrace_version);
        exit(0);
      }
      case 98:
      {
        buf_size=strtoul(optarg, (char ** restrict )(void *)0, 10);
        if(buf_size >= 16385ul || !(buf_size >= 1ul))
        {
          fprintf(stderr, "Invalid buffer size (%lu)\n", buf_size);
          return 1;
        }

        buf_size = buf_size << 10;
        break;
      }
      case 110:
      {
        buf_nr=strtoul(optarg, (char ** restrict )(void *)0, 10);
        if(!(buf_nr >= 1ul))
        {
          fprintf(stderr, "Invalid buffer nr (%lu)\n", buf_nr);
          return 1;
        }

        break;
      }
      case 68:
      {
        output_dir = optarg;
        break;
      }
      case 104:
      {
        net_mode = 2;
        memset((void *)hostname, 0, sizeof(char [64l]) /*64ul*/ );
        strncpy(hostname, optarg, sizeof(char [64l]) /*64ul*/ );
        hostname[(signed long int)(sizeof(char [64l]) /*64ul*/  - (unsigned long int)1)] = (char)0;
        break;
      }
      case 108:
      {
        net_mode = 1;
        break;
      }
      case 112:
      {
        net_port=atoi(optarg);
        break;
      }
      case 115:
      {
        net_use_sendfile = 0;
        break;
      }
      default:
      {
        show_usage(argv[(signed long int)0]);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  signed int tmp_post_7;
  signed int return_value_add_devpath_8;
  while(!(optind >= argc))
  {
    tmp_post_7 = optind;
    optind = optind + 1;
    return_value_add_devpath_8=add_devpath(argv[(signed long int)tmp_post_7]);
    if(!(return_value_add_devpath_8 == 0))
      return 1;

  }
  signed int return_value_net_setup_addr_13;
  signed int return_value_net_client_use_send_17;
  _Bool tmp_if_expr_16;
  signed int return_value_strcmp_15;
  if(ndevs == 0 && !(net_mode == 1))
  {
    show_usage(argv[(signed long int)0]);
    return 1;
  }

  else
  {
    signed int return_value_statfs_12;
    return_value_statfs_12=statfs(debugfs_path, &st);
    if(!(return_value_statfs_12 >= 0))
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      char *return_value_strerror_11;
      return_value_strerror_11=strerror(*return_value___errno_location_10);
      fprintf(stderr, "Invalid debug path %s: %d/%s\n", debugfs_path, *return_value___errno_location_9, return_value_strerror_11);
      return 1;
    }

    if(!(st.f_type == 1684170528l))
    {
      fprintf(stderr, "Debugfs is not mounted at %s\n", debugfs_path);
      return 1;
    }

    else
    {
      if(!(act_mask_tmp == 0))
        act_mask = act_mask_tmp;

      if(net_mode == 2)
      {
        return_value_net_setup_addr_13=net_setup_addr();
        if(return_value_net_setup_addr_13 == 0)
          goto __CPROVER_DUMP_L38;

        return 1;
      }

      else
      {

      __CPROVER_DUMP_L38:
        ;
        signed int return_value_net_client_use_sendfile_18;
        return_value_net_client_use_sendfile_18=net_client_use_sendfile();
        if(!(return_value_net_client_use_sendfile_18 == 0))
          handle_pfds = handle_pfds_netclient;

        else
        {
          return_value_net_client_use_send_17=net_client_use_send();
          if(!(return_value_net_client_use_send_17 == 0))
            handle_pfds = handle_pfds_entries;

          else
          {
            if(!(output_name == ((char *)NULL)))
            {
              return_value_strcmp_15=strcmp(output_name, "-");
              tmp_if_expr_16 = return_value_strcmp_15 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_16 = (_Bool)0;
            if(tmp_if_expr_16)
            {
              piped_output = 1;
              handle_pfds = handle_pfds_entries;
              pfp = stdout;
              signed int return_value_setvbuf_14;
              return_value_setvbuf_14=setvbuf(pfp, (char *)(void *)0, 2, (unsigned long int)0);
              if(!(return_value_setvbuf_14 == 0))
              {
                perror("setvbuf stdout");
                return 1;
              }

            }

            else
              handle_pfds = handle_pfds_file;
          }
        }
        return 0;
      }
    }
  }
}

// handle_client_data
// file blktrace.c line 2504
static void handle_client_data(struct net_server_s *ns, signed int events)
{
  struct cl_conn *nc;
  struct pollfd *pfd;
  struct list_head *p;
  struct list_head *q;
  pfd = &ns->pfds[(signed long int)1];
  p = (&ns->conn_list)->next;
  q = p->next;
  struct cl_conn *tmp_statement_expression_1;
  _Bool tmp_if_expr_3;
  for( ; !(p == &ns->conn_list); q = p->next)
  {
    if(!((0x001 & (signed int)pfd->revents) == 0))
    {
      const struct list_head *__mptr = p;
      tmp_statement_expression_1 = (struct cl_conn *)((char *)__mptr - (signed long int)(unsigned long int)&((struct cl_conn *)0)->ns_head);
      nc = tmp_statement_expression_1;
      signed int return_value_net_client_data_2;
      return_value_net_client_data_2=net_client_data(nc);
      if(!(return_value_net_client_data_2 == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        events = events - 1;
        tmp_if_expr_3 = events == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        break;

    }

    pfd = pfd + 1l;
    p = q;
  }
}

// handle_list_file
// file blktrace.c line 1353
static signed int handle_list_file(struct tracer_devpath_head *hd, struct list_head *list)
{
  signed int off;
  signed int t_len;
  signed int nevents;
  struct blk_io_trace *t;
  struct list_head *p;
  struct list_head *q;
  signed int entries_handled = 0;
  struct trace_buf *tbp;
  struct trace_buf *prev = hd->prev;
  p = list->next;
  q = p->next;
  struct trace_buf *tmp_statement_expression_1;
  _Bool tmp_if_expr_3;
  for( ; !(p == list); q = p->next)
  {
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct trace_buf *)((char *)__mptr - (signed long int)(unsigned long int)&((struct trace_buf *)0)->head);
    tbp = tmp_statement_expression_1;
    list_del(&tbp->head);
    entries_handled = entries_handled + 1;
    if(!(prev == ((struct trace_buf *)NULL)))
      tbp=tb_combine(prev, tbp);

    off = 0;
    nevents = 0;
    for( ; tbp->len >= (signed int)sizeof(struct blk_io_trace) /*48*/  + off; nevents = nevents + 1)
    {
      t = (struct blk_io_trace *)(tbp->buf + (signed long int)off);
      t_len = (signed int)(sizeof(struct blk_io_trace) /*48ul*/  + (unsigned long int)t->pdu_len);
      if(!(tbp->len >= off + t_len))
        break;

      off = off + t_len;
    }
    if(!(nevents == 0))
      pdc_nev_update(tbp->dpp, tbp->cpu, nevents);

    if(!(off == 0))
    {
      signed int return_value_write_data_2;
      return_value_write_data_2=write_data((char *)tbp->buf, off);
      if(!(return_value_write_data_2 == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = off == tbp->len ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        free((void *)tbp);
        prev = (struct trace_buf *)(void *)0;
      }

      else
      {
        tbp->len = tbp->len - off;
        memmove(tbp->buf, tbp->buf + (signed long int)off, (unsigned long int)tbp->len);
        prev = tbp;
      }
    }

    else
      prev = tbp;
    p = q;
  }
  hd->prev = prev;
  return entries_handled;
}

// handle_list_net
// file blktrace.c line 1299
static signed int handle_list_net(struct tracer_devpath_head *hd, struct list_head *list)
{
  struct trace_buf *tbp;
  struct list_head *p;
  struct list_head *q;
  signed int entries_handled = 0;
  p = list->next;
  q = p->next;
  struct trace_buf *tmp_statement_expression_1;
  for( ; !(p == list); q = p->next)
  {
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct trace_buf *)((char *)__mptr - (signed long int)(unsigned long int)&((struct trace_buf *)0)->head);
    tbp = tmp_statement_expression_1;
    list_del(&tbp->head);
    entries_handled = entries_handled + 1;
    if(cl_fds[(signed long int)tbp->cpu] >= 0)
    {
      signed int return_value_flush_subbuf_net_2;
      return_value_flush_subbuf_net_2=flush_subbuf_net(tbp);
      if(!(return_value_flush_subbuf_net_2 == 0))
      {
        close(cl_fds[(signed long int)tbp->cpu]);
        cl_fds[(signed long int)tbp->cpu] = -1;
      }

    }

    free((void *)tbp);
    p = q;
  }
  return entries_handled;
}

// handle_mem_failure
// file blktrace.c line 665
static signed int handle_mem_failure(unsigned long int length)
{
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  signed int return_value_handle_open_failure_1;
  signed int *return_value___errno_location_3;
  signed int return_value_increase_limit_2;
  if(*return_value___errno_location_4 == 23)
  {
    return_value_handle_open_failure_1=handle_open_failure();
    return return_value_handle_open_failure_1;
  }

  else
  {
    return_value___errno_location_3=__errno_location();
    if(*return_value___errno_location_3 == 12)
    {
      return_value_increase_limit_2=increase_limit(__RLIMIT_MEMLOCK, (unsigned long int)2 * length);
      return return_value_increase_limit_2;
    }

  }
  return 0;
}

// handle_open_failure
// file blktrace.c line 658
static signed int handle_open_failure(void)
{
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  if(*return_value___errno_location_2 == 23)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value___errno_location_3=__errno_location();
    tmp_if_expr_4 = *return_value___errno_location_3 == 24 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_increase_limit_1;
  if(tmp_if_expr_4)
  {
    return_value_increase_limit_1=increase_limit(RLIMIT_NOFILE, (unsigned long int)16);
    return return_value_increase_limit_1;
  }

  else
    return 0;
}

// handle_pfds_entries
// file blktrace.c line 1770
static signed int handle_pfds_entries(struct tracer *tp, signed int nevs, signed int force_read)
{
  signed int i;
  signed int nentries = 0;
  struct trace_buf *tbp;
  struct pollfd *pfd = tp->pfds;
  struct io_info *iop = tp->ios;
  tbp=alloc_trace_buf(tp->cpu, (signed int)buf_size);
  i = 0;
  _Bool tmp_if_expr_3;
  for( ; !(i >= ndevs); iop = iop + 1l)
  {
    if(!((0x001 & (signed int)pfd->revents) == 0) || !(force_read == 0))
    {
      signed long int return_value_read_1;
      return_value_read_1=read(iop->ifd, tbp->buf, buf_size);
      tbp->len = (signed int)return_value_read_1;
      if(tbp->len >= 1)
      {
        pdc_dr_update(iop->dpp, tp->cpu, tbp->len);
        add_trace_buf(iop->dpp, tp->cpu, &tbp);
        nentries = nentries + 1;
      }

      else
        if(tbp->len == 0)
        {
          if(!(tp->is_done == 0))
            clear_events(pfd);

        }

        else
        {
          read_err(tp->cpu, iop->ifn);
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          if(!(*return_value___errno_location_2 == 11))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = tp->is_done != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            clear_events(pfd);

        }
      if(piped_output == 0)
      {
        nevs = nevs - 1;
        if(nevs == 0)
          break;

      }

    }

    i = i + 1;
    pfd = pfd + 1l;
  }
  free((void *)tbp);
  if(!(nentries == 0))
    incr_entries(nentries);

  return nentries;
}

// handle_pfds_file
// file blktrace.c line 1693
static signed int handle_pfds_file(struct tracer *tp, signed int nevs, signed int force_read)
{
  struct mmap_info *mip;
  signed int i;
  signed int ret;
  signed int nentries = 0;
  struct pollfd *pfd = tp->pfds;
  struct io_info *iop = tp->ios;
  i = 0;
  _Bool tmp_if_expr_3;
  for( ; nevs >= 1 && !(i >= ndevs); iop = iop + 1l)
  {
    if(!((0x001 & (signed int)pfd->revents) == 0) || !(force_read == 0))
    {
      mip = &iop->mmap_info;
      ret=setup_mmap(iop->ofd, (unsigned int)buf_size, mip, tp);
      if(!(ret >= 0))
      {
        pfd->events = (signed short int)0;
        break;
      }

      signed long int return_value_read_1;
      return_value_read_1=read(iop->ifd, mip->fs_buf + (signed long int)mip->fs_off, buf_size);
      ret = (signed int)return_value_read_1;
      if(ret >= 1)
      {
        pdc_dr_update(iop->dpp, tp->cpu, ret);
        mip->fs_size = mip->fs_size + (unsigned long long int)ret;
        mip->fs_off = mip->fs_off + (unsigned long long int)ret;
        nentries = nentries + 1;
      }

      else
        if(ret == 0)
        {
          if(!(tp->is_done == 0))
            clear_events(pfd);

        }

        else
        {
          read_err(tp->cpu, iop->ifn);
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          if(!(*return_value___errno_location_2 == 11))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = tp->is_done != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            clear_events(pfd);

        }
      nevs = nevs - 1;
    }

    i = i + 1;
    pfd = pfd + 1l;
  }
  return nentries;
}

// handle_pfds_netclient
// file blktrace.c line 1736
static signed int handle_pfds_netclient(struct tracer *tp, signed int nevs, signed int force_read)
{
  struct stat sb;
  signed int i;
  signed int nentries = 0;
  struct pollfd *pfd = tp->pfds;
  struct io_info *iop = tp->ios;
  i = 0;
  for( ; !(i >= ndevs); iop = iop + 1l)
  {
    if(!((0x001 & (signed int)pfd->revents) == 0) || !(force_read == 0))
    {
      signed int return_value_fstat_2;
      return_value_fstat_2=fstat(iop->ifd, &sb);
      if(!(return_value_fstat_2 >= 0))
      {
        perror(iop->ifn);
        pfd->events = (signed short int)0;
      }

      else
        if(!((signed long int)iop->data_queued >= sb.st_size))
        {
          iop->ready = (unsigned int)((unsigned long int)sb.st_size - iop->data_queued);
          iop->data_queued = (unsigned long long int)sb.st_size;
          signed int return_value_net_sendfile_data_1;
          return_value_net_sendfile_data_1=net_sendfile_data(tp, iop);
          if(return_value_net_sendfile_data_1 == 0)
          {
            pdc_dr_update(iop->dpp, tp->cpu, (signed int)iop->ready);
            nentries = nentries + 1;
          }

          else
            clear_events(pfd);
        }

      nevs = nevs - 1;
      if(nevs == 0)
        break;

    }

    i = i + 1;
    pfd = pfd + 1l;
  }
  if(!(nentries == 0))
    incr_entries(nentries);

  return nentries;
}

// handle_sigint
// file blktrace.c line 1969
static void handle_sigint(signed int sig)
{
  done = 1;
  stop_tracers();
}

// in_addr_eq
// file blktrace.c line 494
static inline signed int in_addr_eq(struct in_addr a, struct in_addr b)
{
  return (signed int)(a.s_addr == b.s_addr);
}

// incr_entries
// file blktrace.c line 1206
static inline void incr_entries(signed int entries_handled)
{
  pthread_mutex_lock(&dp_mutex);
  if(dp_entries == 0)
    pthread_cond_signal(&dp_cond);

  dp_entries = dp_entries + entries_handled;
  pthread_mutex_unlock(&dp_mutex);
}

// increase_limit
// file blktrace.c line 640
static signed int increase_limit(signed int resource, unsigned long int increase)
{
  struct rlimit rlim;
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  signed int return_value_getrlimit_3;
  return_value_getrlimit_3=getrlimit((enum __rlimit_resource)resource, &rlim);
  if(return_value_getrlimit_3 == 0)
  {
    rlim.rlim_cur = rlim.rlim_cur + increase;
    if(rlim.rlim_cur >= rlim.rlim_max)
      rlim.rlim_max = rlim.rlim_cur + increase;

    signed int return_value_setrlimit_2;
    return_value_setrlimit_2=setrlimit((enum __rlimit_resource)resource, &rlim);
    if(return_value_setrlimit_2 == 0)
      return 1;

  }

  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  *return_value___errno_location_4 = save_errno;
  return 0;
}

// init_mmap_info
// file blktrace.c line 595
static void init_mmap_info(struct mmap_info *mip)
{
  mip->buf_size = buf_size;
  mip->buf_nr = buf_nr;
  mip->pagesize = pagesize;
}

// iop_open
// file blktrace.c line 1559
static signed int iop_open(struct io_info *iop, signed int cpu)
{
  iop->ofd = -1;
  signed int return_value_fill_ofname_1;
  return_value_fill_ofname_1=fill_ofname(iop, cpu);
  if(!(return_value_fill_ofname_1 == 0))
    return 1;

  else
  {
    iop->ofp=my_fopen(iop->ofn, "w+");
    if(iop->ofp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      fprintf(stderr, "Open output file %s failed: %d/%s\n", (const void *)iop->ofn, *return_value___errno_location_2, return_value_strerror_4);
      return 1;
    }

    signed int return_value_set_vbuf_8;
    return_value_set_vbuf_8=set_vbuf(iop, 1, (unsigned long int)(128 * 1024));
    if(!(return_value_set_vbuf_8 == 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      fprintf(stderr, "set_vbuf for file %s failed: %d/%s\n", (const void *)iop->ofn, *return_value___errno_location_5, return_value_strerror_7);
      fclose(iop->ofp);
      return 1;
    }

    iop->ofd=fileno(iop->ofp);
    return 0;
  }
}

// list_add_tail
// file btt/list.h line 86
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_del
// file btt/list.h line 110
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)(void *)0x00100100;
  entry->prev = (struct list_head *)(void *)0x00200200;
}

// list_empty
// file btt/list.h line 165
static inline signed int list_empty(struct list_head *head)
{
  return (signed int)(head->next == head);
}

// list_replace
// file btt/list.h line 223
static inline void list_replace(struct list_head *old, struct list_head *new)
{
  new->next = old->next;
  new->next->prev = new;
  new->prev = old->prev;
  new->prev->next = new;
}

// list_replace_init
// file btt/list.h line 232
static inline void list_replace_init(struct list_head *old, struct list_head *new)
{
  list_replace(old, new);
  INIT_LIST_HEAD(old);
}

// lock_on_cpu
// file blktrace.c line 622
static signed int lock_on_cpu(signed int cpu)
{
  struct anonymous_6 *cpu_mask;
  unsigned long int size;
  cpu_mask=__sched_cpualloc((unsigned long int)ncpus);
  size = ((((unsigned long int)ncpus + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
  do
    __builtin_memset((void *)cpu_mask, 0, size);
  while((_Bool)0);
  unsigned long int __cpu = (unsigned long int)cpu;
  if(!(__cpu / 8ul >= size))
    ((unsigned long int *)cpu_mask->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)cpu_mask->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

  else
    (unsigned long int)0;
  signed int return_value_sched_setaffinity_2;
  return_value_sched_setaffinity_2=sched_setaffinity(0, size, cpu_mask);
  if(!(return_value_sched_setaffinity_2 >= 0))
  {
    __sched_cpufree(cpu_mask);
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    return *return_value___errno_location_1;
  }

  __sched_cpufree(cpu_mask);
  return 0;
}

// main
// file blktrace.c line 2660
signed int main(signed int argc, char **argv)
{
  signed int ret = 0;
  setlocale(1, "en_US");
  pagesize=getpagesize();
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(83);
  ncpus = (signed int)return_value_sysconf_1;
  signed int return_value_handle_args_5;
  if(!(ncpus >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fprintf(stderr, "sysconf(_SC_NPROCESSORS_CONF) failed %d/%s\n", *return_value___errno_location_2, return_value_strerror_4);
    ret = 1;
    goto out;
  }

  else
  {
    return_value_handle_args_5=handle_args(argc, argv);
    if(!(return_value_handle_args_5 == 0))
    {
      ret = 1;
      goto out;
    }

  }
  signed int return_value_strcmp_6;
  struct devpath *tmp_statement_expression_7;
  if(ndevs >= 2 && !(output_name == ((char *)NULL)))
  {
    return_value_strcmp_6=strcmp(output_name, "-");
    if(return_value_strcmp_6 == 0)
      goto __CPROVER_DUMP_L3;

    fprintf(stderr, "-o not supported with multiple devices\n");
    ret = 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    signal(2, handle_sigint);
    signal(1, handle_sigint);
    signal(15, handle_sigint);
    signal(14, handle_sigint);
    signal(13, (void (*)(signed int))1);
    if(!(kill_running_trace == 0))
    {
      struct devpath *dpp;
      struct list_head *p = (&devpaths)->next;
      for( ; !(p == &devpaths); p = p->next)
      {
        const struct list_head *__mptr = p;
        tmp_statement_expression_7 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
        dpp = tmp_statement_expression_7;
        signed int return_value___stop_trace_11;
        return_value___stop_trace_11=__stop_trace(dpp->fd);
        if(!(return_value___stop_trace_11 == 0))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          char *return_value_strerror_10;
          return_value_strerror_10=strerror(*return_value___errno_location_9);
          fprintf(stderr, "BLKTRACETEARDOWN %s failed: %d/%s\n", dpp->path, *return_value___errno_location_8, return_value_strerror_10);
        }

      }
    }

    else
      if(net_mode == 1)
      {
        if(!(output_name == ((char *)NULL)))
        {
          fprintf(stderr, "-o ignored in server mode\n");
          output_name = (char *)(void *)0;
        }

        ret=net_server();
      }

      else
        ret=run_tracers();
  }

out:
  ;
  if(!(pfp == ((struct _IO_FILE *)NULL)))
    fclose(pfp);

  rel_devpaths();
  return ret;
}

// make_timespec
// file blktrace.c line 517
static inline void make_timespec(struct timespec *tsp, signed long int delta_msec)
{
  struct timeval now;
  gettimeofday(&now, (struct timezone *)(void *)0);
  tsp->tv_sec = now.tv_sec;
  tsp->tv_nsec = 1000L * now.tv_usec;
  tsp->tv_nsec = tsp->tv_nsec + delta_msec * 1000000L;
  if(tsp->tv_nsec >= 1000000001l)
  {
    signed long int secs = tsp->tv_nsec / 1000000000L;
    tsp->tv_sec = tsp->tv_sec + secs;
    tsp->tv_nsec = tsp->tv_nsec - secs * 1000000000L;
  }

}

// my_accept
// file blktrace.c line 707
static signed int my_accept(signed int sockfd, struct sockaddr *addr, unsigned int *addrlen)
{
  signed int fd;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_open_failure_1;
  do
  {
    fd=accept(sockfd, addr, addrlen);
    if(!(fd >= 0))
    {
      return_value_handle_open_failure_1=handle_open_failure();
      tmp_if_expr_2 = return_value_handle_open_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return fd;
}

// my_fopen
// file blktrace.c line 674
static struct _IO_FILE * my_fopen(const char *path, const char *mode)
{
  struct _IO_FILE *fp;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_open_failure_1;
  do
  {
    fp=fopen(path, mode);
    if(fp == ((struct _IO_FILE *)NULL))
    {
      return_value_handle_open_failure_1=handle_open_failure();
      tmp_if_expr_2 = return_value_handle_open_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return fp;
}

// my_mlock
// file blktrace.c line 730
static signed int my_mlock(struct tracer *tp, const void *addr, unsigned long int len)
{
  signed int ret;
  signed int retry = 0;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_mem_failure_1;
  do
  {
    ret=mlock(addr, len);
    if(retry >= 10 && !(tp == ((struct tracer *)NULL)))
    {
      if(!(tp->is_done == 0))
        break;

    }

    retry = retry + 1;
    if(!(ret >= 0))
    {
      return_value_handle_mem_failure_1=handle_mem_failure(len);
      tmp_if_expr_2 = return_value_handle_mem_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return ret;
}

// my_mmap
// file blktrace.c line 718
static void * my_mmap(void *addr, unsigned long int length, signed int prot, signed int flags, signed int fd, signed long int offset)
{
  void *new;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_mem_failure_1;
  do
  {
    new=mmap(addr, length, prot, flags, fd, offset);
    if(new == (void *)-1)
    {
      return_value_handle_mem_failure_1=handle_mem_failure(length);
      tmp_if_expr_2 = return_value_handle_mem_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return new;
}

// my_open
// file blktrace.c line 685
static signed int my_open(const char *path, signed int flags)
{
  signed int fd;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_open_failure_1;
  do
  {
    fd=open(path, flags);
    if(!(fd >= 0))
    {
      return_value_handle_open_failure_1=handle_open_failure();
      tmp_if_expr_2 = return_value_handle_open_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return fd;
}

// my_socket
// file blktrace.c line 696
static signed int my_socket(signed int domain, signed int type, signed int protocol)
{
  signed int fd;
  _Bool tmp_if_expr_2;
  signed int return_value_handle_open_failure_1;
  do
  {
    fd=socket(domain, type, protocol);
    if(!(fd >= 0))
    {
      return_value_handle_open_failure_1=handle_open_failure();
      tmp_if_expr_2 = return_value_handle_open_failure_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return fd;
}

// nc_add_dpp
// file blktrace.c line 2341
static struct devpath * nc_add_dpp(struct cl_conn *nc, struct blktrace_net_hdr *bnh, signed long int connect_time)
{
  signed int cpu;
  struct io_info *iop;
  struct devpath *dpp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct devpath) /*96ul*/ );
  dpp = (struct devpath *)return_value_malloc_1;
  memset((void *)dpp, 0, sizeof(struct devpath) /*96ul*/ );
  dpp->buts_name=strdup(bnh->buts_name);
  dpp->path=strdup(bnh->buts_name);
  dpp->fd = -1;
  dpp->ch = nc->ch;
  dpp->cl_id = bnh->cl_id;
  dpp->cl_connect_time = connect_time;
  dpp->ncpus = nc->ncpus;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)dpp->ncpus, sizeof(struct pdc_stats) /*16ul*/ );
  dpp->stats = (struct pdc_stats *)return_value_calloc_2;
  memset((void *)dpp->stats, 0, (unsigned long int)dpp->ncpus * sizeof(struct pdc_stats) /*16ul*/ );
  list_add_tail(&dpp->head, &nc->ch->devpaths);
  nc->ch->ndevs = nc->ch->ndevs + 1;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)nc->ncpus, sizeof(struct io_info) /*8440ul*/ );
  dpp->ios = (struct io_info *)return_value_calloc_3;
  memset((void *)dpp->ios, 0, (unsigned long int)ndevs * sizeof(struct io_info) /*8440ul*/ );
  cpu = 0;
  iop = dpp->ios;
  for( ; !(cpu >= nc->ncpus); iop = iop + 1l)
  {
    iop->dpp = dpp;
    iop->nc = nc;
    init_mmap_info(&iop->mmap_info);
    signed int return_value_iop_open_4;
    return_value_iop_open_4=iop_open(iop, cpu);
    if(!(return_value_iop_open_4 == 0))
      goto err;

    cpu = cpu + 1;
  }
  return dpp;

err:
  ;
  signed int tmp_post_5;
  while(cpu >= 0)
  {
    tmp_post_5 = cpu;
    cpu = cpu - 1;
    close_iop(&dpp->ios[(signed long int)tmp_post_5]);
  }
  dpp_free(dpp);
  return (struct devpath *)(void *)0;
}

// nc_find_dpp
// file blktrace.c line 2390
static struct devpath * nc_find_dpp(struct cl_conn *nc, struct blktrace_net_hdr *bnh)
{
  struct list_head *p;
  signed long int connect_time = nc->connect_time;
  p = (&nc->ch->devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &nc->ch->devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(dpp->buts_name, bnh->buts_name);
    if(return_value_strcmp_2 == 0)
      return dpp;

    if(dpp->cl_id == bnh->cl_id)
      connect_time = dpp->cl_connect_time;

  }
  struct devpath *return_value_nc_add_dpp_3;
  return_value_nc_add_dpp_3=nc_add_dpp(nc, bnh, connect_time);
  return return_value_nc_add_dpp_3;
}

// net_add_client_host
// file blktrace.c line 2261
static struct cl_host * net_add_client_host(struct net_server_s *ns, struct sockaddr_in *addr)
{
  struct cl_host *ch;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct cl_host) /*80ul*/ );
  ch = (struct cl_host *)return_value_malloc_1;
  memset((void *)ch, 0, sizeof(struct cl_host) /*80ul*/ );
  ch->ns = ns;
  ch->cl_in_addr = addr->sin_addr;
  list_add_tail(&ch->head, &ns->ch_list);
  ns->nchs = ns->nchs + 1;
  char *return_value_inet_ntoa_2;
  return_value_inet_ntoa_2=inet_ntoa(addr->sin_addr);
  ch->hostname=strdup(return_value_inet_ntoa_2);
  printf("server: connection from %s\n", ch->hostname);
  INIT_LIST_HEAD(&ch->conn_list);
  INIT_LIST_HEAD(&ch->devpaths);
  return ch;
}

// net_add_connection
// file blktrace.c line 2319
static void net_add_connection(struct net_server_s *ns)
{
  signed int fd;
  struct cl_host *ch;
  unsigned int socklen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  fd=my_accept(ns->listen_fd, (struct sockaddr *)&ns->addr, &socklen);
  if(!(fd >= 0))
    perror("accept");

  else
  {
    ch=net_find_client_host(ns, ns->addr.sin_addr);
    if(ch == ((struct cl_host *)NULL))
      ch=net_add_client_host(ns, &ns->addr);

    ch_add_connection(ns, ch, fd);
  }
}

// net_ch_remove
// file blktrace.c line 2295
static void net_ch_remove(struct cl_host *ch, signed int ncpus)
{
  struct list_head *p;
  struct list_head *q;
  struct net_server_s *ns = ch->ns;
  p = (&ch->devpaths)->next;
  q = p->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &ch->devpaths); q = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    device_done(dpp, ncpus);
    p = q;
  }
  p = (&ch->conn_list)->next;
  q = p->next;
  struct cl_conn *tmp_statement_expression_2;
  for( ; !(p == &ch->conn_list); q = p->next)
  {
    struct cl_conn *nc;
    const struct list_head *net_ch_remove__1__2__1__1____mptr = p;
    tmp_statement_expression_2 = (struct cl_conn *)((char *)net_ch_remove__1__2__1__1____mptr - (signed long int)(unsigned long int)&((struct cl_conn *)0)->ch_head);
    nc = tmp_statement_expression_2;
    ch_rem_connection(ns, ch, nc);
    p = q;
  }
  list_del(&ch->head);
  ns->nchs = ns->nchs - 1;
  if(!(ch->hostname == ((char *)NULL)))
    free((void *)ch->hostname);

  free((void *)ch);
}

// net_client_data
// file blktrace.c line 2435
static signed int net_client_data(struct cl_conn *nc)
{
  signed int ret;
  struct devpath *dpp;
  struct blktrace_net_hdr bnh;
  ret=net_get_header(nc, &bnh);
  signed int return_value_check_data_endianness_1;
  if(ret == 0)
    return 0;

  else
  {
    if(!(ret >= 0))
    {
      fprintf(stderr, "ncd(%d): header read failed\n", nc->fd);
      exit(1);
    }

    if(data_is_native == -1)
    {
      return_value_check_data_endianness_1=check_data_endianness(bnh.magic);
      if(!(return_value_check_data_endianness_1 == 0))
      {
        fprintf(stderr, "ncd(%d): received data is bad\n", nc->fd);
        exit(1);
      }

    }

    if(data_is_native == 0)
    {
      bnh.magic=__bswap_32(bnh.magic);
      bnh.cpu=__bswap_32(bnh.cpu);
      bnh.max_cpus=__bswap_32(bnh.max_cpus);
      bnh.len=__bswap_32(bnh.len);
      bnh.cl_id=__bswap_32(bnh.cl_id);
      bnh.buf_size=__bswap_32(bnh.buf_size);
      bnh.buf_nr=__bswap_32(bnh.buf_nr);
      bnh.page_size=__bswap_32(bnh.page_size);
    }

    if(!((0xffffff00 & bnh.magic) == 1700885504u))
    {
      fprintf(stderr, "ncd(%s:%d): bad data magic\n", nc->ch->hostname, nc->fd);
      exit(1);
    }

    if(nc->ncpus == -1)
      nc->ncpus = (signed int)bnh.max_cpus;

    dpp=nc_find_dpp(nc, &bnh);
    if(bnh.len == 0u)
    {
      ack_open_close(nc->fd, dpp->buts_name);
      nc->ch->cl_opens = nc->ch->cl_opens + 1;
    }

    else
      if(bnh.len == 1u)
      {
        dpp->drops = (unsigned long long int)bnh.cpu;
        ack_open_close(nc->fd, dpp->buts_name);
        nc->ch->cl_opens = nc->ch->cl_opens - 1;
        if(nc->ch->cl_opens == 0)
        {
          show_stats(&nc->ch->devpaths);
          net_ch_remove(nc->ch, nc->ncpus);
          return 1;
        }

      }

      else
        net_client_read_data(nc, dpp, &bnh);
    return 0;
  }
}

// net_client_read_data
// file blktrace.c line 2409
static void net_client_read_data(struct cl_conn *nc, struct devpath *dpp, struct blktrace_net_hdr *bnh)
{
  signed int ret;
  struct io_info *iop = &dpp->ios[(signed long int)bnh->cpu];
  struct mmap_info *mip = &iop->mmap_info;
  signed int return_value_setup_mmap_1;
  return_value_setup_mmap_1=setup_mmap(iop->ofd, bnh->len, &iop->mmap_info, (struct tracer *)(void *)0);
  if(!(return_value_setup_mmap_1 == 0))
  {
    fprintf(stderr, "ncd(%s:%d): mmap failed\n", nc->ch->hostname, nc->fd);
    exit(1);
  }

  ret=net_recv_data(nc->fd, mip->fs_buf + (signed long int)mip->fs_off, bnh->len);
  if(ret >= 1)
  {
    pdc_dr_update(dpp, (signed int)bnh->cpu, ret);
    mip->fs_size = mip->fs_size + (unsigned long long int)ret;
    mip->fs_off = mip->fs_off + (unsigned long long int)ret;
  }

  else
    if(!(ret >= 0))
      exit(1);

}

// net_client_use_send
// file blktrace.c line 484
static inline signed int net_client_use_send(void)
{
  return (signed int)(net_mode == 2 && !(net_use_sendfile != 0));
}

// net_client_use_sendfile
// file blktrace.c line 479
static inline signed int net_client_use_sendfile(void)
{
  return (signed int)(net_mode == 2 && net_use_sendfile != 0);
}

// net_close_connection
// file blktrace.c line 602
static void net_close_connection(signed int *fd)
{
  shutdown(*fd, 2);
  close(*fd);
  *fd = -1;
}

// net_find_client_host
// file blktrace.c line 2246
static struct cl_host * net_find_client_host(struct net_server_s *ns, struct in_addr cl_in_addr)
{
  struct list_head *p = (&ns->ch_list)->next;
  struct cl_host *tmp_statement_expression_1;
  for( ; !(p == &ns->ch_list); p = p->next)
  {
    struct cl_host *ch;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct cl_host *)((char *)__mptr - (signed long int)(unsigned long int)&((struct cl_host *)0)->head);
    ch = tmp_statement_expression_1;
    signed int return_value_in_addr_eq_2;
    return_value_in_addr_eq_2=in_addr_eq(ch->cl_in_addr, cl_in_addr);
    if(!(return_value_in_addr_eq_2 == 0))
      return ch;

  }
  return (struct cl_host *)(void *)0;
}

// net_get_header
// file blktrace.c line 943
static signed int net_get_header(struct cl_conn *nc, struct blktrace_net_hdr *bnh)
{
  signed int bytes_read;
  signed int fl;
  fl=fcntl(nc->fd, 3);
  fcntl(nc->fd, 4, fl | 04000);
  bytes_read=__net_recv_data(nc->fd, (void *)bnh, (unsigned int)sizeof(struct blktrace_net_hdr) /*64ul*/ );
  fcntl(nc->fd, 4, fl & ~04000);
  if((unsigned long int)bytes_read == sizeof(struct blktrace_net_hdr) /*64ul*/ )
    return 1;

  else
    if(bytes_read == 0)
      return 0;

    else
      return -1;
}

// net_recv_data
// file blktrace.c line 847
static signed int net_recv_data(signed int fd, void *buf, unsigned int len)
{
  signed int return_value___net_recv_data_1;
  return_value___net_recv_data_1=__net_recv_data(fd, buf, len);
  return return_value___net_recv_data_1;
}

// net_send_close
// file blktrace.c line 908
static void net_send_close(signed int fd, char *buts_name, signed int drops)
{
  done = 0;
  net_send_open_close(fd, drops, buts_name, 1);
  done = 1;
}

// net_send_data
// file blktrace.c line 855
static signed int net_send_data(signed int fd, void *buf, unsigned int buf_len)
{
  signed int ret;
  unsigned int bytes_left = buf_len;
  while(!(bytes_left == 0u))
  {
    signed long int return_value_send_1;
    return_value_send_1=send(fd, buf, (unsigned long int)bytes_left, 0);
    ret = (signed int)return_value_send_1;
    if(!(ret >= 0))
    {
      perror("send");
      break;
    }

    buf = buf + (signed long int)ret;
    bytes_left = bytes_left - (unsigned int)ret;
  }
  return (signed int)(buf_len - bytes_left);
}

// net_send_drops
// file blktrace.c line 926
static void net_send_drops(signed int fd)
{
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    net_send_close(fd, dpp->buts_name, (signed int)dpp->drops);
  }
}

// net_send_header
// file blktrace.c line 874
static signed int net_send_header(signed int fd, signed int cpu, char *buts_name, signed int len)
{
  struct blktrace_net_hdr hdr;
  memset((void *)&hdr, 0, sizeof(struct blktrace_net_hdr) /*64ul*/ );
  hdr.magic = (unsigned int)0x65617400;
  memset((void *)hdr.buts_name, 0, sizeof(char [32l]) /*32ul*/ );
  strncpy(hdr.buts_name, buts_name, sizeof(char [32l]) /*32ul*/ );
  hdr.buts_name[(signed long int)(sizeof(char [32l]) /*32ul*/  - (unsigned long int)1)] = (char)0;
  hdr.cpu = (unsigned int)cpu;
  hdr.max_cpus = (unsigned int)ncpus;
  hdr.len = (unsigned int)len;
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  hdr.cl_id = (unsigned int)return_value_getpid_1;
  hdr.buf_size = (unsigned int)buf_size;
  hdr.buf_nr = (unsigned int)buf_nr;
  hdr.page_size = (unsigned int)pagesize;
  signed int return_value_net_send_data_2;
  return_value_net_send_data_2=net_send_data(fd, (void *)&hdr, (unsigned int)sizeof(struct blktrace_net_hdr) /*64ul*/ );
  return (signed int)((unsigned long int)return_value_net_send_data_2 != sizeof(struct blktrace_net_hdr) /*64ul*/ );
}

// net_send_open
// file blktrace.c line 903
static void net_send_open(signed int fd, signed int cpu, char *buts_name)
{
  net_send_open_close(fd, cpu, buts_name, 0);
}

// net_send_open_close
// file blktrace.c line 895
static void net_send_open_close(signed int fd, signed int cpu, char *buts_name, signed int len)
{
  struct blktrace_net_hdr ret_hdr;
  net_send_header(fd, cpu, buts_name, len);
  net_recv_data(fd, (void *)&ret_hdr, (unsigned int)sizeof(struct blktrace_net_hdr) /*64ul*/ );
}

// net_sendfile
// file blktrace.c line 1470
static signed int net_sendfile(struct io_info *iop)
{
  signed int ret;
  signed long int return_value_sendfile_1;
  return_value_sendfile_1=sendfile(iop->ofd, iop->ifd, (signed long int *)(void *)0, (unsigned long int)iop->ready);
  ret = (signed int)return_value_sendfile_1;
  if(!(ret >= 0))
  {
    perror("sendfile");
    return 1;
  }

  else
    if(!(ret >= (signed int)iop->ready))
    {
      fprintf(stderr, "short sendfile send (%d of %d)\n", ret, iop->ready);
      return 1;
    }

  return 0;
}

// net_sendfile_data
// file blktrace.c line 1487
static inline signed int net_sendfile_data(struct tracer *tp, struct io_info *iop)
{
  struct devpath *dpp = iop->dpp;
  signed int return_value_net_send_header_1;
  return_value_net_send_header_1=net_send_header(iop->ofd, tp->cpu, dpp->buts_name, (signed int)iop->ready);
  if(!(return_value_net_send_header_1 == 0))
    return 1;

  else
  {
    signed int return_value_net_sendfile_2;
    return_value_net_sendfile_2=net_sendfile(iop);
    return return_value_net_sendfile_2;
  }
}

// net_server
// file blktrace.c line 2568
static signed int net_server(void)
{
  signed int fd;
  signed int opt;
  signed int ret = 1;
  struct net_server_s net_server__1__net_server;
  struct net_server_s *ns = &net_server__1__net_server;
  memset((void *)ns, 0, sizeof(struct net_server_s) /*72ul*/ );
  INIT_LIST_HEAD(&ns->ch_list);
  INIT_LIST_HEAD(&ns->conn_list);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pollfd) /*8ul*/ );
  ns->pfds = (struct pollfd *)return_value_malloc_1;
  fd=my_socket(2, 1, 0);
  signed int return_value_setsockopt_2;
  signed int return_value_bind_3;
  signed int return_value_listen_4;
  if(!(fd >= 0))
    perror("server: socket");

  else
  {
    opt = 1;
    return_value_setsockopt_2=setsockopt(fd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_2 >= 0))
      perror("setsockopt");

    else
    {
      memset((void *)&ns->addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      ns->addr.sin_family = (unsigned short int)2;
      ns->addr.sin_addr.s_addr=htonl((unsigned int)0x00000000);
      ns->addr.sin_port=htons((unsigned short int)net_port);
      return_value_bind_3=bind(fd, (struct sockaddr *)&ns->addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_3 >= 0))
        perror("bind");

      else
      {
        return_value_listen_4=listen(fd, 1);
        if(!(return_value_listen_4 >= 0))
          perror("listen");

        else
        {
          ns->listen_fd = fd;
          ret=net_server_handle_connections(ns);
        }
      }
    }
  }

out:
  ;
  free((void *)ns->pfds);
  return ret;
}

// net_server_handle_connections
// file blktrace.c line 2540
static signed int net_server_handle_connections(struct net_server_s *ns)
{
  signed int events;
  printf("server: waiting for connections...\n");
  while(done == 0)
  {
    net_setup_pfds(ns);
    events=poll(ns->pfds, (unsigned long int)(ns->connects + 1), -1);
    if(!(events >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 4))
      {
        perror("FATAL: poll error");
        return 1;
      }

    }

    else
      if(events >= 1)
      {
        if(!((0x001 & (signed int)ns->pfds->revents) == 0))
        {
          net_add_connection(ns);
          events = events - 1;
        }

        if(!(events == 0))
          handle_client_data(ns, events);

      }

  }
  return 0;
}

// net_setup_addr
// file blktrace.c line 960
static signed int net_setup_addr(void)
{
  struct sockaddr_in *addr = &hostname_addr;
  memset((void *)addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr->sin_family = (unsigned short int)2;
  addr->sin_port=htons((unsigned short int)net_port);
  signed int return_value_inet_aton_3;
  return_value_inet_aton_3=inet_aton(hostname, &addr->sin_addr);
  signed int *return_value___h_errno_location_2;
  if(!(return_value_inet_aton_3 == 1))
  {
    struct hostent *hent;
    do
    {

    retry:
      ;
      hent=gethostbyname(hostname);
      if(!(hent == ((struct hostent *)NULL)))
        goto __CPROVER_DUMP_L5;

      return_value___h_errno_location_2=__h_errno_location();
      if(!(*return_value___h_errno_location_2 == 2))
        break;

      usleep((unsigned int)100);
    }
    while((_Bool)1);
    signed int *return_value___h_errno_location_1;
    return_value___h_errno_location_1=__h_errno_location();
    if(*return_value___h_errno_location_1 == 3)
      fprintf(stderr, "gethostbyname(%s)non-recoverable error encountered\n", (const void *)hostname);

    else
      fprintf(stderr, "Host %s not found\n", (const void *)hostname);
    return 1;

  __CPROVER_DUMP_L5:
    ;
    memcpy((void *)&addr->sin_addr, (const void *)hent->h_addr_list[(signed long int)0], (unsigned long int)4);
    memset((void *)hostname, 0, sizeof(char [64l]) /*64ul*/ );
    strncpy(hostname, hent->h_name, sizeof(char [64l]) /*64ul*/ );
    hostname[(signed long int)(sizeof(char [64l]) /*64ul*/  - (unsigned long int)1)] = (char)0;
  }

  return 0;
}

// net_setup_client
// file blktrace.c line 999
static signed int net_setup_client(void)
{
  signed int fd;
  struct sockaddr_in *addr = &hostname_addr;
  fd=my_socket(2, 1, 0);
  if(!(fd >= 0))
  {
    perror("client: socket");
    return -1;
  }

  else
  {
    signed int return_value_connect_2;
    return_value_connect_2=connect(fd, (struct sockaddr *)addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_connect_2 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 111)
        fprintf(stderr, "\nclient: Connection to %s refused, perhaps the server is not started?\n\n", (const void *)hostname);

      else
        perror("client: connect");
      close(fd);
      return -1;
    }

    return fd;
  }
}

// net_setup_pfds
// file blktrace.c line 2522
static void net_setup_pfds(struct net_server_s *ns)
{
  struct pollfd *pfd;
  struct list_head *p;
  (ns->pfds + (signed long int)0)->fd = ns->listen_fd;
  (ns->pfds + (signed long int)0)->events = (signed short int)0x001;
  pfd = &ns->pfds[(signed long int)1];
  p = (&ns->conn_list)->next;
  struct cl_conn *tmp_statement_expression_1;
  for( ; !(p == &ns->conn_list); p = p->next)
  {
    struct cl_conn *nc;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct cl_conn *)((char *)__mptr - (signed long int)(unsigned long int)&((struct cl_conn *)0)->ns_head);
    nc = tmp_statement_expression_1;
    pfd->fd = nc->fd;
    pfd->events = (signed short int)0x001;
    pfd = pfd + 1l;
  }
}

// open_client_connections
// file blktrace.c line 1026
static signed int open_client_connections(void)
{
  signed int cpu;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)ncpus, sizeof(signed int) /*4ul*/ );
  cl_fds = (signed int *)return_value_calloc_1;
  cpu = 0;
  for( ; !(cpu >= ncpus); cpu = cpu + 1)
  {
    cl_fds[(signed long int)cpu]=net_setup_client();
    if(!(cl_fds[(signed long int)cpu] >= 0))
      goto err;

  }
  return 0;

err:
  ;
  signed int tmp_post_2;
  while(cpu >= 1)
  {
    tmp_post_2 = cpu;
    cpu = cpu - 1;
    close(cl_fds[(signed long int)tmp_post_2]);
  }
  free((void *)cl_fds);
  return 1;
}

// open_ios
// file blktrace.c line 1627
static signed int open_ios(struct tracer *tp)
{
  struct pollfd *pfd;
  struct io_info *iop;
  struct list_head *p;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)ndevs, sizeof(struct io_info) /*8440ul*/ );
  tp->ios = (struct io_info *)return_value_calloc_1;
  memset((void *)tp->ios, 0, (unsigned long int)ndevs * sizeof(struct io_info) /*8440ul*/ );
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)ndevs, sizeof(struct pollfd) /*8ul*/ );
  tp->pfds = (struct pollfd *)return_value_calloc_2;
  memset((void *)tp->pfds, 0, (unsigned long int)ndevs * sizeof(struct pollfd) /*8ul*/ );
  tp->nios = 0;
  iop = tp->ios;
  pfd = tp->pfds;
  p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_3;
  signed int return_value_net_client_use_sendfile_8;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_3 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_3;
    iop->dpp = dpp;
    iop->ofd = -1;
    snprintf(iop->ifn, sizeof(char [4160l]) /*4160ul*/ , "%s/block/%s/trace%d", debugfs_path, dpp->buts_name, tp->cpu);
    iop->ifd=my_open(iop->ifn, 00 | 04000);
    if(!(iop->ifd >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      fprintf(stderr, "Thread %d failed open %s: %d/%s\n", tp->cpu, (const void *)iop->ifn, *return_value___errno_location_4, return_value_strerror_6);
      return 1;
    }

    init_mmap_info(&iop->mmap_info);
    pfd->fd = iop->ifd;
    pfd->events = (signed short int)0x001;
    if(piped_output == 0)
    {
      return_value_net_client_use_sendfile_8=net_client_use_sendfile();
      if(!(return_value_net_client_use_sendfile_8 == 0))
      {
        iop->ofd=net_setup_client();
        if(!(iop->ofd >= 0))
          goto err;

        net_send_open(iop->ofd, tp->cpu, dpp->buts_name);
      }

      else
        if(net_mode == 0)
        {
          signed int return_value_iop_open_7;
          return_value_iop_open_7=iop_open(iop, tp->cpu);
          if(!(return_value_iop_open_7 == 0))
            goto err;

        }

        else
          net_send_open(cl_fds[(signed long int)tp->cpu], tp->cpu, dpp->buts_name);
    }

    pfd = pfd + 1l;
    iop = iop + 1l;
    tp->nios = tp->nios + 1;
  }
  return 0;

err:
  ;
  close(iop->ifd);
  close_ios(tp);
  return 1;
}

// pdc_dr_update
// file blktrace.c line 499
static inline void pdc_dr_update(struct devpath *dpp, signed int cpu, signed int data_read)
{
  (dpp->stats + (signed long int)cpu)->data_read = (dpp->stats + (signed long int)cpu)->data_read + (unsigned long long int)data_read;
}

// pdc_nev_update
// file blktrace.c line 504
static inline void pdc_nev_update(struct devpath *dpp, signed int cpu, signed int nevents)
{
  (dpp->stats + (signed long int)cpu)->nevents = (dpp->stats + (signed long int)cpu)->nevents + (unsigned long long int)nevents;
}

// process_trace_bufs
// file blktrace.c line 1447
static void process_trace_bufs(void)
{
  signed int return_value_wait_empty_entries_1;
  do
  {
    return_value_wait_empty_entries_1=wait_empty_entries();
    if(return_value_wait_empty_entries_1 == 0)
      break;

    __process_trace_bufs();
  }
  while((_Bool)1);
}

// read_err
// file blktrace.c line 1463
static inline void read_err(signed int cpu, char *ifn)
{
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(!(*return_value___errno_location_4 == 11))
  {
    return_value___errno_location_1=__errno_location();
    return_value___errno_location_2=__errno_location();
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, "Thread %d failed read of %s: %d/%s\n", cpu, ifn, *return_value___errno_location_1, return_value_strerror_3);
  }

}

// rel_devpaths
// file blktrace.c line 1266
static void rel_devpaths(void)
{
  struct list_head *p;
  struct list_head *q;
  p = (&devpaths)->next;
  q = p->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); q = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    list_del(&dpp->head);
    __stop_trace(dpp->fd);
    close(dpp->fd);
    if(!(dpp->heads == ((struct tracer_devpath_head *)NULL)))
      free_tracer_heads(dpp);

    dpp_free(dpp);
    ndevs = ndevs - 1;
    p = q;
  }
}

// run_tracers
// file blktrace.c line 2621
static signed int run_tracers(void)
{
  atexit(exit_tracing);
  if(net_mode == 2)
    printf("blktrace: connecting to %s\n", (const void *)hostname);

  setup_buts();
  signed int return_value_use_tracer_devpaths_2;
  return_value_use_tracer_devpaths_2=use_tracer_devpaths();
  if(!(return_value_use_tracer_devpaths_2 == 0))
  {
    signed int return_value_setup_tracer_devpaths_1;
    return_value_setup_tracer_devpaths_1=setup_tracer_devpaths();
    if(!(return_value_setup_tracer_devpaths_1 == 0))
      return 1;

    if(!(piped_output == 0))
      handle_list = handle_list_file;

    else
      handle_list = handle_list_net;
  }

  start_tracers();
  if(nthreads_running == ncpus)
  {
    unblock_tracers();
    start_buts();
    if(net_mode == 2)
      printf("blktrace: connected!\n");

    if(!(stop_watch == 0))
      alarm((unsigned int)stop_watch);

  }

  else
    stop_tracers();
  wait_tracers();
  if(nthreads_running == ncpus)
    show_stats(&devpaths);

  signed int return_value_net_client_use_send_3;
  return_value_net_client_use_send_3=net_client_use_send();
  if(!(return_value_net_client_use_send_3 == 0))
    close_client_connections();

  del_tracers();
  return 0;
}

// set_vbuf
// file blktrace.c line 1545
static signed int set_vbuf(struct io_info *iop, signed int mode, unsigned long int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  iop->obuf = (char *)return_value_malloc_1;
  signed int return_value_setvbuf_5;
  return_value_setvbuf_5=setvbuf(iop->ofp, iop->obuf, mode, size);
  if(!(return_value_setvbuf_5 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fprintf(stderr, "setvbuf(%s, %d) failed: %d/%s\n", iop->dpp->path, (signed int)size, *return_value___errno_location_2, return_value_strerror_4);
    free((void *)iop->obuf);
    return 1;
  }

  return 0;
}

// setup_buts
// file blktrace.c line 1060
static void setup_buts(void)
{
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct blk_user_trace_setup buts;
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    memset((void *)&buts, 0, sizeof(struct blk_user_trace_setup) /*72ul*/ );
    buts.buf_size = (unsigned int)buf_size;
    buts.buf_nr = (unsigned int)buf_nr;
    buts.act_mask = (unsigned short int)act_mask;
    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(dpp->fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(115 << 0)) | sizeof(struct blk_user_trace_setup) /*72ul*/  << 0 + 8 + 8, &buts);
    if(return_value_ioctl_6 >= 0)
    {
      dpp->ncpus = ncpus;
      dpp->buts_name=strdup(buts.name);
      if(!(dpp->stats == ((struct pdc_stats *)NULL)))
        free((void *)dpp->stats);

      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)dpp->ncpus, sizeof(struct pdc_stats) /*16ul*/ );
      dpp->stats = (struct pdc_stats *)return_value_calloc_2;
      memset((void *)dpp->stats, 0, (unsigned long int)dpp->ncpus * sizeof(struct pdc_stats) /*16ul*/ );
    }

    else
    {
      return_value___errno_location_3=__errno_location();
      return_value___errno_location_4=__errno_location();
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fprintf(stderr, "BLKTRACESETUP(2) %s failed: %d/%s\n", dpp->path, *return_value___errno_location_3, return_value_strerror_5);
    }
  }
}

// setup_mmap
// file blktrace.c line 745
static signed int setup_mmap(signed int fd, unsigned int maxlen, struct mmap_info *mip, struct tracer *tp)
{
  unsigned long int tmp_if_expr_1;
  if(!(mip->fs_buf_len >= mip->fs_off + (unsigned long int)maxlen))
  {
    unsigned long int nr;
    if(!(mip->buf_nr >= 16ul))
      tmp_if_expr_1 = (unsigned long int)16;

    else
      tmp_if_expr_1 = mip->buf_nr;
    nr = tmp_if_expr_1;
    if(!(mip->fs_buf == NULL))
    {
      munlock(mip->fs_buf, mip->fs_buf_len);
      munmap(mip->fs_buf, mip->fs_buf_len);
      mip->fs_buf = (void *)0;
    }

    mip->fs_off = mip->fs_size & (unsigned long int)(mip->pagesize - 1);
    mip->fs_buf_len = nr * mip->buf_size - mip->fs_off;
    mip->fs_max_size = mip->fs_max_size + mip->fs_buf_len;
    signed int return_value_ftruncate_2;
    return_value_ftruncate_2=ftruncate(fd, (signed long int)mip->fs_max_size);
    if(!(return_value_ftruncate_2 >= 0))
    {
      perror("setup_mmap: ftruncate");
      return 1;
    }

    mip->fs_buf=my_mmap((void *)0, mip->fs_buf_len, 0x2, 0x01, fd, (signed long int)(mip->fs_size - mip->fs_off));
    if(mip->fs_buf == (void *)-1)
    {
      perror("setup_mmap: mmap");
      return 1;
    }

    signed int return_value_my_mlock_3;
    return_value_my_mlock_3=my_mlock(tp, mip->fs_buf, mip->fs_buf_len);
    if(!(return_value_my_mlock_3 >= 0))
    {
      perror("setup_mlock: mlock");
      return 1;
    }

  }

  return 0;
}

// setup_tracer_devpaths
// file blktrace.c line 1167
static signed int setup_tracer_devpaths(void)
{
  struct list_head *p;
  signed int return_value_net_client_use_send_2;
  return_value_net_client_use_send_2=net_client_use_send();
  signed int return_value_open_client_connections_1;
  struct devpath *tmp_statement_expression_3;
  if(!(return_value_net_client_use_send_2 == 0))
  {
    return_value_open_client_connections_1=open_client_connections();
    if(return_value_open_client_connections_1 == 0)
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    p = (&devpaths)->next;
    for( ; !(p == &devpaths); p = p->next)
    {
      signed int cpu;
      struct tracer_devpath_head *hd;
      struct devpath *dpp;
      const struct list_head *__mptr = p;
      tmp_statement_expression_3 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
      dpp = tmp_statement_expression_3;
      void *return_value_calloc_4;
      return_value_calloc_4=calloc((unsigned long int)ncpus, sizeof(struct tracer_devpath_head) /*64ul*/ );
      dpp->heads = (struct tracer_devpath_head *)return_value_calloc_4;
      cpu = 0;
      hd = dpp->heads;
      for( ; !(cpu >= ncpus); hd = hd + 1l)
      {
        INIT_LIST_HEAD(&hd->head);
        pthread_mutex_init(&hd->mutex, (const union anonymous_1 *)(void *)0);
        hd->prev = (struct trace_buf *)(void *)0;
        cpu = cpu + 1;
      }
    }
    return 0;
  }
}

// show_stats
// file blktrace.c line 1975
static void show_stats(struct list_head *devpaths)
{
  struct _IO_FILE *ofp;
  struct list_head *p;
  unsigned long long int nevents;
  unsigned long long int data_read;
  unsigned long long int total_drops = (unsigned long long int)0;
  unsigned long long int total_events = (unsigned long long int)0;
  if(!(piped_output == 0))
    ofp=my_fopen("/dev/null", "w");

  else
    ofp = stdout;
  p = devpaths->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == devpaths); p = p->next)
  {
    signed int cpu;
    struct pdc_stats *sp;
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    if(net_mode == 1)
      printf("server: end of run for %s:%s\n", dpp->ch->hostname, dpp->buts_name);

    data_read = (unsigned long long int)0;
    nevents = (unsigned long long int)0;
    fprintf(ofp, "=== %s ===\n", dpp->buts_name);
    cpu = 0;
    sp = dpp->stats;
    for( ; !(cpu >= dpp->ncpus); sp = sp + 1l)
    {
      if(sp->nevents == 0ul)
        sp->nevents = sp->data_read / sizeof(struct blk_io_trace) /*48ul*/ ;

      fprintf(ofp, "  CPU%3d: %20llu events, %8llu KiB data\n", cpu, sp->nevents, sp->data_read + (unsigned long int)1023 >> 10);
      data_read = data_read + sp->data_read;
      nevents = nevents + sp->nevents;
      cpu = cpu + 1;
    }
    fprintf(ofp, "  Total:  %20llu events (dropped %llu), %8llu KiB data\n", nevents, dpp->drops, data_read + (unsigned long int)1024 >> 10);
    total_drops = total_drops + dpp->drops;
    total_events = total_events + nevents + dpp->drops;
  }
  fflush(ofp);
  if(!(piped_output == 0))
    fclose(ofp);

  if(!(total_drops == 0ull))
  {
    double drops_ratio = 1.0;
    if(!(total_events == 0ull))
      drops_ratio = (double)total_drops / (double)total_events;

    fprintf(stderr, "\nYou have %llu (%5.1lf%%) dropped events\nConsider using a larger buffer size (-b) and/or more buffers (-n)\n", total_drops, 100.0 * drops_ratio);
  }

}

// show_usage
// file blktrace.c line 509
static void show_usage(char *prog)
{
  fprintf(stderr, "Usage: %s %s", prog, (const void *)usage_str);
}

// start_buts
// file blktrace.c line 1086
static void start_buts(void)
{
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)__mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    signed int return_value_ioctl_5;
    return_value_ioctl_5=ioctl(dpp->fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(116 << 0) | (unsigned int)(0 << 0 + 8 + 8)));
    if(!(return_value_ioctl_5 >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      fprintf(stderr, "BLKTRACESTART %s failed: %d/%s\n", dpp->path, *return_value___errno_location_2, return_value_strerror_4);
    }

  }
}

// start_tracer
// file blktrace.c line 1855
static signed int start_tracer(signed int cpu)
{
  struct tracer *tp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct tracer) /*56ul*/ );
  tp = (struct tracer *)return_value_malloc_1;
  memset((void *)tp, 0, sizeof(struct tracer) /*56ul*/ );
  INIT_LIST_HEAD(&tp->head);
  tp->status = 0;
  tp->cpu = cpu;
  signed int return_value_pthread_create_5;
  return_value_pthread_create_5=pthread_create(&tp->thread, (const union pthread_attr_t *)(void *)0, thread_main, (void *)tp);
  if(!(return_value_pthread_create_5 == 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fprintf(stderr, "FAILED to start thread on CPU %d: %d/%s\n", cpu, *return_value___errno_location_2, return_value_strerror_4);
    free((void *)tp);
    return 1;
  }

  list_add_tail(&tp->head, &tracers);
  return 0;
}

// start_tracers
// file blktrace.c line 1877
static void start_tracers(void)
{
  signed int cpu;
  struct list_head *p;
  cpu = 0;
  signed int return_value_start_tracer_1;
  for( ; !(cpu >= ncpus); cpu = cpu + 1)
  {
    return_value_start_tracer_1=start_tracer(cpu);
    if(!(return_value_start_tracer_1 == 0))
      break;

  }
  wait_tracers_ready(cpu);
  p = (&tracers)->next;
  struct tracer *tmp_statement_expression_2;
  char *return_value_strerror_3;
  for( ; !(p == &tracers); p = p->next)
  {
    struct tracer *tp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_2 = (struct tracer *)((char *)__mptr - (signed long int)(unsigned long int)&((struct tracer *)0)->head);
    tp = tmp_statement_expression_2;
    if(!(tp->status == 0))
    {
      return_value_strerror_3=strerror(tp->status);
      fprintf(stderr, "FAILED to start thread on CPU %d: %d/%s\n", tp->cpu, tp->status, return_value_strerror_3);
    }

  }
}

// stop_tracers
// file blktrace.c line 1897
static void stop_tracers(void)
{
  struct list_head *p = (&devpaths)->next;
  struct devpath *tmp_statement_expression_1;
  for( ; !(p == &devpaths); p = p->next)
  {
    struct devpath *dpp;
    const struct list_head *stop_tracers__1__1__1__1____mptr = p;
    tmp_statement_expression_1 = (struct devpath *)((char *)stop_tracers__1__1__1__1____mptr - (signed long int)(unsigned long int)&((struct devpath *)0)->head);
    dpp = tmp_statement_expression_1;
    ioctl(dpp->fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(117 << 0) | (unsigned int)(0 << 0 + 8 + 8)));
  }
  p = (&tracers)->next;
  struct tracer *tmp_statement_expression_2;
  for( ; !(p == &tracers); p = p->next)
  {
    struct tracer *tp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_2 = (struct tracer *)((char *)__mptr - (signed long int)(unsigned long int)&((struct tracer *)0)->head);
    tp = tmp_statement_expression_2;
    tp->is_done = 1;
  }
  pthread_cond_broadcast(&mt_cond);
}

// t_pthread_cond_wait
// file blktrace.c line 537
static void t_pthread_cond_wait(union anonymous_3 *cond, union anonymous_0 *mutex)
{
  struct timespec ts;
  make_timespec(&ts, (signed long int)50);
  pthread_cond_timedwait(cond, mutex, &ts);
}

// tb_combine
// file blktrace.c line 1328
static struct trace_buf * tb_combine(struct trace_buf *prev, struct trace_buf *tbp)
{
  unsigned long int tot_len = (unsigned long int)(prev->len + tbp->len);
  if(!(buf_size >= tot_len))
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)prev, sizeof(struct trace_buf) /*40ul*/  + tot_len);
    prev = (struct trace_buf *)return_value_realloc_1;
    prev->buf = (void *)(prev + (signed long int)1);
  }

  memcpy(prev->buf + (signed long int)prev->len, tbp->buf, (unsigned long int)tbp->len);
  prev->len = (signed int)tot_len;
  free((void *)tbp);
  return prev;
}

// thread_main
// file blktrace.c line 1809
static void * thread_main(void *arg)
{
  signed int ret;
  signed int ndone;
  signed int to_val;
  struct tracer *tp = (struct tracer *)arg;
  ret=lock_on_cpu(tp->cpu);
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  signed int return_value;
  if(ret == 0)
  {
    ret=open_ios(tp);
    if(!(ret == 0))
      goto err;

    if(!(piped_output == 0))
      to_val = 50;

    else
      to_val = 500;
    tracer_signal_ready(tp, (enum thread_status)Th_running, 0);
    tracer_wait_unblock(tp);
    while(tp->is_done == 0)
    {
      ndone=poll(tp->pfds, (unsigned long int)ndevs, to_val);
      if(!(piped_output == 0) || !(ndone == 0))
        handle_pfds(tp, ndone, piped_output);

      else
        if(!(ndone >= 0))
        {
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 4))
          {
            return_value___errno_location_1=__errno_location();
            return_value___errno_location_2=__errno_location();
            return_value_strerror_3=strerror(*return_value___errno_location_2);
            fprintf(stderr, "Thread %d poll failed: %d/%s\n", tp->cpu, *return_value___errno_location_1, return_value_strerror_3);
          }

        }

    }
    return_value=handle_pfds(tp, ndevs, 1);
    close_ios(tp);
    tracer_signal_ready(tp, (enum thread_status)Th_leaving, 0);
    return (void *)0;
  }

  else
  {

  err:
    ;
    tracer_signal_ready(tp, (enum thread_status)Th_error, ret);
    return (void *)0;
  }
}

// tracer_signal_ready
// file blktrace.c line 561
static void tracer_signal_ready(struct tracer *tp, enum thread_status th_status, signed int status)
{
  pthread_mutex_lock(&mt_mutex);
  tp->status = status;
  if((signed int)th_status == Th_running)
    nthreads_running = nthreads_running + 1;

  else
    if((signed int)th_status == Th_error)
      nthreads_error = nthreads_error + 1;

    else
      nthreads_leaving = nthreads_leaving + 1;
  pthread_cond_signal(&mt_cond);
  pthread_mutex_unlock(&mt_mutex);
}

// tracer_wait_unblock
// file blktrace.c line 553
static void tracer_wait_unblock(struct tracer *tp)
{
  pthread_mutex_lock(&mt_mutex);
  while(tp->is_done == 0)
  {
    if(!(tracers_run == 0))
      break;

    pthread_cond_wait(&mt_cond, &mt_mutex);
  }
  pthread_mutex_unlock(&mt_mutex);
}

// unblock_tracers
// file blktrace.c line 545
static void unblock_tracers(void)
{
  pthread_mutex_lock(&mt_mutex);
  tracers_run = 1;
  pthread_cond_broadcast(&mt_cond);
  pthread_mutex_unlock(&mt_mutex);
}

// use_tracer_devpaths
// file blktrace.c line 489
static inline signed int use_tracer_devpaths(void)
{
  _Bool tmp_if_expr_2;
  signed int return_value_net_client_use_send_1;
  if(!(piped_output == 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_net_client_use_send_1=net_client_use_send();
    tmp_if_expr_2 = return_value_net_client_use_send_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_2;
}

// valid_act_opt
// file blktrace.h line 146
extern signed int valid_act_opt(signed int x)
{
  return (signed int)(1 <= x && x < 1 << 16);
}

// wait_empty_entries
// file blktrace.c line 1222
static signed int wait_empty_entries(void)
{
  pthread_mutex_lock(&dp_mutex);
  while(done == 0 && dp_entries == 0)
    t_pthread_cond_wait(&dp_cond, &dp_mutex);
  pthread_mutex_unlock(&dp_mutex);
  return (signed int)!(done != 0);
}

// wait_tracers
// file blktrace.c line 1931
static void wait_tracers(void)
{
  struct list_head *p;
  signed int return_value_use_tracer_devpaths_1;
  return_value_use_tracer_devpaths_1=use_tracer_devpaths();
  if(!(return_value_use_tracer_devpaths_1 == 0))
    process_trace_bufs();

  wait_tracers_leaving();
  p = (&tracers)->next;
  struct tracer *tmp_statement_expression_2;
  for( ; !(p == &tracers); p = p->next)
  {
    signed int ret;
    struct tracer *tp;
    const struct list_head *__mptr = p;
    tmp_statement_expression_2 = (struct tracer *)((char *)__mptr - (signed long int)(unsigned long int)&((struct tracer *)0)->head);
    tp = tmp_statement_expression_2;
    ret=pthread_join(tp->thread, (void **)(void *)0);
    if(!(ret == 0))
      fprintf(stderr, "Thread join %d failed %d\n", tp->cpu, ret);

  }
  signed int return_value_use_tracer_devpaths_3;
  return_value_use_tracer_devpaths_3=use_tracer_devpaths();
  if(!(return_value_use_tracer_devpaths_3 == 0))
    clean_trace_bufs();

  get_all_drops();
}

// wait_tracers_leaving
// file blktrace.c line 587
static void wait_tracers_leaving(void)
{
  pthread_mutex_lock(&mt_mutex);
  while(!(nthreads_leaving >= nthreads_running))
    t_pthread_cond_wait(&mt_cond, &mt_mutex);
  pthread_mutex_unlock(&mt_mutex);
}

// wait_tracers_ready
// file blktrace.c line 579
static void wait_tracers_ready(signed int ncpus_started)
{
  pthread_mutex_lock(&mt_mutex);
  while(!(nthreads_error + nthreads_running >= ncpus_started))
    t_pthread_cond_wait(&mt_cond, &mt_mutex);
  pthread_mutex_unlock(&mt_mutex);
}

// write_data
// file blktrace.c line 792
static signed int write_data(char *buf, signed int len)
{
  signed int ret;
  unsigned long int return_value_fwrite_1;
  signed int return_value_ferror_10;
  signed int *return_value___errno_location_2;
  do
  {

  rewrite:
    ;
    return_value_fwrite_1=fwrite((const void *)buf, (unsigned long int)len, (unsigned long int)1, pfp);
    ret = (signed int)return_value_fwrite_1;
    return_value_ferror_10=ferror(pfp);
    if(return_value_ferror_10 == 0 && ret == 1)
      goto __CPROVER_DUMP_L8;

    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 4))
      break;

    clearerr(pfp);
  }
  while((_Bool)1);
  _Bool tmp_if_expr_9;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_8;
  signed int *return_value___errno_location_7;
  if(piped_output == 0)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value___errno_location_6=__errno_location();
    if(!(*return_value___errno_location_6 == 32))
    {
      return_value___errno_location_7=__errno_location();
      tmp_if_expr_8 = *return_value___errno_location_7 != 9 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_9)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    fprintf(stderr, "write(%d) failed: %d/%s\n", len, *return_value___errno_location_3, return_value_strerror_5);
  }

  goto err;

__CPROVER_DUMP_L8:
  ;
  fflush(pfp);
  return 0;

err:
  ;
  clearerr(pfp);
  return 1;
}

