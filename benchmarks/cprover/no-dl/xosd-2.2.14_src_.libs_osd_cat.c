// #anon_enum$UPD_none=0$UPD_hide=1$UPD_show=2$UPD_timer=4$UPD_pos=8$UPD_lines=16$UPD_mask=32$UPD_size=64$UPD_content=48$UPD_font=120
// file intern.h line 126
enum anonymous$50 { UPD_none=0, UPD_hide=1, UPD_show=2, UPD_timer=4, UPD_pos=8, UPD_lines=16, UPD_mask=32, UPD_size=64, UPD_content=48, UPD_font=120 };

// #anon_enum$XOSD_left=0$XOSD_center=1$XOSD_right=2
// file ./xosd.h line 44
enum anonymous$8 { XOSD_left=0, XOSD_center=1, XOSD_right=2 };

// #anon_enum$XOSD_percentage=0$XOSD_string=1$XOSD_printf=2$XOSD_slider=3
// file ./xosd.h line 27
enum anonymous$0 { XOSD_percentage=0, XOSD_string=1, XOSD_printf=2, XOSD_slider=3 };

// #anon_enum$XOSD_top=0$XOSD_bottom=1$XOSD_middle=2
// file ./xosd.h line 36
enum anonymous$40 { XOSD_top=0, XOSD_bottom=1, XOSD_middle=2 };

// #anon_enum$bar_none=0$bar_percentage=1$bar_slider=2
// file osd_cat.c line 51
enum anonymous$17 { bar_none=0, bar_percentage=1, bar_slider=2 };

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$53;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$47;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$49;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$6;

// tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]
// file /usr/include/X11/Xlib.h line 430
struct anonymous$41;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$51;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$5;

// tag-#anon#ST[S32'function'||U32'$pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'$pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'$pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous$44;

// tag-#anon#ST[S32'screen_number'||S16'x_org'||S16'y_org'||S16'width'||S16'height'|]
// file /usr/include/X11/extensions/Xinerama.h line 32
struct anonymous$52;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$36;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$38;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$39;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$16;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$15;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$19;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$20;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$21;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$29;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$18;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$27;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$33;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$7;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$37;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$13;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$35;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$4;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$14;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$30;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$34;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$3;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$12;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$11;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$10;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$9;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$31;

// tag-#anon#ST[SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'max_ink_extent'||SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'max_logical_extent'|]
// file /usr/include/X11/Xlib.h line 1084
struct anonymous$45;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$43;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous$2;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$48;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$42;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$46;

// tag-DEBUG_LEVEL
// file intern.h line 36
const enum DEBUG_LEVEL { Dnone=0, Dfunction=1, Dlocking=2, Dselect=4, Dtrace=8, Dvalue=16, Dupdate=32, Dall=-1 };

// tag-LINE
// file intern.h line 66
enum LINE { LINE_blank=0, LINE_text=1, LINE_percentage=2, LINE_slider=3 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XOC
// file /usr/include/X11/Xlib.h line 1094
struct _XOC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-xosd
// file ../../src/xosd.h line 24
struct xosd;

// tag-xosd_bar
// file intern.h line 75
struct xosd_bar;

// tag-xosd_line
// file intern.h line 67
union xosd_line;

// tag-xosd_text
// file intern.h line 70
struct xosd_text;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous$2 *);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCopyArea
// file /usr/include/X11/Xlib.h line 2184
extern signed int XCopyArea(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int, signed int, signed int);
// XCreateFontSet
// file /usr/include/X11/Xlib.h line 3609
extern struct _XOC * XCreateFontSet(struct _XDisplay *, const char *, char ***, signed int *, char **);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$44 *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$49 *, unsigned long int, struct anonymous$43 *);
// XDefaultScreen
// file /usr/include/X11/Xlib.h line 2227
extern signed int XDefaultScreen(struct _XDisplay *);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XDisplayHeight
// file /usr/include/X11/Xlib.h line 2271
extern signed int XDisplayHeight(struct _XDisplay *, signed int);
// XDisplayWidth
// file /usr/include/X11/Xlib.h line 2292
extern signed int XDisplayWidth(struct _XDisplay *, signed int);
// XExtentsOfFontSet
// file /usr/include/X11/Xlib.h line 3648
extern struct anonymous$45 * XExtentsOfFontSet(struct _XOC *);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFillRectangles
// file /usr/include/X11/Xlib.h line 2499
extern signed int XFillRectangles(struct _XDisplay *, unsigned long int, struct _XGC *, struct anonymous$41 *, signed int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeFontSet
// file /usr/include/X11/Xlib.h line 3617
extern void XFreeFontSet(struct _XDisplay *, struct _XOC *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XFreeStringList
// file /usr/include/X11/Xlib.h line 1922
extern void XFreeStringList(char **);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XMapRaised
// file /usr/include/X11/Xlib.h line 2796
extern signed int XMapRaised(struct _XDisplay *, unsigned long int);
// XMoveWindow
// file /usr/include/X11/Xlib.h line 2834
extern signed int XMoveWindow(struct _XDisplay *, unsigned long int, signed int, signed int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous$2 *);
// XRaiseWindow
// file /usr/include/X11/Xlib.h line 3026
extern signed int XRaiseWindow(struct _XDisplay *, unsigned long int);
// XResizeWindow
// file /usr/include/X11/Xlib.h line 3099
extern signed int XResizeWindow(struct _XDisplay *, unsigned long int, unsigned int, unsigned int);
// XRootWindow
// file /usr/include/X11/Xlib.h line 1765
extern unsigned long int XRootWindow(struct _XDisplay *, signed int);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetBackground
// file /usr/include/X11/Xlib.h line 3154
extern signed int XSetBackground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetForeground
// file /usr/include/X11/Xlib.h line 3227
extern signed int XSetForeground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XShapeCombineMask
// file /usr/include/X11/extensions/shape.h line 85
extern void XShapeCombineMask(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int, signed int);
// XShapeQueryExtension
// file /usr/include/X11/extensions/shape.h line 51
extern signed int XShapeQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XStoreName
// file /usr/include/X11/Xlib.h line 3395
extern signed int XStoreName(struct _XDisplay *, unsigned long int, const char *);
// XSupportsLocale
// file /usr/include/X11/Xlib.h line 3551
extern signed int XSupportsLocale(void);
// XUnmapWindow
// file /usr/include/X11/Xlib.h line 3505
extern signed int XUnmapWindow(struct _XDisplay *, unsigned long int);
// XineramaIsActive
// file /usr/include/X11/extensions/Xinerama.h line 54
signed int XineramaIsActive(struct _XDisplay *);
// XineramaQueryExtension
// file /usr/include/X11/extensions/Xinerama.h line 42
signed int XineramaQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XineramaQueryScreens
// file /usr/include/X11/extensions/Xinerama.h line 66
struct anonymous$52 * XineramaQueryScreens(struct _XDisplay *, signed int *);
// XmbDrawString
// file /usr/include/X11/Xlib.h line 3760
extern void XmbDrawString(struct _XDisplay *, unsigned long int, struct _XOC *, struct _XGC *, signed int, signed int, const char *, signed int);
// XmbTextExtents
// file /usr/include/X11/Xlib.h line 3670
extern signed int XmbTextExtents(struct _XOC *, const char *, signed int, struct anonymous$41 *, struct anonymous$41 *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// _draw_bar
// file xosd.c line 98
static void _draw_bar(struct xosd *osd, signed int nbars, signed int on, struct anonymous$41 *p, struct anonymous$41 *mod, signed int is_slider);
// _draw_text
// file xosd.c line 186
static void _draw_text(struct xosd *osd, char *string, signed int x, signed int y);
// _wait_until_update
// file xosd.c line 38
static void _wait_until_update(struct xosd *osd, signed int generation);
// _xosd_lock
// file xosd.c line 72
static void _xosd_lock(struct xosd *osd);
// _xosd_unlock
// file xosd.c line 81
static void _xosd_unlock(struct xosd *osd);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// draw_bar
// file xosd.c line 119
static void draw_bar(struct xosd *osd, signed int line);
// draw_text
// file xosd.c line 197
static void draw_text(struct xosd *osd, signed int line);
// event_loop
// file xosd.c line 258
static void * event_loop(void *osdv);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// parse_colour
// file xosd.c line 509
static signed int parse_colour(struct xosd *osd, struct anonymous$2 *col, unsigned long int *pixel, const char *colour);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$42 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$42 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$42 *, const union anonymous$48 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$42 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$42 *, union anonymous$46 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$46 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$46 *, const union anonymous$48 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$46 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$46 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$6 *, struct anonymous$6 *, struct anonymous$6 *, struct timeval *);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// stay_on_top
// file xosd.c line 543
void stay_on_top(struct _XDisplay *dpy, unsigned long int win);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xosd_create
// file ./xosd.h line 59
struct xosd * xosd_create(signed int number_lines);
// xosd_destroy
// file ./xosd.h line 92
signed int xosd_destroy(struct xosd *osd);
// xosd_display
// file ./xosd.h line 134
signed int xosd_display(struct xosd *osd, signed int line, enum anonymous$0 command, ...);
// xosd_get_colour
// file xosd.c line 1242
signed int xosd_get_colour(struct xosd *osd, signed int *red, signed int *green, signed int *blue);
// xosd_get_number_lines
// file xosd.c line 1353
signed int xosd_get_number_lines(struct xosd *osd);
// xosd_hide
// file xosd.c line 1278
signed int xosd_hide(struct xosd *osd);
// xosd_init
// file xosd.c line 619
struct xosd * xosd_init(const char *font, const char *colour, signed int timeout, enum anonymous$40 pos, signed int voffset, signed int shadow_offset, signed int number_lines);
// xosd_is_onscreen
// file ./xosd.h line 146
signed int xosd_is_onscreen(struct xosd *osd);
// xosd_scroll
// file ./xosd.h line 346
signed int xosd_scroll(struct xosd *osd, signed int lines);
// xosd_set_align
// file ./xosd.h line 203
signed int xosd_set_align(struct xosd *osd, enum anonymous$8 align);
// xosd_set_bar_length
// file xosd.c line 896
signed int xosd_set_bar_length(struct xosd *osd, signed int length);
// xosd_set_colour
// file ./xosd.h line 308
signed int xosd_set_colour(struct xosd *osd, const char *colour);
// xosd_set_font
// file ./xosd.h line 320
signed int xosd_set_font(struct xosd *osd, const char *font);
// xosd_set_horizontal_offset
// file ./xosd.h line 269
signed int xosd_set_horizontal_offset(struct xosd *osd, signed int hoffset);
// xosd_set_outline_colour
// file ./xosd.h line 242
signed int xosd_set_outline_colour(struct xosd *osd, const char *colour);
// xosd_set_outline_offset
// file ./xosd.h line 229
signed int xosd_set_outline_offset(struct xosd *osd, signed int outline_offset);
// xosd_set_pos
// file ./xosd.h line 191
signed int xosd_set_pos(struct xosd *osd, enum anonymous$40 pos);
// xosd_set_shadow_colour
// file ./xosd.h line 255
signed int xosd_set_shadow_colour(struct xosd *osd, const char *colour);
// xosd_set_shadow_offset
// file ./xosd.h line 215
signed int xosd_set_shadow_offset(struct xosd *osd, signed int shadow_offset);
// xosd_set_timeout
// file ./xosd.h line 295
signed int xosd_set_timeout(struct xosd *osd, signed int timeout);
// xosd_set_vertical_offset
// file ./xosd.h line 283
signed int xosd_set_vertical_offset(struct xosd *osd, signed int voffset);
// xosd_show
// file xosd.c line 1298
signed int xosd_show(struct xosd *osd);
// xosd_uninit
// file xosd.c line 834
signed int xosd_uninit(struct xosd *osd);
// xosd_wait_until_no_display
// file ./xosd.h line 157
signed int xosd_wait_until_no_display(struct xosd *osd);

struct anonymous$53
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$5 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$49 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$47 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$53 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$47
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$49
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$6
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$41
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous$51
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$5
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$49 *visuals;
};

struct anonymous$44
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous$52
{
  // screen_number
  signed int screen_number;
  // x_org
  signed short int x_org;
  // y_org
  signed short int y_org;
  // width
  signed short int width;
  // height
  signed short int height;
};

struct anonymous$36
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$16
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$15
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$18
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$7
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$13
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$4
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$1
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$3
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$1 data;
};

struct anonymous$12
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$11
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$9
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$45
{
  // max_ink_extent
  struct anonymous$41 max_ink_extent;
  // max_logical_extent
  struct anonymous$41 max_logical_extent;
};

struct anonymous$43
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous$2
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

union anonymous$48
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$42
{
  // __data
  struct anonymous$51 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$46
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$7 xany;
  // xkey
  struct anonymous$9 xkey;
  // xbutton
  struct anonymous$10 xbutton;
  // xmotion
  struct anonymous$11 xmotion;
  // xcrossing
  struct anonymous$12 xcrossing;
  // xfocus
  struct anonymous$13 xfocus;
  // xexpose
  struct anonymous$14 xexpose;
  // xgraphicsexpose
  struct anonymous$15 xgraphicsexpose;
  // xnoexpose
  struct anonymous$16 xnoexpose;
  // xvisibility
  struct anonymous$4 xvisibility;
  // xcreatewindow
  struct anonymous$18 xcreatewindow;
  // xdestroywindow
  struct anonymous$19 xdestroywindow;
  // xunmap
  struct anonymous$20 xunmap;
  // xmap
  struct anonymous$21 xmap;
  // xmaprequest
  struct anonymous$22 xmaprequest;
  // xreparent
  struct anonymous$23 xreparent;
  // xconfigure
  struct anonymous$24 xconfigure;
  // xgravity
  struct anonymous$25 xgravity;
  // xresizerequest
  struct anonymous$26 xresizerequest;
  // xconfigurerequest
  struct anonymous$27 xconfigurerequest;
  // xcirculate
  struct anonymous$28 xcirculate;
  // xcirculaterequest
  struct anonymous$29 xcirculaterequest;
  // xproperty
  struct anonymous$30 xproperty;
  // xselectionclear
  struct anonymous$31 xselectionclear;
  // xselectionrequest
  struct anonymous$32 xselectionrequest;
  // xselection
  struct anonymous$33 xselection;
  // xcolormap
  struct anonymous$34 xcolormap;
  // xclient
  struct anonymous$3 xclient;
  // xmapping
  struct anonymous$35 xmapping;
  // xerror
  struct anonymous$36 xerror;
  // xkeymap
  struct anonymous$37 xkeymap;
  // xgeneric
  struct anonymous$38 xgeneric;
  // xcookie
  struct anonymous$39 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct xosd
{
  // event_thread
  unsigned long int event_thread;
  // mutex
  union anonymous$46 mutex;
  // cond_wait
  union anonymous$42 cond_wait;
  // pipefd
  signed int pipefd[2l];
  // mutex_sync
  union anonymous$46 mutex_sync;
  // cond_sync
  union anonymous$42 cond_sync;
  // display
  struct _XDisplay *display;
  // screen
  signed int screen;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // mask_bitmap
  unsigned long int mask_bitmap;
  // line_bitmap
  unsigned long int line_bitmap;
  // visual
  struct anonymous$49 *visual;
  // fontset
  struct _XOC *fontset;
  // extent
  struct anonymous$41 *extent;
  // gc
  struct _XGC *gc;
  // mask_gc
  struct _XGC *mask_gc;
  // mask_gc_back
  struct _XGC *mask_gc_back;
  // screen_width
  signed int screen_width;
  // screen_height
  signed int screen_height;
  // screen_xpos
  signed int screen_xpos;
  // height
  signed int height;
  // line_height
  signed int line_height;
  // pos
  enum anonymous$40 pos;
  // align
  enum anonymous$8 align;
  // hoffset
  signed int hoffset;
  // voffset
  signed int voffset;
  // shadow_offset
  signed int shadow_offset;
  // shadow_colour
  struct anonymous$2 shadow_colour;
  // shadow_pixel
  unsigned long int shadow_pixel;
  // outline_offset
  signed int outline_offset;
  // outline_colour
  struct anonymous$2 outline_colour;
  // outline_pixel
  unsigned long int outline_pixel;
  // bar_length
  signed int bar_length;
  // generation
  signed int generation;
  // done
  signed int done;
  // update
  enum anonymous$50 update;
  // pixel
  unsigned long int pixel;
  // colour
  struct anonymous$2 colour;
  // lines
  union xosd_line *lines;
  // number_lines
  signed int number_lines;
  // timeout
  signed int timeout;
  // timeout_start
  struct timeval timeout_start;
};

struct xosd_bar
{
  // type
  enum LINE type;
  // value
  signed int value;
};

struct xosd_text
{
  // type
  enum LINE type;
  // width
  signed int width;
  // string
  char *string;
};

union xosd_line
{
  // type
  enum LINE type;
  // text
  struct xosd_text text;
  // bar
  struct xosd_bar bar;
};


// XOSD_MAX_PRINTF_BUF_SIZE
// file intern.h line 149
static const signed int XOSD_MAX_PRINTF_BUF_SIZE = 2000;
// _xosd_debug_level
// file intern.h line 45
static const enum DEBUG_LEVEL _xosd_debug_level = (const enum DEBUG_LEVEL)0;
// align
// file osd_cat.c line 66
enum anonymous$8 align = (enum anonymous$8)XOSD_left;
// barmode
// file osd_cat.c line 51
enum anonymous$17 barmode = (enum anonymous$17)bar_none;
// buffer
// file osd_cat.c line 46
char buffer[1024l];
// colour
// file osd_cat.c line 49
char *colour = "red";
// delay
// file osd_cat.c line 56
signed int delay = 5;
// font
// file osd_cat.c line 48
char *font = (char *)(void *)0;
// forcewait
// file osd_cat.c line 57
signed int forcewait = 0;
// fp
// file osd_cat.c line 44
struct _IO_FILE *fp;
// hoffset
// file osd_cat.c line 60
signed int hoffset = 0;
// lines
// file osd_cat.c line 65
signed int lines = 5;
// long_options
// file osd_cat.c line 21
static struct option long_options[20l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="font", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="color", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="colour", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="indent", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 },
    { .name="delay", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="offset", .has_arg=1, .flag=(signed int *)(void *)0, .val=111 },
    { .name="pos", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="align", .has_arg=1, .flag=(signed int *)(void *)0, .val=65 },
    { .name="shadow", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="shadowcolour", .has_arg=1, .flag=(signed int *)(void *)0, .val=83 },
    { .name="age", .has_arg=2, .flag=(signed int *)(void *)0, .val=97 },
    { .name="lines", .has_arg=1, .flag=(signed int *)(void *)0, .val=108 },
    { .name="wait", .has_arg=0, .flag=(signed int *)(void *)0, .val=119 },
    { .name="outline", .has_arg=1, .flag=(signed int *)(void *)0, .val=79 },
    { .name="outlinecolour", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="barmode", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="percentage", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="text", .has_arg=1, .flag=(signed int *)(void *)0, .val=84 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// new_age
// file osd_cat.c line 63
struct timeval new_age;
// old_age
// file osd_cat.c line 63
struct timeval old_age;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// osd
// file osd_cat.c line 45
struct xosd *osd;
// osd_default_colour
// file xosd.c line 31
const char *osd_default_colour = "green";
// osd_default_font
// file xosd.c line 26
const char *osd_default_font = "-misc-fixed-medium-r-semicondensed--*-*-*-*-c-*-*-*";
// outline_colour
// file osd_cat.c line 54
char *outline_colour = (char *)(void *)0;
// outline_offset
// file osd_cat.c line 53
signed int outline_offset = 0;
// percentage
// file osd_cat.c line 52
signed int percentage = 50;
// pos
// file osd_cat.c line 58
enum anonymous$40 pos = (enum anonymous$40)XOSD_top;
// screen_line
// file osd_cat.c line 64
signed int screen_line = 0;
// scroll_age
// file osd_cat.c line 62
signed int scroll_age = 0;
// shadow
// file osd_cat.c line 61
signed int shadow = 0;
// shadow_colour
// file osd_cat.c line 55
char *shadow_colour = (char *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// text
// file osd_cat.c line 50
char *text = (char *)(void *)0;
// voffset
// file osd_cat.c line 59
signed int voffset = 0;
// xosd_error
// file xosd.c line 34
char *xosd_error;

// _draw_bar
// file xosd.c line 98
static void _draw_bar(struct xosd *osd, signed int nbars, signed int on, struct anonymous$41 *p, struct anonymous$41 *mod, signed int is_slider)
{
  signed int i;
  struct anonymous$41 rs[2l];
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 103, return_value_pthread_self$1, (const void *)"_draw_bar");
    }

  while((_Bool)0);
  rs[(signed long int)1].x = (signed short int)((signed int)mod->x + (signed int)p->x);
  rs[(signed long int)0].x = rs[(signed long int)1].x;
  rs[(signed long int)1].y = (signed short int)((signed int)mod->y + (signed int)p->y);
  rs[(signed long int)0].y = (signed short int)((signed int)rs[(signed long int)1].y + (signed int)p->height / 3);
  rs[(signed long int)0].width = (unsigned short int)((double)mod->width + (double)p->width * 0.8);
  rs[(signed long int)0].height = (unsigned short int)((signed int)mod->height + (signed int)p->height / 3);
  rs[(signed long int)1].width = (unsigned short int)((double)mod->width + (double)p->width * 0.7);
  rs[(signed long int)1].height = (unsigned short int)((signed int)mod->height + (signed int)p->height);
  i = 0;
  for( ; !(i >= nbars); rs[(signed long int)0].x = rs[(signed long int)1].x)
  {
    struct anonymous$41 *r = &rs[(signed long int)(is_slider != 0 ? (signed int)(i == on) : (signed int)(i < on))];
    XFillRectangles(osd->display, osd->mask_bitmap, osd->mask_gc, r, 1);
    XFillRectangles(osd->display, osd->line_bitmap, osd->gc, r, 1);
    i = i + 1;
    rs[(signed long int)1].x = rs[(signed long int)1].x + (signed short int)p->width;
  }
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 116, return_value_pthread_self$2, (const void *)"_draw_bar");
    }

  while((_Bool)0);
}

// _draw_text
// file xosd.c line 186
static void _draw_text(struct xosd *osd, char *string, signed int x, signed int y)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(string);
  len = (signed int)return_value_strlen$1;
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 189, return_value_pthread_self$2, (const void *)"_draw_text");
    }

  while((_Bool)0);
  XmbDrawString(osd->display, osd->mask_bitmap, osd->fontset, osd->mask_gc, x, y, string, len);
  XmbDrawString(osd->display, osd->line_bitmap, osd->fontset, osd->gc, x, y, string, len);
  unsigned long int return_value_pthread_self$3;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$3=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 194, return_value_pthread_self$3, (const void *)"_draw_text");
    }

  while((_Bool)0);
}

// _wait_until_update
// file xosd.c line 38
static void _wait_until_update(struct xosd *osd, signed int generation)
{
  pthread_mutex_lock(&osd->mutex_sync);
  unsigned long int return_value_pthread_self$1;
  while(osd->generation == generation)
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$1=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: waiting %d %d\n", (const void *)"xosd.c", 42, return_value_pthread_self$1, (const void *)"_wait_until_update", generation, osd->generation);
      }

    while((_Bool)0);
    pthread_cond_wait(&osd->cond_sync, &osd->mutex_sync);
  }
  pthread_mutex_unlock(&osd->mutex_sync);
}

// _xosd_lock
// file xosd.c line 72
static void _xosd_lock(struct xosd *osd)
{
  char c = (char)0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 75, return_value_pthread_self$1, (const void *)"_xosd_lock");
    }

  while((_Bool)0);
  write(osd->pipefd[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  pthread_mutex_lock(&osd->mutex);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 78, return_value_pthread_self$2, (const void *)"_xosd_lock");
    }

  while((_Bool)0);
}

// _xosd_unlock
// file xosd.c line 81
static void _xosd_unlock(struct xosd *osd)
{
  char c;
  signed int generation = osd->generation;
  signed int update = (signed int)osd->update;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 85, return_value_pthread_self$1, (const void *)"_xosd_unlock");
    }

  while((_Bool)0);
  read(osd->pipefd[(signed long int)0], (void *)&c, sizeof(char) /*1ul*/ );
  pthread_cond_signal(&osd->cond_wait);
  pthread_mutex_unlock(&osd->mutex);
  if(!((UPD_show & update) == 0))
    _wait_until_update(osd, generation & ~1);

  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 91, return_value_pthread_self$2, (const void *)"_xosd_unlock");
    }

  while((_Bool)0);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// draw_bar
// file xosd.c line 119
static void draw_bar(struct xosd *osd, signed int line)
{
  struct xosd_bar *l = &(osd->lines + (signed long int)line)->bar;
  signed int is_slider = (signed int)((signed int)l->type == LINE_slider);
  signed int nbars;
  signed int on;
  struct anonymous$41 p;
  struct anonymous$41 m;
  p.x = (signed short int)10;
  p.y = (signed short int)(osd->line_height * line);
  p.width = (unsigned short int)(-((signed int)osd->extent->y) / 2);
  p.height = (unsigned short int)-((signed int)osd->extent->y);
  /* assertion osd */
  assert(osd != ((struct xosd *)NULL));
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 130, return_value_pthread_self$1, (const void *)"draw_bar");
    }

  while((_Bool)0);
  if(osd->bar_length == -1)
  {
    nbars = (signed int)(((double)osd->screen_width * 0.8) / (double)p.width);
    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        p.x = (signed short int)((double)osd->screen_width * (((double)1 - 0.8) / (double)2));
        break;
      }
      case XOSD_right:
        p.x = (signed short int)((double)osd->screen_width * ((double)1 - 0.8));
      case XOSD_left:

      default:
        ;
    }
  }

  else
  {
    nbars = osd->bar_length;
    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        p.x = (signed short int)((osd->screen_width - nbars * (signed int)p.width) / 2);
        break;
      }
      case XOSD_right:
        p.x = (signed short int)((osd->screen_width - nbars * (signed int)p.width) - (signed int)p.x);
      case XOSD_left:

      default:
        ;
    }
  }
  on = ((nbars - is_slider) * l->value) / 100;
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: percent=%d, nbars=%d, on=%d\n", (const void *)"xosd.c", 158, return_value_pthread_self$2, (const void *)"draw_bar", l->value, nbars, on);
    }

  while((_Bool)0);
  if(!(osd->outline_offset == 0))
  {
    m.y = (signed short int)-osd->outline_offset;
    m.x = m.y;
    m.height = (unsigned short int)(2 * osd->outline_offset);
    m.width = m.height;
    XSetForeground(osd->display, osd->gc, osd->outline_pixel);
    _draw_bar(osd, nbars, on, &p, &m, is_slider);
  }

  if(!(osd->shadow_offset == 0))
  {
    m.y = (signed short int)osd->shadow_offset;
    m.x = m.y;
    m.height = (unsigned short int)0;
    m.width = m.height;
    XSetForeground(osd->display, osd->gc, osd->shadow_pixel);
    _draw_bar(osd, nbars, on, &p, &m, is_slider);
  }

  m.height = (unsigned short int)0;
  m.width = m.height;
  m.y = (signed short int)m.width;
  m.x = m.y;
  XSetForeground(osd->display, osd->gc, osd->pixel);
  _draw_bar(osd, nbars, on, &p, &m, is_slider);
}

// draw_text
// file xosd.c line 197
static void draw_text(struct xosd *osd, signed int line)
{
  signed int x = 10;
  signed int y = osd->line_height * line - (signed int)osd->extent->y;
  struct xosd_text *l = &(osd->lines + (signed long int)line)->text;
  /* assertion osd */
  assert(osd != ((struct xosd *)NULL));
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 203, return_value_pthread_self$1, (const void *)"draw_text");
    }

  while((_Bool)0);
  if(!(l->string == ((char *)NULL)))
  {
    if(!(l->width >= 0))
    {
      struct anonymous$41 rect;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(l->string);
      XmbTextExtents(osd->fontset, l->string, (signed int)return_value_strlen$2, (struct anonymous$41 *)(void *)0, &rect);
      l->width = (signed int)rect.width;
    }

    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        x = (osd->screen_width - l->width) / 2;
        goto __CPROVER_DUMP_L7;
      }
      case XOSD_right:
        x = (osd->screen_width - l->width) - x;
      case XOSD_left:

      default:
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(osd->shadow_offset == 0))
        {
          XSetForeground(osd->display, osd->gc, osd->shadow_pixel);
          _draw_text(osd, l->string, x + osd->shadow_offset, y + osd->shadow_offset);
        }

        if(!(osd->outline_offset == 0))
        {
          signed int i;
          signed int j;
          XSetForeground(osd->display, osd->gc, osd->outline_pixel);
          i = 1;
          for( ; osd->outline_offset >= i; i = i + 1)
          {
            j = 0;
            for( ; !(j >= 9); j = j + 1)
              if(!(j == 4))
                _draw_text(osd, l->string, x + (j / 3 - 1) * i, y + (j % 3 - 1) * i);

          }
        }

        XSetForeground(osd->display, osd->gc, osd->pixel);
        _draw_text(osd, l->string, x, y);
      }
    }
  }

}

// event_loop
// file xosd.c line 258
static void * event_loop(void *osdv)
{
  struct xosd *event_loop$$1$$osd = (struct xosd *)osdv;
  signed int xfd;
  signed int max;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 263, return_value_pthread_self$1, (const void *)"event_loop");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: event thread started\n", (const void *)"xosd.c", 264, return_value_pthread_self$2, (const void *)"event_loop");
    }

  while((_Bool)0);
  /* assertion osd */
  assert(event_loop$$1$$osd != ((struct xosd *)NULL));
  xfd = ((struct anonymous *)event_loop$$1$$osd->display)->fd;
  signed int tmp_if_expr$3;
  if(!(xfd >= event_loop$$1$$osd->pipefd[0l]))
    tmp_if_expr$3 = event_loop$$1$$osd->pipefd[(signed long int)0];

  else
    tmp_if_expr$3 = xfd;
  max = tmp_if_expr$3;
  pthread_mutex_lock(&event_loop$$1$$osd->mutex);
  unsigned long int return_value_pthread_self$4;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$4=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: Request exposure events\n", (const void *)"xosd.c", 271, return_value_pthread_self$4, (const void *)"event_loop");
    }

  while((_Bool)0);
  XSelectInput(event_loop$$1$$osd->display, event_loop$$1$$osd->window, 1L << 15);
  event_loop$$1$$osd->update = event_loop$$1$$osd->update | (enum anonymous$50)(UPD_size | UPD_pos | UPD_mask);
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  unsigned long int return_value_pthread_self$9;
  unsigned long int return_value_pthread_self$10;
  unsigned long int return_value_pthread_self$11;
  unsigned long int return_value_pthread_self$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  signed int tmp_if_expr$14;
  unsigned long int return_value_pthread_self$16;
  _Bool tmp_if_expr$28;
  signed int *return_value___errno_location$27;
  unsigned long int return_value_pthread_self$17;
  unsigned long int return_value_pthread_self$18;
  signed int *return_value___errno_location$19;
  unsigned long int return_value_pthread_self$20;
  unsigned long int return_value_pthread_self$21;
  struct anonymous$14 *event_loop$$1$$4$$17$$1$$1$$XE;
  unsigned long int return_value_pthread_self$22;
  struct anonymous$15 *XE;
  unsigned long int return_value_pthread_self$23;
  struct anonymous$16 *event_loop$$1$$4$$17$$1$$3$$XE;
  unsigned long int return_value_pthread_self$24;
  unsigned long int return_value_pthread_self$25;
  unsigned long int return_value_pthread_self$26;
  while(event_loop$$1$$osd->done == 0)
  {
    signed int retval;
    signed int line;
    struct anonymous$6 readfds;
    struct timeval tv;
    struct timeval *tvp = (struct timeval *)(void *)0;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$6) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << xfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    (&readfds)->__fds_bits[(signed long int)(event_loop$$1$$osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(event_loop$$1$$osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << event_loop$$1$$osd->pipefd[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!((UPD_hide & (signed int)event_loop$$1$$osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_hide\n", (const void *)"xosd.c", 285, return_value_pthread_self$5, (const void *)"event_loop");
        }

      while((_Bool)0);
      if(!((1 & event_loop$$1$$osd->generation) == 0))
      {
        XUnmapWindow(event_loop$$1$$osd->display, event_loop$$1$$osd->window);
        event_loop$$1$$osd->generation = event_loop$$1$$osd->generation + 1;
      }

    }

    if(!((UPD_size & (signed int)event_loop$$1$$osd->update) == 0))
    {
      struct anonymous$45 *extents;
      extents=XExtentsOfFontSet(event_loop$$1$$osd->fontset);
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$6=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_size\n", (const void *)"xosd.c", 295, return_value_pthread_self$6, (const void *)"event_loop");
        }

      while((_Bool)0);
      event_loop$$1$$osd->extent = &extents->max_logical_extent;
      event_loop$$1$$osd->line_height = (signed int)event_loop$$1$$osd->extent->height + event_loop$$1$$osd->shadow_offset + 2 * event_loop$$1$$osd->outline_offset;
      event_loop$$1$$osd->height = event_loop$$1$$osd->line_height * event_loop$$1$$osd->number_lines;
      line = 0;
      for( ; !(line >= event_loop$$1$$osd->number_lines); line = line + 1)
        if((signed int)(event_loop$$1$$osd->lines + (signed long int)line)->type == LINE_text)
          (event_loop$$1$$osd->lines + (signed long int)line)->text.width = -1;

      XResizeWindow(event_loop$$1$$osd->display, event_loop$$1$$osd->window, (unsigned int)event_loop$$1$$osd->screen_width, (unsigned int)event_loop$$1$$osd->height);
      XFreePixmap(event_loop$$1$$osd->display, event_loop$$1$$osd->mask_bitmap);
      event_loop$$1$$osd->mask_bitmap=XCreatePixmap(event_loop$$1$$osd->display, event_loop$$1$$osd->window, (unsigned int)event_loop$$1$$osd->screen_width, (unsigned int)event_loop$$1$$osd->height, (unsigned int)1);
      XFreePixmap(event_loop$$1$$osd->display, event_loop$$1$$osd->line_bitmap);
      event_loop$$1$$osd->line_bitmap=XCreatePixmap(event_loop$$1$$osd->display, event_loop$$1$$osd->window, (unsigned int)event_loop$$1$$osd->screen_width, (unsigned int)event_loop$$1$$osd->height, event_loop$$1$$osd->depth);
    }

    if(!((UPD_pos & (signed int)event_loop$$1$$osd->update) == 0))
    {
      signed int x = 0;
      signed int y = 0;
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$7=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_pos\n", (const void *)"xosd.c", 318, return_value_pthread_self$7, (const void *)"event_loop");
        }

      while((_Bool)0);
      switch((signed int)event_loop$$1$$osd->align)
      {
        case XOSD_left:

        case XOSD_center:
        {
          x = event_loop$$1$$osd->screen_xpos + event_loop$$1$$osd->hoffset;
          break;
        }
        case XOSD_right:
          x = event_loop$$1$$osd->screen_xpos - event_loop$$1$$osd->hoffset;
      }
      switch((signed int)event_loop$$1$$osd->pos)
      {
        case XOSD_bottom:
        {
          y = (event_loop$$1$$osd->screen_height - event_loop$$1$$osd->height) - event_loop$$1$$osd->voffset;
          break;
        }
        case XOSD_middle:
        {
          y = (event_loop$$1$$osd->screen_height - event_loop$$1$$osd->height) / 2 - event_loop$$1$$osd->voffset;
          break;
        }
        case XOSD_top:
          y = event_loop$$1$$osd->voffset;
      }
      XMoveWindow(event_loop$$1$$osd->display, event_loop$$1$$osd->window, x, y);
    }

    if(!((48 & (signed int)event_loop$$1$$osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$8=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_lines\n", (const void *)"xosd.c", 342, return_value_pthread_self$8, (const void *)"event_loop");
        }

      while((_Bool)0);
      line = 0;
      while(!(line >= event_loop$$1$$osd->number_lines))
      {
        signed int event_loop$$1$$4$$5$$2$$1$$y = event_loop$$1$$osd->line_height * line;
        if(!((UPD_mask & (signed int)event_loop$$1$$osd->update) == 0))
          XFillRectangle(event_loop$$1$$osd->display, event_loop$$1$$osd->mask_bitmap, event_loop$$1$$osd->mask_gc_back, 0, event_loop$$1$$4$$5$$2$$1$$y, (unsigned int)event_loop$$1$$osd->screen_width, (unsigned int)event_loop$$1$$osd->line_height);

        switch((signed int)(event_loop$$1$$osd->lines + (signed long int)line)->type)
        {
          case LINE_text:
          {
            draw_text(event_loop$$1$$osd, line);
            goto __CPROVER_DUMP_L36;
          }
          case LINE_percentage:

          case LINE_slider:
            draw_bar(event_loop$$1$$osd, line);
          case LINE_blank:

          default:
          {

          __CPROVER_DUMP_L36:
            ;
            line = line + 1;
          }
        }
      }
    }

    if(!((UPD_mask & (signed int)event_loop$$1$$osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$9=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_mask\n", (const void *)"xosd.c", 369, return_value_pthread_self$9, (const void *)"event_loop");
        }

      while((_Bool)0);
      XShapeCombineMask(event_loop$$1$$osd->display, event_loop$$1$$osd->window, 0, 0, 0, event_loop$$1$$osd->mask_bitmap, 0);
    }

    if(!((UPD_show & (signed int)event_loop$$1$$osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$10=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_show\n", (const void *)"xosd.c", 376, return_value_pthread_self$10, (const void *)"event_loop");
        }

      while((_Bool)0);
      if(!((~event_loop$$1$$osd->generation & 1) == 0))
      {
        event_loop$$1$$osd->generation = event_loop$$1$$osd->generation + 1;
        XMapRaised(event_loop$$1$$osd->display, event_loop$$1$$osd->window);
      }

    }

    if(!((1 & event_loop$$1$$osd->generation) == 0))
    {
      if(!((90 & (signed int)event_loop$$1$$osd->update) == 0))
      {
        do
          if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$11=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: UPD_copy\n", (const void *)"xosd.c", 385, return_value_pthread_self$11, (const void *)"event_loop");
          }

        while((_Bool)0);
        XCopyArea(event_loop$$1$$osd->display, event_loop$$1$$osd->line_bitmap, event_loop$$1$$osd->window, event_loop$$1$$osd->gc, 0, 0, (unsigned int)event_loop$$1$$osd->screen_width, (unsigned int)event_loop$$1$$osd->height, 0, 0);
      }

    }

    if(!((-5 & (signed int)event_loop$$1$$osd->update) == 0))
    {
      XFlush(event_loop$$1$$osd->display);
      event_loop$$1$$osd->update = event_loop$$1$$osd->update & (enum anonymous$50)UPD_timer;
    }

    if(!((UPD_timer & (signed int)event_loop$$1$$osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$12=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_timer\n", (const void *)"xosd.c", 396, return_value_pthread_self$12, (const void *)"event_loop");
        }

      while((_Bool)0);
      event_loop$$1$$osd->update = (enum anonymous$50)UPD_none;
      if(!((1 & event_loop$$1$$osd->generation) == 0))
        tmp_if_expr$13 = event_loop$$1$$osd->timeout > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        gettimeofday(&event_loop$$1$$osd->timeout_start, (struct timezone *)(void *)0);

      else
      {
        (&event_loop$$1$$osd->timeout_start)->tv_usec = (signed long int)0;
        (&event_loop$$1$$osd->timeout_start)->tv_sec = (&event_loop$$1$$osd->timeout_start)->tv_usec;
      }
    }

    if(!(event_loop$$1$$osd->timeout_start.tv_sec == 0l))
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = (&event_loop$$1$$osd->timeout_start)->tv_usec != 0l ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
    {
      gettimeofday(&tv, (struct timezone *)(void *)0);
      tv.tv_sec = tv.tv_sec - (signed long int)event_loop$$1$$osd->timeout;
      if(tv.tv_sec == event_loop$$1$$osd->timeout_start.tv_sec)
        tmp_if_expr$14 = (signed int)((&tv)->tv_usec < (&event_loop$$1$$osd->timeout_start)->tv_usec);

      else
        tmp_if_expr$14 = (signed int)((&tv)->tv_sec < (&event_loop$$1$$osd->timeout_start)->tv_sec);
      if(!(tmp_if_expr$14 == 0))
      {
        tv.tv_sec = event_loop$$1$$osd->timeout_start.tv_sec - tv.tv_sec;
        tv.tv_usec = event_loop$$1$$osd->timeout_start.tv_usec - tv.tv_usec;
        if(!(tv.tv_usec >= 0l))
        {
          tv.tv_usec = tv.tv_usec + (signed long int)1000000;
          tv.tv_sec = tv.tv_sec - (signed long int)1;
        }

        tvp = &tv;
        goto __CPROVER_DUMP_L61;
      }

      (&event_loop$$1$$osd->timeout_start)->tv_usec = (signed long int)0;
      (&event_loop$$1$$osd->timeout_start)->tv_sec = (&event_loop$$1$$osd->timeout_start)->tv_usec;
      if(!((1 & event_loop$$1$$osd->generation) == 0))
        event_loop$$1$$osd->update = event_loop$$1$$osd->update | (enum anonymous$50)UPD_hide;

    }

    else
    {

    __CPROVER_DUMP_L61:
      ;
      pthread_mutex_lock(&event_loop$$1$$osd->mutex_sync);
      pthread_cond_broadcast(&event_loop$$1$$osd->cond_sync);
      pthread_mutex_unlock(&event_loop$$1$$osd->mutex_sync);
      retval=select(max + 1, &readfds, (struct anonymous$6 *)(void *)0, (struct anonymous$6 *)(void *)0, tvp);
      do
        if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$16=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: SELECT=%d PIPE=%d X11=%d\n", (const void *)"xosd.c", 431, return_value_pthread_self$16, (const void *)"event_loop", retval, ((&readfds)->__fds_bits[(signed long int)(event_loop$$1$$osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << event_loop$$1$$osd->pipefd[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0, ((&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << xfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0);
        }

      while((_Bool)0);
      if(retval == -1)
      {
        return_value___errno_location$27=__errno_location();
        tmp_if_expr$28 = *return_value___errno_location$27 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$28 = (_Bool)0;
      if(tmp_if_expr$28)
      {
        do
          if(!((Dselect & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$17=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: select() EINTR\n", (const void *)"xosd.c", 434, return_value_pthread_self$17, (const void *)"event_loop");
          }

        while((_Bool)0);
        continue;
      }

      else
        if(retval == -1)
        {
          do
            if(!((Dselect & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$18=pthread_self();
              return_value___errno_location$19=__errno_location();
              fprintf(stderr, "%s:%-4d %ld@%s: select() error %d\n", (const void *)"xosd.c", 437, return_value_pthread_self$18, (const void *)"event_loop", *return_value___errno_location$19);
            }

          while((_Bool)0);
          event_loop$$1$$osd->done = 1;
          break;
        }

        else
          if(retval == 0)
          {
            do
              if(!((Dselect & (signed int)_xosd_debug_level) == 0))
              {
                return_value_pthread_self$20=pthread_self();
                fprintf(stderr, "%s:%-4d %ld@%s: select() timeout\n", (const void *)"xosd.c", 441, return_value_pthread_self$20, (const void *)"event_loop");
              }

            while((_Bool)0);
            continue;
          }

          else
            if(!((readfds.__fds_bits[(signed long int)(event_loop$$1$$osd->pipefd[0l] / 8)] & (signed long int)(1UL << event_loop$$1$$osd->pipefd[0l] % 8)) == 0l))
            {
              pthread_cond_wait(&event_loop$$1$$osd->cond_wait, &event_loop$$1$$osd->mutex);
              do
                if(!((Dselect & (signed int)_xosd_debug_level) == 0))
                {
                  return_value_pthread_self$21=pthread_self();
                  fprintf(stderr, "%s:%-4d %ld@%s: Resume exposure thread after X11 call\n", (const void *)"xosd.c", 446, return_value_pthread_self$21, (const void *)"event_loop");
                }

              while((_Bool)0);
              continue;
            }

            else
              if(!((readfds.__fds_bits[(signed long int)(xfd / 8)] & (signed long int)(1UL << xfd % 8)) == 0l))
              {
                union _XEvent report;
                XNextEvent(event_loop$$1$$osd->display, &report);
                switch(report.type & 0x7f)
                {
                  case 12:
                  {
                    event_loop$$1$$4$$17$$1$$1$$XE = &report.xexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$22=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: expose %d: x=%d y=%d w=%d h=%d\n", (const void *)"xosd.c", 460, return_value_pthread_self$22, (const void *)"event_loop", event_loop$$1$$4$$17$$1$$1$$XE->count, event_loop$$1$$4$$17$$1$$1$$XE->x, event_loop$$1$$4$$17$$1$$1$$XE->y, event_loop$$1$$4$$17$$1$$1$$XE->width, event_loop$$1$$4$$17$$1$$1$$XE->height);
                      }

                    while((_Bool)0);
                    XCopyArea(event_loop$$1$$osd->display, event_loop$$1$$osd->line_bitmap, event_loop$$1$$osd->window, event_loop$$1$$osd->gc, report.xexpose.x, report.xexpose.y, (unsigned int)report.xexpose.width, (unsigned int)report.xexpose.height, report.xexpose.x, report.xexpose.y);
                    break;
                  }
                  case 13:
                  {
                    XE = &report.xgraphicsexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$23=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: gfxexpose %d: x=%d y=%d w=%d h=%d code=%d\n", (const void *)"xosd.c", 481, return_value_pthread_self$23, (const void *)"event_loop", XE->count, XE->x, XE->y, XE->width, XE->height, XE->major_code);
                      }

                    while((_Bool)0);
                    break;
                  }
                  case 14:
                  {
                    event_loop$$1$$4$$17$$1$$3$$XE = &report.xnoexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$24=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: noexpose: code=%d\n", (const void *)"xosd.c", 487, return_value_pthread_self$24, (const void *)"event_loop", event_loop$$1$$4$$17$$1$$3$$XE->major_code);
                      }

                    while((_Bool)0);
                    break;
                  }
                  default:
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$25=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: XEvent=%d\n", (const void *)"xosd.c", 491, return_value_pthread_self$25, (const void *)"event_loop", report.type);
                      }

                    while((_Bool)0);
                }
                continue;
              }

              else
              {
                do
                  if(!((Dselect & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$26=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: select() FATAL %d\n", (const void *)"xosd.c", 496, return_value_pthread_self$26, (const void *)"event_loop", retval);
                  }

                while((_Bool)0);
                exit(-1);
              }
    }
  }
  pthread_mutex_unlock(&event_loop$$1$$osd->mutex);
  return (void *)0;
}

// main
// file osd_cat.c line 69
signed int main(signed int argc, char **argv)
{
  char *return_value_setlocale$1;
  return_value_setlocale$1=setlocale(6, "");
  _Bool tmp_if_expr$3;
  signed int return_value_XSupportsLocale$2;
  if(return_value_setlocale$1 == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_XSupportsLocale$2=XSupportsLocale();
    tmp_if_expr$3 = !(return_value_XSupportsLocale$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    fprintf(stderr, "Locale not available, expect problems with fonts.\n");

  signed int tmp_if_expr$5;
  signed int return_value_atoi$4;
  signed int return_value_strcasecmp$9;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$12;
  signed int return_value_strcasecmp$11;
  signed int return_value_strcasecmp$10;
  signed int return_value_strcasecmp$14;
  signed int return_value_strcasecmp$13;
  while((_Bool)1)
  {
    signed int option_index = 0;
    signed int c;
    c=getopt_long(argc, argv, "l:A:a::f:c:d:o:i:s:p:O:S:u:b:P:T:hw", long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 97:
      {
        if(!(optarg == ((char *)NULL)))
        {
          return_value_atoi$4=atoi(optarg);
          tmp_if_expr$5 = return_value_atoi$4;
        }

        else
          tmp_if_expr$5 = delay;
        scroll_age = tmp_if_expr$5;
        break;
      }
      case 119:
      {
        forcewait = 1;
        break;
      }
      case 65:
      {
        return_value_strcasecmp$9=strcasecmp(optarg, "left");
        if(return_value_strcasecmp$9 == 0)
          align = (enum anonymous$8)XOSD_left;

        else
        {
          return_value_strcasecmp$8=strcasecmp(optarg, "right");
          if(return_value_strcasecmp$8 == 0)
            align = (enum anonymous$8)XOSD_right;

          else
          {
            return_value_strcasecmp$7=strcasecmp(optarg, "center");
            if(return_value_strcasecmp$7 == 0)
              align = (enum anonymous$8)XOSD_center;

            else
            {
              return_value_strcasecmp$6=strcasecmp(optarg, "centre");
              if(return_value_strcasecmp$6 == 0)
                align = (enum anonymous$8)XOSD_center;

              else
              {
                fprintf(stderr, "Unknown alignment: %s\n", optarg);
                return 1;
              }
            }
          }
        }
        break;
      }
      case 112:
      {
        return_value_strcasecmp$12=strcasecmp(optarg, "top");
        if(return_value_strcasecmp$12 == 0)
          pos = (enum anonymous$40)XOSD_top;

        else
        {
          return_value_strcasecmp$11=strcasecmp(optarg, "middle");
          if(return_value_strcasecmp$11 == 0)
            pos = (enum anonymous$40)XOSD_middle;

          else
          {
            return_value_strcasecmp$10=strcasecmp(optarg, "bottom");
            if(return_value_strcasecmp$10 == 0)
              pos = (enum anonymous$40)XOSD_bottom;

            else
            {
              fprintf(stderr, "Unknown alignment: %s\n", optarg);
              return 1;
            }
          }
        }
        break;
      }
      case 102:
      {
        font = optarg;
        break;
      }
      case 99:
      {
        colour = optarg;
        break;
      }
      case 100:
      {
        delay=atoi(optarg);
        break;
      }
      case 111:
      {
        voffset=atoi(optarg);
        break;
      }
      case 79:
      {
        outline_offset=atoi(optarg);
        break;
      }
      case 83:
      {
        shadow_colour = optarg;
        break;
      }
      case 117:
      {
        outline_colour = optarg;
        break;
      }
      case 105:
      {
        hoffset=atoi(optarg);
        break;
      }
      case 115:
      {
        shadow=atoi(optarg);
        break;
      }
      case 108:
      {
        lines=atoi(optarg);
        if(!(lines >= 1))
        {
          fprintf(stderr, "Illegal number of lines: %d\n", lines);
          return 1;
        }

        break;
      }
      case 98:
      {
        return_value_strcasecmp$14=strcasecmp(optarg, "percentage");
        if(return_value_strcasecmp$14 == 0)
          barmode = (enum anonymous$17)bar_percentage;

        else
        {
          return_value_strcasecmp$13=strcasecmp(optarg, "slider");
          if(return_value_strcasecmp$13 == 0)
            barmode = (enum anonymous$17)bar_slider;

          else
          {
            fprintf(stderr, "Unknown barmode: %s.\n", optarg);
            return 1;
          }
        }
        break;
      }
      case 80:
      {
        percentage=atoi(optarg);
        break;
      }
      case 84:
      {
        text = optarg;
        break;
      }
      case 63:

      case 104:

      default:
      {
        fprintf(stderr, "Usage: %s [OPTION] [FILE]...\n", argv[(signed long int)0]);
        fprintf(stderr, "Version: %s\n", (const void *)"2.2.14");
        fprintf(stderr, "Display FILE, or standard input, on top of display.\n\n  -h, --help          Show this help\n  -p, --pos=(top|middle|bottom)\n                      Display at top/middle/bottom of screen. Top is default\n  -o, --offset=OFFSET Vertical Offset\n  -A, --align=(left|right|center)\n                      Display at left/right/center of screen.Left is default\n  -i, --indent=OFFSET Horizontal Offset\n  -f, --font=FONT     Use font (default: %s)\n", osd_default_font);
        fprintf(stderr, "  -c, --colour=COLOUR Use colour\n  -s, --shadow=OFFSET Offset of shadow, default is 0 which is no shadow\n  -S, --shadowcolour=COLOUR\n                      Colour of shadow, default is black\n  -O, --outline=WIDTH\n                      Offset of outline, default is 0 which is no outline\n  -u, --outlinecolour=COLOUR\n                      Colour of outline, default is black\n  -a, --age[=TIME]    Time in seconds before old scroll lines are discarded\n                      If no time is given, the current DELAY is used.\n  -l, --lines=N       Scroll using n lines. Default is 5.\n  -d, --delay=TIME    Show for specified time\n  -w, --wait          Delay display even when new lines are ready\n\n  -b, --barmode=(percentage|slider)\n                      Lets you display a percentage or slider bar instead of just text.\n                      Options may be 'percentage' or 'slider'.\n                      Disregards any text or files when used.\n                      When this option is used, the following options are also valid.\n  -P, --percentage=PERCENTAGE\n                      The length of the percentage bar / slider position (0 to 100).\n  -T, --text=TEXT     The text to get displayed above the percentage bar.\n\n\nWith no FILE, or when FILE is -, read standard input.\n");
        return 0;
      }
    }
  }
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$17;
  signed int return_value_strncmp$16;
  if(!(barmode == /*enum*/bar_none))
  {
    if(!(text == ((char *)NULL)))
      tmp_if_expr$15 = *text != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$15 = (_Bool)0;
    osd=xosd_create(tmp_if_expr$15 ? 2 : 1);
  }

  else
  {
    if(!(optind >= argc))
    {
      return_value_strncmp$16=strncmp(argv[(signed long int)optind], "-", (unsigned long int)2);
      tmp_if_expr$17 = return_value_strncmp$16 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$17 = (_Bool)0;
    if(tmp_if_expr$17)
    {
      fp=fopen(argv[(signed long int)optind], "r");
      if(fp == ((struct _IO_FILE *)NULL))
      {
        fprintf(stderr, "Unable to open: %s\n", argv[(signed long int)optind]);
        return 1;
      }

    }

    else
      fp = stdin;
    osd=xosd_create(lines);
  }
  signed int return_value_xosd_set_font$18;
  signed int return_value_feof$19;
  signed int return_value_xosd_is_onscreen$21;
  signed int tmp_post$22;
  signed int return_value_feof$25;
  if(osd == ((struct xosd *)NULL))
  {
    fprintf(stderr, "Error initializing osd: %s\n", xosd_error);
    return 1;
  }

  else
  {
    xosd_set_shadow_offset(osd, shadow);
    if(!(shadow_colour == ((char *)NULL)))
      xosd_set_shadow_colour(osd, shadow_colour);

    xosd_set_outline_offset(osd, outline_offset);
    if(!(outline_colour == ((char *)NULL)))
      xosd_set_outline_colour(osd, outline_colour);

    if(!(colour == ((char *)NULL)))
      xosd_set_colour(osd, colour);

    xosd_set_timeout(osd, delay);
    xosd_set_pos(osd, pos);
    xosd_set_vertical_offset(osd, voffset);
    xosd_set_horizontal_offset(osd, hoffset);
    xosd_set_align(osd, align);
    if(!(font == ((char *)NULL)))
    {
      return_value_xosd_set_font$18=xosd_set_font(osd, font);
      if(return_value_xosd_set_font$18 == 0)
        goto __CPROVER_DUMP_L53;

      fprintf(stderr, "ABORT: %s\n", xosd_error);
      return 1;
    }

    else
    {

    __CPROVER_DUMP_L53:
      ;
      switch((signed int)barmode)
      {
        case bar_percentage:
        {
          if(!(text == ((char *)NULL)))
            xosd_display(osd, 0, (enum anonymous$0)XOSD_string, text);

          xosd_display(osd, text != ((char *)NULL) ? 1 : 0, (enum anonymous$0)XOSD_percentage, percentage);
          break;
        }
        case bar_slider:
        {
          if(!(text == ((char *)NULL)))
            xosd_display(osd, 0, (enum anonymous$0)XOSD_string, text);

          xosd_display(osd, text != ((char *)NULL) ? 1 : 0, (enum anonymous$0)XOSD_slider, percentage);
          break;
        }
        case bar_none:
        {
          old_age.tv_sec = (signed long int)0;
          if(!(scroll_age == 0))
            gettimeofday(&old_age, ((struct timezone *)NULL));

          do
          {
            return_value_feof$19=feof(fp);
            if(!(return_value_feof$19 == 0))
              break;

            char *return_value_fgets$26;
            return_value_fgets$26=fgets(buffer, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1), fp);
            if(!(return_value_fgets$26 == ((char *)NULL)))
            {
              char *newline;
              char *return_value___builtin_strchr$20;
              return_value___builtin_strchr$20=__builtin_strchr(buffer, 10);
              newline = return_value___builtin_strchr$20;
              if(!(newline == ((char *)NULL)))
                newline[(signed long int)0] = (char)0;

              if(!(forcewait == 0))
              {
                return_value_xosd_is_onscreen$21=xosd_is_onscreen(osd);
                if(!(return_value_xosd_is_onscreen$21 == 0))
                  xosd_wait_until_no_display(osd);

              }

              if(!(scroll_age == 0))
              {
                gettimeofday(&new_age, ((struct timezone *)NULL));
                if(!((signed long int)scroll_age >= new_age.tv_sec + -old_age.tv_sec))
                {
                  if(lines >= 2)
                    xosd_scroll(osd, lines);

                  screen_line = 0;
                }

              }

              if(screen_line >= lines)
              {
                if(lines >= 2)
                  xosd_scroll(osd, 1);

                screen_line = lines - 1;
              }

              tmp_post$22 = screen_line;
              screen_line = screen_line + 1;
              xosd_display(osd, tmp_post$22, (enum anonymous$0)XOSD_string, (const void *)buffer);
              old_age.tv_sec = new_age.tv_sec;
            }

            else
            {
              return_value_feof$25=feof(fp);
              if(return_value_feof$25 == 0)
              {
                signed int *return_value___errno_location$23;
                return_value___errno_location$23=__errno_location();
                char *return_value_strerror$24;
                return_value_strerror$24=strerror(*return_value___errno_location$23);
                fprintf(stderr, "Error occured reading input file: %s\n", return_value_strerror$24);
                exit(1);
              }

            }
          }
          while((_Bool)1);
          fclose(fp);
        }
      }
      signed int return_value_xosd_is_onscreen$27;
      return_value_xosd_is_onscreen$27=xosd_is_onscreen(osd);
      if(!(return_value_xosd_is_onscreen$27 == 0))
        xosd_wait_until_no_display(osd);

      xosd_destroy(osd);
      return 0;
    }
  }
}

// parse_colour
// file xosd.c line 509
static signed int parse_colour(struct xosd *osd, struct anonymous$2 *col, unsigned long int *pixel, const char *colour)
{
  unsigned long int colourmap;
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 515, return_value_pthread_self$1, (const void *)"parse_colour");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: getting colourmap\n", (const void *)"xosd.c", 516, return_value_pthread_self$2, (const void *)"parse_colour");
    }

  while((_Bool)0);
  colourmap = (&((struct anonymous *)osd->display)->screens[(signed long int)osd->screen])->cmap;
  unsigned long int return_value_pthread_self$3;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$3=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: parsing colour\n", (const void *)"xosd.c", 519, return_value_pthread_self$3, (const void *)"parse_colour");
    }

  while((_Bool)0);
  signed int return_value_XParseColor$9;
  return_value_XParseColor$9=XParseColor(osd->display, colourmap, colour, col);
  unsigned long int return_value_pthread_self$4;
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$8;
  if(!(return_value_XParseColor$9 == 0))
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$4=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: attempting to allocate colour\n", (const void *)"xosd.c", 521, return_value_pthread_self$4, (const void *)"parse_colour");
      }

    while((_Bool)0);
    signed int return_value_XAllocColor$7;
    return_value_XAllocColor$7=XAllocColor(osd->display, colourmap, col);
    if(!(return_value_XAllocColor$7 == 0))
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: allocation sucessful\n", (const void *)"xosd.c", 523, return_value_pthread_self$5, (const void *)"parse_colour");
        }

      while((_Bool)0);
      *pixel = col->pixel;
    }

    else
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$6=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: defaulting to white. could not allocate colour\n", (const void *)"xosd.c", 526, return_value_pthread_self$6, (const void *)"parse_colour");
        }

      while((_Bool)0);
      *pixel = (&((struct anonymous *)osd->display)->screens[(signed long int)osd->screen])->white_pixel;
      retval = -1;
    }
  }

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$8=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: could not poarse colour. defaulting to white\n", (const void *)"xosd.c", 531, return_value_pthread_self$8, (const void *)"parse_colour");
      }

    while((_Bool)0);
    *pixel = (&((struct anonymous *)osd->display)->screens[(signed long int)osd->screen])->white_pixel;
    retval = -1;
  }
  return retval;
}

// stay_on_top
// file xosd.c line 543
void stay_on_top(struct _XDisplay *dpy, unsigned long int win)
{
  unsigned long int gnome;
  unsigned long int net_wm;
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *args = (unsigned char *)(void *)0;
  unsigned long int root = (&((struct anonymous *)dpy)->screens[(signed long int)((struct anonymous *)dpy)->default_screen])->root;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 551, return_value_pthread_self$1, (const void *)"stay_on_top");
    }

  while((_Bool)0);
  gnome=XInternAtom(dpy, "_WIN_SUPPORTING_WM_CHECK", 0);
  net_wm=XInternAtom(dpy, "_NET_SUPPORTED", 0);
  signed int return_value_XGetWindowProperty$3;
  return_value_XGetWindowProperty$3=XGetWindowProperty(dpy, root, gnome, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 0, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, &args);
  signed int return_value_XGetWindowProperty$2;
  if(return_value_XGetWindowProperty$3 == 0 && nitems >= 1ul)
  {
    struct anonymous$3 xev;
    unsigned long int gnome_layer;
    gnome_layer=XInternAtom(dpy, "_WIN_LAYER", 0);
    memset((void *)&xev, 0, sizeof(struct anonymous$3) /*96ul*/ );
    xev.type = 33;
    xev.window = win;
    xev.message_type = gnome_layer;
    xev.format = 32;
    xev.data.l[(signed long int)0] = (signed long int)6;
    XSendEvent(dpy, (&((struct anonymous *)dpy)->screens[(signed long int)((struct anonymous *)dpy)->default_screen])->root, 0, 1L << 19, (union _XEvent *)&xev);
    XFree((void *)args);
  }

  else
  {
    return_value_XGetWindowProperty$2=XGetWindowProperty(dpy, root, net_wm, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 0, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, &args);
    if(return_value_XGetWindowProperty$2 == 0)
    {
      if(nitems >= 1ul)
      {
        union _XEvent e;
        unsigned long int net_wm_state;
        net_wm_state=XInternAtom(dpy, "_NET_WM_STATE", 0);
        unsigned long int net_wm_top;
        net_wm_top=XInternAtom(dpy, "_NET_WM_STATE_STAYS_ON_TOP", 0);
        memset((void *)&e, 0, sizeof(union _XEvent) /*192ul*/ );
        e.xclient.type = 33;
        e.xclient.message_type = net_wm_state;
        e.xclient.display = dpy;
        e.xclient.window = win;
        e.xclient.format = 32;
        e.xclient.data.l[(signed long int)0] = (signed long int)1;
        e.xclient.data.l[(signed long int)1] = (signed long int)net_wm_top;
        e.xclient.data.l[(signed long int)2] = 0l;
        e.xclient.data.l[(signed long int)3] = 0l;
        e.xclient.data.l[(signed long int)4] = 0l;
        XSendEvent(dpy, (&((struct anonymous *)dpy)->screens[(signed long int)((struct anonymous *)dpy)->default_screen])->root, 0, 1L << 20, &e);
        XFree((void *)args);
      }

    }

  }
  XRaiseWindow(dpy, win);
}

// xosd_create
// file ./xosd.h line 59
struct xosd * xosd_create(signed int number_lines)
{
  struct xosd *xosd_create$$1$$osd;
  signed int event_basep;
  signed int error_basep;
  signed int i;
  char *display;
  struct anonymous$43 setwinattr;
  struct anonymous$44 xgcv = { .function=0, .plane_mask=0ul, .foreground=0ul, .background=0ul,
    .line_width=0, .line_style=0, .cap_style=0,
    .join_style=0, .fill_style=0, .fill_rule=0,
    .arc_mode=0, .tile=0ul, .stipple=0ul,
    .ts_x_origin=0, .ts_y_origin=0, .font=0ul,
    .subwindow_mode=0, .graphics_exposures=0, .clip_x_origin=0,
    .clip_y_origin=0, .clip_mask=0ul, .dash_offset=0,
    .dashes=0 };
  signed int screens;
  signed int dummy_a;
  signed int dummy_b;
  struct anonymous$52 *screeninfo = (struct anonymous$52 *)(void *)0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 662, return_value_pthread_self$1, (const void *)"xosd_create");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: getting display\n", (const void *)"xosd.c", 663, return_value_pthread_self$2, (const void *)"xosd_create");
    }

  while((_Bool)0);
  display=getenv("DISPLAY");
  unsigned long int return_value_pthread_self$3;
  unsigned long int return_value_pthread_self$5;
  signed int return_value_pipe$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  unsigned long int return_value_pthread_self$9;
  void *return_value_malloc$10;
  unsigned long int return_value_pthread_self$11;
  unsigned long int return_value_pthread_self$12;
  unsigned long int return_value_pthread_self$13;
  signed int return_value_XShapeQueryExtension$14;
  unsigned long int return_value_pthread_self$15;
  unsigned long int return_value_pthread_self$16;
  signed int return_value_XineramaQueryExtension$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$20;
  signed int return_value_XineramaIsActive$19;
  unsigned long int return_value_pthread_self$21;
  unsigned long int return_value_XRootWindow$22;
  unsigned long int return_value_pthread_self$23;
  unsigned long int return_value_pthread_self$24;
  unsigned long int return_value_pthread_self$25;
  if(display == ((char *)NULL))
  {
    xosd_error = "No display";
    return (struct xosd *)(void *)0;
  }

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$3=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: Mallocing osd\n", (const void *)"xosd.c", 670, return_value_pthread_self$3, (const void *)"xosd_create");
      }

    while((_Bool)0);
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct xosd) /*456ul*/ );
    xosd_create$$1$$osd = (struct xosd *)return_value_malloc$4;
    memset((void *)xosd_create$$1$$osd, 0, sizeof(struct xosd) /*456ul*/ );
    if(xosd_create$$1$$osd == ((struct xosd *)NULL))
      xosd_error = "Out of memory";

    else
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: Creating pipe\n", (const void *)"xosd.c", 678, return_value_pthread_self$5, (const void *)"xosd_create");
        }

      while((_Bool)0);
      return_value_pipe$6=pipe(xosd_create$$1$$osd->pipefd);
      if(return_value_pipe$6 == -1)
        xosd_error = "Error creating pipe";

      else
      {
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$7=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing mutex\n", (const void *)"xosd.c", 684, return_value_pthread_self$7, (const void *)"xosd_create");
          }

        while((_Bool)0);
        pthread_mutex_init(&xosd_create$$1$$osd->mutex, (const union anonymous$48 *)(void *)0);
        pthread_mutex_init(&xosd_create$$1$$osd->mutex_sync, (const union anonymous$48 *)(void *)0);
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$8=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing condition\n", (const void *)"xosd.c", 687, return_value_pthread_self$8, (const void *)"xosd_create");
          }

        while((_Bool)0);
        pthread_cond_init(&xosd_create$$1$$osd->cond_wait, (const union anonymous$48 *)(void *)0);
        pthread_cond_init(&xosd_create$$1$$osd->cond_sync, (const union anonymous$48 *)(void *)0);
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$9=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing number lines\n", (const void *)"xosd.c", 691, return_value_pthread_self$9, (const void *)"xosd_create");
          }

        while((_Bool)0);
        xosd_create$$1$$osd->number_lines = number_lines;
        return_value_malloc$10=malloc(sizeof(union xosd_line) /*16ul*/  * (unsigned long int)xosd_create$$1$$osd->number_lines);
        xosd_create$$1$$osd->lines = (union xosd_line *)return_value_malloc$10;
        if(xosd_create$$1$$osd->lines == ((union xosd_line *)NULL))
          xosd_error = "Out of memory";

        else
        {
          i = 0;
          for( ; !(i >= xosd_create$$1$$osd->number_lines); i = i + 1)
            memset((void *)&xosd_create$$1$$osd->lines[(signed long int)i], 0, sizeof(union xosd_line) /*16ul*/ );
          do
            if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$11=pthread_self();
              fprintf(stderr, "%s:%-4d %ld@%s: misc osd variable initialization\n", (const void *)"xosd.c", 702, return_value_pthread_self$11, (const void *)"xosd_create");
            }

          while((_Bool)0);
          xosd_create$$1$$osd->generation = 0;
          xosd_create$$1$$osd->done = 0;
          xosd_create$$1$$osd->pos = (enum anonymous$40)XOSD_top;
          xosd_create$$1$$osd->hoffset = 0;
          xosd_create$$1$$osd->align = (enum anonymous$8)XOSD_left;
          xosd_create$$1$$osd->voffset = 0;
          xosd_create$$1$$osd->timeout = -1;
          (&xosd_create$$1$$osd->timeout_start)->tv_usec = (signed long int)0;
          (&xosd_create$$1$$osd->timeout_start)->tv_sec = (&xosd_create$$1$$osd->timeout_start)->tv_usec;
          xosd_create$$1$$osd->fontset = (struct _XOC *)(void *)0;
          xosd_create$$1$$osd->bar_length = -1;
          do
            if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$12=pthread_self();
              fprintf(stderr, "%s:%-4d %ld@%s: Display query\n", (const void *)"xosd.c", 714, return_value_pthread_self$12, (const void *)"xosd_create");
            }

          while((_Bool)0);
          xosd_create$$1$$osd->display=XOpenDisplay(display);
          if(xosd_create$$1$$osd->display == ((struct _XDisplay *)NULL))
            xosd_error = "Cannot open display";

          else
          {
            xosd_create$$1$$osd->screen=XDefaultScreen(xosd_create$$1$$osd->display);
            do
              if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
              {
                return_value_pthread_self$13=pthread_self();
                fprintf(stderr, "%s:%-4d %ld@%s: x shape extension query\n", (const void *)"xosd.c", 722, return_value_pthread_self$13, (const void *)"xosd_create");
              }

            while((_Bool)0);
            return_value_XShapeQueryExtension$14=XShapeQueryExtension(xosd_create$$1$$osd->display, &event_basep, &error_basep);
            if(return_value_XShapeQueryExtension$14 == 0)
              xosd_error = "X-Server does not support shape extension";

            else
            {
              xosd_create$$1$$osd->visual = (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->root_visual;
              xosd_create$$1$$osd->depth = (unsigned int)(&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->root_depth;
              do
                if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                {
                  return_value_pthread_self$15=pthread_self();
                  fprintf(stderr, "%s:%-4d %ld@%s: font selection info\n", (const void *)"xosd.c", 731, return_value_pthread_self$15, (const void *)"xosd_create");
                }

              while((_Bool)0);
              xosd_set_font(xosd_create$$1$$osd, osd_default_font);
              if(xosd_create$$1$$osd->fontset == ((struct _XOC *)NULL))
                xosd_error = "Default font not found";

              else
              {
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$16=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: width and height initialization\n", (const void *)"xosd.c", 741, return_value_pthread_self$16, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                return_value_XineramaQueryExtension$17=XineramaQueryExtension(xosd_create$$1$$osd->display, &dummy_a, &dummy_b);
                if(!(return_value_XineramaQueryExtension$17 == 0))
                {
                  screeninfo=XineramaQueryScreens(xosd_create$$1$$osd->display, &screens);
                  tmp_if_expr$18 = screeninfo != ((struct anonymous$52 *)NULL) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$18 = (_Bool)0;
                if(tmp_if_expr$18)
                {
                  return_value_XineramaIsActive$19=XineramaIsActive(xosd_create$$1$$osd->display);
                  tmp_if_expr$20 = return_value_XineramaIsActive$19 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$20 = (_Bool)0;
                if(tmp_if_expr$20)
                {
                  xosd_create$$1$$osd->screen_width = (signed int)(screeninfo + (signed long int)0)->width;
                  xosd_create$$1$$osd->screen_height = (signed int)(screeninfo + (signed long int)0)->height;
                  xosd_create$$1$$osd->screen_xpos = (signed int)(screeninfo + (signed long int)0)->x_org;
                }

                else
                {
                  xosd_create$$1$$osd->screen_width=XDisplayWidth(xosd_create$$1$$osd->display, xosd_create$$1$$osd->screen);
                  xosd_create$$1$$osd->screen_height=XDisplayHeight(xosd_create$$1$$osd->display, xosd_create$$1$$osd->screen);
                  xosd_create$$1$$osd->screen_xpos = 0;
                }
                if(!(screeninfo == ((struct anonymous$52 *)NULL)))
                  XFree((void *)screeninfo);

                xosd_create$$1$$osd->line_height = 10;
                xosd_create$$1$$osd->height = xosd_create$$1$$osd->line_height * xosd_create$$1$$osd->number_lines;
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$21=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: creating X Window\n", (const void *)"xosd.c", 763, return_value_pthread_self$21, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                setwinattr.override_redirect = 1;
                return_value_XRootWindow$22=XRootWindow(xosd_create$$1$$osd->display, xosd_create$$1$$osd->screen);
                xosd_create$$1$$osd->window=XCreateWindow(xosd_create$$1$$osd->display, return_value_XRootWindow$22, 0, 0, (unsigned int)xosd_create$$1$$osd->screen_width, (unsigned int)xosd_create$$1$$osd->height, (unsigned int)0, (signed int)xosd_create$$1$$osd->depth, (unsigned int)0L, xosd_create$$1$$osd->visual, (unsigned long int)(1L << 9), &setwinattr);
                XStoreName(xosd_create$$1$$osd->display, xosd_create$$1$$osd->window, "XOSD");
                xosd_create$$1$$osd->mask_bitmap=XCreatePixmap(xosd_create$$1$$osd->display, xosd_create$$1$$osd->window, (unsigned int)xosd_create$$1$$osd->screen_width, (unsigned int)xosd_create$$1$$osd->height, (unsigned int)1);
                xosd_create$$1$$osd->line_bitmap=XCreatePixmap(xosd_create$$1$$osd->display, xosd_create$$1$$osd->window, (unsigned int)xosd_create$$1$$osd->screen_width, (unsigned int)xosd_create$$1$$osd->line_height, xosd_create$$1$$osd->depth);
                xosd_create$$1$$osd->gc=XCreateGC(xosd_create$$1$$osd->display, xosd_create$$1$$osd->window, (unsigned long int)(1L << 16), &xgcv);
                xosd_create$$1$$osd->mask_gc=XCreateGC(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_bitmap, (unsigned long int)(1L << 16), &xgcv);
                xosd_create$$1$$osd->mask_gc_back=XCreateGC(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_bitmap, (unsigned long int)(1L << 16), &xgcv);
                XSetBackground(xosd_create$$1$$osd->display, xosd_create$$1$$osd->gc, (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->white_pixel);
                XSetForeground(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_gc_back, (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->black_pixel);
                XSetBackground(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_gc_back, (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->white_pixel);
                XSetForeground(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_gc, (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->white_pixel);
                XSetBackground(xosd_create$$1$$osd->display, xosd_create$$1$$osd->mask_gc, (&((struct anonymous *)xosd_create$$1$$osd->display)->screens[(signed long int)xosd_create$$1$$osd->screen])->black_pixel);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$23=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: setting colour\n", (const void *)"xosd.c", 801, return_value_pthread_self$23, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                xosd_set_colour(xosd_create$$1$$osd, osd_default_colour);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$24=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: stay on top\n", (const void *)"xosd.c", 804, return_value_pthread_self$24, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                stay_on_top(xosd_create$$1$$osd->display, xosd_create$$1$$osd->window);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$25=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: initializing event thread\n", (const void *)"xosd.c", 807, return_value_pthread_self$25, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                pthread_create(&xosd_create$$1$$osd->event_thread, (const union pthread_attr_t *)(void *)0, event_loop, (void *)xosd_create$$1$$osd);
                return xosd_create$$1$$osd;
              }
            }

          error3:
            ;
            XCloseDisplay(xosd_create$$1$$osd->display);
          }

        error2:
          ;
          free((void *)xosd_create$$1$$osd->lines);
        }

      error1:
        ;
        pthread_cond_destroy(&xosd_create$$1$$osd->cond_sync);
        pthread_cond_destroy(&xosd_create$$1$$osd->cond_wait);
        pthread_mutex_destroy(&xosd_create$$1$$osd->mutex_sync);
        pthread_mutex_destroy(&xosd_create$$1$$osd->mutex);
        close(xosd_create$$1$$osd->pipefd[(signed long int)0]);
        close(xosd_create$$1$$osd->pipefd[(signed long int)1]);
      }

    error0b:
      ;
      free((void *)xosd_create$$1$$osd);
    }

  error0:
    ;
    return (struct xosd *)(void *)0;
  }
}

// xosd_destroy
// file ./xosd.h line 92
signed int xosd_destroy(struct xosd *osd)
{
  signed int i;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 848, return_value_pthread_self$1, (const void *)"xosd_destroy");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  unsigned long int return_value_pthread_self$3;
  unsigned long int return_value_pthread_self$4;
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$2=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: waiting for threads to exit\n", (const void *)"xosd.c", 852, return_value_pthread_self$2, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    _xosd_lock(osd);
    osd->done = 1;
    _xosd_unlock(osd);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$3=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: join threads\n", (const void *)"xosd.c", 857, return_value_pthread_self$3, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    pthread_join(osd->event_thread, (void **)(void *)0);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$4=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing X resources\n", (const void *)"xosd.c", 860, return_value_pthread_self$4, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    XFreeGC(osd->display, osd->gc);
    XFreeGC(osd->display, osd->mask_gc);
    XFreeGC(osd->display, osd->mask_gc_back);
    XFreePixmap(osd->display, osd->line_bitmap);
    XFreeFontSet(osd->display, osd->fontset);
    XFreePixmap(osd->display, osd->mask_bitmap);
    XDestroyWindow(osd->display, osd->window);
    XCloseDisplay(osd->display);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$5=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing lines\n", (const void *)"xosd.c", 871, return_value_pthread_self$5, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    i = 0;
    for( ; !(i >= osd->number_lines); i = i + 1)
      if((signed int)(osd->lines + (signed long int)i)->type == LINE_text)
      {
        if(!((osd->lines + (signed long int)i)->text.string == ((char *)NULL)))
          free((void *)(osd->lines + (signed long int)i)->text.string);

      }

    free((void *)osd->lines);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$6=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: destroying condition and mutex\n", (const void *)"xosd.c", 877, return_value_pthread_self$6, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    pthread_cond_destroy(&osd->cond_sync);
    pthread_cond_destroy(&osd->cond_wait);
    pthread_mutex_destroy(&osd->mutex_sync);
    pthread_mutex_destroy(&osd->mutex);
    close(osd->pipefd[(signed long int)0]);
    close(osd->pipefd[(signed long int)1]);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$7=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing osd structure\n", (const void *)"xosd.c", 885, return_value_pthread_self$7, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    free((void *)osd);
    do
      if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$8=pthread_self();
        fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 888, return_value_pthread_self$8, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    return 0;
  }
}

// xosd_display
// file ./xosd.h line 134
signed int xosd_display(struct xosd *osd, signed int line, enum anonymous$0 command, ...)
{
  signed int ret = -1;
  union xosd_line newline = { .type=(enum LINE)LINE_blank };
  __builtin_va_list a;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 922, return_value_pthread_self$1, (const void *)"xosd_display");
    }

  while((_Bool)0);
  _Bool tmp_if_expr$2;
  signed long int a$array_size0;
  char buf[a$array_size0];
  struct xosd_text *l;
  char *string;
  _Bool tmp_if_expr$6;
  struct xosd_bar *xosd_display$$1$$3$$2$$l;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(line >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = line >= osd->number_lines ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      xosd_error = "xosd_display: Invalid Line Number";
      return -1;
    }

    else
    {
      va_start(a, command);
      switch((signed int)command)
      {
        case XOSD_string:

        case XOSD_printf:
        {
          a$array_size0 = (signed long int)XOSD_MAX_PRINTF_BUF_SIZE;
          l = &newline.text;
          string=va_arg(a, __typeof__(string));
          if((signed int)command == XOSD_printf)
          {
            signed int return_value_vsnprintf$3;
            return_value_vsnprintf$3=vsnprintf(buf, (unsigned long int)a$array_size0, string, a);
            if((unsigned long int)return_value_vsnprintf$3 >= (unsigned long int)a$array_size0)
            {
              xosd_error = "xosd_display: Buffer too small";
              goto error;
            }

            string = buf;
          }

          if(!(string == ((char *)NULL)))
            tmp_if_expr$6 = *string != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(string);
            ret = (signed int)return_value_strlen$4;
            l->type = (enum LINE)LINE_text;
            void *return_value_malloc$5;
            return_value_malloc$5=malloc((unsigned long int)(ret + 1));
            l->string = (char *)return_value_malloc$5;
            memcpy((void *)l->string, (const void *)string, (unsigned long int)(ret + 1));
          }

          else
          {
            ret = 0;
            l->type = (enum LINE)LINE_blank;
          }
          l->width = -1;
          break;
        }
        case XOSD_percentage:

        case XOSD_slider:
        {
          xosd_display$$1$$3$$2$$l = &newline.bar;
          ret=va_arg(a, __typeof__(ret));
          ret = ret < 0 ? 0 : (ret > 100 ? 100 : ret);
          xosd_display$$1$$3$$2$$l->type = (enum LINE)((signed int)command == XOSD_percentage ? LINE_percentage : LINE_slider);
          xosd_display$$1$$3$$2$$l->value = ret;
          break;
        }
        default:
        {
          xosd_error = "xosd_display: Unknown command";
          goto error;
        }
      }
      _xosd_lock(osd);
      if(!((signed int)(osd->lines + (signed long int)line)->type == LINE_text))
      {
        if((signed int)(osd->lines + (signed long int)line)->type == LINE_blank || (signed int)(osd->lines + (signed long int)line)->type == LINE_percentage || (signed int)(osd->lines + (signed long int)line)->type == LINE_slider)
          goto __CPROVER_DUMP_L18;

      }

      else
        free((void *)(osd->lines + (signed long int)line)->text.string);

    __CPROVER_DUMP_L18:
      ;
      osd->lines[(signed long int)line] = newline;
      osd->update = osd->update | (enum anonymous$50)(UPD_content | UPD_timer | UPD_show);
      _xosd_unlock(osd);

    error:
      ;
      va_end(a);
      return ret;
    }
  }
}

// xosd_get_colour
// file xosd.c line 1242
signed int xosd_get_colour(struct xosd *osd, signed int *red, signed int *green, signed int *blue)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1244, return_value_pthread_self$1, (const void *)"xosd_get_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(red == ((signed int *)NULL)))
      *red = (signed int)osd->colour.red;

    if(!(blue == ((signed int *)NULL)))
      *blue = (signed int)osd->colour.blue;

    if(!(green == ((signed int *)NULL)))
      *green = (signed int)osd->colour.green;

    return 0;
  }
}

// xosd_get_number_lines
// file xosd.c line 1353
signed int xosd_get_number_lines(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1355, return_value_pthread_self$1, (const void *)"xosd_get_number_lines");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    return osd->number_lines;
}

// xosd_hide
// file xosd.c line 1278
signed int xosd_hide(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1280, return_value_pthread_self$1, (const void *)"xosd_hide");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!((1 & osd->generation) == 0))
    {
      _xosd_lock(osd);
      osd->update = osd->update & (enum anonymous$50)~UPD_show;
      osd->update = osd->update | (enum anonymous$50)UPD_hide;
      _xosd_unlock(osd);
      return 0;
    }

    else
      return -1;
}

// xosd_init
// file xosd.c line 619
struct xosd * xosd_init(const char *font, const char *colour, signed int timeout, enum anonymous$40 pos, signed int voffset, signed int shadow_offset, signed int number_lines)
{
  struct xosd *xosd_init$$1$$osd;
  xosd_init$$1$$osd=xosd_create(number_lines);
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 624, return_value_pthread_self$1, (const void *)"xosd_init");
    }

  while((_Bool)0);
  if(xosd_init$$1$$osd == ((struct xosd *)NULL))
    return (struct xosd *)(void *)0;

  else
  {
    signed int return_value_xosd_set_font$2;
    return_value_xosd_set_font$2=xosd_set_font(xosd_init$$1$$osd, font);
    if(return_value_xosd_set_font$2 == -1)
    {
      xosd_destroy(xosd_init$$1$$osd);
      return (struct xosd *)(void *)0;
    }

    else
    {
      xosd_set_colour(xosd_init$$1$$osd, colour);
      xosd_set_timeout(xosd_init$$1$$osd, timeout);
      xosd_set_pos(xosd_init$$1$$osd, pos);
      xosd_set_vertical_offset(xosd_init$$1$$osd, voffset);
      xosd_set_shadow_offset(xosd_init$$1$$osd, shadow_offset);
      return xosd_init$$1$$osd;
    }
  }
}

// xosd_is_onscreen
// file ./xosd.h line 146
signed int xosd_is_onscreen(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1002, return_value_pthread_self$1, (const void *)"xosd_is_onscreen");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    return osd->generation & 1;
}

// xosd_scroll
// file ./xosd.h line 346
signed int xosd_scroll(struct xosd *osd, signed int lines)
{
  signed int i;
  union xosd_line *src;
  union xosd_line *dst;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1323, return_value_pthread_self$1, (const void *)"xosd_scroll");
    }

  while((_Bool)0);
  _Bool tmp_if_expr$2;
  union xosd_line *tmp_post$3;
  union xosd_line *tmp_post$4;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(lines >= 1))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = lines > osd->number_lines ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    else
    {
      _xosd_lock(osd);
      i = 0;
      src = osd->lines;
      for( ; !(i >= lines); src = src + 1l)
      {
        if((signed int)src->type == LINE_text)
        {
          if(!(src->text.string == ((char *)NULL)))
          {
            free((void *)src->text.string);
            src->text.string = (char *)(void *)0;
          }

        }

        i = i + 1;
      }
      dst = osd->lines;
      for( ; !(i >= osd->number_lines); i = i + 1)
      {
        tmp_post$3 = dst;
        dst = dst + 1l;
        tmp_post$4 = src;
        src = src + 1l;
        *tmp_post$3 = *tmp_post$4;
      }
      for( ; !(dst >= src); dst = dst + 1l)
      {
        dst->type = (enum LINE)LINE_blank;
        dst->text.string = (char *)(void *)0;
      }
      osd->update = osd->update | (enum anonymous$50)UPD_content;
      _xosd_unlock(osd);
      return 0;
    }
  }
}

// xosd_set_align
// file ./xosd.h line 203
signed int xosd_set_align(struct xosd *osd, enum anonymous$8 align)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1226, return_value_pthread_self$1, (const void *)"xosd_set_align");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->align = align;
    osd->update = osd->update | (enum anonymous$50)UPD_content;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_bar_length
// file xosd.c line 896
signed int xosd_set_bar_length(struct xosd *osd, signed int length)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 898, return_value_pthread_self$1, (const void *)"xosd_set_bar_length");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(length == 0)
      return -1;

    else
      if(!(length >= -1))
        return -1;

      else
      {
        osd->bar_length = length;
        return 0;
      }
}

// xosd_set_colour
// file ./xosd.h line 308
signed int xosd_set_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1034, return_value_pthread_self$1, (const void *)"xosd_set_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->colour, &osd->pixel, colour);
    osd->update = osd->update | (enum anonymous$50)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_font
// file ./xosd.h line 320
signed int xosd_set_font(struct xosd *osd, const char *font)
{
  struct _XOC *fontset2;
  char **missing;
  signed int nmissing;
  char *defstr;
  signed int ret = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1100, return_value_pthread_self$1, (const void *)"xosd_set_font");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(font == ((const char *)NULL))
      return -1;

    else
    {
      _xosd_lock(osd);
      fontset2=XCreateFontSet(osd->display, font, &missing, &nmissing, &defstr);
      XFreeStringList(missing);
      if(fontset2 == ((struct _XOC *)NULL))
      {
        xosd_error = "Requested font not found";
        ret = -1;
      }

      else
      {
        if(!(osd->fontset == ((struct _XOC *)NULL)))
          XFreeFontSet(osd->display, osd->fontset);

        osd->fontset = fontset2;
        osd->update = osd->update | (enum anonymous$50)UPD_font;
      }
      _xosd_unlock(osd);
      return ret;
    }
}

// xosd_set_horizontal_offset
// file ./xosd.h line 269
signed int xosd_set_horizontal_offset(struct xosd *osd, signed int hoffset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1190, return_value_pthread_self$1, (const void *)"xosd_set_horizontal_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->hoffset = hoffset;
    osd->update = osd->update | (enum anonymous$50)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_outline_colour
// file ./xosd.h line 242
signed int xosd_set_outline_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1074, return_value_pthread_self$1, (const void *)"xosd_set_outline_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->outline_colour, &osd->outline_pixel, colour);
    osd->update = osd->update | (enum anonymous$50)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_outline_offset
// file ./xosd.h line 229
signed int xosd_set_outline_offset(struct xosd *osd, signed int outline_offset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1152, return_value_pthread_self$1, (const void *)"xosd_set_outline_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!(outline_offset >= 0))
      return -1;

    else
    {
      _xosd_lock(osd);
      osd->outline_offset = outline_offset;
      osd->update = osd->update | (enum anonymous$50)UPD_font;
      _xosd_unlock(osd);
      return 0;
    }
}

// xosd_set_pos
// file ./xosd.h line 191
signed int xosd_set_pos(struct xosd *osd, enum anonymous$40 pos)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1208, return_value_pthread_self$1, (const void *)"xosd_set_pos");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->pos = pos;
    osd->update = osd->update | (enum anonymous$50)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_shadow_colour
// file ./xosd.h line 255
signed int xosd_set_shadow_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1054, return_value_pthread_self$1, (const void *)"xosd_set_shadow_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->shadow_colour, &osd->shadow_pixel, colour);
    osd->update = osd->update | (enum anonymous$50)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_shadow_offset
// file ./xosd.h line 215
signed int xosd_set_shadow_offset(struct xosd *osd, signed int shadow_offset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1132, return_value_pthread_self$1, (const void *)"xosd_set_shadow_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!(shadow_offset >= 0))
      return -1;

    else
    {
      _xosd_lock(osd);
      osd->shadow_offset = shadow_offset;
      osd->update = osd->update | (enum anonymous$50)UPD_font;
      _xosd_unlock(osd);
      return 0;
    }
}

// xosd_set_timeout
// file ./xosd.h line 295
signed int xosd_set_timeout(struct xosd *osd, signed int timeout)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1264, return_value_pthread_self$1, (const void *)"xosd_set_timeout");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->timeout = timeout;
    osd->update = osd->update | (enum anonymous$50)UPD_timer;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_vertical_offset
// file ./xosd.h line 283
signed int xosd_set_vertical_offset(struct xosd *osd, signed int voffset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1172, return_value_pthread_self$1, (const void *)"xosd_set_vertical_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->voffset = voffset;
    osd->update = osd->update | (enum anonymous$50)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_show
// file xosd.c line 1298
signed int xosd_show(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1300, return_value_pthread_self$1, (const void *)"xosd_show");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!((~osd->generation & 1) == 0))
    {
      _xosd_lock(osd);
      osd->update = osd->update & (enum anonymous$50)~UPD_hide;
      osd->update = osd->update | (enum anonymous$50)(UPD_show | UPD_timer);
      _xosd_unlock(osd);
      return 0;
    }

    else
      return -1;
}

// xosd_uninit
// file xosd.c line 834
signed int xosd_uninit(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 836, return_value_pthread_self$1, (const void *)"xosd_uninit");
    }

  while((_Bool)0);
  signed int return_value_xosd_destroy$2;
  return_value_xosd_destroy$2=xosd_destroy(osd);
  return return_value_xosd_destroy$2;
}

// xosd_wait_until_no_display
// file ./xosd.h line 157
signed int xosd_wait_until_no_display(struct xosd *osd)
{
  signed int generation;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1015, return_value_pthread_self$1, (const void *)"xosd_wait_until_no_display");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    generation = osd->generation;
    if(!((1 & generation) == 0))
      _wait_until_update(osd, generation);

    do
      if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$2=pthread_self();
        fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 1022, return_value_pthread_self$2, (const void *)"xosd_wait_until_no_display");
      }

    while((_Bool)0);
    return 0;
  }
}

