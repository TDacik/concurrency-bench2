// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$15;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$13;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$3;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$11;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$7;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$10;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$14;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$1;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$6;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$16;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$4;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$0;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-option
// file ../../src/common/getopt.h line 83
struct option;

// tag-protoent
// file /usr/include/netdb.h line 326
struct protoent;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-servent
// file /usr/include/netdb.h line 257
struct servent;

// tag-session_commands_s
// file network.c line 112
struct session_commands_s;

// tag-session_s
// file network.c line 111
struct session_s;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-xine_cfg_entry_s
// file /usr/include/xine.h line 1563
struct xine_cfg_entry_s;

// tag-xine_s
// file /usr/include/xine.h line 81
struct xine_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __sock_write
// file network.c line 549
static signed int __sock_write(signed int socket, signed int cr, char *msg, ...);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject);
// __strsep_1c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link1(char **__s$link1, char __reject$link1);
// __strsep_1c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link2(char **__s$link2, char __reject$link2);
// __strsep_1c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link3(char **__s$link3, char __reject$link3);
// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2);
// __strsep_2c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link1(char **__s$link1, char __reject1$link1, char __reject2$link1);
// __strsep_2c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link2(char **__s$link2, char __reject1$link2, char __reject2$link2);
// __strsep_2c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link3(char **__s$link3, char __reject1$link3, char __reject2$link3);
// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3);
// __strsep_3c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link1(char **__s$link1, char __reject1$link1, char __reject2$link1, char __reject3$link1);
// __strsep_3c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link2(char **__s$link2, char __reject1$link2, char __reject2$link2, char __reject3$link2);
// __strsep_3c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link3(char **__s$link3, char __reject1$link3, char __reject2$link3, char __reject3$link3);
// __strsep_g
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1179
extern char * __strsep_g(char **, const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 412
extern signed int __xstat(signed int, const char *, struct stat *);
// _atoa
// file network.c line 574
static char * _atoa(char *str);
// _mkdir_safe
// file utils.c line 140
static signed int _mkdir_safe(char *path);
// _sock_write
// file network.c line 525
static signed int _sock_write(signed int socket, char *buf, signed int len);
// add_history
// file /usr/include/readline/history.h line 84
extern void add_history(const char *);
// atoa
// file utils.c line 89
char * atoa(char *str);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// client_close
// file network.c line 775
static void client_close(struct session_s *session, struct session_commands_s *command, const char *cmd);
// client_handle_command
// file network.c line 1031
static void client_handle_command(struct session_s *session, const char *command);
// client_help
// file network.c line 724
static void client_help(struct session_s *session, struct session_commands_s *command, const char *cmd);
// client_noop
// file network.c line 722
static void client_noop(struct session_s *session, struct session_commands_s *command, const char *cmd);
// client_open
// file network.c line 795
static void client_open(struct session_s *session, struct session_commands_s *command, const char *cmd);
// client_quit
// file network.c line 849
static void client_quit(struct session_s *session, struct session_commands_s *command, const char *cmd);
// client_version
// file network.c line 768
static void client_version(struct session_s *session, struct session_commands_s *command, const char *cmd);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// command_generator
// file network.c line 861
static char * command_generator(const char *text, signed int state);
// completion_function
// file network.c line 884
static char ** completion_function(const char *text, signed int start, signed int end);
// config_mrl
// file config_wrapper.c line 129
void config_mrl(const char *mrl);
// config_update
// file config_wrapper.c line 44
static void config_update(struct xine_cfg_entry_s *entry, signed int type, signed int min, signed int max, signed int value, char *string);
// config_update_bool
// file config_wrapper.c line 108
void config_update_bool(const char *key, signed int value);
// config_update_enum
// file config_wrapper.c line 99
void config_update_enum(const char *key, signed int value);
// config_update_num
// file config_wrapper.c line 117
void config_update_num(const char *key, signed int value);
// config_update_range
// file config_wrapper.c line 77
void config_update_range(const char *key, signed int min, signed int max);
// config_update_string
// file config_wrapper.c line 86
void config_update_string(const char *key, char *string);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$0, unsigned int);
// dump_cpu_infos
// file dump.c line 63
void dump_cpu_infos(void);
// dump_error
// file dump.c line 97
void dump_error(const char *msg);
// dump_host_info
// file dump.c line 40
void dump_host_info(void);
// dump_info
// file dump.c line 105
void dump_info(const char *msg);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_bool_value
// file utils.c line 192
signed int get_bool_value(const char *val);
// get_last_double_semicolon
// file utils.c line 212
const char * get_last_double_semicolon(const char *str);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt_long
// file ../../src/common/getopt.h line 140
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getprotobyname
// file /usr/include/netdb.h line 357
extern struct protoent * getprotobyname(const char *);
// getservbyname
// file /usr/include/netdb.h line 290
extern struct servent * getservbyname(const char *, const char *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// is_a_dir
// file utils.c line 321
signed int is_a_dir(char *filename);
// is_a_file
// file utils.c line 330
signed int is_a_file(char *filename);
// is_downloadable
// file utils.c line 314
signed int is_downloadable(char *filename);
// is_ipv6_last_double_semicolon
// file utils.c line 230
signed int is_ipv6_last_double_semicolon(const char *str);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdir_safe
// file utils.c line 168
signed int mkdir_safe(char *path);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$4 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$4 *, const union anonymous$5 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$4 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$4 *);
// readline
// file /usr/include/readline/readline.h line 288
extern char * readline(const char *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, union anonymous$0, unsigned int *);
// rl_attempted_completion_function$object
//
char ** rl_attempted_completion_function$object(const char *, signed int, signed int);
// rl_completion_matches
// file /usr/include/readline/readline.h line 457
extern char ** rl_completion_matches(const char *, char * (*)(const char *, signed int));
// rl_crlf
// file /usr/include/readline/readline.h line 381
extern signed int rl_crlf(void);
// rl_forced_update_display
// file /usr/include/readline/readline.h line 378
extern signed int rl_forced_update_display(void);
// rl_initialize
// file /usr/include/readline/readline.h line 293
extern signed int rl_initialize(void);
// rl_kill_full_line
// file /usr/include/readline/readline.h line 164
extern signed int rl_kill_full_line(signed int, signed int);
// rl_redisplay
// file /usr/include/readline/readline.h line 375
extern void rl_redisplay(void);
// rl_set_prompt
// file /usr/include/readline/readline.h line 290
extern signed int rl_set_prompt(const char *);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$3 *, struct anonymous$3 *, struct anonymous$3 *, struct timeval *);
// select_thread
// file network.c line 915
static void * select_thread(void *data);
// session_create_commands
// file network.c line 685
static void session_create_commands(struct session_s *session);
// session_single_shot
// file network.c line 1108
static void session_single_shot(struct session_s *session, signed int num_commands, char **commands);
// session_update_prompt
// file network.c line 675
static void session_update_prompt(struct session_s *session);
// show_usage
// file network.c line 1131
static void show_usage(void);
// show_version
// file network.c line 1126
static void show_version(void);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$2 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signals_handler
// file network.c line 893
static void signals_handler(signed int sig);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_check_opened
// file network.c line 496
static signed int sock_check_opened(signed int socket);
// sock_client
// file network.c line 601
static signed int sock_client(const char *host, const char *service, const char *transport);
// sock_create
// file network.c line 446
static signed int sock_create(const char *service, const char *transport, struct sockaddr_in *sin);
// sock_err
// file network.c line 438
static void sock_err(const char *error_msg, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcat
// file ../../src/common/utils.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../../src/common/utils.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_to_console
// file network.c line 641
static signed int write_to_console(struct session_s *session, const char *msg, ...);
// xine_config_lookup_entry
// file /usr/include/xine.h line 1687
signed int xine_config_lookup_entry(struct xine_s *, const char *, struct xine_cfg_entry_s *);
// xine_config_update_entry
// file /usr/include/xine.h line 1696
void xine_config_update_entry(struct xine_s *, const struct xine_cfg_entry_s *);
// xine_system
// file utils.c line 44
signed int xine_system(signed int dont_run_as_root, char *command);

struct anonymous$15
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$13
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$3
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$2
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$10
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$14
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$16
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$9 _kill;
  // _timer
  struct anonymous$10 _timer;
  // _rt
  struct anonymous$11 _rt;
  // _sigchld
  struct anonymous$12 _sigchld;
  // _sigfault
  struct anonymous$13 _sigfault;
  // _sigpoll
  struct anonymous$14 _sigpoll;
  // _sigsys
  struct anonymous$15 _sigsys;
};

struct anonymous$7
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$16 _sifields;
};

union anonymous$1
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$7 *, void *);
};

union anonymous$6
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$5
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$4
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$0
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$6 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct protoent
{
  // p_name
  char *p_name;
  // p_aliases
  char **p_aliases;
  // p_proto
  signed int p_proto;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct servent
{
  // s_name
  char *s_name;
  // s_aliases
  char **s_aliases;
  // s_port
  signed int s_port;
  // s_proto
  char *s_proto;
};

struct session_commands_s
{
  // command
  char *command;
  // origin
  signed int origin;
  // enable
  signed int enable;
  // function
  void (*function)(struct session_s *, struct session_commands_s *, const char *);
};

struct session_s
{
  // host
  char host[256l];
  // port
  char port[256l];
  // socket
  signed int socket;
  // console
  signed int console;
  // running
  signed int running;
  // prompt
  char prompt[544l];
  // thread
  unsigned long int thread;
  // console_mutex
  union anonymous$4 console_mutex;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$1 __sigaction_handler;
  // sa_mask
  struct anonymous$2 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};

struct xine_cfg_entry_s
{
  // key
  const char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  const char *description;
  // help
  const char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};


// __xineui_global_config_file
// file globals.c line 36
char *__xineui_global_config_file;
// __xineui_global_lirc_enable
// file globals.c line 47
signed int __xineui_global_lirc_enable;
// __xineui_global_verbosity
// file globals.c line 41
signed int __xineui_global_verbosity;
// __xineui_global_xine_instance
// file globals.c line 31
struct xine_s *__xineui_global_xine_instance;
// client_commands
// file network.c line 144
static struct session_commands_s client_commands[6l];
// client_commands
// file network.c line 144
static struct session_commands_s client_commands[6l] = { { .command="?", .origin=2, .enable=1, .function=client_help },
    { .command="version", .origin=2, .enable=1, .function=client_version },
    { .command="open", .origin=2, .enable=1, .function=client_open },
    { .command="close", .origin=2, .enable=1, .function=client_close },
    { .command="quit", .origin=2, .enable=1, .function=client_quit },
    { .command=(char *)(void *)0, .origin=2, .enable=1,
    .function=(void (*)(struct session_s *, struct session_commands_s *, const char *))(void *)0 } };
// environ
// file /usr/include/unistd.h line 545
extern char **environ;
// long_options
// file network.c line 100
static struct option long_options[7l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="host", .has_arg=1, .flag=((signed int *)NULL), .val=72 },
    { .name="port", .has_arg=1, .flag=((signed int *)NULL), .val=80 },
    { .name="command", .has_arg=0, .flag=((signed int *)NULL), .val=99 },
    { .name="noconnect", .has_arg=0, .flag=((signed int *)NULL), .val=110 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// optarg
// file ../../src/common/getopt.h line 36
extern char *optarg;
// opterr
// file ../../src/common/getopt.h line 55
extern signed int opterr;
// optind
// file ../../src/common/getopt.h line 50
extern signed int optind;
// rl_attempted_completion_function
// file /usr/include/readline/readline.h line 655
extern char ** (*rl_attempted_completion_function)(const char *, signed int, signed int);
// rl_end
// file /usr/include/readline/readline.h line 520
extern signed int rl_end;
// rl_prompt
// file /usr/include/readline/readline.h line 509
extern char *rl_prompt;
// rl_readline_name
// file /usr/include/readline/readline.h line 505
extern const char *rl_readline_name;
// session
// file network.c line 143
static struct session_s session;
// session_commands
// file network.c line 153
static struct session_commands_s **session_commands = (struct session_commands_s **)(void *)0;
// short_options
// file network.c line 99
static const char short_options[10l] = { '?', 'h', 'H', ':', 'P', ':', 'n', 'c', 'v', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// __sock_write
// file network.c line 549
static signed int __sock_write(signed int socket, signed int cr, char *msg, ...)
{
  char buf[20480l];
  void **args = (void **)&msg;
  vsnprintf(buf, (unsigned long int)20480, msg, args);
  args = ((void **)NULL);
  unsigned long int return_value_strlen$1;
  if(!(cr == 0))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    if((signed int)buf[(signed long int)return_value_strlen$2] == 0)
    {
      return_value_strlen$1=strlen(buf);
      if(!((signed int)buf[-1l + (signed long int)return_value_strlen$1] == 10))
        strlcat(buf, "\n", sizeof(char [20480l]) /*20480ul*/ );

    }

  }

  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(buf);
  signed int return_value__sock_write$4;
  return_value__sock_write$4=_sock_write(socket, buf, (signed int)return_value_strlen$3);
  return return_value__sock_write$4;
}

// __strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c(char **__s, char __reject)
{
  char *__retval = *__s;
  char *return_value___builtin_strchr$2;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    return_value___builtin_strchr$2=__builtin_strchr(__retval, (signed int)__reject);
    *__s = return_value___builtin_strchr$2;
    if(!(*__s == ((char *)NULL)))
    {
      tmp_post$1 = *__s;
      *__s = *__s + 1l;
      *tmp_post$1 = (char)0;
    }

  }

  return __retval;
}

// __strsep_1c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link1(char **__s$link1, char __reject$link1)
{
  char *__retval$link1 = *__s$link1;
  char *return_value___builtin_strchr$2$link1;
  char *tmp_post$1$link1;
  if(!(__retval$link1 == ((char *)NULL)))
  {
    return_value___builtin_strchr$2$link1=__builtin_strchr(__retval$link1, (signed int)__reject$link1);
    *__s$link1 = return_value___builtin_strchr$2$link1;
    if(!(*__s$link1 == ((char *)NULL)))
    {
      tmp_post$1$link1 = *__s$link1;
      *__s$link1 = *__s$link1 + 1l;
      *tmp_post$1$link1 = (char)0;
    }

  }

  return __retval$link1;
}

// __strsep_1c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link2(char **__s$link2, char __reject$link2)
{
  char *__retval$link2 = *__s$link2;
  char *return_value___builtin_strchr$2$link2;
  char *tmp_post$1$link2;
  if(!(__retval$link2 == ((char *)NULL)))
  {
    return_value___builtin_strchr$2$link2=__builtin_strchr(__retval$link2, (signed int)__reject$link2);
    *__s$link2 = return_value___builtin_strchr$2$link2;
    if(!(*__s$link2 == ((char *)NULL)))
    {
      tmp_post$1$link2 = *__s$link2;
      *__s$link2 = *__s$link2 + 1l;
      *tmp_post$1$link2 = (char)0;
    }

  }

  return __retval$link2;
}

// __strsep_1c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1199
static inline char * __strsep_1c$link3(char **__s$link3, char __reject$link3)
{
  char *__retval$link3 = *__s$link3;
  char *return_value___builtin_strchr$2$link3;
  char *tmp_post$1$link3;
  if(!(__retval$link3 == ((char *)NULL)))
  {
    return_value___builtin_strchr$2$link3=__builtin_strchr(__retval$link3, (signed int)__reject$link3);
    *__s$link3 = return_value___builtin_strchr$2$link3;
    if(!(*__s$link3 == ((char *)NULL)))
    {
      tmp_post$1$link3 = *__s$link3;
      *__s$link3 = *__s$link3 + 1l;
      *tmp_post$1$link3 = (char)0;
    }

  }

  return __retval$link3;
}

// __strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c(char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  _Bool tmp_if_expr$2;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        tmp_post$1 = __cp;
        __cp = __cp + 1l;
        *tmp_post$1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// __strsep_2c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link1(char **__s$link1, char __reject1$link1, char __reject2$link1)
{
  char *__retval$link1 = *__s$link1;
  _Bool tmp_if_expr$2$link1;
  char *tmp_post$1$link1;
  if(!(__retval$link1 == ((char *)NULL)))
  {
    char *__cp$link1 = __retval$link1;
    for( ; (_Bool)1; __cp$link1 = __cp$link1 + 1l)
    {
      if((signed int)*__cp$link1 == 0)
      {
        __cp$link1 = (char *)(void *)0;
        break;
      }

      if(*__cp$link1 == __reject1$link1)
        tmp_if_expr$2$link1 = (_Bool)1;

      else
        tmp_if_expr$2$link1 = *__cp$link1 == __reject2$link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link1)
      {
        tmp_post$1$link1 = __cp$link1;
        __cp$link1 = __cp$link1 + 1l;
        *tmp_post$1$link1 = (char)0;
        break;
      }

    }
    *__s$link1 = __cp$link1;
  }

  return __retval$link1;
}

// __strsep_2c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link2(char **__s$link2, char __reject1$link2, char __reject2$link2)
{
  char *__retval$link2 = *__s$link2;
  _Bool tmp_if_expr$2$link2;
  char *tmp_post$1$link2;
  if(!(__retval$link2 == ((char *)NULL)))
  {
    char *__cp$link2 = __retval$link2;
    for( ; (_Bool)1; __cp$link2 = __cp$link2 + 1l)
    {
      if((signed int)*__cp$link2 == 0)
      {
        __cp$link2 = (char *)(void *)0;
        break;
      }

      if(*__cp$link2 == __reject1$link2)
        tmp_if_expr$2$link2 = (_Bool)1;

      else
        tmp_if_expr$2$link2 = *__cp$link2 == __reject2$link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link2)
      {
        tmp_post$1$link2 = __cp$link2;
        __cp$link2 = __cp$link2 + 1l;
        *tmp_post$1$link2 = (char)0;
        break;
      }

    }
    *__s$link2 = __cp$link2;
  }

  return __retval$link2;
}

// __strsep_2c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1209
static inline char * __strsep_2c$link3(char **__s$link3, char __reject1$link3, char __reject2$link3)
{
  char *__retval$link3 = *__s$link3;
  _Bool tmp_if_expr$2$link3;
  char *tmp_post$1$link3;
  if(!(__retval$link3 == ((char *)NULL)))
  {
    char *__cp$link3 = __retval$link3;
    for( ; (_Bool)1; __cp$link3 = __cp$link3 + 1l)
    {
      if((signed int)*__cp$link3 == 0)
      {
        __cp$link3 = (char *)(void *)0;
        break;
      }

      if(*__cp$link3 == __reject1$link3)
        tmp_if_expr$2$link3 = (_Bool)1;

      else
        tmp_if_expr$2$link3 = *__cp$link3 == __reject2$link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link3)
      {
        tmp_post$1$link3 = __cp$link3;
        __cp$link3 = __cp$link3 + 1l;
        *tmp_post$1$link3 = (char)0;
        break;
      }

    }
    *__s$link3 = __cp$link3;
  }

  return __retval$link3;
}

// __strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    for( ; (_Bool)1; __cp = __cp + 1l)
    {
      if((signed int)*__cp == 0)
      {
        __cp = (char *)(void *)0;
        break;
      }

      if(*__cp == __reject1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = *__cp == __reject2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = *__cp == __reject3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        tmp_post$1 = __cp;
        __cp = __cp + 1l;
        *tmp_post$1 = (char)0;
        break;
      }

    }
    *__s = __cp;
  }

  return __retval;
}

// __strsep_3c$link1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link1(char **__s$link1, char __reject1$link1, char __reject2$link1, char __reject3$link1)
{
  char *__retval$link1 = *__s$link1;
  _Bool tmp_if_expr$2$link1;
  _Bool tmp_if_expr$3$link1;
  char *tmp_post$1$link1;
  if(!(__retval$link1 == ((char *)NULL)))
  {
    char *__cp$link1 = __retval$link1;
    for( ; (_Bool)1; __cp$link1 = __cp$link1 + 1l)
    {
      if((signed int)*__cp$link1 == 0)
      {
        __cp$link1 = (char *)(void *)0;
        break;
      }

      if(*__cp$link1 == __reject1$link1)
        tmp_if_expr$2$link1 = (_Bool)1;

      else
        tmp_if_expr$2$link1 = *__cp$link1 == __reject2$link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link1)
        tmp_if_expr$3$link1 = (_Bool)1;

      else
        tmp_if_expr$3$link1 = *__cp$link1 == __reject3$link1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3$link1)
      {
        tmp_post$1$link1 = __cp$link1;
        __cp$link1 = __cp$link1 + 1l;
        *tmp_post$1$link1 = (char)0;
        break;
      }

    }
    *__s$link1 = __cp$link1;
  }

  return __retval$link1;
}

// __strsep_3c$link2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link2(char **__s$link2, char __reject1$link2, char __reject2$link2, char __reject3$link2)
{
  char *__retval$link2 = *__s$link2;
  _Bool tmp_if_expr$2$link2;
  _Bool tmp_if_expr$3$link2;
  char *tmp_post$1$link2;
  if(!(__retval$link2 == ((char *)NULL)))
  {
    char *__cp$link2 = __retval$link2;
    for( ; (_Bool)1; __cp$link2 = __cp$link2 + 1l)
    {
      if((signed int)*__cp$link2 == 0)
      {
        __cp$link2 = (char *)(void *)0;
        break;
      }

      if(*__cp$link2 == __reject1$link2)
        tmp_if_expr$2$link2 = (_Bool)1;

      else
        tmp_if_expr$2$link2 = *__cp$link2 == __reject2$link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link2)
        tmp_if_expr$3$link2 = (_Bool)1;

      else
        tmp_if_expr$3$link2 = *__cp$link2 == __reject3$link2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3$link2)
      {
        tmp_post$1$link2 = __cp$link2;
        __cp$link2 = __cp$link2 + 1l;
        *tmp_post$1$link2 = (char)0;
        break;
      }

    }
    *__s$link2 = __cp$link2;
  }

  return __retval$link2;
}

// __strsep_3c$link3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1237
static inline char * __strsep_3c$link3(char **__s$link3, char __reject1$link3, char __reject2$link3, char __reject3$link3)
{
  char *__retval$link3 = *__s$link3;
  _Bool tmp_if_expr$2$link3;
  _Bool tmp_if_expr$3$link3;
  char *tmp_post$1$link3;
  if(!(__retval$link3 == ((char *)NULL)))
  {
    char *__cp$link3 = __retval$link3;
    for( ; (_Bool)1; __cp$link3 = __cp$link3 + 1l)
    {
      if((signed int)*__cp$link3 == 0)
      {
        __cp$link3 = (char *)(void *)0;
        break;
      }

      if(*__cp$link3 == __reject1$link3)
        tmp_if_expr$2$link3 = (_Bool)1;

      else
        tmp_if_expr$2$link3 = *__cp$link3 == __reject2$link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2$link3)
        tmp_if_expr$3$link3 = (_Bool)1;

      else
        tmp_if_expr$3$link3 = *__cp$link3 == __reject3$link3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3$link3)
      {
        tmp_post$1$link3 = __cp$link3;
        __cp$link3 = __cp$link3 + 1l;
        *tmp_post$1$link3 = (char)0;
        break;
      }

    }
    *__s$link3 = __cp$link3;
  }

  return __retval$link3;
}

// _atoa
// file network.c line 574
static char * _atoa(char *str)
{
  char *pbuf = str;
  for( ; !((signed int)*pbuf == 0); pbuf = pbuf + 1l)
    ;
  if(!(str >= pbuf))
    pbuf = pbuf - 1l;

  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 13))
    {
      if(!((signed int)*pbuf == 10))
        break;

    }

    *pbuf = (char)0;
  }
  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 32))
      break;

    *pbuf = (char)0;
  }
  pbuf = str;
  for( ; (_Bool)1; pbuf = pbuf + 1l)
    if(!((signed int)*pbuf == 34))
    {
      if(!((signed int)*pbuf == 32))
      {
        if(!((signed int)*pbuf == 9))
          goto __CPROVER_DUMP_L9;

      }

    }


__CPROVER_DUMP_L9:
  ;
  return pbuf;
}

// _mkdir_safe
// file utils.c line 140
static signed int _mkdir_safe(char *path)
{
  struct stat pstat;
  if(path == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_stat$5;
    return_value_stat$5=stat(path, &pstat);
    if(!(return_value_stat$5 >= 0))
    {
      signed int return_value_mkdir$3;
      return_value_mkdir$3=mkdir(path, (unsigned int)0755);
      if(!(return_value_mkdir$3 >= 0))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        fprintf(stderr, "mkdir(%s) failed: %s\n", path, return_value_strerror$2);
        return 0;
      }

    }

    else
      if(!((61440u & pstat.st_mode) == 16384u))
      {
        fprintf(stderr, "%s is not a directory.\n", path);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 17;
        return 0;
      }

    return 1;
  }
}

// _sock_write
// file network.c line 525
static signed int _sock_write(signed int socket, char *buf, signed int len)
{
  signed long int size;
  signed int wlen = 0;
  if(buf == ((char *)NULL) || !(socket >= 0))
    return -1;

  else
  {
    signed int return_value_sock_check_opened$1;
    return_value_sock_check_opened$1=sock_check_opened(socket);
    if(return_value_sock_check_opened$1 == 0)
      return -1;

    else
    {
      for( ; !(len == 0); buf = buf + size)
      {
        size=write(socket, (const void *)buf, (unsigned long int)len);
        if(!(size >= 1l))
          return -1;

        len = len - (signed int)size;
        wlen = wlen + (signed int)size;
      }
      return wlen;
    }
  }
}

// atoa
// file utils.c line 89
char * atoa(char *str)
{
  char *pbuf;
  signed int quote = 0;
  signed int dblquote = 0;
  pbuf = str;
  for( ; (signed int)*pbuf == 32; pbuf = pbuf + 1l)
    ;
  if((signed int)*pbuf == 39)
    quote = 1;

  else
    if((signed int)*pbuf == 34)
      dblquote = 1;

  pbuf = str;
  for( ; !((signed int)*pbuf == 0); pbuf = pbuf + 1l)
    ;
  if(!(str >= pbuf))
    pbuf = pbuf - 1l;

  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 13))
    {
      if(!((signed int)*pbuf == 10))
        break;

    }

    *pbuf = (char)0;
  }
  for( ; !(str >= pbuf); pbuf = pbuf - 1l)
  {
    if(!((signed int)*pbuf == 32))
      break;

    *pbuf = (char)0;
  }
  _Bool tmp_if_expr$1;
  if(!(quote == 0))
    tmp_if_expr$1 = (signed int)*pbuf == 39 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(dblquote == 0))
      tmp_if_expr$2 = (signed int)*pbuf == 34 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    *pbuf = (char)0;
    pbuf = pbuf - 1l;
  }

  pbuf = str;
  for( ; (_Bool)1; pbuf = pbuf + 1l)
    if(!((signed int)*pbuf == 32))
    {
      if(!((signed int)*pbuf == 9))
        goto __CPROVER_DUMP_L20;

    }


__CPROVER_DUMP_L20:
  ;
  _Bool tmp_if_expr$4;
  if(!(quote == 0))
    tmp_if_expr$4 = (signed int)*pbuf == 39 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    if(!(dblquote == 0))
      tmp_if_expr$5 = (signed int)*pbuf == 34 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
    pbuf = pbuf + 1l;

  return pbuf;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// client_close
// file network.c line 775
static void client_close(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  if(!(command == ((struct session_commands_s *)NULL)) && !(session == ((struct session_s *)NULL)))
  {
    if(session->socket >= 0)
    {
      signed int i = 0;
      __sock_write(session->socket, 1, "exit");
      close(session->socket);
      session->socket = -1;
      session_update_prompt(session);
      for( ; !(session_commands[(signed long int)i]->command == ((char *)NULL)); i = i + 1)
        if(session_commands[(signed long int)i]->origin == 1)
          session_commands[(signed long int)i]->enable = 0;

    }

  }

}

// client_handle_command
// file network.c line 1031
static void client_handle_command(struct session_s *session, const char *command)
{
  signed int i;
  signed int found;
  char cmd[20480l];
  char *p;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(command == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen(command);
    tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  char *tmp_post$4;
  char *tmp_post$5;
  _Bool tmp_if_expr$13;
  unsigned long int return_value_strlen$11;
  signed int return_value_strncasecmp$12;
  if(!tmp_if_expr$2)
  {
    strlcpy(cmd, command, sizeof(char [20480l]) /*20480ul*/ );
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(cmd, 32);
    p = return_value___builtin_strchr$3;
    if(!(p == ((char *)NULL)))
      *p = (char)0;

    found = 0;
    i = found;
    for( ; !(session_commands[(signed long int)i]->command == ((char *)NULL)); i = i + 1)
    {
      if(!(found == 0))
        break;

      if(!(session_commands[(signed long int)i]->enable == 0))
      {
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(cmd);
        signed int return_value_strncasecmp$8;
        return_value_strncasecmp$8=strncasecmp(cmd, session_commands[(signed long int)i]->command, return_value_strlen$7);
        if(return_value_strncasecmp$8 == 0)
        {
          found = found + 1;
          if(session_commands[(signed long int)i]->origin == 2)
          {
            if(!(session_commands[(signed long int)i]->function == ((void (*)(struct session_s *, struct session_commands_s *, const char *))NULL)))
              session_commands[(signed long int)i]->function(session, session_commands[(signed long int)i], command);

          }

          else
          {
            char *client_handle_command$$1$$1$$1$$1$$2$$p;
            char *pp;
            char buf[20480l];
            client_handle_command$$1$$1$$1$$1$$2$$p = (char *)command;
            pp = buf;
            for( ; !((signed int)*client_handle_command$$1$$1$$1$$1$$2$$p == 0); client_handle_command$$1$$1$$1$$1$$2$$p = client_handle_command$$1$$1$$1$$1$$2$$p + 1l)
            {
              if((signed int)*client_handle_command$$1$$1$$1$$1$$2$$p == 37)
              {
                if(!((signed int)client_handle_command$$1$$1$$1$$1$$2$$p[1l] == 37))
                {
                  tmp_post$4 = pp;
                  pp = pp + 1l;
                  *tmp_post$4 = (char)37;
                  tmp_post$5 = pp;
                  pp = pp + 1l;
                  *tmp_post$5 = (char)37;
                }

                goto __CPROVER_DUMP_L12;
              }

              *pp = *client_handle_command$$1$$1$$1$$1$$2$$p;
              pp = pp + 1l;

            __CPROVER_DUMP_L12:
              ;
            }
            *pp = (char)0;
            signed int return_value___sock_write$6;
            return_value___sock_write$6=__sock_write(session->socket, 1, "%s", (const void *)buf);
            if(return_value___sock_write$6 == -1)
              session->running = 0;

          }
        }

      }

    }
    if(found == 0)
      __sock_write(session->socket, 1, "%s", (char *)command);

    unsigned long int return_value_strlen$9;
    return_value_strlen$9=strlen(cmd);
    signed int return_value_strncasecmp$10;
    return_value_strncasecmp$10=strncasecmp(cmd, "exit", return_value_strlen$9);
    if(return_value_strncasecmp$10 == 0)
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_strlen$11=strlen(cmd);
      return_value_strncasecmp$12=strncasecmp(cmd, "halt", return_value_strlen$11);
      tmp_if_expr$13 = !(return_value_strncasecmp$12 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
    {
      session_create_commands(session);
      session->socket = -1;
    }

  }

}

// client_help
// file network.c line 724
static void client_help(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  signed int i = 0;
  unsigned long int maxlen = (unsigned long int)0;
  unsigned long int j;
  signed int curpos = 0;
  char buf[20480l] = { 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 's', ' ', 'a', 'r', 'e', ':', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned long int return_value_strlen$3;
  if(!(command == ((struct session_commands_s *)NULL)) && !(session == ((struct session_s *)NULL)))
  {
    for( ; !(session_commands[(signed long int)i]->command == ((char *)NULL)); i = i + 1)
      if(!(session_commands[(signed long int)i]->enable == 0))
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(session_commands[(signed long int)i]->command);
        if(!(maxlen >= return_value_strlen$1))
          maxlen=strlen(session_commands[(signed long int)i]->command);

      }

    maxlen = maxlen + 1ul;
    i = 0;
    curpos = curpos + 7;
    for( ; !(session_commands[(signed long int)i]->command == ((char *)NULL)); i = i + 1)
      if(!(session_commands[(signed long int)i]->enable == 0))
      {
        if(maxlen + (unsigned long int)curpos >= 80ul)
        {
          strlcat(buf, "\n       ", sizeof(char [20480l]) /*20480ul*/ );
          curpos = 7;
        }

        strlcat(buf, session_commands[(signed long int)i]->command, sizeof(char [20480l]) /*20480ul*/ );
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(session_commands[(signed long int)i]->command);
        curpos = curpos + (signed int)return_value_strlen$2;
        j = (unsigned long int)0;
        do
        {
          return_value_strlen$3=strlen(session_commands[(signed long int)i]->command);
          if(j >= maxlen + -return_value_strlen$3)
            break;

          strlcat(buf, " ", sizeof(char [20480l]) /*20480ul*/ );
          curpos = curpos + 1;
          j = j + 1ul;
        }
        while((_Bool)1);
      }

    write_to_console(session, "%s\n", (const void *)buf);
  }

}

// client_noop
// file network.c line 722
static void client_noop(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  ;
}

// client_open
// file network.c line 795
static void client_open(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  char buf[20480l];
  char *pbuf;
  char *p;
  char *host = (char *)(void *)0;
  char *port = (char *)(void *)0;
  if(!(command == ((struct session_commands_s *)NULL)) && !(session == ((struct session_s *)NULL)))
  {
    if(session->socket >= 0)
      write_to_console(session, "Already connected to '%s:%s'.", (const void *)session->host, (const void *)session->port);

    else
      if(!(cmd == ((const char *)NULL)))
      {
        strlcpy(buf, cmd, sizeof(char [20480l]) /*20480ul*/ );
        pbuf = buf;
        char *return_value___builtin_strchr$2;
        return_value___builtin_strchr$2=__builtin_strchr(pbuf, 32);
        p = return_value___builtin_strchr$2;
        if(!(p == ((char *)NULL)))
        {
          host=_atoa(p);
          port=strrchr(p, 58);
          if(!(port == ((char *)NULL)))
          {
            unsigned long int return_value_strlen$1;
            return_value_strlen$1=strlen(port);
            if(return_value_strlen$1 >= 2ul)
            {
              *port = (char)0;
              port = port + 1l;
            }

            else
            {
              *port = (char)0;
              port = (char *)(void *)0;
            }
          }

        }

        if(!(host == ((char *)NULL)))
        {
          strlcpy(session->host, host, sizeof(char [256l]) /*256ul*/ );
          if(!(port == ((char *)NULL)))
            strlcpy(session->port, port, sizeof(char [256l]) /*256ul*/ );

          session_create_commands(session);
          session->socket=sock_client(session->host, session->port, "tcp");
          if(!(session->socket >= 0))
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            char *return_value_strerror$4;
            return_value_strerror$4=strerror(*return_value___errno_location$3);
            write_to_console(session, "opening server '%s' failed: %s.\nExiting.\n", (const void *)session->host, return_value_strerror$4);
            session->running = 0;
          }

          __sock_write(session->socket, 1, "commands");
          session_update_prompt(session);
        }

        else
          write_to_console(session, "open require arguments (host or host:port)\n");
      }

  }

}

// client_quit
// file network.c line 849
static void client_quit(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  client_close(session, command, cmd);
  session->running = 0;
}

// client_version
// file network.c line 768
static void client_version(struct session_s *session, struct session_commands_s *command, const char *cmd)
{
  if(!(command == ((struct session_commands_s *)NULL)) && !(session == ((struct session_s *)NULL)))
    write_to_console(session, "%s version %s\n\n", (const void *)"xine-remote", (const void *)"0.1.2");

}

// command_generator
// file network.c line 861
static char * command_generator(const char *text, signed int state)
{
  char *cmd;
  char *retcmd = (char *)(void *)0;
  static signed int len;
  static signed int index;
  if(state == 0)
  {
    index = 0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(text);
    len = (signed int)return_value_strlen$1;
  }

  if(!(len == 0))
    do
    {
      cmd = session_commands[(signed long int)index]->command;
      if(cmd == ((char *)NULL))
        break;

      index = index + 1;
      if(!(session_commands[(signed long int)(index + -1)]->enable == 0))
      {
        signed int return_value_strncasecmp$3;
        return_value_strncasecmp$3=strncasecmp(cmd, text, (unsigned long int)len);
        if(return_value_strncasecmp$3 == 0)
        {
          char *return_value___strdup$2;
          return_value___strdup$2=__strdup(cmd);
          retcmd = return_value___strdup$2;
          return retcmd;
        }

      }

    }
    while((_Bool)1);

  return (char *)(void *)0;
}

// completion_function
// file network.c line 884
static char ** completion_function(const char *text, signed int start, signed int end)
{
  char **cmd = (char **)(void *)0;
  if(start == 0)
    cmd=rl_completion_matches(text, command_generator);

  return cmd;
}

// config_mrl
// file config_wrapper.c line 129
void config_mrl(const char *mrl)
{
  struct xine_cfg_entry_s entry;
  char *key;
  char *config;
  char *_mrl;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, "misc.implicit_config", &entry);
  unsigned long int return_value_strlen$4;
  char *tmp_statement_expression$5;
  unsigned long int return_value_strlen$9;
  char *tmp_post$8;
  unsigned long int return_value_strlen$13;
  signed long int return_value_strtol$10;
  signed int return_value_get_bool_value$11;
  if(entry.num_value == 0 || return_value_xine_config_lookup_entry$1 == 0 || !(entry.type == 5))
    fprintf(stderr, "You tried to change the configuration with a cfg: MRL.\nThis is not allowed unless you enable the 'misc.implicit_config' setting after reading and understanding its help text.");

  else
  {
    char *return_value___strdup$2;
    return_value___strdup$2=__strdup(mrl);
    _mrl = return_value___strdup$2;
    char *return_value___builtin_strchr$3;
    return_value___builtin_strchr$3=__builtin_strchr(_mrl, 47);
    config = return_value___builtin_strchr$3;
    if(!(config == ((char *)NULL)))
    {
      return_value_strlen$4=strlen(config);
      if(!(return_value_strlen$4 == 0ul))
        config = config + 1l;

    }

    do
    {
      char __r0;
      char __r1;
      char __r2;
      char *return_value___strsep_g$6;
      return_value___strsep_g$6=__strsep_g(&config, ",");
      tmp_statement_expression$5 = return_value___strsep_g$6;
      key = tmp_statement_expression$5;
      if(key == ((char *)NULL))
        break;

      char *str_value;
      char *return_value___builtin_strchr$7;
      return_value___builtin_strchr$7=__builtin_strchr(key, 58);
      str_value = return_value___builtin_strchr$7;
      if(!(str_value == ((char *)NULL)))
      {
        return_value_strlen$9=strlen(str_value);
        if(!(return_value_strlen$9 == 0ul))
        {
          tmp_post$8 = str_value;
          str_value = str_value + 1l;
          *tmp_post$8 = (char)0;
        }

      }

      if(!(str_value == ((char *)NULL)))
      {
        return_value_strlen$13=strlen(str_value);
        if(!(return_value_strlen$13 == 0ul))
        {
          signed int return_value_xine_config_lookup_entry$12;
          return_value_xine_config_lookup_entry$12=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
          if(!(return_value_xine_config_lookup_entry$12 == 0))
          {
            if(entry.exp_level >= 30)
            {
              fprintf(stderr, "For security reason, you're not allowed to change the configuration entry named '%s'.", entry.key);
              break;
            }

            switch(entry.type)
            {
              case 2:
              {
                config_update(&entry, entry.type, 0, 0, 0, str_value);
                break;
              }
              case 1:

              case 3:

              case 4:
              {
                return_value_strtol$10=strtol(str_value, &str_value, 10);
                config_update(&entry, entry.type == 1 ? 4 : entry.type, 0, 0, (signed int)return_value_strtol$10, (char *)(void *)0);
                break;
              }
              case 5:
              {
                return_value_get_bool_value$11=get_bool_value(str_value);
                config_update(&entry, entry.type, 0, 0, return_value_get_bool_value$11, (char *)(void *)0);
                break;
              }
              case 0:

              default:
                fprintf(stderr, "WOW, key %s isn't registered\n", key);
            }
          }

        }

      }

    }
    while((_Bool)1);
    free((void *)_mrl);
  }
}

// config_update
// file config_wrapper.c line 44
static void config_update(struct xine_cfg_entry_s *entry, signed int type, signed int min, signed int max, signed int value, char *string)
{
  switch(type)
  {
    case 0:
    {
      fprintf(stderr, "Config key '%s' isn't registered yet.\n", entry->key);
      goto __CPROVER_DUMP_L7;
    }
    case 1:
    {
      entry->range_min = min;
      entry->range_max = max;
      break;
    }
    case 2:
    {
      entry->str_value = string;
      break;
    }
    case 3:

    case 4:

    case 5:
    {
      entry->num_value = value;
      break;
    }
    default:
    {
      fprintf(stderr, "Unknown config type %d\n", type);
      goto __CPROVER_DUMP_L7;
    }
  }
  xine_config_update_entry(__xineui_global_xine_instance, entry);

__CPROVER_DUMP_L7:
  ;
}

// config_update_bool
// file config_wrapper.c line 108
void config_update_bool(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry$1 == 0))
    config_update(&entry, 5, 0, 0, value > 0 ? 1 : 0, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, bool key %s isn't registered\n", key);
}

// config_update_enum
// file config_wrapper.c line 99
void config_update_enum(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry$1 == 0))
    config_update(&entry, 3, 0, 0, value, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, enum key %s isn't registered\n", key);
}

// config_update_num
// file config_wrapper.c line 117
void config_update_num(const char *key, signed int value)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry$1 == 0))
    config_update(&entry, 4, 0, 0, value, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, num key %s isn't registered\n", key);
}

// config_update_range
// file config_wrapper.c line 77
void config_update_range(const char *key, signed int min, signed int max)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(return_value_xine_config_lookup_entry$1 == 0))
    config_update(&entry, 1, min, max, 0, (char *)(void *)0);

  else
    fprintf(stderr, "WOW, range key %s isn't registered\n", key);
}

// config_update_string
// file config_wrapper.c line 86
void config_update_string(const char *key, char *string)
{
  struct xine_cfg_entry_s entry;
  signed int return_value_xine_config_lookup_entry$1;
  return_value_xine_config_lookup_entry$1=xine_config_lookup_entry(__xineui_global_xine_instance, key, &entry);
  if(!(string == ((char *)NULL)) && !(return_value_xine_config_lookup_entry$1 == 0))
    config_update(&entry, 2, 0, 0, 0, string);

  else
    if(string == ((char *)NULL))
      fprintf(stderr, "string is NULL\n");

    else
      fprintf(stderr, "WOW, string key %s isn't registered\n", key);
}

// dump_cpu_infos
// file dump.c line 63
void dump_cpu_infos(void)
{
  struct _IO_FILE *stream;
  char buffer[2048l];
  stream=fopen("/proc/cpuinfo", "r");
  unsigned long int return_value_fread$1;
  char *tmp_statement_expression$2;
  unsigned long int return_value_strlen$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(!(stream == ((struct _IO_FILE *)NULL)))
  {
    printf("   CPU information:\n");
    printf("   ---------------\n");
    memset((void *)&buffer, 0, sizeof(char [2048l]) /*2048ul*/ );
    do
    {
      return_value_fread$1=fread((void *)&buffer, (unsigned long int)1, (unsigned long int)2047, stream);
      if(return_value_fread$1 == 0ul)
        break;

      char *p;
      char *pp = buffer;
      do
      {
        char __r0;
        char __r1;
        char __r2;
        char *return_value___strsep_g$3;
        return_value___strsep_g$3=__strsep_g(&pp, "\n");
        tmp_statement_expression$2 = return_value___strsep_g$3;
        p = tmp_statement_expression$2;
        if(p == ((char *)NULL))
          break;

        if(!(p == ((char *)NULL)))
        {
          return_value_strlen$4=strlen(p);
          if(!(return_value_strlen$4 == 0ul))
            printf("\t%s\n", p);

        }

      }
      while((_Bool)1);
      memset((void *)&buffer, 0, sizeof(char [2048l]) /*2048ul*/ );
    }
    while((_Bool)1);
    printf("   -------\n");
    fclose(stream);
  }

  else
  {
    return_value___errno_location$5=__errno_location();
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    printf("   Unable to open '/proc/cpuinfo': '%s'.\n", return_value_strerror$6);
  }
}

// dump_error
// file dump.c line 97
void dump_error(const char *msg)
{
  if(!(__xineui_global_verbosity == 0))
  {
    fprintf(stderr, "%s", (const void *)"\n---------------------- (ERROR) ----------------------\n");
    fputs(msg, stderr);
    fprintf(stderr, "%s", (const void *)"\n------------------ (END OF ERROR) -------------------\n\n");
  }

}

// dump_host_info
// file dump.c line 40
void dump_host_info(void)
{
  struct utsname uts;
  signed int return_value_uname$3;
  return_value_uname$3=uname(&uts);
  if(return_value_uname$3 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    printf("uname() failed: %s\n", return_value_strerror$2);
  }

  else
  {
    printf("   Platform information:\n");
    printf("   --------------------\n");
    printf("        system name     : %s\n", (const void *)uts.sysname);
    printf("        node name       : %s\n", (const void *)uts.nodename);
    printf("        release         : %s\n", (const void *)uts.release);
    printf("        version         : %s\n", (const void *)uts.version);
    printf("        machine         : %s\n", (const void *)uts.machine);
  }
}

// dump_info
// file dump.c line 105
void dump_info(const char *msg)
{
  if(!(__xineui_global_verbosity == 0))
  {
    fprintf(stderr, "%s", (const void *)"\n---------------------- (INFO) ----------------------\n");
    fputs(msg, stderr);
    fprintf(stderr, "%s", (const void *)"\n------------------- (END OF INFO) ------------------\n\n");
  }

}

// get_bool_value
// file utils.c line 192
signed int get_bool_value(const char *val)
{
  signed int i;
  if(!(val == ((const char *)NULL)))
  {
    i = 0;
    for( ; !((unsigned long int)i >= 8ul); i = i + 1)
    {
      signed int return_value_strcasecmp$1;
      /* tag-#anon#clST[lARR7{S8}$S8$'str'||S8'value'|] */
struct anonymous$17
{
  // str
  char str[7l];
  // value
  char value;
};

/* */
      ;
      static struct anonymous$17 bools[8l] = { { .str={ '1', 0, 0, 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ 't', 'r', 'u', 'e', 0, 0, 0 }, .value=(char)1 },
    { .str={ 'y', 'e', 's', 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ 'o', 'n', 0, 0, 0, 0, 0 }, .value=(char)1 },
    { .str={ '0', 0, 0, 0, 0, 0, 0 }, .value=(char)0 },
    { .str={ 'f', 'a', 'l', 's', 'e', 0, 0 }, .value=(char)0 },
    { .str={ 'n', 'o', 0, 0, 0, 0, 0 }, .value=(char)0 },
    { .str={ 'o', 'f', 'f', 0, 0, 0, 0 }, .value=(char)0 } };
      return_value_strcasecmp$1=strcasecmp(bools[(signed long int)i].str, val);
      if(return_value_strcasecmp$1 == 0)
        return (signed int)bools[(signed long int)i].value;

    }
  }

  return 0;
}

// get_last_double_semicolon
// file utils.c line 212
const char * get_last_double_semicolon(const char *str)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  if(!(str == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(str);
    len = (signed int)return_value_strlen$1;
    if(!(len == 0))
    {
      const char *p = str + (signed long int)(len - 1);
      for( ; !(str >= p); p = p - 1l)
        if((signed int)*p == 58)
        {
          if((signed int)p[-1l] == 58)
            return p - (signed long int)1;

        }

    }

  }

  return (const char *)(void *)0;
}

// is_a_dir
// file utils.c line 321
signed int is_a_dir(char *filename)
{
  struct stat pstat;
  signed int return_value_stat$1;
  return_value_stat$1=stat(filename, &pstat);
  if(!(return_value_stat$1 >= 0))
    return 0;

  else
    return (signed int)((pstat.st_mode & (unsigned int)0170000) == (unsigned int)0040000);
}

// is_a_file
// file utils.c line 330
signed int is_a_file(char *filename)
{
  struct stat pstat;
  signed int return_value_stat$1;
  return_value_stat$1=stat(filename, &pstat);
  if(!(return_value_stat$1 >= 0))
    return 0;

  else
    return (signed int)((pstat.st_mode & (unsigned int)0170000) == (unsigned int)0100000);
}

// is_downloadable
// file utils.c line 314
signed int is_downloadable(char *filename)
{
  signed int return_value_strncasecmp$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strncasecmp$2;
  if(!(filename == ((char *)NULL)))
  {
    return_value_strncasecmp$1=strncasecmp(filename, "http://", (unsigned long int)7);
    if(return_value_strncasecmp$1 == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_strncasecmp$2=strncasecmp(filename, "ftp://", (unsigned long int)6);
      tmp_if_expr$3 = !(return_value_strncasecmp$2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
      goto __CPROVER_DUMP_L3;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    return 0;
  }
}

// is_ipv6_last_double_semicolon
// file utils.c line 230
signed int is_ipv6_last_double_semicolon(const char *str)
{
  unsigned long int return_value_strlen$3;
  const unsigned short int **return_value___ctype_b_loc$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(!(str == ((const char *)NULL)))
  {
    return_value_strlen$3=strlen(str);
    if(!(return_value_strlen$3 == 0ul))
    {
      const char *d_semic;
      d_semic=get_last_double_semicolon(str);
      if(!(d_semic == ((const char *)NULL)))
      {
        const char *bracketl = (const char *)(void *)0;
        const char *bracketr = (const char *)(void *)0;
        const char *p = d_semic + (signed long int)2;
        for( ; !(*p == 0); p = p + 1l)
        {
          if(!(bracketr == ((const char *)NULL)))
            break;

          if((signed int)*p == 93)
            bracketr = p;

        }
        if(!(bracketr == ((const char *)NULL)))
        {
          p = d_semic;
          for( ; bracketl == ((const char *)NULL) && p >= str; p = p - 1l)
            if((signed int)*p == 91)
              bracketl = p;

          if(!(bracketl == ((const char *)NULL)))
          {
            p = d_semic + (signed long int)2;
            for( ; !(*p == 0); p = p + 1l)
              switch((signed int)*p)
              {
                case 58:

                case 46:
                  break;
                case 93:
                {
                  p = d_semic;
                  for( ; p >= str; p = p - 1l)
                    switch((signed int)*p)
                    {
                      case 58:
                        break;
                      case 46:
                        return 0;
                      case 91:
                        return 1;
                      default:
                      {
                        return_value___ctype_b_loc$1=__ctype_b_loc();
                        if((4096 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*p]) == 0)
                          return 0;

                      }
                    }
                  break;
                }
                default:
                {
                  return_value___ctype_b_loc$2=__ctype_b_loc();
                  if((4096 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
                    return 0;

                }
              }
          }

        }

      }

    }

  }

  return 0;
}

// main
// file network.c line 1142
signed int main(signed int argc, char **argv)
{
  signed int c = 63;
  signed int option_index = 0;
  char *grabbed_line;
  struct sigaction action;
  struct servent *serv_ent;
  signed int port_set = 0;
  signed int auto_connect = 1;
  signed int single_shot = 0;
  void *p;
  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$3;
  return_value_sigaction$3=sigaction(1, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "sigaction(SIGHUP) failed: %s\n", return_value_strerror$2);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$6;
  return_value_sigaction$6=sigaction(10, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$6 == 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    fprintf(stderr, "sigaction(SIGUSR1) failed: %s\n", return_value_strerror$5);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$9;
  return_value_sigaction$9=sigaction(12, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$9 == 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    fprintf(stderr, "sigaction(SIGUSR2) failed: %s\n", return_value_strerror$8);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$12;
  return_value_sigaction$12=sigaction(2, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$12 == 0))
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    char *return_value_strerror$11;
    return_value_strerror$11=strerror(*return_value___errno_location$10);
    fprintf(stderr, "sigaction(SIGINT) failed: %s\n", return_value_strerror$11);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$15;
  return_value_sigaction$15=sigaction(15, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$15 == 0))
  {
    signed int *return_value___errno_location$13;
    return_value___errno_location$13=__errno_location();
    char *return_value_strerror$14;
    return_value_strerror$14=strerror(*return_value___errno_location$13);
    fprintf(stderr, "sigaction(SIGTERM) failed: %s\n", return_value_strerror$14);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$18;
  return_value_sigaction$18=sigaction(3, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$18 == 0))
  {
    signed int *return_value___errno_location$16;
    return_value___errno_location$16=__errno_location();
    char *return_value_strerror$17;
    return_value_strerror$17=strerror(*return_value___errno_location$16);
    fprintf(stderr, "sigaction(SIGQUIT) failed: %s\n", return_value_strerror$17);
  }

  action.__sigaction_handler.sa_handler = signals_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$21;
  return_value_sigaction$21=sigaction(14, &action, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$21 == 0))
  {
    signed int *return_value___errno_location$19;
    return_value___errno_location$19=__errno_location();
    char *return_value_strerror$20;
    return_value_strerror$20=strerror(*return_value___errno_location$19);
    fprintf(stderr, "sigaction(SIGALRM) failed: %s\n", return_value_strerror$20);
  }

  grabbed_line = (char *)(void *)0;
  session.socket = -1;
  pthread_mutex_init(&session.console_mutex, (const union anonymous$5 *)(void *)0);
  strcpy(session.host, "localhost");
  strcpy(session.port, "6789");
  opterr = 0;
  do
  {
    c=getopt_long(argc, argv, short_options, long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 72:
      {
        if(!(optarg == ((char *)NULL)))
          strlcpy(session.host, optarg, sizeof(char [256l]) /*256ul*/ );

        break;
      }
      case 80:
      {
        if(!(optarg == ((char *)NULL)))
        {
          port_set = 1;
          strlcpy(session.port, optarg, sizeof(char [256l]) /*256ul*/ );
        }

        break;
      }
      case 99:
      {
        single_shot = 1;
        break;
      }
      case 110:
      {
        auto_connect = 0;
        break;
      }
      case 118:
      {
        show_version();
        exit(1);
        break;
      }
      case 104:

      case 63:
      {
        show_usage();
        exit(1);
        break;
      }
      default:
      {
        show_usage();
        fprintf(stderr, "invalid argument %d => exit\n", c);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(!(single_shot == 0))
    session.console = -1;

  else
    session.console = 1;
  rl_readline_name = "xine-remote";
  rl_set_prompt(session.prompt);
  rl_initialize();
  rl_attempted_completion_function = completion_function;
  signal(13, (void (*)(signed int))1);
  unsigned short int tmp_statement_expression$22;
  if(port_set == 0)
  {
    serv_ent=getservbyname("xinectl", "tcp");
    if(!(serv_ent == ((struct servent *)NULL)))
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)serv_ent->s_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$22 = __v;
      snprintf(session.port, sizeof(char [256l]) /*256ul*/ , "%u", tmp_statement_expression$22);
    }

  }

  session_create_commands(&session);
  if(!(auto_connect == 0))
  {
    session.socket=sock_client(session.host, session.port, "tcp");
    if(!(session.socket >= 0))
    {
      signed int *return_value___errno_location$23;
      return_value___errno_location$23=__errno_location();
      char *return_value_strerror$24;
      return_value_strerror$24=strerror(*return_value___errno_location$23);
      fprintf(stderr, "opening server '%s' failed: %s\n", (const void *)session.host, return_value_strerror$24);
      exit(1);
    }

    __sock_write(session.socket, 1, "commands");
  }

  write_to_console(&session, "? for help.\n");
  session.running = 1;
  pthread_create(&session.thread, (const union pthread_attr_t *)(void *)0, select_thread, (void *)&session);
  _Bool tmp_if_expr$27;
  signed int *return_value___errno_location$26;
  if(!(single_shot == 0))
  {
    session_single_shot(&session, argc - optind, &argv[(signed long int)optind]);
    session.running = 0;
  }

  else
    while(!(session.running == 0))
    {
      session_update_prompt(&session);
      grabbed_line=readline(session.prompt);
      if(grabbed_line == ((char *)NULL))
      {
        signed int *return_value___errno_location$25;
        return_value___errno_location$25=__errno_location();
        if(*return_value___errno_location$25 == 0)
          tmp_if_expr$27 = (_Bool)1;

        else
        {
          return_value___errno_location$26=__errno_location();
          tmp_if_expr$27 = *return_value___errno_location$26 == 25 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$27)
          exit(0);

        signed int *return_value___errno_location$28;
        return_value___errno_location$28=__errno_location();
        char *return_value_strerror$29;
        return_value_strerror$29=strerror(*return_value___errno_location$28);
        fprintf(stderr, "%s(%d): readline() failed: %s\n", (const void *)"main", 1301, return_value_strerror$29);
        exit(1);
      }

      if(!(grabbed_line == ((char *)NULL)))
      {
        char *line;
        line=_atoa(grabbed_line);
        unsigned long int return_value_strlen$30;
        return_value_strlen$30=strlen(line);
        if(!(return_value_strlen$30 == 0ul))
        {
          add_history(line);
          client_handle_command(&session, line);
        }

      }

      do
      {
        free((void *)grabbed_line);
        grabbed_line = (char *)(void *)0;
      }
      while((_Bool)0);
    }

__end:
  ;
  if(session.socket >= 0)
    close(session.socket);

  pthread_join(session.thread, &p);
  pthread_mutex_destroy(&session.console_mutex);
  return 0;
}

// mkdir_safe
// file utils.c line 168
signed int mkdir_safe(char *path)
{
  char *p;
  char *pp;
  char buf[4352l];
  char buf2[4352l];
  char *tmp_statement_expression$1;
  unsigned long int return_value_strlen$5;
  if(path == ((char *)NULL))
    return 0;

  else
  {
    memset((void *)&buf, 0, sizeof(char [4352l]) /*4352ul*/ );
    memset((void *)&buf2, 0, sizeof(char [4352l]) /*4352ul*/ );
    strcpy(buf, path);
    pp = buf;
    do
    {
      char __r0;
      char __r1;
      char __r2;
      char *return_value___strsep_g$2;
      return_value___strsep_g$2=__strsep_g(&pp, "/");
      tmp_statement_expression$1 = return_value___strsep_g$2;
      p = tmp_statement_expression$1;
      if(p == ((char *)NULL))
        break;

      if(!(p == ((char *)NULL)))
      {
        return_value_strlen$5=strlen(p);
        if(!(return_value_strlen$5 == 0ul))
        {
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(buf2);
          sprintf(buf2 + (signed long int)return_value_strlen$3, "/%s", p);
          signed int return_value__mkdir_safe$4;
          return_value__mkdir_safe$4=_mkdir_safe(buf2);
          if(return_value__mkdir_safe$4 == 0)
            return 0;

        }

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// select_thread
// file network.c line 915
static void * select_thread(void *data)
{
  struct session_s *select_thread$$1$$session = (struct session_s *)data;
  struct anonymous$3 readfds;
  struct timeval timeout;
  char obuffer[20480l];
  signed int ocount;
  char buffer[20480l];
  signed int size;
  signed int select_thread$$1$$i;
  char c;
  signed int was_down = 1;
  memset((void *)&buffer, 0, sizeof(char [20480l]) /*20480ul*/ );
  memset((void *)&obuffer, 0, sizeof(char [20480l]) /*20480ul*/ );
  ocount = 0;
  signed int tmp_post$2;
  char *tmp_statement_expression$5;
  signed int tmp_post$14;
  while(!(select_thread$$1$$session->running == 0))
    if(select_thread$$1$$session->socket >= 0)
    {
      if(!(was_down == 0))
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&readfds)->fds_bits[(signed long int)(select_thread$$1$$session->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(select_thread$$1$$session->socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << select_thread$$1$$session->socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        timeout.tv_sec = (signed long int)0;
        timeout.tv_usec = (signed long int)200000;
        select(select_thread$$1$$session->socket + 1, &readfds, (struct anonymous$3 *)0, (struct anonymous$3 *)0, &timeout);
        was_down = 0;
      }

      if(!((readfds.fds_bits[(signed long int)(select_thread$$1$$session->socket / 8)] & (signed long int)(1UL << select_thread$$1$$session->socket % 8)) == 0l))
      {
        signed long int return_value_recvfrom$1;
        return_value_recvfrom$1=recvfrom(select_thread$$1$$session->socket, (void *)buffer, sizeof(char [20480l]) /*20480ul*/ , 16384, (void *)0, (unsigned int *)(void *)0);
        size = (signed int)return_value_recvfrom$1;
        if(size >= 1)
        {
          select_thread$$1$$i = 0;
          for( ; !(select_thread$$1$$i >= size); select_thread$$1$$i = select_thread$$1$$i + 1)
          {
            c = buffer[(signed long int)select_thread$$1$$i];
            switch((signed int)c)
            {
              case 13:
                break;
              case 10:
              {
                tmp_post$2 = ocount;
                ocount = ocount + 1;
                obuffer[(signed long int)tmp_post$2] = c;
                if(select_thread$$1$$i == size + -1)
                {
                  signed int pos;
                  unsigned long int return_value_strlen$3;
                  return_value_strlen$3=strlen(select_thread$$1$$session->prompt);
                  pos = (signed int)(return_value_strlen$3 + (unsigned long int)rl_end);
                  char *special;
                  special=strstr(obuffer, "/COMMANDS");
                  if(!(special == ((char *)NULL)))
                  {
                    char *p;
                    char *pp;
                    signed int special_length;
                    unsigned long int return_value_strlen$4;
                    return_value_strlen$4=strlen(special);
                    special_length = (signed int)return_value_strlen$4;
                    unsigned long int i = sizeof(struct session_commands_s [6l]) /*144ul*/  / sizeof(struct session_commands_s) /*24ul*/  - (unsigned long int)1;
                    pp = special + (signed long int)11;
                    do
                    {
                      char __r0;
                      char __r1;
                      char __r2;
                      char *return_value___strsep_g$6;
                      return_value___strsep_g$6=__strsep_g(&pp, "\t");
                      tmp_statement_expression$5 = return_value___strsep_g$6;
                      p = tmp_statement_expression$5;
                      if(p == ((char *)NULL))
                        break;

                      unsigned long int return_value_strlen$10;
                      return_value_strlen$10=strlen(p);
                      if(!(return_value_strlen$10 == 0ul))
                      {
                        for( ; (_Bool)1; p = p + 1l)
                          if(!((signed int)*p == 32))
                          {
                            if(!((signed int)*p == 9))
                              goto __CPROVER_DUMP_L11;

                          }


                      __CPROVER_DUMP_L11:
                        ;
                        void *return_value_realloc$7;
                        return_value_realloc$7=realloc((void *)session_commands, (i + (unsigned long int)2) * sizeof(struct session_commands_s *) /*8ul*/ );
                        session_commands = (struct session_commands_s **)return_value_realloc$7;
                        void *return_value_malloc$8;
                        return_value_malloc$8=malloc(sizeof(struct session_commands_s) /*24ul*/ );
                        session_commands[(signed long int)i] = (struct session_commands_s *)return_value_malloc$8;
                        char *return_value___strdup$9;
                        return_value___strdup$9=__strdup(p);
                        session_commands[(signed long int)i]->command = return_value___strdup$9;
                        session_commands[(signed long int)i]->origin = 1;
                        session_commands[(signed long int)i]->enable = 1;
                        session_commands[(signed long int)i]->function = client_noop;
                        i = i + 1ul;
                      }

                    }
                    while((_Bool)1);
                    unsigned long int return_value_strlen$11;
                    return_value_strlen$11=strlen(session_commands[(signed long int)(i - (unsigned long int)1)]->command);
                    session_commands[(signed long int)(i - (unsigned long int)1)]->command[(signed long int)(return_value_strlen$11 - (unsigned long int)1)] = (char)0;
                    unsigned long int return_value_strlen$12;
                    return_value_strlen$12=strlen(session_commands[(signed long int)(i - (unsigned long int)1)]->command);
                    session_commands[(signed long int)(i - (unsigned long int)1)]->command[(signed long int)(return_value_strlen$12 - (unsigned long int)1)] = (char)0;
                    void *return_value_malloc$13;
                    return_value_malloc$13=malloc(sizeof(struct session_commands_s) /*24ul*/ );
                    session_commands[(signed long int)i] = (struct session_commands_s *)return_value_malloc$13;
                    session_commands[(signed long int)i]->command = (char *)(void *)0;
                    session_commands[(signed long int)i]->origin = 2;
                    session_commands[(signed long int)i]->enable = 1;
                    session_commands[(signed long int)i]->function = (void (*)(struct session_s *, struct session_commands_s *, const char *))(void *)0;
                    ocount = ocount - special_length;
                    obuffer[(signed long int)ocount] = (char)0;
                  }

                  pthread_mutex_lock(&select_thread$$1$$session->console_mutex);
                  for( ; !(pos == 0); pos = pos - 1)
                    __sock_write(select_thread$$1$$session->console, 0, "\b \b");
                  __sock_write(select_thread$$1$$session->console, 1, "%s", (const void *)obuffer);
                  rl_crlf();
                  rl_forced_update_display();
                  pthread_mutex_unlock(&select_thread$$1$$session->console_mutex);
                  memset((void *)&obuffer, 0, sizeof(char [20480l]) /*20480ul*/ );
                  ocount = 0;
                }

                break;
              }
              default:
              {
                tmp_post$14 = ocount;
                ocount = ocount + 1;
                obuffer[(signed long int)tmp_post$14] = c;
              }
            }
          }
        }

      }

    }

    else
      was_down = 1;
  pthread_exit((void *)0);
}

// session_create_commands
// file network.c line 685
static void session_create_commands(struct session_s *session)
{
  signed int i;
  if(!(session == ((struct session_s *)NULL)))
  {
    if(!(session_commands == ((struct session_commands_s **)NULL)))
    {
      i = 0;
      for( ; !(session_commands[(signed long int)i]->command == ((char *)NULL)); i = i + 1)
      {
        free((void *)session_commands[(signed long int)i]->command);
        free((void *)session_commands[(signed long int)i]);
      }
      free((void *)session_commands[(signed long int)i]);
      free((void *)session_commands);
    }

    void *return_value_calloc$1;
    static const unsigned long int num_commands = sizeof(struct session_commands_s [6l]) /*144ul*/  / sizeof(struct session_commands_s) /*24ul*/ ;
    return_value_calloc$1=calloc(num_commands, sizeof(struct session_commands_s *) /*8ul*/ );
    session_commands = (struct session_commands_s **)return_value_calloc$1;
    i = 0;
    for( ; !(client_commands[(signed long int)i].command == ((char *)NULL)); i = i + 1)
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct session_commands_s) /*24ul*/ );
      session_commands[(signed long int)i] = (struct session_commands_s *)return_value_malloc$2;
      char *return_value___strdup$3;
      return_value___strdup$3=__strdup(client_commands[(signed long int)i].command);
      session_commands[(signed long int)i]->command = return_value___strdup$3;
      session_commands[(signed long int)i]->origin = client_commands[(signed long int)i].origin;
      session_commands[(signed long int)i]->enable = client_commands[(signed long int)i].enable;
      session_commands[(signed long int)i]->function = client_commands[(signed long int)i].function;
    }
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct session_commands_s) /*24ul*/ );
    session_commands[(signed long int)i] = (struct session_commands_s *)return_value_malloc$4;
    session_commands[(signed long int)i]->command = (char *)(void *)0;
    session_commands[(signed long int)i]->origin = 2;
    session_commands[(signed long int)i]->enable = 0;
    session_commands[(signed long int)i]->function = (void (*)(struct session_s *, struct session_commands_s *, const char *))(void *)0;
  }

}

// session_single_shot
// file network.c line 1108
static void session_single_shot(struct session_s *session, signed int num_commands, char **commands)
{
  signed int i;
  char buf[20480l];
  buf[(signed long int)0] = (char)0;
  i = 0;
  unsigned long int return_value_strlen$1;
  for( ; !(i >= num_commands); i = i + 1)
    if(!(buf[0l] == 0))
    {
      return_value_strlen$1=strlen(buf);
      sprintf(buf + (signed long int)return_value_strlen$1, " %s", commands[(signed long int)i]);
    }

    else
      strcpy(buf, commands[(signed long int)i]);
  client_handle_command(session, buf);
  usleep((unsigned int)10000);
  __sock_write(session->socket, 1, "exit");
}

// session_update_prompt
// file network.c line 675
static void session_update_prompt(struct session_s *session)
{
  if(!(session == ((struct session_s *)NULL)))
  {
    if(session->socket >= 0)
      snprintf(session->prompt, sizeof(char [544l]) /*544ul*/ , "[%s:%s]xine-remote >", (const void *)session->host, (const void *)session->port);

    else
      strlcpy(session->prompt, "[******:****]xine-remote >", sizeof(char [544l]) /*544ul*/ );
  }

}

// show_usage
// file network.c line 1131
static void show_usage(void)
{
  printf("usage: %s [options]\n", (const void *)"xine-remote");
  printf("  -H, --host <hostname>        Connect host <hostname>.\n");
  printf("  -P, --port <port>            Connect using <port>.\n");
  printf("  -c, --command <command>      Send <command> to server then quit.\n");
  printf("  -n, --noconnect              Do not connect default server.\n");
  printf("  -v, --version                Display version.\n");
  printf("  -h, --help                   Display this help text.\n");
  printf("\n");
}

// show_version
// file network.c line 1126
static void show_version(void)
{
  printf("This is %s - xine's remote control v%s.\n(c) 2000-2003 The xine Team.\n", (const void *)"xine-remote", (const void *)"0.1.2");
}

// signals_handler
// file network.c line 893
static void signals_handler(signed int sig)
{
  if(sig == 2 || sig == 15)
  {
    if(!(rl_prompt == ((char *)NULL)))
    {
      rl_kill_full_line(1, 1);
      rl_redisplay();
    }

    else
    {
      if(session.socket >= 0)
      {
        __sock_write(session.socket, 1, "exit");
        close(session.socket);
      }

      exit(1);
    }
  }

}

// sock_check_opened
// file network.c line 496
static signed int sock_check_opened(signed int socket)
{
  struct anonymous$3 readfds;
  struct anonymous$3 writefds;
  struct anonymous$3 exceptfds;
  signed int retval;
  struct timeval timeout;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$1;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int sock_check_opened$$1$$1$$1$$1$$__d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(sock_check_opened$$1$$1$$1$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
    do
    {
      signed int sock_check_opened$$1$$1$$1$$2$$__d0;
      signed int sock_check_opened$$1$$1$$1$$2$$__d1;
      asm("cld; rep; stosq" : "=c"(sock_check_opened$$1$$1$$1$$2$$__d0), "=D"(sock_check_opened$$1$$1$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writefds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int __d0;
      signed int sock_check_opened$$1$$1$$1$$3$$__d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(sock_check_opened$$1$$1$$1$$3$$__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&exceptfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&exceptfds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&exceptfds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    timeout.tv_sec = (signed long int)0;
    timeout.tv_usec = (signed long int)0;
    retval=select(socket + 1, &readfds, &writefds, &exceptfds, &timeout);
    if(retval == -1)
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 11))
      {
        return_value___errno_location$1=__errno_location();
        if(!(*return_value___errno_location$1 == 4))
          return 0;

      }

    }

    if(!(retval == -1))
      return 1;

  }
  while((_Bool)1);
  return 0;
}

// sock_client
// file network.c line 601
static signed int sock_client(const char *host, const char *service, const char *transport)
{
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'in'||lSYM#tag-sockaddr#'sa'|] */
union anonymous$8
{
  // in
  struct sockaddr_in in;
  // sa
  struct sockaddr sa;
};

/* */
  ;
  union anonymous$8 fsin;
  struct hostent *ihost;
  signed int sock;
  sock=sock_create(service, transport, &fsin.in);
  fsin.in.sin_addr.s_addr=inet_addr(host);
  if(fsin.in.sin_addr.s_addr == 0xffffffff)
  {
    ihost=gethostbyname(host);
    if(ihost == ((struct hostent *)NULL))
    {
      sock_err("Unknown host: %s\n", host);
      return -1;
    }

    memcpy((void *)&fsin.in.sin_addr, (const void *)ihost->h_addr_list[(signed long int)0], (unsigned long int)ihost->h_length);
  }

  signed int return_value_connect$5;
  return_value_connect$5=connect(sock, &fsin.sa, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_connect$5 >= 0))
  {
    signed int err;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    err = *return_value___errno_location$1;
    close(sock);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = err;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    sock_err("Unable to connect %s[%s]: %s\n", host, service, return_value_strerror$4);
    return -1;
  }

  return sock;
}

// sock_create
// file network.c line 446
static signed int sock_create(const char *service, const char *transport, struct sockaddr_in *sin)
{
  struct servent *iservice;
  struct protoent *itransport;
  signed int sock;
  signed int type;
  signed int proto;
  memset((void *)sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  sin->sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x;
  signed int return_value_atoi$2;
  return_value_atoi$2=atoi(service);
  __x = (unsigned short int)return_value_atoi$2;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  sin->sin_port = tmp_statement_expression$1;
  if(sin->sin_port == 0)
  {
    iservice=getservbyname(service, "tcp");
    if(iservice == ((struct servent *)NULL))
      sock_err("Service not registered: %s\n", service);

    sin->sin_port = (unsigned short int)iservice->s_port;
  }

  itransport=getprotobyname(transport);
  if(transport == ((const char *)NULL))
    sock_err("Protocol not registered: %s\n", transport);

  proto = itransport->p_proto;
  signed int tmp_statement_expression$3;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$4;
  return_value___builtin_strcmp$4=__builtin_strcmp(transport, "udp");
  tmp_statement_expression$3 = return_value___builtin_strcmp$4;
  if(tmp_statement_expression$3 == 0)
    type = 2;

  else
    type = 1;
  sock=socket(2, type, proto);
  if(!(sock >= 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    sock_err("Cannot create socket: %s\n", return_value_strerror$6);
    return -1;
  }

  signed int return_value_fcntl$9;
  return_value_fcntl$9=fcntl(sock, 2, 1);
  if(!(return_value_fcntl$9 >= 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    sock_err("** socket cannot be made uninheritable (%s)\n", return_value_strerror$8);
  }

  return sock;
}

// sock_err
// file network.c line 438
static void sock_err(const char *error_msg, ...)
{
  void **args = (void **)&error_msg;
  vfprintf(stderr, error_msg, args);
  args = ((void **)NULL);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// strlcat
// file ../../src/common/utils.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post$1;
  do
  {
    tmp_post$1 = n;
    n = n - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen$2;
  char *tmp_post$3;
  if(n == 0ul)
  {
    return_value_strlen$2=strlen(s);
    return dlen + return_value_strlen$2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post$3 = d;
        d = d + 1l;
        *tmp_post$3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../../src/common/utils.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post$1;
  const char *tmp_post$2;
  if(!(n == 0ul))
    do
    {
      n = n - 1ul;
      if(n == 0ul)
        break;

      tmp_post$1 = d;
      d = d + 1l;
      tmp_post$2 = s;
      s = s + 1l;
      *tmp_post$1 = *tmp_post$2;
      if((signed int)*tmp_post$1 == 0)
        break;

    }
    while((_Bool)1);

  const char *tmp_post$3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post$3 = s;
      s = s + 1l;
      if(*tmp_post$3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// write_to_console
// file network.c line 641
static signed int write_to_console(struct session_s *session, const char *msg, ...)
{
  char buf[20480l];
  void **args;
  signed int err;
  args = (void **)&msg;
  vsnprintf(buf, (unsigned long int)20480, msg, args);
  args = ((void **)NULL);
  pthread_mutex_lock(&session->console_mutex);
  err=__sock_write(session->console, 1, "%s", (const void *)buf);
  pthread_mutex_unlock(&session->console_mutex);
  return err;
}

// xine_system
// file utils.c line 44
signed int xine_system(signed int dont_run_as_root, char *command)
{
  signed int pid;
  signed int status;
  if(!(dont_run_as_root == 0))
  {
    unsigned int return_value_getuid$1;
    return_value_getuid$1=getuid();
    if(return_value_getuid$1 == 0u)
      return -1;

  }

  if(command == ((char *)NULL))
    return 1;

  else
  {
    pid=fork();
    if(pid == -1)
      return -1;

    else
    {
      if(pid == 0)
      {
        char *argv[4l];
        argv[(signed long int)0] = "sh";
        argv[(signed long int)1] = "-c";
        argv[(signed long int)2] = command;
        argv[(signed long int)3] = ((char *)NULL);
        execve("/bin/sh", argv, environ);
        exit(127);
      }

      do
      {
        signed int return_value_waitpid$3;
        return_value_waitpid$3=waitpid(pid, &status, 0);
        /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$18
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
        ;
        if(return_value_waitpid$3 == -1)
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          if(!(*return_value___errno_location$2 == 4))
            return -1;

        }

        else
          return (((union anonymous$18){ .__in=status }).__i & 0xff00) >> 8;
      }
      while((_Bool)1);
      return -1;
    }
  }
}

