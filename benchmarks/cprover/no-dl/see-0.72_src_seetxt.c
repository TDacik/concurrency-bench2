// #anon_enum_GDK_ACTION_DEFAULT=1_GDK_ACTION_COPY=2_GDK_ACTION_MOVE=4_GDK_ACTION_LINK=8_GDK_ACTION_PRIVATE=16_GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous_10 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum_GDK_AXIS_IGNORE=0_GDK_AXIS_X=1_GDK_AXIS_Y=2_GDK_AXIS_PRESSURE=3_GDK_AXIS_XTILT=4_GDK_AXIS_YTILT=5_GDK_AXIS_WHEEL=6_GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous_36 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum_GDK_DRAG_PROTO_MOTIF=0_GDK_DRAG_PROTO_XDND=1_GDK_DRAG_PROTO_ROOTWIN=2_GDK_DRAG_PROTO_NONE=3_GDK_DRAG_PROTO_WIN32_DROPFILES=4_GDK_DRAG_PROTO_OLE2=5_GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous_30 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum_GDK_FONT_FONT=0_GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous_12 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum_GDK_LSB_FIRST=0_GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous_19 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum_GDK_MODE_DISABLED=0_GDK_MODE_SCREEN=1_GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous_21 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum_GDK_NOTHING=-1_GDK_DELETE=0_GDK_DESTROY=1_GDK_EXPOSE=2_GDK_MOTION_NOTIFY=3_GDK_BUTTON_PRESS=4_GDK_2BUTTON_PRESS=5_GDK_3BUTTON_PRESS=6_GDK_BUTTON_RELEASE=7_GDK_KEY_PRESS=8_GDK_KEY_RELEASE=9_GDK_ENTER_NOTIFY=10_GDK_LEAVE_NOTIFY=11_GDK_FOCUS_CHANGE=12_GDK_CONFIGURE=13_GDK_MAP=14_GDK_UNMAP=15_GDK_PROPERTY_NOTIFY=16_GDK_SELECTION_CLEAR=17_GDK_SELECTION_REQUEST=18_GDK_SELECTION_NOTIFY=19_GDK_PROXIMITY_IN=20_GDK_PROXIMITY_OUT=21_GDK_DRAG_ENTER=22_GDK_DRAG_LEAVE=23_GDK_DRAG_MOTION=24_GDK_DRAG_STATUS=25_GDK_DROP_START=26_GDK_DROP_FINISHED=27_GDK_CLIENT_EVENT=28_GDK_VISIBILITY_NOTIFY=29_GDK_NO_EXPOSE=30_GDK_SCROLL=31_GDK_WINDOW_STATE=32_GDK_SETTING=33_GDK_OWNER_CHANGE=34_GDK_GRAB_BROKEN=35_GDK_DAMAGE=36_GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous_40 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum_GDK_SHIFT_MASK=1_GDK_LOCK_MASK=2_GDK_CONTROL_MASK=4_GDK_MOD1_MASK=8_GDK_MOD2_MASK=16_GDK_MOD3_MASK=32_GDK_MOD4_MASK=64_GDK_MOD5_MASK=128_GDK_BUTTON1_MASK=256_GDK_BUTTON2_MASK=512_GDK_BUTTON3_MASK=1024_GDK_BUTTON4_MASK=2048_GDK_BUTTON5_MASK=4096_GDK_SUPER_MASK=67108864_GDK_HYPER_MASK=134217728_GDK_META_MASK=268435456_GDK_RELEASE_MASK=1073741824_GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous_0 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum_GDK_SOURCE_MOUSE=0_GDK_SOURCE_PEN=1_GDK_SOURCE_ERASER=2_GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous_20 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum_GDK_VISUAL_STATIC_GRAY=0_GDK_VISUAL_GRAYSCALE=1_GDK_VISUAL_STATIC_COLOR=2_GDK_VISUAL_PSEUDO_COLOR=3_GDK_VISUAL_TRUE_COLOR=4_GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous_18 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum_GDK_WINDOW_STATE_WITHDRAWN=1_GDK_WINDOW_STATE_ICONIFIED=2_GDK_WINDOW_STATE_MAXIMIZED=4_GDK_WINDOW_STATE_STICKY=8_GDK_WINDOW_STATE_FULLSCREEN=16_GDK_WINDOW_STATE_ABOVE=32_GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous_15 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum_GDK_X_CURSOR=0_GDK_ARROW=2_GDK_BASED_ARROW_DOWN=4_GDK_BASED_ARROW_UP=6_GDK_BOAT=8_GDK_BOGOSITY=10_GDK_BOTTOM_LEFT_CORNER=12_GDK_BOTTOM_RIGHT_CORNER=14_GDK_BOTTOM_SIDE=16_GDK_BOTTOM_TEE=18_GDK_BOX_SPIRAL=20_GDK_CENTER_PTR=22_GDK_CIRCLE=24_GDK_CLOCK=26_GDK_COFFEE_MUG=28_GDK_CROSS=30_GDK_CROSS_REVERSE=32_GDK_CROSSHAIR=34_GDK_DIAMOND_CROSS=36_GDK_DOT=38_GDK_DOTBOX=40_GDK_DOUBLE_ARROW=42_GDK_DRAFT_LARGE=44_GDK_DRAFT_SMALL=46_GDK_DRAPED_BOX=48_GDK_EXCHANGE=50_GDK_FLEUR=52_GDK_GOBBLER=54_GDK_GUMBY=56_GDK_HAND1=58_GDK_HAND2=60_GDK_HEART=62_GDK_ICON=64_GDK_IRON_CROSS=66_GDK_LEFT_PTR=68_GDK_LEFT_SIDE=70_GDK_LEFT_TEE=72_GDK_LEFTBUTTON=74_GDK_LL_ANGLE=76_GDK_LR_ANGLE=78_GDK_MAN=80_GDK_MIDDLEBUTTON=82_GDK_MOUSE=84_GDK_PENCIL=86_GDK_PIRATE=88_GDK_PLUS=90_GDK_QUESTION_ARROW=92_GDK_RIGHT_PTR=94_GDK_RIGHT_SIDE=96_GDK_RIGHT_TEE=98_GDK_RIGHTBUTTON=100_GDK_RTL_LOGO=102_GDK_SAILBOAT=104_GDK_SB_DOWN_ARROW=106_GDK_SB_H_DOUBLE_ARROW=108_GDK_SB_LEFT_ARROW=110_GDK_SB_RIGHT_ARROW=112_GDK_SB_UP_ARROW=114_GDK_SB_V_DOUBLE_ARROW=116_GDK_SHUTTLE=118_GDK_SIZING=120_GDK_SPIDER=122_GDK_SPRAYCAN=124_GDK_STAR=126_GDK_TARGET=128_GDK_TCROSS=130_GDK_TOP_LEFT_ARROW=132_GDK_TOP_LEFT_CORNER=134_GDK_TOP_RIGHT_CORNER=136_GDK_TOP_SIDE=138_GDK_TOP_TEE=140_GDK_TREK=142_GDK_UL_ANGLE=144_GDK_UMBRELLA=146_GDK_UR_ANGLE=148_GDK_WATCH=150_GDK_XTERM=152_GDK_LAST_CURSOR=153_GDK_BLANK_CURSOR=-2_GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous_14 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum_GTK_ACCEL_VISIBLE=1_GTK_ACCEL_LOCKED=2_GTK_ACCEL_MASK=7
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 51
enum anonymous_1 { GTK_ACCEL_VISIBLE=1, GTK_ACCEL_LOCKED=2, GTK_ACCEL_MASK=7 };

// #anon_enum_GTK_DEST_DEFAULT_MOTION=1_GTK_DEST_DEFAULT_HIGHLIGHT=2_GTK_DEST_DEFAULT_DROP=4_GTK_DEST_DEFAULT_ALL=7
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 42
enum anonymous_11 { GTK_DEST_DEFAULT_MOTION=1, GTK_DEST_DEFAULT_HIGHLIGHT=2, GTK_DEST_DEFAULT_DROP=4, GTK_DEST_DEFAULT_ALL=7 };

// #anon_enum_GTK_DIALOG_MODAL=1_GTK_DIALOG_DESTROY_WITH_PARENT=2_GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous_45 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum_GTK_JUSTIFY_LEFT=0_GTK_JUSTIFY_RIGHT=1_GTK_JUSTIFY_CENTER=2_GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous_32 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum_GTK_PROGRESS_CONTINUOUS=0_GTK_PROGRESS_DISCRETE=1
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 51
enum anonymous_27 { GTK_PROGRESS_CONTINUOUS=0, GTK_PROGRESS_DISCRETE=1 };

// #anon_enum_GTK_PROGRESS_LEFT_TO_RIGHT=0_GTK_PROGRESS_RIGHT_TO_LEFT=1_GTK_PROGRESS_BOTTOM_TO_TOP=2_GTK_PROGRESS_TOP_TO_BOTTOM=3
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 57
enum anonymous_28 { GTK_PROGRESS_LEFT_TO_RIGHT=0, GTK_PROGRESS_RIGHT_TO_LEFT=1, GTK_PROGRESS_BOTTOM_TO_TOP=2, GTK_PROGRESS_TOP_TO_BOTTOM=3 };

// #anon_enum_GTK_RC_FG=1_GTK_RC_BG=2_GTK_RC_TEXT=4_GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous_13 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum_GTK_RELIEF_NORMAL=0_GTK_RELIEF_HALF=1_GTK_RELIEF_NONE=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 329
enum anonymous_33 { GTK_RELIEF_NORMAL=0, GTK_RELIEF_HALF=1, GTK_RELIEF_NONE=2 };

// #anon_enum_GTK_SELECTION_NONE=0_GTK_SELECTION_SINGLE=1_GTK_SELECTION_BROWSE=2_GTK_SELECTION_MULTIPLE=3_GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous_34 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum_GTK_SORT_ASCENDING=0_GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous_37 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum_GTK_STATE_NORMAL=0_GTK_STATE_ACTIVE=1_GTK_STATE_PRELIGHT=2_GTK_STATE_SELECTED=3_GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous_17 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum_GTK_TEXT_DIR_NONE=0_GTK_TEXT_DIR_LTR=1_GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous_31 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum_GTK_TEXT_WINDOW_PRIVATE=0_GTK_TEXT_WINDOW_WIDGET=1_GTK_TEXT_WINDOW_TEXT=2_GTK_TEXT_WINDOW_LEFT=3_GTK_TEXT_WINDOW_RIGHT=4_GTK_TEXT_WINDOW_TOP=5_GTK_TEXT_WINDOW_BOTTOM=6
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 48
enum anonymous { GTK_TEXT_WINDOW_PRIVATE=0, GTK_TEXT_WINDOW_WIDGET=1, GTK_TEXT_WINDOW_TEXT=2, GTK_TEXT_WINDOW_LEFT=3, GTK_TEXT_WINDOW_RIGHT=4, GTK_TEXT_WINDOW_TOP=5, GTK_TEXT_WINDOW_BOTTOM=6 };

// #anon_enum_GTK_TREE_VIEW_COLUMN_GROW_ONLY=0_GTK_TREE_VIEW_COLUMN_AUTOSIZE=1_GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous_46 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum_GTK_WINDOW_TOPLEVEL=0_GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous_5 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum_GTK_WIN_POS_NONE=0_GTK_WIN_POS_CENTER=1_GTK_WIN_POS_MOUSE=2_GTK_WIN_POS_CENTER_ALWAYS=3_GTK_WIN_POS_CENTER_ON_PARENT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 450
enum anonymous_35 { GTK_WIN_POS_NONE=0, GTK_WIN_POS_CENTER=1, GTK_WIN_POS_MOUSE=2, GTK_WIN_POS_CENTER_ALWAYS=3, GTK_WIN_POS_CENTER_ON_PARENT=4 };

// #anon_enum_GTK_WRAP_NONE=0_GTK_WRAP_CHAR=1_GTK_WRAP_WORD=2_GTK_WRAP_WORD_CHAR=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 467
enum anonymous_3 { GTK_WRAP_NONE=0, GTK_WRAP_CHAR=1, GTK_WRAP_WORD=2, GTK_WRAP_WORD_CHAR=3 };

// #anon_enum_G_CONNECT_AFTER=1_G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous_39 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum_G_IO_FLAG_APPEND=1_G_IO_FLAG_NONBLOCK=2_G_IO_FLAG_IS_READABLE=4_G_IO_FLAG_IS_WRITABLE=8_G_IO_FLAG_IS_WRITEABLE=8_G_IO_FLAG_IS_SEEKABLE=16_G_IO_FLAG_MASK=31_G_IO_FLAG_GET_MASK=31_G_IO_FLAG_SET_MASK=3
// file /usr/include/glib-2.0/glib/giochannel.h line 84
enum anonymous_44 { G_IO_FLAG_APPEND=1, G_IO_FLAG_NONBLOCK=2, G_IO_FLAG_IS_READABLE=4, G_IO_FLAG_IS_WRITABLE=8, G_IO_FLAG_IS_WRITEABLE=8, G_IO_FLAG_IS_SEEKABLE=16, G_IO_FLAG_MASK=31, G_IO_FLAG_GET_MASK=31, G_IO_FLAG_SET_MASK=3 };

// #anon_enum_G_IO_IN=1_G_IO_OUT=4_G_IO_PRI=2_G_IO_ERR=8_G_IO_HUP=16_G_IO_NVAL=32
// file /usr/include/glib-2.0/glib/gmain.h line 31
enum anonymous_43 { G_IO_IN=1, G_IO_OUT=4, G_IO_PRI=2, G_IO_ERR=8, G_IO_HUP=16, G_IO_NVAL=32 };

// #anon_enum_G_IO_STATUS_ERROR=0_G_IO_STATUS_NORMAL=1_G_IO_STATUS_EOF=2_G_IO_STATUS_AGAIN=3
// file /usr/include/glib-2.0/glib/giochannel.h line 69
enum anonymous_41 { G_IO_STATUS_ERROR=0, G_IO_STATUS_NORMAL=1, G_IO_STATUS_EOF=2, G_IO_STATUS_AGAIN=3 };

// #anon_enum_G_SEEK_CUR=0_G_SEEK_SET=1_G_SEEK_END=2
// file /usr/include/glib-2.0/glib/giochannel.h line 77
enum anonymous_42 { G_SEEK_CUR=0, G_SEEK_SET=1, G_SEEK_END=2 };

// #anon_enum_PANGO_ATTR_INVALID=0_PANGO_ATTR_LANGUAGE=1_PANGO_ATTR_FAMILY=2_PANGO_ATTR_STYLE=3_PANGO_ATTR_WEIGHT=4_PANGO_ATTR_VARIANT=5_PANGO_ATTR_STRETCH=6_PANGO_ATTR_SIZE=7_PANGO_ATTR_FONT_DESC=8_PANGO_ATTR_FOREGROUND=9_PANGO_ATTR_BACKGROUND=10_PANGO_ATTR_UNDERLINE=11_PANGO_ATTR_STRIKETHROUGH=12_PANGO_ATTR_RISE=13_PANGO_ATTR_SHAPE=14_PANGO_ATTR_SCALE=15_PANGO_ATTR_FALLBACK=16_PANGO_ATTR_LETTER_SPACING=17_PANGO_ATTR_UNDERLINE_COLOR=18_PANGO_ATTR_STRIKETHROUGH_COLOR=19_PANGO_ATTR_ABSOLUTE_SIZE=20_PANGO_ATTR_GRAVITY=21_PANGO_ATTR_GRAVITY_HINT=22_PANGO_ATTR_FONT_FEATURES=23_PANGO_ATTR_FOREGROUND_ALPHA=24_PANGO_ATTR_BACKGROUND_ALPHA=25
// file /usr/include/pango-1.0/pango/pango-attributes.h line 150
enum anonymous_29 { PANGO_ATTR_INVALID=0, PANGO_ATTR_LANGUAGE=1, PANGO_ATTR_FAMILY=2, PANGO_ATTR_STYLE=3, PANGO_ATTR_WEIGHT=4, PANGO_ATTR_VARIANT=5, PANGO_ATTR_STRETCH=6, PANGO_ATTR_SIZE=7, PANGO_ATTR_FONT_DESC=8, PANGO_ATTR_FOREGROUND=9, PANGO_ATTR_BACKGROUND=10, PANGO_ATTR_UNDERLINE=11, PANGO_ATTR_STRIKETHROUGH=12, PANGO_ATTR_RISE=13, PANGO_ATTR_SHAPE=14, PANGO_ATTR_SCALE=15, PANGO_ATTR_FALLBACK=16, PANGO_ATTR_LETTER_SPACING=17, PANGO_ATTR_UNDERLINE_COLOR=18, PANGO_ATTR_STRIKETHROUGH_COLOR=19, PANGO_ATTR_ABSOLUTE_SIZE=20, PANGO_ATTR_GRAVITY=21, PANGO_ATTR_GRAVITY_HINT=22, PANGO_ATTR_FONT_FEATURES=23, PANGO_ATTR_FOREGROUND_ALPHA=24, PANGO_ATTR_BACKGROUND_ALPHA=25 };

// #anon_enum_PANGO_WEIGHT_THIN=100_PANGO_WEIGHT_ULTRALIGHT=200_PANGO_WEIGHT_LIGHT=300_PANGO_WEIGHT_SEMILIGHT=350_PANGO_WEIGHT_BOOK=380_PANGO_WEIGHT_NORMAL=400_PANGO_WEIGHT_MEDIUM=500_PANGO_WEIGHT_SEMIBOLD=600_PANGO_WEIGHT_BOLD=700_PANGO_WEIGHT_ULTRABOLD=800_PANGO_WEIGHT_HEAVY=900_PANGO_WEIGHT_ULTRAHEAVY=1000
// file /usr/include/pango-1.0/pango/pango-font.h line 97
enum anonymous_38 { PANGO_WEIGHT_THIN=100, PANGO_WEIGHT_ULTRALIGHT=200, PANGO_WEIGHT_LIGHT=300, PANGO_WEIGHT_SEMILIGHT=350, PANGO_WEIGHT_BOOK=380, PANGO_WEIGHT_NORMAL=400, PANGO_WEIGHT_MEDIUM=500, PANGO_WEIGHT_SEMIBOLD=600, PANGO_WEIGHT_BOLD=700, PANGO_WEIGHT_ULTRABOLD=800, PANGO_WEIGHT_HEAVY=900, PANGO_WEIGHT_ULTRAHEAVY=1000 };

// tag-#anon#ST[*{S8}_S8_'txtfnt'||S32'width'||S32'height'||S8'wrap'||U56'_pad0'||*{cS8}_cS8_'tbcolor'||S8'bConfirm'||S8'bRedirect'||U16'_pad1'||S32'watchtime'||*{S8}_S8_'filelist'||ARR108{S8}_S8_'sock'||U32'_pad2'||*{S8}_S8_'editor'||*{S8}_S8_'copyto'||*{S8}_S8_'seedata'||S32'tailat'||U32'_pad3'|]
// file main.h line 54
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'toplevel_under_pointer'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window_under_pointer'||F64'toplevel_x'||F64'toplevel_y'||U32'state'||U32'button'||U64'motion_hint_serial'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 63
struct anonymous_23;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'native_window'||U64'serial'||S32'owner_events'||U32'time'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 47
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'hbx'||*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'back'||*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'current'||*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'forward'||*{SYM#tag-_GtkTreeSelection#}_SYM#tag-_GtkTreeSelection#_'select'|]
// file main.h line 71
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'wgt'||*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'image1'||*{SYM#tag-_GtkWidget#}_SYM#tag-_GtkWidget#_'image2'||S32'sw'||U32'_pad0'|]
// file main.h line 47
struct anonymous_26;

// tag-#anon#ST[ARR4097{S8}_S8_'path'||ARR129{S8}_S8_'name'||S8'type'||ARR17{S8}_S8_'sec'|]
// file main.h line 79
struct anonymous_2;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_9;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_24;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'cond'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||S32'data'||U32'_pad0'|]
// file main.h line 86
struct anonymous_8;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}_V_'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous_4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GIConv
// file /usr/include/glib-2.0/glib/gconvert.h line 77
struct _GIConv;

// tag-_GIOChannel
// file /usr/include/glib-2.0/glib/giochannel.h line 41
struct _GIOChannel;

// tag-_GIOFuncs
// file /usr/include/glib-2.0/glib/giochannel.h line 42
struct _GIOFuncs;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GSource
// file /usr/include/glib-2.0/glib/gmain.h line 64
struct _GSource;

// tag-_GSourceCallbackFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 77
struct _GSourceCallbackFuncs;

// tag-_GSourceFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 130
struct _GSourceFuncs;

// tag-_GSourcePrivate
// file /usr/include/glib-2.0/glib/gmain.h line 65
struct _GSourcePrivate;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDisplay
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 115
struct _GdkDisplay;

// tag-_GdkDisplayPointerHooks
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 37
struct _GdkDisplayPointerHooks;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkCheckButton
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 48
struct _GtkCheckButton;

// tag-_GtkClipboard
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 483
struct _GtkClipboard;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkFrame
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 49
struct _GtkFrame;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenu
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 49
struct _GtkMenu;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkProgress
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 48
struct _GtkProgress;

// tag-_GtkProgressBar
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 48
struct _GtkProgressBar;

// tag-_GtkRadioButton
// file /usr/include/gtk-2.0/gtk/gtkradiobutton.h line 48
struct _GtkRadioButton;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSelectionData
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 479
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTargetEntry
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 42
struct _GtkTargetEntry;

// tag-_GtkTextAppearance
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 170
struct _GtkTextAppearance;

// tag-_GtkTextAttributes
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 70
struct _GtkTextAttributes;

// tag-_GtkTextBTree
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 61
struct _GtkTextBTree;

// tag-_GtkTextBuffer
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 51
struct _GtkTextBuffer;

// tag-_GtkTextIter
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 67
struct _GtkTextIter;

// tag-_GtkTextLayout
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 72
struct _GtkTextLayout;

// tag-_GtkTextLogAttrCache
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 63
struct _GtkTextLogAttrCache;

// tag-_GtkTextMark
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 61
struct _GtkTextMark;

// tag-_GtkTextPendingScroll
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 66
struct _GtkTextPendingScroll;

// tag-_GtkTextTag
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 81
struct _GtkTextTag;

// tag-_GtkTextTagTable
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 68
struct _GtkTextTagTable;

// tag-_GtkTextView
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 61
struct _GtkTextView;

// tag-_GtkTextWindow
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 65
struct _GtkTextWindow;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 58
struct _GtkTreeSelection;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoAttrClass
// file /usr/include/pango-1.0/pango/pango-attributes.h line 68
struct _PangoAttrClass;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoAttribute
// file /usr/include/pango-1.0/pango/pango-attributes.h line 67
struct _PangoAttribute;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLanguage
// file /usr/include/pango-1.0/pango/pango-language.h line 30
struct _PangoLanguage;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-_PangoTabArray
// file /usr/include/pango-1.0/pango/pango-tabs.h line 29
struct _PangoTabArray;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-matchspec
// file main.h line 92
struct matchspec;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#ifndef NULL
#define NULL ((void*)0)
#endif

// DnDdrop
// file see.c line 656
signed int DnDdrop(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, unsigned int time, void **NA);
// DnDleave
// file see.c line 677
void DnDleave(struct _GtkWidget *widget, struct _GdkDragContext *context, unsigned int time, void **NA);
// DnDmotion
// file see.c line 684
signed int DnDmotion(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, struct _GtkSelectionData *seld, unsigned int ttype, unsigned int time, void **NA);
// DnDreceive
// file see.c line 694
void DnDreceive(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, struct _GtkSelectionData *data, unsigned int ttype, unsigned int time, void **NA);
// FentKpress
// file see.c line 879
signed int FentKpress(struct _GtkWidget *widget, struct _GdkEventKey *kyprs, void **data);
// SFcopy
// file see.c line 2118
struct anonymous_2 * SFcopy(struct anonymous_2 *orig);
// TxTKpress
// file see.c line 2337
signed int TxTKpress(struct _GtkWidget *widget, struct _GdkEventKey *kyprs, void **data);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// addtohistory
// file see.c line 357
void addtohistory(char *line);
// applytag
// file see.c line 420
void applytag(signed int Ts, signed int Te, char *tag);
// apropos
// file see.c line 378
void apropos();
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// blinktoggle
// file see.c line 429
signed int blinktoggle(struct anonymous_26 *ff);
// bookmark_list
// file see.c line 442
void bookmark_list();
// buflen
// file main.h line 170
signed int buflen(char *buffer);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// changewrapmode
// file see.c line 507
void changewrapmode(struct _GtkWidget *RButton, char mode);
// check_seesock
// file main.h line 188
signed int check_seesock();
// clear
// file see.c line 525
void clear(signed int opt);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closeFL_window
// file see.c line 551
void closeFL_window(struct _GtkWidget *ignored, void **sbwin);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// confirm_popup
// file see.c line 557
signed int confirm_popup(char *title, char *messg);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// copytmp
// file main.h line 171
signed int copytmp(char *tmp, char *perm);
// copytoX
// file see.c line 574
void copytoX(struct _GtkWidget *ignored, signed int opt);
// cursor_tofound
// file see.c line 583
void cursor_tofound(struct _GtkWidget *widget, signed int way);
// cursorline
// file see.c line 621
signed int cursorline();
// defluff
// file main.h line 172
char * defluff(char *string);
// delbmk
// file see.c line 633
signed int delbmk(struct _GtkWidget *treeview, struct _GdkEventButton *MoBt, struct _GtkListStore *liststore);
// destroy_widget
// file see.c line 651
void destroy_widget(struct _GtkWidget *widget, struct _GtkWidget *dead);
// dobmks
// file see.c line 716
void dobmks();
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// ec_malloc
// file main.h line 173
void * ec_malloc(unsigned long int bytes);
// error_popup
// file see.c line 770
void error_popup(char *messg);
// exeFSlisting
// file see.c line 863
void exeFSlisting(char *listing);
// exec_proc
// file see.c line 784
void exec_proc();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdreadin
// file main.h line 174
signed int fdreadin(char *source, char *buffer, char end, signed int max, signed int offset);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_check
// file main.h line 189
signed int file_check(char *file);
// file_out
// file see.c line 906
void file_out(void);
// filelen
// file main.h line 175
signed int filelen(char *file);
// fileselect
// file see.c line 952
void fileselect(struct _GtkTreeView *treeview, struct _GtkTreePath *treepath, struct _GtkTreeViewColumn *treecol, struct _GtkWidget *swin);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseeko
// file /usr/include/stdio.h line 781
extern signed int fseeko(struct _IO_FILE *, signed long int, signed int);
// g_get_home_dir
// file /usr/include/glib-2.0/glib/gutils.h line 90
extern const char * g_get_home_dir(void);
// g_io_add_watch
// file /usr/include/glib-2.0/glib/giochannel.h line 200
extern unsigned int g_io_add_watch(struct _GIOChannel *, enum anonymous_43, signed int (*)(struct _GIOChannel *, enum anonymous_43, void *), void *);
// g_io_channel_set_close_on_unref
// file /usr/include/glib-2.0/glib/giochannel.h line 240
extern void g_io_channel_set_close_on_unref(struct _GIOChannel *, signed int);
// g_io_channel_shutdown
// file /usr/include/glib-2.0/glib/giochannel.h line 186
extern enum anonymous_41 g_io_channel_shutdown(struct _GIOChannel *, signed int, struct _GError **);
// g_io_channel_unix_get_fd
// file /usr/include/glib-2.0/glib/giochannel.h line 323
extern signed int g_io_channel_unix_get_fd(struct _GIOChannel *);
// g_io_channel_unix_new
// file /usr/include/glib-2.0/glib/giochannel.h line 321
extern struct _GIOChannel * g_io_channel_unix_new(signed int);
// g_io_channel_unref
// file /usr/include/glib-2.0/glib/giochannel.h line 163
extern void g_io_channel_unref(struct _GIOChannel *);
// g_list_nth_data
// file /usr/include/glib-2.0/glib/glist.h line 143
extern void * g_list_nth_data(struct _GList *, unsigned int);
// g_object_get
// file /usr/include/glib-2.0/gobject/gobject.h line 436
extern void g_object_get(void *, const char *, ...);
// g_object_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 478
extern void * g_object_ref(void *);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_print
// file /usr/include/glib-2.0/glib/gmessages.h line 265
extern void g_print(const char *, ...);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous_39);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_utf8_validate
// file /usr/include/glib-2.0/glib/gunicode.h line 790
extern signed int g_utf8_validate(const char *, signed long int, const char **);
// gdk_color_parse
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 136
signed int gdk_color_parse(const char *, struct _GdkColor *);
// gdk_cursor_new
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 142
struct _GdkCursor * gdk_cursor_new(enum anonymous_14);
// gdk_cursor_unref
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 156
void gdk_cursor_unref(struct _GdkCursor *);
// gdk_display_flush
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 157
void gdk_display_flush(struct _GdkDisplay *);
// gdk_display_get_default
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 179
struct _GdkDisplay * gdk_display_get_default(void);
// gdk_window_set_cursor
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 547
void gdk_window_set_cursor(struct _GdkDrawable *, struct _GdkCursor *);
// getMsg
// file server.c line 78
signed int getMsg(signed int fd, char *buffer, signed int sz);
// getagcoords
// file see.c line 983
signed int getagcoords(struct _GtkTextTag *tag, char *tagline);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gotoCursor
// file see.c line 1010
void gotoCursor(struct _GtkWidget *ignored);
// gotobmk
// file see.c line 1007
void gotobmk();
// grabfocus
// file see.c line 1019
void grabfocus(struct _GtkWidget *ignored);
// gtk_accel_group_new
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 123
struct _GtkAccelGroup * gtk_accel_group_new(void);
// gtk_adjustment_get_page_size
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 107
double gtk_adjustment_get_page_size(struct _GtkAdjustment *);
// gtk_adjustment_get_upper
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 98
double gtk_adjustment_get_upper(struct _GtkAdjustment *);
// gtk_adjustment_set_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 93
void gtk_adjustment_set_value(struct _GtkAdjustment *, double);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_end
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 114
void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 91
unsigned long int gtk_button_get_type(void);
// gtk_button_new
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 92
struct _GtkWidget * gtk_button_new(void);
// gtk_button_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 94
struct _GtkWidget * gtk_button_new_from_stock(const char *);
// gtk_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 93
struct _GtkWidget * gtk_button_new_with_label(const char *);
// gtk_button_set_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 109
void gtk_button_set_label(struct _GtkButton *, const char *);
// gtk_button_set_relief
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 106
void gtk_button_set_relief(struct _GtkButton *, enum anonymous_33);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_clipboard_get_for_display
// file /usr/include/gtk-2.0/gtk/gtkclipboard.h line 72
struct _GtkClipboard * gtk_clipboard_get_for_display(struct _GdkDisplay *, struct _GdkAtom *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_remove
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 113
void gtk_container_remove(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_set_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 108
void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_new_with_buttons
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 130
struct _GtkWidget * gtk_dialog_new_with_buttons(const char *, struct _GtkWindow *, enum anonymous_45, const char *, ...);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_drag_dest_add_text_targets
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 93
void gtk_drag_dest_add_text_targets(struct _GtkWidget *);
// gtk_drag_dest_add_uri_targets
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 95
void gtk_drag_dest_add_uri_targets(struct _GtkWidget *);
// gtk_drag_dest_set
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 74
void gtk_drag_dest_set(struct _GtkWidget *, enum anonymous_11, const struct _GtkTargetEntry *, signed int, enum anonymous_10);
// gtk_drag_finish
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 64
void gtk_drag_finish(struct _GdkDragContext *, signed int, signed int, unsigned int);
// gtk_drag_get_data
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 60
void gtk_drag_get_data(struct _GtkWidget *, struct _GdkDragContext *, struct _GdkAtom *, unsigned int);
// gtk_entry_get_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 216
const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_new
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 167
struct _GtkWidget * gtk_entry_new(void);
// gtk_entry_set_has_frame
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 185
void gtk_entry_set_has_frame(struct _GtkEntry *, signed int);
// gtk_entry_set_max_length
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 198
void gtk_entry_set_max_length(struct _GtkEntry *, signed int);
// gtk_entry_set_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 213
void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_entry_set_width_chars
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 207
void gtk_entry_set_width_chars(struct _GtkEntry *, signed int);
// gtk_events_pending
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 137
signed int gtk_events_pending(void);
// gtk_frame_get_label_widget
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 81
struct _GtkWidget * gtk_frame_get_label_widget(struct _GtkFrame *);
// gtk_frame_get_type
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 72
unsigned long int gtk_frame_get_type(void);
// gtk_frame_new
// file /usr/include/gtk-2.0/gtk/gtkframe.h line 73
struct _GtkWidget * gtk_frame_new(const char *);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_image_new_from_file
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 197
struct _GtkWidget * gtk_image_new_from_file(const char *);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_new_with_mnemonic
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 111
struct _GtkWidget * gtk_label_new_with_mnemonic(const char *);
// gtk_label_set_attributes
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 115
void gtk_label_set_attributes(struct _GtkLabel *, struct _PangoAttrList *);
// gtk_label_set_justify
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 138
void gtk_label_set_justify(struct _GtkLabel *, enum anonymous_32);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_label_set_width_chars
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 144
void gtk_label_set_width_chars(struct _GtkLabel *, signed int);
// gtk_list_store_append
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 126
void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 128
void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_new
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 78
struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_set
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 92
void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_iteration
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 148
signed int gtk_main_iteration(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 125
unsigned long int gtk_menu_get_type(void);
// gtk_menu_item_new
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 100
struct _GtkWidget * gtk_menu_item_new(void);
// gtk_menu_item_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 101
struct _GtkWidget * gtk_menu_item_new_with_label(const char *);
// gtk_menu_new
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 126
struct _GtkWidget * gtk_menu_new(void);
// gtk_menu_popup
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 129
void gtk_menu_popup(struct _GtkMenu *, struct _GtkWidget *, struct _GtkWidget *, void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *), void *, unsigned int, unsigned int);
// gtk_menu_set_accel_group
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 154
void gtk_menu_set_accel_group(struct _GtkMenu *, struct _GtkAccelGroup *);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_menu_shell_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 100
unsigned long int gtk_menu_shell_get_type(void);
// gtk_progress_bar_get_type
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 98
unsigned long int gtk_progress_bar_get_type(void);
// gtk_progress_bar_new
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 99
struct _GtkWidget * gtk_progress_bar_new(void);
// gtk_progress_bar_set_fraction
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 131
void gtk_progress_bar_set_fraction(struct _GtkProgressBar *, double);
// gtk_radio_button_get_group
// file /usr/include/gtk-2.0/gtk/gtkradiobutton.h line 84
struct _GSList * gtk_radio_button_get_group(struct _GtkRadioButton *);
// gtk_radio_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkradiobutton.h line 72
unsigned long int gtk_radio_button_get_type(void);
// gtk_radio_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkradiobutton.h line 76
struct _GtkWidget * gtk_radio_button_new_with_label(struct _GSList *, const char *);
// gtk_scrolled_window_get_hadjustment
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 109
struct _GtkAdjustment * gtk_scrolled_window_get_hadjustment(struct _GtkScrolledWindow *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_get_vadjustment
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 110
struct _GtkAdjustment * gtk_scrolled_window_get_vadjustment(struct _GtkScrolledWindow *);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_text_buffer_apply_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 290
void gtk_text_buffer_apply_tag(struct _GtkTextBuffer *, struct _GtkTextTag *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_apply_tag_by_name
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 298
void gtk_text_buffer_apply_tag_by_name(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_copy_clipboard
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 374
void gtk_text_buffer_copy_clipboard(struct _GtkTextBuffer *, struct _GtkClipboard *);
// gtk_text_buffer_create_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 259
struct _GtkTextMark * gtk_text_buffer_create_mark(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_create_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 314
struct _GtkTextTag * gtk_text_buffer_create_tag(struct _GtkTextBuffer *, const char *, const char *, ...);
// gtk_text_buffer_delete
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 218
void gtk_text_buffer_delete(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_bounds
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 340
void gtk_text_buffer_get_bounds(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_end_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 338
void gtk_text_buffer_get_end_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_insert
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 277
struct _GtkTextMark * gtk_text_buffer_get_insert(struct _GtkTextBuffer *);
// gtk_text_buffer_get_iter_at_line
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 333
void gtk_text_buffer_get_iter_at_line(struct _GtkTextBuffer *, struct _GtkTextIter *, signed int);
// gtk_text_buffer_get_iter_at_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 322
void gtk_text_buffer_get_iter_at_line_offset(struct _GtkTextBuffer *, struct _GtkTextIter *, signed int, signed int);
// gtk_text_buffer_get_iter_at_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 343
void gtk_text_buffer_get_iter_at_mark(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextMark *);
// gtk_text_buffer_get_iter_at_offset
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 330
void gtk_text_buffer_get_iter_at_offset(struct _GtkTextBuffer *, struct _GtkTextIter *, signed int);
// gtk_text_buffer_get_selection_bounds
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 381
signed int gtk_text_buffer_get_selection_bounds(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 231
char * gtk_text_buffer_get_text(struct _GtkTextBuffer *, const struct _GtkTextIter *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_insert
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 175
void gtk_text_buffer_insert(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int);
// gtk_text_buffer_insert_with_tags
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 203
void gtk_text_buffer_insert_with_tags(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int, struct _GtkTextTag *, ...);
// gtk_text_buffer_place_cursor
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 281
void gtk_text_buffer_place_cursor(struct _GtkTextBuffer *, const struct _GtkTextIter *);
// gtk_text_buffer_remove_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 294
void gtk_text_buffer_remove_tag(struct _GtkTextBuffer *, struct _GtkTextTag *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_select_range
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 283
void gtk_text_buffer_select_range(struct _GtkTextBuffer *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_buffer_set_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 170
void gtk_text_buffer_set_text(struct _GtkTextBuffer *, const char *, signed int);
// gtk_text_iter_backward_to_tag_toggle
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 259
signed int gtk_text_iter_backward_to_tag_toggle(struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_begins_tag
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 136
signed int gtk_text_iter_begins_tag(const struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_forward_find_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 264
signed int gtk_text_iter_forward_find_char(struct _GtkTextIter *, signed int (*)(unsigned int, void *), void *, const struct _GtkTextIter *);
// gtk_text_iter_forward_to_tag_toggle
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 256
signed int gtk_text_iter_forward_to_tag_toggle(struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_iter_get_chars_in_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 164
signed int gtk_text_iter_get_chars_in_line(const struct _GtkTextIter *);
// gtk_text_iter_get_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 97
signed int gtk_text_iter_get_line(const struct _GtkTextIter *);
// gtk_text_iter_get_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 98
signed int gtk_text_iter_get_line_offset(const struct _GtkTextIter *);
// gtk_text_iter_get_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 96
signed int gtk_text_iter_get_offset(const struct _GtkTextIter *);
// gtk_text_iter_has_tag
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 145
signed int gtk_text_iter_has_tag(const struct _GtkTextIter *, struct _GtkTextTag *);
// gtk_text_mark_get_type
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 89
unsigned long int gtk_text_mark_get_type(void);
// gtk_text_view_get_buffer
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 222
struct _GtkTextBuffer * gtk_text_view_get_buffer(struct _GtkTextView *);
// gtk_text_view_get_iter_location
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 247
void gtk_text_view_get_iter_location(struct _GtkTextView *, const struct _GtkTextIter *, struct _GdkRectangle *);
// gtk_text_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 217
unsigned long int gtk_text_view_get_type(void);
// gtk_text_view_get_window
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 285
struct _GdkDrawable * gtk_text_view_get_window(struct _GtkTextView *, enum anonymous);
// gtk_text_view_get_wrap_mode
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 336
enum anonymous_3 gtk_text_view_get_wrap_mode(struct _GtkTextView *);
// gtk_text_view_new
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 218
struct _GtkWidget * gtk_text_view_new(void);
// gtk_text_view_scroll_to_iter
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 223
signed int gtk_text_view_scroll_to_iter(struct _GtkTextView *, struct _GtkTextIter *, double, signed int, double, double);
// gtk_text_view_scroll_to_mark
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 229
void gtk_text_view_scroll_to_mark(struct _GtkTextView *, struct _GtkTextMark *, double, signed int, double, double);
// gtk_text_view_set_editable
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 337
void gtk_text_view_set_editable(struct _GtkTextView *, signed int);
// gtk_text_view_set_wrap_mode
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 334
void gtk_text_view_set_wrap_mode(struct _GtkTextView *, enum anonymous_3);
// gtk_toggle_button_get_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 84
signed int gtk_toggle_button_get_active(struct _GtkToggleButton *);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 77
struct _GtkWidget * gtk_toggle_button_new_with_label(const char *);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_path_new_from_string
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 126
struct _GtkTreePath * gtk_tree_path_new_from_string(const char *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 92
signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_get_tree_view
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 86
struct _GtkTreeView * gtk_tree_selection_get_tree_view(struct _GtkTreeSelection *);
// gtk_tree_selection_select_path
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 101
void gtk_tree_selection_select_path(struct _GtkTreeSelection *, struct _GtkTreePath *);
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 128
struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_get_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 145
struct _GtkTreeModel * gtk_tree_view_get_model(struct _GtkTreeView *);
// gtk_tree_view_get_selection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 148
struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 142
struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_tree_view_set_headers_visible
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 156
void gtk_tree_view_set_headers_visible(struct _GtkTreeView *, signed int);
// gtk_tree_view_set_rules_hint
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 162
void gtk_tree_view_set_rules_hint(struct _GtkTreeView *, signed int);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_widget_add_accelerator
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 892
void gtk_widget_add_accelerator(struct _GtkWidget *, const char *, struct _GtkAccelGroup *, unsigned int, enum anonymous_0, enum anonymous_1);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_destroyed
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 838
void gtk_widget_destroyed(struct _GtkWidget *, struct _GtkWidget **);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_grab_focus
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 942
void gtk_widget_grab_focus(struct _GtkWidget *);
// gtk_widget_modify_base
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1155
void gtk_widget_modify_base(struct _GtkWidget *, enum anonymous_17, const struct _GdkColor *);
// gtk_widget_modify_font
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1161
void gtk_widget_modify_font(struct _GtkWidget *, struct _PangoFontDescription *);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_add_accel_group
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 191
void gtk_window_add_accel_group(struct _GtkWindow *, struct _GtkAccelGroup *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous_5);
// gtk_window_present
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 330
void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_decorated
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 275
void gtk_window_set_decorated(struct _GtkWindow *, signed int);
// gtk_window_set_position
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 195
void gtk_window_set_position(struct _GtkWindow *, enum anonymous_35);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// gtk_window_set_transient_for
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 206
void gtk_window_set_transient_for(struct _GtkWindow *, struct _GtkWindow *);
// gtk_window_unfullscreen
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 340
void gtk_window_unfullscreen(struct _GtkWindow *);
// gtk_window_unmaximize
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 338
void gtk_window_unmaximize(struct _GtkWindow *);
// handlequit
// file see.c line 1024
void handlequit();
// help
// file see.c line 1051
void help(void);
// highlight
// file see.c line 1043
void highlight(struct _GtkWidget *widget, char *tag);
// initSF
// file see.c line 1054
struct anonymous_2 * initSF(char *path, char type, char *sec);
// linein
// file main.h line 176
char * linein(struct _IO_FILE *stream);
// list2view
// file see.c line 1093
void list2view(struct _GtkListStore *ls);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// loadfile
// file see.c line 1109
signed int loadfile(signed int setline);
// loadlarge
// file see.c line 1162
signed int loadlarge(signed int len);
// loadlist
// file see.c line 1213
signed int loadlist(char (*list)[5120l]);
// loadman
// file see.c line 1257
signed int loadman(signed int setline);
// loadnew
// file see.c line 1365
signed int loadnew(char *file, char *sec, signed int lastline);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loclcon
// file server.c line 97
signed int loclcon(char *sock);
// loclsckt
// file main.h line 192
signed int loclsckt(char *file);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// mainmenu
// file see.c line 1418
void mainmenu();
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mousevent
// file see.c line 1542
signed int mousevent(struct _GtkWidget *widget, struct _GdkEventButton *MoBt, void **data);
// nextfind
// file see.c line 1601
signed int nextfind(char *haystack, char *needle);
// nomax
// file see.c line 1593
signed int nomax(struct _GtkWidget *widget, struct _GdkEventWindowState *ptr, void **data);
// numberlines
// file see.c line 1623
void numberlines();
// onenwline
// file util.c line 126
void onenwline(char *buffer);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// pango_attr_list_insert
// file /usr/include/pango-1.0/pango/pango-attributes.h line 491
void pango_attr_list_insert(struct _PangoAttrList *, struct _PangoAttribute *);
// pango_attr_list_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 487
struct _PangoAttrList * pango_attr_list_new(void);
// pango_attr_weight_new
// file /usr/include/pango-1.0/pango/pango-attributes.h line 453
struct _PangoAttribute * pango_attr_weight_new(enum anonymous_38);
// pango_font_description_copy
// file /usr/include/pango-1.0/pango/pango-font.h line 219
struct _PangoFontDescription * pango_font_description_copy(const struct _PangoFontDescription *);
// pango_font_description_free
// file /usr/include/pango-1.0/pango/pango-font.h line 224
void pango_font_description_free(struct _PangoFontDescription *);
// pango_font_description_from_string
// file /usr/include/pango-1.0/pango/pango-font.h line 270
struct _PangoFontDescription * pango_font_description_from_string(const char *);
// pango_font_description_set_weight
// file /usr/include/pango-1.0/pango/pango-font.h line 239
void pango_font_description_set_weight(struct _PangoFontDescription *, enum anonymous_38);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// placebmk
// file see.c line 1646
void placebmk();
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reconfigure
// file see.c line 1659
struct anonymous_16 * reconfigure(struct _GtkWidget *ignored);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_24 *, signed int);
// regexp
// file main.h line 178
signed int regexp(char *string, char *patrn);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// reload
// file see.c line 1832
signed int reload();
// removetags
// file see.c line 1823
void removetags(struct _GtkWidget *widget, void **data);
// rescanFileList
// file see.c line 1860
void rescanFileList();
// returnline
// file main.h line 179
char * returnline(char *file, char *match);
// savebmks
// file see.c line 1868
void savebmks(struct _GtkWidget *widget, struct _GtkWidget *subwin);
// scrollToIter
// file see.c line 1934
void scrollToIter(struct _GtkTextIter *iter);
// scrolltoline
// file see.c line 1958
void scrolltoline(struct _GtkWidget *widget, signed int line);
// searchlight
// file see.c line 1968
void searchlight();
// send_remote
// file main.h line 193
signed int send_remote(char *term);
// serverLoop
// file server.c line 176
void * serverLoop(void *p);
// setFL_selected
// file see.c line 2071
void setFL_selected();
// setNULL
// file see.c line 2069
void setNULL(struct _GtkWidget *ignored, void **ptr);
// setwrapmode
// file see.c line 2080
void setwrapmode();
// shiftFilelist
// file see.c line 2125
void shiftFilelist(struct _GtkWidget *ignored, signed int val);
// showconfig
// file see.c line 2141
void showconfig(struct anonymous_16 *cfg);
// showlist
// file see.c line 2229
void showlist();
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sortintray
// file main.h line 180
void sortintray(signed int *ray, signed int len);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// streamline
// file main.h line 181
signed int streamline(struct _IO_FILE *IN, char **line, signed int bsize);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strexd
// file main.h line 182
signed int strexd(signed int EXPlen, char *string);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strsub
// file main.h line 183
char * strsub(const char *string, char *newname);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tailfile
// file see.c line 2274
signed int tailfile();
// takecall
// file server.c line 229
signed int takecall(struct _GIOChannel *gio, enum anonymous_43 ignored);
// testuni
// file see.c line 2301
signed int testuni(unsigned int CHR, signed short int chr);
// textline
// file see.c line 2307
char * textline(signed int line);
// tglServer
// file main.h line 196
void tglServer(struct _GtkWidget *ignored, signed int server);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toedit
// file see.c line 2319
void toedit();
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_filelist
// file see.c line 2390
signed int update_filelist(struct anonymous_2 *old, signed int lastline);
// usage
// file see.c line 2432
void usage(char *name);
// usebmk
// file see.c line 2448
void usebmk(struct _GtkTreeView *treeview, struct _GtkTreePath *treepath, struct _GtkTreeViewColumn *treecol, struct _GtkWidget *swin);
// utfadj
// file main.h line 184
signed int utfadj(char *buffer, signed int pos);
// watchfile
// file see.c line 2458
void watchfile();
// watchfile::1::func_object
//
signed int func_object();
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writeout
// file main.h line 185
char * writeout(char *buffer, char *file, signed int *ptr);

struct anonymous_16
{
  // txtfnt
  char *txtfnt;
  // width
  signed int width;
  // height
  signed int height;
  // wrap
  char wrap;
  // tbcolor
  const char *tbcolor;
  // bConfirm
  char bConfirm;
  // bRedirect
  char bRedirect;
  // watchtime
  signed int watchtime;
  // filelist
  char *filelist;
  // sock
  char sock[108l];
  // editor
  char *editor;
  // copyto
  char *copyto;
  // seedata
  char *seedata;
  // tailat
  signed int tailat;
};

struct anonymous_23
{
  // toplevel_under_pointer
  struct _GdkDrawable *toplevel_under_pointer;
  // window_under_pointer
  struct _GdkDrawable *window_under_pointer;
  // toplevel_x
  double toplevel_x;
  // toplevel_y
  double toplevel_y;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // motion_hint_serial
  unsigned long int motion_hint_serial;
};

struct anonymous_22
{
  // window
  struct _GdkDrawable *window;
  // native_window
  struct _GdkDrawable *native_window;
  // serial
  unsigned long int serial;
  // owner_events
  signed int owner_events;
  // time
  unsigned int time;
};

struct anonymous_25
{
  // hbx
  struct _GtkWidget *hbx;
  // back
  struct _GtkWidget *back;
  // current
  struct _GtkWidget *current;
  // forward
  struct _GtkWidget *forward;
  // select
  struct _GtkTreeSelection *select;
};

struct anonymous_26
{
  // wgt
  struct _GtkWidget *wgt;
  // image1
  struct _GtkWidget *image1;
  // image2
  struct _GtkWidget *image2;
  // sw
  signed int sw;
};

struct anonymous_2
{
  // path
  char path[4097l];
  // name
  char name[129l];
  // type
  char type;
  // sec
  char sec[17l];
};

struct anonymous_9
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_24
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

union anonymous_6
{
  // __data
  struct anonymous_9 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_8
{
  // cond
  union anonymous_6 cond;
  // lock
  union anonymous_7 lock;
  // data
  signed int data;
};

union anonymous_4
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GIOChannel
{
  // ref_count
  signed int ref_count;
  // funcs
  struct _GIOFuncs *funcs;
  // encoding
  char *encoding;
  // read_cd
  struct _GIConv *read_cd;
  // write_cd
  struct _GIConv *write_cd;
  // line_term
  char *line_term;
  // line_term_len
  unsigned int line_term_len;
  // buf_size
  unsigned long int buf_size;
  // read_buf
  struct _GString *read_buf;
  // encoded_read_buf
  struct _GString *encoded_read_buf;
  // write_buf
  struct _GString *write_buf;
  // partial_write_buf
  char partial_write_buf[6l];
  // use_buffer
  unsigned int use_buffer : 1;
  // do_encode
  unsigned int do_encode : 1;
  // close_on_unref
  unsigned int close_on_unref : 1;
  // is_readable
  unsigned int is_readable : 1;
  // is_writeable
  unsigned int is_writeable : 1;
  // is_seekable
  unsigned int is_seekable : 1;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
};

struct _GIOFuncs
{
  // io_read
  enum anonymous_41 (*io_read)(struct _GIOChannel *, char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_write
  enum anonymous_41 (*io_write)(struct _GIOChannel *, const char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_seek
  enum anonymous_41 (*io_seek)(struct _GIOChannel *, signed long int, enum anonymous_42, struct _GError **);
  // io_close
  enum anonymous_41 (*io_close)(struct _GIOChannel *, struct _GError **);
  // io_create_watch
  struct _GSource * (*io_create_watch)(struct _GIOChannel *, enum anonymous_43);
  // io_free
  void (*io_free)(struct _GIOChannel *);
  // io_set_flags
  enum anonymous_41 (*io_set_flags)(struct _GIOChannel *, enum anonymous_44, struct _GError **);
  // io_get_flags
  enum anonymous_44 (*io_get_flags)(struct _GIOChannel *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GSource
{
  // callback_data
  void *callback_data;
  // callback_funcs
  struct _GSourceCallbackFuncs *callback_funcs;
  // source_funcs
  const struct _GSourceFuncs *source_funcs;
  // ref_count
  unsigned int ref_count;
  // context
  struct _GMainContext *context;
  // priority
  signed int priority;
  // flags
  unsigned int flags;
  // source_id
  unsigned int source_id;
  // poll_fds
  struct _GSList *poll_fds;
  // prev
  struct _GSource *prev;
  // next
  struct _GSource *next;
  // name
  char *name;
  // priv
  struct _GSourcePrivate *priv;
};

struct _GSourceCallbackFuncs
{
  // ref
  void (*ref)(void *);
  // unref
  void (*unref)(void *);
  // get
  void (*get)(void *, struct _GSource *, signed int (**)(void *), void **);
};

struct _GSourceFuncs
{
  // prepare
  signed int (*prepare)(struct _GSource *, signed int *);
  // check
  signed int (*check)(struct _GSource *);
  // dispatch
  signed int (*dispatch)(struct _GSource *, signed int (*)(void *), void *);
  // finalize
  void (*finalize)(struct _GSource *);
  // closure_callback
  signed int (*closure_callback)(void *);
  // closure_marshal
  void (*closure_marshal)(void);
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous_4 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous_14 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous_20 source;
  // mode
  enum anonymous_21 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous_36 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous_0 modifiers;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkDisplay
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_events
  struct _GList *queued_events;
  // queued_tail
  struct _GList *queued_tail;
  // button_click_time
  unsigned int button_click_time[2l];
  // button_window
  struct _GdkDrawable *button_window[2l];
  // button_number
  signed int button_number[2l];
  // double_click_time
  unsigned int double_click_time;
  // core_pointer
  struct _GdkDevice *core_pointer;
  // pointer_hooks
  const struct _GdkDisplayPointerHooks *pointer_hooks;
  // closed
  unsigned int closed : 1;
  // ignore_core_events
  unsigned int ignore_core_events : 1;
  // double_click_distance
  unsigned int double_click_distance;
  // button_x
  signed int button_x[2l];
  // button_y
  signed int button_y[2l];
  // pointer_grabs
  struct _GList *pointer_grabs;
  // keyboard_grab
  struct anonymous_22 keyboard_grab;
  // pointer_info
  struct anonymous_23 pointer_info;
  // last_event_time
  unsigned int last_event_time;
};

struct _GdkDisplayPointerHooks
{
  // get_pointer
  void (*get_pointer)(struct _GdkDisplay *, struct _GdkScreen **, signed int *, signed int *, enum anonymous_0 *);
  // window_get_pointer
  struct _GdkDrawable * (*window_get_pointer)(struct _GdkDisplay *, struct _GdkDrawable *, signed int *, signed int *, enum anonymous_0 *);
  // window_at_pointer
  struct _GdkDrawable * (*window_at_pointer)(struct _GdkDisplay *, signed int *, signed int *);
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous_30 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous_10 actions;
  // suggested_action
  enum anonymous_10 suggested_action;
  // action
  enum anonymous_10 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkEventButton
{
  // type
  enum anonymous_40 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous_40 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous_40 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous_15 changed_mask;
  // new_window_state
  enum anonymous_15 new_window_state;
};

struct _GdkFont
{
  // type
  enum anonymous_12 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous_18 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous_19 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous_0 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous_0 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkCheckButton
{
  // toggle_button
  struct _GtkToggleButton toggle_button;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous_0 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkFrame
{
  // bin
  struct _GtkBin bin;
  // label_widget
  struct _GtkWidget *label_widget;
  // shadow_type
  signed short int shadow_type;
  // label_xalign
  float label_xalign;
  // label_yalign
  float label_yalign;
  // child_allocation
  struct _GdkRectangle child_allocation;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous_37 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenu
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
  // parent_menu_item
  struct _GtkWidget *parent_menu_item;
  // old_active_menu_item
  struct _GtkWidget *old_active_menu_item;
  // accel_group
  struct _GtkAccelGroup *accel_group;
  // accel_path
  char *accel_path;
  // position_func
  void (*position_func)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *);
  // position_func_data
  void *position_func_data;
  // toggle_size
  unsigned int toggle_size;
  // toplevel
  struct _GtkWidget *toplevel;
  // tearoff_window
  struct _GtkWidget *tearoff_window;
  // tearoff_hbox
  struct _GtkWidget *tearoff_hbox;
  // tearoff_scrollbar
  struct _GtkWidget *tearoff_scrollbar;
  // tearoff_adjustment
  struct _GtkAdjustment *tearoff_adjustment;
  // view_window
  struct _GdkDrawable *view_window;
  // bin_window
  struct _GdkDrawable *bin_window;
  // scroll_offset
  signed int scroll_offset;
  // saved_scroll_offset
  signed int saved_scroll_offset;
  // scroll_step
  signed int scroll_step;
  // timeout_id
  unsigned int timeout_id;
  // navigation_region
  struct _GdkRegion *navigation_region;
  // navigation_timeout
  unsigned int navigation_timeout;
  // needs_destruction_ref_count
  unsigned int needs_destruction_ref_count : 1;
  // torn_off
  unsigned int torn_off : 1;
  // tearoff_active
  unsigned int tearoff_active : 1;
  // scroll_fast
  unsigned int scroll_fast : 1;
  // upper_arrow_visible
  unsigned int upper_arrow_visible : 1;
  // lower_arrow_visible
  unsigned int lower_arrow_visible : 1;
  // upper_arrow_prelight
  unsigned int upper_arrow_prelight : 1;
  // lower_arrow_prelight
  unsigned int lower_arrow_prelight : 1;
};

struct _GtkProgress
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // offscreen_pixmap
  struct _GdkDrawable *offscreen_pixmap;
  // format
  char *format;
  // x_align
  float x_align;
  // y_align
  float y_align;
  // show_text
  unsigned int show_text : 1;
  // activity_mode
  unsigned int activity_mode : 1;
  // use_text_format
  unsigned int use_text_format : 1;
};

struct _GtkProgressBar
{
  // progress
  struct _GtkProgress progress;
  // bar_style
  enum anonymous_27 bar_style;
  // orientation
  enum anonymous_28 orientation;
  // blocks
  unsigned int blocks;
  // in_block
  signed int in_block;
  // activity_pos
  signed int activity_pos;
  // activity_step
  unsigned int activity_step;
  // activity_blocks
  unsigned int activity_blocks;
  // pulse_fraction
  double pulse_fraction;
  // activity_dir
  unsigned int activity_dir : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // dirty
  unsigned int dirty : 1;
};

struct _GtkRadioButton
{
  // check_button
  struct _GtkCheckButton check_button;
  // group
  struct _GSList *group;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous_13 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSelectionData
{
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // type
  struct _GdkAtom *type;
  // format
  signed int format;
  // data
  unsigned char *data;
  // length
  signed int length;
  // display
  struct _GdkDisplay *display;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTargetEntry
{
  // target
  char *target;
  // flags
  unsigned int flags;
  // info
  unsigned int info;
};

struct _GtkTextAppearance
{
  // bg_color
  struct _GdkColor bg_color;
  // fg_color
  struct _GdkColor fg_color;
  // bg_stipple
  struct _GdkDrawable *bg_stipple;
  // fg_stipple
  struct _GdkDrawable *fg_stipple;
  // rise
  signed int rise;
  // padding1
  void *padding1;
  // underline
  unsigned int underline : 4;
  // strikethrough
  unsigned int strikethrough : 1;
  // draw_bg
  unsigned int draw_bg : 1;
  // inside_selection
  unsigned int inside_selection : 1;
  // is_text
  unsigned int is_text : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextAttributes
{
  // refcount
  unsigned int refcount;
  // appearance
  struct _GtkTextAppearance appearance;
  // justification
  enum anonymous_32 justification;
  // direction
  enum anonymous_31 direction;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // left_margin
  signed int left_margin;
  // indent
  signed int indent;
  // right_margin
  signed int right_margin;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // tabs
  struct _PangoTabArray *tabs;
  // wrap_mode
  enum anonymous_3 wrap_mode;
  // language
  struct _PangoLanguage *language;
  // pg_bg_color
  struct _GdkColor *pg_bg_color;
  // invisible
  unsigned int invisible : 1;
  // bg_full_height
  unsigned int bg_full_height : 1;
  // editable
  unsigned int editable : 1;
  // realized
  unsigned int realized : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextBuffer
{
  // parent_instance
  struct _GObject parent_instance;
  // tag_table
  struct _GtkTextTagTable *tag_table;
  // btree
  struct _GtkTextBTree *btree;
  // clipboard_contents_buffers
  struct _GSList *clipboard_contents_buffers;
  // selection_clipboards
  struct _GSList *selection_clipboards;
  // log_attr_cache
  struct _GtkTextLogAttrCache *log_attr_cache;
  // user_action_count
  unsigned int user_action_count;
  // modified
  unsigned int modified : 1;
  // has_selection
  unsigned int has_selection : 1;
};

struct _GtkTextIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  signed int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  void *dummy9;
  // dummy10
  void *dummy10;
  // dummy11
  signed int dummy11;
  // dummy12
  signed int dummy12;
  // dummy13
  signed int dummy13;
  // dummy14
  void *dummy14;
};

struct _GtkTextMark
{
  // parent_instance
  struct _GObject parent_instance;
  // segment
  void *segment;
};

struct _GtkTextTag
{
  // parent_instance
  struct _GObject parent_instance;
  // table
  struct _GtkTextTagTable *table;
  // name
  char *name;
  // priority
  signed int priority;
  // values
  struct _GtkTextAttributes *values;
  // bg_color_set
  unsigned int bg_color_set : 1;
  // bg_stipple_set
  unsigned int bg_stipple_set : 1;
  // fg_color_set
  unsigned int fg_color_set : 1;
  // scale_set
  unsigned int scale_set : 1;
  // fg_stipple_set
  unsigned int fg_stipple_set : 1;
  // justification_set
  unsigned int justification_set : 1;
  // left_margin_set
  unsigned int left_margin_set : 1;
  // indent_set
  unsigned int indent_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // right_margin_set
  unsigned int right_margin_set : 1;
  // pixels_above_lines_set
  unsigned int pixels_above_lines_set : 1;
  // pixels_below_lines_set
  unsigned int pixels_below_lines_set : 1;
  // pixels_inside_wrap_set
  unsigned int pixels_inside_wrap_set : 1;
  // tabs_set
  unsigned int tabs_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // wrap_mode_set
  unsigned int wrap_mode_set : 1;
  // bg_full_height_set
  unsigned int bg_full_height_set : 1;
  // invisible_set
  unsigned int invisible_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // language_set
  unsigned int language_set : 1;
  // pg_bg_color_set
  unsigned int pg_bg_color_set : 1;
  // accumulative_margin
  unsigned int accumulative_margin : 1;
  // pad1
  unsigned int pad1 : 1;
};

struct _GtkTextTagTable
{
  // parent_instance
  struct _GObject parent_instance;
  // hash
  struct _GHashTable *hash;
  // anonymous
  struct _GSList *anonymous;
  // anon_count
  signed int anon_count;
  // buffers
  struct _GSList *buffers;
};

struct _GtkTextView
{
  // parent_instance
  struct _GtkContainer parent_instance;
  // layout
  struct _GtkTextLayout *layout;
  // buffer
  struct _GtkTextBuffer *buffer;
  // selection_drag_handler
  unsigned int selection_drag_handler;
  // scroll_timeout
  unsigned int scroll_timeout;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // wrap_mode
  enum anonymous_3 wrap_mode;
  // justify
  enum anonymous_32 justify;
  // left_margin
  signed int left_margin;
  // right_margin
  signed int right_margin;
  // indent
  signed int indent;
  // tabs
  struct _PangoTabArray *tabs;
  // editable
  unsigned int editable : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // accepts_tab
  unsigned int accepts_tab : 1;
  // width_changed
  unsigned int width_changed : 1;
  // onscreen_validated
  unsigned int onscreen_validated : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // text_window
  struct _GtkTextWindow *text_window;
  // left_window
  struct _GtkTextWindow *left_window;
  // right_window
  struct _GtkTextWindow *right_window;
  // top_window
  struct _GtkTextWindow *top_window;
  // bottom_window
  struct _GtkTextWindow *bottom_window;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xoffset
  signed int xoffset;
  // yoffset
  signed int yoffset;
  // width
  signed int width;
  // height
  signed int height;
  // virtual_cursor_x
  signed int virtual_cursor_x;
  // virtual_cursor_y
  signed int virtual_cursor_y;
  // first_para_mark
  struct _GtkTextMark *first_para_mark;
  // first_para_pixels
  signed int first_para_pixels;
  // dnd_mark
  struct _GtkTextMark *dnd_mark;
  // blink_timeout
  unsigned int blink_timeout;
  // first_validate_idle
  unsigned int first_validate_idle;
  // incremental_validate_idle
  unsigned int incremental_validate_idle;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // children
  struct _GSList *children;
  // pending_scroll
  struct _GtkTextPendingScroll *pending_scroll;
  // pending_place_cursor_button
  signed int pending_place_cursor_button;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // tree_view
  struct _GtkTreeView *tree_view;
  // type
  enum anonymous_34 type;
  // user_func
  signed int (*user_func)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *);
  // user_data
  void *user_data;
  // destroy
  void (*destroy)(void *);
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous_46 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous_37 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _PangoAttrClass
{
  // type
  enum anonymous_29 type;
  // copy
  struct _PangoAttribute * (*copy)(const struct _PangoAttribute *);
  // destroy
  void (*destroy)(struct _PangoAttribute *);
  // equal
  signed int (*equal)(const struct _PangoAttribute *, const struct _PangoAttribute *);
};

struct _PangoAttribute
{
  // klass
  const struct _PangoAttrClass *klass;
  // start_index
  unsigned int start_index;
  // end_index
  unsigned int end_index;
};

struct matchspec
{
  // bgn
  signed int bgn;
  // end
  signed int end;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// CaseTgl
// file see.c line 21
struct _GtkWidget *CaseTgl;
// Chist
// file see.c line 29
signed int Chist = 0;
// Config
// file see.c line 20
struct anonymous_16 *Config;
// CurFS
// file see.c line 29
signed int CurFS = 1;
// DND
// file see.c line 33
char DND = (char)0;
// Debug
// file see.c line 35
signed int Debug = 0;
// EXDline
// file util.c line 13
char *EXDline;
// Fent
// file see.c line 21
struct _GtkWidget *Fent;
// Fhist
// file see.c line 28
char **Fhist;
// FileCon
// file see.c line 28
char *FileCon = (char *)(void *)0;
// FindBT
// file see.c line 21
struct _GtkWidget *FindBT;
// Gio
// file server.c line 19
struct _GIOChannel *Gio = (struct _GIOChannel *)(void *)0;
// InitTL
// file server.c line 13
const struct anonymous_8 InitTL = { .cond={ .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } }, .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    .data=666 };
// LNsw
// file see.c line 34
signed int LNsw = 0;
// MMenu
// file see.c line 21
struct _GtkWidget *MMenu;
// MainWindow
// file see.c line 21
struct _GtkWidget *MainWindow;
// Me
// file util.c line 13
char Me[64l];
// Nbar
// file see.c line 23
struct anonymous_25 Nbar;
// SFsz
// file see.c line 29
signed int SFsz = 0;
// Scroll
// file see.c line 21
struct _GtkWidget *Scroll;
// Seefile
// file see.c line 19
struct anonymous_2 *Seefile;
// ServOff
// file see.c line 22
struct _GtkWidget *ServOff;
// ServOn
// file see.c line 22
struct _GtkWidget *ServOn;
// ServTgl
// file see.c line 22
struct _GtkWidget *ServTgl;
// Settitle
// file see.c line 33
char Settitle = (char)1;
// Sff
// file see.c line 18
struct anonymous_26 Sff;
// TF
// file see.c line 29
signed int TF[200000l];
// Tbuf
// file see.c line 24
struct _GtkTextBuffer *Tbuf;
// TxT
// file see.c line 21
struct _GtkWidget *TxT;
// bmk
// file see.c line 26
struct _GtkTextMark *bmk;
// boldblue
// file see.c line 27
struct _GtkTextTag *boldblue;
// bookmarks
// file see.c line 30
signed int *bookmarks = (signed int *)(void *)0;
// ctitle
// file see.c line 27
struct _GtkTextTag *ctitle;
// finish
// file see.c line 25
struct _GtkTextIter finish;
// histC
// file see.c line 29
signed int histC = 0;
// hlink
// file see.c line 27
struct _GtkTextTag *hlink;
// hlite
// file see.c line 27
struct _GtkTextTag *hlite;
// italred
// file see.c line 27
struct _GtkTextTag *italred;
// lnnm
// file see.c line 27
struct _GtkTextTag *lnnm;
// mainframe
// file see.c line 22
struct _GtkWidget *mainframe;
// norm
// file see.c line 27
struct _GtkTextTag *norm;
// numLbl
// file see.c line 21
struct _GtkWidget *numLbl;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pushTgl
// file see.c line 21
struct _GtkWidget *pushTgl;
// pushed
// file see.c line 27
struct _GtkTextTag *pushed;
// regxTgl
// file see.c line 21
struct _GtkWidget *regxTgl;
// rgxp
// file main.h line 95
struct matchspec rgxp;
// start
// file see.c line 25
struct _GtkTextIter start;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// textframe
// file see.c line 22
struct _GtkWidget *textframe;
// totalF
// file see.c line 29
signed int totalF = 0;
// watchSW
// file see.c line 34
signed int watchSW = 0;
// watchTgl
// file see.c line 22
struct _GtkWidget *watchTgl;
// watchoff
// file see.c line 22
struct _GtkWidget *watchoff;
// watchon
// file see.c line 22
struct _GtkWidget *watchon;
// wff
// file see.c line 18
struct anonymous_26 wff;

// DnDdrop
// file see.c line 656
signed int DnDdrop(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, unsigned int time, void **NA)
{
  struct _GdkAtom *target_type;
  if(Debug >= 3)
  {
    g_print("\tDnDdrop()\t");
    fflush(stdout);
  }

  if(!(context->targets == ((struct _GList *)NULL)))
  {
    void *return_value_g_list_nth_data_1;
    return_value_g_list_nth_data_1=g_list_nth_data(context->targets, (unsigned int)0);
    target_type = (struct _GdkAtom *)return_value_g_list_nth_data_1;
    gtk_drag_get_data(TxT, context, target_type, time);
  }

  else
    return 0;
  return (signed int)!(0 != 0);
}

// DnDleave
// file see.c line 677
void DnDleave(struct _GtkWidget *widget, struct _GdkDragContext *context, unsigned int time, void **NA)
{
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
  gtk_text_view_set_editable((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, 0);
  if(Debug >= 3)
  {
    g_print("\tDnDleave()\t");
    fflush(stdout);
  }

  DND = (char)0;
}

// DnDmotion
// file see.c line 684
signed int DnDmotion(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, struct _GtkSelectionData *seld, unsigned int ttype, unsigned int time, void **NA)
{
  if(!(DND == 0))
    return (signed int)!(0 != 0);

  else
  {
    if(Debug >= 3)
    {
      g_print("\tDnDmotion()\t");
      fflush(stdout);
    }

    unsigned long int return_value_gtk_text_view_get_type_1;
    return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
    gtk_text_view_set_editable((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, (signed int)!(0 != 0));
    DND = (char)1;
    return (signed int)!(0 != 0);
  }
}

// DnDreceive
// file see.c line 694
void DnDreceive(struct _GtkWidget *widget, struct _GdkDragContext *context, signed int x, signed int y, struct _GtkSelectionData *data, unsigned int ttype, unsigned int time, void **NA)
{
  signed int got = (signed int)!(0 != 0);
  char *ptr = (char *)data->data;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(ptr == ((char *)NULL))
    gtk_drag_finish(context, 0, 0, time);

  else
  {
    if(Debug >= 2)
      fprintf(stderr, "\nDnDrecieve() \"%s\"\n", ptr);

    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(ptr, "file:///", (unsigned long int)8);
    if(!(return_value_strncmp_1 == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strlen_2=strlen(ptr);
      tmp_if_expr_3 = return_value_strlen_2 > (unsigned long int)4096 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      got = 0;

    gtk_drag_finish(context, got, 0, time);
    if(!(got == 0))
    {
      ptr = ptr + (signed long int)((unsigned long int)7 * sizeof(char) /*1ul*/ );
      ptr=defluff(ptr);
      loadnew(ptr, (char *)(void *)0, 0);
      free((void *)ptr);
    }

  }
}

// FentKpress
// file see.c line 879
signed int FentKpress(struct _GtkWidget *widget, struct _GdkEventKey *kyprs, void **data)
{
  unsigned long int return_value_gtk_entry_get_type_1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_entry_get_type_5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  switch(kyprs->keyval)
  {
    case (unsigned int)0xff52:
    {
      if(histC == 0)
        return (signed int)!(0 != 0);

      if(!(Chist >= 1))
        Chist = histC - 1;

      else
        Chist = Chist - 1;
      return_value_gtk_entry_get_type_1=gtk_entry_get_type();
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2, Fhist[(signed long int)Chist]);
      return (signed int)!(0 != 0);
    }
    case (unsigned int)0xff54:
    {
      if(histC == 0)
        return (signed int)!(0 != 0);

      Chist = Chist + 1;
      if(Chist >= histC)
      {
        unsigned long int return_value_gtk_entry_get_type_3;
        return_value_gtk_entry_get_type_3=gtk_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
        return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_3);
        gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_4, "");
        Chist = -1;
        return (signed int)!(0 != 0);
      }

      return_value_gtk_entry_get_type_5=gtk_entry_get_type();
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_5);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_6, Fhist[(signed long int)Chist]);
      return (signed int)!(0 != 0);
    }
    case (unsigned int)0xff0d:
    {
      searchlight();
      return (signed int)!(0 != 0);
    }
    default:
      return 0;
  }
  return 0;
}

// SFcopy
// file see.c line 2118
struct anonymous_2 * SFcopy(struct anonymous_2 *orig)
{
  struct anonymous_2 *r;
  void *return_value_ec_malloc_1;
  return_value_ec_malloc_1=ec_malloc(sizeof(struct anonymous_2) /*4244ul*/ );
  r = (struct anonymous_2 *)return_value_ec_malloc_1;
  memcpy((void *)r, (const void *)orig, sizeof(struct anonymous_2) /*4244ul*/ );
  return r;
}

// TxTKpress
// file see.c line 2337
signed int TxTKpress(struct _GtkWidget *widget, struct _GdkEventKey *kyprs, void **data)
{
  signed int ln;
  signed int nofl;
  signed int lend;
  signed int lffs;
  struct _GtkTextMark *curpos;
  struct _GtkTextIter from;
  struct _GtkTextIter moveto;
  _Bool tmp_if_expr_1;
  switch(kyprs->keyval)
  {
    case (unsigned int)0xff50:
      if(kyprs->state == 4u)
      {
        scrolltoline((struct _GtkWidget *)(void *)0, 1);
        return (signed int)!(0 != 0);
      }

      else
        return 0;
    case (unsigned int)0xff57:
    {
      if(!(FileCon == ((char *)NULL)))
        tmp_if_expr_1 = kyprs->state == (unsigned int)GDK_CONTROL_MASK ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        nofl=buflen(FileCon);
        scrolltoline((struct _GtkWidget *)(void *)0, nofl - 1);
        return (signed int)!(0 != 0);
      }

      else
        return 0;
    }
    case (unsigned int)0xff51:
      if(kyprs->state == 8u)
      {
        curpos=gtk_text_buffer_get_insert(Tbuf);
        gtk_text_buffer_get_iter_at_mark(Tbuf, &from, curpos);
        ln=gtk_text_iter_get_line(&from);
        gtk_text_buffer_get_iter_at_line(Tbuf, &moveto, ln);
        gtk_text_buffer_place_cursor(Tbuf, &moveto);
        gtk_text_view_scroll_to_iter((struct _GtkTextView *)TxT, &moveto, (double)0, 0, (double)0, (double)0);
        return (signed int)!(0 != 0);
      }

      else
        return 0;
    case (unsigned int)0xff53:
      if(kyprs->state == 8u)
      {
        curpos=gtk_text_buffer_get_insert(Tbuf);
        gtk_text_buffer_get_iter_at_mark(Tbuf, &from, curpos);
        signed int return_value_gtk_text_iter_get_chars_in_line_2;
        return_value_gtk_text_iter_get_chars_in_line_2=gtk_text_iter_get_chars_in_line(&from);
        lend = return_value_gtk_text_iter_get_chars_in_line_2 - 1;
        lffs=gtk_text_iter_get_line_offset(&from);
        ln=gtk_text_iter_get_line(&from);
        if(!(lend >= 27 + lffs))
          gtk_text_buffer_get_iter_at_line_offset(Tbuf, &moveto, ln, lend);

        else
        {
          lffs = lffs + 27;
          gtk_text_buffer_get_iter_at_line_offset(Tbuf, &moveto, ln, lffs);
        }
        gtk_text_buffer_place_cursor(Tbuf, &moveto);
        gtk_text_view_scroll_to_iter((struct _GtkTextView *)TxT, &moveto, (double)0, 0, (double)0, (double)0);
        return (signed int)!(0 != 0);
      }

      else
        return 0;
    default:
      return 0;
  }
}

// addtohistory
// file see.c line 357
void addtohistory(char *line)
{
  signed int i = 0;
  for( ; !(i >= histC); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(Fhist[(signed long int)i], line);
    if(return_value_strcmp_1 == 0)
    {
      Chist = i;
      goto __CPROVER_DUMP_L5;
    }

  }
  void *return_value_realloc_2;
  return_value_realloc_2=realloc((void *)Fhist, (unsigned long int)(histC + 1) * sizeof(char *) /*8ul*/ );
  Fhist = (char **)return_value_realloc_2;
  if(Fhist == ((char **)NULL))
  {
    error_popup("WARNING: Out of memory");
    exit(30);
  }

  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(line);
  void *return_value_ec_malloc_4;
  return_value_ec_malloc_4=ec_malloc(return_value_strlen_3 + (unsigned long int)1);
  Fhist[(signed long int)histC] = (char *)return_value_ec_malloc_4;
  strcpy(Fhist[(signed long int)histC], line);
  histC = histC + 1;
  Chist = histC;

__CPROVER_DUMP_L5:
  ;
}

// applytag
// file see.c line 420
void applytag(signed int Ts, signed int Te, char *tag)
{
  struct _GtkTextIter tagS;
  struct _GtkTextIter tagE;
  if(Debug >= 1)
    g_print("applytag()...");

  gtk_text_buffer_get_iter_at_offset(Tbuf, &tagS, Ts);
  gtk_text_buffer_get_iter_at_offset(Tbuf, &tagE, Te);
  gtk_text_buffer_apply_tag_by_name(Tbuf, tag, &tagS, &tagE);
}

// apropos
// file see.c line 378
void apropos()
{
  char *string;
  char *tok;
  const char *term;
  unsigned long int return_value_gtk_entry_get_type_1;
  return_value_gtk_entry_get_type_1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
  term=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2);
  signed int len;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(term);
  len = (signed int)return_value_strlen_3;
  struct _IO_FILE *fstIN;
  struct _GtkTextIter end;
  struct _GdkCursor *hand;
  hand=gdk_cursor_new((enum anonymous_14)GDK_HAND2);
  if(!(len == 0))
  {
    void *return_value_ec_malloc_4;
    return_value_ec_malloc_4=ec_malloc((unsigned long int)(len + 23));
    string = (char *)return_value_ec_malloc_4;
    sprintf(string, "Apropos search for \"%s\"?", term);
    signed int return_value_confirm_popup_5;
    return_value_confirm_popup_5=confirm_popup("Confirm", string);
    if(return_value_confirm_popup_5 == -6)
      free((void *)string);

    else
    {
      free((void *)string);
      addtohistory((char *)term);
      void *return_value_ec_malloc_6;
      return_value_ec_malloc_6=ec_malloc((unsigned long int)(len + 11));
      string = (char *)return_value_ec_malloc_6;
      sprintf(string, "apropos \"%s\"", term);
      fstIN=popen(string, "r");
      if(fstIN == ((struct _IO_FILE *)NULL))
      {
        free((void *)string);
        error_popup("apropos failed");
      }

      else
      {
        free((void *)string);
        clear(1);
        gtk_text_buffer_get_end_iter(Tbuf, &end);
        do
        {
          string=linein(fstIN);
          if(string == ((char *)NULL))
            break;

          tok=strtok(string, " ");
          gtk_text_buffer_insert_with_tags(Tbuf, &end, (const char *)tok, -1, hlink, (void *)0);
          tok=strtok((char *)(void *)0, " ");
          gtk_text_buffer_insert_with_tags(Tbuf, &end, (const char *)tok, -1, lnnm, (void *)0);
          tok=strtok((char *)(void *)0, "");
          gtk_text_buffer_insert(Tbuf, &end, (const char *)tok, -1);
          free((void *)string);
        }
        while((_Bool)1);
        signed int return_value_pclose_7;
        return_value_pclose_7=pclose(fstIN);
        if(!(return_value_pclose_7 == 0))
          error_popup("pclose fail in apropos()");

        unsigned long int return_value_gtk_text_view_get_type_8;
        return_value_gtk_text_view_get_type_8=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
        return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_8);
        struct _GdkDrawable *return_value_gtk_text_view_get_window_10;
        return_value_gtk_text_view_get_window_10=gtk_text_view_get_window((struct _GtkTextView *)return_value_g_type_check_instance_cast_9, (enum anonymous)GTK_TEXT_WINDOW_TEXT);
        gdk_window_set_cursor(return_value_gtk_text_view_get_window_10, hand);
        gdk_cursor_unref(hand);
      }
    }
  }

}

// blinktoggle
// file see.c line 429
signed int blinktoggle(struct anonymous_26 *ff)
{
  if(ff->sw == 0)
  {
    unsigned long int return_value_gtk_container_get_type_1;
    return_value_gtk_container_get_type_1=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)ff->wgt, return_value_gtk_container_get_type_1);
    gtk_container_remove((struct _GtkContainer *)return_value_g_type_check_instance_cast_2, ff->image1);
    unsigned long int return_value_gtk_container_get_type_3;
    return_value_gtk_container_get_type_3=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)ff->wgt, return_value_gtk_container_get_type_3);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_4, ff->image2);
    ff->sw = 1;
  }

  else
  {
    unsigned long int return_value_gtk_container_get_type_5;
    return_value_gtk_container_get_type_5=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)ff->wgt, return_value_gtk_container_get_type_5);
    gtk_container_remove((struct _GtkContainer *)return_value_g_type_check_instance_cast_6, ff->image2);
    unsigned long int return_value_gtk_container_get_type_7;
    return_value_gtk_container_get_type_7=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)ff->wgt, return_value_gtk_container_get_type_7);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_8, ff->image1);
    ff->sw = 0;
  }
  return (signed int)!(0 != 0);
}

// bookmark_list
// file see.c line 442
void bookmark_list()
{
  signed int i;
  signed int ii;
  struct _GtkListStore *liststore;
  liststore=gtk_list_store_new(2, (unsigned long int)(6 << 2), (unsigned long int)(16 << 2));
  struct _GtkWidget *subwin;
  subwin=gtk_window_new((enum anonymous_5)GTK_WINDOW_POPUP);
  struct _GtkWidget *bmkLV;
  unsigned long int return_value_gtk_tree_model_get_type_1;
  return_value_gtk_tree_model_get_type_1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)liststore, return_value_gtk_tree_model_get_type_1);
  bmkLV=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_2);
  struct _GtkWidget *frame;
  frame=gtk_frame_new("Bookmarks");
  struct _GtkWidget *flab;
  unsigned long int return_value_gtk_frame_get_type_3;
  return_value_gtk_frame_get_type_3=gtk_frame_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_frame_get_type_3);
  flab=gtk_frame_get_label_widget((struct _GtkFrame *)return_value_g_type_check_instance_cast_4);
  struct _GtkWidget *BMVbox;
  BMVbox=gtk_vbox_new(0, 4);
  struct _GtkWidget *BMHbox;
  BMHbox=gtk_hbox_new(0, 4);
  struct _GtkWidget *DisBT;
  DisBT=gtk_button_new_with_label("Dismiss");
  struct _GtkCellRenderer *render;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeIter Litr;
  struct _PangoAttrList *atrb;
  atrb=pango_attr_list_new();
  struct _PangoAttribute *ubold;
  ubold=pango_attr_weight_new((enum anonymous_38)PANGO_WEIGHT_ULTRABOLD);
  char *ptr;
  char snippet[32l];
  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    if(Debug >= 1)
      g_print("bookmark_list() %d...\n", bookmarks[(signed long int)0]);

    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_window_get_type_5);
    unsigned long int return_value_gtk_window_get_type_7;
    return_value_gtk_window_get_type_7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_7);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (struct _GtkWindow *)return_value_g_type_check_instance_cast_8);
    unsigned long int return_value_gtk_window_get_type_9;
    return_value_gtk_window_get_type_9=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
    return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_window_get_type_9);
    gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_10, (enum anonymous_35)GTK_WIN_POS_CENTER_ON_PARENT);
    unsigned long int return_value_gtk_container_get_type_11;
    return_value_gtk_container_get_type_11=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
    return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_container_get_type_11);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_12, frame);
    unsigned long int return_value_gtk_container_get_type_13;
    return_value_gtk_container_get_type_13=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
    return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_13);
    gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_14, (unsigned int)4);
    unsigned long int return_value_gtk_container_get_type_15;
    return_value_gtk_container_get_type_15=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_15);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_16, BMVbox);
    ubold->start_index = (unsigned int)0;
    ubold->end_index = (unsigned int)10;
    pango_attr_list_insert(atrb, ubold);
    unsigned long int return_value_gtk_label_get_type_17;
    return_value_gtk_label_get_type_17=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
    return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)flab, return_value_gtk_label_get_type_17);
    gtk_label_set_attributes((struct _GtkLabel *)return_value_g_type_check_instance_cast_18, atrb);
    unsigned long int return_value_gtk_box_get_type_19;
    return_value_gtk_box_get_type_19=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
    return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)BMVbox, return_value_gtk_box_get_type_19);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_20, bmkLV, 0, 0, (unsigned int)4);
    unsigned long int return_value_gtk_tree_view_get_type_21;
    return_value_gtk_tree_view_get_type_21=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
    return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)bmkLV, return_value_gtk_tree_view_get_type_21);
    gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_22, 0);
    unsigned long int return_value_gtk_tree_view_get_type_23;
    return_value_gtk_tree_view_get_type_23=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
    return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)bmkLV, return_value_gtk_tree_view_get_type_23);
    gtk_tree_view_set_rules_hint((struct _GtkTreeView *)return_value_g_type_check_instance_cast_24, (signed int)!(0 != 0));
    render=gtk_cell_renderer_text_new();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
    return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)render, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast_25, "foreground", (const void *)"Red", (const void *)"foreground-set", !(0 != 0), (void *)0);
    column=gtk_tree_view_column_new_with_attributes("LN", render, (const void *)"text", 0, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type_26;
    return_value_gtk_tree_view_get_type_26=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
    return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)bmkLV, return_value_gtk_tree_view_get_type_26);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_27, column);
    render=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("text", render, (const void *)"text", 1, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type_28;
    return_value_gtk_tree_view_get_type_28=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
    return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)bmkLV, return_value_gtk_tree_view_get_type_28);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_29, column);
    g_signal_connect_data((void *)bmkLV, "row-activated", (void (*)(void))usebmk, (void *)subwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    g_signal_connect_data((void *)bmkLV, "button-press-event", (void (*)(void))delbmk, (void *)liststore, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    unsigned long int return_value_gtk_box_get_type_30;
    return_value_gtk_box_get_type_30=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
    return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)BMVbox, return_value_gtk_box_get_type_30);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_31, BMHbox, 0, 0, (unsigned int)4);
    unsigned long int return_value_gtk_box_get_type_32;
    return_value_gtk_box_get_type_32=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
    return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)BMHbox, return_value_gtk_box_get_type_32);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_33, DisBT, 0, 0, (unsigned int)4);
    g_signal_connect_data((void *)DisBT, "clicked", (void (*)(void))destroy_widget, (void *)subwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    if(*bookmarks >= 2)
      sortintray(&bookmarks[(signed long int)1], bookmarks[(signed long int)0]);

    i = 1;
    for( ; *bookmarks >= i; i = i + 1)
      if(!(bookmarks[(signed long int)i] == 0))
      {
        ptr=textline(bookmarks[(signed long int)i]);
        if(ptr == ((char *)NULL))
          sprintf(snippet, "LINE NUMBER INVALID");

        else
        {
          ii = 0;
          for( ; !(ii >= 31); ii = ii + 1)
            snippet[(signed long int)ii] = ptr[(signed long int)ii];
        }
        snippet[(signed long int)ii] = (char)0;
        if(Debug >= 2)
          g_print("\tsnippet=\"%s\"", (const void *)snippet);

        gtk_list_store_append(liststore, &Litr);
        gtk_list_store_set(liststore, &Litr, 0, bookmarks[(signed long int)i], 1, (const void *)snippet, -1);
      }

    gtk_widget_show_all(subwin);
  }

}

// buflen
// file main.h line 170
signed int buflen(char *buffer)
{
  signed int blen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buffer);
  blen = (signed int)return_value_strlen_1;
  signed int NofL = 0;
  signed int i;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(buffer == ((char *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; blen >= i; i = i + 1)
    {
      if((signed int)buffer[(signed long int)i] == 10)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if((signed int)buffer[(signed long int)i] == 0)
          tmp_if_expr_2 = (signed int)buffer[(signed long int)(i - 1)] != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        NofL = NofL + 1;

    }
    return NofL;
  }
}

// changewrapmode
// file see.c line 507
void changewrapmode(struct _GtkWidget *RButton, char mode)
{
  enum anonymous_3 macro;
  switch((signed int)mode)
  {
    case 87:
    {
      macro = (enum anonymous_3)GTK_WRAP_WORD;
      break;
    }
    case 69:
    {
      macro = (enum anonymous_3)GTK_WRAP_CHAR;
      break;
    }
    default:
      macro = (enum anonymous_3)GTK_WRAP_NONE;
  }
  if(!(RButton == ((struct _GtkWidget *)NULL)))
    Config->wrap = mode;

  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
  gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, macro);
}

// check_seesock
// file main.h line 188
signed int check_seesock()
{
  char buf[16l];
  signed int remote;
  signed int err = 0;
  if(!(Debug == 0))
    g_print("check_seesocket()...\n");

  signed int return_value_file_check_1;
  return_value_file_check_1=file_check(Config->sock);
  if(!(return_value_file_check_1 == -2))
  {
    if(return_value_file_check_1 == 0)
      goto __CPROVER_DUMP_L3;

    if(return_value_file_check_1 == 49152)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    return 0;

  __CPROVER_DUMP_L3:
    ;
    puts("Abnormal output from stat on seesocket");
    return -66;

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L8;
  }
  signed int return_value_unlink_2;
  return_value_unlink_2=unlink(Config->sock);
  if(!(return_value_unlink_2 >= 0))
    return -11;

  else
    return 0;

__CPROVER_DUMP_L8:
  ;
  if(!(Debug == 0))
    g_print("Socket exists!\n");

  remote=loclcon(Config->sock);
  signed int *return_value___errno_location_4;
  if(!(remote == 0))
  {
    write(remote, (const void *)"XOSEESOX\n", (unsigned long int)9);
    getMsg(remote, buf, 16);
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(buf, "XOSEESOX", (unsigned long int)8);
    if(return_value_strncmp_3 == 0)
    {
      puts("See server running");
      close(remote);
      return -1;
    }

  }

  else
  {
    return_value___errno_location_4=__errno_location();
    err = *return_value___errno_location_4;
  }
  if(!(remote == 0))
    close(remote);

  char *return_value_strerror_5;
  if(Debug >= 2)
  {
    fprintf(stderr, "(no connect) err=%d\n", err);
    if(!(err == 0))
    {
      return_value_strerror_5=strerror(err);
      fprintf(stderr, "%s\n", return_value_strerror_5);
    }

  }

  signed int return_value_unlink_6;
  return_value_unlink_6=unlink(Config->sock);
  if(!(return_value_unlink_6 >= 0))
    return -11;

  else
    return 0;
}

// clear
// file see.c line 525
void clear(signed int opt)
{
  gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
  gtk_text_buffer_delete(Tbuf, &start, &finish);
  if(!(FileCon == ((char *)NULL)))
  {
    free((void *)FileCon);
    FileCon = (char *)(void *)0;
  }

  if(!(Seefile == ((struct anonymous_2 *)NULL)) && !(opt == 0))
  {
    free((void *)Seefile);
    Seefile = (struct anonymous_2 *)(void *)0;
  }

  if(!(bookmarks == ((signed int *)NULL)))
  {
    free((void *)bookmarks);
    bookmarks = (signed int *)(void *)0;
  }

  SFsz = 0;
  LNsw = 0;
  unsigned long int return_value_gtk_button_get_type_1;
  return_value_gtk_button_get_type_1=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.current, return_value_gtk_button_get_type_1);
  gtk_button_set_label((struct _GtkButton *)return_value_g_type_check_instance_cast_2, "");
  if(Debug >= 1)
  {
    g_print("clear(%d) done\n", opt);
    fflush(stdout);
  }

}

// closeFL_window
// file see.c line 551
void closeFL_window(struct _GtkWidget *ignored, void **sbwin)
{
  unsigned long int return_value_gtk_widget_get_type_1;
  return_value_gtk_widget_get_type_1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_widget_get_type_1);
  gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast_2);
  Nbar.select = (struct _GtkTreeSelection *)(void *)0;
}

// confirm_popup
// file see.c line 557
signed int confirm_popup(char *title, char *messg)
{
  signed int respv;
  struct _GtkWidget *textLbl;
  struct _GtkWidget *dialgBx;
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
  dialgBx=gtk_dialog_new_with_buttons(title, (struct _GtkWindow *)return_value_g_type_check_instance_cast_2, (enum anonymous_45)GTK_DIALOG_NO_SEPARATOR, "gtk-cancel", -6, (const void *)"gtk-ok", -5, (void *)0);
  unsigned long int return_value_gtk_window_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  if(!(Settitle == 0))
  {
    return_value_gtk_window_get_type_3=gtk_window_get_type();
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_3);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, "Waiting for confirmation");
  }

  unsigned long int return_value_gtk_window_get_type_5;
  return_value_gtk_window_get_type_5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)dialgBx, return_value_gtk_window_get_type_5);
  gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (enum anonymous_35)GTK_WIN_POS_CENTER_ON_PARENT);
  textLbl=gtk_label_new_with_mnemonic(messg);
  unsigned long int return_value_gtk_label_get_type_7;
  return_value_gtk_label_get_type_7=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)textLbl, return_value_gtk_label_get_type_7);
  gtk_label_set_justify((struct _GtkLabel *)return_value_g_type_check_instance_cast_8, (enum anonymous_32)GTK_JUSTIFY_CENTER);
  unsigned long int return_value_gtk_dialog_get_type_9;
  return_value_gtk_dialog_get_type_9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)dialgBx, return_value_gtk_dialog_get_type_9);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkDialog *)return_value_g_type_check_instance_cast_10)->vbox, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, textLbl, 0, 0, (unsigned int)0);
  gtk_widget_show(textLbl);
  unsigned long int return_value_gtk_dialog_get_type_13;
  return_value_gtk_dialog_get_type_13=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)dialgBx, return_value_gtk_dialog_get_type_13);
  respv=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_14);
  gtk_widget_destroy(dialgBx);
  unsigned long int return_value_gtk_window_get_type_15;
  return_value_gtk_window_get_type_15=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_15);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_16, "...okay");
  return respv;
}

// copytmp
// file main.h line 171
signed int copytmp(char *tmp, char *perm)
{
  signed int retv = 0;
  char *line;
  struct _IO_FILE *fstRO;
  struct _IO_FILE *fstW;
  fstRO=fopen(tmp, "r");
  if(fstRO == ((struct _IO_FILE *)NULL))
    return -4;

  else
  {
    fstW=fopen(perm, "w");
    if(fstW == ((struct _IO_FILE *)NULL))
    {
      fclose(fstRO);
      return -5;
    }

    else
    {
      do
      {
        line=linein(fstRO);
        if(line == ((char *)NULL))
          break;

        fprintf(fstW, "%s", line);
        free((void *)line);
      }
      while((_Bool)1);
      signed int return_value_fclose_1;
      return_value_fclose_1=fclose(fstRO);
      if(!(return_value_fclose_1 == 0))
        retv = -1;

      signed int return_value_fclose_2;
      return_value_fclose_2=fclose(fstW);
      if(!(return_value_fclose_2 == 0))
        retv = retv - 2;

      signed int return_value_unlink_3;
      return_value_unlink_3=unlink(tmp);
      if(!(return_value_unlink_3 >= 0))
        retv = retv - 10;

      return retv;
    }
  }
}

// copytoX
// file see.c line 574
void copytoX(struct _GtkWidget *ignored, signed int opt)
{
  struct _GdkDisplay *display;
  display=gdk_display_get_default();
  struct _GtkClipboard *clipboard;
  clipboard=gtk_clipboard_get_for_display(display, (struct _GdkAtom *)(void *)(unsigned long int)69);
  if(!(opt == 0))
  {
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    gtk_text_buffer_select_range(Tbuf, (const struct _GtkTextIter *)&start, (const struct _GtkTextIter *)&finish);
  }

  gtk_text_buffer_copy_clipboard(Tbuf, clipboard);
}

// cursor_tofound
// file see.c line 583
void cursor_tofound(struct _GtkWidget *widget, signed int way)
{
  signed int oset;
  signed int i;
  signed int sw = 0;
  struct _GtkTextMark *mk;
  mk=gtk_text_buffer_get_insert(Tbuf);
  struct _GtkTextIter itr;
  if(!(totalF == 0))
  {
    gtk_widget_grab_focus(TxT);
    gtk_text_buffer_get_iter_at_mark(Tbuf, &itr, mk);
    if(LNsw == 1)
    {
      numberlines();
      sw = 1;
    }

    oset=gtk_text_iter_get_offset(&itr);
    if(way == 0)
    {
      i = 0;
      for( ; 2 * totalF + -1 >= i; i = i + 2)
        if(!(oset >= TF[(signed long int)i]))
        {
          gtk_text_buffer_get_iter_at_offset(Tbuf, &itr, TF[(signed long int)i]);
          gtk_text_buffer_place_cursor(Tbuf, &itr);
          unsigned long int return_value_gtk_text_view_get_type_1;
          return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
          return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
          gtk_text_view_scroll_to_iter((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, &itr, 0.0, (signed int)!(0 != 0), 0.5, 0.5);
          break;
        }

    }

    else
    {
      i = totalF * 2 - 1;
      for( ; i >= 0; i = i - 2)
        if(!(TF[(signed long int)i] >= oset))
        {
          gtk_text_buffer_get_iter_at_offset(Tbuf, &itr, TF[(signed long int)i]);
          gtk_text_buffer_place_cursor(Tbuf, &itr);
          unsigned long int return_value_gtk_text_view_get_type_3;
          return_value_gtk_text_view_get_type_3=gtk_text_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
          return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_3);
          gtk_text_view_scroll_to_iter((struct _GtkTextView *)return_value_g_type_check_instance_cast_4, &itr, 0.0, (signed int)!(0 != 0), 0.5, 0.5);
          break;
        }

    }
    if(sw == 1)
      numberlines();

  }

}

// cursorline
// file see.c line 621
signed int cursorline()
{
  struct _GtkTextIter where;
  signed int pos;
  signed int line;
  g_object_get((void *)Tbuf, "cursor-position", &pos, (void *)0);
  gtk_text_buffer_get_iter_at_offset(Tbuf, &where, pos);
  line=gtk_text_iter_get_line(&where);
  return line;
}

// defluff
// file main.h line 172
char * defluff(char *string)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed int)return_value_strlen_1;
  signed int i;
  char *new_line;
  void *return_value_ec_malloc_2;
  return_value_ec_malloc_2=ec_malloc((unsigned long int)(len + 1));
  new_line = (char *)return_value_ec_malloc_2;
  if(Debug >= 3)
    g_print("defluff() ++%s++\n", string);

  strcpy(new_line, string);
  i = 0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  for( ; !(i >= len); i = i + 1)
  {
    if((signed int)new_line[(signed long int)i] == 32)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)new_line[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)new_line[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      new_line[(signed long int)i] = (char)0;
      break;
    }

  }
  return new_line;
}

// delbmk
// file see.c line 633
signed int delbmk(struct _GtkWidget *treeview, struct _GdkEventButton *MoBt, struct _GtkListStore *liststore)
{
  struct _GtkTreeIter itr;
  struct _GtkTreeModel *Tmod;
  unsigned long int return_value_gtk_tree_view_get_type_1;
  return_value_gtk_tree_view_get_type_1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type_1);
  Tmod=gtk_tree_view_get_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast_2);
  struct _GtkTreeSelection *selected;
  unsigned long int return_value_gtk_tree_view_get_type_3;
  return_value_gtk_tree_view_get_type_3=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type_3);
  selected=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_4);
  signed int ln;
  signed int i;
  if(MoBt->button == 2u)
  {
    gtk_tree_selection_get_selected(selected, &Tmod, &itr);
    gtk_tree_model_get(Tmod, &itr, 0, &ln, -1);
    i = 1;
    for( ; *bookmarks >= i; i = i + 1)
      if(bookmarks[(signed long int)i] == ln)
      {
        bookmarks[(signed long int)i] = 0;
        bookmarks[(signed long int)0] = bookmarks[(signed long int)0] - 1;
        break;
      }

    gtk_list_store_set(liststore, &itr, 0, 0, -1);
    gtk_list_store_set(liststore, &itr, 1, (const void *)"", -1);
    savebmks((struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0);
    return (signed int)!(0 != 0);
  }

  else
    return 0;
}

// destroy_widget
// file see.c line 651
void destroy_widget(struct _GtkWidget *widget, struct _GtkWidget *dead)
{
  gtk_widget_destroy(dead);
}

// dobmks
// file see.c line 716
void dobmks()
{
  signed int Ts;
  signed int Te;
  signed int i = 1;
  signed int type;
  char tmpname[5120l];
  char *line = (char *)(void *)0;
  char *tok;
  char messg[5120l];
  char DL[3l] = { '*', '\n', 0 };
  if((signed int)Seefile->type == 82)
    line=returnline(Config->seedata, Seefile->path);

  else
  {
    sprintf(tmpname, "%s(%s)", (const void *)Seefile->path, (const void *)Seefile->sec);
    line=returnline(Config->seedata, tmpname);
  }
  if(!(line == ((char *)NULL)))
  {
    tok=strtok(line, DL);
    if((signed int)*tok == 48)
    {
      void *return_value_ec_malloc_1;
      return_value_ec_malloc_1=ec_malloc(sizeof(signed int) /*4ul*/ );
      bookmarks = (signed int *)return_value_ec_malloc_1;
      bookmarks[(signed long int)0] = 0;
      tok=strtok((char *)(void *)0, DL);
      if(tok == ((char *)NULL))
        goto __CPROVER_DUMP_L24;

    }

    else
    {
      signed int return_value_atoi_2;
      return_value_atoi_2=atoi(tok);
      void *return_value_ec_malloc_3;
      return_value_ec_malloc_3=ec_malloc((unsigned long int)(return_value_atoi_2 + 1));
      bookmarks = (signed int *)return_value_ec_malloc_3;
      bookmarks[(signed long int)0]=atoi(tok);
      do
      {
        tok=strtok((char *)(void *)0, DL);
        if(tok == ((char *)NULL))
          break;

        if((signed int)*tok == 82)
          break;

        if((signed int)*tok == 66)
          break;

        bookmarks[(signed long int)i]=atoi(tok);
        if(Debug >= 2)
          g_print("domks() #=%d i=%d bm=%d\n", bookmarks[(signed long int)0], i, bookmarks[(signed long int)i]);

        i = i + 1;
      }
      while((_Bool)1);
      if(tok == ((char *)NULL))
        goto __CPROVER_DUMP_L24;

    }
    if((signed int)*tok == 82)
      type = 0;

    else
      if((signed int)*tok == 66)
        type = 1;

      else
      {
        sprintf(messg, "Corrupted entry in\n%s!", Config->seedata);
        error_popup(messg);
        goto __CPROVER_DUMP_L24;
      }
    do
    {
      tok=strtok((char *)(void *)0, DL);
      if(tok == ((char *)NULL))
        break;

      if((signed int)*tok == 82)
        type = 0;

      else
        if((signed int)*tok == 66)
          type = 1;

        else
        {
          Ts=atoi(tok);
          char *return_value_strtok_4;
          return_value_strtok_4=strtok((char *)(void *)0, DL);
          Te=atoi(return_value_strtok_4);
          if(Te == 0)
            goto __CPROVER_DUMP_L24;

          if(type == 1)
            applytag(Ts, Te, "boldblue");

          else
            applytag(Ts, Te, "italred");
        }
      if(Debug >= 2)
        g_print("domks() type=%d Ts=%d Te=%d\n", type, Ts, Te);

    }
    while((_Bool)1);
    free((void *)line);
  }

  else
  {
    void *return_value_ec_malloc_5;
    return_value_ec_malloc_5=ec_malloc(sizeof(signed int) /*4ul*/ );
    bookmarks = (signed int *)return_value_ec_malloc_5;
    bookmarks[(signed long int)0] = 0;
  }
  if(Debug >= 1)
    g_print("end domks()\n");


__CPROVER_DUMP_L24:
  ;
}

// ec_malloc
// file main.h line 173
void * ec_malloc(unsigned long int bytes)
{
  void *assign;
  assign=calloc(bytes, (unsigned long int)1);
  if(assign == NULL)
  {
    fprintf(stderr, "!!! %s ec_malloc(): CALLOC FAILURE, OUT OF MEMORY !!!", (const void *)Me);
    gtk_main_quit();
  }

  return assign;
}

// error_popup
// file see.c line 770
void error_popup(char *messg)
{
  char title[12l] = { ' ', 'S', 'e', 'e', '/', 'E', 'r', 'r', 'o', 'r', ' ', 0 };
  struct _GtkWidget *textLbl;
  struct _GtkWidget *dialgBx;
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
  dialgBx=gtk_dialog_new_with_buttons(title, (struct _GtkWindow *)return_value_g_type_check_instance_cast_2, (enum anonymous_45)GTK_DIALOG_MODAL, "gtk-ok", -5, (void *)0);
  unsigned long int return_value_gtk_window_get_type_3;
  return_value_gtk_window_get_type_3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, "!Error");
  textLbl=gtk_label_new_with_mnemonic(messg);
  unsigned long int return_value_gtk_label_get_type_5;
  return_value_gtk_label_get_type_5=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)textLbl, return_value_gtk_label_get_type_5);
  gtk_label_set_justify((struct _GtkLabel *)return_value_g_type_check_instance_cast_6, (enum anonymous_32)GTK_JUSTIFY_CENTER);
  unsigned long int return_value_gtk_dialog_get_type_7;
  return_value_gtk_dialog_get_type_7=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)dialgBx, return_value_gtk_dialog_get_type_7);
  unsigned long int return_value_gtk_box_get_type_9;
  return_value_gtk_box_get_type_9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkDialog *)return_value_g_type_check_instance_cast_8)->vbox, return_value_gtk_box_get_type_9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_10, textLbl, 0, 0, (unsigned int)0);
  gtk_widget_show(textLbl);
  unsigned long int return_value_gtk_dialog_get_type_11;
  return_value_gtk_dialog_get_type_11=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)dialgBx, return_value_gtk_dialog_get_type_11);
  gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_12);
  gtk_widget_destroy(dialgBx);
  unsigned long int return_value_gtk_window_get_type_13;
  return_value_gtk_window_get_type_13=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_13);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_14, "...okay");
}

// exeFSlisting
// file see.c line 863
void exeFSlisting(char *listing)
{
  signed int lastline = 0;
  char *ptr;
  char sec[17l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char tplate[16l];
  ptr=strrchr(listing, 124);
  if(!(ptr == ((char *)NULL)))
  {
    ptr[(signed long int)0] = (char)0;
    sprintf(tplate, "(%%%d[^)]", 16);
    ptr = ptr + 1l;
    sscanf(ptr, tplate, (const void *)sec);
    ptr=strrchr(ptr, 36);
    if(!(ptr == ((char *)NULL)))
      sscanf(ptr, "_%d", &lastline);

    if(!(sec[0l] == 0))
      loadnew(listing, sec, lastline);

    else
      loadnew(listing, (char *)(void *)0, lastline);
  }

}

// exec_proc
// file see.c line 784
void exec_proc()
{
  struct _GtkTextIter begin;
  struct _GtkTextIter end;
  signed int sel;
  sel=gtk_text_buffer_get_selection_bounds(Tbuf, &begin, &end);
  signed int i;
  signed int len;
  struct _IO_FILE *pin;
  struct _IO_FILE *tfp;
  const char *term;
  unsigned long int return_value_gtk_entry_get_type_1;
  return_value_gtk_entry_get_type_1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
  term=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2);
  const char *homedir;
  char *tfile;
  char flag = (char)0;
  char *text = (char *)(void *)0;
  char *cmmd;
  char *line;
  struct anonymous_2 *old;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  if(term == ((const char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strlen_3=strlen(term);
    tmp_if_expr_4 = return_value_strlen_3 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_gtk_events_pending_14;
  if(!tmp_if_expr_4)
  {
    addtohistory((char *)term);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(term);
    void *return_value_ec_malloc_6;
    return_value_ec_malloc_6=ec_malloc(return_value_strlen_5 + (unsigned long int)16);
    cmmd = (char *)return_value_ec_malloc_6;
    sprintf(cmmd, "Execute:\n%s", term);
    signed int return_value_confirm_popup_7;
    return_value_confirm_popup_7=confirm_popup("See Operation", cmmd);
    if(return_value_confirm_popup_7 == -6)
      free((void *)cmmd);

    else
    {
      free((void *)cmmd);
      if(Debug >= 1)
      {
        g_print("exec_proc() +%s+", term);
        fflush(stdout);
      }

      char *return_value_strstr_13;
      return_value_strstr_13=strstr(term, "SEEBUF");
      if(!(return_value_strstr_13 == ((char *)NULL)))
      {
        homedir=g_get_home_dir();
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(homedir);
        void *return_value_ec_malloc_9;
        return_value_ec_malloc_9=ec_malloc(return_value_strlen_8 + (unsigned long int)16);
        tfile = (char *)return_value_ec_malloc_9;
        sprintf(tfile, "%s/.seeTMP", homedir);
        tfp=fopen(tfile, "w");
        if(tfp == ((struct _IO_FILE *)NULL))
        {
          error_popup("Could not\ncreate temp file!");
          goto __CPROVER_DUMP_L25;
        }

        cmmd=strsub(term, tfile);
        if(FileCon == ((char *)NULL) && sel == 0)
        {
          gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
          FileCon=gtk_text_buffer_get_text(Tbuf, &start, &finish, 0);
          text = FileCon;
        }

        else
          if(!(sel == 0))
          {
            text=gtk_text_buffer_get_text(Tbuf, &begin, &end, 0);
            flag = flag + 1;
          }

          else
            text = FileCon;
        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(text);
        len = (signed int)return_value_strlen_10;
        i = 0;
        for( ; !(i >= len); i = i + 1)
          fputc((signed int)text[(signed long int)i], tfp);
        flag = flag + 1;
        fclose(tfp);
      }

      else
      {
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen(term);
        void *return_value_ec_malloc_12;
        return_value_ec_malloc_12=ec_malloc(return_value_strlen_11 + (unsigned long int)8);
        cmmd = (char *)return_value_ec_malloc_12;
        strcpy(cmmd, term);
      }
      if(!(Config->bRedirect == 0))
        strcat(cmmd, " 2>&1");

      if(!(Seefile == ((struct anonymous_2 *)NULL)))
      {
        old=SFcopy(Seefile);
        i=cursorline();
        update_filelist(old, i);
        free((void *)old);
      }

      clear(0);
      if(Debug >= 2)
      {
        g_print("...cmmd=\"%s\"...", cmmd);
        fflush(stdout);
      }

      pin=popen(cmmd, "r");
      gtk_text_buffer_get_end_iter(Tbuf, &finish);
      do
      {
        line=linein(pin);
        if(line == ((char *)NULL))
          break;

        gtk_text_buffer_insert(Tbuf, &finish, (const char *)line, -1);
        do
        {
          return_value_gtk_events_pending_14=gtk_events_pending();
          if(return_value_gtk_events_pending_14 == 0)
            break;

          gtk_main_iteration();
        }
        while((_Bool)1);
        free((void *)line);
      }
      while((_Bool)1);
      void *return_value_ec_malloc_15;
      return_value_ec_malloc_15=ec_malloc((unsigned long int)64);
      line = (char *)return_value_ec_malloc_15;
      signed int return_value_pclose_16;
      return_value_pclose_16=pclose(pin);
      sprintf(line, "Process returned %d", return_value_pclose_16);
      unsigned long int return_value_gtk_window_get_type_17;
      return_value_gtk_window_get_type_17=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
      return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_17);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_18, line);
      free((void *)line);
      if(!(FileCon == ((char *)NULL)))
        free((void *)FileCon);

      FileCon = (char *)(void *)0;
      free((void *)cmmd);
      if((signed int)flag >= 1)
      {
        unlink(tfile);
        free((void *)tfile);
      }

      if((signed int)flag == 2)
        free((void *)text);

      if(Debug >= 1)
      {
        g_print("...exec_proc() DONE\n");
        fflush(stdout);
      }

    }
  }


__CPROVER_DUMP_L25:
  ;
}

// fdreadin
// file main.h line 174
signed int fdreadin(char *source, char *buffer, char end, signed int max, signed int offset)
{
  signed int i = 0;
  char *errmsg;
  char ch = (char)-9;
  signed int FDIN;
  FDIN=open(source, 00);
  if(!(FDIN >= 3))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    errmsg=strerror(*return_value___errno_location_1);
    strcpy(buffer, errmsg);
    return 0;
  }

  if(offset >= 1)
    lseek(FDIN, (signed long int)offset, 0);

  while(!(ch == end) && !(i >= max))
  {
    signed long int return_value_read_2;
    return_value_read_2=read(FDIN, (void *)&ch, (unsigned long int)1);
    if(!(return_value_read_2 == 1l))
      break;

    buffer[(signed long int)i] = ch;
    i = i + 1;
  }
  buffer[(signed long int)i] = (char)0;
  close(FDIN);
  return i;
}

// file_check
// file main.h line 189
signed int file_check(char *file)
{
  signed int ftype;
  struct stat info;
  signed int return_value_stat_2;
  return_value_stat_2=stat(file, &info);
  if(!(return_value_stat_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 2)
      return -2;

    else
      return 0;
  }

  ftype = (signed int)(info.st_mode & (unsigned int)0170000);
  return ftype;
}

// file_out
// file see.c line 906
void file_out(void)
{
  struct _GtkTextIter begin;
  struct _GtkTextIter end;
  signed int sel;
  sel=gtk_text_buffer_get_selection_bounds(Tbuf, &begin, &end);
  signed int ip;
  char messg[4352l];
  char name[4096l];
  char *rp;
  char flag = (char)0;
  char *ptr;
  const char *term;
  unsigned long int return_value_gtk_entry_get_type_1;
  return_value_gtk_entry_get_type_1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
  term=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(term);
  ip = (signed int)return_value_strlen_3;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  if(ip == 0)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strlen_4=strlen(Config->copyto);
    tmp_if_expr_5 = (unsigned long int)ip + return_value_strlen_4 > (unsigned long int)4096 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_gtk_window_get_type_7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  unsigned long int return_value_gtk_window_get_type_9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  if(tmp_if_expr_5)
    error_popup("You must give a proper file name\nin the text entry.");

  else
  {
    addtohistory((char *)term);
    if(Debug >= 1)
    {
      g_print("file_out() +%s+", term);
      fflush(stdout);
    }

    sprintf(name, "%s/%s", Config->copyto, term);
    if(!(sel == 0))
      sprintf(messg, "Copy selected text to\n\"%s/%s\"?", Config->copyto, term);

    else
      sprintf(messg, "Copy text buffer content to\n\"%s/%s\"?", Config->copyto, term);
    signed int return_value_confirm_popup_6;
    return_value_confirm_popup_6=confirm_popup("See Operation", messg);
    if(!(return_value_confirm_popup_6 == -6))
    {
      if(FileCon == ((char *)NULL) && sel == 0)
      {
        gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
        FileCon=gtk_text_buffer_get_text(Tbuf, &start, &finish, 0);
        flag = (char)1;
      }

      if(!(sel == 0))
      {
        ptr=gtk_text_buffer_get_text(Tbuf, &begin, &end, 0);
        flag = (char)2;
      }

      else
        ptr = FileCon;
      rp=writeout(ptr, name, &ip);
      if(!(rp == ((char *)NULL)))
      {
        sprintf(messg, "Copy failed:\n%s", rp);
        error_popup(messg);
      }

      else
      {
        Settitle = (char)0;
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen(ptr);
        if(!((unsigned long int)ip == return_value_strlen_11))
        {
          return_value_gtk_window_get_type_7=gtk_window_get_type();
          return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_7);
          gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_8, "Copy Incomplete!");
        }

        else
        {
          return_value_gtk_window_get_type_9=gtk_window_get_type();
          return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_9);
          gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_10, "Copy Complete");
        }
        loadnew(name, (char *)(void *)0, 0);
        Settitle = (char)1;
        if((signed int)flag == 1)
        {
          free((void *)FileCon);
          FileCon = (char *)(void *)0;
        }

        if((signed int)flag == 2)
          free((void *)ptr);

        if(Debug >= 1)
        {
          g_print("...file_out() DONE");
          fflush(stdout);
        }

      }
    }

  }
}

// filelen
// file main.h line 175
signed int filelen(char *file)
{
  struct stat info;
  if(Debug >= 2)
  {
    g_print("filelen() %s\n", file);
    fflush(stdout);
  }

  signed int return_value_stat_1;
  return_value_stat_1=stat(file, &info);
  if(!(return_value_stat_1 >= 0))
  {
    perror("\tstat");
    return -1;
  }

  else
    return (signed int)info.st_size;
}

// fileselect
// file see.c line 952
void fileselect(struct _GtkTreeView *treeview, struct _GtkTreePath *treepath, struct _GtkTreeViewColumn *treecol, struct _GtkWidget *swin)
{
  signed int len;
  signed int i;
  signed int lend;
  char list[27l][5120l];
  char *ptr;
  char *file;
  struct _GtkTreeModel *Tmod;
  Tmod=gtk_tree_view_get_model(treeview);
  struct _GtkTreeIter itr;
  Nbar.select = (struct _GtkTreeSelection *)(void *)0;
  signed int return_value_gtk_tree_model_get_iter_1;
  return_value_gtk_tree_model_get_iter_1=gtk_tree_model_get_iter(Tmod, &itr, treepath);
  if(!(return_value_gtk_tree_model_get_iter_1 == 0))
    gtk_tree_model_get(Tmod, &itr, 0, &file, -1);

  else
    goto __CPROVER_DUMP_L8;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(file);
  lend = (signed int)return_value_strlen_2;
  ptr=strrchr(file, 32);
  if(!(ptr == ((char *)NULL)))
    ptr[(signed long int)0] = (char)124;

  gtk_widget_destroy(swin);
  len=loadlist(list);
  i = 0;
  signed int return_value_strncmp_3;
  for( ; !(i >= len); i = i + 1)
  {
    return_value_strncmp_3=strncmp(file, list[(signed long int)i], (unsigned long int)lend);
    if(return_value_strncmp_3 == 0)
      break;

  }
  if(Debug >= 1)
    g_print("fileselect(): %s %d %d\n", file, len, i);

  free((void *)file);
  if(!(i == len))
  {
    CurFS = 1;
    exeFSlisting(list[(signed long int)i]);
  }


__CPROVER_DUMP_L8:
  ;
}

// getMsg
// file server.c line 78
signed int getMsg(signed int fd, char *buffer, signed int sz)
{
  signed int err;
  signed int c = 0;
  signed int skip = 0;
  signed long int return_value_read_1;
  do
  {
    return_value_read_1=read(fd, (void *)&buffer[(signed long int)c], (unsigned long int)1);
    err = (signed int)return_value_read_1;
    if(err == 0)
      break;

    if(err == -1)
    {
      perror("getMsg() read fail: ");
      skip = skip + 1;
      if(skip == 5)
        return -1;

    }

    else
    {
      if(c == sz || (signed int)buffer[(signed long int)c] == 10)
        break;

      c = c + 1;
    }
  }
  while((_Bool)1);
  buffer[(signed long int)c] = (char)0;
  return c;
}

// getagcoords
// file see.c line 983
signed int getagcoords(struct _GtkTextTag *tag, char *tagline)
{
  signed int cc;
  signed int total = 0;
  char coord[16l];
  struct _GtkTextIter itr;
  if(Debug >= 1)
    g_print("getagcoords() %s | ", tagline);

  gtk_text_buffer_get_iter_at_line(Tbuf, &itr, 0);
  signed int return_value_gtk_text_iter_forward_to_tag_toggle_4;
  return_value_gtk_text_iter_forward_to_tag_toggle_4=gtk_text_iter_forward_to_tag_toggle(&itr, tag);
  signed int return_value_gtk_text_iter_forward_to_tag_toggle_2;
  if(return_value_gtk_text_iter_forward_to_tag_toggle_4 == 1)
  {
    cc=gtk_text_iter_get_offset(&itr);
    if(Debug >= 2)
      g_print("%d -- ", cc);

    if(tag == boldblue)
      sprintf(tagline, "*B*%d*", cc);

    else
      if(tag == italred)
        sprintf(tagline, "*R*%d*", cc);

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(tagline);
    total = (signed int)return_value_strlen_1;
    do
    {
      return_value_gtk_text_iter_forward_to_tag_toggle_2=gtk_text_iter_forward_to_tag_toggle(&itr, tag);
      if(!(return_value_gtk_text_iter_forward_to_tag_toggle_2 == 1))
        break;

      cc=gtk_text_iter_get_offset(&itr);
      if(Debug >= 2)
        g_print("%d -- ", cc);

      sprintf(coord, "%d*", cc);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(coord);
      total = total + (signed int)return_value_strlen_3;
      if(total >= 4096)
        break;

      strcat(tagline, coord);
    }
    while((_Bool)1);
  }

  return total;
}

// gotoCursor
// file see.c line 1010
void gotoCursor(struct _GtkWidget *ignored)
{
  struct _GtkTextMark *mk;
  mk=gtk_text_buffer_get_insert(Tbuf);
  struct _GtkTextIter iter;
  gtk_text_buffer_get_iter_at_mark(Tbuf, &iter, mk);
  scrollToIter(&iter);
}

// gotobmk
// file see.c line 1007
void gotobmk()
{
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
  unsigned long int return_value_gtk_text_mark_get_type_3;
  return_value_gtk_text_mark_get_type_3=gtk_text_mark_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)bmk, return_value_gtk_text_mark_get_type_3);
  gtk_text_view_scroll_to_mark((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, (struct _GtkTextMark *)return_value_g_type_check_instance_cast_4, 0.0, (signed int)!(0 != 0), 0.0, 0.5);
}

// grabfocus
// file see.c line 1019
void grabfocus(struct _GtkWidget *ignored)
{
  unsigned long int return_value_gtk_entry_get_type_1;
  return_value_gtk_entry_get_type_1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2, "");
  gtk_widget_grab_focus(Fent);
}

// handlequit
// file see.c line 1024
void handlequit()
{
  signed int lastline;
  lastline=cursorline();
  struct anonymous_2 *old;
  signed int pid;
  pid=getpid();
  tglServer((struct _GtkWidget *)(void *)0, -1);
  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    old=SFcopy(Seefile);
    free((void *)Seefile);
    Seefile = (struct anonymous_2 *)(void *)0;
    update_filelist(old, lastline);
    free((void *)old);
  }

  if(Debug >= 1)
  {
    g_print("______pid %d handlequit(), exiting_______\n\n", pid);
    fflush(stdout);
  }

  gtk_widget_destroy(MainWindow);
  gtk_main_quit();
}

// help
// file see.c line 1051
void help(void)
{
  loadnew("seetxt", "1", 0);
}

// highlight
// file see.c line 1043
void highlight(struct _GtkWidget *widget, char *tag)
{
  struct _GtkTextIter begin;
  struct _GtkTextIter end;
  gtk_text_buffer_get_selection_bounds(Tbuf, &begin, &end);
  gtk_text_buffer_apply_tag_by_name(Tbuf, tag, &begin, &end);
  savebmks((struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0);
}

// initSF
// file see.c line 1054
struct anonymous_2 * initSF(char *path, char type, char *sec)
{
  char *ptr;
  signed int len;
  struct anonymous_2 *r;
  void *return_value_ec_malloc_1;
  return_value_ec_malloc_1=ec_malloc(sizeof(struct anonymous_2) /*4244ul*/ );
  r = (struct anonymous_2 *)return_value_ec_malloc_1;
  memset((void *)r, 0, sizeof(struct anonymous_2) /*4244ul*/ );
  if(!(Debug == 0))
    fprintf(stderr, "initSF() %s %c\n", path, type);

  strncpy(r->path, path, (unsigned long int)4096);
  r->type = type;
  if((signed int)type == 82)
  {
    ptr=strrchr(path, 47);
    if(ptr == ((char *)NULL))
    {
      error_popup("No / prefixed to Regular file path!");
      return (struct anonymous_2 *)(void *)0;
    }

    ptr = ptr + 1l;
    strncpy(r->name, ptr, (unsigned long int)128);
    r->sec[(signed long int)0] = (char)0;
  }

  else
    if(!(sec == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(sec);
      len = (signed int)return_value_strlen_2;
      if(len >= 17)
        len = 16;

      strncpy(r->name, path, (unsigned long int)((128 - len) - 2));
      if(!(*sec == 0))
      {
        strcat(r->name, "(");
        strncat(r->name, sec, (unsigned long int)len);
        strcat(r->name, ")");
        strncpy(r->sec, sec, (unsigned long int)16);
      }

    }

    else
    {
      strncpy(r->name, path, (unsigned long int)(128 - 1));
      r->sec[(signed long int)0] = (char)0;
    }
  r->name[(signed long int)128] = (char)0;
  return r;
}

// linein
// file main.h line 176
char * linein(struct _IO_FILE *stream)
{
  signed int c = 0;
  char *line = (char *)(void *)0;
  char buffer[1024l];
  char byte;
  char kb = (char)0;
  char *tmp;
  memset((void *)buffer, 0, (unsigned long int)1024);
  if(Debug >= 3)
  {
    g_print("linein()...");
    fflush(stdout);
  }

  unsigned long int return_value_fread_1;
  do
  {
    return_value_fread_1=fread((void *)&byte, (unsigned long int)1, (unsigned long int)1, stream);
    if(!(return_value_fread_1 == 1ul))
      break;

    buffer[(signed long int)c] = byte;
    c = c + 1;
    if((signed int)byte == 10)
      break;

    if(c == 1024)
    {
      kb = kb + 1;
      if((signed int)kb >= 2)
      {
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)line, (unsigned long int)(1024 * (signed int)kb));
        tmp = (char *)return_value_realloc_2;
        if(tmp == ((char *)NULL))
        {
          fprintf(stderr, "!!!%s linein() REALLOC FAILED, OUT OF MEMORY\n", (const void *)Me);
          return line;
        }

        line = tmp;
      }

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(buffer);
        void *return_value_ec_malloc_4;
        return_value_ec_malloc_4=ec_malloc(return_value_strlen_3 + (unsigned long int)1);
        line = (char *)return_value_ec_malloc_4;
        line[(signed long int)0] = (char)0;
      }
      strcat(line, buffer);
      memset((void *)buffer, 0, (unsigned long int)1024);
      c = 0;
    }

  }
  while((_Bool)1);
  unsigned long int return_value_strlen_7;
  void *return_value_ec_malloc_8;
  if(c == 0)
    return line;

  else
  {
    if(!(kb == 0))
    {
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(buffer);
      void *return_value_realloc_6;
      return_value_realloc_6=realloc((void *)line, (unsigned long int)((signed int)kb * 1024) + return_value_strlen_5 + (unsigned long int)1);
      tmp = (char *)return_value_realloc_6;
      if(tmp == ((char *)NULL))
      {
        fprintf(stderr, "!!!%s linein() REALLOC FAILED, OUT OF MEMORY\n", (const void *)Me);
        return line;
      }

      line = tmp;
    }

    else
    {
      return_value_strlen_7=strlen(buffer);
      return_value_ec_malloc_8=ec_malloc(return_value_strlen_7 + (unsigned long int)1);
      line = (char *)return_value_ec_malloc_8;
    }
    strcat(line, buffer);
    if(Debug >= 3)
    {
      g_print("%s", line);
      fflush(stdout);
    }

    return line;
  }
}

// list2view
// file see.c line 1093
void list2view(struct _GtkListStore *ls)
{
  struct _GtkTreeIter itr;
  char list[27l][5120l];
  char *ptr;
  signed int i;
  signed int len;
  len=loadlist(list);
  if(!(len == 0))
  {
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      gtk_list_store_append(ls, &itr);
      ptr=strrchr(list[(signed long int)i], 36);
      if(!(ptr == ((char *)NULL)))
        ptr[(signed long int)0] = (char)0;

      ptr=strrchr(list[(signed long int)i], 124);
      if(!(ptr == ((char *)NULL)))
        ptr[(signed long int)0] = (char)32;

      gtk_list_store_set(ls, &itr, 0, (const void *)list[(signed long int)i], -1);
    }
    setFL_selected();
  }

}

// loadfile
// file see.c line 1109
signed int loadfile(signed int setline)
{
  signed int len;
  len=filelen(Seefile->path);
  signed int i;
  signed int lastline = 0;
  char messg[256l];
  if(Debug >= 1)
    g_print("loadfile() '%s',%d bytes...\n", (const void *)Seefile->path, len);

  if(!(len >= 1))
  {
    if(Debug >= 1)
    {
      g_print("loadfile() -- filelen() returned %d (can't load)\n", len);
      fflush(stdout);
    }

    if(len == 0)
      sprintf(messg, "\"%s\"\nhas no content", (const void *)Seefile->path);

    else
      sprintf(messg, "Can't open\n%s", (const void *)Seefile->path);
    error_popup(messg);
    if(len == 0)
      goto __CPROVER_DUMP_L5;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    lastline=cursorline();
    clear(0);
    void *return_value_ec_malloc_1;
    return_value_ec_malloc_1=ec_malloc((unsigned long int)(len + 1));
    FileCon = (char *)return_value_ec_malloc_1;
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    if(!(Config->tailat >= len))
    {
      signed int return_value_loadlarge_2;
      return_value_loadlarge_2=loadlarge(len);
      if(return_value_loadlarge_2 == 0)
      {
        clear(1);
        return 1;
      }

    }

    else
    {
      i=fdreadin(Seefile->path, FileCon, (char)-1, len, 0);
      if(!(i == len))
      {
        if(Debug >= 2)
          g_print("\tshort read (stat %d, read %d)\n", len, i);

        if(i == 0)
          sprintf(messg, "Permission denied for\n%s", (const void *)Seefile->path);

        else
          sprintf(messg, "Read short on\n%s", (const void *)Seefile->path);
        error_popup(messg);
      }

      signed int return_value_g_utf8_validate_3;
      return_value_g_utf8_validate_3=g_utf8_validate((const char *)FileCon, (signed long int)-1, (const char **)(void *)0);
      if(return_value_g_utf8_validate_3 == 0)
        error_popup("Can't Validate Text\n(Error #4)");

      else
        gtk_text_buffer_set_text(Tbuf, FileCon, len);
    }
    if(!(Config->seedata == ((char *)NULL)))
      dobmks();

    else
    {
      void *return_value_ec_malloc_4;
      return_value_ec_malloc_4=ec_malloc(sizeof(signed int) /*4ul*/ );
      bookmarks = (signed int *)return_value_ec_malloc_4;
      bookmarks[(signed long int)0] = 0;
    }
    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_5);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, Seefile->name);
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    gtk_text_buffer_place_cursor(Tbuf, &start);
    scrolltoline((struct _GtkWidget *)(void *)0, setline);
    sprintf(messg, "%d %s", CurFS, (const void *)Seefile->name);
    unsigned long int return_value_gtk_button_get_type_7;
    return_value_gtk_button_get_type_7=gtk_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.current, return_value_gtk_button_get_type_7);
    gtk_button_set_label((struct _GtkButton *)return_value_g_type_check_instance_cast_8, messg);
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen(FileCon);
    SFsz = (signed int)return_value_strlen_9;
    return 1;
  }
}

// loadlarge
// file see.c line 1162
signed int loadlarge(signed int len)
{
  signed int total = 0;
  float inc = 1.0f / ((float)len / 100000.0f);
  float sofar = 0.0f;
  char buffer[100001l];
  char title[4224l];
  struct _GtkWidget *subwin;
  subwin=gtk_window_new((enum anonymous_5)GTK_WINDOW_POPUP);
  struct _GtkWidget *frame;
  frame=gtk_frame_new("Loading File");
  struct _GtkWidget *svbox;
  svbox=gtk_vbox_new(0, 0);
  struct _GtkWidget *caption;
  caption=gtk_label_new(Seefile->name);
  struct _GtkWidget *pbar;
  pbar=gtk_progress_bar_new();
  struct _GtkWidget *cancelBT;
  cancelBT=gtk_button_new_with_label("cancel");
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_window_get_type_1);
  unsigned long int return_value_gtk_window_get_type_3;
  return_value_gtk_window_get_type_3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_3);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, (struct _GtkWindow *)return_value_g_type_check_instance_cast_4);
  unsigned long int return_value_gtk_window_get_type_5;
  return_value_gtk_window_get_type_5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_window_get_type_5);
  gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (enum anonymous_35)GTK_WIN_POS_CENTER_ON_PARENT);
  sprintf(title, "Loading \"%s\"...", (const void *)Seefile->name);
  unsigned long int return_value_gtk_window_get_type_7;
  return_value_gtk_window_get_type_7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_7);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_8, title);
  unsigned long int return_value_gtk_container_get_type_9;
  return_value_gtk_container_get_type_9=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)subwin, return_value_gtk_container_get_type_9);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_10, frame);
  unsigned long int return_value_gtk_container_get_type_11;
  return_value_gtk_container_get_type_11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_11);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_12, svbox);
  unsigned long int return_value_gtk_box_get_type_13;
  return_value_gtk_box_get_type_13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)svbox, return_value_gtk_box_get_type_13);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_14, caption, 0, 0, (unsigned int)4);
  unsigned long int return_value_gtk_box_get_type_15;
  return_value_gtk_box_get_type_15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)svbox, return_value_gtk_box_get_type_15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_16, pbar, 0, 0, (unsigned int)4);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)svbox, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, cancelBT, 0, 0, (unsigned int)4);
  g_signal_connect_data((void *)cancelBT, "clicked", (void (*)(void))destroy_widget, (void *)subwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)subwin, "destroy", (void (*)(void))gtk_widget_destroyed, (void *)&subwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)subwin, "destroy", (void (*)(void))gtk_widget_destroyed, (void *)&pbar, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_show_all(subwin);
  FileCon[(signed long int)0] = (char)0;
  unsigned long int return_value_gtk_progress_bar_get_type_21;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  signed int return_value_gtk_events_pending_23;
  while(!(subwin == ((struct _GtkWidget *)NULL)) && !(total >= len))
  {
    signed int return_value_fdreadin_19;
    return_value_fdreadin_19=fdreadin(Seefile->path, buffer, (char)-1, 100000, total);
    total = total + return_value_fdreadin_19;
    signed int return_value_g_utf8_validate_20;
    return_value_g_utf8_validate_20=g_utf8_validate((const char *)buffer, (signed long int)-1, (const char **)(void *)0);
    if(return_value_g_utf8_validate_20 == 0)
    {
      gtk_widget_destroy(subwin);
      error_popup("Can't Validate Text\n(Error #4)");
      clear(1);
      break;
    }

    gtk_text_buffer_insert(Tbuf, &finish, buffer, -1);
    strcat(FileCon, buffer);
    sofar = sofar + inc;
    if(pbar == ((struct _GtkWidget *)NULL))
      break;

    if(sofar <= 1.0f)
    {
      return_value_gtk_progress_bar_get_type_21=gtk_progress_bar_get_type();
      return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)pbar, return_value_gtk_progress_bar_get_type_21);
      gtk_progress_bar_set_fraction((struct _GtkProgressBar *)return_value_g_type_check_instance_cast_22, (double)sofar);
    }

    do
    {
      return_value_gtk_events_pending_23=gtk_events_pending();
      if(return_value_gtk_events_pending_23 == 0)
        break;

      gtk_main_iteration();
    }
    while((_Bool)1);
  }
  if(total == len)
  {
    gtk_widget_destroy(subwin);
    return (signed int)!(0 != 0);
  }

  else
    return 0;
}

// loadlist
// file see.c line 1213
signed int loadlist(char (*list)[5120l])
{
  signed int i = 0;
  char *line;
  char *bad = (char *)(void *)0;
  char messg[5120l];
  struct _IO_FILE *fstRO;
  if(Debug >= 2)
    fprintf(stderr, "loadlist()...");

  memset((void *)list, 0, (unsigned long int)(27 * (4096 + 1024)));
  signed int return_value_streamline_4;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_5;
  if(Config->filelist == ((char *)NULL))
  {
    error_popup("You don't have a filelist defined.\nCheck your ~/.seeconfig");
    return 0;
  }

  else
  {
    fstRO=fopen(Config->filelist, "r");
    if(fstRO == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      if(!(*return_value___errno_location_3 == 2))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        sprintf(messg, "Could not open filelist:\n%s", return_value_strerror_2);
        error_popup(messg);
      }

      return 0;
    }

    do
    {
      return_value_streamline_4=streamline(fstRO, &line, 4096 + 1024);
      if(!(return_value_streamline_4 >= 1))
        break;

      if(i == 27)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_strlen_5=strlen(line);
        tmp_if_expr_6 = !(return_value_strlen_5 != 0ul) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        break;

      char *return_value_strrchr_7;
      return_value_strrchr_7=strrchr(line, 124);
      if(return_value_strrchr_7 == ((char *)NULL))
      {
        if(bad == ((char *)NULL))
          bad = line;

        else
          free((void *)line);
      }

      else
      {
        strcpy(list[(signed long int)i], line);
        free((void *)line);
        i = i + 1;
      }
    }
    while((_Bool)1);
    fclose(fstRO);
    if(!(bad == ((char *)NULL)))
    {
      sprintf(messg, "Filelist entry \"%s\" is not formatted correctly.\n", bad);
      strcat(messg, "If you are using a filelist from a version prior to 0.70,\nsee the manpage under FILELIST or delete all contents.");
      error_popup(messg);
      free((void *)bad);
    }

    return i;
  }
}

// loadman
// file see.c line 1257
signed int loadman(signed int setline)
{
  signed int len;
  signed int i;
  char byte;
  char cmmd[4352l];
  char *line;
  char *ptr;
  char messg[384l];
  struct _IO_FILE *pin;
  if(Debug >= 1)
    g_print("loadman()...%s (%s)\n", (const void *)Seefile->path, (const void *)Seefile->sec);

  _Bool tmp_if_expr_1;
  if(Seefile->sec[0l] == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)Seefile->sec[(signed long int)0] == 42 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    sprintf(cmmd, "man -w %s", (const void *)Seefile->path);

  else
    sprintf(cmmd, "man -w %s %s", (const void *)Seefile->sec, (const void *)Seefile->path);
  if(Debug >= 3)
    fprintf(stderr, "\tcmmd: %s\n", (const void *)cmmd);

  void *return_value_ec_malloc_2;
  return_value_ec_malloc_2=ec_malloc((unsigned long int)1024);
  line = (char *)return_value_ec_malloc_2;
  pin=popen(cmmd, "r");
  signed int return_value_gtk_events_pending_7;
  if(pin == ((struct _IO_FILE *)NULL))
  {
    sprintf(messg, "\"%s\" failed", (const void *)cmmd);
    error_popup(messg);
    return 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= 1024); i = i + 1)
    {
      unsigned long int return_value_fread_3;
      return_value_fread_3=fread((void *)&byte, (unsigned long int)1, (unsigned long int)1, pin);
      if(!(return_value_fread_3 == 1ul))
        break;

      if(i == 0 && (signed int)byte == 10)
        i = -1;

      else
        if((signed int)byte == 10 && i >= 1)
        {
          line[(signed long int)i] = (char)0;
          break;
        }

        else
          line[(signed long int)i] = byte;
    }
    if(Debug >= 2)
      fprintf(stderr, "\t++%s++\n", line);

    signed int return_value_pclose_4;
    return_value_pclose_4=pclose(pin);
    if(!(return_value_pclose_4 == 0))
    {
      if(!(Seefile->sec[0l] == 0))
        sprintf(cmmd, "No manual entry for\n\"man %s %s\"", (const void *)Seefile->sec, (const void *)Seefile->path);

      else
        sprintf(cmmd, "No manual entry for \n\"man %s\"", (const void *)Seefile->path);
      error_popup(cmmd);
      return 0;
    }

    else
    {
      clear(0);
      if(Seefile->sec[0l] == 0)
      {
        ptr=strrchr(line, 47);
        ptr[(signed long int)0] = (char)0;
        ptr=strrchr(line, 47);
        sscanf(ptr, "/man%s", (const void *)Seefile->sec);
        strcat(Seefile->name, "(");
        strcat(Seefile->name, Seefile->sec);
        strcat(Seefile->name, ")");
      }

      if((signed int)Seefile->sec[0l] == 42)
        sprintf(cmmd, "man %s | col -b -x", (const void *)Seefile->path);

      else
        sprintf(cmmd, "man %s %s | col -b -x", (const void *)Seefile->sec, (const void *)Seefile->path);
      free((void *)line);
      sprintf(messg, "Loading %s...", (const void *)Seefile->name);
      unsigned long int return_value_gtk_window_get_type_5;
      return_value_gtk_window_get_type_5=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_5);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, messg);
      do
      {
        return_value_gtk_events_pending_7=gtk_events_pending();
        if(return_value_gtk_events_pending_7 == 0)
          break;

        gtk_main_iteration();
      }
      while((_Bool)1);
      pin=popen(cmmd, "r");
      if(pin == ((struct _IO_FILE *)NULL))
      {
        sprintf(messg, "\"%s\" failed", (const void *)cmmd);
        error_popup(messg);
        clear(1);
        return 0;
      }

      else
      {
        line=linein(pin);
        len=strexd(0, line);
        do
        {
          line=linein(pin);
          if(line == ((char *)NULL))
            break;

          len=strexd(len, line);
          free((void *)line);
        }
        while((_Bool)1);
        pclose(pin);
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(EXDline);
        if(!(return_value_strlen_8 >= 25ul))
        {
          sprintf(cmmd, "No manual entry for \n\"man %s\"", (const void *)Seefile->path);
          error_popup(cmmd);
          return 0;
        }

        else
        {
          void *return_value_ec_malloc_9;
          return_value_ec_malloc_9=ec_malloc((unsigned long int)(len + 1));
          FileCon = (char *)return_value_ec_malloc_9;
          strcpy(FileCon, EXDline);
          free((void *)EXDline);
          gtk_text_buffer_set_text(Tbuf, FileCon, len);
          sprintf(messg, "Manual Page for \"%s\"", (const void *)Seefile->name);
          unsigned long int return_value_gtk_window_get_type_10;
          return_value_gtk_window_get_type_10=gtk_window_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
          return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_10);
          gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_11, messg);
          gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
          gtk_text_buffer_place_cursor(Tbuf, &start);
          scrolltoline((struct _GtkWidget *)(void *)0, setline);
          if(!(Config->seedata == ((char *)NULL)))
            dobmks();

          else
          {
            void *return_value_ec_malloc_12;
            return_value_ec_malloc_12=ec_malloc(sizeof(signed int) /*4ul*/ );
            bookmarks = (signed int *)return_value_ec_malloc_12;
            bookmarks[(signed long int)0] = 0;
          }
          sprintf(messg, "%d %s", CurFS, (const void *)Seefile->name);
          unsigned long int return_value_gtk_button_get_type_13;
          return_value_gtk_button_get_type_13=gtk_button_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
          return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.current, return_value_gtk_button_get_type_13);
          gtk_button_set_label((struct _GtkButton *)return_value_g_type_check_instance_cast_14, messg);
          return 1;
        }
      }
    }
  }
}

// loadnew
// file see.c line 1365
signed int loadnew(char *file, char *sec, signed int lastline)
{
  char messg[256l];
  signed int curpos;
  signed int success;
  struct anonymous_2 *old = (struct anonymous_2 *)(void *)0;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(file);
  if(return_value_strlen_3 >= 4096ul)
  {
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "Filename Too Long");
    return -1;
  }

  if(!(watchSW == 0))
    watchfile();

  if(!(LNsw == 0))
    numberlines();

  if(!(FileCon == ((char *)NULL)))
  {
    if((signed int)Config->bConfirm == 0)
    {
      if(!((signed int)*file == 47))
        sprintf(messg, "Load manual page for\n%s?", file);

      else
        sprintf(messg, "Load \n%s?", file);
      signed int return_value_confirm_popup_4;
      return_value_confirm_popup_4=confirm_popup("SEE Request", messg);
      if(return_value_confirm_popup_4 == -6)
        return -1;

    }

  }

  if(Debug >= 1)
    g_print("loadnew() %s \"%s\" %d\n", file, sec, lastline);

  unsigned long int return_value_gtk_window_get_type_5;
  return_value_gtk_window_get_type_5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_5);
  gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast_6);
  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    old=SFcopy(Seefile);
    free((void *)Seefile);
  }

  if(!(sec == ((char *)NULL)))
    Seefile=initSF(file, (char)77, sec);

  else
    Seefile=initSF(file, (char)82, sec);
  _Bool tmp_if_expr_7;
  if(Seefile == ((struct anonymous_2 *)NULL))
  {
    Seefile = old;
    free((void *)old);
    return 27;
  }

  else
  {
    curpos=cursorline();
    if(!(sec == ((char *)NULL)))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)file[(signed long int)0] != 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      success=loadman(lastline);

    else
      success=loadfile(lastline);
    if(success == 0)
    {
      free((void *)Seefile);
      Seefile = old;
      return 0;
    }

    else
    {
      if(!(Config->filelist == ((char *)NULL)))
        update_filelist(old, curpos);

      if(!(old == ((struct anonymous_2 *)NULL)))
        free((void *)old);

      return 0;
    }
  }
}

// loclcon
// file server.c line 97
signed int loclcon(char *sock)
{
  struct sockaddr_un addr;
  unsigned long int size;
  signed int con;
  con=socket(1, 1, 0);
  addr.sun_family = (unsigned short int)1;
  strcpy(addr.sun_path, sock);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen((&addr)->sun_path);
  size = (unsigned long int)((struct sockaddr_un *)0)->sun_path + return_value_strlen_1;
  signed int return_value_connect_2;
  return_value_connect_2=connect(con, (struct sockaddr *)&addr, (unsigned int)size);
  if(return_value_connect_2 == -1)
    return 0;

  else
    return con;
}

// loclsckt
// file main.h line 192
signed int loclsckt(char *file)
{
  struct sockaddr_un name;
  signed int sock;
  unsigned int size;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(file);
  if(return_value_strlen_1 >= 108ul)
    return -2;

  else
  {
    sock=socket(1, 1, 0);
    if(!(sock >= 0))
      return -1;

    else
    {
      name.sun_family = (unsigned short int)1;
      strcpy(name.sun_path, file);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen((&name)->sun_path);
      size = (unsigned int)((unsigned long int)((struct sockaddr_un *)0)->sun_path + return_value_strlen_2);
      signed int return_value_bind_3;
      return_value_bind_3=bind(sock, (struct sockaddr *)&name, size);
      if(!(return_value_bind_3 >= 0))
      {
        close(sock);
        return -3;
      }

      else
        return sock;
    }
  }
}

// main
// file see.c line 38
signed int main(signed int argc, char **argv)
{
  const char *homedir;
  homedir=g_get_home_dir();
  char *cwd = (char *)(void *)0;
  char type;
  char image[4096l];
  char *term = (char *)(void *)0;
  char options[10l] = { 'K', 'd', ':', 's', ':', 'x', ':', 'v', 'h', 0 };
  char *p;
  struct _PangoFontDescription *Tfont;
  struct _PangoFontDescription *Nfont;
  signed int opt;
  signed int len;
  signed int server = 0;
  struct _GdkCursor *cursor;
  struct _GdkCursor *crosshair;
  struct _GdkColor textback;
  struct _GtkAdjustment *vadj;
  struct _GtkAdjustment *hadj;
  struct _GtkWidget *v_box;
  struct _GtkWidget *h_box;
  struct _GtkWidget *hbox_0;
  p=strrchr(argv[(signed long int)0], 47);
  if(!(p == ((char *)NULL)))
  {
    p = p + 1l;
    argv[(signed long int)0] = p;
  }

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen("/usr/share/seetxt-runtime");
  if(return_value_strlen_1 >= 3969ul)
  {
    fprintf(stderr, "Your runtime directory path, %s, is too long.  In order to access the files there, it must be shorter than your system's PATH_MAX (%d) by 128 characters.\n", (const void *)"/usr/share/seetxt-runtime", 4096);
    exit(0);
  }

  signal(13, (void (*)(signed int))1);
  Config=reconfigure((struct _GtkWidget *)(void *)0);
  if(Config->seedata == ((char *)NULL))
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(homedir);
    void *return_value_ec_malloc_3;
    return_value_ec_malloc_3=ec_malloc(return_value_strlen_2 + (unsigned long int)10);
    Config->seedata = (char *)return_value_ec_malloc_3;
    sprintf(Config->seedata, "%s/.seedata", homedir);
    opt=open(Config->seedata, 01 | 0100, 0200 | 0400);
    if(opt == -1)
    {
      free((void *)Config->seedata);
      Config->seedata = (char *)(void *)0;
    }

    else
      close(opt);
  }

  signed int return_value_strcmp_4;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_strlen_8;
  unsigned long int return_value_strlen_9;
  _Bool tmp_if_expr_13;
  unsigned long int return_value_strlen_11;
  unsigned long int return_value_strlen_12;
  signed int return_value_sscanf_16;
  unsigned long int return_value_strlen_17;
  _Bool tmp_if_expr_19;
  signed int return_value_strcmp_18;
  unsigned long int return_value_strlen_20;
  unsigned long int return_value_strlen_21;
  unsigned long int return_value_strlen_22;
  void *return_value_ec_malloc_23;
  if(argc >= 2)
  {
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(argv[(signed long int)0], "seeman");
    if(return_value_strcmp_5 == 0)
      type = (char)77;

    else
    {
      return_value_strcmp_4=strcmp(argv[(signed long int)0], "seetxt");
      if(return_value_strcmp_4 == 0)
        type = (char)82;

      else
      {
        puts("The executable name must be \"seetxt\" to function correctly.");
        return 66;
      }
    }
    if(!((signed int)*argv[1l] == 45))
    {
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(argv[(signed long int)1]);
      if(return_value_strlen_6 >= 4096ul)
      {
        puts("Filename is too long!");
        return 10;
      }

      if((signed int)type == 82)
      {
        if(!((signed int)*argv[1l] == 47))
        {
          cwd=getcwd((char *)(void *)0, (unsigned long int)(4096 + 1));
          signed int return_value_strncmp_7;
          return_value_strncmp_7=strncmp(argv[(signed long int)1], "./", (unsigned long int)2);
          if(return_value_strncmp_7 == 0)
            argv[(signed long int)1] = argv[(signed long int)1] + (signed long int)2;

          if(cwd == ((char *)NULL))
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            return_value_strlen_8=strlen(cwd);
            return_value_strlen_9=strlen(argv[(signed long int)1]);
            tmp_if_expr_10 = return_value_strlen_8 + return_value_strlen_9 > (unsigned long int)(4096 - 1) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
          {
            puts("Path to file is too long!");
            return 10;
          }

          strcat(cwd, "/");
          strcat(cwd, argv[(signed long int)1]);
          Seefile=initSF(cwd, type, (char *)(void *)0);
        }

        else
          Seefile=initSF(argv[(signed long int)1], type, (char *)(void *)0);
      }

      else
      {
        char *return_value_strchr_15;
        return_value_strchr_15=strchr(argv[(signed long int)1], 47);
        if(!(return_value_strchr_15 == ((char *)NULL)))
        {
          signed int return_value_strncmp_14;
          return_value_strncmp_14=strncmp(argv[(signed long int)1], "./", (unsigned long int)2);
          if(return_value_strncmp_14 == 0)
          {
            argv[(signed long int)1] = argv[(signed long int)1] + (signed long int)2;
            cwd=getcwd((char *)(void *)0, (unsigned long int)(4096 + 1));
            if(cwd == ((char *)NULL))
              tmp_if_expr_13 = (_Bool)1;

            else
            {
              return_value_strlen_11=strlen(cwd);
              return_value_strlen_12=strlen(argv[(signed long int)1]);
              tmp_if_expr_13 = return_value_strlen_11 + return_value_strlen_12 > (unsigned long int)(4096 - 1) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_13)
            {
              puts("Path to out of tree manpage is too long!");
              return 10;
            }

            strcat(cwd, "/");
            strcat(cwd, argv[(signed long int)1]);
            Seefile=initSF(cwd, type, "***");
          }

          else
            Seefile=initSF(argv[(signed long int)1], type, "***");
        }

        else
          Seefile=initSF(argv[(signed long int)1], type, (char *)(void *)0);
      }
      argv[(signed long int)1][(signed long int)0] = (char)0;
    }

    if(!(cwd == ((char *)NULL)))
      free((void *)cwd);

    do
    {
      opt=getopt(argc, argv, options);
      if(!(opt >= 1))
        break;

      switch(opt)
      {
        case 63:
        {
          usage(argv[(signed long int)0]);
          return 2;
        }
        case 104:
        {
          usage(argv[(signed long int)0]);
          return 2;
        }
        case 75:
        {
          sprintf(image, "killall -9 seetxt & killall -9 seeman");
          system(image);
          return 0;
        }
        case 100:
        {
          return_value_sscanf_16=sscanf(optarg, "%d", &Debug);
          if(return_value_sscanf_16 == 0)
          {
            usage(argv[(signed long int)0]);
            return 2;
          }

          break;
        }
        case 115:
        {
          return_value_strlen_17=strlen(optarg);
          if(return_value_strlen_17 >= 16ul)
            tmp_if_expr_19 = (_Bool)1;

          else
          {
            return_value_strcmp_18=strcmp(argv[(signed long int)0], "seeman");
            tmp_if_expr_19 = return_value_strcmp_18 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(Seefile == ((struct anonymous_2 *)NULL) || tmp_if_expr_19)
          {
            usage(argv[(signed long int)0]);
            return 2;
          }

          strncpy(Seefile->sec, optarg, (unsigned long int)16);
          return_value_strlen_20=strlen(Seefile->name);
          len = (signed int)return_value_strlen_20;
          if(128 + -len >= 19)
          {
            strcat(Seefile->name, "(");
            strncat(Seefile->name, optarg, (unsigned long int)16);
            strcat(Seefile->name, ")");
          }

          break;
        }
        case 120:
        {
          return_value_strlen_21=strlen(optarg);
          if(return_value_strlen_21 >= 1025ul)
          {
            fprintf(stderr, "Maximum search term length from command line is %d\n.", 1024);
            return 3;
          }

          return_value_strlen_22=strlen(optarg);
          return_value_ec_malloc_23=ec_malloc(return_value_strlen_22 + (unsigned long int)1);
          term = (char *)return_value_ec_malloc_23;
          strcpy(term, optarg);
          break;
        }
        case 118:
        {
          printf("%s version %s\n", argv[(signed long int)0], (const void *)"0.72");
          return 0;
        }
        default:
        {
          usage(argv[(signed long int)0]);
          return 2;
        }
      }
    }
    while((_Bool)1);
  }

  signed int return_value_getpid_24;
  if(Debug >= 1)
  {
    return_value_getpid_24=getpid();
    fprintf(stderr, "%s pid %d (Debug level %d)\n", argv[(signed long int)0], return_value_getpid_24, Debug);
  }

  if(!(Config->sock[0l] == 0))
  {
    signed int return_value_check_seesock_25;
    return_value_check_seesock_25=check_seesock();
    if(!(return_value_check_seesock_25 == -66))
    {
      if(return_value_check_seesock_25 == -11)
        goto __CPROVER_DUMP_L46;

      if(return_value_check_seesock_25 == -1)
        goto __CPROVER_DUMP_L47;

      if(return_value_check_seesock_25 == 0)
        goto __CPROVER_DUMP_L51;

    }

    else
    {
      Config->sock[(signed long int)0] = (char)0;
      goto __CPROVER_DUMP_L52;

    __CPROVER_DUMP_L46:
      ;
      puts("!defunct seesocket won't unlink");
      goto __CPROVER_DUMP_L52;

    __CPROVER_DUMP_L47:
      ;
      if(!(Seefile == ((struct anonymous_2 *)NULL)))
      {
        signed int return_value_send_remote_26;
        return_value_send_remote_26=send_remote(term);
        if(return_value_send_remote_26 == -3)
          puts("Request failed.");

        return 20;
      }

      goto __CPROVER_DUMP_L52;

    __CPROVER_DUMP_L51:
      ;
      server=loclsckt(Config->sock);
      if(!(server >= 3))
        server = -666;

    }

  __CPROVER_DUMP_L52:
    ;
    if(server >= 3)
      tglServer((struct _GtkWidget *)(void *)0, server);

  }

  gtk_init(&argc, &argv);
  MainWindow=gtk_window_new((enum anonymous_5)GTK_WINDOW_TOPLEVEL);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_27, "delete_event", (void (*)(void))handlequit, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_28, "destroy", (void (*)(void))gtk_main_quit, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_29, "window-state-event", (void (*)(void))nomax, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  Nfont=pango_font_description_copy(MainWindow->style->font_desc);
  pango_font_description_set_weight(Nfont, (enum anonymous_38)PANGO_WEIGHT_HEAVY);
  v_box=gtk_vbox_new(0, 0);
  unsigned long int return_value_gtk_container_get_type_30;
  return_value_gtk_container_get_type_30=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_container_get_type_30);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_31, v_box);
  sprintf(image, "%s/seeon.png", (const void *)"/usr/share/seetxt-runtime");
  watchon=gtk_image_new_from_file(image);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)watchon, (unsigned long int)(20 << 2));
  g_object_ref((void *)(struct _GObject *)return_value_g_type_check_instance_cast_32);
  ServOn=gtk_image_new_from_file(image);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)ServOn, (unsigned long int)(20 << 2));
  g_object_ref((void *)(struct _GObject *)return_value_g_type_check_instance_cast_33);
  sprintf(image, "%s/seeoff.png", (const void *)"/usr/share/seetxt-runtime");
  ServOff=gtk_image_new_from_file(image);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)ServOff, (unsigned long int)(20 << 2));
  g_object_ref((void *)(struct _GObject *)return_value_g_type_check_instance_cast_34);
  watchoff=gtk_image_new_from_file(image);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
  return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)watchoff, (unsigned long int)(20 << 2));
  g_object_ref((void *)(struct _GObject *)return_value_g_type_check_instance_cast_35);
  MMenu=gtk_menu_new();
  mainmenu();
  Nbar.hbx=gtk_hbox_new(0, 0);
  unsigned long int return_value_gtk_box_get_type_36;
  return_value_gtk_box_get_type_36=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)v_box, return_value_gtk_box_get_type_36);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_37, Nbar.hbx, 0, 0, (unsigned int)0);
  Nbar.back=gtk_button_new_from_stock("gtk-go-back");
  unsigned long int return_value_gtk_box_get_type_38;
  return_value_gtk_box_get_type_38=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.hbx, return_value_gtk_box_get_type_38);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_39, Nbar.back, 0, 0, (unsigned int)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.back, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_40, "clicked", (void (*)(void))shiftFilelist, (void *)1, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  Nbar.current=gtk_button_new();
  unsigned long int return_value_gtk_box_get_type_41;
  return_value_gtk_box_get_type_41=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
  return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.hbx, return_value_gtk_box_get_type_41);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_42, Nbar.current, 0, 0, (unsigned int)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.current, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_43, "clicked", (void (*)(void))showlist, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  Nbar.forward=gtk_button_new_from_stock("gtk-go-forward");
  unsigned long int return_value_gtk_box_get_type_44;
  return_value_gtk_box_get_type_44=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_45;
  return_value_g_type_check_instance_cast_45=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.hbx, return_value_gtk_box_get_type_44);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_45, Nbar.forward, 0, 0, (unsigned int)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
  return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)Nbar.forward, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_46, "clicked", (void (*)(void))shiftFilelist, (void *)-1, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  Nbar.select = (struct _GtkTreeSelection *)(void *)0;
  Scroll=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_box_get_type_47;
  return_value_gtk_box_get_type_47=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_48;
  return_value_g_type_check_instance_cast_48=g_type_check_instance_cast((struct _GTypeInstance *)v_box, return_value_gtk_box_get_type_47);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_48, Scroll, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_scrolled_window_get_type_49;
  return_value_gtk_scrolled_window_get_type_49=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_50;
  return_value_g_type_check_instance_cast_50=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_scrolled_window_get_type_49);
  vadj=gtk_scrolled_window_get_vadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_50);
  unsigned long int return_value_gtk_scrolled_window_get_type_51;
  return_value_gtk_scrolled_window_get_type_51=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_52;
  return_value_g_type_check_instance_cast_52=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_scrolled_window_get_type_51);
  hadj=gtk_scrolled_window_get_vadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_52);
  TxT=gtk_text_view_new();
  unsigned long int return_value_gtk_widget_get_type_53;
  return_value_gtk_widget_get_type_53=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
  return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_widget_get_type_53);
  gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast_54, Config->width, Config->height);
  unsigned long int return_value_gtk_text_view_get_type_55;
  return_value_gtk_text_view_get_type_55=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_56;
  return_value_g_type_check_instance_cast_56=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_55);
  gtk_text_view_set_editable((struct _GtkTextView *)return_value_g_type_check_instance_cast_56, 0);
  changewrapmode((struct _GtkWidget *)(void *)0, Config->wrap);
  unsigned long int return_value_gtk_container_get_type_57;
  return_value_gtk_container_get_type_57=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_58;
  return_value_g_type_check_instance_cast_58=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_container_get_type_57);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_58, TxT);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_59;
  return_value_g_type_check_instance_cast_59=g_type_check_instance_cast((struct _GTypeInstance *)TxT, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_59, "button_press_event", (void (*)(void))mousevent, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_drag_dest_set(TxT, (enum anonymous_11)GTK_DEST_DEFAULT_ALL, (const struct _GtkTargetEntry *)(void *)0, 0, (enum anonymous_10)GDK_ACTION_COPY);
  gtk_drag_dest_add_text_targets(TxT);
  gtk_drag_dest_add_uri_targets(TxT);
  g_signal_connect_data((void *)TxT, "drag-drop", (void (*)(void))DnDdrop, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)TxT, "drag-motion", (void (*)(void))DnDmotion, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)TxT, "drag-data-received", (void (*)(void))DnDreceive, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)TxT, "drag-leave", (void (*)(void))DnDleave, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  if(!(Config->txtfnt == ((char *)NULL)))
  {
    Tfont=pango_font_description_from_string(Config->txtfnt);
    gtk_widget_modify_font(TxT, Tfont);
    pango_font_description_free(Tfont);
  }

  if(!(Config->tbcolor == ((const char *)NULL)))
  {
    signed int return_value_gdk_color_parse_60;
    return_value_gdk_color_parse_60=gdk_color_parse(Config->tbcolor, &textback);
    if(!(return_value_gdk_color_parse_60 == 0))
      gtk_widget_modify_base(TxT, (enum anonymous_17)GTK_STATE_NORMAL, &textback);

    free((void *)(char *)Config->tbcolor);
  }

  unsigned long int return_value_gtk_text_view_get_type_61;
  return_value_gtk_text_view_get_type_61=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_62;
  return_value_g_type_check_instance_cast_62=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_61);
  Tbuf=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast_62);
  italred=gtk_text_buffer_create_tag(Tbuf, "italred", "foreground", (const void *)"#ff0000", (const void *)"style", 2, (void *)0);
  boldblue=gtk_text_buffer_create_tag(Tbuf, "boldblue", "foreground", (const void *)"#0000bb", (const void *)"weight", PANGO_WEIGHT_BOLD, (void *)0);
  hlink=gtk_text_buffer_create_tag(Tbuf, "hyperlinks", "foreground", (const void *)"#00aa00", (const void *)"underline", 2, (void *)0);
  pushed=gtk_text_buffer_create_tag(Tbuf, "pushed", "foreground", (const void *)"#ffff00", (const void *)"background", (const void *)"#aa00aa", (void *)0);
  hlite=gtk_text_buffer_create_tag(Tbuf, "highlights", "foreground", (const void *)"#aa00aa", (const void *)"background", (const void *)"#ffff00", (void *)0);
  lnnm=gtk_text_buffer_create_tag(Tbuf, "line_numbers", "foreground", (const void *)"#00ffaa", (void *)0);
  ctitle=gtk_text_buffer_create_tag(Tbuf, "center_title", "justification", GTK_JUSTIFY_CENTER, (const void *)"weight", 700, (void *)0);
  hbox_0=gtk_hbox_new(0, 0);
  unsigned long int return_value_gtk_box_get_type_63;
  return_value_gtk_box_get_type_63=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_64;
  return_value_g_type_check_instance_cast_64=g_type_check_instance_cast((struct _GTypeInstance *)v_box, return_value_gtk_box_get_type_63);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_64, hbox_0, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  ServTgl=gtk_button_new();
  unsigned long int return_value_gtk_container_get_type_65;
  return_value_gtk_container_get_type_65=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_66;
  return_value_g_type_check_instance_cast_66=g_type_check_instance_cast((struct _GTypeInstance *)ServTgl, return_value_gtk_container_get_type_65);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_66, ServOff);
  Sff.wgt = ServTgl;
  Sff.image1 = ServOff;
  Sff.image2 = ServOn;
  Sff.sw = 0;
  unsigned long int return_value_gtk_button_get_type_67;
  return_value_gtk_button_get_type_67=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_68;
  return_value_g_type_check_instance_cast_68=g_type_check_instance_cast((struct _GTypeInstance *)ServTgl, return_value_gtk_button_get_type_67);
  gtk_button_set_relief((struct _GtkButton *)return_value_g_type_check_instance_cast_68, (enum anonymous_33)GTK_RELIEF_NONE);
  unsigned long int return_value_gtk_box_get_type_69;
  return_value_gtk_box_get_type_69=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_70;
  return_value_g_type_check_instance_cast_70=g_type_check_instance_cast((struct _GTypeInstance *)hbox_0, return_value_gtk_box_get_type_69);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_70, ServTgl, 0, 0, (unsigned int)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_71;
  return_value_g_type_check_instance_cast_71=g_type_check_instance_cast((struct _GTypeInstance *)ServTgl, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_71, "clicked", (void (*)(void))tglServer, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_72;
  return_value_g_type_check_instance_cast_72=g_type_check_instance_cast((struct _GTypeInstance *)TxT, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_72, "key_press_event", (void (*)(void))TxTKpress, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  g_signal_connect_data((void *)ServTgl, "drag-data-received", (void (*)(void))DnDreceive, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  mainframe=gtk_frame_new((const char *)(void *)0);
  unsigned long int return_value_gtk_box_get_type_73;
  return_value_gtk_box_get_type_73=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_74;
  return_value_g_type_check_instance_cast_74=g_type_check_instance_cast((struct _GTypeInstance *)hbox_0, return_value_gtk_box_get_type_73);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_74, mainframe, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  h_box=gtk_hbox_new(0, 0);
  unsigned long int return_value_gtk_container_get_type_75;
  return_value_gtk_container_get_type_75=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_76;
  return_value_g_type_check_instance_cast_76=g_type_check_instance_cast((struct _GTypeInstance *)mainframe, return_value_gtk_container_get_type_75);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_76, h_box);
  pushTgl=gtk_toggle_button_new_with_label("push");
  unsigned long int return_value_gtk_box_get_type_77;
  return_value_gtk_box_get_type_77=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_78;
  return_value_g_type_check_instance_cast_78=g_type_check_instance_cast((struct _GTypeInstance *)h_box, return_value_gtk_box_get_type_77);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_78, pushTgl, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  numLbl=gtk_label_new("0");
  unsigned long int return_value_gtk_box_get_type_79;
  return_value_gtk_box_get_type_79=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_80;
  return_value_g_type_check_instance_cast_80=g_type_check_instance_cast((struct _GTypeInstance *)h_box, return_value_gtk_box_get_type_79);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_80, numLbl, 0, 0, (unsigned int)4);
  gtk_widget_modify_font(numLbl, Nfont);
  pango_font_description_free(Nfont);
  unsigned long int return_value_gtk_label_get_type_81;
  return_value_gtk_label_get_type_81=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_82;
  return_value_g_type_check_instance_cast_82=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_81);
  gtk_label_set_width_chars((struct _GtkLabel *)return_value_g_type_check_instance_cast_82, 6);
  Fent=gtk_entry_new();
  unsigned long int return_value_gtk_entry_get_type_83;
  return_value_gtk_entry_get_type_83=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_84;
  return_value_g_type_check_instance_cast_84=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_83);
  gtk_entry_set_max_length((struct _GtkEntry *)return_value_g_type_check_instance_cast_84, 4096);
  unsigned long int return_value_gtk_entry_get_type_85;
  return_value_gtk_entry_get_type_85=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_86;
  return_value_g_type_check_instance_cast_86=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_85);
  gtk_entry_set_has_frame((struct _GtkEntry *)return_value_g_type_check_instance_cast_86, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_entry_get_type_87;
  return_value_gtk_entry_get_type_87=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_88;
  return_value_g_type_check_instance_cast_88=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_87);
  gtk_entry_set_width_chars((struct _GtkEntry *)return_value_g_type_check_instance_cast_88, 27);
  unsigned long int return_value_gtk_box_get_type_89;
  return_value_gtk_box_get_type_89=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_90;
  return_value_g_type_check_instance_cast_90=g_type_check_instance_cast((struct _GTypeInstance *)h_box, return_value_gtk_box_get_type_89);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_90, Fent, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_91;
  return_value_g_type_check_instance_cast_91=g_type_check_instance_cast((struct _GTypeInstance *)Fent, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_91, "key_press_event", (void (*)(void))FentKpress, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  CaseTgl=gtk_toggle_button_new_with_label("case");
  unsigned long int return_value_gtk_box_get_type_92;
  return_value_gtk_box_get_type_92=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_93;
  return_value_g_type_check_instance_cast_93=g_type_check_instance_cast((struct _GTypeInstance *)h_box, return_value_gtk_box_get_type_92);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_93, CaseTgl, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  regxTgl=gtk_toggle_button_new_with_label("regexp");
  unsigned long int return_value_gtk_box_get_type_94;
  return_value_gtk_box_get_type_94=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_95;
  return_value_g_type_check_instance_cast_95=g_type_check_instance_cast((struct _GTypeInstance *)h_box, return_value_gtk_box_get_type_94);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_95, regxTgl, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)4);
  watchTgl=gtk_button_new();
  unsigned long int return_value_gtk_container_get_type_96;
  return_value_gtk_container_get_type_96=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_97;
  return_value_g_type_check_instance_cast_97=g_type_check_instance_cast((struct _GTypeInstance *)watchTgl, return_value_gtk_container_get_type_96);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_97, watchoff);
  wff.wgt = watchTgl;
  wff.image1 = watchoff;
  wff.image2 = watchon;
  wff.sw = 0;
  unsigned long int return_value_gtk_button_get_type_98;
  return_value_gtk_button_get_type_98=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_99;
  return_value_g_type_check_instance_cast_99=g_type_check_instance_cast((struct _GTypeInstance *)watchTgl, return_value_gtk_button_get_type_98);
  gtk_button_set_relief((struct _GtkButton *)return_value_g_type_check_instance_cast_99, (enum anonymous_33)GTK_RELIEF_NONE);
  unsigned long int return_value_gtk_box_get_type_100;
  return_value_gtk_box_get_type_100=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_101;
  return_value_g_type_check_instance_cast_101=g_type_check_instance_cast((struct _GTypeInstance *)hbox_0, return_value_gtk_box_get_type_100);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_101, watchTgl, 0, 0, (unsigned int)4);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_102;
  return_value_g_type_check_instance_cast_102=g_type_check_instance_cast((struct _GTypeInstance *)watchTgl, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_102, "clicked", (void (*)(void))watchfile, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_show(ServOn);
  gtk_widget_show(ServOff);
  gtk_widget_show(watchon);
  gtk_widget_show(watchoff);
  gtk_widget_show_all(MainWindow);
  cursor=gdk_cursor_new((enum anonymous_14)GDK_BOX_SPIRAL);
  gdk_window_set_cursor(MainWindow->window, cursor);
  gdk_cursor_unref(cursor);
  crosshair=gdk_cursor_new((enum anonymous_14)GDK_CROSSHAIR);
  unsigned long int return_value_gtk_text_view_get_type_103;
  return_value_gtk_text_view_get_type_103=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_104;
  return_value_g_type_check_instance_cast_104=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_103);
  struct _GdkDrawable *return_value_gtk_text_view_get_window_105;
  return_value_gtk_text_view_get_window_105=gtk_text_view_get_window((struct _GtkTextView *)return_value_g_type_check_instance_cast_104, (enum anonymous)GTK_TEXT_WINDOW_TEXT);
  gdk_window_set_cursor(return_value_gtk_text_view_get_window_105, crosshair);
  gdk_cursor_unref(crosshair);
  unsigned long int return_value_gtk_window_get_type_106;
  return_value_gtk_window_get_type_106=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_107;
  return_value_g_type_check_instance_cast_107=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_106);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_107, argv[(signed long int)0]);
  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    if((signed int)Seefile->type == 82)
      opt=loadfile(0);

    else
      opt=loadman(0);
    if(!(opt == 0))
    {
      if(!(Config->filelist == ((char *)NULL)))
        update_filelist((struct anonymous_2 *)(void *)0, 0);

    }

    if(!(term == ((char *)NULL)) && !(opt == 0))
    {
      unsigned long int return_value_gtk_entry_get_type_108;
      return_value_gtk_entry_get_type_108=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_109;
      return_value_g_type_check_instance_cast_109=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_108);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_109, term);
      searchlight();
    }

    if(!(term == ((char *)NULL)))
      free((void *)term);

  }

  else
    showconfig(Config);
  if(server == -666)
    error_popup("Could not start server.");

  gtk_main();
  return 0;
}

// mainmenu
// file see.c line 1418
void mainmenu()
{
  struct _GtkWidget *item1;
  struct _GtkWidget *item2;
  struct _GtkWidget *item3;
  struct _GtkWidget *item4;
  struct _GtkWidget *item5;
  struct _GtkWidget *item6;
  struct _GtkWidget *item7;
  struct _GtkWidget *item8;
  struct _GtkWidget *item9;
  struct _GtkWidget *item17;
  struct _GtkWidget *item18;
  struct _GtkWidget *item10;
  struct _GtkWidget *item11;
  struct _GtkWidget *item12;
  struct _GtkWidget *item13;
  struct _GtkWidget *item14;
  struct _GtkWidget *item15;
  struct _GtkWidget *item16;
  struct _GtkWidget *item19;
  struct _GtkWidget *sp1;
  struct _GtkWidget *sp2;
  struct _GtkWidget *notshown;
  struct _GtkAccelGroup *keymacros;
  keymacros=gtk_accel_group_new();
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, keymacros);
  unsigned long int return_value_gtk_menu_get_type_3;
  return_value_gtk_menu_get_type_3=gtk_menu_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_get_type_3);
  gtk_menu_set_accel_group((struct _GtkMenu *)return_value_g_type_check_instance_cast_4, keymacros);
  notshown=gtk_menu_item_new();
  unsigned long int return_value_gtk_menu_shell_get_type_5;
  return_value_gtk_menu_shell_get_type_5=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_5);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_6, notshown);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)notshown, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_7, "activate", (void (*)(void))grabfocus, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(notshown, "activate", keymacros, (unsigned int)0x02f, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)0);
  item12=gtk_menu_item_new_with_label("file list");
  unsigned long int return_value_gtk_menu_shell_get_type_8;
  return_value_gtk_menu_shell_get_type_8=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_8);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_9, item12);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)item12, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_10, "activate", (void (*)(void))showlist, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item12, "activate", keymacros, (unsigned int)0x066, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  if(!(Config->seedata == ((char *)NULL)))
  {
    item6=gtk_menu_item_new_with_label("see bookmarks");
    unsigned long int return_value_gtk_menu_shell_get_type_11;
    return_value_gtk_menu_shell_get_type_11=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
    return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_11);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_12, item6);
    struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
    return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)item6, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_13, "activate", (void (*)(void))bookmark_list, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    gtk_widget_add_accelerator(item6, "activate", keymacros, (unsigned int)0x073, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
    item5=gtk_menu_item_new_with_label("place bookmark");
    unsigned long int return_value_gtk_menu_shell_get_type_14;
    return_value_gtk_menu_shell_get_type_14=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
    return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_14);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_15, item5);
    struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)item5, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_16, "activate", (void (*)(void))placebmk, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    gtk_widget_add_accelerator(item5, "activate", keymacros, (unsigned int)0x06d, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  }

  item4=gtk_menu_item_new_with_label("reload");
  unsigned long int return_value_gtk_menu_shell_get_type_17;
  return_value_gtk_menu_shell_get_type_17=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_17);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_18, item4);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)item4, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_19, "activate", (void (*)(void))reload, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item4, "activate", keymacros, (unsigned int)0x06c, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item17=gtk_menu_item_new_with_label("copy selection");
  unsigned long int return_value_gtk_menu_shell_get_type_20;
  return_value_gtk_menu_shell_get_type_20=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_20);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_21, item17);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)item17, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_22, "activate", (void (*)(void))copytoX, NULL, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item17, "activate", keymacros, (unsigned int)0x063, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item18=gtk_menu_item_new_with_label("copy all");
  unsigned long int return_value_gtk_menu_shell_get_type_23;
  return_value_gtk_menu_shell_get_type_23=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_23);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_24, item18);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)item18, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_25, "activate", (void (*)(void))copytoX, (void *)(signed int *)1, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item18, "activate", keymacros, (unsigned int)0x063, (enum anonymous_0)GDK_MOD1_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item11=gtk_menu_item_new_with_label("apropos search");
  unsigned long int return_value_gtk_menu_shell_get_type_26;
  return_value_gtk_menu_shell_get_type_26=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_26);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_27, item11);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)item11, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_28, "activate", (void (*)(void))apropos, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item11, "activate", keymacros, (unsigned int)0x061, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item13=gtk_menu_item_new_with_label("previous found");
  unsigned long int return_value_gtk_menu_shell_get_type_29;
  return_value_gtk_menu_shell_get_type_29=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_29);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_30, item13);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)item13, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_31, "activate", (void (*)(void))cursor_tofound, (void *)(signed int *)1, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item13, "activate", keymacros, (unsigned int)0x070, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item14=gtk_menu_item_new_with_label("next find");
  unsigned long int return_value_gtk_menu_shell_get_type_32;
  return_value_gtk_menu_shell_get_type_32=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_32);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_33, item14);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)item14, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_34, "activate", (void (*)(void))cursor_tofound, NULL, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item14, "activate", keymacros, (unsigned int)0x06e, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item19=gtk_menu_item_new_with_label("goto cursor");
  unsigned long int return_value_gtk_menu_shell_get_type_35;
  return_value_gtk_menu_shell_get_type_35=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
  return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_35);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_36, item19);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)item19, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_37, "activate", (void (*)(void))gotoCursor, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item19, "activate", keymacros, (unsigned int)0x067, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item3=gtk_menu_item_new_with_label("(un)number lines");
  unsigned long int return_value_gtk_menu_shell_get_type_38;
  return_value_gtk_menu_shell_get_type_38=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_38);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_39, item3);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)item3, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_40, "activate", (void (*)(void))numberlines, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item3, "activate", keymacros, (unsigned int)0x033, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item7=gtk_menu_item_new_with_label("bold blue");
  unsigned long int return_value_gtk_menu_shell_get_type_41;
  return_value_gtk_menu_shell_get_type_41=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
  return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_41);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_42, item7);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)item7, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_43, "activate", (void (*)(void))highlight, (void *)"boldblue", (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item7, "activate", keymacros, (unsigned int)0x068, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item8=gtk_menu_item_new_with_label("italic red");
  unsigned long int return_value_gtk_menu_shell_get_type_44;
  return_value_gtk_menu_shell_get_type_44=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_45;
  return_value_g_type_check_instance_cast_45=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_44);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_45, item8);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
  return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)item8, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_46, "activate", (void (*)(void))highlight, (void *)"italred", (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item8, "activate", keymacros, (unsigned int)0x068, (enum anonymous_0)GDK_MOD1_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item9=gtk_menu_item_new_with_label("untag");
  unsigned long int return_value_gtk_menu_shell_get_type_47;
  return_value_gtk_menu_shell_get_type_47=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_48;
  return_value_g_type_check_instance_cast_48=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_47);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_48, item9);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_49;
  return_value_g_type_check_instance_cast_49=g_type_check_instance_cast((struct _GTypeInstance *)item9, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_49, "activate", (void (*)(void))removetags, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item9, "activate", keymacros, (unsigned int)0x075, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item10=gtk_menu_item_new_with_label("wrap mode");
  unsigned long int return_value_gtk_menu_shell_get_type_50;
  return_value_gtk_menu_shell_get_type_50=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_51;
  return_value_g_type_check_instance_cast_51=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_50);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_51, item10);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_52;
  return_value_g_type_check_instance_cast_52=g_type_check_instance_cast((struct _GTypeInstance *)item10, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_52, "activate", (void (*)(void))setwrapmode, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item10, "activate", keymacros, (unsigned int)0x077, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item1=gtk_menu_item_new_with_label("send to editor");
  unsigned long int return_value_gtk_menu_shell_get_type_53;
  return_value_gtk_menu_shell_get_type_53=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
  return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_53);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_54, item1);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_55;
  return_value_g_type_check_instance_cast_55=g_type_check_instance_cast((struct _GTypeInstance *)item1, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_55, "activate", (void (*)(void))toedit, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item1, "activate", keymacros, (unsigned int)0x065, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  signed int return_value_strcmp_62;
  if(!(Config->copyto == ((char *)NULL)))
  {
    return_value_strcmp_62=strcmp(Config->copyto, "Could not open!");
    if(!(return_value_strcmp_62 == 0))
    {
      sp1=gtk_menu_item_new_with_label("copy out");
      unsigned long int return_value_gtk_menu_shell_get_type_56;
      return_value_gtk_menu_shell_get_type_56=gtk_menu_shell_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_57;
      return_value_g_type_check_instance_cast_57=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_56);
      gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_57, sp1);
      struct _GTypeInstance *return_value_g_type_check_instance_cast_58;
      return_value_g_type_check_instance_cast_58=g_type_check_instance_cast((struct _GTypeInstance *)sp1, (unsigned long int)(20 << 2));
      g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_58, "activate", (void (*)(void))file_out, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
      gtk_widget_add_accelerator(sp1, "activate", keymacros, (unsigned int)0x06f, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
      sp2=gtk_menu_item_new_with_label("execute");
      unsigned long int return_value_gtk_menu_shell_get_type_59;
      return_value_gtk_menu_shell_get_type_59=gtk_menu_shell_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_60;
      return_value_g_type_check_instance_cast_60=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_59);
      gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_60, sp2);
      struct _GTypeInstance *return_value_g_type_check_instance_cast_61;
      return_value_g_type_check_instance_cast_61=g_type_check_instance_cast((struct _GTypeInstance *)sp2, (unsigned long int)(20 << 2));
      g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_61, "activate", (void (*)(void))exec_proc, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
      gtk_widget_add_accelerator(sp2, "activate", keymacros, (unsigned int)0x078, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
    }

  }

  item15=gtk_menu_item_new_with_label("reconfigure");
  unsigned long int return_value_gtk_menu_shell_get_type_63;
  return_value_gtk_menu_shell_get_type_63=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_64;
  return_value_g_type_check_instance_cast_64=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_63);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_64, item15);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_65;
  return_value_g_type_check_instance_cast_65=g_type_check_instance_cast((struct _GTypeInstance *)item15, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_65, "activate", (void (*)(void))reconfigure, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item15, "activate", keymacros, (unsigned int)0xffbf, (enum anonymous_0)0, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item16=gtk_menu_item_new_with_label("help");
  unsigned long int return_value_gtk_menu_shell_get_type_66;
  return_value_gtk_menu_shell_get_type_66=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_67;
  return_value_g_type_check_instance_cast_67=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_66);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_67, item16);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_68;
  return_value_g_type_check_instance_cast_68=g_type_check_instance_cast((struct _GTypeInstance *)item16, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_68, "activate", (void (*)(void))help, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item16, "activate", keymacros, (unsigned int)0xffbe, (enum anonymous_0)0, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  item2=gtk_menu_item_new_with_label("quit");
  unsigned long int return_value_gtk_menu_shell_get_type_69;
  return_value_gtk_menu_shell_get_type_69=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_70;
  return_value_g_type_check_instance_cast_70=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_shell_get_type_69);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_70, item2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_71;
  return_value_g_type_check_instance_cast_71=g_type_check_instance_cast((struct _GTypeInstance *)item2, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_71, "activate", (void (*)(void))handlequit, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_add_accelerator(item2, "activate", keymacros, (unsigned int)0x071, (enum anonymous_0)GDK_CONTROL_MASK, (enum anonymous_1)GTK_ACCEL_VISIBLE);
  gtk_widget_show_all(MMenu);
}

// mousevent
// file see.c line 1542
signed int mousevent(struct _GtkWidget *widget, struct _GdkEventButton *MoBt, void **data)
{
  struct _GtkTextIter togo;
  struct _GtkTextIter there;
  char *word;
  char *sec;
  char fname[4096l];
  struct _GdkCursor *text;
  text=gdk_cursor_new((enum anonymous_14)GDK_CROSSHAIR);
  if(MoBt->button == 3u)
  {
    unsigned long int return_value_gtk_menu_get_type_1;
    return_value_gtk_menu_get_type_1=gtk_menu_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MMenu, return_value_gtk_menu_get_type_1);
    gtk_menu_popup((struct _GtkMenu *)return_value_g_type_check_instance_cast_2, (struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0, (void (*)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *))(void *)0, (void *)0, (unsigned int)0, (unsigned int)0L);
    return (signed int)!(0 != 0);
  }

  if(MoBt->button == 1u)
  {
    if(!((signed int)MoBt->type == GDK_2BUTTON_PRESS))
      return 0;

    struct _GtkTextMark *return_value_gtk_text_buffer_get_insert_3;
    return_value_gtk_text_buffer_get_insert_3=gtk_text_buffer_get_insert(Tbuf);
    gtk_text_buffer_get_iter_at_mark(Tbuf, &there, return_value_gtk_text_buffer_get_insert_3);
    signed int return_value_gtk_text_iter_has_tag_4;
    return_value_gtk_text_iter_has_tag_4=gtk_text_iter_has_tag(&there, hlink);
    if(!(return_value_gtk_text_iter_has_tag_4 == 1))
      return 0;

    signed int return_value_gtk_text_iter_begins_tag_5;
    return_value_gtk_text_iter_begins_tag_5=gtk_text_iter_begins_tag(&there, hlink);
    if(!(return_value_gtk_text_iter_begins_tag_5 == 1))
      gtk_text_iter_backward_to_tag_toggle(&there, hlink);

    togo = there;
    gtk_text_iter_forward_to_tag_toggle(&togo, hlink);
    word=gtk_text_buffer_get_text(Tbuf, &there, &togo, 0);
    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(word, "manual page");
    if(return_value_strcmp_6 == 0)
    {
      loadnew("seetxt", "1", 0);
      return (signed int)!(0 != 0);
    }

    signed int return_value_strncmp_7;
    return_value_strncmp_7=strncmp(word, "the example", (unsigned long int)11);
    if(return_value_strncmp_7 == 0)
    {
      sprintf(fname, "%s/.seeconfig", (const void *)"/usr/share/seetxt-runtime");
      loadnew(fname, (char *)(void *)0, 0);
      return (signed int)!(0 != 0);
    }

    if((signed int)*word == 47)
    {
      strncpy(fname, word, (unsigned long int)4095);
      loadnew(fname, (char *)(void *)0, 0);
      return (signed int)!(0 != 0);
    }

    gtk_text_iter_forward_find_char(&there, (signed int (*)(unsigned int, void *))testuni, (void *)(signed short int *)40, (const struct _GtkTextIter *)(void *)0);
    gtk_text_iter_forward_find_char(&togo, (signed int (*)(unsigned int, void *))testuni, (void *)(signed short int *)41, (const struct _GtkTextIter *)(void *)0);
    sec=gtk_text_buffer_get_text(Tbuf, &there, &togo, 0);
    gtk_text_buffer_set_text(Tbuf, " ", 1);
    loadnew(word, &sec[(signed long int)1], 0);
    free((void *)word);
    free((void *)sec);
    unsigned long int return_value_gtk_text_view_get_type_8;
    return_value_gtk_text_view_get_type_8=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
    return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_8);
    struct _GdkDrawable *return_value_gtk_text_view_get_window_10;
    return_value_gtk_text_view_get_window_10=gtk_text_view_get_window((struct _GtkTextView *)return_value_g_type_check_instance_cast_9, (enum anonymous)GTK_TEXT_WINDOW_TEXT);
    gdk_window_set_cursor(return_value_gtk_text_view_get_window_10, text);
    gdk_cursor_unref(text);
    return (signed int)!(0 != 0);
  }

  return 0;
}

// nextfind
// file see.c line 1601
signed int nextfind(char *haystack, char *needle)
{
  signed int nlen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(needle);
  nlen = (signed int)return_value_strlen_1;
  signed int hslen;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(haystack);
  hslen = (signed int)return_value_strlen_2;
  signed int i;
  signed int ii;
  const signed long int ii_array_size0 = (signed long int)(nlen + 1);
  char copy[ii_array_size0];
  char UC = (char)0;
  unsigned long int return_value_gtk_toggle_button_get_type_3;
  return_value_gtk_toggle_button_get_type_3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)CaseTgl, return_value_gtk_toggle_button_get_type_3);
  signed int return_value_gtk_toggle_button_get_active_5;
  return_value_gtk_toggle_button_get_active_5=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_4);
  if(!(return_value_gtk_toggle_button_get_active_5 == 0))
    UC = (char)1;

  signed int return_value_tolower_6;
  if((signed int)UC == 0)
  {
    i = 0;
    for( ; !(i >= nlen); i = i + 1)
    {
      return_value_tolower_6=tolower((signed int)needle[(signed long int)i]);
      copy[(signed long int)i] = (char)return_value_tolower_6;
    }
  }

  else
    strcpy(copy, needle);
  if(Debug >= 3)
    fprintf(stderr, "nextfind() %ld, needle=%s\n", haystack - FileCon, needle);

  i = 0;
  _Bool tmp_if_expr_12;
  signed int return_value_tolower_11;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_8;
  signed int return_value_tolower_7;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  for( ; !(i >= hslen); i = i + 1)
  {
    if((signed int)UC == 0)
    {
      return_value_tolower_11=tolower((signed int)haystack[(signed long int)i]);
      tmp_if_expr_12 = return_value_tolower_11 == (signed int)copy[(signed long int)0] ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    if(tmp_if_expr_12)
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      if((signed int)UC == 1)
        tmp_if_expr_13 = haystack[(signed long int)i] == copy[(signed long int)0] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_13 = (_Bool)0;
      tmp_if_expr_14 = tmp_if_expr_13 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
    {
      ii = 1;
      for( ; !(ii >= nlen); ii = ii + 1)
      {
        if((signed int)UC == 0)
        {
          return_value_tolower_7=tolower((signed int)haystack[(signed long int)(i + ii)]);
          tmp_if_expr_8 = return_value_tolower_7 != (signed int)copy[(signed long int)ii] ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          if((signed int)UC == 1)
            tmp_if_expr_9 = haystack[(signed long int)(i + ii)] != copy[(signed long int)ii] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_9 = (_Bool)0;
          tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
          break;

        else
          if(ii == nlen + -1)
            return i;

      }
    }

  }
  return -1;
}

// nomax
// file see.c line 1593
signed int nomax(struct _GtkWidget *widget, struct _GdkEventWindowState *ptr, void **data)
{
  unsigned char newstate = (unsigned char)ptr->new_window_state;
  newstate = newstate & (unsigned char)4;
  unsigned long int return_value_gtk_window_get_type_1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  if(!(newstate == 0))
  {
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
    gtk_window_unmaximize((struct _GtkWindow *)return_value_g_type_check_instance_cast_2);
  }

  newstate = newstate & (unsigned char)16;
  unsigned long int return_value_gtk_window_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  if(!(newstate == 0))
  {
    return_value_gtk_window_get_type_3=gtk_window_get_type();
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_3);
    gtk_window_unfullscreen((struct _GtkWindow *)return_value_g_type_check_instance_cast_4);
  }

  return (signed int)!(0 != 0);
}

// numberlines
// file see.c line 1623
void numberlines()
{
  struct _GtkTextIter lstrt;
  struct _GtkTextIter Nend;
  char lnum[6l];
  signed int i;
  signed int nlen;
  signed int nofl;
  if(!(FileCon == ((char *)NULL)))
  {
    nofl=buflen(FileCon);
    if(!(nofl >= 100000))
    {
      if(LNsw == 0)
      {
        LNsw = 1;
        i = 0;
        for( ; !(i >= nofl); i = i + 1)
        {
          sprintf(lnum, "%5d ", i + 1);
          unsigned long int return_value_strlen_1;
          return_value_strlen_1=strlen(lnum);
          nlen = (signed int)return_value_strlen_1;
          gtk_text_buffer_get_iter_at_line(Tbuf, &lstrt, i);
          gtk_text_buffer_insert_with_tags(Tbuf, &lstrt, lnum, nlen, lnnm, (void *)0);
        }
      }

      else
      {
        LNsw = 0;
        i = 0;
        for( ; !(i >= nofl); i = i + 1)
        {
          gtk_text_buffer_get_iter_at_line(Tbuf, &lstrt, i);
          gtk_text_buffer_get_iter_at_line_offset(Tbuf, &Nend, i, 5);
          gtk_text_buffer_delete(Tbuf, &lstrt, &Nend);
        }
      }
    }

  }

}

// onenwline
// file util.c line 126
void onenwline(char *buffer)
{
  signed int i;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buffer);
  len = (signed int)return_value_strlen_1;
  i = 0;
  for( ; !(i >= len); i = i + 1)
    if((signed int)buffer[(signed long int)i] == 10)
    {
      buffer[(signed long int)i] = (char)0;
      break;
    }

}

// placebmk
// file see.c line 1646
void placebmk()
{
  signed int num = bookmarks[(signed long int)0] + 1;
  signed int ln;
  ln=cursorline();
  signed int i;
  char messg[25l];
  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    i = 1;
    for( ; *bookmarks >= i; i = i + 1)
      if(bookmarks[(signed long int)i] == 1 + ln)
        goto __CPROVER_DUMP_L5;

    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)bookmarks, (unsigned long int)(num + 1));
    bookmarks = (signed int *)return_value_realloc_1;
    bookmarks[(signed long int)num] = ln + 1;
    bookmarks[(signed long int)0] = bookmarks[(signed long int)0] + 1;
    sprintf(messg, "Bookmark set at line %d", ln + 1);
    unsigned long int return_value_gtk_window_get_type_2;
    return_value_gtk_window_get_type_2=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
    return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_2);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_3, messg);
    savebmks((struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0);
  }


__CPROVER_DUMP_L5:
  ;
}

// reconfigure
// file see.c line 1659
struct anonymous_16 * reconfigure(struct _GtkWidget *ignored)
{
  signed int DBL;
  signed int i;
  signed int tmp;
  signed int servon = 0;
  struct _PangoFontDescription *Tfont;
  struct _IO_FILE *fstRO;
  struct __dirstream *test;
  const char *homedir;
  homedir=g_get_home_dir();
  char configfile[4096l];
  char *tok;
  char *line;
  signed long int now;
  now=time((signed long int *)(void *)0);
  struct tm *tp;
  tp=localtime(&now);
  signed int pid;
  pid=getpid();
  struct _GdkColor textback;
  struct anonymous_2 *old;
  struct anonymous_16 *r;
  void *return_value_ec_malloc_1;
  return_value_ec_malloc_1=ec_malloc(sizeof(struct anonymous_16) /*192ul*/ );
  r = (struct anonymous_16 *)return_value_ec_malloc_1;
  memset((void *)r, 0, sizeof(struct anonymous_16) /*192ul*/ );
  if(!(Config == ((struct anonymous_16 *)NULL)) && !(Gio == ((struct _GIOChannel *)NULL)))
  {
    if(!(Config->sock[0l] == 0))
    {
      tglServer((struct _GtkWidget *)(void *)0, -1);
      servon = 1;
    }

  }

  if(!(Config == ((struct anonymous_16 *)NULL)) && !(ignored == ((struct _GtkWidget *)NULL)))
  {
    if(!(Config->txtfnt == ((char *)NULL)))
      free((void *)Config->txtfnt);

    if(!(Config->tbcolor == ((const char *)NULL)))
      free((void *)(char *)Config->tbcolor);

    if(!(Config->filelist == ((char *)NULL)))
      free((void *)Config->filelist);

    if(!(Config->editor == ((char *)NULL)))
      free((void *)Config->editor);

    if(!(Config->copyto == ((char *)NULL)))
      free((void *)Config->copyto);

    if(!(Config->seedata == ((char *)NULL)))
      free((void *)Config->seedata);

    free((void *)Config);
  }

  r->width = 700;
  r->height = 700;
  r->wrap = (char)87;
  r->bConfirm = (char)0;
  r->bRedirect = (char)1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen("/usr/share/seetxt-runtime");
  void *return_value_ec_malloc_3;
  return_value_ec_malloc_3=ec_malloc(return_value_strlen_2 + (unsigned long int)16);
  r->filelist = (char *)return_value_ec_malloc_3;
  strcpy(r->filelist, "/usr/share/seetxt-runtime");
  strcat(r->filelist, "/filelist");
  r->editor=strdup("gedit");
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(homedir);
  if(!(return_value_strlen_4 >= 98ul))
    sprintf(r->sock, "%s/.seesock", homedir);

  tmp=file_check(r->sock);
  if(!(tmp == 49152) && !(tmp == -2))
    r->sock[(signed long int)0] = (char)0;

  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(homedir);
  void *return_value_ec_malloc_6;
  return_value_ec_malloc_6=ec_malloc(return_value_strlen_5 + (unsigned long int)10);
  r->seedata = (char *)return_value_ec_malloc_6;
  sprintf(r->seedata, "%s/.seedata", homedir);
  sprintf(configfile, "%s/.seeconfig", homedir);
  fstRO=fopen(configfile, "r");
  signed int return_value_strcasecmp_31;
  signed long int return_value_strtol_9;
  signed int return_value_strcasecmp_30;
  signed int return_value_strcasecmp_29;
  signed int return_value_strcasecmp_28;
  signed int return_value_strncmp_27;
  signed int return_value_strcasecmp_26;
  signed int return_value_strcasecmp_25;
  signed int return_value_strcasecmp_24;
  signed int return_value_strcasecmp_23;
  signed int return_value_strcasecmp_22;
  signed int return_value_strcasecmp_21;
  signed int return_value_strcasecmp_17;
  signed int return_value_strcasecmp_16;
  signed int return_value_strcasecmp_20;
  signed int return_value_strncmp_19;
  unsigned long int return_value_gtk_window_get_type_33;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  if(!(fstRO == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      line=linein(fstRO);
      if(line == ((char *)NULL))
        break;

      tok=strtok(line, ":");
      signed int return_value_strcasecmp_32;
      return_value_strcasecmp_32=strcasecmp(tok, "text font");
      if(return_value_strcasecmp_32 == 0)
      {
        tok=strtok((char *)(void *)0, ":\n");
        if(!(tok == ((char *)NULL)))
        {
          for( ; (signed int)*tok == 32; tok = tok + 1l)
            ;
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(tok);
          void *return_value_ec_malloc_8;
          return_value_ec_malloc_8=ec_malloc(return_value_strlen_7 + (unsigned long int)1);
          r->txtfnt = (char *)return_value_ec_malloc_8;
          strcpy(r->txtfnt, tok);
        }

      }

      else
      {
        return_value_strcasecmp_31=strcasecmp(tok, "watch interval");
        if(return_value_strcasecmp_31 == 0)
        {
          tok=strtok((char *)(void *)0, ":\n");
          if(!(tok == ((char *)NULL)))
          {
            return_value_strtol_9=strtol((const char *)tok, (char ** restrict )(void *)0, 10);
            r->watchtime = (signed int)return_value_strtol_9;
          }

        }

        else
        {
          return_value_strcasecmp_30=strcasecmp(tok, "dimensions");
          if(return_value_strcasecmp_30 == 0)
          {
            tok=strtok((char *)(void *)0, ":\n");
            if(!(tok == ((char *)NULL)))
            {
              tmp=sscanf(tok, "%d%[x ]%d", &i, (const void *)configfile, &DBL);
              if(tmp == 0)
                continue;

              if(i >= 1 && !(i >= 9999))
                r->width = i;

              if(tmp == 1)
                continue;

              if(DBL >= 1 && !(DBL >= 9999))
                r->height = DBL;

            }

          }

          else
          {
            return_value_strcasecmp_29=strcasecmp(tok, "seedata");
            if(return_value_strcasecmp_29 == 0)
            {
              tok=strtok((char *)(void *)0, ": \n");
              if(!(tok == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_10;
                return_value_strlen_10=strlen(tok);
                tmp = (signed int)return_value_strlen_10;
                if(tmp >= 4097)
                  continue;

                free((void *)r->seedata);
                void *return_value_ec_malloc_11;
                return_value_ec_malloc_11=ec_malloc((unsigned long int)(tmp + 1));
                r->seedata = (char *)return_value_ec_malloc_11;
                strcpy(r->seedata, tok);
              }

            }

            else
            {
              return_value_strcasecmp_28=strcasecmp(tok, "filelist");
              if(return_value_strcasecmp_28 == 0)
              {
                tok=strtok((char *)(void *)0, ": \n");
                if(!(tok == ((char *)NULL)))
                {
                  free((void *)r->filelist);
                  r->filelist=strdup(tok);
                }

              }

              else
              {
                return_value_strncmp_27=strncmp(tok, "no confirm", (unsigned long int)10);
                if(return_value_strncmp_27 == 0)
                  r->bConfirm = (char)1;

                else
                {
                  return_value_strcasecmp_26=strcasecmp(tok, "seesocket");
                  if(return_value_strcasecmp_26 == 0)
                  {
                    tok=strtok((char *)(void *)0, ": \n");
                    if(tok == ((char *)NULL))
                      continue;

                    unsigned long int return_value_strlen_12;
                    return_value_strlen_12=strlen(tok);
                    if(return_value_strlen_12 >= 108ul)
                      continue;

                    tmp=file_check(tok);
                    if(!(tmp == 49152) && !(tmp == -2))
                      continue;

                    strncpy(r->sock, tok, (unsigned long int)107);
                  }

                  else
                  {
                    return_value_strcasecmp_25=strcasecmp(tok, "Debuglog");
                    if(return_value_strcasecmp_25 == 0)
                    {
                      tok=strtok((char *)(void *)0, ": \n");
                      if(tok == ((char *)NULL))
                        continue;

                      DBL=open(tok, 0100 | 01, 0400 | 0200);
                      if(!(DBL >= 3))
                        continue;

                      printf("switching stdout & stderr to %s", tok);
                      dup2(DBL, 1);
                      dup2(DBL, 2);
                      lseek(DBL, (signed long int)0, 2);
                      printf("\n******* pid %d -- %d:%02d *******\n", pid, tp->tm_hour, tp->tm_min);
                    }

                    else
                    {
                      return_value_strcasecmp_24=strcasecmp(tok, "editor");
                      if(return_value_strcasecmp_24 == 0)
                      {
                        tok=strtok((char *)(void *)0, "\n");
                        if(tok == ((char *)NULL))
                          continue;

                        for( ; (signed int)*tok == 32; tok = tok + 1l)
                          ;
                        free((void *)r->editor);
                        r->editor=strdup(tok);
                      }

                      else
                      {
                        return_value_strcasecmp_23=strcasecmp(tok, "background");
                        if(return_value_strcasecmp_23 == 0)
                        {
                          tok=strtok((char *)(void *)0, ": \n");
                          if(tok == ((char *)NULL))
                            continue;

                          unsigned long int return_value_strlen_13;
                          return_value_strlen_13=strlen(tok);
                          void *return_value_ec_malloc_14;
                          return_value_ec_malloc_14=ec_malloc(return_value_strlen_13 + (unsigned long int)1);
                          r->tbcolor = (const char *)return_value_ec_malloc_14;
                          strcpy((char *)r->tbcolor, tok);
                        }

                        else
                        {
                          return_value_strcasecmp_22=strcasecmp(tok, "tail at");
                          if(return_value_strcasecmp_22 == 0)
                          {
                            tok=strtok((char *)(void *)0, ": \n");
                            if(tok == ((char *)NULL))
                              continue;

                            signed long int return_value_strtol_15;
                            return_value_strtol_15=strtol((const char *)tok, (char ** restrict )(void *)0, 10);
                            r->tailat = (signed int)return_value_strtol_15;
                          }

                          else
                          {
                            return_value_strcasecmp_21=strcasecmp(tok, "wrap");
                            if(return_value_strcasecmp_21 == 0)
                            {
                              tok=strtok((char *)(void *)0, ": \n");
                              if(tok == ((char *)NULL))
                                continue;

                              signed int return_value_strcasecmp_18;
                              return_value_strcasecmp_18=strcasecmp(tok, "exact");
                              if(return_value_strcasecmp_18 == 0)
                                r->wrap = (char)69;

                              else
                              {
                                return_value_strcasecmp_17=strcasecmp(tok, "word");
                                if(return_value_strcasecmp_17 == 0)
                                  r->wrap = (char)87;

                                else
                                {
                                  return_value_strcasecmp_16=strcasecmp(tok, "none");
                                  if(return_value_strcasecmp_16 == 0)
                                    r->wrap = (char)78;

                                }
                              }
                            }

                            else
                            {
                              return_value_strcasecmp_20=strcasecmp(tok, "copy to");
                              if(return_value_strcasecmp_20 == 0)
                              {
                                tok=strtok((char *)(void *)0, ": \n");
                                if(tok == ((char *)NULL))
                                  continue;

                                test=opendir((const char *)tok);
                                if(test == ((struct __dirstream *)NULL))
                                {
                                  r->copyto=strdup("Could not open!");
                                  continue;
                                }

                                closedir(test);
                                r->copyto=strdup(tok);
                              }

                              else
                              {
                                return_value_strncmp_19=strncmp(tok, "no redirect", (unsigned long int)11);
                                if(return_value_strncmp_19 == 0)
                                  r->bRedirect = (char)0;

                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      free((void *)line);
    }
    while((_Bool)1);
    fclose(fstRO);
  }

  else
  {
    sprintf(configfile, "No %s/.seeconfig found.", homedir);
    puts(configfile);
    if(!(ignored == ((struct _GtkWidget *)NULL)))
    {
      return_value_gtk_window_get_type_33=gtk_window_get_type();
      return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_33);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_34, configfile);
    }

  }
  if(ignored == ((struct _GtkWidget *)NULL))
    return r;

  else
  {
    if(!(r->txtfnt == ((char *)NULL)))
    {
      Tfont=pango_font_description_from_string(r->txtfnt);
      gtk_widget_modify_font(TxT, Tfont);
      pango_font_description_free(Tfont);
    }

    unsigned long int return_value_gtk_widget_get_type_35;
    return_value_gtk_widget_get_type_35=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
    return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_widget_get_type_35);
    gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast_36, r->width, r->height);
    if(!(r->tbcolor == ((const char *)NULL)))
    {
      signed int return_value_gdk_color_parse_37;
      return_value_gdk_color_parse_37=gdk_color_parse(r->tbcolor, &textback);
      if(!(return_value_gdk_color_parse_37 == 0))
        gtk_widget_modify_base(TxT, (enum anonymous_17)GTK_STATE_NORMAL, &textback);

    }

    changewrapmode((struct _GtkWidget *)(void *)0, r->wrap);
    Config = r;
    if(!(Seefile == ((struct anonymous_2 *)NULL)))
    {
      old=SFcopy(Seefile);
      free((void *)Seefile);
      Seefile = (struct anonymous_2 *)(void *)0;
      i=cursorline();
      update_filelist(old, i);
      free((void *)old);
    }

    clear(1);
    showconfig(r);
    if(!(servon == 0))
    {
      if(!(Config->sock[0l] == 0))
        tglServer((struct _GtkWidget *)(void *)0, 0);

    }

    return (struct anonymous_16 *)(void *)0;
  }
}

// regexp
// file main.h line 178
signed int regexp(char *string, char *patrn)
{
  signed int len = 0;
  struct re_pattern_buffer rgT;
  struct anonymous_24 match;
  regcomp(&rgT, patrn, 1);
  signed int return_value_regexec_1;
  return_value_regexec_1=regexec(&rgT, (char *)string, (unsigned long int)1, &match, 0);
  if(return_value_regexec_1 == 0)
  {
    rgxp.bgn = (signed int)match.rm_so;
    rgxp.end = (signed int)match.rm_eo;
    len = rgxp.end - rgxp.bgn;
  }

  regfree(&rgT);
  if(Debug >= 2)
    g_print("regexp() B=%d E=%d returning %d\n", rgxp.bgn, rgxp.end, len);

  return len;
}

// reload
// file see.c line 1832
signed int reload()
{
  signed int lnum;
  signed int return_value_filelen_4;
  if(Seefile == ((struct anonymous_2 *)NULL))
  {
    if(!(watchSW == 0))
      watchfile();

    return (signed int)!(0 != 0);
  }

  else
  {
    if(Debug >= 2)
    {
      g_print("reload() %s\n", (const void *)Seefile->path);
      fflush(stdout);
    }

    if((signed int)Seefile->type == 82)
    {
      return_value_filelen_4=filelen(Seefile->path);
      if(!(Config->tailat >= return_value_filelen_4))
      {
        unsigned long int return_value_gtk_window_get_type_1;
        return_value_gtk_window_get_type_1=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
        return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_1);
        gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "large file: tailed, not reloaded");
        signed int return_value_tailfile_3;
        return_value_tailfile_3=tailfile();
        return return_value_tailfile_3;
      }

    }

    lnum=cursorline();
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    gtk_text_buffer_delete(Tbuf, &start, &finish);
    if((signed int)Seefile->type == 82)
      loadfile(lnum);

    else
      loadman(lnum);
    if(watchSW == 0)
      return 0;

    else
      return (signed int)!(0 != 0);
  }
}

// removetags
// file see.c line 1823
void removetags(struct _GtkWidget *widget, void **data)
{
  struct _GtkTextIter Ts;
  struct _GtkTextIter Te;
  gtk_text_buffer_get_selection_bounds(Tbuf, &Ts, &Te);
  gtk_text_buffer_remove_tag(Tbuf, boldblue, &Ts, &Te);
  gtk_text_buffer_remove_tag(Tbuf, italred, &Ts, &Te);
  savebmks((struct _GtkWidget *)(void *)0, (struct _GtkWidget *)(void *)0);
}

// rescanFileList
// file see.c line 1860
void rescanFileList()
{
  struct _GtkTreeView *tv;
  tv=gtk_tree_selection_get_tree_view(Nbar.select);
  struct _GtkListStore *ls;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model_1;
  return_value_gtk_tree_view_get_model_1=gtk_tree_view_get_model(tv);
  ls = (struct _GtkListStore *)return_value_gtk_tree_view_get_model_1;
  gtk_list_store_clear(ls);
  list2view(ls);
}

// returnline
// file main.h line 179
char * returnline(char *file, char *match)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(match);
  len = (signed int)return_value_strlen_1;
  char *line;
  char *retline;
  struct _IO_FILE *fstRO;
  fstRO=fopen(file, "r");
  if(fstRO == ((struct _IO_FILE *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      line=linein(fstRO);
      if(line == ((char *)NULL))
        break;

      if(Debug >= 3)
        fprintf(stderr, "returnline() %d...\"%s\" \"%s\"\n", len, match, line);

      signed int return_value_strncmp_5;
      return_value_strncmp_5=strncmp(line, match, (unsigned long int)len);
      if(return_value_strncmp_5 == 0)
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(line);
        void *return_value_ec_malloc_3;
        return_value_ec_malloc_3=ec_malloc((return_value_strlen_2 - (unsigned long int)len) + (unsigned long int)1);
        retline = (char *)return_value_ec_malloc_3;
        strcpy(retline, &line[(signed long int)len]);
        free((void *)line);
        signed int return_value_fclose_4;
        return_value_fclose_4=fclose(fstRO);
        if(!(return_value_fclose_4 == 0))
          perror("see.h: in returnline() fclose fail");

        return retline;
      }

      free((void *)line);
    }
    while((_Bool)1);
    signed int return_value_fclose_6;
    return_value_fclose_6=fclose(fstRO);
    if(!(return_value_fclose_6 == 0))
      perror("see.h: in returnline() fclose fail");

    return (char *)(void *)0;
  }
}

// savebmks
// file see.c line 1868
void savebmks(struct _GtkWidget *widget, struct _GtkWidget *subwin)
{
  signed int i;
  struct _IO_FILE *fstRO;
  struct _IO_FILE *fstW;
  const char *homedir;
  homedir=g_get_home_dir();
  signed long int line_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(homedir);
  line_array_size0 = (signed long int)(return_value_strlen_1 + (unsigned long int)8);
  char *line;
  char tmp[line_array_size0];
  char seeline[8192l];
  char tagline[4096l];
  char *sptr;
  char num[7l];
  if(!(subwin == ((struct _GtkWidget *)NULL)))
    gtk_widget_destroy(subwin);

  if(!(Seefile == ((struct anonymous_2 *)NULL)))
  {
    if((signed int)Seefile->type == 82)
      sptr = Seefile->path;

    else
      sptr = Seefile->name;
    sprintf(tmp, "%s/.SeeTP", homedir);
    if(Config->seedata == ((char *)NULL))
    {
      unsigned long int return_value_gtk_window_get_type_2;
      return_value_gtk_window_get_type_2=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
      return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_2);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_3, "No personal \"seedata\" file, your bookmarks cannot be saved");
      goto __CPROVER_DUMP_L21;
    }

    fstRO=fopen(Config->seedata, "r");
    if(fstRO == ((struct _IO_FILE *)NULL))
    {
      unsigned long int return_value_gtk_window_get_type_4;
      return_value_gtk_window_get_type_4=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
      return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_4);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_5, "Could not open your \"seedata\" file!");
      goto __CPROVER_DUMP_L21;
    }

    fstW=fopen(tmp, "w");
    if(fstW == ((struct _IO_FILE *)NULL))
    {
      unsigned long int return_value_gtk_window_get_type_6;
      return_value_gtk_window_get_type_6=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
      return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_6);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_7, "Could not create temp file, your bookmarks will not be saved");
      fclose(fstRO);
      goto __CPROVER_DUMP_L21;
    }

    do
    {
      line=linein(fstRO);
      if(line == ((char *)NULL))
        break;

      if((signed int)*line == 10)
        free((void *)line);

      else
      {
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(sptr);
        signed int return_value_strncmp_9;
        return_value_strncmp_9=strncmp(line, sptr, return_value_strlen_8);
        if(!(return_value_strncmp_9 == 0))
          fprintf(fstW, "%s", line);

        free((void *)line);
      }
    }
    while((_Bool)1);
    fclose(fstRO);
    sprintf(seeline, "%s*%d", sptr, bookmarks[(signed long int)0]);
    if(*bookmarks >= 1)
    {
      i = 1;
      for( ; *bookmarks >= i; i = i + 1)
        if(!(bookmarks[(signed long int)i] == 0))
        {
          sprintf(num, "*%d", bookmarks[(signed long int)i]);
          strcat(seeline, num);
        }

    }

    if(Debug >= 1)
      g_print("savebmks()...\n");

    if(LNsw == 1)
    {
      numberlines();
      LNsw = 1;
    }

    signed int return_value_getagcoords_10;
    return_value_getagcoords_10=getagcoords(boldblue, tagline);
    if(return_value_getagcoords_10 >= 1)
      strcat(seeline, tagline);

    signed int return_value_getagcoords_11;
    return_value_getagcoords_11=getagcoords(italred, tagline);
    if(return_value_getagcoords_11 >= 1)
      strcat(seeline, tagline);

    if(LNsw == 1)
    {
      LNsw = 0;
      numberlines();
    }

    fprintf(fstW, "%s\n", (const void *)seeline);
    fclose(fstW);
    signed int return_value_copytmp_12;
    return_value_copytmp_12=copytmp(tmp, Config->seedata);
    if(!(return_value_copytmp_12 == 0))
      error_popup("in bookmarks(): copytmp()\nfclose or unlink failed");

    unsigned long int return_value_gtk_window_get_type_13;
    return_value_gtk_window_get_type_13=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
    return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_13);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_14, "Bookmarks saved");
  }


__CPROVER_DUMP_L21:
  ;
}

// scrollToIter
// file see.c line 1934
void scrollToIter(struct _GtkTextIter *iter)
{
  struct _GtkAdjustment *vadj;
  unsigned long int return_value_gtk_scrolled_window_get_type_1;
  return_value_gtk_scrolled_window_get_type_1=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_scrolled_window_get_type_1);
  vadj=gtk_scrolled_window_get_vadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_2);
  struct _GtkAdjustment *hadj;
  unsigned long int return_value_gtk_scrolled_window_get_type_3;
  return_value_gtk_scrolled_window_get_type_3=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)Scroll, return_value_gtk_scrolled_window_get_type_3);
  hadj=gtk_scrolled_window_get_hadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_4);
  struct _GdkRectangle goal;
  double x;
  double y;
  double hpage;
  hpage=gtk_adjustment_get_page_size(hadj);
  double vpage;
  vpage=gtk_adjustment_get_page_size(vadj);
  double maxx;
  double return_value_gtk_adjustment_get_upper_5;
  return_value_gtk_adjustment_get_upper_5=gtk_adjustment_get_upper(hadj);
  maxx = return_value_gtk_adjustment_get_upper_5 - hpage;
  double maxy;
  double return_value_gtk_adjustment_get_upper_6;
  return_value_gtk_adjustment_get_upper_6=gtk_adjustment_get_upper(vadj);
  maxy = return_value_gtk_adjustment_get_upper_6 - vpage;
  unsigned long int return_value_gtk_text_view_get_type_7;
  return_value_gtk_text_view_get_type_7=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_7);
  gtk_text_view_get_iter_location((struct _GtkTextView *)return_value_g_type_check_instance_cast_8, iter, &goal);
  x = (double)goal.x;
  y = (double)goal.y - vpage / (double)2;
  if(x < hpage + -50.000000)
    x = (double)0;

  else
    if(x > maxx)
      x = maxx;

  if(y > maxy)
    y = maxy;

  gtk_adjustment_set_value(hadj, x);
  gtk_adjustment_set_value(vadj, y);
}

// scrolltoline
// file see.c line 1958
void scrolltoline(struct _GtkWidget *widget, signed int line)
{
  struct _GtkTextIter where;
  struct _GtkTextMark *goal;
  gtk_text_buffer_get_iter_at_line(Tbuf, &where, line);
  goal=gtk_text_buffer_create_mark(Tbuf, "goal", &where, 0);
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_1);
  unsigned long int return_value_gtk_text_mark_get_type_3;
  return_value_gtk_text_mark_get_type_3=gtk_text_mark_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)goal, return_value_gtk_text_mark_get_type_3);
  gtk_text_view_scroll_to_mark((struct _GtkTextView *)return_value_g_type_check_instance_cast_2, (struct _GtkTextMark *)return_value_g_type_check_instance_cast_4, 0.0, (signed int)!(0 != 0), 0.0, 0.5);
  gtk_text_buffer_place_cursor(Tbuf, &where);
}

// searchlight
// file see.c line 1968
void searchlight()
{
  struct _GdkDisplay *display;
  display=gdk_display_get_default();
  struct _GtkTextIter begin;
  struct _GtkTextIter end;
  struct _GtkTextIter togo;
  char tonumLbl[7l];
  char title[128l];
  char *ptr;
  char *FCend;
  char flag = (char)0;
  const char *fthis;
  unsigned long int return_value_gtk_entry_get_type_1;
  return_value_gtk_entry_get_type_1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_1);
  fthis=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2);
  signed int slen;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(fthis);
  slen = (signed int)return_value_strlen_3;
  signed int x = 0;
  signed int i;
  signed int sw = 0;
  signed int cc = 0;
  signed int tmp;
  signed int return_value_gtk_events_pending_12;
  signed int return_value_gtk_events_pending_15;
  signed int return_value_gtk_events_pending_18;
  signed int return_value_gtk_events_pending_21;
  if(!(slen == 0))
  {
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    if(FileCon == ((char *)NULL))
    {
      gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
      FileCon=gtk_text_buffer_get_text(Tbuf, &start, &finish, 0);
      flag = (char)1;
    }

    ptr = FileCon;
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(FileCon);
    FCend = FileCon + (signed long int)return_value_strlen_4;
    if(Debug >= 1)
      g_print("searchlight()...\n");

    addtohistory((char *)fthis);
    strcpy(title, "Searching for ");
    strncat(title, fthis, (unsigned long int)112);
    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_5);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, title);
    gdk_display_flush(display);
    if(LNsw == 1)
    {
      numberlines();
      sw = 1;
    }

    gtk_text_buffer_remove_tag(Tbuf, hlite, &start, &finish);
    unsigned long int return_value_gtk_toggle_button_get_type_7;
    return_value_gtk_toggle_button_get_type_7=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)pushTgl, return_value_gtk_toggle_button_get_type_7);
    signed int return_value_gtk_toggle_button_get_active_9;
    return_value_gtk_toggle_button_get_active_9=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_8);
    if(!(return_value_gtk_toggle_button_get_active_9 == 0))
    {
      gtk_text_buffer_remove_tag(Tbuf, pushed, &start, &finish);
      i = 0;
      for( ; 2 * totalF + -1 >= i; i = i + 2)
      {
        gtk_text_buffer_get_iter_at_offset(Tbuf, &begin, TF[(signed long int)i]);
        gtk_text_buffer_get_iter_at_offset(Tbuf, &end, TF[(signed long int)(i + 1)]);
        gtk_text_buffer_apply_tag(Tbuf, pushed, &begin, &end);
      }
    }

    unsigned long int return_value_gtk_toggle_button_get_type_22;
    return_value_gtk_toggle_button_get_type_22=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
    return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)regxTgl, return_value_gtk_toggle_button_get_type_22);
    signed int return_value_gtk_toggle_button_get_active_24;
    return_value_gtk_toggle_button_get_active_24=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_23);
    if(!(return_value_gtk_toggle_button_get_active_24 == 0))
      do
      {
        slen=regexp(ptr, (char *)fthis);
        if(!(slen >= 1))
          break;

        TF[(signed long int)x]=utfadj(FileCon, (signed int)((ptr - FileCon) + (signed long int)rgxp.bgn));
        TF[(signed long int)(x + 1)] = TF[(signed long int)x] + slen;
        ptr = ptr + (signed long int)rgxp.end;
        if(Debug >= 3)
          g_print("+%d=%p\t", rgxp.end, ptr);

        x = x + 2;
        if(x % 100 == 0 && !(x >= 1000))
        {
          sprintf(tonumLbl, "%d", x / 2);
          unsigned long int return_value_gtk_label_get_type_10;
          return_value_gtk_label_get_type_10=gtk_label_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
          return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_10);
          gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_11, tonumLbl);
          do
          {
            return_value_gtk_events_pending_12=gtk_events_pending();
            if(return_value_gtk_events_pending_12 == 0)
              break;

            gtk_main_iteration();
          }
          while((_Bool)1);
        }

        if(x % 200 == 0 && x >= 1000)
        {
          sprintf(tonumLbl, "%d", x / 2);
          unsigned long int return_value_gtk_label_get_type_13;
          return_value_gtk_label_get_type_13=gtk_label_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
          return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_13);
          gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_14, tonumLbl);
          do
          {
            return_value_gtk_events_pending_15=gtk_events_pending();
            if(return_value_gtk_events_pending_15 == 0)
              break;

            gtk_main_iteration();
          }
          while((_Bool)1);
        }

        if(ptr >= FCend || x >= 198000)
          break;

      }
      while((_Bool)1);

    else
      do
      {
        tmp=nextfind(ptr, (char *)fthis);
        if(!(tmp >= 0))
          break;

        TF[(signed long int)x]=utfadj(FileCon, tmp + cc);
        TF[(signed long int)(x + 1)] = TF[(signed long int)x] + slen;
        cc = cc + tmp + slen;
        ptr = &FileCon[(signed long int)cc];
        x = x + 2;
        if(x % 100 == 0 && !(x >= 1000))
        {
          sprintf(tonumLbl, "%d", x / 2);
          unsigned long int return_value_gtk_label_get_type_16;
          return_value_gtk_label_get_type_16=gtk_label_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
          return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_16);
          gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_17, tonumLbl);
          do
          {
            return_value_gtk_events_pending_18=gtk_events_pending();
            if(return_value_gtk_events_pending_18 == 0)
              break;

            gtk_main_iteration();
          }
          while((_Bool)1);
        }

        if(x % 200 == 0 && x >= 1000)
        {
          sprintf(tonumLbl, "%d", x / 2);
          unsigned long int return_value_gtk_label_get_type_19;
          return_value_gtk_label_get_type_19=gtk_label_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
          return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_19);
          gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_20, tonumLbl);
          do
          {
            return_value_gtk_events_pending_21=gtk_events_pending();
            if(return_value_gtk_events_pending_21 == 0)
              break;

            gtk_main_iteration();
          }
          while((_Bool)1);
        }

        if(ptr >= FCend || x >= 198000)
          break;

      }
      while((_Bool)1);
    if(!(flag == 0))
    {
      free((void *)FileCon);
      FileCon = (char *)(void *)0;
    }

    i = 0;
    for( ; !(i >= x); i = i + 2)
    {
      gtk_text_buffer_get_iter_at_offset(Tbuf, &begin, TF[(signed long int)i]);
      gtk_text_buffer_get_iter_at_offset(Tbuf, &end, TF[(signed long int)(i + 1)]);
      gtk_text_buffer_apply_tag(Tbuf, hlite, &begin, &end);
    }
    totalF = x / 2;
    sprintf(tonumLbl, "%d", totalF);
    unsigned long int return_value_gtk_label_get_type_25;
    return_value_gtk_label_get_type_25=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
    return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)numLbl, return_value_gtk_label_get_type_25);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_26, tonumLbl);
    if(totalF >= 1)
    {
      gtk_text_buffer_get_iter_at_offset(Tbuf, &togo, TF[(signed long int)0]);
      unsigned long int return_value_gtk_text_view_get_type_27;
      return_value_gtk_text_view_get_type_27=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
      return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_27);
      gtk_text_view_scroll_to_iter((struct _GtkTextView *)return_value_g_type_check_instance_cast_28, &togo, 0.0, (signed int)!(0 != 0), 0.5, 0.5);
      gtk_text_buffer_place_cursor(Tbuf, &togo);
    }

    if(sw == 1)
      numberlines();

    unsigned long int return_value_gtk_window_get_type_29;
    return_value_gtk_window_get_type_29=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
    return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_29);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_30, Seefile->name);
  }

}

// send_remote
// file main.h line 193
signed int send_remote(char *term)
{
  char buffer[8192l];
  struct sockaddr_un addr;
  unsigned long int size;
  signed int remote;
  signed int err;
  remote=socket(1, 1, 0);
  addr.sun_family = (unsigned short int)1;
  strcpy(addr.sun_path, Config->sock);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen((&addr)->sun_path);
  size = (unsigned long int)((struct sockaddr_un *)0)->sun_path + return_value_strlen_1;
  if(!(Debug == 0))
    fprintf(stderr, "send_remote()...\n");

  err=connect(remote, (struct sockaddr *)&addr, (unsigned int)size);
  if(!(err == 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    fprintf(stderr, "send_remote() connect failed: %s\n", return_value_strerror_3);
    exit(0);
  }

  if((signed int)Seefile->type == 82)
    sprintf(buffer, "LOAD %s", (const void *)Seefile->path);

  else
    if((signed int)Seefile->path[0l] == 47)
      sprintf(buffer, "SMAN *** %s", (const void *)Seefile->path);

    else
      if(!(Seefile->sec[0l] == 0))
        sprintf(buffer, "SMAN %s %s", (const void *)Seefile->sec, (const void *)Seefile->path);

      else
        sprintf(buffer, "MAN %s", (const void *)Seefile->path);
  if(!(term == ((char *)NULL)))
  {
    strcat(buffer, " FIND ");
    strcat(buffer, term);
  }

  strcat(buffer, "\n");
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(buffer);
  write(remote, (const void *)buffer, return_value_strlen_4);
  g_print("Request_sent...");
  if(Debug >= 1)
    g_print("\"%s\"...", (const void *)buffer);

  getMsg(remote, buffer, 8192);
  signed int return_value_strncmp_5;
  return_value_strncmp_5=strncmp(buffer, "REQ OK", (unsigned long int)6);
  if(!(return_value_strncmp_5 == 0))
    return -3;

  else
  {
    puts("done.");
    return 0;
  }
}

// serverLoop
// file server.c line 176
void * serverLoop(void *p)
{
  struct anonymous_8 *tlock = (struct anonymous_8 *)p;
  signed int mproc;
  signed int remote;
  signed int fd = tlock->data;
  char buffer[8192l];
  struct sockaddr_un addr;
  unsigned int asz = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
  if(Debug >= 1)
    fprintf(stderr, "serverLoop()...%d\n", fd);

  signed int return_value_listen_1;
  return_value_listen_1=listen(fd, 666);
  signed int return_value_strcmp_3;
  if(!(return_value_listen_1 == 0))
  {
    perror("serverLoop() listen fail: ");
    return (void *)0;
  }

  else
  {
    pthread_mutex_lock(&tlock->lock);
    mproc=accept(fd, (struct sockaddr *)&addr, &asz);
    if(!(mproc >= 0))
    {
      perror("serverLoop() accept fail #1: ");
      return (void *)0;
    }

    else
    {
      getMsg(mproc, buffer, 8192);
      write(mproc, (const void *)"SS LAUNCH\n", (unsigned long int)10);
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(buffer, "SS LAUNCH");
      if(!(return_value_strcmp_2 == 0))
      {
        fprintf(stderr, "serverLoop() handshake failed.\n");
        return (void *)0;
      }

      else
        while((_Bool)1)
        {
          remote=accept(fd, (struct sockaddr *)&addr, &asz);
          if(!(remote >= 0))
          {
            perror("startServer() accept fail #2: ");
            return (void *)0;
          }

          getMsg(remote, buffer, 8192);
          signed int return_value_strcmp_4;
          return_value_strcmp_4=strcmp(buffer, "XOSEESOX");
          if(return_value_strcmp_4 == 0)
          {
            write(remote, (const void *)"XOSEESOX\n", (unsigned long int)9);
            continue;
          }

          else
          {
            return_value_strcmp_3=strcmp(buffer, "SS THEND");
            if(return_value_strcmp_3 == 0)
            {
              if(Debug >= 2)
                fprintf(stderr, "serverLoop() thread exiting\n");

              close(mproc);
              close(remote);
              pthread_exit((void *)0);
            }

          }
          write(remote, (const void *)"REQ OK\n", (unsigned long int)7);
          close(remote);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(buffer);
          write(mproc, (const void *)buffer, return_value_strlen_5);
          write(mproc, (const void *)"\n", (unsigned long int)1);
        }
    }
  }
}

// setFL_selected
// file see.c line 2071
void setFL_selected()
{
  char str[4l];
  struct _GtkTreePath *path;
  sprintf(str, "%d", CurFS - 1);
  path=gtk_tree_path_new_from_string(str);
  gtk_tree_selection_select_path(Nbar.select, path);
}

// setNULL
// file see.c line 2069
void setNULL(struct _GtkWidget *ignored, void **ptr)
{
  ptr = (void **)(void *)0;
}

// setwrapmode
// file see.c line 2080
void setwrapmode()
{
  struct _GtkWidget *sbwin;
  sbwin=gtk_window_new((enum anonymous_5)GTK_WINDOW_POPUP);
  struct _GtkWidget *frame;
  frame=gtk_frame_new("Wrap Mode");
  struct _GtkWidget *sbVbox;
  sbVbox=gtk_vbox_new(0, 0);
  struct _GtkWidget *CloseBT;
  CloseBT=gtk_button_new_with_label("close");
  struct _GtkWidget *rbutt;
  rbutt=gtk_radio_button_new_with_label((struct _GSList *)(void *)0, "no wrap");
  struct _GSList *RBgroup;
  unsigned long int return_value_gtk_radio_button_get_type_1;
  return_value_gtk_radio_button_get_type_1=gtk_radio_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_radio_button_get_type_1);
  RBgroup=gtk_radio_button_get_group((struct _GtkRadioButton *)return_value_g_type_check_instance_cast_2);
  enum anonymous_3 current;
  unsigned long int return_value_gtk_text_view_get_type_3;
  return_value_gtk_text_view_get_type_3=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)TxT, return_value_gtk_text_view_get_type_3);
  current=gtk_text_view_get_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast_4);
  unsigned long int return_value_gtk_window_get_type_5;
  return_value_gtk_window_get_type_5=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_window_get_type_5);
  unsigned long int return_value_gtk_window_get_type_7;
  return_value_gtk_window_get_type_7=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_7);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (struct _GtkWindow *)return_value_g_type_check_instance_cast_8);
  unsigned long int return_value_gtk_window_get_type_9;
  return_value_gtk_window_get_type_9=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_window_get_type_9);
  gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_10, (enum anonymous_35)GTK_WIN_POS_CENTER_ON_PARENT);
  unsigned long int return_value_gtk_container_get_type_11;
  return_value_gtk_container_get_type_11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_container_get_type_11);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_12, frame);
  unsigned long int return_value_gtk_container_get_type_13;
  return_value_gtk_container_get_type_13=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_13);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_14, sbVbox);
  unsigned long int return_value_gtk_toggle_button_get_type_15;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  if((signed int)current == GTK_WRAP_NONE)
  {
    return_value_gtk_toggle_button_get_type_15=gtk_toggle_button_get_type();
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_toggle_button_get_type_15);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_16, (signed int)!(0 != 0));
  }

  g_signal_connect_data((void *)rbutt, "toggled", (void (*)(void))changewrapmode, (void *)78, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)sbVbox, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, rbutt, 0, 0, (unsigned int)0);
  rbutt=gtk_radio_button_new_with_label(RBgroup, "wrap on word");
  unsigned long int return_value_gtk_radio_button_get_type_19;
  return_value_gtk_radio_button_get_type_19=gtk_radio_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_radio_button_get_type_19);
  RBgroup=gtk_radio_button_get_group((struct _GtkRadioButton *)return_value_g_type_check_instance_cast_20);
  unsigned long int return_value_gtk_toggle_button_get_type_21;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  if((signed int)current == GTK_WRAP_WORD)
  {
    return_value_gtk_toggle_button_get_type_21=gtk_toggle_button_get_type();
    return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_toggle_button_get_type_21);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_22, (signed int)!(0 != 0));
  }

  g_signal_connect_data((void *)rbutt, "toggled", (void (*)(void))changewrapmode, (void *)87, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  unsigned long int return_value_gtk_box_get_type_23;
  return_value_gtk_box_get_type_23=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)sbVbox, return_value_gtk_box_get_type_23);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_24, rbutt, 0, 0, (unsigned int)0);
  rbutt=gtk_radio_button_new_with_label(RBgroup, "exact wrap");
  unsigned long int return_value_gtk_radio_button_get_type_25;
  return_value_gtk_radio_button_get_type_25=gtk_radio_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_radio_button_get_type_25);
  RBgroup=gtk_radio_button_get_group((struct _GtkRadioButton *)return_value_g_type_check_instance_cast_26);
  unsigned long int return_value_gtk_toggle_button_get_type_27;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  if((signed int)current == GTK_WRAP_CHAR)
  {
    return_value_gtk_toggle_button_get_type_27=gtk_toggle_button_get_type();
    return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)rbutt, return_value_gtk_toggle_button_get_type_27);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_28, (signed int)!(0 != 0));
  }

  g_signal_connect_data((void *)rbutt, "toggled", (void (*)(void))changewrapmode, (void *)69, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  unsigned long int return_value_gtk_box_get_type_29;
  return_value_gtk_box_get_type_29=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)sbVbox, return_value_gtk_box_get_type_29);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_30, rbutt, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_31;
  return_value_gtk_box_get_type_31=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)sbVbox, return_value_gtk_box_get_type_31);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_32, CloseBT, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_widget_get_type_33;
  return_value_gtk_widget_get_type_33=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_widget_get_type_33);
  g_signal_connect_data((void *)CloseBT, "clicked", (void (*)(void))destroy_widget, (void *)(struct _GtkWidget *)return_value_g_type_check_instance_cast_34, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
  gtk_widget_show_all(sbwin);
}

// shiftFilelist
// file see.c line 2125
void shiftFilelist(struct _GtkWidget *ignored, signed int val)
{
  char list[27l][5120l];
  signed int len;
  len=loadlist(list);
  if(!(Seefile == ((struct anonymous_2 *)NULL)) && !(len == 0))
  {
    if(val == 1)
    {
      if(CurFS == len)
        goto __CPROVER_DUMP_L6;

    }

    else
      if(CurFS == 1)
        goto __CPROVER_DUMP_L6;

    CurFS = CurFS + val;
    exeFSlisting(list[(signed long int)(CurFS - 1)]);
    if(!(Nbar.select == ((struct _GtkTreeSelection *)NULL)))
      setFL_selected();

  }


__CPROVER_DUMP_L6:
  ;
}

// showconfig
// file see.c line 2141
void showconfig(struct anonymous_16 *cfg)
{
  char text[1024l];
  struct _GtkTextIter iter;
  gtk_text_buffer_get_end_iter(Tbuf, &iter);
  sprintf(text, "\n___Configuration___\n\n");
  gtk_text_buffer_insert_with_tags(Tbuf, &iter, (const char *)text, -1, ctitle, (void *)0);
  if(!(cfg->txtfnt == ((char *)NULL)))
    sprintf(text, "\n\ttext area font: %s\n", cfg->txtfnt);

  else
    strcpy(text, "\n\tno text font selected.\n");
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  sprintf(text, "\twatch interval set to %d seconds\n", cfg->watchtime);
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  sprintf(text, "\ttext area width=%dpx height=%dpx\n\n", cfg->width, cfg->height);
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  if(!(cfg->seedata == ((char *)NULL)))
  {
    sprintf(text, "\t\"seedata\" file path ");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
    strcpy(text, cfg->seedata);
    gtk_text_buffer_insert_with_tags(Tbuf, &iter, (const char *)text, -1, hlink, (void *)0);
  }

  else
  {
    sprintf(text, "\t...no \"seedata\" file in use.");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  }
  if(!(cfg->filelist == ((char *)NULL)))
  {
    sprintf(text, "\n\tfilelist path ");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
    strcpy(text, cfg->filelist);
    gtk_text_buffer_insert_with_tags(Tbuf, &iter, (const char *)text, -1, hlink, (void *)0);
  }

  else
  {
    sprintf(text, "\n\t...no filelist in use.\n");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  }
  if(!(cfg->sock[0l] == 0))
  {
    sprintf(text, "\n\t\"seesocket\" location: %s\n\n", (const void *)cfg->sock);
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  }

  else
  {
    sprintf(text, "\n\nSORRY:Your home directory path, or the path you provided for the \"seesocket\", is too long, or a regular file exists with the same name.  Local sockets must have a name, including the fullpath, shorter than 108 characters.\n\n");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  }
  sprintf(text, "\tYour editor command: \"%s\"\n", cfg->editor);
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  if(!(cfg->copyto == ((char *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(cfg->copyto, "Could not open!");
    if(return_value_strcmp_1 == 0)
    {
      sprintf(text, "\tSORRY: Could not open your \"copy to\" directory.\n");
      gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
    }

    else
    {
      sprintf(text, "\n\tYour \"copy to\" directory: %s\n", Config->copyto);
      gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
      if(cfg->bRedirect == 0)
      {
        sprintf(text, "\tstderr redirection turned off.\n");
        gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
      }

    }
  }

  else
  {
    strcpy(text, "\n\tNo \"copy to\" directory defined.\n");
    gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  }
  sprintf(text, "\n\t\"Tail at\" boundary: %d bytes\n", Config->tailat);
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  if(!(cfg->bConfirm == 0))
    sprintf(text, "\n\t\"Confirm load\" turned off.\n");

  else
    sprintf(text, "\n\tConfirm load is on.\n");
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  sprintf(text, "\n  For more information, see under \n  \"CONFIGURATION\" in the ");
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
  sprintf(text, "manual page");
  gtk_text_buffer_insert_with_tags(Tbuf, &iter, (const char *)text, -1, hlink, (void *)0);
  sprintf(text, ".\n");
  gtk_text_buffer_insert(Tbuf, &iter, (const char *)text, -1);
}

// showlist
// file see.c line 2229
void showlist()
{
  struct _GtkListStore *liststore;
  liststore=gtk_list_store_new(1, (unsigned long int)(16 << 2));
  struct _GtkWidget *sbwin;
  sbwin=gtk_window_new((enum anonymous_5)GTK_WINDOW_TOPLEVEL);
  struct _GtkWidget *frame;
  frame=gtk_frame_new("Current Filelist");
  struct _GtkWidget *flab;
  unsigned long int return_value_gtk_frame_get_type_1;
  return_value_gtk_frame_get_type_1=gtk_frame_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_frame_get_type_1);
  flab=gtk_frame_get_label_widget((struct _GtkFrame *)return_value_g_type_check_instance_cast_2);
  struct _GtkWidget *sbox;
  sbox=gtk_vbox_new(0, 0);
  struct _GtkWidget *FLLV;
  unsigned long int return_value_gtk_tree_model_get_type_3;
  return_value_gtk_tree_model_get_type_3=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)liststore, return_value_gtk_tree_model_get_type_3);
  FLLV=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_4);
  struct _GtkWidget *cancelBT;
  cancelBT=gtk_button_new_with_label("close filelist");
  struct _GtkCellRenderer *render;
  struct _GtkTreeViewColumn *column;
  struct _PangoAttrList *atrb;
  atrb=pango_attr_list_new();
  struct _PangoAttribute *ubold;
  ubold=pango_attr_weight_new((enum anonymous_38)PANGO_WEIGHT_ULTRABOLD);
  if(Nbar.select == ((struct _GtkTreeSelection *)NULL))
  {
    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_window_get_type_5);
    unsigned long int return_value_gtk_window_get_type_7;
    return_value_gtk_window_get_type_7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_7);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, (struct _GtkWindow *)return_value_g_type_check_instance_cast_8);
    unsigned long int return_value_gtk_window_get_type_9;
    return_value_gtk_window_get_type_9=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
    return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_window_get_type_9);
    gtk_window_set_position((struct _GtkWindow *)return_value_g_type_check_instance_cast_10, (enum anonymous_35)GTK_WIN_POS_MOUSE);
    unsigned long int return_value_gtk_window_get_type_11;
    return_value_gtk_window_get_type_11=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
    return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_window_get_type_11);
    gtk_window_set_decorated((struct _GtkWindow *)return_value_g_type_check_instance_cast_12, (signed int)!(0 != 0));
    struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
    return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_13, "delete_event", (void (*)(void))setNULL, (void *)Nbar.select, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
    return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_14, "destroy", (void (*)(void))setNULL, (void *)Nbar.select, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    unsigned long int return_value_gtk_container_get_type_15;
    return_value_gtk_container_get_type_15=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)sbwin, return_value_gtk_container_get_type_15);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_16, frame);
    unsigned long int return_value_gtk_container_get_type_17;
    return_value_gtk_container_get_type_17=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
    return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_17);
    gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_18, (unsigned int)4);
    ubold->start_index = (unsigned int)0;
    ubold->end_index = (unsigned int)16;
    pango_attr_list_insert(atrb, ubold);
    unsigned long int return_value_gtk_label_get_type_19;
    return_value_gtk_label_get_type_19=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
    return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)flab, return_value_gtk_label_get_type_19);
    gtk_label_set_attributes((struct _GtkLabel *)return_value_g_type_check_instance_cast_20, atrb);
    unsigned long int return_value_gtk_container_get_type_21;
    return_value_gtk_container_get_type_21=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
    return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)frame, return_value_gtk_container_get_type_21);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_22, sbox);
    unsigned long int return_value_gtk_box_get_type_23;
    return_value_gtk_box_get_type_23=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
    return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)sbox, return_value_gtk_box_get_type_23);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_24, FLLV, 0, 0, (unsigned int)0);
    unsigned long int return_value_gtk_tree_view_get_type_25;
    return_value_gtk_tree_view_get_type_25=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
    return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)FLLV, return_value_gtk_tree_view_get_type_25);
    gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast_26, 0);
    render=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("filelist", render, (const void *)"text", 0, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type_27;
    return_value_gtk_tree_view_get_type_27=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
    return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)FLLV, return_value_gtk_tree_view_get_type_27);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_28, column);
    g_signal_connect_data((void *)FLLV, "row-activated", (void (*)(void))fileselect, (void *)sbwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    unsigned long int return_value_gtk_tree_view_get_type_29;
    return_value_gtk_tree_view_get_type_29=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
    return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)FLLV, return_value_gtk_tree_view_get_type_29);
    Nbar.select=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_30);
    list2view(liststore);
    unsigned long int return_value_gtk_box_get_type_31;
    return_value_gtk_box_get_type_31=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
    return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)sbox, return_value_gtk_box_get_type_31);
    gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_32, cancelBT, 0, 0, (unsigned int)0);
    g_signal_connect_data((void *)cancelBT, "clicked", (void (*)(void))closeFL_window, (void *)sbwin, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_39)0);
    gtk_widget_show_all(sbwin);
  }

}

// sortintray
// file main.h line 180
void sortintray(signed int *ray, signed int len)
{
  signed int i;
  signed int flag = 0;
  signed int tmp;
  if(Debug >= 2)
    g_print("sortintray()...%d\n", len);

  if(len >= 2)
    for( ; flag == 0; flag = 0)
    {
      i = 0;
      for( ; !(i >= len + -1); i = i + 1)
        if(!(ray[(signed long int)(1 + i)] >= ray[(signed long int)i]))
        {
          tmp = ray[(signed long int)(i + 1)];
          ray[(signed long int)(i + 1)] = ray[(signed long int)i];
          ray[(signed long int)i] = tmp;
          flag = flag + 1;
        }

      if(flag == 0)
        break;

    }

}

// streamline
// file main.h line 181
signed int streamline(struct _IO_FILE *IN, char **line, signed int bsize)
{
  signed int len;
  const signed long int len_array_size0 = (signed long int)bsize;
  char buffer[len_array_size0];
  char *return_value_fgets_1;
  return_value_fgets_1=fgets(buffer, bsize, IN);
  if(return_value_fgets_1 == ((char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buffer);
    len = (signed int)return_value_strlen_2;
    if((signed int)buffer[(signed long int)(len + -1)] == 10)
      buffer[(signed long int)(len - 1)] = (char)0;

    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)len);
    *line = (char *)return_value_malloc_3;
    if(*line == ((char *)NULL))
      return -1;

    else
    {
      strncpy(*line, buffer, (unsigned long int)len);
      return len;
    }
  }
}

// strexd
// file main.h line 182
signed int strexd(signed int EXPlen, char *string)
{
  char *ptr;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed int)return_value_strlen_1;
  if(EXPlen == 0)
  {
    void *return_value_ec_malloc_2;
    return_value_ec_malloc_2=ec_malloc((unsigned long int)(len + 1));
    EXDline = (char *)return_value_ec_malloc_2;
    strcpy(EXDline, string);
    return len;
  }

  else
  {
    EXPlen = EXPlen + len;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)EXDline, (unsigned long int)(EXPlen + 1));
    ptr = (char *)return_value_realloc_3;
    if(!(ptr == ((char *)NULL)))
      EXDline = ptr;

    else
    {
      puts("!!! see: realloc failure in strexd() !!!");
      gtk_main_quit();
    }
    strcat(EXDline, string);
    return EXPlen;
  }
}

// strsub
// file main.h line 183
char * strsub(const char *string, char *newname)
{
  signed long int strsub_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  strsub_array_size0 = (signed long int)(return_value_strlen_1 + (unsigned long int)1);
  char copy[strsub_array_size0];
  char *ptr;
  char *rp;
  strcpy(copy, string);
  ptr=strstr(copy, "SEEBUF");
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(string);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(newname);
  void *return_value_ec_malloc_4;
  return_value_ec_malloc_4=ec_malloc(return_value_strlen_2 + (return_value_strlen_3 - (unsigned long int)6) + (unsigned long int)8);
  rp = (char *)return_value_ec_malloc_4;
  ptr[(signed long int)0] = (char)0;
  sprintf(rp, "%s%s%s", (const void *)copy, newname, &ptr[(signed long int)6]);
  return rp;
}

// tailfile
// file see.c line 2274
signed int tailfile()
{
  char *line;
  char *tmp;
  struct _IO_FILE *fin;
  signed int now;
  now=filelen(Seefile->path);
  if(SFsz >= now)
    return (signed int)!(0 != 0);

  else
  {
    if(Debug >= 1)
      g_print("tailfile() %d %d\n", SFsz, now);

    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)FileCon, (unsigned long int)(now + 1));
    tmp = (char *)return_value_realloc_1;
    if(tmp == ((char *)NULL))
    {
      error_popup("Out of memory!");
      return (signed int)!(0 != 0);
    }

    else
      FileCon = tmp;
    fin=fopen(Seefile->path, "r");
    fseeko(fin, (signed long int)SFsz, 0);
    gtk_text_buffer_get_bounds(Tbuf, &start, &finish);
    do
    {
      line=linein(fin);
      if(line == ((char *)NULL))
        break;

      gtk_text_buffer_insert(Tbuf, &finish, line, -1);
      strcat(FileCon, line);
      free((void *)line);
    }
    while((_Bool)1);
    fclose(fin);
    signed int return_value_buflen_2;
    return_value_buflen_2=buflen(FileCon);
    scrolltoline((struct _GtkWidget *)(void *)0, return_value_buflen_2);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(FileCon);
    SFsz = (signed int)return_value_strlen_3;
    return (signed int)!(0 != 0);
  }
}

// takecall
// file server.c line 229
signed int takecall(struct _GIOChannel *gio, enum anonymous_43 ignored)
{
  signed int server;
  server=g_io_channel_unix_get_fd(gio);
  char buffer[8192l];
  char *tok;
  char *sec;
  if(Debug >= 1)
    fprintf(stderr, "takecall()...server=%d\n", server);

  getMsg(server, buffer, 8192);
  if(Debug >= 1)
    g_print("received \"%s\"\n", (const void *)buffer);

  tok=strtok(buffer, " ");
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_6;
  if(tok == ((char *)NULL))
    return (signed int)!(0 != 0);

  else
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(tok, "LOAD");
    if(return_value_strcmp_3 == 0)
    {
      tok=strtok((char *)(void *)0, " \n");
      loadnew(tok, (char *)(void *)0, 0);
    }

    else
    {
      return_value_strcmp_2=strcmp(tok, "MAN");
      if(return_value_strcmp_2 == 0)
      {
        tok=strtok((char *)(void *)0, " \n");
        loadnew(tok, "\0", 0);
      }

      else
      {
        return_value_strcmp_1=strcmp(tok, "SMAN");
        if(return_value_strcmp_1 == 0)
        {
          sec=strtok((char *)(void *)0, " ");
          tok=strtok((char *)(void *)0, " \n");
          loadnew(tok, sec, 0);
        }

        else
          return (signed int)!(0 != 0);
      }
    }
    tok=strtok((char *)(void *)0, " ");
    if(!(tok == ((char *)NULL)))
    {
      return_value_strcmp_6=strcmp(tok, "FIND");
      if(return_value_strcmp_6 == 0)
      {
        tok=strtok((char *)(void *)0, " \n");
        if(tok == ((char *)NULL))
          return (signed int)!(0 != 0);

        unsigned long int return_value_gtk_entry_get_type_4;
        return_value_gtk_entry_get_type_4=gtk_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
        return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)Fent, return_value_gtk_entry_get_type_4);
        gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_5, tok);
        searchlight();
      }

    }

    return (signed int)!(0 != 0);
  }
}

// testuni
// file see.c line 2301
signed int testuni(unsigned int CHR, signed short int chr)
{
  if(CHR == (unsigned int)chr)
    return (signed int)!(0 != 0);

  else
    return 0;
}

// textline
// file see.c line 2307
char * textline(signed int line)
{
  char *rptr = (char *)(void *)0;
  signed int cc = 0;
  signed int lc = 1;
  signed int lstart = 0;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(FileCon);
  len = (signed int)return_value_strlen_1;
  for( ; !(cc >= len); cc = cc + 1)
  {
    if((signed int)FileCon[(signed long int)cc] == 10)
    {
      lc = lc + 1;
      lstart = cc + 1;
    }

    if(lc == line)
    {
      rptr = FileCon + (signed long int)lstart;
      break;
    }

  }
  return rptr;
}

// tglServer
// file main.h line 196
void tglServer(struct _GtkWidget *ignored, signed int server)
{
  signed int remote;
  signed int tries = 0;
  char messg[256l];
  unsigned long int tid;
  struct anonymous_8 lock = InitTL;
  if(Debug >= 1)
    fprintf(stderr, "tglServer()...%d\n", server);

  static unsigned int watch_ID;
  static unsigned int blink_TO;
  if(!(server >= 1))
  {
    if(Gio == ((struct _GIOChannel *)NULL))
    {
      if(server == -1)
        goto __CPROVER_DUMP_L20;

      if(Config->sock[0l] == 0)
        goto __CPROVER_DUMP_L20;

      server=loclsckt(Config->sock);
      if(!(server >= 3))
      {
        fprintf(stderr, "tglServer() could not start!\n");
        goto __CPROVER_DUMP_L20;
      }

      goto __CPROVER_DUMP_L10;
    }

    if(Debug >= 2)
      fprintf(stderr, "tglServer() off.\n");

    remote=loclcon(Config->sock);
    if(!(remote == 0))
    {
      write(remote, (const void *)"SS THEND\n", (unsigned long int)9);
      close(remote);
    }

    else
      if(!(Debug == 0))
        perror("Couldn't shut down server thread: ");

    g_io_channel_set_close_on_unref(Gio, (signed int)!(0 != 0));
    g_io_channel_shutdown(Gio, 0, (struct _GError **)(void *)0);
    g_io_channel_unref(Gio);
    Gio = (struct _GIOChannel *)(void *)0;
    g_source_remove(blink_TO);
    g_source_remove(watch_ID);
    unlink(Config->sock);
    if(Sff.sw == 1)
    {
      unsigned long int return_value_gtk_container_get_type_1;
      return_value_gtk_container_get_type_1=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)ServTgl, return_value_gtk_container_get_type_1);
      gtk_container_remove((struct _GtkContainer *)return_value_g_type_check_instance_cast_2, ServOn);
      unsigned long int return_value_gtk_container_get_type_3;
      return_value_gtk_container_get_type_3=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)ServTgl, return_value_gtk_container_get_type_3);
      gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_4, ServOff);
      Sff.sw = 0;
    }

  }

  else
  {

  __CPROVER_DUMP_L10:
    ;
    lock.data = server;
    pthread_mutex_lock(&lock.lock);
    signed int return_value_pthread_create_5;
    return_value_pthread_create_5=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, serverLoop, (void *)&lock);
    if(!(return_value_pthread_create_5 == 0))
      perror("tglServer() pthread_create fail: ");

    else
    {
      pthread_detach(tid);
      pthread_mutex_unlock(&lock.lock);
      while(!(tries >= 5))
      {
        remote=loclcon(Config->sock);
        if(remote == 0)
        {
          if(!(Debug == 0))
            perror("tglServer() connect fail: ");

        }

        else
          break;
        sleep((unsigned int)1);
        tries = tries + 1;
        if(tries == 5)
          goto __CPROVER_DUMP_L20;

      }
      write(remote, (const void *)"SS LAUNCH\n", (unsigned long int)10);
      getMsg(remote, messg, 256);
      signed int return_value_strcmp_6;
      return_value_strcmp_6=strcmp(messg, "SS LAUNCH");
      if(!(return_value_strcmp_6 == 0))
        fprintf(stderr, "tglServer() failed handshake >%s<.\n", (const void *)messg);

      else
      {
        Gio=g_io_channel_unix_new(remote);
        blink_TO=g_timeout_add((unsigned int)750, (signed int (*)(void *))blinktoggle, (void *)&Sff);
        watch_ID=g_io_add_watch(Gio, (enum anonymous_43)G_IO_IN, (signed int (*)(struct _GIOChannel *, enum anonymous_43, void *))takecall, (void *)0);
        if(Debug >= 1)
          g_print("See server initialized...\n");

      }
    }
  }

__CPROVER_DUMP_L20:
  ;
}

// toedit
// file see.c line 2319
void toedit()
{
  signed int pid;
  char string[4112l];
  _Bool tmp_if_expr_1;
  if(Seefile == ((struct anonymous_2 *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)Seefile->type != 82 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(Config->editor != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_2)
  {
    pid=fork();
    if(pid == 0)
    {
      sprintf(string, "%s %s", Config->editor, (const void *)Seefile->path);
      system(string);
      exit(0);
    }

    else
    {
      sprintf(string, "%s sent to %s", (const void *)Seefile->name, Config->editor);
      unsigned long int return_value_gtk_window_get_type_3;
      return_value_gtk_window_get_type_3=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)MainWindow, return_value_gtk_window_get_type_3);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, string);
    }
  }

}

// update_filelist
// file see.c line 2390
signed int update_filelist(struct anonymous_2 *old, signed int lastline)
{
  char list[27l][5120l];
  char newListing[5120l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char oldListing[5120l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int len;
  len=loadlist(list);
  signed int i;
  signed int newsz;
  signed int oldsz;
  struct _IO_FILE *fstW;
  fstW=fopen(Config->filelist, "w");
  signed int return_value_strncmp_3;
  _Bool tmp_if_expr_5;
  signed int return_value_strncmp_4;
  if(fstW == ((struct _IO_FILE *)NULL))
  {
    error_popup("Unable to update filelist!\nError #3\n(see manpage/ctrl-h)");
    return -2;
  }

  else
  {
    if(Debug >= 1)
      g_print("update_filelist() old=%p lastline = %d listlen=%d\n", (void *)old, lastline, len);

    if(len >= 27)
      len = 26;

    if(!(Seefile == ((struct anonymous_2 *)NULL)))
    {
      if(!(Seefile->sec[0l] == 0))
        sprintf(newListing, "%s|(%s)", (const void *)Seefile->path, (const void *)Seefile->sec);

      else
        sprintf(newListing, "%s|", (const void *)Seefile->path);
      if(CurFS == 1)
        fprintf(fstW, "%s\n", (const void *)newListing);

    }

    if(!(old == ((struct anonymous_2 *)NULL)))
    {
      if(!(old->sec[0l] == 0))
        sprintf(oldListing, "%s|(%s)", (const void *)old->path, (const void *)old->sec);

      else
        sprintf(oldListing, "%s|", (const void *)old->path);
    }

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(newListing);
    newsz = (signed int)return_value_strlen_1;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(oldListing);
    oldsz = (signed int)return_value_strlen_2;
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      if(!(newListing[0l] == 0))
      {
        return_value_strncmp_3=strncmp(list[(signed long int)i], newListing, (unsigned long int)newsz);
        if(return_value_strncmp_3 == 0)
        {
          if(CurFS == 1)
            goto __CPROVER_DUMP_L15;

        }

      }

      if(!(oldListing[0l] == 0))
      {
        return_value_strncmp_4=strncmp(list[(signed long int)i], oldListing, (unsigned long int)oldsz);
        tmp_if_expr_5 = !(return_value_strncmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        fprintf(fstW, "%s_%d\n", (const void *)oldListing, lastline);

      else
        fprintf(fstW, "%s\n", (const void *)list[(signed long int)i]);

    __CPROVER_DUMP_L15:
      ;
    }
    fclose(fstW);
    if(!(Nbar.select == ((struct _GtkTreeSelection *)NULL)))
      rescanFileList();

    return 0;
  }
}

// usage
// file see.c line 2432
void usage(char *name)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(name, "seetxt");
  if(!(return_value_strcmp_1 == 0))
  {
    printf("Usage: %s [manpage] [-s section] [-x term] [-d level]\n", name);
    puts("-s\tman page section number (eg, -s 1 or -s 3p)");
  }

  else
    printf("Usage: %s [filename] [-x term] [-d level]\n", name);
  printf("-x\tinitial search term\n-d\t1,2 or 3, turn on debugging to stdout\n-K\tfree server space/socket\n-v\tshow version\n-h\tprints this message\nAll arguments are optional.\nIf used, the filename or manpage should always be the first argument.\n\n");
}

// usebmk
// file see.c line 2448
void usebmk(struct _GtkTreeView *treeview, struct _GtkTreePath *treepath, struct _GtkTreeViewColumn *treecol, struct _GtkWidget *swin)
{
  signed int ln;
  struct _GtkTreeModel *Tmod;
  Tmod=gtk_tree_view_get_model(treeview);
  struct _GtkTreeIter itr;
  signed int return_value_gtk_tree_model_get_iter_1;
  return_value_gtk_tree_model_get_iter_1=gtk_tree_model_get_iter(Tmod, &itr, treepath);
  if(!(return_value_gtk_tree_model_get_iter_1 == 0))
    gtk_tree_model_get(Tmod, &itr, 0, &ln, -1);

  if(!(ln == 0))
    scrolltoline((struct _GtkWidget *)(void *)0, ln - 1);

  gtk_widget_destroy(swin);
}

// utfadj
// file main.h line 184
signed int utfadj(char *buffer, signed int pos)
{
  signed int i;
  signed int count = 0;
  if(Debug >= 3)
    g_print("utfadj() %d...", pos);

  i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(i >= pos); i = i + 1)
  {
    if((signed int)(unsigned char)buffer[(signed long int)i] >= 0x80)
      tmp_if_expr_1 = (signed int)(unsigned char)buffer[(signed long int)i] <= 0xBF ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      goto __CPROVER_DUMP_L6;

    else
      count = count + 1;

  __CPROVER_DUMP_L6:
    ;
  }
  return count;
}

// watchfile
// file see.c line 2458
void watchfile()
{
  signed int (*func)() = reload;
  if(!(Seefile == ((struct anonymous_2 *)NULL)) || !(watchSW == 0))
  {
    if(!(Config->tailat >= SFsz))
      func = tailfile;

    static unsigned int blink_TO;
    static unsigned int watch_TO;
    if(watchSW == 0)
    {
      watch_TO=g_timeout_add((unsigned int)(Config->watchtime * 1000), (signed int (*)(void *))func, (void *)0);
      blink_TO=g_timeout_add((unsigned int)500, (signed int (*)(void *))blinktoggle, (void *)&wff);
      watchSW = 1;
    }

    else
    {
      watchSW = 0;
      g_source_remove(watch_TO);
      g_source_remove(blink_TO);
      if(wff.sw == 1)
      {
        unsigned long int return_value_gtk_container_get_type_1;
        return_value_gtk_container_get_type_1=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
        return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)watchTgl, return_value_gtk_container_get_type_1);
        gtk_container_remove((struct _GtkContainer *)return_value_g_type_check_instance_cast_2, watchon);
        unsigned long int return_value_gtk_container_get_type_3;
        return_value_gtk_container_get_type_3=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
        return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)watchTgl, return_value_gtk_container_get_type_3);
        gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_4, watchoff);
        wff.sw = 0;
      }

    }
  }

}

// writeout
// file main.h line 185
char * writeout(char *buffer, char *file, signed int *ptr)
{
  signed int done;
  signed int size;
  signed int newfd;
  newfd=open(file, 01 | 0100 | 0200, 0400 | 0200);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(newfd == -1)
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    return return_value_strerror_2;
  }

  else
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(buffer);
    size = (signed int)return_value_strlen_3;
    signed long int return_value_write_4;
    return_value_write_4=write(newfd, (const void *)buffer, (unsigned long int)size);
    done = (signed int)return_value_write_4;
    close(newfd);
    if(done == -1)
    {
      return_value___errno_location_5=__errno_location();
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      return return_value_strerror_6;
    }

    else
    {
      *ptr = done;
      return (char *)(void *)0;
    }
  }
}

