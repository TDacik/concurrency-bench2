// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$10;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$8;

// tag-#anon#ST[ARR16{U64}$U64$'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous$2;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$7;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$6;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$12;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$5;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$9;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$0;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$11;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-cpu_data
// file numad.c line 1109
struct cpu_data;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-id_list
// file numad.c line 248
struct id_list;

// tag-msg
// file numad.c line 192
struct msg;

// tag-msg_body
// file numad.c line 184
struct msg_body;

// tag-node_data
// file numad.c line 387
struct node_data;

// tag-pid_list
// file numad.c line 644
struct pid_list;

// tag-process_data
// file numad.c line 417
struct process_data;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __sched_cpualloc
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 205
extern struct anonymous$2 * __sched_cpualloc(unsigned long int);
// __sched_cpucount
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 203
extern signed int __sched_cpucount(unsigned long int, const struct anonymous$2 *);
// __sched_cpufree
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 206
extern void __sched_cpufree(struct anonymous$2 *);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_ids_to_list_from_str
// file numad.c line 317
signed int add_ids_to_list_from_str(struct id_list *list_p, char *s);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// bind_process_and_migrate_memory
// file numad.c line 980
signed int bind_process_and_migrate_memory(struct process_data *p);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_prereqs
// file numad.c line 773
void check_prereqs(char *prog_name);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_log_file
// file numad.c line 171
void close_log_file();
// combined_value_of_weighted_resources
// file numad.c line 1687
unsigned long int combined_value_of_weighted_resources(signed int ix, signed int mbs, signed int cpus, unsigned long int MBs_free, unsigned long int CPUs_free);
// count_set_bits_in_hex_list_file
// file numad.c line 852
signed int count_set_bits_in_hex_list_file(char *fname);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// flush_msg_queue
// file numad.c line 199
void flush_msg_queue();
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_daemon_pid
// file numad.c line 779
signed int get_daemon_pid();
// get_huge_page_size_in_bytes
// file numad.c line 934
unsigned long int get_huge_page_size_in_bytes();
// get_num_cpus
// file numad.c line 889
signed int get_num_cpus();
// get_num_kvm_vcpu_threads
// file numad.c line 903
signed int get_num_kvm_vcpu_threads(signed int pid);
// get_stat_data_for_pid
// file numad.c line 1508
struct process_data * get_stat_data_for_pid(signed int pid, char *pid_string);
// get_time_stamp
// file numad.c line 957
unsigned long int get_time_stamp();
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// init_msg_queue
// file numad.c line 206
void init_msg_queue();
// initialize_mem_node_list
// file numad.c line 1643
signed int initialize_mem_node_list(struct process_data *p);
// insert_pid_into_pid_list
// file numad.c line 652
struct pid_list * insert_pid_into_pid_list(struct pid_list *list_ptr, signed long int pid);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// manage_loads
// file numad.c line 2041
signed int manage_loads();
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmem
// file /usr/include/string.h line 381
extern void * memmem(const void *, unsigned long int, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// msgget
// file /usr/include/x86_64-linux-gnu/sys/msg.h line 65
extern signed int msgget(signed int, signed int);
// msgrcv
// file /usr/include/x86_64-linux-gnu/sys/msg.h line 71
extern signed long int msgrcv(signed int, void *, unsigned long int, signed long int, signed int);
// msgsnd
// file /usr/include/x86_64-linux-gnu/sys/msg.h line 78
extern signed int msgsnd(signed int, const void *, unsigned long int, signed int);
// name_starts_with_digit
// file numad.c line 969
static signed int name_starts_with_digit(struct dirent *dptr);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// negate_cpu_list
// file numad.c line 298
signed int negate_cpu_list(struct id_list *list_p);
// node_and_digits
// file numad.c line 1169
signed int node_and_digits(struct dirent *dptr);
// numad_log
// file numad.c line 135
void numad_log(signed int level, const char *fmt, ...);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_log_file
// file numad.c line 162
void open_log_file();
// parse_two_arg_values
// file numad.c line 2340
void parse_two_arg_values(char *p, signed int *first_ptr, signed int *second_ptr, signed int first_is_optional, signed int first_scale_digits);
// pick_numa_nodes
// file numad.c line 1715
struct id_list * pick_numa_nodes(signed int pid, signed int cpus, signed int mbs, signed int assume_enough_cpus);
// print_usage_and_exit
// file numad.c line 720
void print_usage_and_exit(char *prog_name);
// print_version_and_exit
// file numad.c line 714
void print_version_and_exit(char *prog_name);
// process_hash_clear_all_bind_time_stamps
// file numad.c line 528
void process_hash_clear_all_bind_time_stamps();
// process_hash_insert
// file numad.c line 469
signed int process_hash_insert(signed int pid);
// process_hash_ix
// file numad.c line 442
signed int process_hash_ix(signed int pid);
// process_hash_lookup
// file numad.c line 450
signed int process_hash_lookup(signed int pid);
// process_hash_rehash
// file numad.c line 534
signed int process_hash_rehash(signed int old_ix);
// process_hash_remove
// file numad.c line 548
signed int process_hash_remove(signed int pid);
// process_hash_table_cleanup
// file numad.c line 617
void process_hash_table_cleanup(unsigned long int update_time);
// process_hash_table_dump
// file numad.c line 604
void process_hash_table_dump();
// process_hash_table_expand
// file numad.c line 574
void process_hash_table_expand();
// process_hash_update
// file numad.c line 490
signed int process_hash_update(struct process_data *newp);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv_msg
// file numad.c line 217
void recv_msg(struct msg *m);
// register_numad_pid
// file numad.c line 807
signed int register_numad_pid();
// remove_pid_from_pid_list
// file numad.c line 681
struct pid_list * remove_pid_from_pid_list(struct pid_list *list_ptr, signed long int pid);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// scandir
// file /usr/include/dirent.h line 254
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// sched_setaffinity
// file /usr/include/sched.h line 118
extern signed int sched_setaffinity(signed int, unsigned long int, const struct anonymous$2 *);
// send_msg
// file numad.c line 225
void send_msg(signed long int dst_pid, signed long int cmd, signed long int arg1, signed long int arg2, char *s);
// set_dynamic_options
// file numad.c line 2237
void * set_dynamic_options(void *arg);
// set_thp_scan_sleep_ms
// file numad.c line 747
void set_thp_scan_sleep_ms(signed int new_ms);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// show_nodes
// file numad.c line 1189
void show_nodes();
// shut_down_numad
// file numad.c line 705
void shut_down_numad();
// sig_handler
// file numad.c line 122
void sig_handler(signed int signum);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// str_from_id_list
// file numad.c line 351
signed int str_from_id_list(char *str_p, signed int str_size, struct id_list *list_p);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_cpu_data
// file numad.c line 1117
void update_cpu_data();
// update_nodes
// file numad.c line 1209
signed int update_nodes();
// update_processes
// file numad.c line 1568
signed int update_processes();
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$10
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$8
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$2
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous$1
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$7
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$5
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$9
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$11
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$4 _kill;
  // _timer
  struct anonymous$5 _timer;
  // _rt
  struct anonymous$6 _rt;
  // _sigchld
  struct anonymous$7 _sigchld;
  // _sigfault
  struct anonymous$8 _sigfault;
  // _sigpoll
  struct anonymous$9 _sigpoll;
  // _sigsys
  struct anonymous$10 _sigsys;
};

struct anonymous$12
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$11 _sifields;
};

union anonymous$0
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$12 *, void *);
};

union anonymous$3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct cpu_data
{
  // time_stamp
  unsigned long int time_stamp;
  // idle
  unsigned long int *idle;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct id_list
{
  // set_p
  struct anonymous$2 *set_p;
  // bytes
  unsigned long int bytes;
};

struct msg_body
{
  // src_pid
  signed long int src_pid;
  // cmd
  signed long int cmd;
  // arg1
  signed long int arg1;
  // arg2
  signed long int arg2;
  // text
  char text[96l];
};

struct msg
{
  // dst_pid
  signed long int dst_pid;
  // body
  struct msg_body body;
};

struct node_data
{
  // node_id
  unsigned long int node_id;
  // MBs_total
  unsigned long int MBs_total;
  // MBs_free
  unsigned long int MBs_free;
  // CPUs_total
  unsigned long int CPUs_total;
  // CPUs_free
  unsigned long int CPUs_free;
  // magnitude
  unsigned long int magnitude;
  // distance
  unsigned char *distance;
  // cpu_list_p
  struct id_list *cpu_list_p;
};

struct pid_list
{
  // pid
  signed long int pid;
  // next
  struct pid_list *next;
};

struct process_data
{
  // pid
  signed int pid;
  // flags
  unsigned int flags;
  // data_time_stamp
  unsigned long int data_time_stamp;
  // bind_time_stamp
  unsigned long int bind_time_stamp;
  // num_threads
  unsigned long int num_threads;
  // MBs_size
  unsigned long int MBs_size;
  // MBs_used
  unsigned long int MBs_used;
  // cpu_util
  unsigned long int cpu_util;
  // CPUs_used
  unsigned long int CPUs_used;
  // CPUs_used_ring_buf
  unsigned long int CPUs_used_ring_buf[8l];
  // ring_buf_ix
  signed int ring_buf_ix;
  // comm
  char *comm;
  // node_list_p
  struct id_list *node_list_p;
  // process_MBs
  unsigned long int *process_MBs;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$0 __sigaction_handler;
  // sa_mask
  struct anonymous$1 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};


// all_cpus_list_p
// file numad.c line 1184
struct id_list *all_cpus_list_p = (struct id_list *)(void *)0;
// all_nodes_list_p
// file numad.c line 1185
struct id_list *all_nodes_list_p = (struct id_list *)(void *)0;
// avg_node_CPUs_free
// file numad.c line 405
signed long int avg_node_CPUs_free = (signed long int)0;
// avg_node_MBs_free
// file numad.c line 406
signed long int avg_node_MBs_free = (signed long int)0;
// cpu_data_buf
// file numad.c line 1114
struct cpu_data cpu_data_buf[2l];
// cur_cpu_data_buf
// file numad.c line 1115
signed int cur_cpu_data_buf = 0;
// exclude_pid_list
// file numad.c line 650
struct pid_list *exclude_pid_list = (struct pid_list *)(void *)0;
// got_sighup
// file numad.c line 118
signed int got_sighup = 0;
// got_sigquit
// file numad.c line 120
signed int got_sigquit = 0;
// got_sigterm
// file numad.c line 119
signed int got_sigterm = 0;
// htt_percent
// file numad.c line 105
signed int htt_percent = 20;
// huge_page_size_in_bytes
// file numad.c line 101
unsigned long int huge_page_size_in_bytes = (unsigned long int)0;
// include_pid_list
// file numad.c line 649
struct pid_list *include_pid_list = (struct pid_list *)(void *)0;
// keep_interleaved_memory
// file numad.c line 110
signed int keep_interleaved_memory = 0;
// log_fs
// file numad.c line 132
struct _IO_FILE *log_fs = (struct _IO_FILE *)(void *)0;
// log_level
// file numad.c line 133
signed int log_level = 5;
// max_interval
// file numad.c line 104
signed int max_interval = 15;
// max_node_CPUs_free
// file numad.c line 403
signed long int max_node_CPUs_free = (signed long int)0;
// max_node_MBs_free
// file numad.c line 404
signed long int max_node_MBs_free = (signed long int)0;
// min_interval
// file numad.c line 103
signed int min_interval = 5;
// min_node_CPUs_free
// file numad.c line 401
signed long int min_node_CPUs_free = (signed long int)0x7fffffff;
// min_node_CPUs_free_ix
// file numad.c line 399
signed int min_node_CPUs_free_ix = -1;
// min_node_MBs_free
// file numad.c line 402
signed long int min_node_MBs_free = (signed long int)0x7fffffff;
// min_node_MBs_free_ix
// file numad.c line 400
signed int min_node_MBs_free_ix = -1;
// msg_qid
// file numad.c line 197
signed int msg_qid;
// node
// file numad.c line 397
struct node_data *node = (struct node_data *)(void *)0;
// node_info_mutex
// file numad.c line 114
union anonymous node_info_mutex;
// node_info_time_stamp
// file numad.c line 1183
unsigned long int node_info_time_stamp = (unsigned long int)0;
// num_cpus
// file numad.c line 97
signed int num_cpus = 0;
// num_nodes
// file numad.c line 98
signed int num_nodes = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// page_size_in_bytes
// file numad.c line 100
unsigned long int page_size_in_bytes = (unsigned long int)0;
// pid_list_mutex
// file numad.c line 113
union anonymous pid_list_mutex;
// process_hash_collisions
// file numad.c line 439
signed int process_hash_collisions = 0;
// process_hash_table
// file numad.c line 440
struct process_data *process_hash_table = (struct process_data *)(void *)0;
// process_hash_table_size
// file numad.c line 438
signed int process_hash_table_size = 0;
// requested_cpus
// file numad.c line 117
signed int requested_cpus = 0;
// requested_mbs
// file numad.c line 116
signed int requested_mbs = 0;
// reserved_cpu_mask_list_p
// file numad.c line 1186
struct id_list *reserved_cpu_mask_list_p = (struct id_list *)(void *)0;
// reserved_cpu_str
// file numad.c line 1187
char *reserved_cpu_str = (char *)(void *)0;
// scan_all_processes
// file numad.c line 109
signed int scan_all_processes = 1;
// stddev_node_CPUs_free
// file numad.c line 407
double stddev_node_CPUs_free = 0.0;
// stddev_node_MBs_free
// file numad.c line 408
double stddev_node_MBs_free = 0.0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sum_CPUs_total
// file numad.c line 115
signed long int sum_CPUs_total = (signed long int)0;
// target_memlocality
// file numad.c line 108
signed int target_memlocality = 90;
// target_utilization
// file numad.c line 107
signed int target_utilization = 85;
// thp_scan_sleep_ms
// file numad.c line 106
signed int thp_scan_sleep_ms = 1000;
// threads_per_core
// file numad.c line 99
signed int threads_per_core = 0;
// use_inactive_file_cache
// file numad.c line 111
signed int use_inactive_file_cache = 1;

// add_ids_to_list_from_str
// file numad.c line 317
signed int add_ids_to_list_from_str(struct id_list *list_p, char *s)
{
  if(list_p == ((struct id_list *)NULL))
  {
    numad_log(2, "Cannot add to NULL list\n");
    exit(1);
  }

  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(s == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen(s);
    tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int in_range;
  signed int next_id;
  _Bool tmp_if_expr$4;
  char *tmp_post$5;
  char *tmp_post$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  char *tmp_post$8;
  if(!tmp_if_expr$2)
  {
    in_range = 0;
    next_id = 0;
    do
    {

    __CPROVER_DUMP_L4:
      ;
      const unsigned short int **return_value___ctype_b_loc$3;
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*s]) == 0)
      {
        if((signed int)*s == 10)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*s == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          break;

        tmp_post$5 = s;
        s = s + 1l;
        if((signed int)*tmp_post$5 == 45)
          in_range = 1;

        goto __CPROVER_DUMP_L4;
      }

      signed int id;
      tmp_post$6 = s;
      s = s + 1l;
      id = (signed int)*tmp_post$6 - 48;
      do
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*s]) == 0)
          break;

        id = id * 10;
        tmp_post$8 = s;
        s = s + 1l;
        id = id + ((signed int)*tmp_post$8 - 48);
      }
      while((_Bool)1);
      if(in_range == 0)
        next_id = id;

      for( ; id >= next_id; next_id = next_id + 1)
      {
        unsigned long int __cpu = (unsigned long int)next_id;
        if(!(__cpu / 8ul >= list_p->bytes))
          ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

        else
          (unsigned long int)0;
      }
      in_range = 0;
    }
    while((_Bool)1);
  }


return_list:
  ;
  signed int return_value___sched_cpucount$9;
  return_value___sched_cpucount$9=__sched_cpucount(list_p->bytes, list_p->set_p);
  return return_value___sched_cpucount$9;
}

// bind_process_and_migrate_memory
// file numad.c line 980
signed int bind_process_and_migrate_memory(struct process_data *p)
{
  unsigned long int t0;
  t0=get_time_stamp();
  _Bool tmp_if_expr$1;
  if(p == ((struct process_data *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = p->pid < 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    numad_log(2, "Bad PID to bind\n");
    exit(1);
  }

  if(p->node_list_p == ((struct id_list *)NULL))
  {
    numad_log(2, "Cannot bind to unspecified node(s)\n");
    exit(1);
  }

  static struct id_list *cpu_bind_list_p;
  if(cpu_bind_list_p == ((struct id_list *)NULL))
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct id_list) /*16ul*/ );
    cpu_bind_list_p = (struct id_list *)return_value_malloc$2;
    if(cpu_bind_list_p == ((struct id_list *)NULL))
    {
      numad_log(2, "INIT_ID_LIST malloc failed\n");
      exit(1);
    }

    cpu_bind_list_p->set_p=__sched_cpualloc((unsigned long int)num_cpus);
    if(cpu_bind_list_p->set_p == ((struct anonymous$2 *)NULL))
    {
      numad_log(2, "CPU_ALLOC failed\n");
      exit(1);
    }

    cpu_bind_list_p->bytes = ((((unsigned long int)num_cpus + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
  }

  do
    __builtin_memset((void *)cpu_bind_list_p->set_p, 0, cpu_bind_list_p->bytes);
  while((_Bool)0);
  signed int nodes;
  nodes=__sched_cpucount(p->node_list_p->bytes, p->node_list_p->set_p);
  signed int node_id = 0;
  signed int tmp_statement_expression$3;
  signed int tmp_if_expr$4;
  for( ; !(nodes == 0); node_id = node_id + 1)
  {
    unsigned long int __cpu = (unsigned long int)node_id;
    if(!(__cpu / 8ul >= p->node_list_p->bytes))
      tmp_if_expr$4 = (signed int)((((const unsigned long int *)p->node_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

    else
      tmp_if_expr$4 = 0;
    tmp_statement_expression$3 = tmp_if_expr$4;
    if(!(tmp_statement_expression$3 == 0))
    {
      struct anonymous$2 *__dest = cpu_bind_list_p->set_p;
      const unsigned long int *__arr1 = cpu_bind_list_p->set_p->__bits;
      const unsigned long int *__arr2 = (node + (signed long int)node_id)->cpu_list_p->set_p->__bits;
      unsigned long int __imax = cpu_bind_list_p->bytes / sizeof(unsigned long int) /*8ul*/ ;
      unsigned long int __i = (unsigned long int)0;
      for( ; !(__i >= __imax); __i = __i + 1ul)
        ((unsigned long int *)__dest->__bits)[(signed long int)__i] = __arr1[(signed long int)__i] | __arr2[(signed long int)__i];
      __dest;
      nodes = nodes - 1;
    }

  }
  char fname[192l];
  struct dirent **namelist;
  snprintf(fname, (unsigned long int)192, "/proc/%d/task", p->pid);
  signed int num_tasks;
  num_tasks=scandir(fname, &namelist, name_starts_with_digit, (signed int (*)(struct dirent **, struct dirent **))(void *)0);
  signed int tmp_statement_expression$11;
  signed int tmp_if_expr$12;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  if(!(num_tasks >= 1))
  {
    numad_log(4, "Could not scandir task list for PID: %d\n", p->pid);
    return 0;
  }

  else
  {
    signed int namelist_ix = 0;
    for( ; !(namelist_ix >= num_tasks); namelist_ix = namelist_ix + 1)
    {
      signed int tid;
      tid=atoi(namelist[(signed long int)namelist_ix]->d_name);
      signed int bind_process_and_migrate_memory$$1$$6$$1$$rc;
      bind_process_and_migrate_memory$$1$$6$$1$$rc=sched_setaffinity(tid, cpu_bind_list_p->bytes, cpu_bind_list_p->set_p);
      if(!(bind_process_and_migrate_memory$$1$$6$$1$$rc >= 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 3)
          numad_log(4, "Tried to move PID %d, TID %d, but it apparently went away.\n", p->pid, tid);

        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        numad_log(3, "Bad sched_setaffinity() on PID %d, TID %d -- errno: %d\n", p->pid, tid, *return_value___errno_location$6);
      }

      free((void *)namelist[(signed long int)namelist_ix]);
    }
    free((void *)namelist);
    signed int num_bytes_in_masks = (signed int)(((unsigned long int)1 + (unsigned long int)(num_nodes + 1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ );
    static unsigned long int *from_mask;
    static unsigned long int *dest_mask;
    static signed int allocated_bytes_in_masks;
    if(!(allocated_bytes_in_masks >= num_bytes_in_masks))
    {
      allocated_bytes_in_masks = num_bytes_in_masks;
      void *return_value_realloc$7;
      return_value_realloc$7=realloc((void *)dest_mask, (unsigned long int)num_bytes_in_masks);
      dest_mask = (unsigned long int *)return_value_realloc$7;
      void *return_value_realloc$8;
      return_value_realloc$8=realloc((void *)from_mask, (unsigned long int)num_bytes_in_masks);
      from_mask = (unsigned long int *)return_value_realloc$8;
      if(dest_mask == ((unsigned long int *)NULL) || from_mask == ((unsigned long int *)NULL))
      {
        numad_log(2, "bit mask malloc failed\n");
        exit(1);
      }

    }

    signed int prev_from_node_id = -1;
    do
    {
      signed int min_dest_node_id = -1;
      signed int max_from_node_id = -1;
      signed int node_ix = 0;
      for( ; !(node_ix >= num_nodes); node_ix = node_ix + 1)
      {
        node_id = (signed int)(node + (signed long int)node_ix)->node_id;
        unsigned long int bind_process_and_migrate_memory$$1$$8$$1$$1$$1$$1$$__cpu = (unsigned long int)node_id;
        if(!(bind_process_and_migrate_memory$$1$$8$$1$$1$$1$$1$$__cpu / 8ul >= p->node_list_p->bytes))
          tmp_if_expr$12 = (signed int)((((const unsigned long int *)p->node_list_p->set_p->__bits)[(signed long int)(bind_process_and_migrate_memory$$1$$8$$1$$1$$1$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << bind_process_and_migrate_memory$$1$$8$$1$$1$$1$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

        else
          tmp_if_expr$12 = 0;
        tmp_statement_expression$11 = tmp_if_expr$12;
        if(!(tmp_statement_expression$11 == 0))
        {
          if(!(min_dest_node_id >= 0))
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = p->process_MBs[(signed long int)min_dest_node_id] >= p->process_MBs[(signed long int)node_id] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$9)
            min_dest_node_id = node_id;

        }

        else
        {
          if(!(max_from_node_id >= 0))
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = p->process_MBs[(signed long int)max_from_node_id] < p->process_MBs[(signed long int)node_id] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
            max_from_node_id = node_id;

        }
      }
      if(p->process_MBs[(signed long int)max_from_node_id] == 0ul || max_from_node_id == prev_from_node_id)
        break;

      memset((void *)dest_mask, 0, (unsigned long int)num_bytes_in_masks);
      memset((void *)from_mask, 0, (unsigned long int)num_bytes_in_masks);
      from_mask[(signed long int)((unsigned long int)max_from_node_id / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = from_mask[(signed long int)((unsigned long int)max_from_node_id / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)(1u << (unsigned long int)max_from_node_id % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ));
      dest_mask[(signed long int)((unsigned long int)min_dest_node_id / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = dest_mask[(signed long int)((unsigned long int)min_dest_node_id / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)(1u << (unsigned long int)min_dest_node_id % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ));
      numad_log(7, "Moving memory from node: %d to node %d\n", max_from_node_id, min_dest_node_id);
      signed int rc;
      signed long int return_value_syscall$13;
      return_value_syscall$13=syscall((signed long int)256, p->pid, num_nodes + 1, from_mask, dest_mask);
      rc = (signed int)return_value_syscall$13;
      if(rc >= 3)
        numad_log(4, "Tried to move PID %d, but %d pages would not move.\n", p->pid, rc);

      else
        if(!(rc >= 0))
        {
          signed int *return_value___errno_location$14;
          return_value___errno_location$14=__errno_location();
          if(*return_value___errno_location$14 == 3)
          {
            numad_log(4, "Tried to move PID %d, but it apparently went away.\n", p->pid);
            return 0;
          }

        }

      p->process_MBs[(signed long int)min_dest_node_id] = p->process_MBs[(signed long int)min_dest_node_id] + p->process_MBs[(signed long int)max_from_node_id];
      p->process_MBs[(signed long int)max_from_node_id] = (unsigned long int)0;
      prev_from_node_id = max_from_node_id;
    }
    while((_Bool)1);
    snprintf(fname, (unsigned long int)192, "/proc/%d", p->pid);
    signed int return_value_access$15;
    return_value_access$15=access(fname, 0);
    if(!(return_value_access$15 >= 0))
    {
      numad_log(4, "Could not migrate pid %d.  Apparently it went away.\n", p->pid);
      return 0;
    }

    else
    {
      unsigned long int t1;
      t1=get_time_stamp();
      p->bind_time_stamp = t1;
      char node_list_str[1024l];
      str_from_id_list(node_list_str, 1024, p->node_list_p);
      numad_log(5, "PID %d moved to node(s) %s in %d.%d seconds\n", p->pid, (const void *)node_list_str, (t1 - t0) / (unsigned long int)100, (t1 - t0) % (unsigned long int)100);
      return 1;
    }
  }
}

// check_prereqs
// file numad.c line 773
void check_prereqs(char *prog_name)
{
  set_thp_scan_sleep_ms(thp_scan_sleep_ms);
}

// close_log_file
// file numad.c line 171
void close_log_file()
{
  if(!(log_fs == ((struct _IO_FILE *)NULL)))
  {
    if(!(log_fs == stderr))
      fclose(log_fs);

    log_fs = (struct _IO_FILE *)(void *)0;
  }

}

// combined_value_of_weighted_resources
// file numad.c line 1687
unsigned long int combined_value_of_weighted_resources(signed int ix, signed int mbs, signed int cpus, unsigned long int MBs_free, unsigned long int CPUs_free)
{
  signed long int needed_mem;
  signed long int needed_cpu;
  signed long int excess_mem;
  signed long int excess_cpu;
  if(!((unsigned long int)mbs >= MBs_free))
  {
    needed_mem = (signed long int)mbs;
    excess_mem = (signed long int)(MBs_free - (unsigned long int)mbs);
  }

  else
  {
    needed_mem = (signed long int)MBs_free;
    excess_mem = (signed long int)0;
  }
  if(!((unsigned long int)cpus >= CPUs_free))
  {
    needed_cpu = (signed long int)cpus;
    excess_cpu = (signed long int)(CPUs_free - (unsigned long int)cpus);
  }

  else
  {
    needed_cpu = (signed long int)CPUs_free;
    excess_cpu = (signed long int)0;
  }
  signed long int memfactor = needed_mem * (signed long int)10 + excess_mem * (signed long int)4;
  signed long int cpufactor = needed_cpu * (signed long int)6 + excess_cpu * (signed long int)1;
  numad_log(7, "    Node[%d]: mem: %ld  cpu: %ld\n", ix, memfactor, cpufactor);
  return (unsigned long int)(memfactor * cpufactor);
}

// count_set_bits_in_hex_list_file
// file numad.c line 852
signed int count_set_bits_in_hex_list_file(char *fname)
{
  signed int sum = 0;
  signed int fd;
  fd=open(fname, 00, 0);
  if(fd >= 0)
  {
    char buf[1024l];
    signed int bytes;
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)buf, (unsigned long int)1024);
    bytes = (signed int)return_value_read$1;
    close(fd);
    signed int ix = 0;
    for( ; !(ix >= bytes); ix = ix + 1)
    {
      char c;
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)buf[(signed long int)ix]);
      c = (char)return_value_tolower$2;
      switch((signed int)c)
      {
        case 48:
        {
          sum = sum + 0;
          break;
        }
        case 49:
        {
          sum = sum + 1;
          break;
        }
        case 50:
        {
          sum = sum + 1;
          break;
        }
        case 51:
        {
          sum = sum + 2;
          break;
        }
        case 52:
        {
          sum = sum + 1;
          break;
        }
        case 53:
        {
          sum = sum + 2;
          break;
        }
        case 54:
        {
          sum = sum + 2;
          break;
        }
        case 55:
        {
          sum = sum + 3;
          break;
        }
        case 56:
        {
          sum = sum + 1;
          break;
        }
        case 57:
        {
          sum = sum + 2;
          break;
        }
        case 97:
        {
          sum = sum + 2;
          break;
        }
        case 98:
        {
          sum = sum + 3;
          break;
        }
        case 99:
        {
          sum = sum + 2;
          break;
        }
        case 100:
        {
          sum = sum + 3;
          break;
        }
        case 101:
        {
          sum = sum + 3;
          break;
        }
        case 102:
        {
          sum = sum + 4;
          break;
        }
        case 32:
        {
          sum = sum + 0;
          break;
        }
        case 44:
        {
          sum = sum + 0;
          break;
        }
        case 10:
        {
          sum = sum + 0;
          break;
        }
        default:
        {
          numad_log(2, "Unexpected character in list\n");
          exit(1);
        }
      }
    }
  }

  return sum;
}

// flush_msg_queue
// file numad.c line 199
void flush_msg_queue()
{
  struct msg msg;
  signed int *return_value___errno_location$1;
  do
  {
    msgrcv(msg_qid, (void *)&msg, sizeof(struct msg_body) /*128ul*/ , (signed long int)0, 04000);
    return_value___errno_location$1=__errno_location();
  }
  while(!(*return_value___errno_location$1 == 42));
}

// get_daemon_pid
// file numad.c line 779
signed int get_daemon_pid()
{
  signed int fd;
  fd=open("/var/run/numad.pid", 00, 0);
  char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *tmp_post$4;
  if(!(fd >= 0))
    return 0;

  else
  {
    char buf[1024l];
    signed int bytes;
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)buf, (unsigned long int)1024);
    bytes = (signed int)return_value_read$1;
    close(fd);
    if(!(bytes >= 1))
      return 0;

    else
    {
      signed int pid;
      char *p = buf;
      tmp_post$2 = p;
      p = p + 1l;
      pid = (signed int)*tmp_post$2 - 48;
      do
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0)
          break;

        pid = pid * 10;
        tmp_post$4 = p;
        p = p + 1l;
        pid = pid + ((signed int)*tmp_post$4 - 48);
      }
      while((_Bool)1);
      char fname[192l];
      snprintf(fname, (unsigned long int)192, "/proc/%d", pid);
      signed int return_value_access$6;
      return_value_access$6=access(fname, 0);
      if(!(return_value_access$6 >= 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 2)
        {
          numad_log(5, "Removing out-of-date numad run file because %s doesn't exist\n", (const void *)fname);
          unlink("/var/run/numad.pid");
        }

        return 0;
      }

      return pid;
    }
  }
}

// get_huge_page_size_in_bytes
// file numad.c line 934
unsigned long int get_huge_page_size_in_bytes()
{
  unsigned long int huge_page_size = (unsigned long int)0;
  struct _IO_FILE *fs;
  fs=fopen("/proc/meminfo", "r");
  if(fs == ((struct _IO_FILE *)NULL))
  {
    numad_log(2, "Can't open /proc/meminfo\n");
    exit(1);
  }

  char buf[1024l];
  char *return_value_fgets$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  do
  {
    return_value_fgets$1=fgets(buf, 1024, fs);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp("Hugepagesize", buf, (unsigned long int)12);
    if(return_value_strncmp$4 == 0)
    {
      char *p = &buf[(signed long int)12];
      do
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0))
          break;

        if(p >= buf + 1024l)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      signed long int return_value_atol$3;
      return_value_atol$3=atol(p);
      huge_page_size = (unsigned long int)return_value_atol$3;
      break;
    }

  }
  while((_Bool)1);
  fclose(fs);
  return huge_page_size * (unsigned long int)1024;
}

// get_num_cpus
// file numad.c line 889
signed int get_num_cpus()
{
  signed int n1;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(83);
  n1 = (signed int)return_value_sysconf$1;
  signed int n2;
  signed long int return_value_sysconf$2;
  return_value_sysconf$2=sysconf(84);
  n2 = (signed int)return_value_sysconf$2;
  if(!(n1 >= n2))
    n1 = n2;

  if(!(n1 >= 0))
  {
    numad_log(2, "Cannot count number of processors\n");
    exit(1);
  }

  return n1;
}

// get_num_kvm_vcpu_threads
// file numad.c line 903
signed int get_num_kvm_vcpu_threads(signed int pid)
{
  char fname[192l];
  snprintf(fname, (unsigned long int)192, "/proc/%d/cmdline", pid);
  signed int fd;
  fd=open(fname, 00, 0);
  const unsigned short int **return_value___ctype_b_loc$3;
  char *tmp_post$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  char *tmp_post$6;
  if(fd >= 0)
  {
    char buf[1024l];
    signed int bytes;
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)buf, (unsigned long int)1024);
    bytes = (signed int)return_value_read$1;
    close(fd);
    if(bytes >= 1)
    {
      char *p;
      void *return_value_memmem$2;
      return_value_memmem$2=memmem((const void *)buf, (unsigned long int)bytes, (const void *)"smp", (unsigned long int)3);
      p = (char *)return_value_memmem$2;
      if(!(p == ((char *)NULL)))
      {
        do
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0))
            break;

          if(p - buf >= (signed long int)(bytes + -2))
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        const unsigned short int **return_value___ctype_b_loc$7;
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0))
        {
          signed int vcpu_threads;
          tmp_post$4 = p;
          p = p + 1l;
          vcpu_threads = (signed int)*tmp_post$4 - 48;
          do
          {
            return_value___ctype_b_loc$5=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*p]) == 0)
              break;

            vcpu_threads = vcpu_threads * 10;
            tmp_post$6 = p;
            p = p + 1l;
            vcpu_threads = vcpu_threads + ((signed int)*tmp_post$6 - 48);
          }
          while((_Bool)1);
          if(vcpu_threads >= 1 && num_cpus >= vcpu_threads)
            return vcpu_threads;

        }

      }

    }

  }

  return 0x7fffffff;
}

// get_stat_data_for_pid
// file numad.c line 1508
struct process_data * get_stat_data_for_pid(signed int pid, char *pid_string)
{
  char fname[192l];
  if(pid >= 0)
    snprintf(fname, (unsigned long int)192, "/proc/%d/stat", pid);

  else
    snprintf(fname, (unsigned long int)192, "/proc/%s/stat", pid_string);
  signed int fd;
  fd=open(fname, 00, 0);
  char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  char *tmp_post$8;
  char *tmp_post$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  char *tmp_post$11;
  char *tmp_post$12;
  const unsigned short int **return_value___ctype_b_loc$13;
  char *tmp_post$14;
  char *tmp_post$15;
  const unsigned short int **return_value___ctype_b_loc$16;
  char *tmp_post$17;
  char *tmp_post$18;
  const unsigned short int **return_value___ctype_b_loc$19;
  char *tmp_post$20;
  if(!(fd >= 0))
  {
    numad_log(4, "Could not open stat file: %s\n", (const void *)fname);
    return (struct process_data *)(void *)0;
  }

  else
  {
    signed int bytes;
    signed long int return_value_read$1;
    static char buf[1024l];
    return_value_read$1=read(fd, (void *)buf, (unsigned long int)1024);
    bytes = (signed int)return_value_read$1;
    close(fd);
    if(!(bytes >= 50))
    {
      numad_log(4, "Could not read stat file: %s\n", (const void *)fname);
      return (struct process_data *)(void *)0;
    }

    else
    {
      unsigned long int val;
      char *p = buf;
      tmp_post$2 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$2 - 48);
      do
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$4 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$4 - 48);
      }
      while((_Bool)1);
      static struct process_data data;
      data.pid = (signed int)val;
      for( ; (signed int)*p == 32; p = p + 1l)
        ;
      data.comm = p;
      for( ; !((signed int)*p == 32); p = p + 1l)
        ;
      tmp_post$5 = p;
      p = p + 1l;
      *tmp_post$5 = (char)0;
      signed int ix = 0;
      for( ; !(ix >= 11); ix = ix + 1)
      {
        for( ; !((signed int)*p == 32); p = p + 1l)
          ;
        for( ; (signed int)*p == 32; p = p + 1l)
          ;
      }
      tmp_post$6 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$6 - 48);
      do
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$8 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$8 - 48);
      }
      while((_Bool)1);
      data.cpu_util = val;
      for( ; (signed int)*p == 32; p = p + 1l)
        ;
      tmp_post$9 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$9 - 48);
      do
      {
        return_value___ctype_b_loc$10=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$11 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$11 - 48);
      }
      while((_Bool)1);
      data.cpu_util = data.cpu_util + val;
      for( ; (signed int)*p == 32; p = p + 1l)
        ;
      signed int get_stat_data_for_pid$$1$$13$$ix = 0;
      for( ; !(get_stat_data_for_pid$$1$$13$$ix >= 4); get_stat_data_for_pid$$1$$13$$ix = get_stat_data_for_pid$$1$$13$$ix + 1)
      {
        for( ; !((signed int)*p == 32); p = p + 1l)
          ;
        for( ; (signed int)*p == 32; p = p + 1l)
          ;
      }
      tmp_post$12 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$12 - 48);
      do
      {
        return_value___ctype_b_loc$13=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$14 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$14 - 48);
      }
      while((_Bool)1);
      data.num_threads = val;
      for( ; (signed int)*p == 32; p = p + 1l)
        ;
      signed int get_stat_data_for_pid$$1$$16$$ix = 0;
      for( ; !(get_stat_data_for_pid$$1$$16$$ix >= 2); get_stat_data_for_pid$$1$$16$$ix = get_stat_data_for_pid$$1$$16$$ix + 1)
      {
        for( ; !((signed int)*p == 32); p = p + 1l)
          ;
        for( ; (signed int)*p == 32; p = p + 1l)
          ;
      }
      tmp_post$15 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$15 - 48);
      do
      {
        return_value___ctype_b_loc$16=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$16)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$17 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$17 - 48);
      }
      while((_Bool)1);
      data.MBs_size = val / (unsigned long int)(1024 * 1024);
      for( ; (signed int)*p == 32; p = p + 1l)
        ;
      tmp_post$18 = p;
      p = p + 1l;
      val = (unsigned long int)((signed int)*tmp_post$18 - 48);
      do
      {
        return_value___ctype_b_loc$19=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$19)[(signed long int)(signed int)*p]) == 0)
          break;

        val = val * (unsigned long int)10;
        tmp_post$20 = p;
        p = p + 1l;
        val = val + (unsigned long int)((signed int)*tmp_post$20 - 48);
      }
      while((_Bool)1);
      data.MBs_used = (val * page_size_in_bytes) / (unsigned long int)(1024 * 1024);
      return &data;
    }
  }
}

// get_time_stamp
// file numad.c line 957
unsigned long int get_time_stamp()
{
  struct timespec ts;
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(1, &ts);
  if(!(return_value_clock_gettime$1 >= 0))
  {
    numad_log(2, "Cannot get clock_gettime()\n");
    exit(1);
  }

  return (unsigned long int)(ts.tv_sec * (signed long int)100 + ts.tv_nsec / (signed long int)(1000000000 / 100));
}

// init_msg_queue
// file numad.c line 206
void init_msg_queue()
{
  signed int msg_key = (signed int)0xdeadbeef;
  signed int msg_flg = 0660 | 01000;
  msg_qid=msgget(msg_key, msg_flg);
  if(!(msg_qid >= 0))
  {
    numad_log(2, "msgget failed\n");
    exit(1);
  }

  flush_msg_queue();
}

// initialize_mem_node_list
// file numad.c line 1643
signed int initialize_mem_node_list(struct process_data *p)
{
  _Bool tmp_if_expr$1;
  if(p == ((struct process_data *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = p->pid < 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    numad_log(2, "Cannot initialize mem node lists with bad PID\n");
    exit(1);
  }

  signed int n = 0;
  char fname[192l];
  char buf[4096l];
  p->process_MBs = (unsigned long int *)(void *)0;
  if(p->node_list_p == ((struct id_list *)NULL))
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct id_list) /*16ul*/ );
    p->node_list_p = (struct id_list *)return_value_malloc$2;
    if(p->node_list_p == ((struct id_list *)NULL))
    {
      numad_log(2, "INIT_ID_LIST malloc failed\n");
      exit(1);
    }

    p->node_list_p->set_p=__sched_cpualloc((unsigned long int)num_nodes);
    if(p->node_list_p->set_p == ((struct anonymous$2 *)NULL))
    {
      numad_log(2, "CPU_ALLOC failed\n");
      exit(1);
    }

    p->node_list_p->bytes = ((((unsigned long int)num_nodes + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
  }

  do
    __builtin_memset((void *)p->node_list_p->set_p, 0, p->node_list_p->bytes);
  while((_Bool)0);
  snprintf(fname, (unsigned long int)192, "/proc/%d/status", p->pid);
  signed int fd;
  fd=open(fname, 00, 0);
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!(fd >= 0))
  {
    numad_log(4, "Tried to research PID %d, but it apparently went away.\n", p->pid);
    return 0;
  }

  else
  {
    signed int bytes;
    signed long int return_value_read$3;
    return_value_read$3=read(fd, (void *)buf, (unsigned long int)4096);
    bytes = (signed int)return_value_read$3;
    close(fd);
    if(!(bytes >= 1))
    {
      numad_log(4, "Tried to research PID %d, but cannot read status file.\n", p->pid);
      return 0;
    }

    else
      if(bytes >= 4096)
        buf[(signed long int)(4096 - 1)] = (char)0;

      else
        buf[(signed long int)bytes] = (char)0;
    char *list_str_p;
    list_str_p=strstr(buf, "Mems_allowed_list:");
    if(list_str_p == ((char *)NULL))
    {
      numad_log(2, "Could not get node Mems_allowed_list\n");
      exit(1);
    }

    list_str_p = list_str_p + (signed long int)18;
    do
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*list_str_p]) == 0))
        break;

      list_str_p = list_str_p + 1l;
    }
    while((_Bool)1);
    n=add_ids_to_list_from_str(p->node_list_p, list_str_p);
    if(!(n >= num_nodes))
    {
      unsigned long int return_value_get_time_stamp$5;
      return_value_get_time_stamp$5=get_time_stamp();
      p->bind_time_stamp = return_value_get_time_stamp$5 - (unsigned long int)(1800 * 100);
    }

    return n;
  }
}

// insert_pid_into_pid_list
// file numad.c line 652
struct pid_list * insert_pid_into_pid_list(struct pid_list *list_ptr, signed long int pid)
{
  if(!(process_hash_table == ((struct process_data *)NULL)))
  {
    signed int hash_ix;
    hash_ix=process_hash_lookup((signed int)pid);
    if(list_ptr == include_pid_list && hash_ix >= 0)
      (process_hash_table + (signed long int)hash_ix)->flags = (process_hash_table + (signed long int)hash_ix)->flags & (unsigned int)~(1 << 0);

  }

  struct pid_list *pid_ptr = list_ptr;
  for( ; !(pid_ptr == ((struct pid_list *)NULL)); pid_ptr = pid_ptr->next)
    if(pid_ptr->pid == pid)
      return list_ptr;

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pid_list) /*16ul*/ );
  pid_ptr = (struct pid_list *)return_value_malloc$1;
  if(pid_ptr == ((struct pid_list *)NULL))
  {
    numad_log(2, "pid_list malloc failed\n");
    exit(1);
  }

  pid_ptr->pid = pid;
  pid_ptr->next = list_ptr;
  list_ptr = pid_ptr;
  return list_ptr;
}

// main
// file numad.c line 2385
signed int main(signed int argc, char **argv)
{
  signed int opt;
  signed int C_flag = 0;
  signed int d_flag = 0;
  signed int H_flag = 0;
  signed int i_flag = 0;
  signed int K_flag = 0;
  signed int l_flag = 0;
  signed int m_flag = 0;
  signed int p_flag = 0;
  signed int r_flag = 0;
  signed int S_flag = 0;
  signed int t_flag = 0;
  signed int u_flag = 0;
  signed int v_flag = 0;
  signed int w_flag = 0;
  signed int x_flag = 0;
  signed int tmp_int = 0;
  signed long int list_pid = (signed long int)0;
  signed int return_value_atoi$1;
  signed int return_value_atoi$2;
  signed int return_value_atoi$3;
  do
  {
    opt=getopt(argc, argv, "C:dD:hH:i:K:l:p:r:R:S:t:u:vVw:x:");
    if(opt == -1)
      break;

    switch(opt)
    {
      case 67:
      {
        C_flag = 1;
        return_value_atoi$1=atoi(optarg);
        use_inactive_file_cache = (signed int)(return_value_atoi$1 != 0);
        break;
      }
      case 100:
      {
        d_flag = 1;
        log_level = 7;
        break;
      }
      case 68:
        break;
      case 104:
      {
        print_usage_and_exit(argv[(signed long int)0]);
        break;
      }
      case 72:
      {
        tmp_int=atoi(optarg);
        if(tmp_int == 0 || tmp_int >= 10 && !(tmp_int >= 1000001))
        {
          H_flag = 1;
          thp_scan_sleep_ms = tmp_int;
        }

        else
        {
          fprintf(stderr, "THP scan_sleep_ms must be > 9 and < 1000001\n");
          exit(1);
        }
        break;
      }
      case 105:
      {
        i_flag = 1;
        parse_two_arg_values(optarg, &min_interval, &max_interval, 1, 0);
        break;
      }
      case 75:
      {
        K_flag = 1;
        return_value_atoi$2=atoi(optarg);
        keep_interleaved_memory = (signed int)(return_value_atoi$2 != 0);
        break;
      }
      case 108:
      {
        l_flag = 1;
        log_level=atoi(optarg);
        break;
      }
      case 109:
      {
        tmp_int=atoi(optarg);
        if(tmp_int >= 50 && !(tmp_int >= 101))
        {
          m_flag = 1;
          target_memlocality = tmp_int;
        }

        break;
      }
      case 112:
      {
        p_flag = 1;
        list_pid=atol(optarg);
        exclude_pid_list=remove_pid_from_pid_list(exclude_pid_list, list_pid);
        include_pid_list=insert_pid_into_pid_list(include_pid_list, list_pid);
        break;
      }
      case 114:
      {
        r_flag = 1;
        list_pid=atol(optarg);
        include_pid_list=remove_pid_from_pid_list(include_pid_list, list_pid);
        exclude_pid_list=remove_pid_from_pid_list(exclude_pid_list, list_pid);
        break;
      }
      case 82:
      {
        reserved_cpu_str=strdup(optarg);
        break;
      }
      case 83:
      {
        S_flag = 1;
        return_value_atoi$3=atoi(optarg);
        scan_all_processes = (signed int)(return_value_atoi$3 != 0);
        break;
      }
      case 116:
      {
        tmp_int=atoi(optarg);
        if(tmp_int >= 0 && !(tmp_int >= 101))
        {
          t_flag = 1;
          htt_percent = tmp_int;
        }

        break;
      }
      case 117:
      {
        tmp_int=atoi(optarg);
        if(tmp_int >= 10 && !(tmp_int >= 131))
        {
          u_flag = 1;
          target_utilization = tmp_int;
        }

        break;
      }
      case 118:
      {
        v_flag = 1;
        log_level = 6;
        break;
      }
      case 86:
      {
        print_version_and_exit(argv[(signed long int)0]);
        break;
      }
      case 119:
      {
        w_flag = 1;
        parse_two_arg_values(optarg, &requested_cpus, &requested_mbs, 0, 2);
        break;
      }
      case 120:
      {
        x_flag = 1;
        list_pid=atol(optarg);
        include_pid_list=remove_pid_from_pid_list(include_pid_list, list_pid);
        exclude_pid_list=insert_pid_into_pid_list(exclude_pid_list, list_pid);
        break;
      }
      default:
        print_usage_and_exit(argv[(signed long int)0]);
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
  {
    fprintf(stderr, "Unexpected arg = %s\n", argv[(signed long int)optind]);
    exit(1);
  }

  if(!(i_flag == 0))
  {
    if(!(max_interval == 0) && !(max_interval >= min_interval))
    {
      fprintf(stderr, "Max interval (%d) must be greater than min interval (%d)\n", max_interval, min_interval);
      exit(1);
    }

  }

  open_log_file();
  init_msg_queue();
  num_cpus=get_num_cpus();
  signed long int return_value_sysconf$4;
  return_value_sysconf$4=sysconf(30);
  page_size_in_bytes = (unsigned long int)return_value_sysconf$4;
  huge_page_size_in_bytes=get_huge_page_size_in_bytes();
  signed int daemon_pid;
  daemon_pid=get_daemon_pid();
  if(daemon_pid >= 1)
  {
    struct msg msg;
    if(!(C_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)67, (signed long int)use_inactive_file_cache, (signed long int)0, "");

    if(!(H_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)72, (signed long int)thp_scan_sleep_ms, (signed long int)0, "");

    if(!(i_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)105, (signed long int)min_interval, (signed long int)max_interval, "");

    if(!(K_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)75, (signed long int)keep_interleaved_memory, (signed long int)0, "");

    if(!(d_flag == 0) || !(l_flag == 0) || !(v_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)108, (signed long int)log_level, (signed long int)0, "");

    if(!(m_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)109, (signed long int)target_memlocality, (signed long int)0, "");

    if(!(p_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)112, list_pid, (signed long int)0, "");

    if(!(r_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)114, list_pid, (signed long int)0, "");

    if(!(S_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)83, (signed long int)scan_all_processes, (signed long int)0, "");

    if(!(t_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)116, (signed long int)htt_percent, (signed long int)0, "");

    if(!(u_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)117, (signed long int)target_utilization, (signed long int)0, "");

    if(!(w_flag == 0))
    {
      send_msg((signed long int)daemon_pid, (signed long int)119, (signed long int)requested_cpus, (signed long int)requested_mbs, "");
      recv_msg(&msg);
      fprintf(stdout, "%s\n", (const void *)msg.body.text);
    }

    if(!(x_flag == 0))
      send_msg((signed long int)daemon_pid, (signed long int)120, list_pid, (signed long int)0, "");

    close_log_file();
    exit(0);
  }

  if(!(reserved_cpu_str == ((char *)NULL)))
  {
    if(reserved_cpu_mask_list_p == ((struct id_list *)NULL))
    {
      void *return_value_malloc$5;
      return_value_malloc$5=malloc(sizeof(struct id_list) /*16ul*/ );
      reserved_cpu_mask_list_p = (struct id_list *)return_value_malloc$5;
      if(reserved_cpu_mask_list_p == ((struct id_list *)NULL))
      {
        numad_log(2, "INIT_ID_LIST malloc failed\n");
        exit(1);
      }

      reserved_cpu_mask_list_p->set_p=__sched_cpualloc((unsigned long int)num_cpus);
      if(reserved_cpu_mask_list_p->set_p == ((struct anonymous$2 *)NULL))
      {
        numad_log(2, "CPU_ALLOC failed\n");
        exit(1);
      }

      reserved_cpu_mask_list_p->bytes = ((((unsigned long int)num_cpus + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
    }

    do
      __builtin_memset((void *)reserved_cpu_mask_list_p->set_p, 0, reserved_cpu_mask_list_p->bytes);
    while((_Bool)0);
    signed int n;
    n=add_ids_to_list_from_str(reserved_cpu_mask_list_p, reserved_cpu_str);
    char buf[1024l];
    str_from_id_list(buf, 1024, reserved_cpu_mask_list_p);
    numad_log(5, "Reserving %d CPUs (%s) for non-numad use\n", n, (const void *)buf);
    negate_cpu_list(reserved_cpu_mask_list_p);
  }

  _Bool tmp_if_expr$10;
  signed int return_value_sigaction$9;
  _Bool tmp_if_expr$12;
  signed int return_value_sigaction$11;
  if(!(w_flag == 0))
  {
    update_nodes();
    sleep((unsigned int)2);
    update_nodes();
    numad_log(5, "Getting NUMA pre-placement advice for %d CPUs and %d MBs\n", requested_cpus, requested_mbs);
    struct id_list *node_list_p;
    node_list_p=pick_numa_nodes(-1, requested_cpus, requested_mbs, 0);
    char main$$1$$6$$buf[1024l];
    str_from_id_list(main$$1$$6$$buf, 1024, node_list_p);
    fprintf(stdout, "%s\n", (const void *)main$$1$$6$$buf);
    close_log_file();
    exit(0);
  }

  else
    if(max_interval >= 1)
    {
      check_prereqs(argv[(signed long int)0]);
      daemon_pid=fork();
      if(!(daemon_pid >= 0))
      {
        numad_log(2, "fork() failed\n");
        exit(1);
      }

      if(daemon_pid >= 1)
        exit(0);

      umask((unsigned int)(0200 >> 3 | (0200 >> 3) >> 3));
      signed int sid;
      sid=setsid();
      if(!(sid >= 0))
      {
        numad_log(2, "setsid() failed\n");
        exit(1);
      }

      signed int return_value_chdir$6;
      return_value_chdir$6=chdir("/");
      if(!(return_value_chdir$6 >= 0))
      {
        numad_log(2, "chdir() failed");
        exit(1);
      }

      daemon_pid=register_numad_pid();
      signed int return_value_getpid$7;
      return_value_getpid$7=getpid();
      if(!(daemon_pid == return_value_getpid$7))
      {
        numad_log(2, "Could not register daemon PID\n");
        exit(1);
      }

      fclose(stdin);
      fclose(stdout);
      if(!(log_fs == stderr))
        fclose(stderr);

      struct sigaction sa;
      memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
      sa.__sigaction_handler.sa_handler = sig_handler;
      signed int return_value_sigaction$8;
      return_value_sigaction$8=sigaction(1, &sa, (struct sigaction *)(void *)0);
      if(!(return_value_sigaction$8 == 0))
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_sigaction$9=sigaction(15, &sa, (struct sigaction *)(void *)0);
        tmp_if_expr$10 = return_value_sigaction$9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_sigaction$11=sigaction(3, &sa, (struct sigaction *)(void *)0);
        tmp_if_expr$12 = return_value_sigaction$11 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
      {
        numad_log(2, "sigaction does not work?\n");
        exit(1);
      }

      process_hash_table_expand();
      pthread_mutex_init(&pid_list_mutex, (const union anonymous$3 *)(void *)0);
      pthread_mutex_init(&node_info_mutex, (const union anonymous$3 *)(void *)0);
      union pthread_attr_t attr;
      signed int return_value_pthread_attr_init$13;
      return_value_pthread_attr_init$13=pthread_attr_init(&attr);
      if(!(return_value_pthread_attr_init$13 == 0))
      {
        numad_log(2, "pthread_attr_init failure\n");
        exit(1);
      }

      unsigned long int tid;
      signed int return_value_pthread_create$14;
      return_value_pthread_create$14=pthread_create(&tid, &attr, set_dynamic_options, (void *)&tid);
      if(!(return_value_pthread_create$14 == 0))
      {
        numad_log(2, "pthread_create failure: setting thread\n");
        exit(1);
      }

      do
      {
        signed int interval = max_interval;
        pthread_mutex_lock(&node_info_mutex);
        signed int nodes;
        nodes=update_nodes();
        pthread_mutex_unlock(&node_info_mutex);
        if(nodes >= 2)
        {
          update_processes();
          interval=manage_loads();
          if(!(interval >= max_interval))
            nodes=update_nodes();

        }

        sleep((unsigned int)interval);
        if(!((got_sigquit | got_sigterm) == 0))
          shut_down_numad();

        if(!(got_sighup == 0))
        {
          got_sighup = 0;
          close_log_file();
          open_log_file();
        }

      }
      while((_Bool)1);
      signed int return_value_pthread_attr_destroy$15;
      return_value_pthread_attr_destroy$15=pthread_attr_destroy(&attr);
      if(!(return_value_pthread_attr_destroy$15 == 0))
        numad_log(4, "pthread_attr_destroy failure\n");

      pthread_mutex_destroy(&pid_list_mutex);
      pthread_mutex_destroy(&node_info_mutex);
    }

  exit(0);
}

// manage_loads
// file numad.c line 2041
signed int manage_loads()
{
  unsigned long int time_stamp;
  time_stamp=get_time_stamp();
  static struct process_data **pindex;
  static signed int pindex_size;
  if(!(pindex_size >= process_hash_table_size))
  {
    pindex_size = process_hash_table_size;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)pindex, (unsigned long int)pindex_size * sizeof(struct process_data *) /*8ul*/ );
    pindex = (struct process_data **)return_value_realloc$1;
    if(pindex == ((struct process_data **)NULL))
    {
      numad_log(2, "pindex realloc failed\n");
      exit(1);
    }

    return min_interval / 2;
  }

  memset((void *)pindex, 0, (unsigned long int)pindex_size * sizeof(struct process_data *) /*8ul*/ );
  signed int nprocs = 0;
  signed long int sum_CPUs_used = (signed long int)0;
  signed int ix = 0;
  signed int tmp_post$2;
  for( ; !(ix >= process_hash_table_size); ix = ix + 1)
  {
    struct process_data *p = &process_hash_table[(signed long int)ix];
    if(!(p->pid == 0))
    {
      if(p->CPUs_used >= 51ul)
      {
        if(p->MBs_used >= 301ul)
        {
          tmp_post$2 = nprocs;
          nprocs = nprocs + 1;
          pindex[(signed long int)tmp_post$2] = p;
          sum_CPUs_used = sum_CPUs_used + (signed long int)p->CPUs_used;
          if(p->node_list_p == ((struct id_list *)NULL))
            initialize_mem_node_list(p);

        }

      }

    }

  }
  signed int num_unbound = 0;
  signed int ij = 0;
  signed int tmp_post$3;
  for( ; !(ij >= nprocs); ij = ij + 1)
    if(pindex[(signed long int)ij]->bind_time_stamp == 0ul)
    {
      struct process_data *tmp = pindex[(signed long int)num_unbound];
      tmp_post$3 = num_unbound;
      num_unbound = num_unbound + 1;
      pindex[(signed long int)tmp_post$3] = pindex[(signed long int)ij];
      pindex[(signed long int)ij] = tmp;
    }

  signed int manage_loads$$1$$4$$ij = 0;
  for( ; !(manage_loads$$1$$4$$ij >= num_unbound); manage_loads$$1$$4$$ij = manage_loads$$1$$4$$ij + 1)
  {
    signed int best = manage_loads$$1$$4$$ij;
    signed int ik = manage_loads$$1$$4$$ij + 1;
    for( ; !(ik >= num_unbound); ik = ik + 1)
    {
      unsigned long int ik_mag = pindex[(signed long int)ik]->CPUs_used * pindex[(signed long int)ik]->MBs_used;
      unsigned long int best_mag = pindex[(signed long int)best]->CPUs_used * pindex[(signed long int)best]->MBs_used;
      if(!(best_mag >= ik_mag))
        best = ik;

    }
    if(!(best == manage_loads$$1$$4$$ij))
    {
      struct process_data *manage_loads$$1$$4$$1$$2$$tmp = pindex[(signed long int)manage_loads$$1$$4$$ij];
      pindex[(signed long int)manage_loads$$1$$4$$ij] = pindex[(signed long int)best];
      pindex[(signed long int)best] = manage_loads$$1$$4$$1$$2$$tmp;
    }

  }
  signed int manage_loads$$1$$5$$ij = num_unbound;
  for( ; !(manage_loads$$1$$5$$ij >= nprocs); manage_loads$$1$$5$$ij = manage_loads$$1$$5$$ij + 1)
  {
    signed int manage_loads$$1$$5$$1$$best = manage_loads$$1$$5$$ij;
    signed int manage_loads$$1$$5$$1$$1$$ik = manage_loads$$1$$5$$ij + 1;
    for( ; !(manage_loads$$1$$5$$1$$1$$ik >= nprocs); manage_loads$$1$$5$$1$$1$$ik = manage_loads$$1$$5$$1$$1$$ik + 1)
    {
      unsigned long int manage_loads$$1$$5$$1$$1$$1$$ik_mag = pindex[(signed long int)manage_loads$$1$$5$$1$$1$$ik]->CPUs_used * pindex[(signed long int)manage_loads$$1$$5$$1$$1$$ik]->MBs_used;
      unsigned long int manage_loads$$1$$5$$1$$1$$1$$best_mag = pindex[(signed long int)manage_loads$$1$$5$$1$$best]->CPUs_used * pindex[(signed long int)manage_loads$$1$$5$$1$$best]->MBs_used;
      unsigned long int min_mag = manage_loads$$1$$5$$1$$1$$1$$ik_mag;
      unsigned long int diff_mag = manage_loads$$1$$5$$1$$1$$1$$best_mag - manage_loads$$1$$5$$1$$1$$1$$ik_mag;
      if(diff_mag >= 1ul && !(min_mag / diff_mag >= 5ul))
      {
        if(manage_loads$$1$$5$$1$$1$$1$$best_mag >= manage_loads$$1$$5$$1$$1$$1$$ik_mag)
          goto __CPROVER_DUMP_L22;

      }

      else
        if(!(pindex[(signed long int)manage_loads$$1$$5$$1$$best]->bind_time_stamp >= pindex[(signed long int)manage_loads$$1$$5$$1$$1$$ik]->bind_time_stamp))
          goto __CPROVER_DUMP_L22;

      manage_loads$$1$$5$$1$$best = manage_loads$$1$$5$$1$$1$$ik;

    __CPROVER_DUMP_L22:
      ;
    }
    if(!(manage_loads$$1$$5$$1$$best == manage_loads$$1$$5$$ij))
    {
      struct process_data *manage_loads$$1$$5$$1$$2$$tmp = pindex[(signed long int)manage_loads$$1$$5$$ij];
      pindex[(signed long int)manage_loads$$1$$5$$ij] = pindex[(signed long int)manage_loads$$1$$5$$1$$best];
      pindex[(signed long int)manage_loads$$1$$5$$1$$best] = manage_loads$$1$$5$$1$$2$$tmp;
    }

  }
  if(log_level >= 6 && nprocs >= 1)
  {
    numad_log(6, "Candidates: %d\n", nprocs);
    signed int manage_loads$$1$$6$$1$$ix = 0;
    for( ; !(manage_loads$$1$$6$$1$$ix >= nprocs); manage_loads$$1$$6$$1$$ix = manage_loads$$1$$6$$1$$ix + 1)
    {
      struct process_data *manage_loads$$1$$6$$1$$1$$p = pindex[(signed long int)manage_loads$$1$$6$$1$$ix];
      char buf[1024l];
      str_from_id_list(buf, 1024, manage_loads$$1$$6$$1$$1$$p->node_list_p);
      fprintf(log_fs, "%ld: PID %d: %s, Threads %2ld, MBs_size %6ld, MBs_used %6ld, CPUs_used %4ld, Magnitude %6ld, Nodes: %s\n", manage_loads$$1$$6$$1$$1$$p->data_time_stamp, manage_loads$$1$$6$$1$$1$$p->pid, manage_loads$$1$$6$$1$$1$$p->comm, manage_loads$$1$$6$$1$$1$$p->num_threads, manage_loads$$1$$6$$1$$1$$p->MBs_size, manage_loads$$1$$6$$1$$1$$p->MBs_used, manage_loads$$1$$6$$1$$1$$p->CPUs_used, manage_loads$$1$$6$$1$$1$$p->MBs_used * manage_loads$$1$$6$$1$$1$$p->CPUs_used, (const void *)buf);
    }
    fflush(log_fs);
  }

  signed int manage_loads$$1$$7$$ix = 0;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$5;
  signed int tmp_statement_expression$6;
  signed int tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  signed int tmp_statement_expression$8;
  signed int tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$15;
  signed int return_value_abs$13;
  signed int return_value_abs$14;
  _Bool tmp_if_expr$18;
  signed int return_value_abs$16;
  signed int return_value_abs$17;
  signed int return_value_bind_process_and_migrate_memory$19;
  for( ; !(manage_loads$$1$$7$$ix >= nprocs); manage_loads$$1$$7$$ix = manage_loads$$1$$7$$ix + 1)
  {
    struct process_data *manage_loads$$1$$7$$1$$p = pindex[(signed long int)manage_loads$$1$$7$$ix];
    if((1u & manage_loads$$1$$7$$1$$p->flags) >= 1u)
    {
      if(time_stamp >= 180000ul + manage_loads$$1$$7$$1$$p->bind_time_stamp)
        goto __CPROVER_DUMP_L31;

      if(log_level >= 7)
        numad_log(7, "Skipping evaluation of PID %d because of interleaved memory.\n", manage_loads$$1$$7$$1$$p->pid);

    }

    else
    {

    __CPROVER_DUMP_L31:
      ;
      signed int mem_target_utilization = target_utilization;
      signed int cpu_target_utilization = target_utilization;
      if(mem_target_utilization >= 101)
        mem_target_utilization = 100;

      signed int mb_request;
      if(!(node->MBs_total >= manage_loads$$1$$7$$1$$p->MBs_size))
        tmp_if_expr$4 = (manage_loads$$1$$7$$1$$p->MBs_used * (unsigned long int)5) / (unsigned long int)4 > (node + (signed long int)0)->MBs_total ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        mb_request = (signed int)((manage_loads$$1$$7$$1$$p->MBs_size * (unsigned long int)100) / (unsigned long int)mem_target_utilization);

      else
        mb_request = (signed int)((manage_loads$$1$$7$$1$$p->MBs_used * (unsigned long int)100) / (unsigned long int)mem_target_utilization);
      signed int cpu_request = (signed int)((manage_loads$$1$$7$$1$$p->CPUs_used * (unsigned long int)100) / (unsigned long int)cpu_target_utilization);
      signed int thread_limit = (signed int)manage_loads$$1$$7$$1$$p->num_threads;
      if(!(manage_loads$$1$$7$$1$$p->comm == ((char *)NULL)))
      {
        if((signed int)*manage_loads$$1$$7$$1$$p->comm == 40)
        {
          if((signed int)manage_loads$$1$$7$$1$$p->comm[1l] == 113)
          {
            return_value_strcmp$5=strcmp(manage_loads$$1$$7$$1$$p->comm, "(qemu-kvm)");
            if(return_value_strcmp$5 == 0)
            {
              signed int kvm_vcpu_threads;
              kvm_vcpu_threads=get_num_kvm_vcpu_threads(manage_loads$$1$$7$$1$$p->pid);
              if(!(kvm_vcpu_threads >= thread_limit))
                thread_limit = kvm_vcpu_threads;

            }

          }

        }

      }

      thread_limit = thread_limit * 100;
      if(!(thread_limit >= cpu_request))
        cpu_request = thread_limit;

      if(!(time_stamp >= 30000ul + manage_loads$$1$$7$$1$$p->bind_time_stamp))
      {
        unsigned long int __cpu = (unsigned long int)min_node_CPUs_free_ix;
        if(!(__cpu / 8ul >= manage_loads$$1$$7$$1$$p->node_list_p->bytes))
          tmp_if_expr$7 = (signed int)((((const unsigned long int *)manage_loads$$1$$7$$1$$p->node_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

        else
          tmp_if_expr$7 = 0;
        tmp_statement_expression$6 = tmp_if_expr$7;
        if(!(tmp_statement_expression$6 == 0))
          tmp_if_expr$10 = (_Bool)1;

        else
        {
          unsigned long int manage_loads$$1$$7$$1$$7$$2$$__cpu = (unsigned long int)min_node_MBs_free_ix;
          if(!(manage_loads$$1$$7$$1$$7$$2$$__cpu / 8ul >= manage_loads$$1$$7$$1$$p->node_list_p->bytes))
            tmp_if_expr$9 = (signed int)((((const unsigned long int *)manage_loads$$1$$7$$1$$p->node_list_p->set_p->__bits)[(signed long int)(manage_loads$$1$$7$$1$$7$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << manage_loads$$1$$7$$1$$7$$2$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

          else
            tmp_if_expr$9 = 0;
          tmp_statement_expression$8 = tmp_if_expr$9;
          tmp_if_expr$10 = tmp_statement_expression$8 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$10)
          tmp_if_expr$11 = (unsigned long int)cpu_request < (node + (signed long int)0)->CPUs_total ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
          tmp_if_expr$12 = (unsigned long int)mb_request < (node + (signed long int)0)->MBs_total ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
        {
          return_value_abs$13=abs((signed int)(((unsigned long int)min_node_CPUs_free + manage_loads$$1$$7$$1$$p->CPUs_used) - (unsigned long int)avg_node_CPUs_free));
          return_value_abs$14=abs((signed int)(((unsigned long int)max_node_CPUs_free - manage_loads$$1$$7$$1$$p->CPUs_used) - (unsigned long int)avg_node_CPUs_free));
          tmp_if_expr$15 = (signed long int)(return_value_abs$13 + return_value_abs$14) < (max_node_CPUs_free - min_node_CPUs_free) - (signed long int)50 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$15 = (_Bool)0;
        if(tmp_if_expr$15)
        {
          return_value_abs$16=abs((signed int)(((unsigned long int)min_node_MBs_free + manage_loads$$1$$7$$1$$p->MBs_used) - (unsigned long int)avg_node_MBs_free));
          return_value_abs$17=abs((signed int)(((unsigned long int)max_node_MBs_free - manage_loads$$1$$7$$1$$p->MBs_used) - (unsigned long int)avg_node_MBs_free));
          tmp_if_expr$18 = (signed long int)(return_value_abs$16 + return_value_abs$17) < max_node_MBs_free - min_node_MBs_free ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$18 = (_Bool)0;
        if(tmp_if_expr$18)
        {
          if(log_level >= 7)
            numad_log(7, "Bypassing delay for %d because it looks like it can do better.\n", manage_loads$$1$$7$$1$$p->pid);

        }

        else
        {
          if(log_level >= 7)
            numad_log(7, "Skipping evaluation of PID %d because done too recently.\n", manage_loads$$1$$7$$1$$p->pid);

          goto __CPROVER_DUMP_L60;
        }
      }

      pthread_mutex_lock(&node_info_mutex);
      signed int assume_enough_cpus = (signed int)(sum_CPUs_used <= sum_CPUs_total);
      struct id_list *node_list_p;
      node_list_p=pick_numa_nodes(manage_loads$$1$$7$$1$$p->pid, cpu_request, mb_request, assume_enough_cpus);
      if(!(node_list_p == ((struct id_list *)NULL)))
      {
        return_value_bind_process_and_migrate_memory$19=bind_process_and_migrate_memory(manage_loads$$1$$7$$1$$p);
        if(!(return_value_bind_process_and_migrate_memory$19 == 0))
        {
          pthread_mutex_unlock(&node_info_mutex);
          return min_interval;
        }

      }

      pthread_mutex_unlock(&node_info_mutex);
    }

  __CPROVER_DUMP_L60:
    ;
  }
  return max_interval;
}

// name_starts_with_digit
// file numad.c line 969
static signed int name_starts_with_digit(struct dirent *dptr)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  return_value___ctype_b_loc$1=__ctype_b_loc();
  return (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)dptr->d_name[(signed long int)0]] & (signed int)(unsigned short int)2048;
}

// negate_cpu_list
// file numad.c line 298
signed int negate_cpu_list(struct id_list *list_p)
{
  if(list_p == ((struct id_list *)NULL))
  {
    numad_log(2, "Cannot negate a NULL list\n");
    exit(1);
  }

  if(!(num_cpus >= 1))
  {
    numad_log(2, "No CPUs to negate in list!\n");
    exit(1);
  }

  signed int ix = 0;
  signed int tmp_statement_expression$1;
  signed int tmp_if_expr$2;
  for( ; !(ix >= num_cpus); ix = ix + 1)
  {
    unsigned long int __cpu = (unsigned long int)ix;
    if(!(__cpu / 8ul >= list_p->bytes))
      tmp_if_expr$2 = (signed int)((((const unsigned long int *)list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

    else
      tmp_if_expr$2 = 0;
    tmp_statement_expression$1 = tmp_if_expr$2;
    if(!(tmp_statement_expression$1 == 0))
    {
      unsigned long int negate_cpu_list$$1$$3$$1$$2$$1$$__cpu = (unsigned long int)ix;
      if(!(negate_cpu_list$$1$$3$$1$$2$$1$$__cpu / 8ul >= list_p->bytes))
        ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(negate_cpu_list$$1$$3$$1$$2$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(negate_cpu_list$$1$$3$$1$$2$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & ~((unsigned long int)1 << negate_cpu_list$$1$$3$$1$$2$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ));

      else
        (unsigned long int)0;
    }

    else
    {
      unsigned long int negate_cpu_list$$1$$3$$1$$3$$1$$__cpu = (unsigned long int)ix;
      if(!(negate_cpu_list$$1$$3$$1$$3$$1$$__cpu / 8ul >= list_p->bytes))
        ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(negate_cpu_list$$1$$3$$1$$3$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)list_p->set_p->__bits)[(signed long int)(negate_cpu_list$$1$$3$$1$$3$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << negate_cpu_list$$1$$3$$1$$3$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

      else
        (unsigned long int)0;
    }
  }
  signed int return_value___sched_cpucount$3;
  return_value___sched_cpucount$3=__sched_cpucount(list_p->bytes, list_p->set_p);
  return return_value___sched_cpucount$3;
}

// node_and_digits
// file numad.c line 1169
signed int node_and_digits(struct dirent *dptr)
{
  char *p = (char *)dptr->d_name;
  char *tmp_post$1 = p;
  p = p + 1l;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$6;
  if(!((signed int)*tmp_post$1 == 110))
    return 0;

  else
  {
    tmp_post$2 = p;
    p = p + 1l;
    if(!((signed int)*tmp_post$2 == 111))
      return 0;

    else
    {
      tmp_post$3 = p;
      p = p + 1l;
      if(!((signed int)*tmp_post$3 == 100))
        return 0;

      else
      {
        tmp_post$4 = p;
        p = p + 1l;
        if(!((signed int)*tmp_post$4 == 101))
          return 0;

        else
        {
          do
          {
            const unsigned short int **return_value___ctype_b_loc$5;
            return_value___ctype_b_loc$5=__ctype_b_loc();
            tmp_post$6 = p;
            p = p + 1l;
            if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*tmp_post$6]) == 0)
              return 0;

          }
          while(!((signed int)*p == 0));
          return 1;
        }
      }
    }
  }
}

// numad_log
// file numad.c line 135
void numad_log(signed int level, const char *fmt, ...)
{
  char *tmp_post$3;
  char *tmp_post$4;
  if(log_level >= level)
  {
    char buf[1024l];
    signed long int ts;
    ts=time((signed long int *)(void *)0);
    char *return_value_ctime$1;
    return_value_ctime$1=ctime(&ts);
    strncpy(buf, return_value_ctime$1, sizeof(char [1024l]) /*1024ul*/ );
    char *p;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    p = &buf[(signed long int)(return_value_strlen$2 - (unsigned long int)1)];
    tmp_post$3 = p;
    p = p + 1l;
    *tmp_post$3 = (char)58;
    tmp_post$4 = p;
    p = p + 1l;
    *tmp_post$4 = (char)32;
    void **ap = (void **)&fmt;
    vsnprintf(p, (unsigned long int)1024, fmt, ap);
    ap = ((void **)NULL);
    fprintf(log_fs, "%s", (const void *)buf);
    fflush(log_fs);
  }

}

// open_log_file
// file numad.c line 162
void open_log_file()
{
  log_fs=fopen("/var/log/numad.log", "a");
  if(log_fs == ((struct _IO_FILE *)NULL))
  {
    log_fs = stderr;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    numad_log(3, "Cannot open numad log file (errno: %d) -- using stderr\n", *return_value___errno_location$1);
  }

}

// parse_two_arg_values
// file numad.c line 2340
void parse_two_arg_values(char *p, signed int *first_ptr, signed int *second_ptr, signed int first_is_optional, signed int first_scale_digits)
{
  char *orig_p = p;
  char *q = (char *)(void *)0;
  signed int second = -1;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  signed int first;
  signed long int return_value_strtol$2;
  return_value_strtol$2=strtol(p, &p, 10);
  first = (signed int)return_value_strtol$2;
  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  if(p == orig_p || !(*return_value___errno_location$3 == 0) || !(first >= 0))
  {
    fprintf(stderr, "Can't parse arg value(s): %s\n", orig_p);
    exit(1);
  }

  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  if((signed int)*p == 46)
  {
    p = p + 1l;
    for( ; first_scale_digits >= 1; first_scale_digits = first_scale_digits - 1)
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*p]) == 0)
        break;

      first = first * 10;
      tmp_post$5 = p;
      p = p + 1l;
      first = first + ((signed int)*tmp_post$5 - 48);
    }
    do
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*p]) == 0)
        break;

      p = p + 1l;
    }
    while((_Bool)1);
  }

  for( ; first_scale_digits >= 1; first_scale_digits = first_scale_digits - 1)
    first = first * 10;
  if((signed int)*p == 58)
  {
    q = p + (signed long int)1;
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    *return_value___errno_location$7 = 0;
    signed long int return_value_strtol$8;
    return_value_strtol$8=strtol(q, &p, 10);
    second = (signed int)return_value_strtol$8;
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    if(p == q || !(*return_value___errno_location$9 == 0) || !(second >= 0))
    {
      fprintf(stderr, "Can't parse arg value(s): %s\n", orig_p);
      exit(1);
    }

  }

  if(!(q == ((char *)NULL)))
  {
    if(!(first_ptr == ((signed int *)NULL)))
      *first_ptr = first;

    if(!(second_ptr == ((signed int *)NULL)))
      *second_ptr = second;

  }

  else
    if(!(first_is_optional == 0))
    {
      if(!(second_ptr == ((signed int *)NULL)))
        *second_ptr = first;

    }

    else
      if(!(first_ptr == ((signed int *)NULL)))
        *first_ptr = first;

}

// pick_numa_nodes
// file numad.c line 1715
struct id_list * pick_numa_nodes(signed int pid, signed int cpus, signed int mbs, signed int assume_enough_cpus)
{
  if(log_level >= 7)
    numad_log(7, "PICK NODES FOR:  PID: %d,  CPUs %d,  MBs %d\n", pid, cpus, mbs);

  char buf[1024l];
  unsigned long int proc_avg_node_CPUs_free = (unsigned long int)0;
  signed int pid_ix;
  struct process_data *p = (struct process_data *)(void *)0;
  char *return_value_fgets$2;
  signed int return_value_strcmp$11;
  char *tmp_post$10;
  char *tmp_post$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  const unsigned short int **return_value___ctype_b_loc$8;
  char *tmp_post$9;
  signed int tmp_statement_expression$13;
  signed int tmp_if_expr$14;
  if(pid >= 1)
  {
    pid_ix=process_hash_lookup(pid);
    if(pid_ix >= 0)
    {
      p = &process_hash_table[(signed long int)pid_ix];
      char fname[192l];
      snprintf(fname, (unsigned long int)192, "/proc/%d/numa_maps", pid);
      struct _IO_FILE *fs;
      fs=fopen(fname, "r");
      if(fs == ((struct _IO_FILE *)NULL))
      {
        numad_log(4, "Tried to research PID %d numamaps, but it apparently went away.\n", p->pid);
        return (struct id_list *)(void *)0;
      }

      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)p->process_MBs, (unsigned long int)(num_nodes + 1) * sizeof(unsigned long int) /*8ul*/ );
      p->process_MBs = (unsigned long int *)return_value_realloc$1;
      if(p->process_MBs == ((unsigned long int *)NULL))
      {
        numad_log(2, "p->process_MBs realloc failed\n");
        exit(1);
      }

      memset((void *)p->process_MBs, 0, (unsigned long int)(num_nodes + 1) * sizeof(unsigned long int) /*8ul*/ );
      signed int process_has_interleaved_memory = 0;
      do
      {
        return_value_fgets$2=fgets(buf, 1024, fs);
        if(return_value_fgets$2 == ((char *)NULL))
          break;

        signed int interleaved_memory = 0;
        unsigned long int page_size = page_size_in_bytes;
        const char *delimiters = " \n";
        char *str_p;
        str_p=strtok(buf, delimiters);
        while(!(str_p == ((char *)NULL)))
        {
          signed int return_value_strncmp$12;
          return_value_strncmp$12=strncmp(str_p, "interleave", (unsigned long int)10);
          if(return_value_strncmp$12 == 0)
          {
            interleaved_memory = 1;
            process_has_interleaved_memory = 1;
          }

          else
          {
            return_value_strcmp$11=strcmp(str_p, "huge");
            if(return_value_strcmp$11 == 0)
              page_size = huge_page_size_in_bytes;

            else
            {
              tmp_post$10 = str_p;
              str_p = str_p + 1l;
              if((signed int)*tmp_post$10 == 78)
              {
                signed int pick_numa_nodes$$1$$2$$3$$1$$3$$node;
                unsigned long int pages;
                tmp_post$3 = str_p;
                str_p = str_p + 1l;
                pick_numa_nodes$$1$$2$$3$$1$$3$$node = (signed int)*tmp_post$3 - 48;
                do
                {
                  return_value___ctype_b_loc$4=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*str_p]) == 0)
                    break;

                  pick_numa_nodes$$1$$2$$3$$1$$3$$node = pick_numa_nodes$$1$$2$$3$$1$$3$$node * 10;
                  tmp_post$5 = str_p;
                  str_p = str_p + 1l;
                  pick_numa_nodes$$1$$2$$3$$1$$3$$node = pick_numa_nodes$$1$$2$$3$$1$$3$$node + ((signed int)*tmp_post$5 - 48);
                }
                while((_Bool)1);
                tmp_post$6 = str_p;
                str_p = str_p + 1l;
                if(!((signed int)*tmp_post$6 == 61))
                {
                  numad_log(2, "numa_maps node number parse error\n");
                  exit(1);
                }

                tmp_post$7 = str_p;
                str_p = str_p + 1l;
                pages = (unsigned long int)((signed int)*tmp_post$7 - 48);
                do
                {
                  return_value___ctype_b_loc$8=__ctype_b_loc();
                  if((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*str_p]) == 0)
                    break;

                  pages = pages * (unsigned long int)10;
                  tmp_post$9 = str_p;
                  str_p = str_p + 1l;
                  pages = pages + (unsigned long int)((signed int)*tmp_post$9 - 48);
                }
                while((_Bool)1);
                p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$3$$1$$3$$node] = p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$3$$1$$3$$node] + pages * page_size;
                if(!(interleaved_memory == 0))
                  p->process_MBs[(signed long int)num_nodes] = p->process_MBs[(signed long int)num_nodes] + pages * page_size;

              }

            }
          }
          str_p=strtok((char *)(void *)0, delimiters);
        }
      }
      while((_Bool)1);
      fclose(fs);
      proc_avg_node_CPUs_free = p->CPUs_used;
      signed int pick_numa_nodes$$1$$2$$4$$ix = 0;
      for( ; num_nodes >= pick_numa_nodes$$1$$2$$4$$ix; pick_numa_nodes$$1$$2$$4$$ix = pick_numa_nodes$$1$$2$$4$$ix + 1)
      {
        p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$4$$ix] = p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$4$$ix] / (unsigned long int)(1024 * 1024);
        if(log_level >= 7)
        {
          if(p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$4$$ix] >= 1ul)
          {
            if(pick_numa_nodes$$1$$2$$4$$ix == num_nodes)
              numad_log(7, "Interleaved MBs: %ld\n", pick_numa_nodes$$1$$2$$4$$ix, p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$4$$ix]);

            else
              numad_log(7, "PROCESS_MBs[%d]: %ld\n", pick_numa_nodes$$1$$2$$4$$ix, p->process_MBs[(signed long int)pick_numa_nodes$$1$$2$$4$$ix]);
          }

        }

        unsigned long int pick_numa_nodes$$1$$2$$4$$1$$2$$__cpu = (unsigned long int)pick_numa_nodes$$1$$2$$4$$ix;
        if(!(pick_numa_nodes$$1$$2$$4$$1$$2$$__cpu / 8ul >= p->node_list_p->bytes))
          tmp_if_expr$14 = (signed int)((((const unsigned long int *)p->node_list_p->set_p->__bits)[(signed long int)(pick_numa_nodes$$1$$2$$4$$1$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << pick_numa_nodes$$1$$2$$4$$1$$2$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

        else
          tmp_if_expr$14 = 0;
        tmp_statement_expression$13 = tmp_if_expr$14;
        if(!(tmp_statement_expression$13 == 0))
          proc_avg_node_CPUs_free = proc_avg_node_CPUs_free + (node + (signed long int)pick_numa_nodes$$1$$2$$4$$ix)->CPUs_free;

      }
      signed int return_value___sched_cpucount$15;
      return_value___sched_cpucount$15=__sched_cpucount(p->node_list_p->bytes, p->node_list_p->set_p);
      proc_avg_node_CPUs_free = proc_avg_node_CPUs_free / (unsigned long int)return_value___sched_cpucount$15;
      if(!(keep_interleaved_memory == 0) && !(process_has_interleaved_memory == 0))
      {
        p->flags = p->flags | (unsigned int)(1 << 0);
        p->bind_time_stamp=get_time_stamp();
        if(log_level >= 7)
          numad_log(7, "Skipping evaluation of PID %d because of interleaved memory.\n", p->pid);

        return (struct id_list *)(void *)0;
      }

    }

  }

  void *return_value_realloc$16;
  static struct node_data *tmp_node;
  return_value_realloc$16=realloc((void *)tmp_node, (unsigned long int)num_nodes * sizeof(struct node_data) /*64ul*/ );
  tmp_node = (struct node_data *)return_value_realloc$16;
  if(tmp_node == ((struct node_data *)NULL))
  {
    numad_log(2, "tmp_node realloc failed\n");
    exit(1);
  }

  memcpy((void *)tmp_node, (const void *)node, (unsigned long int)num_nodes * sizeof(struct node_data) /*64ul*/ );
  unsigned long int sum_of_node_CPUs_free = (unsigned long int)0;
  signed int pick_numa_nodes$$1$$4$$ix = 0;
  signed int tmp_statement_expression$17;
  signed int tmp_if_expr$18;
  for( ; !(pick_numa_nodes$$1$$4$$ix >= num_nodes); pick_numa_nodes$$1$$4$$ix = pick_numa_nodes$$1$$4$$ix + 1)
  {
    if(pid >= 1)
    {
      signed int return_value___sched_cpucount$19;
      return_value___sched_cpucount$19=__sched_cpucount(p->node_list_p->bytes, p->node_list_p->set_p);
      if(return_value___sched_cpucount$19 >= num_nodes)
      {
        (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free = (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free + (p->process_MBs[(signed long int)pick_numa_nodes$$1$$4$$ix] * (unsigned long int)17) / (unsigned long int)16;
        (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free = (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free + (p->CPUs_used * p->process_MBs[(signed long int)pick_numa_nodes$$1$$4$$ix]) / p->MBs_used;
      }

      else
      {
        (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free = (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free + (p->process_MBs[(signed long int)pick_numa_nodes$$1$$4$$ix] * (unsigned long int)5) / (unsigned long int)4;
        unsigned long int pick_numa_nodes$$1$$4$$1$$1$$2$$1$$__cpu = (unsigned long int)pick_numa_nodes$$1$$4$$ix;
        if(!(pick_numa_nodes$$1$$4$$1$$1$$2$$1$$__cpu / 8ul >= p->node_list_p->bytes))
          tmp_if_expr$18 = (signed int)((((const unsigned long int *)p->node_list_p->set_p->__bits)[(signed long int)(pick_numa_nodes$$1$$4$$1$$1$$2$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << pick_numa_nodes$$1$$4$$1$$1$$2$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

        else
          tmp_if_expr$18 = 0;
        tmp_statement_expression$17 = tmp_if_expr$18;
        if(!(tmp_statement_expression$17 == 0))
          (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free = proc_avg_node_CPUs_free;

      }
      sum_of_node_CPUs_free = sum_of_node_CPUs_free + (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free;
      if(!((tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_total >= (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free))
        (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free = (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_total;

      if(!((tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_total >= (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free))
        (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free = (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_total;

    }

    if(!((tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free >= 1ul))
      (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free = (unsigned long int)1;

    (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->magnitude=combined_value_of_weighted_resources(pick_numa_nodes$$1$$4$$ix, mbs, cpus, (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->MBs_free, (tmp_node + (signed long int)pick_numa_nodes$$1$$4$$ix)->CPUs_free);
  }
  static struct id_list *target_node_list_p;
  if(target_node_list_p == ((struct id_list *)NULL))
  {
    void *return_value_malloc$20;
    return_value_malloc$20=malloc(sizeof(struct id_list) /*16ul*/ );
    target_node_list_p = (struct id_list *)return_value_malloc$20;
    if(target_node_list_p == ((struct id_list *)NULL))
    {
      numad_log(2, "INIT_ID_LIST malloc failed\n");
      exit(1);
    }

    target_node_list_p->set_p=__sched_cpualloc((unsigned long int)num_nodes);
    if(target_node_list_p->set_p == ((struct anonymous$2 *)NULL))
    {
      numad_log(2, "CPU_ALLOC failed\n");
      exit(1);
    }

    target_node_list_p->bytes = ((((unsigned long int)num_nodes + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
  }

  do
    __builtin_memset((void *)target_node_list_p->set_p, 0, target_node_list_p->bytes);
  while((_Bool)0);
  if(pid >= 1 && !(sum_of_node_CPUs_free >= (unsigned long int)cpus))
    assume_enough_cpus = 1;

  signed int cpu_flex = 0;
  if(pid >= 1 && !(target_utilization >= 100))
    cpu_flex = (signed int)(((unsigned long int)(100 - target_utilization) * (node + (signed long int)0)->CPUs_total) / (unsigned long int)200);

  signed int mem_req_nodes;
  double return_value_ceil$21;
  return_value_ceil$21=ceil((double)mbs / (double)(node + (signed long int)0)->MBs_total);
  mem_req_nodes = (signed int)return_value_ceil$21;
  signed int cpu_req_nodes;
  double return_value_ceil$22;
  return_value_ceil$22=ceil((double)(cpus - cpu_flex) / (double)(node + (signed long int)0)->CPUs_total);
  cpu_req_nodes = (signed int)return_value_ceil$22;
  signed int min_req_nodes = mem_req_nodes;
  if(!(min_req_nodes >= cpu_req_nodes))
    min_req_nodes = cpu_req_nodes;

  if(!(num_nodes >= min_req_nodes))
    min_req_nodes = num_nodes;

  const signed long int min_req_nodes$array_size0 = (signed long int)num_nodes;
  signed int index[min_req_nodes$array_size0];
  const signed long int index$array_size0 = (signed long int)num_nodes;
  unsigned long int totmag[index$array_size0];
  signed int pick_numa_nodes$$1$$10$$ix = 0;
  for( ; !(pick_numa_nodes$$1$$10$$ix >= num_nodes); pick_numa_nodes$$1$$10$$ix = pick_numa_nodes$$1$$10$$ix + 1)
  {
    signed int n = 0;
    for( ; !(n >= num_nodes); n = n + 1)
      index[(signed long int)n] = n;
    signed int ij = 0;
    for( ; !(ij >= num_nodes); ij = ij + 1)
    {
      signed int best_ix = ij;
      signed int ik = ij + 1;
      for( ; !(ik >= num_nodes); ik = ik + 1)
      {
        signed int ik_dist = (signed int)(tmp_node + (signed long int)index[(signed long int)ik])->distance[(signed long int)pick_numa_nodes$$1$$10$$ix];
        signed int best_ix_dist = (signed int)(tmp_node + (signed long int)index[(signed long int)best_ix])->distance[(signed long int)pick_numa_nodes$$1$$10$$ix];
        if(!(ik_dist >= best_ix_dist))
          best_ix = ik;

        else
          if(best_ix_dist == ik_dist)
          {
            if(!((tmp_node + (signed long int)index[(signed long int)best_ix])->magnitude >= (tmp_node + (signed long int)index[(signed long int)ik])->magnitude))
              best_ix = ik;

          }

      }
      if(!(best_ix == ij))
      {
        signed int tmp = index[(signed long int)ij];
        index[(signed long int)ij] = index[(signed long int)best_ix];
        index[(signed long int)best_ix] = tmp;
      }

    }
    totmag[(signed long int)pick_numa_nodes$$1$$10$$ix] = (unsigned long int)0;
    signed int pick_numa_nodes$$1$$10$$1$$3$$ij = 0;
    for( ; !(pick_numa_nodes$$1$$10$$1$$3$$ij >= min_req_nodes); pick_numa_nodes$$1$$10$$1$$3$$ij = pick_numa_nodes$$1$$10$$1$$3$$ij + 1)
    {
      signed int dist = (signed int)(tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$10$$1$$3$$ij])->distance[(signed long int)pick_numa_nodes$$1$$10$$ix];
      totmag[(signed long int)pick_numa_nodes$$1$$10$$ix] = totmag[(signed long int)pick_numa_nodes$$1$$10$$ix] + (tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$10$$1$$3$$ij])->magnitude / (unsigned long int)(dist * dist);
    }
    numad_log(7, "Totmag[%d]: %ld\n", pick_numa_nodes$$1$$10$$ix, totmag[(signed long int)pick_numa_nodes$$1$$10$$ix]);
  }
  signed int best_node_ix = 0;
  signed int ix = 0;
  for( ; !(ix >= num_nodes); ix = ix + 1)
    if(!(totmag[(signed long int)best_node_ix] >= totmag[(signed long int)ix]))
      best_node_ix = ix;

  numad_log(7, "best_node_ix: %d\n", best_node_ix);
  signed int pick_numa_nodes$$1$$12$$n = 0;
  for( ; !(pick_numa_nodes$$1$$12$$n >= num_nodes); pick_numa_nodes$$1$$12$$n = pick_numa_nodes$$1$$12$$n + 1)
    index[(signed long int)pick_numa_nodes$$1$$12$$n] = pick_numa_nodes$$1$$12$$n;
  signed int pick_numa_nodes$$1$$13$$ij = 0;
  for( ; !(pick_numa_nodes$$1$$13$$ij >= num_nodes); pick_numa_nodes$$1$$13$$ij = pick_numa_nodes$$1$$13$$ij + 1)
  {
    signed int pick_numa_nodes$$1$$13$$1$$best_ix = pick_numa_nodes$$1$$13$$ij;
    signed int pick_numa_nodes$$1$$13$$1$$1$$ik = pick_numa_nodes$$1$$13$$ij + 1;
    for( ; !(pick_numa_nodes$$1$$13$$1$$1$$ik >= num_nodes); pick_numa_nodes$$1$$13$$1$$1$$ik = pick_numa_nodes$$1$$13$$1$$1$$ik + 1)
    {
      signed int pick_numa_nodes$$1$$13$$1$$1$$1$$ik_dist = (signed int)(tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$13$$1$$1$$ik])->distance[(signed long int)best_node_ix];
      signed int pick_numa_nodes$$1$$13$$1$$1$$1$$best_ix_dist = (signed int)(tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$13$$1$$best_ix])->distance[(signed long int)best_node_ix];
      if(!(pick_numa_nodes$$1$$13$$1$$1$$1$$ik_dist >= pick_numa_nodes$$1$$13$$1$$1$$1$$best_ix_dist))
        pick_numa_nodes$$1$$13$$1$$best_ix = pick_numa_nodes$$1$$13$$1$$1$$ik;

      else
        if(pick_numa_nodes$$1$$13$$1$$1$$1$$best_ix_dist == pick_numa_nodes$$1$$13$$1$$1$$1$$ik_dist)
        {
          if(!((tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$13$$1$$best_ix])->magnitude >= (tmp_node + (signed long int)index[(signed long int)pick_numa_nodes$$1$$13$$1$$1$$ik])->magnitude))
            pick_numa_nodes$$1$$13$$1$$best_ix = pick_numa_nodes$$1$$13$$1$$1$$ik;

        }

    }
    if(!(pick_numa_nodes$$1$$13$$1$$best_ix == pick_numa_nodes$$1$$13$$ij))
    {
      signed int pick_numa_nodes$$1$$13$$1$$2$$tmp = index[(signed long int)pick_numa_nodes$$1$$13$$ij];
      index[(signed long int)pick_numa_nodes$$1$$13$$ij] = index[(signed long int)pick_numa_nodes$$1$$13$$1$$best_ix];
      index[(signed long int)pick_numa_nodes$$1$$13$$1$$best_ix] = pick_numa_nodes$$1$$13$$1$$2$$tmp;
    }

  }
  if(log_level >= 7)
  {
    signed int iq = 0;
    for( ; !(iq >= num_nodes); iq = iq + 1)
      numad_log(7, "Node: %d  Dist: %d  Magnitude: %ld\n", (tmp_node + (signed long int)index[(signed long int)iq])->node_id, (tmp_node + (signed long int)index[(signed long int)iq])->distance[(signed long int)best_node_ix], (tmp_node + (signed long int)index[(signed long int)iq])->magnitude);
  }

  best_node_ix = 0;
  while(min_req_nodes >= 1 || mbs >= 1 || assume_enough_cpus == 0 && !(cpu_flex >= cpus))
  {
    if(log_level >= 7)
      numad_log(7, "MBs: %d,  CPUs: %d\n", mbs, cpus);

    numad_log(7, "Assigning resources from node %d\n", index[(signed long int)best_node_ix]);
    unsigned long int pick_numa_nodes$$1$$15$$2$$__cpu = (tmp_node + (signed long int)index[(signed long int)best_node_ix])->node_id;
    if(!(pick_numa_nodes$$1$$15$$2$$__cpu / 8ul >= target_node_list_p->bytes))
      ((unsigned long int *)target_node_list_p->set_p->__bits)[(signed long int)(pick_numa_nodes$$1$$15$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)target_node_list_p->set_p->__bits)[(signed long int)(pick_numa_nodes$$1$$15$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << pick_numa_nodes$$1$$15$$2$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

    else
      (unsigned long int)0;
    min_req_nodes = min_req_nodes - 1;
    signed int return_value___builtin_memcmp$23;
    return_value___builtin_memcmp$23=__builtin_memcmp((const void *)target_node_list_p->set_p, (const void *)all_nodes_list_p->set_p, target_node_list_p->bytes);
    if(return_value___builtin_memcmp$23 == 0)
      break;

    if((tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free >= (unsigned long int)(100 + mbs))
    {
      (tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free = (tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free - (unsigned long int)mbs;
      mbs = 0;
    }

    else
    {
      mbs = mbs - (signed int)((tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free - (unsigned long int)100);
      (tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free = (unsigned long int)100;
    }
    if((tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free >= (unsigned long int)cpus)
    {
      (tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free = (tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free - (unsigned long int)cpus;
      cpus = 0;
    }

    else
    {
      cpus = cpus - (signed int)((tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free - (unsigned long int)0);
      (tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free = (unsigned long int)0;
    }
    (tmp_node + (signed long int)index[(signed long int)best_node_ix])->magnitude=combined_value_of_weighted_resources(0, mbs, cpus, (tmp_node + (signed long int)index[(signed long int)best_node_ix])->MBs_free, (tmp_node + (signed long int)index[(signed long int)best_node_ix])->CPUs_free);
    best_node_ix = best_node_ix + 1;
  }
  signed int tmp_statement_expression$24;
  signed int tmp_if_expr$25;
  signed int return_value___builtin_memcmp$26;
  if(pid >= 1 && !(p == ((struct process_data *)NULL)))
  {
    unsigned long int nonlocal_memory = (unsigned long int)0;
    signed int pick_numa_nodes$$1$$16$$1$$ix = 0;
    for( ; !(pick_numa_nodes$$1$$16$$1$$ix >= num_nodes); pick_numa_nodes$$1$$16$$1$$ix = pick_numa_nodes$$1$$16$$1$$ix + 1)
    {
      unsigned long int pick_numa_nodes$$1$$16$$1$$1$$1$$__cpu = (unsigned long int)pick_numa_nodes$$1$$16$$1$$ix;
      if(!(pick_numa_nodes$$1$$16$$1$$1$$1$$__cpu / 8ul >= target_node_list_p->bytes))
        tmp_if_expr$25 = (signed int)((((const unsigned long int *)target_node_list_p->set_p->__bits)[(signed long int)(pick_numa_nodes$$1$$16$$1$$1$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << pick_numa_nodes$$1$$16$$1$$1$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

      else
        tmp_if_expr$25 = 0;
      tmp_statement_expression$24 = tmp_if_expr$25;
      if(tmp_statement_expression$24 == 0)
        nonlocal_memory = nonlocal_memory + p->process_MBs[(signed long int)pick_numa_nodes$$1$$16$$1$$ix];

    }
    signed int disp_percent = (signed int)(((unsigned long int)100 * nonlocal_memory) / p->MBs_used);
    if(100 + -target_memlocality >= disp_percent)
    {
      if(!(p->bind_time_stamp == 0ul))
      {
        return_value___builtin_memcmp$26=__builtin_memcmp((const void *)target_node_list_p->set_p, (const void *)p->node_list_p->set_p, target_node_list_p->bytes);
        if(return_value___builtin_memcmp$26 == 0)
        {
          if(log_level >= 7)
            numad_log(7, "Process %d already %d percent localized to target nodes.\n", p->pid, 100 - disp_percent);

          p->bind_time_stamp=get_time_stamp();
          return (struct id_list *)(void *)0;
        }

      }

    }

  }

  signed int return_value___sched_cpucount$27;
  if(!(pid >= 1))
  {
    return_value___sched_cpucount$27=__sched_cpucount(target_node_list_p->bytes, target_node_list_p->set_p);
    if(!(return_value___sched_cpucount$27 >= 1))
    {
      unsigned long int __cpu = (node + (signed long int)0)->node_id;
      if(!(__cpu / 8ul >= target_node_list_p->bytes))
        ((unsigned long int *)target_node_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)target_node_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

      else
        (unsigned long int)0;
    }

  }

  _Bool tmp_if_expr$28;
  if(pid >= 1)
    tmp_if_expr$28 = p->bind_time_stamp != 0ul ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$28 = (_Bool)0;
  if(tmp_if_expr$28)
    str_from_id_list(buf, 1024, p->node_list_p);

  else
    str_from_id_list(buf, 1024, all_nodes_list_p);
  char buf2[1024l];
  str_from_id_list(buf2, 1024, target_node_list_p);
  char *cmd_name = "(unknown)";
  if(!(p == ((struct process_data *)NULL)))
  {
    if(!(p->comm == ((char *)NULL)))
      cmd_name = p->comm;

  }

  numad_log(5, "Advising pid %d %s move from nodes (%s) to nodes (%s)\n", pid, cmd_name, (const void *)buf, (const void *)buf2);
  if(pid >= 1)
    memcpy((void *)p->node_list_p->set_p, (const void *)target_node_list_p->set_p, target_node_list_p->bytes);

  return target_node_list_p;
}

// print_usage_and_exit
// file numad.c line 720
void print_usage_and_exit(char *prog_name)
{
  fprintf(stderr, "Usage: %s <options> ...\n", prog_name);
  fprintf(stderr, "-C 1  to count inactive file cache as available memory (default 1)\n");
  fprintf(stderr, "-C 0  to count inactive file cache memory as unavailable (default 1)\n");
  fprintf(stderr, "-d for debug logging (same effect as '-l 7')\n");
  fprintf(stderr, "-h to print this usage info\n");
  fprintf(stderr, "-H <N> to set THP scan_sleep_ms (default %d)\n", 1000);
  fprintf(stderr, "-i [<MIN>:]<MAX> to specify interval seconds\n");
  fprintf(stderr, "-K 1  to keep interleaved memory spread across nodes (default 0)\n");
  fprintf(stderr, "-K 0  to merge interleaved memory to local NUMA nodes (default 0)\n");
  fprintf(stderr, "-l <N> to specify logging level (usually 5, 6, or 7 -- default 5)\n");
  fprintf(stderr, "-m <N> to specify memory locality target percent (default %d)\n", 90);
  fprintf(stderr, "-p <PID> to add PID to inclusion pid list\n");
  fprintf(stderr, "-r <PID> to remove PID from explicit pid lists\n");
  fprintf(stderr, "-R <CPU_LIST> to reserve some CPUs for non-numad use\n");
  fprintf(stderr, "-S 1  to scan all processes (default 1)\n");
  fprintf(stderr, "-S 0  to scan only explicit PID list processes (default 1)\n");
  fprintf(stderr, "-t <N> to specify thread / logical CPU valuation percent (default %d)\n", 20);
  fprintf(stderr, "-u <N> to specify utilization target percent (default %d)\n", 85);
  fprintf(stderr, "-v for verbose  (same effect as '-l 6')\n");
  fprintf(stderr, "-V to show version info\n");
  fprintf(stderr, "-w <CPUs>[:<MBs>] for NUMA node suggestions\n");
  fprintf(stderr, "-x <PID> to add PID to exclusion pid list\n");
  exit(1);
}

// print_version_and_exit
// file numad.c line 714
void print_version_and_exit(char *prog_name)
{
  fprintf(stdout, "%s version: %s: compiled %s\n", prog_name, (const void *)"20150602", (const void *)"Jan 26 2016");
  exit(0);
}

// process_hash_clear_all_bind_time_stamps
// file numad.c line 528
void process_hash_clear_all_bind_time_stamps()
{
  signed int ix = 0;
  for( ; !(ix >= process_hash_table_size); ix = ix + 1)
    (process_hash_table + (signed long int)ix)->bind_time_stamp = (unsigned long int)0;
}

// process_hash_insert
// file numad.c line 469
signed int process_hash_insert(signed int pid)
{
  signed int ix;
  ix=process_hash_ix(pid);
  signed int starting_ix = ix;
  while(!((process_hash_table + (signed long int)ix)->pid == 0))
  {
    if(pid == (process_hash_table + (signed long int)ix)->pid)
      return ix;

    process_hash_collisions = process_hash_collisions + 1;
    ix = ix + 1;
    ix = ix & process_hash_table_size - 1;
    if(ix == starting_ix)
    {
      numad_log(3, "Process hash table is full\n");
      return -1;
    }

  }
  (process_hash_table + (signed long int)ix)->pid = pid;
  return ix;
}

// process_hash_ix
// file numad.c line 442
signed int process_hash_ix(signed int pid)
{
  unsigned int ix = (unsigned int)pid;
  ix = ix * (unsigned int)717;
  ix = ix >> 8;
  ix = ix & (unsigned int)(process_hash_table_size - 1);
  return (signed int)ix;
}

// process_hash_lookup
// file numad.c line 450
signed int process_hash_lookup(signed int pid)
{
  signed int ix;
  ix=process_hash_ix(pid);
  signed int starting_ix = ix;
  while(!((process_hash_table + (signed long int)ix)->pid == 0))
  {
    if(pid == (process_hash_table + (signed long int)ix)->pid)
      return ix;

    ix = ix + 1;
    ix = ix & process_hash_table_size - 1;
    if(ix == starting_ix)
      break;

  }
  return -1;
}

// process_hash_rehash
// file numad.c line 534
signed int process_hash_rehash(signed int old_ix)
{
  struct process_data *op = &process_hash_table[(signed long int)old_ix];
  signed int new_ix;
  new_ix=process_hash_insert(op->pid);
  if(new_ix >= 0)
  {
    struct process_data *np = &process_hash_table[(signed long int)new_ix];
    memcpy((void *)np, (const void *)op, sizeof(struct process_data) /*160ul*/ );
    memset((void *)op, 0, sizeof(struct process_data) /*160ul*/ );
  }

  return new_ix;
}

// process_hash_remove
// file numad.c line 548
signed int process_hash_remove(signed int pid)
{
  signed int ix;
  ix=process_hash_lookup(pid);
  if(ix >= 0)
  {
    struct process_data *dp = &process_hash_table[(signed long int)ix];
    if(!(dp->comm == ((char *)NULL)))
      free((void *)dp->comm);

    if(!(dp->process_MBs == ((unsigned long int *)NULL)))
      free((void *)dp->process_MBs);

    if(!(dp->node_list_p == ((struct id_list *)NULL)))
    {
      if(!(dp->node_list_p->set_p == ((struct anonymous$2 *)NULL)))
        __sched_cpufree(dp->node_list_p->set_p);

      free((void *)dp->node_list_p);
      dp->node_list_p = (struct id_list *)(void *)0;
    }

    memset((void *)dp, 0, sizeof(struct process_data) /*160ul*/ );
    do
    {
      ix = ix + 1;
      ix = ix & process_hash_table_size - 1;
      pid = (process_hash_table + (signed long int)ix)->pid;
      if(!(pid >= 1))
        break;

      signed int return_value_process_hash_lookup$2;
      return_value_process_hash_lookup$2=process_hash_lookup(pid);
      if(!(return_value_process_hash_lookup$2 >= 0))
      {
        signed int return_value_process_hash_rehash$1;
        return_value_process_hash_rehash$1=process_hash_rehash(ix);
        if(!(return_value_process_hash_rehash$1 >= 0))
          numad_log(3, "rehash fail\n");

      }

    }
    while((_Bool)1);
  }

  return ix;
}

// process_hash_table_cleanup
// file numad.c line 617
void process_hash_table_cleanup(unsigned long int update_time)
{
  signed int num_hash_entries_used = 0;
  signed int ix = 0;
  signed int *return_value___errno_location$1;
  for( ; !(ix >= process_hash_table_size); ix = ix + 1)
  {
    struct process_data *p = &process_hash_table[(signed long int)ix];
    if(!(p->pid == 0))
    {
      num_hash_entries_used = num_hash_entries_used + 1;
      if(!(p->data_time_stamp >= update_time))
      {
        p->data_time_stamp = (unsigned long int)0;
        p->CPUs_used = (unsigned long int)0;
        signed int return_value_kill$2;
        return_value_kill$2=kill(p->pid, 0);
        if(return_value_kill$2 == -1)
        {
          return_value___errno_location$1=__errno_location();
          if(*return_value___errno_location$1 == 3)
          {
            process_hash_remove(p->pid);
            num_hash_entries_used = num_hash_entries_used - 1;
          }

        }

      }

    }

  }
  if(!(process_hash_table_size >= (7 * num_hash_entries_used) / 4))
    process_hash_table_expand();

}

// process_hash_table_dump
// file numad.c line 604
void process_hash_table_dump()
{
  signed int ix = 0;
  char *tmp_if_expr$1;
  for( ; !(ix >= process_hash_table_size); ix = ix + 1)
  {
    struct process_data *p = &process_hash_table[(signed long int)ix];
    if(!(p->pid == 0))
    {
      if(!(p->comm == ((char *)NULL)))
        tmp_if_expr$1 = p->comm;

      else
        tmp_if_expr$1 = "(Null)";
      numad_log(7, "ix: %d  PID: %d %s  Thds: %d  CPU %ld  MBs: %ld/%ld Data TS: %ld  Bind TS: %ld\n", ix, p->pid, tmp_if_expr$1, p->num_threads, p->CPUs_used, p->MBs_used, p->MBs_size, p->data_time_stamp, p->bind_time_stamp);
    }

  }
}

// process_hash_table_expand
// file numad.c line 574
void process_hash_table_expand()
{
  signed int old_size = process_hash_table_size;
  struct process_data *old_table = process_hash_table;
  if(old_size >= 1)
    process_hash_table_size = process_hash_table_size * 2;

  else
    process_hash_table_size = 16;
  numad_log(7, "Expanding hash table size: %d\n", process_hash_table_size);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)process_hash_table_size * sizeof(struct process_data) /*160ul*/ );
  process_hash_table = (struct process_data *)return_value_malloc$1;
  if(process_hash_table == ((struct process_data *)NULL))
  {
    numad_log(2, "hash table malloc failed\n");
    exit(1);
  }

  memset((void *)process_hash_table, 0, (unsigned long int)process_hash_table_size * sizeof(struct process_data) /*160ul*/ );
  signed int ix = 0;
  for( ; !(ix >= old_size); ix = ix + 1)
  {
    struct process_data *p = &old_table[(signed long int)ix];
    if(!(p->pid == 0))
    {
      signed int new_table_ix;
      new_table_ix=process_hash_insert(p->pid);
      memcpy((void *)&process_hash_table[(signed long int)new_table_ix], (const void *)p, sizeof(struct process_data) /*160ul*/ );
    }

  }
  if(!(old_table == ((struct process_data *)NULL)))
    free((void *)old_table);

}

// process_hash_update
// file numad.c line 490
signed int process_hash_update(struct process_data *newp)
{
  signed int new_hash_table_entry = 1;
  signed int process_hash_update$$1$$ix;
  process_hash_update$$1$$ix=process_hash_insert(newp->pid);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(process_hash_update$$1$$ix >= 0)
  {
    struct process_data *p = &process_hash_table[(signed long int)process_hash_update$$1$$ix];
    if(!(p->data_time_stamp == 0ul))
    {
      new_hash_table_entry = 0;
      p->ring_buf_ix = p->ring_buf_ix + 1;
      p->ring_buf_ix = p->ring_buf_ix & 8 - 1;
      unsigned long int cpu_util_diff = newp->cpu_util - p->cpu_util;
      unsigned long int time_diff = newp->data_time_stamp - p->data_time_stamp;
      p->CPUs_used_ring_buf[(signed long int)p->ring_buf_ix] = ((unsigned long int)100 * cpu_util_diff) / time_diff;
      unsigned long int max_CPUs_used = p->CPUs_used_ring_buf[(signed long int)0];
      signed int ix = 1;
      for( ; !(ix >= 8); ix = ix + 1)
        if(!(max_CPUs_used >= p->CPUs_used_ring_buf[(signed long int)ix]))
          max_CPUs_used = p->CPUs_used_ring_buf[(signed long int)ix];

      p->CPUs_used = max_CPUs_used;
    }

    if(p->comm == ((char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_strcmp$1=strcmp(p->comm, newp->comm);
      tmp_if_expr$2 = return_value_strcmp$1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      if(!(p->comm == ((char *)NULL)))
        free((void *)p->comm);

      p->comm=strdup(newp->comm);
    }

    p->MBs_size = newp->MBs_size;
    p->MBs_used = newp->MBs_used;
    p->cpu_util = newp->cpu_util;
    p->num_threads = newp->num_threads;
    p->data_time_stamp = newp->data_time_stamp;
  }

  return new_hash_table_entry;
}

// recv_msg
// file numad.c line 217
void recv_msg(struct msg *m)
{
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  signed long int return_value_msgrcv$2;
  return_value_msgrcv$2=msgrcv(msg_qid, (void *)m, sizeof(struct msg_body) /*128ul*/ , (signed long int)return_value_getpid$1, 0);
  if(!(return_value_msgrcv$2 >= 0l))
  {
    numad_log(2, "msgrcv failed\n");
    exit(1);
  }

}

// register_numad_pid
// file numad.c line 807
signed int register_numad_pid()
{
  signed int pid;
  char buf[1024l];
  signed int fd;
  signed int *return_value___errno_location$8;
  signed int bytes;
  signed long int return_value_read$2;
  char *p;
  char *tmp_post$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$5;
  char fname[192l];
  signed int return_value_access$7;
  signed int *return_value___errno_location$6;
  do
  {

  create_run_file:
    ;
    fd=open("/var/run/numad.pid", 02 | 0100 | 0200, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
    if(fd >= 0)
    {
      pid=getpid();
      sprintf(buf, "%d\n", pid);
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(buf);
      write(fd, (const void *)buf, return_value_strlen$1);
      close(fd);
      numad_log(5, "Registering numad version %s PID %d\n", (const void *)"20150602", pid);
      return pid;
    }

    return_value___errno_location$8=__errno_location();
    if(!(*return_value___errno_location$8 == 17))
      goto fail_numad_run_file;

    fd=open("/var/run/numad.pid", 02 | 0100, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
    if(!(fd >= 0))
      goto fail_numad_run_file;

    return_value_read$2=read(fd, (void *)buf, (unsigned long int)1024);
    bytes = (signed int)return_value_read$2;
    close(fd);
    if(!(bytes >= 1))
      goto __CPROVER_DUMP_L7;

    p = buf;
    tmp_post$3 = p;
    p = p + 1l;
    pid = (signed int)*tmp_post$3 - 48;
    do
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*p]) == 0)
        break;

      pid = pid * 10;
      tmp_post$5 = p;
      p = p + 1l;
      pid = pid + ((signed int)*tmp_post$5 - 48);
    }
    while((_Bool)1);
    snprintf(fname, (unsigned long int)192, "/proc/%d", pid);
    return_value_access$7=access(fname, 0);
    if(return_value_access$7 >= 0)
      goto __CPROVER_DUMP_L6;

    return_value___errno_location$6=__errno_location();
    if(!(*return_value___errno_location$6 == 2))
      break;

    numad_log(5, "Removing out-of-date numad run file because %s doesn't exist\n", (const void *)fname);
    unlink("/var/run/numad.pid");
  }
  while((_Bool)1);

__CPROVER_DUMP_L6:
  ;
  return pid;

__CPROVER_DUMP_L7:
  ;

fail_numad_run_file:
  ;
  numad_log(2, "Cannot open numad.pid file\n");
  exit(1);
}

// remove_pid_from_pid_list
// file numad.c line 681
struct pid_list * remove_pid_from_pid_list(struct pid_list *list_ptr, signed long int pid)
{
  struct pid_list *last_pid_ptr = (struct pid_list *)(void *)0;
  struct pid_list *pid_ptr = list_ptr;
  while(!(pid_ptr == ((struct pid_list *)NULL)))
  {
    if(pid_ptr->pid == pid)
    {
      if(pid_ptr == list_ptr)
      {
        list_ptr = list_ptr->next;
        free((void *)pid_ptr);
        pid_ptr = list_ptr;
        continue;
      }

      else
      {
        last_pid_ptr->next = pid_ptr->next;
        free((void *)pid_ptr);
        pid_ptr = last_pid_ptr;
      }
    }

    last_pid_ptr = pid_ptr;
    pid_ptr = pid_ptr->next;
  }
  return list_ptr;
}

// send_msg
// file numad.c line 225
void send_msg(signed long int dst_pid, signed long int cmd, signed long int arg1, signed long int arg2, char *s)
{
  struct msg msg;
  msg.dst_pid = dst_pid;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  msg.body.src_pid = (signed long int)return_value_getpid$1;
  msg.body.cmd = cmd;
  msg.body.arg1 = arg1;
  msg.body.arg2 = arg2;
  signed int s_len;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(s);
  s_len = (signed int)return_value_strlen$2;
  if(s_len >= 96)
  {
    numad_log(2, "msgsnd text too big\n");
    exit(1);
  }

  strcpy(msg.body.text, s);
  unsigned long int m_len = (sizeof(struct msg_body) /*128ul*/  - (unsigned long int)96) + (unsigned long int)s_len + (unsigned long int)1;
  signed int return_value_msgsnd$3;
  return_value_msgsnd$3=msgsnd(msg_qid, (const void *)&msg, m_len, 04000);
  if(!(return_value_msgsnd$3 >= 0))
  {
    numad_log(2, "msgsnd failed\n");
    exit(1);
  }

}

// set_dynamic_options
// file numad.c line 2237
void * set_dynamic_options(void *arg)
{
  char buf[1024l];
  struct id_list *node_list_p;
  do
  {
    struct msg msg;
    recv_msg(&msg);
    switch(msg.body.cmd)
    {
      case (signed long int)67:
      {
        use_inactive_file_cache = (signed int)(msg.body.arg1 != (signed long int)0);
        if(!(use_inactive_file_cache == 0))
          numad_log(5, "Counting inactive file cache as available\n");

        else
          numad_log(5, "Counting inactive file cache as unavailable\n");
        break;
      }
      case (signed long int)72:
      {
        thp_scan_sleep_ms = (signed int)msg.body.arg1;
        set_thp_scan_sleep_ms(thp_scan_sleep_ms);
        break;
      }
      case (signed long int)105:
      {
        min_interval = (signed int)msg.body.arg1;
        max_interval = (signed int)msg.body.arg2;
        if(!(max_interval >= 1))
          shut_down_numad();

        numad_log(5, "Changing interval to %d:%d\n", msg.body.arg1, msg.body.arg2);
        break;
      }
      case (signed long int)75:
      {
        keep_interleaved_memory = (signed int)(msg.body.arg1 != (signed long int)0);
        if(!(keep_interleaved_memory == 0))
          numad_log(5, "Keeping interleaved memory spread across nodes\n");

        else
          numad_log(5, "Merging interleaved memory to localized NUMA nodes\n");
        break;
      }
      case (signed long int)108:
      {
        numad_log(5, "Changing log level to %d\n", msg.body.arg1);
        log_level = (signed int)msg.body.arg1;
        break;
      }
      case (signed long int)109:
      {
        numad_log(5, "Changing target memory locality to %d\n", msg.body.arg1);
        target_memlocality = (signed int)msg.body.arg1;
        break;
      }
      case (signed long int)112:
      {
        numad_log(5, "Adding PID %d to inclusion PID list\n", msg.body.arg1);
        pthread_mutex_lock(&pid_list_mutex);
        exclude_pid_list=remove_pid_from_pid_list(exclude_pid_list, msg.body.arg1);
        include_pid_list=insert_pid_into_pid_list(include_pid_list, msg.body.arg1);
        pthread_mutex_unlock(&pid_list_mutex);
        break;
      }
      case (signed long int)114:
      {
        numad_log(5, "Removing PID %d from explicit PID lists\n", msg.body.arg1);
        pthread_mutex_lock(&pid_list_mutex);
        include_pid_list=remove_pid_from_pid_list(include_pid_list, msg.body.arg1);
        exclude_pid_list=remove_pid_from_pid_list(exclude_pid_list, msg.body.arg1);
        pthread_mutex_unlock(&pid_list_mutex);
        break;
      }
      case (signed long int)83:
      {
        scan_all_processes = (signed int)(msg.body.arg1 != (signed long int)0);
        if(!(scan_all_processes == 0))
          numad_log(5, "Scanning all processes\n");

        else
          numad_log(5, "Scanning only explicit PID list processes\n");
        break;
      }
      case (signed long int)116:
      {
        numad_log(5, "Changing logical CPU thread percent to %d\n", msg.body.arg1);
        htt_percent = (signed int)msg.body.arg1;
        node_info_time_stamp = (unsigned long int)0;
        break;
      }
      case (signed long int)117:
      {
        numad_log(5, "Changing target utilization to %d\n", msg.body.arg1);
        target_utilization = (signed int)msg.body.arg1;
        break;
      }
      case (signed long int)119:
      {
        numad_log(5, "Getting NUMA pre-placement advice for %d CPUs and %d MBs\n", msg.body.arg1, msg.body.arg2);
        pthread_mutex_lock(&node_info_mutex);
        update_nodes();
        node_list_p=pick_numa_nodes(-1, (signed int)msg.body.arg1, (signed int)msg.body.arg2, 0);
        str_from_id_list(buf, 1024, node_list_p);
        pthread_mutex_unlock(&node_info_mutex);
        send_msg(msg.body.src_pid, (signed long int)119, (signed long int)0, (signed long int)0, buf);
        break;
      }
      case (signed long int)120:
      {
        numad_log(5, "Adding PID %d to exclusion PID list\n", msg.body.arg1);
        pthread_mutex_lock(&pid_list_mutex);
        include_pid_list=remove_pid_from_pid_list(include_pid_list, msg.body.arg1);
        exclude_pid_list=insert_pid_into_pid_list(exclude_pid_list, msg.body.arg1);
        pthread_mutex_unlock(&pid_list_mutex);
        break;
      }
      default:
        numad_log(4, "Unexpected msg command: %c %d %d %s from PID %d\n", msg.body.cmd, msg.body.arg1, msg.body.arg1, (const void *)msg.body.text, msg.body.src_pid);
    }
  }
  while((_Bool)1);
}

// set_thp_scan_sleep_ms
// file numad.c line 747
void set_thp_scan_sleep_ms(signed int new_ms)
{
  char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *tmp_post$4;
  if(new_ms >= 1)
  {
    char *thp_scan_fname = "/sys/kernel/mm/transparent_hugepage/khugepaged/scan_sleep_millisecs";
    signed int fd;
    fd=open(thp_scan_fname, 02, 0);
    if(fd >= 0)
    {
      char buf[1024l];
      signed int bytes;
      signed long int return_value_read$1;
      return_value_read$1=read(fd, (void *)buf, (unsigned long int)1024);
      bytes = (signed int)return_value_read$1;
      if(bytes >= 1)
      {
        buf[(signed long int)bytes] = (char)0;
        signed int cur_ms;
        char *p = buf;
        tmp_post$2 = p;
        p = p + 1l;
        cur_ms = (signed int)*tmp_post$2 - 48;
        do
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0)
            break;

          cur_ms = cur_ms * 10;
          tmp_post$4 = p;
          p = p + 1l;
          cur_ms = cur_ms + ((signed int)*tmp_post$4 - 48);
        }
        while((_Bool)1);
        if(!(cur_ms == new_ms))
        {
          lseek(fd, (signed long int)0, 0);
          numad_log(5, "Changing THP scan time in %s from %d to %d ms.\n", thp_scan_fname, cur_ms, new_ms);
          sprintf(buf, "%d\n", new_ms);
          unsigned long int return_value_strlen$5;
          return_value_strlen$5=strlen(buf);
          write(fd, (const void *)buf, return_value_strlen$5);
        }

      }

      close(fd);
    }

  }

}

// show_nodes
// file numad.c line 1189
void show_nodes()
{
  fprintf(log_fs, "\n");
  numad_log(6, "Nodes: %d\n", num_nodes);
  fprintf(log_fs, "Min CPUs free: %ld, Max CPUs: %ld, Avg CPUs: %ld, StdDev: %lg\n", min_node_CPUs_free, max_node_CPUs_free, avg_node_CPUs_free, stddev_node_CPUs_free);
  fprintf(log_fs, "Min MBs free: %ld, Max MBs: %ld, Avg MBs: %ld, StdDev: %lg\n", min_node_MBs_free, max_node_MBs_free, avg_node_MBs_free, stddev_node_MBs_free);
  signed int ix = 0;
  for( ; !(ix >= num_nodes); ix = ix + 1)
  {
    fprintf(log_fs, "Node %d: MBs_total %ld, MBs_free %6ld, CPUs_total %ld, CPUs_free %4ld,  Distance: ", ix, (node + (signed long int)ix)->MBs_total, (node + (signed long int)ix)->MBs_free, (node + (signed long int)ix)->CPUs_total, (node + (signed long int)ix)->CPUs_free);
    signed int d = 0;
    for( ; !(d >= num_nodes); d = d + 1)
      fprintf(log_fs, "%d ", (node + (signed long int)ix)->distance[(signed long int)d]);
    char buf[1024l];
    str_from_id_list(buf, 1024, (node + (signed long int)ix)->cpu_list_p);
    fprintf(log_fs, " CPUs: %s\n", (const void *)buf);
  }
  fflush(log_fs);
}

// shut_down_numad
// file numad.c line 705
void shut_down_numad()
{
  numad_log(5, "Shutting down numad\n");
  flush_msg_queue();
  unlink("/var/run/numad.pid");
  close_log_file();
  exit(0);
}

// sig_handler
// file numad.c line 122
void sig_handler(signed int signum)
{
  switch(signum)
  {
    case 1:
    {
      got_sighup = 1;
      break;
    }
    case 15:
    {
      got_sigterm = 1;
      break;
    }
    case 3:
      got_sigquit = 1;
  }
}

// str_from_id_list
// file numad.c line 351
signed int str_from_id_list(char *str_p, signed int str_size, struct id_list *list_p)
{
  char *p = str_p;
  if(p == ((char *)NULL) || !(str_size >= 3))
  {
    numad_log(2, "Bad string for ID listing\n");
    exit(1);
  }

  signed int n;
  _Bool tmp_if_expr$1;
  if(list_p == ((struct id_list *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    n=__sched_cpucount(list_p->bytes, list_p->set_p);
    tmp_if_expr$1 = n == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int id_range_start;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$3;
  char *tmp_post$5;
  char *tmp_post$7;
  if(!tmp_if_expr$1)
  {
    id_range_start = -1;
    signed int id = 0;
    do
    {
      signed int id_in_list;
      unsigned long int __cpu = (unsigned long int)id;
      if(!(__cpu / 8ul >= list_p->bytes))
        tmp_if_expr$3 = (signed int)((((const unsigned long int *)list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

      else
        tmp_if_expr$3 = 0;
      tmp_statement_expression$2 = tmp_if_expr$3;
      id_in_list = (signed int)(tmp_statement_expression$2 != 0);
      if(!(id_in_list == 0) && !(id_range_start >= 0))
        id_range_start = id;

      else
        if(id_in_list == 0 && id_range_start >= 0)
        {
          signed int return_value_snprintf$4;
          return_value_snprintf$4=snprintf(p, (unsigned long int)(((str_p + (signed long int)str_size) - p) - (signed long int)1), "%d", id_range_start);
          p = p + (signed long int)return_value_snprintf$4;
          if(id + -id_range_start >= 2)
          {
            tmp_post$5 = p;
            p = p + 1l;
            *tmp_post$5 = (char)45;
            signed int return_value_snprintf$6;
            return_value_snprintf$6=snprintf(p, (unsigned long int)(((str_p + (signed long int)str_size) - p) - (signed long int)1), "%d", id - 1);
            p = p + (signed long int)return_value_snprintf$6;
          }

          tmp_post$7 = p;
          p = p + 1l;
          *tmp_post$7 = (char)44;
          id_range_start = -1;
          if(!(n >= 1))
            break;

        }

      n = n - id_in_list;
      id = id + 1;
    }
    while((_Bool)1);
    p = p - (signed long int)1;
  }


terminate_string:
  ;
  *p = (char)0;
  return (signed int)(p - str_p);
}

// update_cpu_data
// file numad.c line 1117
void update_cpu_data()
{
  _Bool tmp_if_expr$3;
  static struct _IO_FILE *fs;
  if(!(fs == ((struct _IO_FILE *)NULL)))
    rewind(fs);

  else
  {
    fs=fopen("/proc/stat", "r");
    if(fs == ((struct _IO_FILE *)NULL))
    {
      numad_log(2, "Cannot get /proc/stat contents\n");
      exit(1);
    }

    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)num_cpus * sizeof(unsigned long int) /*8ul*/ );
    cpu_data_buf[(signed long int)0].idle = (unsigned long int *)return_value_malloc$1;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)num_cpus * sizeof(unsigned long int) /*8ul*/ );
    cpu_data_buf[(signed long int)1].idle = (unsigned long int *)return_value_malloc$2;
    if(cpu_data_buf[0l].idle == ((unsigned long int *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = cpu_data_buf[(signed long int)1].idle == (unsigned long int *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      numad_log(2, "cpu_data_buf malloc failed\n");
      exit(1);
    }

  }
  signed int new = 1 - cur_cpu_data_buf;
  cpu_data_buf[(signed long int)new].time_stamp=get_time_stamp();
  char buf[1024l];
  char *return_value_fgets$4;
  const unsigned short int **return_value___ctype_b_loc$18;
  char *tmp_post$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  char *tmp_post$7;
  const unsigned short int **return_value___ctype_b_loc$8;
  const unsigned short int **return_value___ctype_b_loc$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  const unsigned short int **return_value___ctype_b_loc$11;
  const unsigned short int **return_value___ctype_b_loc$12;
  const unsigned short int **return_value___ctype_b_loc$13;
  const unsigned short int **return_value___ctype_b_loc$14;
  char *tmp_post$15;
  const unsigned short int **return_value___ctype_b_loc$16;
  char *tmp_post$17;
  do
  {
    return_value_fgets$4=fgets(buf, 1024, fs);
    if(return_value_fgets$4 == ((char *)NULL))
      break;

    if((signed int)buf[0l] == 99)
    {
      if((signed int)buf[1l] == 112)
      {
        if((signed int)buf[2l] == 117)
        {
          return_value___ctype_b_loc$18=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$18)[(signed long int)(signed int)buf[3l]]) == 0))
          {
            char *p = &buf[(signed long int)3];
            signed int cpu_id;
            tmp_post$5 = p;
            p = p + 1l;
            cpu_id = (signed int)*tmp_post$5 - 48;
            do
            {
              return_value___ctype_b_loc$6=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*p]) == 0)
                break;

              cpu_id = cpu_id * 10;
              tmp_post$7 = p;
              p = p + 1l;
              cpu_id = cpu_id + ((signed int)*tmp_post$7 - 48);
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$8=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*p]) == 0))
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$9=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*p]) == 0)
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$10=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)*p]) == 0))
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$11=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*p]) == 0)
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$12=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*p]) == 0))
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$13=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)*p]) == 0)
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            do
            {
              return_value___ctype_b_loc$14=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$14)[(signed long int)(signed int)*p]) == 0))
                break;

              p = p + 1l;
            }
            while((_Bool)1);
            unsigned long int idle;
            tmp_post$15 = p;
            p = p + 1l;
            idle = (unsigned long int)((signed int)*tmp_post$15 - 48);
            do
            {
              return_value___ctype_b_loc$16=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc$16)[(signed long int)(signed int)*p]) == 0)
                break;

              idle = idle * (unsigned long int)10;
              tmp_post$17 = p;
              p = p + 1l;
              idle = idle + (unsigned long int)((signed int)*tmp_post$17 - 48);
            }
            while((_Bool)1);
            cpu_data_buf[(signed long int)new].idle[(signed long int)cpu_id] = idle;
          }

        }

      }

    }

  }
  while((_Bool)1);
  cur_cpu_data_buf = new;
}

// update_nodes
// file numad.c line 1209
signed int update_nodes()
{
  char fname[192l];
  char buf[4096l];
  unsigned long int time_stamp;
  time_stamp=get_time_stamp();
  char *tmp_post$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  char *tmp_post$6;
  _Bool tmp_if_expr$9;
  signed long int return_value_read$8;
  _Bool tmp_if_expr$16;
  signed long int return_value_read$15;
  char *tmp_post$11;
  const unsigned short int **return_value___ctype_b_loc$12;
  char *tmp_post$13;
  signed int tmp_post$14;
  if(num_nodes == 0 || !(60000ul + node_info_time_stamp >= time_stamp))
  {
    node_info_time_stamp = time_stamp;
    struct dirent **namelist;
    signed int num_files;
    num_files=scandir("/sys/devices/system/node", &namelist, node_and_digits, (signed int (*)(struct dirent **, struct dirent **))(void *)0);
    if(!(num_files >= 1))
    {
      numad_log(2, "Could not get NUMA node info\n");
      exit(1);
    }

    signed int need_to_realloc = (signed int)(num_files != num_nodes);
    if(!(need_to_realloc == 0))
    {
      signed int ix = num_files;
      for( ; !(ix >= num_nodes); ix = ix + 1)
      {
        free((void *)(node + (signed long int)ix)->distance);
        if(!((node + (signed long int)ix)->cpu_list_p == ((struct id_list *)NULL)))
        {
          if(!((node + (signed long int)ix)->cpu_list_p->set_p == ((struct anonymous$2 *)NULL)))
            __sched_cpufree((node + (signed long int)ix)->cpu_list_p->set_p);

          free((void *)(node + (signed long int)ix)->cpu_list_p);
          (node + (signed long int)ix)->cpu_list_p = (struct id_list *)(void *)0;
        }

      }
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)node, (unsigned long int)num_files * sizeof(struct node_data) /*64ul*/ );
      node = (struct node_data *)return_value_realloc$1;
      if(node == ((struct node_data *)NULL))
      {
        numad_log(2, "node realloc failed\n");
        exit(1);
      }

      signed int update_nodes$$1$$1$$2$$3$$ix = num_nodes;
      for( ; !(update_nodes$$1$$1$$2$$3$$ix >= num_files); update_nodes$$1$$1$$2$$3$$ix = update_nodes$$1$$1$$2$$3$$ix + 1)
      {
        (node + (signed long int)update_nodes$$1$$1$$2$$3$$ix)->distance = (unsigned char *)(void *)0;
        (node + (signed long int)update_nodes$$1$$1$$2$$3$$ix)->cpu_list_p = (struct id_list *)(void *)0;
      }
      num_nodes = num_files;
    }

    sum_CPUs_total = (signed long int)0;
    if(all_cpus_list_p == ((struct id_list *)NULL))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct id_list) /*16ul*/ );
      all_cpus_list_p = (struct id_list *)return_value_malloc$2;
      if(all_cpus_list_p == ((struct id_list *)NULL))
      {
        numad_log(2, "INIT_ID_LIST malloc failed\n");
        exit(1);
      }

      all_cpus_list_p->set_p=__sched_cpualloc((unsigned long int)num_cpus);
      if(all_cpus_list_p->set_p == ((struct anonymous$2 *)NULL))
      {
        numad_log(2, "CPU_ALLOC failed\n");
        exit(1);
      }

      all_cpus_list_p->bytes = ((((unsigned long int)num_cpus + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
    }

    do
      __builtin_memset((void *)all_cpus_list_p->set_p, 0, all_cpus_list_p->bytes);
    while((_Bool)0);
    if(all_nodes_list_p == ((struct id_list *)NULL))
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct id_list) /*16ul*/ );
      all_nodes_list_p = (struct id_list *)return_value_malloc$3;
      if(all_nodes_list_p == ((struct id_list *)NULL))
      {
        numad_log(2, "INIT_ID_LIST malloc failed\n");
        exit(1);
      }

      all_nodes_list_p->set_p=__sched_cpualloc((unsigned long int)num_nodes);
      if(all_nodes_list_p->set_p == ((struct anonymous$2 *)NULL))
      {
        numad_log(2, "CPU_ALLOC failed\n");
        exit(1);
      }

      all_nodes_list_p->bytes = ((((unsigned long int)num_nodes + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
    }

    do
      __builtin_memset((void *)all_nodes_list_p->set_p, 0, all_nodes_list_p->bytes);
    while((_Bool)0);
    threads_per_core=count_set_bits_in_hex_list_file("/sys/devices/system/cpu/cpu0/topology/thread_siblings");
    if(!(threads_per_core >= 1))
    {
      numad_log(2, "Could not count threads per core\n");
      exit(1);
    }

    signed int update_nodes$$1$$1$$6$$node_ix = 0;
    for( ; !(update_nodes$$1$$1$$6$$node_ix >= num_nodes); update_nodes$$1$$1$$6$$node_ix = update_nodes$$1$$1$$6$$node_ix + 1)
    {
      signed int update_nodes$$1$$1$$6$$1$$node_id;
      char *update_nodes$$1$$1$$6$$1$$p = &namelist[(signed long int)update_nodes$$1$$1$$6$$node_ix]->d_name[(signed long int)4];
      tmp_post$4 = update_nodes$$1$$1$$6$$1$$p;
      update_nodes$$1$$1$$6$$1$$p = update_nodes$$1$$1$$6$$1$$p + 1l;
      update_nodes$$1$$1$$6$$1$$node_id = (signed int)*tmp_post$4 - 48;
      do
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*update_nodes$$1$$1$$6$$1$$p]) == 0)
          break;

        update_nodes$$1$$1$$6$$1$$node_id = update_nodes$$1$$1$$6$$1$$node_id * 10;
        tmp_post$6 = update_nodes$$1$$1$$6$$1$$p;
        update_nodes$$1$$1$$6$$1$$p = update_nodes$$1$$1$$6$$1$$p + 1l;
        update_nodes$$1$$1$$6$$1$$node_id = update_nodes$$1$$1$$6$$1$$node_id + ((signed int)*tmp_post$6 - 48);
      }
      while((_Bool)1);
      free((void *)namelist[(signed long int)update_nodes$$1$$1$$6$$node_ix]);
      (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->node_id = (unsigned long int)update_nodes$$1$$1$$6$$1$$node_id;
      unsigned long int update_nodes$$1$$1$$6$$1$$2$$__cpu = (unsigned long int)update_nodes$$1$$1$$6$$1$$node_id;
      if(!(update_nodes$$1$$1$$6$$1$$2$$__cpu / 8ul >= all_nodes_list_p->bytes))
        ((unsigned long int *)all_nodes_list_p->set_p->__bits)[(signed long int)(update_nodes$$1$$1$$6$$1$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)all_nodes_list_p->set_p->__bits)[(signed long int)(update_nodes$$1$$1$$6$$1$$2$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << update_nodes$$1$$1$$6$$1$$2$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

      else
        (unsigned long int)0;
      snprintf(fname, (unsigned long int)192, "/sys/devices/system/node/node%d/cpulist", update_nodes$$1$$1$$6$$1$$node_id);
      signed int update_nodes$$1$$1$$6$$1$$fd;
      update_nodes$$1$$1$$6$$1$$fd=open(fname, 00, 0);
      if(update_nodes$$1$$1$$6$$1$$fd >= 0)
      {
        return_value_read$8=read(update_nodes$$1$$1$$6$$1$$fd, (void *)buf, (unsigned long int)4096);
        tmp_if_expr$9 = return_value_read$8 > (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        buf[(signed long int)(4096 - 1)] = (char)0;
        if((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p == ((struct id_list *)NULL))
        {
          void *return_value_malloc$7;
          return_value_malloc$7=malloc(sizeof(struct id_list) /*16ul*/ );
          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p = (struct id_list *)return_value_malloc$7;
          if((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p == ((struct id_list *)NULL))
          {
            numad_log(2, "INIT_ID_LIST malloc failed\n");
            exit(1);
          }

          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p=__sched_cpualloc((unsigned long int)num_cpus);
          if((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p == ((struct anonymous$2 *)NULL))
          {
            numad_log(2, "CPU_ALLOC failed\n");
            exit(1);
          }

          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->bytes = ((((unsigned long int)num_cpus + (unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) * sizeof(unsigned long int) /*8ul*/ ;
        }

        do
          __builtin_memset((void *)(node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p, 0, (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->bytes);
        while((_Bool)0);
        signed int n;
        n=add_ids_to_list_from_str((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p, buf);
        if(!(reserved_cpu_str == ((char *)NULL)))
        {
          struct anonymous$2 *__dest = (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p;
          const unsigned long int *__arr1 = (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p->__bits;
          const unsigned long int *__arr2 = reserved_cpu_mask_list_p->set_p->__bits;
          unsigned long int __imax = (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->bytes / sizeof(unsigned long int) /*8ul*/ ;
          unsigned long int __i = (unsigned long int)0;
          for( ; !(__i >= __imax); __i = __i + 1ul)
            ((unsigned long int *)__dest->__bits)[(signed long int)__i] = __arr1[(signed long int)__i] & __arr2[(signed long int)__i];
          __dest;
          n=__sched_cpucount((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->bytes, (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p);
        }

        struct anonymous$2 *update_nodes$$1$$1$$6$$1$$3$$3$$__dest = all_cpus_list_p->set_p;
        const unsigned long int *update_nodes$$1$$1$$6$$1$$3$$3$$__arr1 = all_cpus_list_p->set_p->__bits;
        const unsigned long int *update_nodes$$1$$1$$6$$1$$3$$3$$__arr2 = (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->cpu_list_p->set_p->__bits;
        unsigned long int update_nodes$$1$$1$$6$$1$$3$$3$$__imax = all_cpus_list_p->bytes / sizeof(unsigned long int) /*8ul*/ ;
        unsigned long int update_nodes$$1$$1$$6$$1$$3$$3$$__i = (unsigned long int)0;
        for( ; !(update_nodes$$1$$1$$6$$1$$3$$3$$__i >= update_nodes$$1$$1$$6$$1$$3$$3$$__imax); update_nodes$$1$$1$$6$$1$$3$$3$$__i = update_nodes$$1$$1$$6$$1$$3$$3$$__i + 1ul)
          ((unsigned long int *)update_nodes$$1$$1$$6$$1$$3$$3$$__dest->__bits)[(signed long int)update_nodes$$1$$1$$6$$1$$3$$3$$__i] = update_nodes$$1$$1$$6$$1$$3$$3$$__arr1[(signed long int)update_nodes$$1$$1$$6$$1$$3$$3$$__i] | update_nodes$$1$$1$$6$$1$$3$$3$$__arr2[(signed long int)update_nodes$$1$$1$$6$$1$$3$$3$$__i];
        update_nodes$$1$$1$$6$$1$$3$$3$$__dest;
        if(threads_per_core == 1 || htt_percent >= 100)
          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->CPUs_total = (unsigned long int)(n * 100);

        else
        {
          n = n / threads_per_core;
          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->CPUs_total = (unsigned long int)(n * 100);
          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->CPUs_total = (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->CPUs_total + (unsigned long int)(n * (threads_per_core - 1) * htt_percent);
        }
        sum_CPUs_total = sum_CPUs_total + (signed long int)(node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->CPUs_total;
        close(update_nodes$$1$$1$$6$$1$$fd);
      }

      else
      {
        numad_log(2, "Could not get node cpu list\n");
        exit(1);
      }
      if(!(need_to_realloc == 0))
      {
        void *return_value_realloc$10;
        return_value_realloc$10=realloc((void *)(node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->distance, (unsigned long int)num_nodes * sizeof(unsigned char) /*1ul*/ );
        (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->distance = (unsigned char *)return_value_realloc$10;
        if((node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->distance == ((unsigned char *)NULL))
        {
          numad_log(2, "node distance realloc failed\n");
          exit(1);
        }

      }

      snprintf(fname, (unsigned long int)192, "/sys/devices/system/node/node%d/distance", update_nodes$$1$$1$$6$$1$$node_id);
      update_nodes$$1$$1$$6$$1$$fd=open(fname, 00, 0);
      if(update_nodes$$1$$1$$6$$1$$fd >= 0)
      {
        return_value_read$15=read(update_nodes$$1$$1$$6$$1$$fd, (void *)buf, (unsigned long int)4096);
        tmp_if_expr$16 = return_value_read$15 > (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$16 = (_Bool)0;
      if(tmp_if_expr$16)
      {
        signed int rnode = 0;
        char *p = buf;
        while(!((signed int)*p == 10))
        {
          signed int lat;
          tmp_post$11 = p;
          p = p + 1l;
          lat = (signed int)*tmp_post$11 - 48;
          do
          {
            return_value___ctype_b_loc$12=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*p]) == 0)
              break;

            lat = lat * 10;
            tmp_post$13 = p;
            p = p + 1l;
            lat = lat + ((signed int)*tmp_post$13 - 48);
          }
          while((_Bool)1);
          tmp_post$14 = rnode;
          rnode = rnode + 1;
          (node + (signed long int)update_nodes$$1$$1$$6$$node_ix)->distance[(signed long int)tmp_post$14] = (unsigned char)lat;
          for( ; (signed int)*p == 32; p = p + 1l)
            ;
        }
        close(update_nodes$$1$$1$$6$$1$$fd);
      }

      else
      {
        numad_log(2, "Could not get node distance data\n");
        exit(1);
      }
    }
    free((void *)namelist);
  }

  while(7ul + cpu_data_buf[(signed long int)cur_cpu_data_buf].time_stamp >= time_stamp)
  {
    struct timespec ts = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)100000000 };
    nanosleep(&ts, &ts);
    time_stamp=get_time_stamp();
  }
  update_cpu_data();
  max_node_MBs_free = (signed long int)0;
  max_node_CPUs_free = (signed long int)0;
  min_node_MBs_free = (signed long int)0x7fffffff;
  min_node_CPUs_free = (signed long int)0x7fffffff;
  unsigned long int sum_of_node_MBs_free = (unsigned long int)0;
  unsigned long int sum_of_node_CPUs_free = (unsigned long int)0;
  signed int node_ix = 0;
  _Bool tmp_if_expr$30;
  signed long int return_value_read$29;
  const unsigned short int **return_value___ctype_b_loc$17;
  char *tmp_post$18;
  const unsigned short int **return_value___ctype_b_loc$19;
  char *tmp_post$20;
  const unsigned short int **return_value___ctype_b_loc$21;
  char *tmp_post$22;
  const unsigned short int **return_value___ctype_b_loc$23;
  char *tmp_post$24;
  const unsigned short int **return_value___ctype_b_loc$25;
  char *tmp_post$26;
  const unsigned short int **return_value___ctype_b_loc$27;
  char *tmp_post$28;
  signed int tmp_statement_expression$31;
  signed int tmp_if_expr$32;
  for( ; !(node_ix >= num_nodes); node_ix = node_ix + 1)
  {
    signed int node_id = (signed int)(node + (signed long int)node_ix)->node_id;
    snprintf(fname, (unsigned long int)192, "/sys/devices/system/node/node%d/meminfo", node_id);
    signed int fd;
    fd=open(fname, 00, 0);
    if(fd >= 0)
    {
      return_value_read$29=read(fd, (void *)buf, (unsigned long int)4096);
      tmp_if_expr$30 = return_value_read$29 > (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$30 = (_Bool)0;
    if(tmp_if_expr$30)
    {
      close(fd);
      unsigned long int KB;
      buf[(signed long int)(4096 - 1)] = (char)0;
      char *update_nodes$$1$$3$$1$$1$$p;
      update_nodes$$1$$3$$1$$1$$p=strstr(buf, "MemTotal:");
      if(!(update_nodes$$1$$3$$1$$1$$p == ((char *)NULL)))
        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + (signed long int)9;

      else
      {
        numad_log(2, "Could not get node MemTotal\n");
        exit(1);
      }
      do
      {
        return_value___ctype_b_loc$17=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$17)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0))
          break;

        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
      }
      while((_Bool)1);
      tmp_post$18 = update_nodes$$1$$3$$1$$1$$p;
      update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
      KB = (unsigned long int)((signed int)*tmp_post$18 - 48);
      do
      {
        return_value___ctype_b_loc$19=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$19)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0)
          break;

        KB = KB * (unsigned long int)10;
        tmp_post$20 = update_nodes$$1$$3$$1$$1$$p;
        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
        KB = KB + (unsigned long int)((signed int)*tmp_post$20 - 48);
      }
      while((_Bool)1);
      (node + (signed long int)node_ix)->MBs_total = KB / (unsigned long int)1024;
      if(!((node + (signed long int)node_ix)->MBs_total >= 1ul))
      {
        unsigned long int __cpu = (unsigned long int)node_id;
        if(!(__cpu / 8ul >= all_nodes_list_p->bytes))
          ((unsigned long int *)all_nodes_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)all_nodes_list_p->set_p->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & ~((unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ));

        else
          (unsigned long int)0;
      }

      update_nodes$$1$$3$$1$$1$$p=strstr(update_nodes$$1$$3$$1$$1$$p, "MemFree:");
      if(!(update_nodes$$1$$3$$1$$1$$p == ((char *)NULL)))
        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + (signed long int)8;

      else
      {
        numad_log(2, "Could not get node MemFree\n");
        exit(1);
      }
      do
      {
        return_value___ctype_b_loc$21=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc$21)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0))
          break;

        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
      }
      while((_Bool)1);
      tmp_post$22 = update_nodes$$1$$3$$1$$1$$p;
      update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
      KB = (unsigned long int)((signed int)*tmp_post$22 - 48);
      do
      {
        return_value___ctype_b_loc$23=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$23)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0)
          break;

        KB = KB * (unsigned long int)10;
        tmp_post$24 = update_nodes$$1$$3$$1$$1$$p;
        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
        KB = KB + (unsigned long int)((signed int)*tmp_post$24 - 48);
      }
      while((_Bool)1);
      (node + (signed long int)node_ix)->MBs_free = KB / (unsigned long int)1024;
      if(!(use_inactive_file_cache == 0))
      {
        update_nodes$$1$$3$$1$$1$$p=strstr(update_nodes$$1$$3$$1$$1$$p, "Inactive(file):");
        if(!(update_nodes$$1$$3$$1$$1$$p == ((char *)NULL)))
          update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + (signed long int)15;

        else
        {
          numad_log(2, "Could not get node Inactive(file)\n");
          exit(1);
        }
        do
        {
          return_value___ctype_b_loc$25=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$25)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0))
            break;

          update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
        }
        while((_Bool)1);
        tmp_post$26 = update_nodes$$1$$3$$1$$1$$p;
        update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
        KB = (unsigned long int)((signed int)*tmp_post$26 - 48);
        do
        {
          return_value___ctype_b_loc$27=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)*update_nodes$$1$$3$$1$$1$$p]) == 0)
            break;

          KB = KB * (unsigned long int)10;
          tmp_post$28 = update_nodes$$1$$3$$1$$1$$p;
          update_nodes$$1$$3$$1$$1$$p = update_nodes$$1$$3$$1$$1$$p + 1l;
          KB = KB + (unsigned long int)((signed int)*tmp_post$28 - 48);
        }
        while((_Bool)1);
        (node + (signed long int)node_ix)->MBs_free = (node + (signed long int)node_ix)->MBs_free + KB / (unsigned long int)1024;
      }

      sum_of_node_MBs_free = sum_of_node_MBs_free + (node + (signed long int)node_ix)->MBs_free;
      if(!((node + (signed long int)node_ix)->MBs_free >= (unsigned long int)min_node_MBs_free))
      {
        min_node_MBs_free = (signed long int)(node + (signed long int)node_ix)->MBs_free;
        min_node_MBs_free_ix = (signed int)(node + (signed long int)node_ix)->node_id;
      }

      if(!((unsigned long int)max_node_MBs_free >= (node + (signed long int)node_ix)->MBs_free))
        max_node_MBs_free = (signed long int)(node + (signed long int)node_ix)->MBs_free;

    }

    else
    {
      numad_log(2, "Could not get node meminfo\n");
      exit(1);
    }
    signed int old_cpu_data_buf = 1 - cur_cpu_data_buf;
    if(cpu_data_buf[(signed long int)old_cpu_data_buf].time_stamp >= 1ul)
    {
      unsigned long int idle_ticks = (unsigned long int)0;
      signed int cpu = 0;
      signed int num_lcpus;
      num_lcpus=__sched_cpucount((node + (signed long int)node_ix)->cpu_list_p->bytes, (node + (signed long int)node_ix)->cpu_list_p->set_p);
      signed int num_cpus_to_process = num_lcpus;
      for( ; !(num_cpus_to_process == 0); cpu = cpu + 1)
      {
        unsigned long int update_nodes$$1$$3$$1$$3$$1$$1$$__cpu = (unsigned long int)cpu;
        if(!(update_nodes$$1$$3$$1$$3$$1$$1$$__cpu / 8ul >= (node + (signed long int)node_ix)->cpu_list_p->bytes))
          tmp_if_expr$32 = (signed int)((((const unsigned long int *)(node + (signed long int)node_ix)->cpu_list_p->set_p->__bits)[(signed long int)(update_nodes$$1$$3$$1$$3$$1$$1$$__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << update_nodes$$1$$3$$1$$3$$1$$1$$__cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

        else
          tmp_if_expr$32 = 0;
        tmp_statement_expression$31 = tmp_if_expr$32;
        if(!(tmp_statement_expression$31 == 0))
        {
          idle_ticks = idle_ticks + (cpu_data_buf[(signed long int)cur_cpu_data_buf].idle[(signed long int)cpu] - cpu_data_buf[(signed long int)old_cpu_data_buf].idle[(signed long int)cpu]);
          num_cpus_to_process = num_cpus_to_process - 1;
        }

      }
      unsigned long int time_diff = cpu_data_buf[(signed long int)cur_cpu_data_buf].time_stamp - cpu_data_buf[(signed long int)old_cpu_data_buf].time_stamp;
      (node + (signed long int)node_ix)->CPUs_free = (idle_ticks * (unsigned long int)100) / time_diff;
      if(threads_per_core >= 2 && !(htt_percent >= 100))
      {
        unsigned long int htt_discount = (unsigned long int)((num_lcpus - num_lcpus / threads_per_core) * (100 - htt_percent));
        if(!(htt_discount >= (node + (signed long int)node_ix)->CPUs_free))
          (node + (signed long int)node_ix)->CPUs_free = (node + (signed long int)node_ix)->CPUs_free - htt_discount;

        else
          (node + (signed long int)node_ix)->CPUs_free = (unsigned long int)0;
      }

      if(!((node + (signed long int)node_ix)->CPUs_total >= (node + (signed long int)node_ix)->CPUs_free))
        (node + (signed long int)node_ix)->CPUs_free = (node + (signed long int)node_ix)->CPUs_total;

      sum_of_node_CPUs_free = sum_of_node_CPUs_free + (node + (signed long int)node_ix)->CPUs_free;
      if(!((node + (signed long int)node_ix)->CPUs_free >= (unsigned long int)min_node_CPUs_free))
      {
        min_node_CPUs_free = (signed long int)(node + (signed long int)node_ix)->CPUs_free;
        min_node_CPUs_free_ix = (signed int)(node + (signed long int)node_ix)->node_id;
      }

      if(!((unsigned long int)max_node_CPUs_free >= (node + (signed long int)node_ix)->CPUs_free))
        max_node_CPUs_free = (signed long int)(node + (signed long int)node_ix)->CPUs_free;

      (node + (signed long int)node_ix)->magnitude = (node + (signed long int)node_ix)->CPUs_free * (node + (signed long int)node_ix)->MBs_free;
    }

    else
    {
      (node + (signed long int)node_ix)->CPUs_free = (unsigned long int)0;
      (node + (signed long int)node_ix)->magnitude = (unsigned long int)0;
    }
  }
  avg_node_MBs_free = (signed long int)(sum_of_node_MBs_free / (unsigned long int)num_nodes);
  avg_node_CPUs_free = (signed long int)(sum_of_node_CPUs_free / (unsigned long int)num_nodes);
  double MBs_variance_sum = 0.0;
  double CPUs_variance_sum = 0.0;
  signed int update_nodes$$1$$4$$node_ix = 0;
  for( ; !(update_nodes$$1$$4$$node_ix >= num_nodes); update_nodes$$1$$4$$node_ix = update_nodes$$1$$4$$node_ix + 1)
  {
    double MBs_diff = (double)(node + (signed long int)update_nodes$$1$$4$$node_ix)->MBs_free - (double)avg_node_MBs_free;
    double CPUs_diff = (double)(node + (signed long int)update_nodes$$1$$4$$node_ix)->CPUs_free - (double)avg_node_CPUs_free;
    MBs_variance_sum = MBs_variance_sum + MBs_diff * MBs_diff;
    CPUs_variance_sum = CPUs_variance_sum + CPUs_diff * CPUs_diff;
  }
  double MBs_variance = MBs_variance_sum / (double)num_nodes;
  double CPUs_variance = CPUs_variance_sum / (double)num_nodes;
  stddev_node_MBs_free=sqrt(MBs_variance);
  stddev_node_CPUs_free=sqrt(CPUs_variance);
  if(log_level >= 6)
    show_nodes();

  return num_nodes;
}

// update_processes
// file numad.c line 1568
signed int update_processes()
{
  unsigned long int this_update_time;
  this_update_time=get_time_stamp();
  signed int new_candidates = 0;
  signed int files = 0;
  if(!(scan_all_processes == 0))
  {
    struct dirent **namelist;
    files=scandir("/proc", &namelist, name_starts_with_digit, (signed int (*)(struct dirent **, struct dirent **))(void *)0);
    if(!(files >= 0))
    {
      numad_log(2, "Could not open /proc\n");
      exit(1);
    }

    signed int ix = 0;
    for( ; !(ix >= files); ix = ix + 1)
    {
      struct process_data *update_processes$$1$$1$$2$$1$$data_p;
      update_processes$$1$$1$$2$$1$$data_p=get_stat_data_for_pid(-1, namelist[(signed long int)ix]->d_name);
      if(!(update_processes$$1$$1$$2$$1$$data_p == ((struct process_data *)NULL)))
      {
        if(update_processes$$1$$1$$2$$1$$data_p->MBs_used >= 301ul)
        {
          if(!(new_candidates >= process_hash_table_size / 3))
          {
            update_processes$$1$$1$$2$$1$$data_p->data_time_stamp=get_time_stamp();
            signed int return_value_process_hash_update$1;
            return_value_process_hash_update$1=process_hash_update(update_processes$$1$$1$$2$$1$$data_p);
            new_candidates = new_candidates + return_value_process_hash_update$1;
          }

        }

      }

      free((void *)namelist[(signed long int)ix]);
    }
    free((void *)namelist);
  }

  pthread_mutex_lock(&pid_list_mutex);
  struct pid_list *pid_ptr = include_pid_list;
  while(!(pid_ptr == ((struct pid_list *)NULL)) && !(new_candidates >= process_hash_table_size / 3))
  {
    signed int hash_ix;
    hash_ix=process_hash_lookup((signed int)pid_ptr->pid);
    if(hash_ix >= 0)
    {
      if(this_update_time >= (process_hash_table + (signed long int)hash_ix)->data_time_stamp)
        goto __CPROVER_DUMP_L7;

      pid_ptr = pid_ptr->next;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      struct process_data *data_p;
      data_p=get_stat_data_for_pid((signed int)pid_ptr->pid, (char *)(void *)0);
      if(!(data_p == ((struct process_data *)NULL)))
      {
        data_p->data_time_stamp=get_time_stamp();
        signed int return_value_process_hash_update$2;
        return_value_process_hash_update$2=process_hash_update(data_p);
        new_candidates = new_candidates + return_value_process_hash_update$2;
        if(scan_all_processes == 0)
          files = files + 1;

        pid_ptr = pid_ptr->next;
      }

      else
      {
        include_pid_list=remove_pid_from_pid_list(include_pid_list, pid_ptr->pid);
        pid_ptr = include_pid_list;
        continue;
      }
    }
  }
  pid_ptr = exclude_pid_list;
  while(!(pid_ptr == ((struct pid_list *)NULL)))
  {
    signed int update_processes$$1$$3$$hash_ix;
    update_processes$$1$$3$$hash_ix=process_hash_lookup((signed int)pid_ptr->pid);
    if(update_processes$$1$$3$$hash_ix >= 0)
      (process_hash_table + (signed long int)update_processes$$1$$3$$hash_ix)->CPUs_used = (unsigned long int)0;

    pid_ptr = pid_ptr->next;
  }
  pthread_mutex_unlock(&pid_list_mutex);
  if(log_level >= 6)
    numad_log(6, "Processes: %d\n", files);

  process_hash_table_cleanup(this_update_time);
  return files;
}

