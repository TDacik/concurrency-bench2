// tag-#anon#ST[*{S8}_S8_'prog'||S32'ind'||S32'outd'||*{S8}_S8_'inf'||U64'inz'||*{S8}_S8_'outf'||S32'verbosity'||S32'headis'||S32'pipeout'||S32'keep'||S32'force'||S32'form'||U8'magic1'||U24'_pad0'||S32'recurse'||*{S8}_S8_'sufx'||*{S8}_S8_'name'||S64'mtime'||S32'list'||S32'first'||S32'decode'||S32'level'||SYM#tag-ZopfliOptions#'zopts'||S32'rsync'||S32'procs'||S32'setdict'||U32'_pad1'||U64'block'||S64'stamp'||*{S8}_S8_'hname'||U64'zip_crc'||U64'zip_clen'||U64'zip_ulen'||ARR32768{U8}_U8_'in_buf'||*{U8}_U8_'in_next'||U64'in_left'||S32'in_eof'||S32'in_short'||S64'in_tot'||S64'out_tot'||U64'out_check'||ARR32768{U8}_U8_'in_buf2'||U64'in_len'||S32'in_which'||U32'_pad2'||*{SYM#tag-lock_s#}_SYM#tag-lock_s#_'load_state'||*{SYM#tag-thread_s#}_SYM#tag-thread_s#_'load_thread'|]
// file pigz.c line 472
struct anonymous_1;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_5;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_4;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_6;

// tag-#anon#ST[S32'code'||S32'free'||*{S8}_S8_'why'|]
// file try.h line 281
struct anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-Node
// file zopfli/src/zopfli/katajainen.c line 30
struct Node;

// tag-NodePool
// file zopfli/src/zopfli/katajainen.c line 45
struct NodePool;

// tag-RanState
// file zopfli/src/zopfli/squeeze.c line 75
struct RanState;

// tag-SplitCostContext
// file zopfli/src/zopfli/blocksplitter.c line 112
struct SplitCostContext;

// tag-SymbolStats
// file zopfli/src/zopfli/squeeze.c line 31
struct SymbolStats;

// tag-ZopfliBlockState
// file zopfli/src/zopfli/lz77.h line 62
struct ZopfliBlockState;

// tag-ZopfliHash
// file zopfli/src/zopfli/hash.h line 29
struct ZopfliHash;

// tag-ZopfliLZ77Store
// file zopfli/src/zopfli/lz77.h line 44
struct ZopfliLZ77Store;

// tag-ZopfliLongestMatchCache
// file zopfli/src/zopfli/cache.h line 39
struct ZopfliLongestMatchCache;

// tag-ZopfliOptions
// file zopfli/src/zopfli/zopfli.h line 33
struct ZopfliOptions;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-capsule
// file yarn.c line 204
struct capsule;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-job
// file pigz.c line 1368
struct job;

// tag-lock_s
// file yarn.h line 123
struct lock_s;

// tag-pool
// file pigz.c line 1229
struct pool;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-space
// file pigz.c line 1224
struct space;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-thread_s
// file yarn.h line 117
struct thread_s;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-try_s_
// file try.h line 288
struct try_s_;

// tag-twist_op
// file yarn.h line 127
enum twist_op { TO=0, BY=1 };

// tag-wait_op
// file yarn.h line 129
enum wait_op { TO_BE=0, NOT_TO_BE=1, TO_BE_MORE_THAN=2, TO_BE_LESS_THAN=3 };

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AbsDiff
// file zopfli/src/zopfli/deflate.c line 369
static unsigned long int AbsDiff(unsigned long int x, unsigned long int y);
// AddBit
// file zopfli/src/zopfli/deflate.c line 38
static void AddBit(signed int bit, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddBits
// file zopfli/src/zopfli/deflate.c line 45
static void AddBits(unsigned int symbol, unsigned int length, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddDynamicTree
// file zopfli/src/zopfli/deflate.c line 251
static void AddDynamicTree(const unsigned int *ll_lengths, const unsigned int *d_lengths, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddHuffmanBits
// file zopfli/src/zopfli/deflate.c line 61
static void AddHuffmanBits(unsigned int symbol, unsigned int length, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddLZ77Block
// file zopfli/src/zopfli/deflate.c line 528
static void AddLZ77Block(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned long int expected_data_size, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddLZ77Data
// file zopfli/src/zopfli/deflate.c line 297
static void AddLZ77Data(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned long int expected_data_size, const unsigned int *ll_symbols, const unsigned int *ll_lengths, const unsigned int *d_symbols, const unsigned int *d_lengths, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// AddSorted
// file zopfli/src/zopfli/blocksplitter.c line 132
static void AddSorted(unsigned long int value, unsigned long int **out, unsigned long int *outsize);
// AddWeighedStatFreqs
// file zopfli/src/zopfli/squeeze.c line 60
static void AddWeighedStatFreqs(const struct SymbolStats *stats1, double w1, const struct SymbolStats *stats2, double w2, struct SymbolStats *result);
// BoundaryPM
// file zopfli/src/zopfli/katajainen.c line 105
static void BoundaryPM(struct Node *(*lists)[2l], signed int maxbits, struct Node *leaves, signed int numsymbols, struct NodePool *pool, signed int index, char final);
// CalculateBlockSymbolSize
// file zopfli/src/zopfli/deflate.c line 348
static unsigned long int CalculateBlockSymbolSize(const unsigned int *ll_lengths, const unsigned int *d_lengths, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend);
// CalculateStatistics
// file zopfli/src/zopfli/squeeze.c line 393
static void CalculateStatistics(struct SymbolStats *stats);
// CalculateTreeSize
// file zopfli/src/zopfli/deflate.c line 277
static unsigned long int CalculateTreeSize(const unsigned int *ll_lengths, const unsigned int *d_lengths);
// ClearStatFreqs
// file zopfli/src/zopfli/squeeze.c line 104
static void ClearStatFreqs(struct SymbolStats *stats);
// CopyStats
// file zopfli/src/zopfli/squeeze.c line 50
static void CopyStats(struct SymbolStats *source, struct SymbolStats *dest);
// DeflateBlock
// file zopfli/src/zopfli/deflate.c line 700
static void DeflateBlock(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// DeflateDynamicBlock
// file zopfli/src/zopfli/deflate.c line 586
static void DeflateDynamicBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// DeflateFixedBlock
// file zopfli/src/zopfli/deflate.c line 639
static void DeflateFixedBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// DeflateNonCompressedBlock
// file zopfli/src/zopfli/deflate.c line 670
static void DeflateNonCompressedBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// DeflateSplittingFirst
// file zopfli/src/zopfli/deflate.c line 721
static void DeflateSplittingFirst(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// DeflateSplittingLast
// file zopfli/src/zopfli/deflate.c line 755
static void DeflateSplittingLast(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// EncodeTree
// file zopfli/src/zopfli/deflate.c line 105
static unsigned long int EncodeTree(const unsigned int *ll_lengths, const unsigned int *d_lengths, signed int use_16, signed int use_17, signed int use_18, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// EstimateCost
// file zopfli/src/zopfli/blocksplitter.c line 106
static double EstimateCost(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend);
// ExtractBitLengths
// file zopfli/src/zopfli/katajainen.c line 163
static void ExtractBitLengths(struct Node *chain, struct Node *leaves, unsigned int *bitlengths);
// FindLargestSplittableBlock
// file zopfli/src/zopfli/blocksplitter.c line 198
static signed int FindLargestSplittableBlock(unsigned long int llsize, const unsigned char *done, const unsigned long int *splitpoints, unsigned long int npoints, unsigned long int *lstart, unsigned long int *lend);
// FindMinimum
// file zopfli/src/zopfli/blocksplitter.c line 43
static unsigned long int FindMinimum(double (*f)(unsigned long int, void *), void *context, unsigned long int start, unsigned long int end);
// FindMinimum::f_object
//
double f_object(unsigned long int, void *);
// FollowPath
// file zopfli/src/zopfli/squeeze.c line 334
static void FollowPath(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned short int *path, unsigned long int pathsize, struct ZopfliLZ77Store *store);
// GetBestLengths
// file zopfli/src/zopfli/squeeze.c line 208
static double GetBestLengths(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext, unsigned short int *length_array);
// GetBestLengths::costmodel_object
//
double costmodel_object(unsigned int, unsigned int, void *);
// GetCostFixed
// file zopfli/src/zopfli/squeeze.c line 120
static double GetCostFixed(unsigned int litlen, unsigned int dist, void *unused);
// GetCostModelMinCost
// file zopfli/src/zopfli/squeeze.c line 158
static double GetCostModelMinCost(double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext);
// GetCostModelMinCost::costmodel_object
//
double costmodel_object(unsigned int, unsigned int, void *);
// GetCostStat
// file zopfli/src/zopfli/squeeze.c line 141
static double GetCostStat(unsigned int litlen, unsigned int dist, void *context);
// GetDynamicLengths
// file zopfli/src/zopfli/deflate.c line 473
static void GetDynamicLengths(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned int *ll_lengths, unsigned int *d_lengths);
// GetFixedTree
// file zopfli/src/zopfli/deflate.c line 336
static void GetFixedTree(unsigned int *ll_lengths, unsigned int *d_lengths);
// GetFreeNode
// file zopfli/src/zopfli/katajainen.c line 67
static struct Node * GetFreeNode(struct Node *(*lists)[2l], signed int maxbits, struct NodePool *pool);
// GetLengthScore
// file zopfli/src/zopfli/lz77.c line 87
static signed int GetLengthScore(signed int length, signed int distance);
// GetMatch
// file zopfli/src/zopfli/lz77.c line 119
static const unsigned char * GetMatch(const unsigned char *scan, const unsigned char *match, const unsigned char *end, const unsigned char *safe_end);
// GetStatistics
// file zopfli/src/zopfli/squeeze.c line 399
static void GetStatistics(const struct ZopfliLZ77Store *store, struct SymbolStats *stats);
// InitLists
// file zopfli/src/zopfli/katajainen.c line 145
static void InitLists(struct NodePool *pool, const struct Node *leaves, signed int maxbits, struct Node *(*lists)[2l]);
// InitNode
// file zopfli/src/zopfli/katajainen.c line 54
static void InitNode(unsigned long int weight, signed int count, struct Node *tail, struct Node *node);
// InitRanState
// file zopfli/src/zopfli/squeeze.c line 79
static void InitRanState(struct RanState *state);
// InitStats
// file zopfli/src/zopfli/squeeze.c line 42
static void InitStats(struct SymbolStats *stats);
// LZ77OptimalRun
// file zopfli/src/zopfli/squeeze.c line 431
static double LZ77OptimalRun(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned short int **path, unsigned long int *pathsize, unsigned short int *length_array, double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext, struct ZopfliLZ77Store *store);
// LZ77OptimalRun::costmodel_object
//
double costmodel_object(unsigned int, unsigned int, void *);
// LeafComparator
// file zopfli/src/zopfli/katajainen.c line 176
static signed int LeafComparator(const void *a, const void *b);
// OptimizeHuffmanForRle
// file zopfli/src/zopfli/deflate.c line 381
void OptimizeHuffmanForRle(signed int length, unsigned long int *counts);
// PatchDistanceCodesForBuggyDecoders
// file zopfli/src/zopfli/deflate.c line 86
static void PatchDistanceCodesForBuggyDecoders(unsigned int *d_lengths);
// PrintBlockSplitPoints
// file zopfli/src/zopfli/blocksplitter.c line 150
static void PrintBlockSplitPoints(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int llsize, const unsigned long int *lz77splitpoints, unsigned long int nlz77points);
// Ran
// file zopfli/src/zopfli/squeeze.c line 85
static unsigned int Ran(struct RanState *state);
// RandomizeFreqs
// file zopfli/src/zopfli/squeeze.c line 91
static void RandomizeFreqs(struct RanState *state, unsigned long int *freqs, signed int n);
// RandomizeStatFreqs
// file zopfli/src/zopfli/squeeze.c line 98
static void RandomizeStatFreqs(struct RanState *state, struct SymbolStats *stats);
// SplitCost
// file zopfli/src/zopfli/blocksplitter.c line 126
static double SplitCost(unsigned long int i, void *context);
// StoreInLongestMatchCache
// file zopfli/src/zopfli/lz77.c line 206
static void StoreInLongestMatchCache(struct ZopfliBlockState *s, unsigned long int pos, unsigned long int limit, const unsigned short int *sublen, unsigned short int distance, unsigned short int length);
// TraceBackwards
// file zopfli/src/zopfli/squeeze.c line 313
static void TraceBackwards(unsigned long int size, const unsigned short int *length_array, unsigned short int **path, unsigned long int *pathsize);
// TryGetFromLongestMatchCache
// file zopfli/src/zopfli/lz77.c line 162
static signed int TryGetFromLongestMatchCache(struct ZopfliBlockState *s, unsigned long int pos, unsigned long int *limit, unsigned short int *sublen, unsigned short int *distance, unsigned short int *length);
// UpdateHashValue
// file zopfli/src/zopfli/hash.c line 87
static void UpdateHashValue(struct ZopfliHash *h, unsigned char c);
// ZopfliBlockSplit
// file zopfli/src/zopfli/blocksplitter.h line 64
void ZopfliBlockSplit(const struct ZopfliOptions *options, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned long int maxblocks, unsigned long int **splitpoints, unsigned long int *npoints);
// ZopfliBlockSplitLZ77
// file zopfli/src/zopfli/blocksplitter.h line 44
void ZopfliBlockSplitLZ77(const struct ZopfliOptions *options, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int llsize, unsigned long int maxblocks, unsigned long int **splitpoints, unsigned long int *npoints);
// ZopfliBlockSplitSimple
// file zopfli/src/zopfli/blocksplitter.h line 72
void ZopfliBlockSplitSimple(const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned long int blocksize, unsigned long int **splitpoints, unsigned long int *npoints);
// ZopfliCacheToSublen
// file zopfli/src/zopfli/cache.h line 57
void ZopfliCacheToSublen(const struct ZopfliLongestMatchCache *lmc, unsigned long int pos, unsigned long int length, unsigned short int *sublen);
// ZopfliCalculateBitLengths
// file zopfli/src/zopfli/tree.h line 33
void ZopfliCalculateBitLengths(const unsigned long int *count, unsigned long int n, signed int maxbits, unsigned int *bitlengths);
// ZopfliCalculateBlockSize
// file zopfli/src/zopfli/deflate.c line 488
double ZopfliCalculateBlockSize(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, signed int btype);
// ZopfliCalculateEntropy
// file zopfli/src/zopfli/tree.c line 71
void ZopfliCalculateEntropy(const unsigned long int *count, unsigned long int n, double *bitlengths);
// ZopfliCleanCache
// file zopfli/src/zopfli/cache.h line 49
void ZopfliCleanCache(struct ZopfliLongestMatchCache *lmc);
// ZopfliCleanHash
// file zopfli/src/zopfli/hash.h line 53
void ZopfliCleanHash(struct ZopfliHash *h);
// ZopfliCleanLZ77Store
// file zopfli/src/zopfli/lz77.h line 52
void ZopfliCleanLZ77Store(struct ZopfliLZ77Store *store);
// ZopfliCopyLZ77Store
// file zopfli/src/zopfli/lz77.c line 38
void ZopfliCopyLZ77Store(const struct ZopfliLZ77Store *source, struct ZopfliLZ77Store *dest);
// ZopfliDeflate
// file zopfli/src/zopfli/deflate.c line 844
void ZopfliDeflate(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int insize, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// ZopfliDeflatePart
// file zopfli/src/zopfli/deflate.h line 66
void ZopfliDeflatePart(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize);
// ZopfliFindLongestMatch
// file zopfli/src/zopfli/lz77.c line 229
void ZopfliFindLongestMatch(struct ZopfliBlockState *s, const struct ZopfliHash *h, const unsigned char *array, unsigned long int pos, unsigned long int size, unsigned long int limit, unsigned short int *sublen, unsigned short int *distance, unsigned short int *length);
// ZopfliGetDistExtraBits
// file zopfli/src/zopfli/util.h line 135
signed int ZopfliGetDistExtraBits(signed int dist);
// ZopfliGetDistExtraBitsValue
// file zopfli/src/zopfli/util.h line 138
signed int ZopfliGetDistExtraBitsValue(signed int dist);
// ZopfliGetDistSymbol
// file zopfli/src/zopfli/util.h line 132
signed int ZopfliGetDistSymbol(signed int dist);
// ZopfliGetLengthExtraBits
// file zopfli/src/zopfli/util.h line 126
signed int ZopfliGetLengthExtraBits(signed int l);
// ZopfliGetLengthExtraBitsValue
// file zopfli/src/zopfli/util.h line 129
signed int ZopfliGetLengthExtraBitsValue(signed int l);
// ZopfliGetLengthSymbol
// file zopfli/src/zopfli/util.h line 123
signed int ZopfliGetLengthSymbol(signed int l);
// ZopfliInitCache
// file zopfli/src/zopfli/cache.h line 46
void ZopfliInitCache(unsigned long int blocksize, struct ZopfliLongestMatchCache *lmc);
// ZopfliInitHash
// file zopfli/src/zopfli/hash.h line 50
void ZopfliInitHash(unsigned long int window_size, struct ZopfliHash *h);
// ZopfliInitLZ77Store
// file zopfli/src/zopfli/lz77.h line 51
void ZopfliInitLZ77Store(struct ZopfliLZ77Store *store);
// ZopfliInitOptions
// file zopfli/src/zopfli/zopfli.h line 70
void ZopfliInitOptions(struct ZopfliOptions *options);
// ZopfliLZ77Counts
// file zopfli/src/zopfli/lz77.h line 113
void ZopfliLZ77Counts(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int start, unsigned long int end, unsigned long int *ll_count, unsigned long int *d_count);
// ZopfliLZ77Greedy
// file zopfli/src/zopfli/lz77.h line 125
void ZopfliLZ77Greedy(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store);
// ZopfliLZ77Optimal
// file zopfli/src/zopfli/squeeze.h line 41
void ZopfliLZ77Optimal(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store);
// ZopfliLZ77OptimalFixed
// file zopfli/src/zopfli/squeeze.h line 55
void ZopfliLZ77OptimalFixed(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store);
// ZopfliLengthLimitedCodeLengths
// file zopfli/src/zopfli/katajainen.h line 39
signed int ZopfliLengthLimitedCodeLengths(const unsigned long int *frequencies, signed int n, signed int maxbits, unsigned int *bitlengths);
// ZopfliLengthsToSymbols
// file zopfli/src/zopfli/tree.h line 39
void ZopfliLengthsToSymbols(const unsigned int *lengths, unsigned long int n, unsigned int maxbits, unsigned int *symbols);
// ZopfliMaxCachedSublen
// file zopfli/src/zopfli/cache.h line 61
unsigned int ZopfliMaxCachedSublen(const struct ZopfliLongestMatchCache *lmc, unsigned long int pos, unsigned long int length);
// ZopfliStoreLitLenDist
// file zopfli/src/zopfli/lz77.c line 59
void ZopfliStoreLitLenDist(unsigned short int length, unsigned short int dist, struct ZopfliLZ77Store *store);
// ZopfliSublenToCache
// file zopfli/src/zopfli/cache.h line 52
void ZopfliSublenToCache(const unsigned short int *sublen, unsigned long int pos, unsigned long int length, struct ZopfliLongestMatchCache *lmc);
// ZopfliUpdateHash
// file zopfli/src/zopfli/hash.h line 59
void ZopfliUpdateHash(const unsigned char *array, unsigned long int pos, unsigned long int end, struct ZopfliHash *h);
// ZopfliVerifyLenDist
// file zopfli/src/zopfli/lz77.c line 95
void ZopfliVerifyLenDist(const unsigned char *data, unsigned long int datasize, unsigned long int pos, unsigned short int dist, unsigned short int length);
// ZopfliWarmupHash
// file zopfli/src/zopfli/hash.h line 67
void ZopfliWarmupHash(const unsigned char *array, unsigned long int pos, unsigned long int end, struct ZopfliHash *h);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_5 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_5 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_5 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// adler32
// file /usr/include/zlib.h line 1569
extern unsigned long int adler32(unsigned long int, const unsigned char *, unsigned int);
// adler32_comb
// file pigz.c line 1192
static unsigned long int adler32_comb(unsigned long int adler1, unsigned long int adler2, unsigned long int len2);
// alloc
// file pigz.c line 656
static void * alloc(void *ptr, unsigned long int size);
// append_len
// file pigz.c line 1792
static void append_len(struct job *job, unsigned long int len);
// cat
// file pigz.c line 2877
static void cat(void);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// complain
// file pigz.c line 528
static signed int complain(char *fmt, ...);
// compress_thread
// file pigz.c line 1482
static void compress_thread(void *dummy);
// compressed_suffix
// file pigz.c line 2642
static unsigned long int compressed_suffix(char *nm);
// copymeta
// file pigz.c line 3386
static void copymeta(char *from, char *to);
// crc32
// file /usr/include/zlib.h line 1600
extern unsigned long int crc32(unsigned long int, const unsigned char *, unsigned int);
// crc32_comb
// file pigz.c line 1136
static unsigned long int crc32_comb(unsigned long int crc1, unsigned long int crc2, unsigned long int len2);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// cut_short
// file pigz.c line 824
static void cut_short(signed int sig);
// cut_yarn
// file pigz.c line 4049
static void cut_yarn(signed int err);
// defaults
// file pigz.c line 3826
static void defaults(void);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit2_
// file /usr/include/zlib.h line 1637
extern signed int deflateInit2_(struct z_stream_s *, signed int, signed int, signed int, signed int, signed int, const char *, signed int);
// deflateParams
// file /usr/include/zlib.h line 660
extern signed int deflateParams(struct z_stream_s *, signed int, signed int);
// deflatePending
// file /usr/include/zlib.h line 713
extern signed int deflatePending(struct z_stream_s *, unsigned int *, signed int *);
// deflatePrime
// file /usr/include/zlib.h line 728
extern signed int deflatePrime(struct z_stream_s *, signed int, signed int);
// deflateReset
// file /usr/include/zlib.h line 649
extern signed int deflateReset(struct z_stream_s *);
// deflateSetDictionary
// file /usr/include/zlib.h line 587
extern signed int deflateSetDictionary(struct z_stream_s *, const unsigned char *, unsigned int);
// deflate_engine
// file pigz.c line 1459
static void deflate_engine(struct z_stream_s *strm, struct space *out, signed int flush);
// destruct
// file yarn.h line 121
void destruct(struct thread_s *off_course);
// dos2time
// file pigz.c line 2415
static signed long int dos2time(unsigned long int dos);
// drop_space
// file pigz.c line 1315
static void drop_space(struct space *space);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fail
// file yarn.c line 57
static void fail(signed int err);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// finish_jobs
// file pigz.c line 1418
static void finish_jobs(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_lock
// file yarn.h line 134
void free_lock(struct lock_s *bolt);
// free_pool
// file pigz.c line 1337
static signed int free_pool(struct pool *pool);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// get_header
// file pigz.c line 2498
static signed int get_header(signed int save);
// get_space
// file pigz.c line 1256
static struct space * get_space(struct pool *pool);
// getchar
// file /usr/include/stdio.h line 538
extern signed int getchar(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gf2_matrix_square
// file pigz.c line 1128
static void gf2_matrix_square(unsigned long int *square, unsigned long int *mat);
// gf2_matrix_times
// file pigz.c line 1114
static unsigned long int gf2_matrix_times(unsigned long int *mat, unsigned long int vec);
// grow
// file pigz.c line 849
static inline unsigned long int grow(unsigned long int size);
// grow_space
// file pigz.c line 1292
static void grow_space(struct space *space);
// help
// file pigz.c line 3789
static void help(void);
// ignition
// file yarn.c line 245
static void * ignition(void *arg);
// ignition::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// in_init
// file pigz.c line 2360
static void in_init(void);
// inb
// file pigz.c line 2897
static unsigned int inb(void *desc, unsigned char **buf);
// infchk
// file pigz.c line 3040
static void infchk(void);
// inflateBack
// file /usr/include/zlib.h line 1029
extern signed int inflateBack(struct z_stream_s *, unsigned int (*)(void *, unsigned char **), void *, signed int (*)(void *, unsigned char *, unsigned int), void *);
// inflateBackEnd
// file /usr/include/zlib.h line 1099
extern signed int inflateBackEnd(struct z_stream_s *);
// inflateBackInit_
// file /usr/include/zlib.h line 1643
extern signed int inflateBackInit_(struct z_stream_s *, signed int, unsigned char *, const char *, signed int);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// join
// file yarn.h line 119
void join(struct thread_s *ally);
// join_all
// file yarn.h line 120
signed int join_all(void);
// justname
// file pigz.c line 3374
static char * justname(char *path);
// launch
// file yarn.h line 118
struct thread_s * launch(void (*probe)(void *), void *payload);
// launch::probe_object
//
void probe_object(void *);
// list_info
// file pigz.c line 2761
static void list_info(void);
// load
// file pigz.c line 2294
static unsigned long int load(void);
// load_read
// file pigz.c line 2264
static void load_read(void *dummy);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 266
extern signed int lstat(const char *, struct stat *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// my_free_object
//
void my_free_object(void *);
// my_malloc
// file yarn.c line 81
static void * my_malloc(unsigned long int size);
// my_malloc_f_object
//
void * my_malloc_f_object(unsigned long int);
// new_lock
// file yarn.h line 124
struct lock_s * new_lock(signed long int initial);
// new_opts
// file pigz.c line 3873
static void new_opts(void);
// new_pool
// file pigz.c line 1245
static void new_pool(struct pool *pool, unsigned long int size, signed int limit);
// nprocs
// file pigz.c line 3804
static signed int nprocs(signed int n);
// num
// file pigz.c line 3882
static unsigned long int num(char *arg);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// option
// file pigz.c line 3899
static signed int option(char *arg);
// outb
// file pigz.c line 2974
static signed int outb(void *desc, unsigned char *buf, unsigned int len);
// outb_check
// file pigz.c line 2945
static void outb_check(void *dummy);
// outb_write
// file pigz.c line 2919
static void outb_write(void *dummy);
// parallel_compress
// file pigz.c line 1828
static void parallel_compress(void);
// peek_lock
// file yarn.h line 133
signed long int peek_lock(struct lock_s *bolt);
// possess
// file yarn.h line 125
void possess(struct lock_s *bolt);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process
// file pigz.c line 3423
static void process(char *path);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_3 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_3 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_3 *, const union anonymous_7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_3 *, union anonymous_2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_2 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_7 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// put_header
// file pigz.c line 960
static unsigned long int put_header(void);
// put_trailer
// file pigz.c line 1025
static void put_trailer(unsigned long int ulen, unsigned long int clen, unsigned long int check, unsigned long int head);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_extra
// file pigz.c line 2440
static signed int read_extra(unsigned int len, signed int save);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// readn
// file pigz.c line 900
static unsigned long int readn(signed int desc, unsigned char *buf, unsigned long int len);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reenter
// file yarn.c line 210
static void reenter(void *dummy);
// release
// file yarn.h line 126
void release(struct lock_s *bolt);
// setup_jobs
// file pigz.c line 1394
static void setup_jobs(void);
// show_info
// file pigz.c line 2675
static void show_info(signed int method, unsigned long int check, signed long int len, signed int cont);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// single_compress
// file pigz.c line 2022
static void single_compress(signed int reset);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time2dos
// file pigz.c line 935
static unsigned long int time2dos(signed long int t);
// tolong
// file pigz.c line 2432
static signed long int tolong(unsigned long int val);
// touch
// file pigz.c line 3410
static void touch(char *path, signed long int t);
// try_create_
// file try.c line 21
static void try_create_(void);
// try_setup_
// file try.h line 303
void try_setup_(void);
// try_throw_
// file try.h line 421
void try_throw_(signed int code, char *fmt, ...);
// twist
// file yarn.h line 128
void twist(struct lock_s *bolt, enum twist_op op, signed long int val);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unlzw
// file pigz.c line 3183
static void unlzw(void);
// use_space
// file pigz.c line 1308
static void use_space(struct space *space);
// utimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 138
extern signed int utimes(const char *, struct timeval *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vmemcpy
// file pigz.c line 870
static inline unsigned long int vmemcpy(char **mem, unsigned long int *size, unsigned long int off, void *cpy, unsigned long int len);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vstrcpy
// file pigz.c line 894
static inline unsigned long int vstrcpy(char **str, unsigned long int *size, unsigned long int off, void *cpy);
// wait_for
// file yarn.h line 132
void wait_for(struct lock_s *bolt, enum wait_op op, signed long int val);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_thread
// file pigz.c line 1716
static void write_thread(void *dummy);
// writen
// file pigz.c line 920
static void writen(signed int desc, unsigned char *buf, unsigned long int len);
// yarn_abort_object
//
void yarn_abort_object(signed int);
// yarn_mem
// file yarn.c line 74
void yarn_mem(void * (*lease)(unsigned long int), void (*vacate)(void *));
// yarn_mem::lease_object
//
void * lease_object(unsigned long int);
// yarn_mem::vacate_object
//
void vacate_object(void *);

struct ZopfliOptions
{
  // verbose
  signed int verbose;
  // verbose_more
  signed int verbose_more;
  // numiterations
  signed int numiterations;
  // blocksplitting
  signed int blocksplitting;
  // blocksplittinglast
  signed int blocksplittinglast;
  // blocksplittingmax
  signed int blocksplittingmax;
};

struct anonymous_1
{
  // prog
  char *prog;
  // ind
  signed int ind;
  // outd
  signed int outd;
  // inf
  char *inf;
  // inz
  unsigned long int inz;
  // outf
  char *outf;
  // verbosity
  signed int verbosity;
  // headis
  signed int headis;
  // pipeout
  signed int pipeout;
  // keep
  signed int keep;
  // force
  signed int force;
  // form
  signed int form;
  // magic1
  unsigned char magic1;
  // recurse
  signed int recurse;
  // sufx
  char *sufx;
  // name
  char *name;
  // mtime
  signed long int mtime;
  // list
  signed int list;
  // first
  signed int first;
  // decode
  signed int decode;
  // level
  signed int level;
  // zopts
  struct ZopfliOptions zopts;
  // rsync
  signed int rsync;
  // procs
  signed int procs;
  // setdict
  signed int setdict;
  // block
  unsigned long int block;
  // stamp
  signed long int stamp;
  // hname
  char *hname;
  // zip_crc
  unsigned long int zip_crc;
  // zip_clen
  unsigned long int zip_clen;
  // zip_ulen
  unsigned long int zip_ulen;
  // in_buf
  unsigned char in_buf[32768l];
  // in_next
  unsigned char *in_next;
  // in_left
  unsigned long int in_left;
  // in_eof
  signed int in_eof;
  // in_short
  signed int in_short;
  // in_tot
  signed long int in_tot;
  // out_tot
  signed long int out_tot;
  // out_check
  unsigned long int out_check;
  // in_buf2
  unsigned char in_buf2[32768l];
  // in_len
  unsigned long int in_len;
  // in_which
  signed int in_which;
  // load_state
  struct lock_s *load_state;
  // load_thread
  struct thread_s *load_thread;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_4
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_5
{
  // __cancel_jmp_buf
  struct anonymous_4 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_6
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous
{
  // code
  signed int code;
  // free
  signed int free;
  // why
  char *why;
};

union anonymous_7
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_3
{
  // __data
  struct anonymous_6 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct Node
{
  // weight
  unsigned long int weight;
  // tail
  struct Node *tail;
  // count
  signed int count;
  // inuse
  char inuse;
};

struct NodePool
{
  // nodes
  struct Node *nodes;
  // next
  struct Node *next;
  // size
  signed int size;
};

struct RanState
{
  // m_w
  unsigned int m_w;
  // m_z
  unsigned int m_z;
};

struct SplitCostContext
{
  // litlens
  const unsigned short int *litlens;
  // dists
  const unsigned short int *dists;
  // llsize
  unsigned long int llsize;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
};

struct SymbolStats
{
  // litlens
  unsigned long int litlens[288l];
  // dists
  unsigned long int dists[32l];
  // ll_symbols
  double ll_symbols[288l];
  // d_symbols
  double d_symbols[32l];
};

struct ZopfliBlockState
{
  // options
  const struct ZopfliOptions *options;
  // lmc
  struct ZopfliLongestMatchCache *lmc;
  // blockstart
  unsigned long int blockstart;
  // blockend
  unsigned long int blockend;
};

struct ZopfliHash
{
  // head
  signed int *head;
  // prev
  unsigned short int *prev;
  // hashval
  signed int *hashval;
  // val
  signed int val;
  // head2
  signed int *head2;
  // prev2
  unsigned short int *prev2;
  // hashval2
  signed int *hashval2;
  // val2
  signed int val2;
  // same
  unsigned short int *same;
};

struct ZopfliLZ77Store
{
  // litlens
  unsigned short int *litlens;
  // dists
  unsigned short int *dists;
  // size
  unsigned long int size;
};

struct ZopfliLongestMatchCache
{
  // length
  unsigned short int *length;
  // dist
  unsigned short int *dist;
  // sublen
  unsigned char *sublen;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_0 __saved_mask;
};

struct capsule
{
  // probe
  void (*probe)(void *);
  // payload
  void *payload;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct job
{
  // seq
  signed long int seq;
  // more
  signed int more;
  // in
  struct space *in;
  // out
  struct space *out;
  // lens
  struct space *lens;
  // check
  unsigned long int check;
  // calc
  struct lock_s *calc;
  // next
  struct job *next;
};

struct lock_s
{
  // mutex
  union anonymous_2 mutex;
  // cond
  union anonymous_3 cond;
  // value
  signed long int value;
};

struct pool
{
  // have
  struct lock_s *have;
  // head
  struct space *head;
  // size
  unsigned long int size;
  // limit
  signed int limit;
  // made
  signed int made;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct space
{
  // use
  struct lock_s *use;
  // buf
  unsigned char *buf;
  // size
  unsigned long int size;
  // len
  unsigned long int len;
  // pool
  struct pool *pool;
  // next
  struct space *next;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct thread_s
{
  // id
  unsigned long int id;
  // done
  signed int done;
  // next
  struct thread_s *next;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct try_s_
{
  // env
  struct __jmp_buf_tag env[1l];
  // ball
  struct anonymous ball;
  // next
  struct try_s_ *next;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// compress_have
// file pigz.c line 1380
static struct lock_s *compress_have = (struct lock_s *)(void *)0;
// compress_head
// file pigz.c line 1381
static struct job *compress_head;
// compress_tail
// file pigz.c line 1381
static struct job **compress_tail;
// cthreads
// file pigz.c line 1388
static signed int cthreads = 0;
// dict_pool
// file pigz.c line 1360
static struct pool dict_pool;
// g
// file pigz.c line 525
static struct anonymous_1 g;
// helptext
// file pigz.c line 3739
static char *helptext[36l] = { "Usage: pigz [options] [files ...]", "  will compress files in place, adding the suffix '.gz'.  If no files are",
    "  specified, stdin will be compressed to stdout.  pigz does what gzip does,",
    "  but spreads the work over multiple processors and cores when compressing.",
    "", "Options:", "  -0 to -9, -11        Compression level (11 is much slower, a few % better)",
    "  --fast, --best       Compression levels 1 and 9 respectively",
    "  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)",
    "  -c, --stdout         Write all processed output to stdout (won't delete)",
    "  -d, --decompress     Decompress the compressed input",
    "  -f, --force          Force overwrite, compress .gz, links, and to terminal",
    "  -F  --first          Do iterations first, before block split for -11",
    "  -h, --help           Display a help screen and quit",
    "  -i, --independent    Compress blocks independently for damage recovery",
    "  -I, --iterations n   Number of iterations for -11 optimization",
    "  -k, --keep           Do not delete original file after processing",
    "  -K, --zip            Compress to PKWare zip (.zip) single entry format",
    "  -l, --list           List the contents of the compressed input",
    "  -L, --license        Display the pigz license and quit",
    "  -M, --maxsplits n    Maximum number of split blocks for -11",
    "  -n, --no-name        Do not store or restore file name in/from header",
    "  -N, --name           Store/restore file name and mod time in/from header",
    "  -O  --oneblock       Do not split into smaller blocks for -11",
    "  -p, --processes n    Allow up to n compression threads (default is the",
    "                       number of online processors, or 8 if unknown)",
    "  -q, --quiet          Print no messages, even on error",
    "  -r, --recursive      Process the contents of all subdirectories",
    "  -R, --rsyncable      Input-determined block locations for rsync",
    "  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)",
    "  -t, --test           Test the integrity of the compressed input",
    "  -T, --no-time        Do not store or restore mod time in/from header",
    "  -v, --verbose        Provide more verbose output",
    "  -V  --version        Show the version of pigz",
    "  -z, --zlib           Compress to zlib (.zz) instead of gzip format",
    "  --                   All arguments after \"--\" are treated as files" };
// in_pool
// file pigz.c line 1358
static struct pool in_pool;
// lens_pool
// file pigz.c line 1361
static struct pool lens_pool;
// longopts
// file pigz.c line 3858
static char *longopts[34l][2l] = { { "LZW", "Z" }, { "ascii", "a" }, { "best", "9" }, { "bits", "Z" }, { "blocksize", "b" }, { "decompress", "d" }, { "fast", "1" }, { "first", "F" }, { "force", "f" }, { "help", "h" }, { "independent", "i" }, { "iterations", "I" }, { "keep", "k" }, { "license", "L" }, { "list", "l" }, { "maxsplits", "M" }, { "name", "N" }, { "no-name", "n" }, { "no-time", "T" }, { "oneblock", "O" }, { "processes", "p" }, { "quiet", "q" }, { "recursive", "r" }, { "rsyncable", "R" }, { "silent", "q" }, { "stdout", "c" }, { "suffix", "S" }, { "test", "t" }, { "to-stdout", "c" }, { "uncompress", "d" }, { "verbose", "v" }, { "version", "V" }, { "zip", "K" }, { "zlib", "z" } };
// my_free
// file yarn.c line 71
static void (*my_free)(void *);
// my_free
// file yarn.c line 71
static void (*my_free)(void *) = free;
// my_malloc_f
// file yarn.c line 70
static void * (*my_malloc_f)(unsigned long int);
// my_malloc_f
// file yarn.c line 70
static void * (*my_malloc_f)(unsigned long int) = malloc;
// out_buf
// file pigz.c line 2907
static unsigned char out_buf[32768l];
// out_copy
// file pigz.c line 2911
static unsigned char out_copy[32768l];
// out_len
// file pigz.c line 2912
static unsigned long int out_len;
// out_pool
// file pigz.c line 1359
static struct pool out_pool;
// outb_check_more
// file pigz.c line 2916
static struct lock_s *outb_check_more;
// outb_write_more
// file pigz.c line 2915
static struct lock_s *outb_write_more = (struct lock_s *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// threads
// file yarn.c line 201
static struct thread_s *threads = (struct thread_s *)(void *)0;
// threads_lock
// file yarn.c line 196
static struct lock_s threads_lock = { .mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .cond={ .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } },
    .value=(signed long int)0 };
// try_key_
// file try.c line 19
unsigned int try_key_;
// try_once_
// file try.c line 20
static signed int try_once_ = 0;
// write_first
// file pigz.c line 1384
static struct lock_s *write_first;
// write_head
// file pigz.c line 1385
static struct job *write_head;
// writeth
// file pigz.c line 1391
static struct thread_s *writeth = (struct thread_s *)(void *)0;
// yarn_abort
// file yarn.c line 53
void (*yarn_abort)(signed int) = (void (*)(signed int))(void *)0;
// yarn_prefix
// file yarn.c line 52
char *yarn_prefix = "yarn";

// AbsDiff
// file zopfli/src/zopfli/deflate.c line 369
static unsigned long int AbsDiff(unsigned long int x, unsigned long int y)
{
  if(!(y >= x))
    return x - y;

  else
    return y - x;
}

// AddBit
// file zopfli/src/zopfli/deflate.c line 38
static void AddBit(signed int bit, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if((signed int)*bp == 0)
  {
    if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
    {
      if(*outsize == 0ul)
      {
        return_value_malloc_1=malloc(sizeof(unsigned char) /*1ul*/ );
        tmp_if_expr_3 = return_value_malloc_1;
      }

      else
      {
        return_value_realloc_2=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
        tmp_if_expr_3 = return_value_realloc_2;
      }
      *out = (unsigned char *)tmp_if_expr_3;
    }

    (*out)[(signed long int)*outsize] = (unsigned char)0;
    *outsize = *outsize + 1ul;
  }

  (*out)[(signed long int)(*outsize - (unsigned long int)1)] = (*out)[(signed long int)(*outsize - (unsigned long int)1)] | (unsigned char)(bit << (signed int)*bp);
  *bp = (unsigned char)((signed int)*bp + 1 & 7);
}

// AddBits
// file zopfli/src/zopfli/deflate.c line 45
static void AddBits(unsigned int symbol, unsigned int length, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned int i = (unsigned int)0;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  for( ; !(i >= length); i = i + 1u)
  {
    unsigned int bit = symbol >> i & (unsigned int)1;
    if((signed int)*bp == 0)
    {
      if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
      {
        if(*outsize == 0ul)
        {
          return_value_malloc_1=malloc(sizeof(unsigned char) /*1ul*/ );
          tmp_if_expr_3 = return_value_malloc_1;
        }

        else
        {
          return_value_realloc_2=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
          tmp_if_expr_3 = return_value_realloc_2;
        }
        *out = (unsigned char *)tmp_if_expr_3;
      }

      (*out)[(signed long int)*outsize] = (unsigned char)0;
      *outsize = *outsize + 1ul;
    }

    (*out)[(signed long int)(*outsize - (unsigned long int)1)] = (*out)[(signed long int)(*outsize - (unsigned long int)1)] | (unsigned char)(bit << (signed int)*bp);
    *bp = (unsigned char)((signed int)*bp + 1 & 7);
  }
}

// AddDynamicTree
// file zopfli/src/zopfli/deflate.c line 251
static void AddDynamicTree(const unsigned int *ll_lengths, const unsigned int *d_lengths, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  signed int i;
  signed int best = 0;
  unsigned long int bestsize = (unsigned long int)0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    unsigned long int size;
    size=EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, ((unsigned char *)NULL), ((unsigned char **)NULL), ((unsigned long int *)NULL));
    if(bestsize == 0ul || !(size >= bestsize))
    {
      bestsize = size;
      best = i;
    }

  }
  EncodeTree(ll_lengths, d_lengths, best & 1, best & 2, best & 4, bp, out, outsize);
}

// AddHuffmanBits
// file zopfli/src/zopfli/deflate.c line 61
static void AddHuffmanBits(unsigned int symbol, unsigned int length, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned int i = (unsigned int)0;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  for( ; !(i >= length); i = i + 1u)
  {
    unsigned int bit = symbol >> (length - i) - (unsigned int)1 & (unsigned int)1;
    if((signed int)*bp == 0)
    {
      if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
      {
        if(*outsize == 0ul)
        {
          return_value_malloc_1=malloc(sizeof(unsigned char) /*1ul*/ );
          tmp_if_expr_3 = return_value_malloc_1;
        }

        else
        {
          return_value_realloc_2=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
          tmp_if_expr_3 = return_value_realloc_2;
        }
        *out = (unsigned char *)tmp_if_expr_3;
      }

      (*out)[(signed long int)*outsize] = (unsigned char)0;
      *outsize = *outsize + 1ul;
    }

    (*out)[(signed long int)(*outsize - (unsigned long int)1)] = (*out)[(signed long int)(*outsize - (unsigned long int)1)] | (unsigned char)(bit << (signed int)*bp);
    *bp = (unsigned char)((signed int)*bp + 1 & 7);
  }
}

// AddLZ77Block
// file zopfli/src/zopfli/deflate.c line 528
static void AddLZ77Block(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned long int expected_data_size, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned int ll_lengths[288l];
  unsigned int d_lengths[32l];
  unsigned int ll_symbols[288l];
  unsigned int d_symbols[32l];
  unsigned long int detect_block_size = *outsize;
  unsigned long int compressed_size;
  unsigned long int uncompressed_size = (unsigned long int)0;
  unsigned long int i;
  AddBit(final, bp, out, outsize);
  AddBit(btype & 1, bp, out, outsize);
  AddBit((btype & 2) >> 1, bp, out, outsize);
  if(btype == 1)
    GetFixedTree(ll_lengths, d_lengths);

  else
  {
    unsigned int detect_tree_size;
    /* assertion btype == 2 */
    assert(btype == 2);
    GetDynamicLengths(litlens, dists, lstart, lend, ll_lengths, d_lengths);
    detect_tree_size = (unsigned int)*outsize;
    AddDynamicTree(ll_lengths, d_lengths, bp, out, outsize);
    if(!(options->verbose == 0))
      fprintf(stderr, "treesize: %d\n", (signed int)(*outsize - (unsigned long int)detect_tree_size));

  }
  ZopfliLengthsToSymbols(ll_lengths, (unsigned long int)288, (unsigned int)15, ll_symbols);
  ZopfliLengthsToSymbols(d_lengths, (unsigned long int)32, (unsigned int)15, d_symbols);
  detect_block_size = *outsize;
  AddLZ77Data(litlens, dists, lstart, lend, expected_data_size, ll_symbols, ll_lengths, d_symbols, d_lengths, bp, out, outsize);
  AddHuffmanBits(ll_symbols[(signed long int)256], ll_lengths[(signed long int)256], bp, out, outsize);
  i = lstart;
  signed int tmp_if_expr_1;
  for( ; !(i >= lend); i = i + 1ul)
  {
    if((signed int)dists[(signed long int)i] == 0)
      tmp_if_expr_1 = 1;

    else
      tmp_if_expr_1 = (signed int)litlens[(signed long int)i];
    uncompressed_size = uncompressed_size + (unsigned long int)tmp_if_expr_1;
  }
  compressed_size = *outsize - detect_block_size;
  if(!(options->verbose == 0))
    fprintf(stderr, "compressed block size: %d (%dk) (unc: %d)\n", (signed int)compressed_size, (signed int)(compressed_size / (unsigned long int)1024), (signed int)uncompressed_size);

}

// AddLZ77Data
// file zopfli/src/zopfli/deflate.c line 297
static void AddLZ77Data(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned long int expected_data_size, const unsigned int *ll_symbols, const unsigned int *ll_lengths, const unsigned int *d_symbols, const unsigned int *d_lengths, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned long int testlength = (unsigned long int)0;
  unsigned long int i = lstart;
  for( ; !(i >= lend); i = i + 1ul)
  {
    unsigned int dist = (unsigned int)dists[(signed long int)i];
    unsigned int litlen = (unsigned int)litlens[(signed long int)i];
    if(dist == 0u)
    {
      /* assertion litlen < 256 */
      assert(litlen < (unsigned int)256);
      /* assertion ll_lengths[litlen] > 0 */
      assert(ll_lengths[(signed long int)litlen] > (unsigned int)0);
      AddHuffmanBits(ll_symbols[(signed long int)litlen], ll_lengths[(signed long int)litlen], bp, out, outsize);
      testlength = testlength + 1ul;
    }

    else
    {
      unsigned int lls;
      signed int return_value_ZopfliGetLengthSymbol_1;
      return_value_ZopfliGetLengthSymbol_1=ZopfliGetLengthSymbol((signed int)litlen);
      lls = (unsigned int)return_value_ZopfliGetLengthSymbol_1;
      unsigned int ds;
      signed int return_value_ZopfliGetDistSymbol_2;
      return_value_ZopfliGetDistSymbol_2=ZopfliGetDistSymbol((signed int)dist);
      ds = (unsigned int)return_value_ZopfliGetDistSymbol_2;
      /* assertion litlen >= 3 && litlen <= 288 */
      assert(litlen >= (unsigned int)3 && litlen <= (unsigned int)288);
      /* assertion ll_lengths[lls] > 0 */
      assert(ll_lengths[(signed long int)lls] > (unsigned int)0);
      /* assertion d_lengths[ds] > 0 */
      assert(d_lengths[(signed long int)ds] > (unsigned int)0);
      AddHuffmanBits(ll_symbols[(signed long int)lls], ll_lengths[(signed long int)lls], bp, out, outsize);
      signed int return_value_ZopfliGetLengthExtraBitsValue_3;
      return_value_ZopfliGetLengthExtraBitsValue_3=ZopfliGetLengthExtraBitsValue((signed int)litlen);
      signed int return_value_ZopfliGetLengthExtraBits_4;
      return_value_ZopfliGetLengthExtraBits_4=ZopfliGetLengthExtraBits((signed int)litlen);
      AddBits((unsigned int)return_value_ZopfliGetLengthExtraBitsValue_3, (unsigned int)return_value_ZopfliGetLengthExtraBits_4, bp, out, outsize);
      AddHuffmanBits(d_symbols[(signed long int)ds], d_lengths[(signed long int)ds], bp, out, outsize);
      signed int return_value_ZopfliGetDistExtraBitsValue_5;
      return_value_ZopfliGetDistExtraBitsValue_5=ZopfliGetDistExtraBitsValue((signed int)dist);
      signed int return_value_ZopfliGetDistExtraBits_6;
      return_value_ZopfliGetDistExtraBits_6=ZopfliGetDistExtraBits((signed int)dist);
      AddBits((unsigned int)return_value_ZopfliGetDistExtraBitsValue_5, (unsigned int)return_value_ZopfliGetDistExtraBits_6, bp, out, outsize);
      testlength = testlength + (unsigned long int)litlen;
    }
  }
  /* assertion expected_data_size == 0 || testlength == expected_data_size */
  assert(expected_data_size == (unsigned long int)0 || testlength == expected_data_size);
}

// AddSorted
// file zopfli/src/zopfli/blocksplitter.c line 132
static void AddSorted(unsigned long int value, unsigned long int **out, unsigned long int *outsize)
{
  unsigned long int i;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
  {
    if(*outsize == 0ul)
    {
      return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/ );
      tmp_if_expr_3 = return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned long int) /*8ul*/ );
      tmp_if_expr_3 = return_value_realloc_2;
    }
    *out = (unsigned long int *)tmp_if_expr_3;
  }

  (*out)[(signed long int)*outsize] = value;
  *outsize = *outsize + 1ul;
  i = (unsigned long int)0;
  for( ; !(1ul + i >= *outsize); i = i + 1ul)
    if(!(value >= (*out)[(signed long int)i]))
    {
      unsigned long int j = *outsize - (unsigned long int)1;
      for( ; !(i >= j); j = j - 1ul)
        (*out)[(signed long int)j] = (*out)[(signed long int)(j - (unsigned long int)1)];
      (*out)[(signed long int)i] = value;
      break;
    }

}

// AddWeighedStatFreqs
// file zopfli/src/zopfli/squeeze.c line 60
static void AddWeighedStatFreqs(const struct SymbolStats *stats1, double w1, const struct SymbolStats *stats2, double w2, struct SymbolStats *result)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 288ul); i = i + 1ul)
    result->litlens[(signed long int)i] = (unsigned long int)((double)stats1->litlens[(signed long int)i] * w1 + (double)stats2->litlens[(signed long int)i] * w2);
  i = (unsigned long int)0;
  for( ; !(i >= 32ul); i = i + 1ul)
    result->dists[(signed long int)i] = (unsigned long int)((double)stats1->dists[(signed long int)i] * w1 + (double)stats2->dists[(signed long int)i] * w2);
  result->litlens[(signed long int)256] = (unsigned long int)1;
}

// BoundaryPM
// file zopfli/src/zopfli/katajainen.c line 105
static void BoundaryPM(struct Node *(*lists)[2l], signed int maxbits, struct Node *leaves, signed int numsymbols, struct NodePool *pool, signed int index, char final)
{
  struct Node *newchain;
  struct Node *oldchain;
  signed int lastcount = lists[(signed long int)index][(signed long int)1]->count;
  _Bool tmp_if_expr_1;
  if(!(index == 0) || !(lastcount >= numsymbols))
  {
    newchain=GetFreeNode(lists, maxbits, pool);
    oldchain = lists[(signed long int)index][(signed long int)1];
    lists[(signed long int)index][(signed long int)0] = oldchain;
    lists[(signed long int)index][(signed long int)1] = newchain;
    if(index == 0)
      InitNode((leaves + (signed long int)lastcount)->weight, lastcount + 1, ((struct Node *)NULL), newchain);

    else
    {
      unsigned long int sum = lists[(signed long int)(index - 1)][(signed long int)0]->weight + lists[(signed long int)(index - 1)][(signed long int)1]->weight;
      if(!(lastcount >= numsymbols))
        tmp_if_expr_1 = sum > (leaves + (signed long int)lastcount)->weight ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        InitNode((leaves + (signed long int)lastcount)->weight, lastcount + 1, oldchain->tail, newchain);

      else
      {
        InitNode(sum, lastcount, lists[(signed long int)(index - 1)][(signed long int)1], newchain);
        if(final == 0)
        {
          BoundaryPM(lists, maxbits, leaves, numsymbols, pool, index - 1, (char)0);
          BoundaryPM(lists, maxbits, leaves, numsymbols, pool, index - 1, (char)0);
        }

      }
    }
  }

}

// CalculateBlockSymbolSize
// file zopfli/src/zopfli/deflate.c line 348
static unsigned long int CalculateBlockSymbolSize(const unsigned int *ll_lengths, const unsigned int *d_lengths, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend)
{
  unsigned long int result = (unsigned long int)0;
  unsigned long int i = lstart;
  for( ; !(i >= lend); i = i + 1ul)
    if((signed int)dists[(signed long int)i] == 0)
      result = result + (unsigned long int)ll_lengths[(signed long int)litlens[(signed long int)i]];

    else
    {
      signed int return_value_ZopfliGetLengthSymbol_1;
      return_value_ZopfliGetLengthSymbol_1=ZopfliGetLengthSymbol((signed int)litlens[(signed long int)i]);
      result = result + (unsigned long int)ll_lengths[(signed long int)return_value_ZopfliGetLengthSymbol_1];
      signed int return_value_ZopfliGetDistSymbol_2;
      return_value_ZopfliGetDistSymbol_2=ZopfliGetDistSymbol((signed int)dists[(signed long int)i]);
      result = result + (unsigned long int)d_lengths[(signed long int)return_value_ZopfliGetDistSymbol_2];
      signed int return_value_ZopfliGetLengthExtraBits_3;
      return_value_ZopfliGetLengthExtraBits_3=ZopfliGetLengthExtraBits((signed int)litlens[(signed long int)i]);
      result = result + (unsigned long int)return_value_ZopfliGetLengthExtraBits_3;
      signed int return_value_ZopfliGetDistExtraBits_4;
      return_value_ZopfliGetDistExtraBits_4=ZopfliGetDistExtraBits((signed int)dists[(signed long int)i]);
      result = result + (unsigned long int)return_value_ZopfliGetDistExtraBits_4;
    }
  result = result + (unsigned long int)ll_lengths[(signed long int)256];
  return result;
}

// CalculateStatistics
// file zopfli/src/zopfli/squeeze.c line 393
static void CalculateStatistics(struct SymbolStats *stats)
{
  ZopfliCalculateEntropy(stats->litlens, (unsigned long int)288, stats->ll_symbols);
  ZopfliCalculateEntropy(stats->dists, (unsigned long int)32, stats->d_symbols);
}

// CalculateTreeSize
// file zopfli/src/zopfli/deflate.c line 277
static unsigned long int CalculateTreeSize(const unsigned int *ll_lengths, const unsigned int *d_lengths)
{
  unsigned long int result = (unsigned long int)0;
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    unsigned long int size;
    size=EncodeTree(ll_lengths, d_lengths, i & 1, i & 2, i & 4, ((unsigned char *)NULL), ((unsigned char **)NULL), ((unsigned long int *)NULL));
    if(result == 0ul || !(size >= result))
      result = size;

  }
  return result;
}

// ClearStatFreqs
// file zopfli/src/zopfli/squeeze.c line 104
static void ClearStatFreqs(struct SymbolStats *stats)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 288ul); i = i + 1ul)
    stats->litlens[(signed long int)i] = (unsigned long int)0;
  i = (unsigned long int)0;
  for( ; !(i >= 32ul); i = i + 1ul)
    stats->dists[(signed long int)i] = (unsigned long int)0;
}

// CopyStats
// file zopfli/src/zopfli/squeeze.c line 50
static void CopyStats(struct SymbolStats *source, struct SymbolStats *dest)
{
  memcpy((void *)dest->litlens, (const void *)source->litlens, (unsigned long int)288 * sizeof(unsigned long int) /*8ul*/ );
  memcpy((void *)dest->dists, (const void *)source->dists, (unsigned long int)32 * sizeof(unsigned long int) /*8ul*/ );
  memcpy((void *)dest->ll_symbols, (const void *)source->ll_symbols, (unsigned long int)288 * sizeof(double) /*8ul*/ );
  memcpy((void *)dest->d_symbols, (const void *)source->d_symbols, (unsigned long int)32 * sizeof(double) /*8ul*/ );
}

// DeflateBlock
// file zopfli/src/zopfli/deflate.c line 700
static void DeflateBlock(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  if(btype == 0)
    DeflateNonCompressedBlock(options, final, in, instart, inend, bp, out, outsize);

  else
    if(btype == 1)
      DeflateFixedBlock(options, final, in, instart, inend, bp, out, outsize);

    else
    {
      /* assertion btype == 2 */
      assert(btype == 2);
      DeflateDynamicBlock(options, final, in, instart, inend, bp, out, outsize);
    }
}

// DeflateDynamicBlock
// file zopfli/src/zopfli/deflate.c line 586
static void DeflateDynamicBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  struct ZopfliBlockState s;
  unsigned long int blocksize = inend - instart;
  struct ZopfliLZ77Store store;
  signed int btype = 2;
  ZopfliInitLZ77Store(&store);
  s.options = options;
  s.blockstart = instart;
  s.blockend = inend;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ZopfliLongestMatchCache) /*24ul*/ );
  s.lmc = (struct ZopfliLongestMatchCache *)return_value_malloc_1;
  ZopfliInitCache(blocksize, s.lmc);
  ZopfliLZ77Optimal(&s, in, instart, inend, &store);
  if(!(store.size >= 1000ul))
  {
    double dyncost;
    double fixedcost;
    struct ZopfliLZ77Store fixedstore;
    ZopfliInitLZ77Store(&fixedstore);
    ZopfliLZ77OptimalFixed(&s, in, instart, inend, &fixedstore);
    dyncost=ZopfliCalculateBlockSize(store.litlens, store.dists, (unsigned long int)0, store.size, 2);
    fixedcost=ZopfliCalculateBlockSize(fixedstore.litlens, fixedstore.dists, (unsigned long int)0, fixedstore.size, 1);
    if(fixedcost < dyncost)
    {
      btype = 1;
      ZopfliCleanLZ77Store(&store);
      store = fixedstore;
    }

    else
      ZopfliCleanLZ77Store(&fixedstore);
  }

  AddLZ77Block(s.options, btype, final, store.litlens, store.dists, (unsigned long int)0, store.size, blocksize, bp, out, outsize);
  ZopfliCleanCache(s.lmc);
  free((void *)s.lmc);
  ZopfliCleanLZ77Store(&store);
}

// DeflateFixedBlock
// file zopfli/src/zopfli/deflate.c line 639
static void DeflateFixedBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  struct ZopfliBlockState s;
  unsigned long int blocksize = inend - instart;
  struct ZopfliLZ77Store store;
  ZopfliInitLZ77Store(&store);
  s.options = options;
  s.blockstart = instart;
  s.blockend = inend;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ZopfliLongestMatchCache) /*24ul*/ );
  s.lmc = (struct ZopfliLongestMatchCache *)return_value_malloc_1;
  ZopfliInitCache(blocksize, s.lmc);
  ZopfliLZ77OptimalFixed(&s, in, instart, inend, &store);
  AddLZ77Block(s.options, 1, final, store.litlens, store.dists, (unsigned long int)0, store.size, blocksize, bp, out, outsize);
  ZopfliCleanCache(s.lmc);
  free((void *)s.lmc);
  ZopfliCleanLZ77Store(&store);
}

// DeflateNonCompressedBlock
// file zopfli/src/zopfli/deflate.c line 670
static void DeflateNonCompressedBlock(const struct ZopfliOptions *options, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned long int i;
  unsigned long int blocksize = inend - instart;
  unsigned short int nlen = (unsigned short int)~blocksize;
  (void)options;
  /* assertion blocksize < 65536 */
  assert(blocksize < (unsigned long int)65536);
  AddBit(final, bp, out, outsize);
  AddBit(0, bp, out, outsize);
  AddBit(0, bp, out, outsize);
  *bp = (unsigned char)0;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
  {
    if(*outsize == 0ul)
    {
      return_value_malloc_1=malloc(sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_3 = return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_3 = return_value_realloc_2;
    }
    *out = (unsigned char *)tmp_if_expr_3;
  }

  (*out)[(signed long int)*outsize] = (unsigned char)(blocksize % (unsigned long int)256);
  *outsize = *outsize + 1ul;
  void *tmp_if_expr_6;
  void *return_value_malloc_4;
  void *return_value_realloc_5;
  if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
  {
    if(*outsize == 0ul)
    {
      return_value_malloc_4=malloc(sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_6 = return_value_malloc_4;
    }

    else
    {
      return_value_realloc_5=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_6 = return_value_realloc_5;
    }
    *out = (unsigned char *)tmp_if_expr_6;
  }

  (*out)[(signed long int)*outsize] = (unsigned char)((blocksize / (unsigned long int)256) % (unsigned long int)256);
  *outsize = *outsize + 1ul;
  void *tmp_if_expr_9;
  void *return_value_malloc_7;
  void *return_value_realloc_8;
  if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
  {
    if(*outsize == 0ul)
    {
      return_value_malloc_7=malloc(sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_9 = return_value_malloc_7;
    }

    else
    {
      return_value_realloc_8=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_9 = return_value_realloc_8;
    }
    *out = (unsigned char *)tmp_if_expr_9;
  }

  (*out)[(signed long int)*outsize] = (unsigned char)((signed int)nlen % 256);
  *outsize = *outsize + 1ul;
  void *tmp_if_expr_12;
  void *return_value_malloc_10;
  void *return_value_realloc_11;
  if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
  {
    if(*outsize == 0ul)
    {
      return_value_malloc_10=malloc(sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_12 = return_value_malloc_10;
    }

    else
    {
      return_value_realloc_11=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
      tmp_if_expr_12 = return_value_realloc_11;
    }
    *out = (unsigned char *)tmp_if_expr_12;
  }

  (*out)[(signed long int)*outsize] = (unsigned char)(((signed int)nlen / 256) % 256);
  *outsize = *outsize + 1ul;
  i = instart;
  void *tmp_if_expr_15;
  void *return_value_malloc_13;
  void *return_value_realloc_14;
  for( ; !(i >= inend); i = i + 1ul)
  {
    if((*outsize + 18446744073709551615ul & *outsize) == 0ul)
    {
      if(*outsize == 0ul)
      {
        return_value_malloc_13=malloc(sizeof(unsigned char) /*1ul*/ );
        tmp_if_expr_15 = return_value_malloc_13;
      }

      else
      {
        return_value_realloc_14=realloc((void *)*out, *outsize * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
        tmp_if_expr_15 = return_value_realloc_14;
      }
      *out = (unsigned char *)tmp_if_expr_15;
    }

    (*out)[(signed long int)*outsize] = in[(signed long int)i];
    *outsize = *outsize + 1ul;
  }
}

// DeflateSplittingFirst
// file zopfli/src/zopfli/deflate.c line 721
static void DeflateSplittingFirst(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned long int i;
  unsigned long int *splitpoints = ((unsigned long int *)NULL);
  unsigned long int npoints = (unsigned long int)0;
  if(btype == 0)
    ZopfliBlockSplitSimple(in, instart, inend, (unsigned long int)65535, &splitpoints, &npoints);

  else
    if(!(btype == 1))
      ZopfliBlockSplit(options, in, instart, inend, (unsigned long int)options->blocksplittingmax, &splitpoints, &npoints);

  i = (unsigned long int)0;
  unsigned long int tmp_if_expr_1;
  unsigned long int tmp_if_expr_2;
  for( ; npoints >= i; i = i + 1ul)
  {
    unsigned long int start;
    if(i == 0ul)
      tmp_if_expr_1 = instart;

    else
      tmp_if_expr_1 = splitpoints[(signed long int)(i - (unsigned long int)1)];
    start = tmp_if_expr_1;
    unsigned long int end;
    if(i == npoints)
      tmp_if_expr_2 = inend;

    else
      tmp_if_expr_2 = splitpoints[(signed long int)i];
    end = tmp_if_expr_2;
    DeflateBlock(options, btype, (signed int)(i == npoints && final != 0), in, start, end, bp, out, outsize);
  }
  free((void *)splitpoints);
}

// DeflateSplittingLast
// file zopfli/src/zopfli/deflate.c line 755
static void DeflateSplittingLast(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned long int i;
  struct ZopfliBlockState s;
  struct ZopfliLZ77Store store;
  unsigned long int *splitpoints = ((unsigned long int *)NULL);
  unsigned long int npoints = (unsigned long int)0;
  if(btype == 0)
    DeflateSplittingFirst(options, btype, final, in, instart, inend, bp, out, outsize);

  /* assertion btype == 1 || btype == 2 */
  assert(btype == 1 || btype == 2);
  ZopfliInitLZ77Store(&store);
  s.options = options;
  s.blockstart = instart;
  s.blockend = inend;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ZopfliLongestMatchCache) /*24ul*/ );
  s.lmc = (struct ZopfliLongestMatchCache *)return_value_malloc_1;
  ZopfliInitCache(inend - instart, s.lmc);
  if(btype == 2)
    ZopfliLZ77Optimal(&s, in, instart, inend, &store);

  else
  {
    /* assertion btype == 1 */
    assert(btype == 1);
    ZopfliLZ77OptimalFixed(&s, in, instart, inend, &store);
  }
  if(!(btype == 1))
    ZopfliBlockSplitLZ77(options, store.litlens, store.dists, store.size, (unsigned long int)options->blocksplittingmax, &splitpoints, &npoints);

  i = (unsigned long int)0;
  unsigned long int tmp_if_expr_2;
  unsigned long int tmp_if_expr_3;
  for( ; npoints >= i; i = i + 1ul)
  {
    unsigned long int start;
    if(i == 0ul)
      tmp_if_expr_2 = (unsigned long int)0;

    else
      tmp_if_expr_2 = splitpoints[(signed long int)(i - (unsigned long int)1)];
    start = tmp_if_expr_2;
    unsigned long int end;
    if(i == npoints)
      tmp_if_expr_3 = store.size;

    else
      tmp_if_expr_3 = splitpoints[(signed long int)i];
    end = tmp_if_expr_3;
    AddLZ77Block(options, btype, (signed int)(i == npoints && final != 0), store.litlens, store.dists, start, end, (unsigned long int)0, bp, out, outsize);
  }
  ZopfliCleanCache(s.lmc);
  free((void *)s.lmc);
  ZopfliCleanLZ77Store(&store);
  free((void *)splitpoints);
}

// EncodeTree
// file zopfli/src/zopfli/deflate.c line 105
static unsigned long int EncodeTree(const unsigned int *ll_lengths, const unsigned int *d_lengths, signed int use_16, signed int use_17, signed int use_18, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned int lld_total;
  unsigned int *rle = ((unsigned int *)NULL);
  unsigned int *rle_bits = ((unsigned int *)NULL);
  unsigned long int rle_size = (unsigned long int)0;
  unsigned long int rle_bits_size = (unsigned long int)0;
  unsigned int hlit = (unsigned int)29;
  unsigned int hdist = (unsigned int)29;
  unsigned int hclen;
  unsigned int hlit2;
  unsigned long int i;
  unsigned long int j;
  unsigned long int clcounts[19l];
  unsigned int clcl[19l];
  unsigned int clsymbols[19l];
  signed int size_only = (signed int)!(out != ((unsigned char **)NULL));
  unsigned long int result_size = (unsigned long int)0;
  i = (unsigned long int)0;
  for( ; !(i >= 19ul); i = i + 1ul)
    clcounts[(signed long int)i] = (unsigned long int)0;
  for( ; hlit >= 1u; hlit = hlit - 1u)
    if(!(ll_lengths[(signed long int)(257u + hlit + 4294967295u)] == 0u))
      break;

  for( ; hdist >= 1u; hdist = hdist - 1u)
    if(!(d_lengths[(signed long int)(1u + hdist + 4294967295u)] == 0u))
      break;

  hlit2 = hlit + (unsigned int)257;
  lld_total = hlit2 + hdist + (unsigned int)1;
  i = (unsigned long int)0;
  unsigned int tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  unsigned int tmp_if_expr_2;
  void *tmp_if_expr_6;
  void *return_value_malloc_4;
  void *return_value_realloc_5;
  void *tmp_if_expr_9;
  void *return_value_malloc_7;
  void *return_value_realloc_8;
  void *tmp_if_expr_12;
  void *return_value_malloc_10;
  void *return_value_realloc_11;
  void *tmp_if_expr_15;
  void *return_value_malloc_13;
  void *return_value_realloc_14;
  void *tmp_if_expr_18;
  void *return_value_malloc_16;
  void *return_value_realloc_17;
  void *tmp_if_expr_21;
  void *return_value_malloc_19;
  void *return_value_realloc_20;
  void *tmp_if_expr_24;
  void *return_value_malloc_22;
  void *return_value_realloc_23;
  void *tmp_if_expr_27;
  void *return_value_malloc_25;
  void *return_value_realloc_26;
  void *tmp_if_expr_30;
  void *return_value_malloc_28;
  void *return_value_realloc_29;
  void *tmp_if_expr_33;
  void *return_value_malloc_31;
  void *return_value_realloc_32;
  for( ; !(i >= (unsigned long int)lld_total); i = i + 1ul)
  {
    unsigned char symbol;
    if(!(i >= (unsigned long int)hlit2))
      tmp_if_expr_1 = ll_lengths[(signed long int)i];

    else
      tmp_if_expr_1 = d_lengths[(signed long int)(i - (unsigned long int)hlit2)];
    symbol = (unsigned char)tmp_if_expr_1;
    unsigned int count = (unsigned int)1;
    if((signed int)symbol == 0 && (!(use_17 == 0) || !(use_18 == 0)) || !(use_16 == 0))
    {
      j = i + (unsigned long int)1;
      do
      {
        if(!(j >= (unsigned long int)lld_total))
        {
          if(!(j >= (unsigned long int)hlit2))
            tmp_if_expr_2 = ll_lengths[(signed long int)j];

          else
            tmp_if_expr_2 = d_lengths[(signed long int)(j - (unsigned long int)hlit2)];
          tmp_if_expr_3 = (unsigned int)symbol == tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        count = count + 1u;
        j = j + 1ul;
      }
      while((_Bool)1);
    }

    i = i + (unsigned long int)(count - (unsigned int)1);
    if((signed int)symbol == 0 && count >= 3u)
    {
      if(!(use_18 == 0))
        while(count >= 11u)
        {
          unsigned int count2 = count > (unsigned int)138 ? (unsigned int)138 : count;
          if(size_only == 0)
          {
            if((rle_size + 18446744073709551615ul & rle_size) == 0ul)
            {
              if(rle_size == 0ul)
              {
                return_value_malloc_4=malloc(sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_6 = return_value_malloc_4;
              }

              else
              {
                return_value_realloc_5=realloc((void *)*(&rle), *(&rle_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_6 = return_value_realloc_5;
              }
              *(&rle) = (unsigned int *)tmp_if_expr_6;
            }

            (*(&rle))[(signed long int)*(&rle_size)] = (unsigned int)18;
            *(&rle_size) = *(&rle_size) + 1ul;
            if((rle_bits_size + 18446744073709551615ul & rle_bits_size) == 0ul)
            {
              if(rle_bits_size == 0ul)
              {
                return_value_malloc_7=malloc(sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_9 = return_value_malloc_7;
              }

              else
              {
                return_value_realloc_8=realloc((void *)*(&rle_bits), *(&rle_bits_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_9 = return_value_realloc_8;
              }
              *(&rle_bits) = (unsigned int *)tmp_if_expr_9;
            }

            (*(&rle_bits))[(signed long int)*(&rle_bits_size)] = count2 - (unsigned int)11;
            *(&rle_bits_size) = *(&rle_bits_size) + 1ul;
          }

          clcounts[(signed long int)18] = clcounts[(signed long int)18] + 1ul;
          count = count - count2;
        }

      if(!(use_17 == 0))
        while(count >= 3u)
        {
          unsigned int EncodeTree__1__2__1__2__2__1__count2 = count > (unsigned int)10 ? (unsigned int)10 : count;
          if(size_only == 0)
          {
            if((rle_size + 18446744073709551615ul & rle_size) == 0ul)
            {
              if(rle_size == 0ul)
              {
                return_value_malloc_10=malloc(sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_12 = return_value_malloc_10;
              }

              else
              {
                return_value_realloc_11=realloc((void *)*(&rle), *(&rle_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_12 = return_value_realloc_11;
              }
              *(&rle) = (unsigned int *)tmp_if_expr_12;
            }

            (*(&rle))[(signed long int)*(&rle_size)] = (unsigned int)17;
            *(&rle_size) = *(&rle_size) + 1ul;
            if((rle_bits_size + 18446744073709551615ul & rle_bits_size) == 0ul)
            {
              if(rle_bits_size == 0ul)
              {
                return_value_malloc_13=malloc(sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_15 = return_value_malloc_13;
              }

              else
              {
                return_value_realloc_14=realloc((void *)*(&rle_bits), *(&rle_bits_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
                tmp_if_expr_15 = return_value_realloc_14;
              }
              *(&rle_bits) = (unsigned int *)tmp_if_expr_15;
            }

            (*(&rle_bits))[(signed long int)*(&rle_bits_size)] = EncodeTree__1__2__1__2__2__1__count2 - (unsigned int)3;
            *(&rle_bits_size) = *(&rle_bits_size) + 1ul;
          }

          clcounts[(signed long int)17] = clcounts[(signed long int)17] + 1ul;
          count = count - EncodeTree__1__2__1__2__2__1__count2;
        }

    }

    if(count >= 4u && !(use_16 == 0))
    {
      count = count - 1u;
      clcounts[(signed long int)symbol] = clcounts[(signed long int)symbol] + 1ul;
      if(size_only == 0)
      {
        if((rle_size + 18446744073709551615ul & rle_size) == 0ul)
        {
          if(rle_size == 0ul)
          {
            return_value_malloc_16=malloc(sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_18 = return_value_malloc_16;
          }

          else
          {
            return_value_realloc_17=realloc((void *)*(&rle), *(&rle_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_18 = return_value_realloc_17;
          }
          *(&rle) = (unsigned int *)tmp_if_expr_18;
        }

        (*(&rle))[(signed long int)*(&rle_size)] = (unsigned int)symbol;
        *(&rle_size) = *(&rle_size) + 1ul;
        if((rle_bits_size + 18446744073709551615ul & rle_bits_size) == 0ul)
        {
          if(rle_bits_size == 0ul)
          {
            return_value_malloc_19=malloc(sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_21 = return_value_malloc_19;
          }

          else
          {
            return_value_realloc_20=realloc((void *)*(&rle_bits), *(&rle_bits_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_21 = return_value_realloc_20;
          }
          *(&rle_bits) = (unsigned int *)tmp_if_expr_21;
        }

        (*(&rle_bits))[(signed long int)*(&rle_bits_size)] = (unsigned int)0;
        *(&rle_bits_size) = *(&rle_bits_size) + 1ul;
      }

      while(count >= 3u)
      {
        unsigned int EncodeTree__1__2__1__3__2__count2 = count > (unsigned int)6 ? (unsigned int)6 : count;
        if(size_only == 0)
        {
          if((rle_size + 18446744073709551615ul & rle_size) == 0ul)
          {
            if(rle_size == 0ul)
            {
              return_value_malloc_22=malloc(sizeof(unsigned int) /*4ul*/ );
              tmp_if_expr_24 = return_value_malloc_22;
            }

            else
            {
              return_value_realloc_23=realloc((void *)*(&rle), *(&rle_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
              tmp_if_expr_24 = return_value_realloc_23;
            }
            *(&rle) = (unsigned int *)tmp_if_expr_24;
          }

          (*(&rle))[(signed long int)*(&rle_size)] = (unsigned int)16;
          *(&rle_size) = *(&rle_size) + 1ul;
          if((rle_bits_size + 18446744073709551615ul & rle_bits_size) == 0ul)
          {
            if(rle_bits_size == 0ul)
            {
              return_value_malloc_25=malloc(sizeof(unsigned int) /*4ul*/ );
              tmp_if_expr_27 = return_value_malloc_25;
            }

            else
            {
              return_value_realloc_26=realloc((void *)*(&rle_bits), *(&rle_bits_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
              tmp_if_expr_27 = return_value_realloc_26;
            }
            *(&rle_bits) = (unsigned int *)tmp_if_expr_27;
          }

          (*(&rle_bits))[(signed long int)*(&rle_bits_size)] = EncodeTree__1__2__1__3__2__count2 - (unsigned int)3;
          *(&rle_bits_size) = *(&rle_bits_size) + 1ul;
        }

        clcounts[(signed long int)16] = clcounts[(signed long int)16] + 1ul;
        count = count - EncodeTree__1__2__1__3__2__count2;
      }
    }

    clcounts[(signed long int)symbol] = clcounts[(signed long int)symbol] + (unsigned long int)count;
    for( ; count >= 1u; count = count - 1u)
      if(size_only == 0)
      {
        if((rle_size + 18446744073709551615ul & rle_size) == 0ul)
        {
          if(rle_size == 0ul)
          {
            return_value_malloc_28=malloc(sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_30 = return_value_malloc_28;
          }

          else
          {
            return_value_realloc_29=realloc((void *)*(&rle), *(&rle_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_30 = return_value_realloc_29;
          }
          *(&rle) = (unsigned int *)tmp_if_expr_30;
        }

        (*(&rle))[(signed long int)*(&rle_size)] = (unsigned int)symbol;
        *(&rle_size) = *(&rle_size) + 1ul;
        if((rle_bits_size + 18446744073709551615ul & rle_bits_size) == 0ul)
        {
          if(rle_bits_size == 0ul)
          {
            return_value_malloc_31=malloc(sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_33 = return_value_malloc_31;
          }

          else
          {
            return_value_realloc_32=realloc((void *)*(&rle_bits), *(&rle_bits_size) * (unsigned long int)2 * sizeof(unsigned int) /*4ul*/ );
            tmp_if_expr_33 = return_value_realloc_32;
          }
          *(&rle_bits) = (unsigned int *)tmp_if_expr_33;
        }

        (*(&rle_bits))[(signed long int)*(&rle_bits_size)] = (unsigned int)0;
        *(&rle_bits_size) = *(&rle_bits_size) + 1ul;
      }

  }
  ZopfliCalculateBitLengths(clcounts, (unsigned long int)19, 7, clcl);
  if(size_only == 0)
    ZopfliLengthsToSymbols(clcl, (unsigned long int)19, (unsigned int)7, clsymbols);

  hclen = (unsigned int)15;
  static const unsigned int order[19l] = { (const unsigned int)16, (const unsigned int)17, (const unsigned int)18, (const unsigned int)0, (const unsigned int)8, (const unsigned int)7, (const unsigned int)9, (const unsigned int)6, (const unsigned int)10, (const unsigned int)5, (const unsigned int)11, (const unsigned int)4, (const unsigned int)12, (const unsigned int)3, (const unsigned int)13, (const unsigned int)2, (const unsigned int)14, (const unsigned int)1, (const unsigned int)15 };
  for( ; hclen >= 1u; hclen = hclen - 1u)
    if(!(clcounts[(signed long int)order[(signed long int)(4u + hclen + 4294967295u)]] == 0ul))
      break;

  if(size_only == 0)
  {
    AddBits(hlit, (unsigned int)5, bp, out, outsize);
    AddBits(hdist, (unsigned int)5, bp, out, outsize);
    AddBits(hclen, (unsigned int)4, bp, out, outsize);
    i = (unsigned long int)0;
    for( ; !(i >= (unsigned long int)(4u + hclen)); i = i + 1ul)
      AddBits(clcl[(signed long int)order[(signed long int)i]], (unsigned int)3, bp, out, outsize);
    i = (unsigned long int)0;
    for( ; !(i >= rle_size); i = i + 1ul)
    {
      unsigned int EncodeTree__1__3__2__1__symbol = clsymbols[(signed long int)rle[(signed long int)i]];
      AddHuffmanBits(EncodeTree__1__3__2__1__symbol, clcl[(signed long int)rle[(signed long int)i]], bp, out, outsize);
      if(rle[(signed long int)i] == 16u)
        AddBits(rle_bits[(signed long int)i], (unsigned int)2, bp, out, outsize);

      else
        if(rle[(signed long int)i] == 17u)
          AddBits(rle_bits[(signed long int)i], (unsigned int)3, bp, out, outsize);

        else
          if(rle[(signed long int)i] == 18u)
            AddBits(rle_bits[(signed long int)i], (unsigned int)7, bp, out, outsize);

    }
  }

  result_size = result_size + (unsigned long int)14;
  result_size = result_size + (unsigned long int)((hclen + (unsigned int)4) * (unsigned int)3);
  i = (unsigned long int)0;
  for( ; !(i >= 19ul); i = i + 1ul)
    result_size = result_size + (unsigned long int)clcl[(signed long int)i] * clcounts[(signed long int)i];
  result_size = result_size + clcounts[(signed long int)16] * (unsigned long int)2;
  result_size = result_size + clcounts[(signed long int)17] * (unsigned long int)3;
  result_size = result_size + clcounts[(signed long int)18] * (unsigned long int)7;
  free((void *)rle);
  free((void *)rle_bits);
  return result_size;
}

// EstimateCost
// file zopfli/src/zopfli/blocksplitter.c line 106
static double EstimateCost(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend)
{
  double return_value_ZopfliCalculateBlockSize_1;
  return_value_ZopfliCalculateBlockSize_1=ZopfliCalculateBlockSize(litlens, dists, lstart, lend, 2);
  return return_value_ZopfliCalculateBlockSize_1;
}

// ExtractBitLengths
// file zopfli/src/zopfli/katajainen.c line 163
static void ExtractBitLengths(struct Node *chain, struct Node *leaves, unsigned int *bitlengths)
{
  struct Node *node = chain;
  for( ; !(node == ((struct Node *)NULL)); node = node->tail)
  {
    signed int i = 0;
    for( ; !(i >= node->count); i = i + 1)
      bitlengths[(signed long int)(leaves + (signed long int)i)->count] = bitlengths[(signed long int)(leaves + (signed long int)i)->count] + 1u;
  }
}

// FindLargestSplittableBlock
// file zopfli/src/zopfli/blocksplitter.c line 198
static signed int FindLargestSplittableBlock(unsigned long int llsize, const unsigned char *done, const unsigned long int *splitpoints, unsigned long int npoints, unsigned long int *lstart, unsigned long int *lend)
{
  unsigned long int longest = (unsigned long int)0;
  signed int found = 0;
  unsigned long int i = (unsigned long int)0;
  unsigned long int tmp_if_expr_1;
  unsigned long int tmp_if_expr_2;
  for( ; npoints >= i; i = i + 1ul)
  {
    unsigned long int start;
    if(i == 0ul)
      tmp_if_expr_1 = (unsigned long int)0;

    else
      tmp_if_expr_1 = splitpoints[(signed long int)(i - (unsigned long int)1)];
    start = tmp_if_expr_1;
    unsigned long int end;
    if(i == npoints)
      tmp_if_expr_2 = llsize - (unsigned long int)1;

    else
      tmp_if_expr_2 = splitpoints[(signed long int)i];
    end = tmp_if_expr_2;
    if(done[(signed long int)start] == 0)
    {
      if(!(longest >= end + -start))
      {
        *lstart = start;
        *lend = end;
        found = 1;
        longest = end - start;
      }

    }

  }
  return found;
}

// FindMinimum
// file zopfli/src/zopfli/blocksplitter.c line 43
static unsigned long int FindMinimum(double (*f)(unsigned long int, void *), void *context, unsigned long int start, unsigned long int end)
{
  unsigned long int tmp_if_expr_1;
  unsigned long int tmp_if_expr_2;
  if(!(end + -start >= 1024ul))
  {
    double best = 1e30;
    unsigned long int result = start;
    unsigned long int i = start;
    if(!(i >= end))
    {
      double v;
      v=f(i, context);
      if(v < best)
      {
        best = v;
        result = i;
      }

      i = i + 1ul;
    }

    return result;
  }

  else
  {
    unsigned long int FindMinimum__1__2__i;
    unsigned long int p[9l];
    double vp[9l];
    unsigned long int besti;
    double FindMinimum__1__2__best;
    double lastbest = 1e30;
    unsigned long int pos = start;
    for( ; end + -start >= 10ul; lastbest = FindMinimum__1__2__best)
    {
      FindMinimum__1__2__i = (unsigned long int)0;
      if(!(FindMinimum__1__2__i >= 9ul))
      {
        p[(signed long int)FindMinimum__1__2__i] = start + (FindMinimum__1__2__i + (unsigned long int)1) * ((end - start) / (unsigned long int)(9 + 1));
        vp[(signed long int)FindMinimum__1__2__i]=f(p[(signed long int)FindMinimum__1__2__i], context);
        FindMinimum__1__2__i = FindMinimum__1__2__i + 1ul;
      }

      besti = (unsigned long int)0;
      FindMinimum__1__2__best = vp[(signed long int)0];
      FindMinimum__1__2__i = (unsigned long int)1;
      for( ; !(FindMinimum__1__2__i >= 9ul); FindMinimum__1__2__i = FindMinimum__1__2__i + 1ul)
        if(vp[(signed long int)FindMinimum__1__2__i] < FindMinimum__1__2__best)
        {
          FindMinimum__1__2__best = vp[(signed long int)FindMinimum__1__2__i];
          besti = FindMinimum__1__2__i;
        }

      if(FindMinimum__1__2__best > lastbest)
        break;

      if(besti == 0ul)
        tmp_if_expr_1 = start;

      else
        tmp_if_expr_1 = p[(signed long int)(besti - (unsigned long int)1)];
      start = tmp_if_expr_1;
      if(besti == 8ul)
        tmp_if_expr_2 = end;

      else
        tmp_if_expr_2 = p[(signed long int)(besti + (unsigned long int)1)];
      end = tmp_if_expr_2;
      pos = p[(signed long int)besti];
    }
    return pos;
  }
}

// FollowPath
// file zopfli/src/zopfli/squeeze.c line 334
static void FollowPath(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned short int *path, unsigned long int pathsize, struct ZopfliLZ77Store *store)
{
  unsigned long int i;
  unsigned long int j;
  unsigned long int pos = (unsigned long int)0;
  unsigned long int windowstart = instart > (unsigned long int)32768 ? instart - (unsigned long int)32768 : (unsigned long int)0;
  unsigned long int total_length_test = (unsigned long int)0;
  struct ZopfliHash hash;
  struct ZopfliHash *h = &hash;
  if(!(instart == inend))
  {
    ZopfliInitHash((unsigned long int)32768, h);
    ZopfliWarmupHash(in, windowstart, inend, h);
    i = windowstart;
    for( ; !(i >= instart); i = i + 1ul)
      ZopfliUpdateHash(in, i, inend, h);
    pos = instart;
    i = (unsigned long int)0;
    for( ; !(i >= pathsize); i = i + 1ul)
    {
      unsigned short int length = path[(signed long int)i];
      unsigned short int dummy_length;
      unsigned short int dist;
      /* assertion pos < inend */
      assert(pos < inend);
      ZopfliUpdateHash(in, pos, inend, h);
      if((signed int)length >= 3)
      {
        ZopfliFindLongestMatch(s, h, in, pos, inend, (unsigned long int)length, ((unsigned short int *)NULL), &dist, &dummy_length);
        /* assertion !(dummy_length != length && length > 2 && dummy_length > 2) */
        assert(!(dummy_length != length && (signed int)length > 2 && (signed int)dummy_length > 2));
        ZopfliVerifyLenDist(in, inend, pos, dist, length);
        ZopfliStoreLitLenDist(length, dist, store);
        total_length_test = total_length_test + (unsigned long int)length;
      }

      else
      {
        length = (unsigned short int)1;
        ZopfliStoreLitLenDist((unsigned short int)in[(signed long int)pos], (unsigned short int)0, store);
        total_length_test = total_length_test + 1ul;
      }
      /* assertion pos + length <= inend */
      assert(pos + (unsigned long int)length <= inend);
      j = (unsigned long int)1;
      for( ; !(j >= (unsigned long int)length); j = j + 1ul)
        ZopfliUpdateHash(in, pos + j, inend, h);
      pos = pos + (unsigned long int)length;
    }
    ZopfliCleanHash(h);
  }

}

// GetBestLengths
// file zopfli/src/zopfli/squeeze.c line 208
static double GetBestLengths(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext, unsigned short int *length_array)
{
  unsigned long int blocksize = inend - instart;
  float *costs;
  unsigned long int i = (unsigned long int)0;
  unsigned long int k;
  unsigned short int leng;
  unsigned short int dist;
  unsigned short int sublen[259l];
  unsigned long int windowstart = instart > (unsigned long int)32768 ? instart - (unsigned long int)32768 : (unsigned long int)0;
  struct ZopfliHash hash;
  struct ZopfliHash *h = &hash;
  double result;
  double mincost;
  mincost=GetCostModelMinCost(costmodel, costcontext);
  if(instart == inend)
    return (double)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(float) /*4ul*/  * (blocksize + (unsigned long int)1));
    costs = (float *)return_value_malloc_1;
    if(costs == ((float *)NULL))
      exit(-1);

    ZopfliInitHash((unsigned long int)32768, h);
    ZopfliWarmupHash(in, windowstart, inend, h);
    i = windowstart;
    for( ; !(i >= instart); i = i + 1ul)
      ZopfliUpdateHash(in, i, inend, h);
    i = (unsigned long int)1;
    for( ; !(i >= 1ul + blocksize); i = i + 1ul)
      costs[(signed long int)i] = (float)1e30;
    costs[(signed long int)0] = (float)0;
    length_array[(signed long int)0] = (unsigned short int)0;
    i = instart;
    for( ; !(i >= inend); i = i + 1ul)
    {
      unsigned long int j = i - instart;
      ZopfliUpdateHash(in, i, inend, h);
      if((signed int)h->same[32767l & (signed long int)i] >= 517)
      {
        if(!(259ul + instart >= i))
        {
          if(!(517ul + i >= inend))
          {
            if((signed int)h->same[-258l + (signed long int)i & 32767l] >= 259)
            {
              double symbolcost;
              symbolcost=costmodel((unsigned int)258, (unsigned int)1, costcontext);
              k = (unsigned long int)0;
              if(!(k >= 258ul))
              {
                costs[(signed long int)(j + (unsigned long int)258)] = (float)((double)costs[(signed long int)j] + symbolcost);
                length_array[(signed long int)(j + (unsigned long int)258)] = (unsigned short int)258;
                i = i + 1ul;
                j = j + 1ul;
                ZopfliUpdateHash(in, i, inend, h);
                k = k + 1ul;
              }

            }

          }

        }

      }

      ZopfliFindLongestMatch(s, h, in, i, inend, (unsigned long int)258, sublen, &dist, &leng);
      if(inend >= 1ul + i)
      {
        double newCost;
        double return_value;
        return_value=costmodel((unsigned int)in[(signed long int)i], (unsigned int)0, costcontext);
        newCost = (double)costs[(signed long int)j] + return_value;
        /* assertion newCost >= 0 */
        assert(newCost >= (double)0);
        if(newCost < (double)costs[1l + (signed long int)j])
        {
          costs[(signed long int)(j + (unsigned long int)1)] = (float)newCost;
          length_array[(signed long int)(j + (unsigned long int)1)] = (unsigned short int)1;
        }

      }

      k = (unsigned long int)3;
      for( ; inend >= i + k && (unsigned long int)leng >= k; k = k + 1ul)
      {
        double GetBestLengths__1__3__1__3__1__newCost;
        if(!((double)(costs[(signed long int)j + (signed long int)k] + -costs[(signed long int)j]) <= mincost))
        {
          double return_value_1;
          return_value_1=costmodel((unsigned int)k, (unsigned int)sublen[(signed long int)k], costcontext);
          GetBestLengths__1__3__1__3__1__newCost = (double)costs[(signed long int)j] + return_value_1;
          /* assertion newCost >= 0 */
          assert(GetBestLengths__1__3__1__3__1__newCost >= (double)0);
          if(GetBestLengths__1__3__1__3__1__newCost < (double)costs[(signed long int)j + (signed long int)k])
          {
            /* assertion k <= 258 */
            assert(k <= (unsigned long int)258);
            costs[(signed long int)(j + k)] = (float)GetBestLengths__1__3__1__3__1__newCost;
            length_array[(signed long int)(j + k)] = (unsigned short int)k;
          }

        }

      }
    }
    /* assertion costs[blocksize] >= 0 */
    assert(costs[(signed long int)blocksize] >= (float)0);
    result = (double)costs[(signed long int)blocksize];
    ZopfliCleanHash(h);
    free((void *)costs);
    return result;
  }
}

// GetCostFixed
// file zopfli/src/zopfli/squeeze.c line 120
static double GetCostFixed(unsigned int litlen, unsigned int dist, void *unused)
{
  (void)unused;
  if(dist == 0u)
  {
    if(!(litlen >= 144u))
      return (double)8;

    else
      return (double)9;
  }

  else
  {
    signed int dbits;
    dbits=ZopfliGetDistExtraBits((signed int)dist);
    signed int lbits;
    lbits=ZopfliGetLengthExtraBits((signed int)litlen);
    signed int lsym;
    lsym=ZopfliGetLengthSymbol((signed int)litlen);
    double cost = (double)0;
    if(!(lsym >= 280))
      cost = cost + (double)7;

    else
      cost = cost + (double)8;
    cost = cost + (double)5;
    return cost + (double)dbits + (double)lbits;
  }
}

// GetCostModelMinCost
// file zopfli/src/zopfli/squeeze.c line 158
static double GetCostModelMinCost(double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext)
{
  double mincost;
  signed int bestlength = 0;
  signed int bestdist = 0;
  signed int i;
  mincost = 1e30;
  i = 3;
  if(!(i >= 259))
  {
    double c;
    c=costmodel((unsigned int)i, (unsigned int)1, costcontext);
    if(c < mincost)
    {
      bestlength = i;
      mincost = c;
    }

    i = i + 1;
  }

  mincost = 1e30;
  i = 0;
  if(!(i >= 30))
  {
    double GetCostModelMinCost__1__2__1__c;
    static const signed int dsymbols[30l] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 };
    GetCostModelMinCost__1__2__1__c=costmodel((unsigned int)3, (unsigned int)dsymbols[(signed long int)i], costcontext);
    if(GetCostModelMinCost__1__2__1__c < mincost)
    {
      bestdist = dsymbols[(signed long int)i];
      mincost = GetCostModelMinCost__1__2__1__c;
    }

    i = i + 1;
  }

  double return_value;
  return_value=costmodel((unsigned int)bestlength, (unsigned int)bestdist, costcontext);
  return return_value;
}

// GetCostStat
// file zopfli/src/zopfli/squeeze.c line 141
static double GetCostStat(unsigned int litlen, unsigned int dist, void *context)
{
  struct SymbolStats *stats = (struct SymbolStats *)context;
  if(dist == 0u)
    return stats->ll_symbols[(signed long int)litlen];

  else
  {
    signed int lsym;
    lsym=ZopfliGetLengthSymbol((signed int)litlen);
    signed int lbits;
    lbits=ZopfliGetLengthExtraBits((signed int)litlen);
    signed int dsym;
    dsym=ZopfliGetDistSymbol((signed int)dist);
    signed int dbits;
    dbits=ZopfliGetDistExtraBits((signed int)dist);
    return stats->ll_symbols[(signed long int)lsym] + (double)lbits + stats->d_symbols[(signed long int)dsym] + (double)dbits;
  }
}

// GetDynamicLengths
// file zopfli/src/zopfli/deflate.c line 473
static void GetDynamicLengths(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, unsigned int *ll_lengths, unsigned int *d_lengths)
{
  unsigned long int ll_counts[288l];
  unsigned long int d_counts[32l];
  ZopfliLZ77Counts(litlens, dists, lstart, lend, ll_counts, d_counts);
  OptimizeHuffmanForRle(288, ll_counts);
  OptimizeHuffmanForRle(32, d_counts);
  ZopfliCalculateBitLengths(ll_counts, (unsigned long int)288, 15, ll_lengths);
  ZopfliCalculateBitLengths(d_counts, (unsigned long int)32, 15, d_lengths);
  PatchDistanceCodesForBuggyDecoders(d_lengths);
}

// GetFixedTree
// file zopfli/src/zopfli/deflate.c line 336
static void GetFixedTree(unsigned int *ll_lengths, unsigned int *d_lengths)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 144ul); i = i + 1ul)
    ll_lengths[(signed long int)i] = (unsigned int)8;
  i = (unsigned long int)144;
  for( ; !(i >= 256ul); i = i + 1ul)
    ll_lengths[(signed long int)i] = (unsigned int)9;
  i = (unsigned long int)256;
  for( ; !(i >= 280ul); i = i + 1ul)
    ll_lengths[(signed long int)i] = (unsigned int)7;
  i = (unsigned long int)280;
  for( ; !(i >= 288ul); i = i + 1ul)
    ll_lengths[(signed long int)i] = (unsigned int)8;
  i = (unsigned long int)0;
  for( ; !(i >= 32ul); i = i + 1ul)
    d_lengths[(signed long int)i] = (unsigned int)5;
}

// GetFreeNode
// file zopfli/src/zopfli/katajainen.c line 67
static struct Node * GetFreeNode(struct Node *(*lists)[2l], signed int maxbits, struct NodePool *pool)
{
  for( ; (_Bool)1; pool->next = pool->next + 1l)
  {
    if(pool->next >= pool->nodes + (signed long int)pool->size)
    {
      signed int i = 0;
      for( ; !(i >= pool->size); i = i + 1)
        (pool->nodes + (signed long int)i)->inuse = (char)0;
      if(!(lists == ((struct Node *(*)[2l])NULL)))
      {
        i = 0;
        for( ; !(i >= 2 * maxbits); i = i + 1)
        {
          struct Node *node = lists[(signed long int)(i / 2)][(signed long int)(i % 2)];
          for( ; !(node == ((struct Node *)NULL)); node = node->tail)
            node->inuse = (char)1;
        }
      }

      pool->next = &pool->nodes[(signed long int)0];
    }

    if(pool->next->inuse == 0)
      break;

  }
  struct Node *tmp_post_1 = pool->next;
  pool->next = pool->next + 1l;
  return tmp_post_1;
}

// GetLengthScore
// file zopfli/src/zopfli/lz77.c line 87
static signed int GetLengthScore(signed int length, signed int distance)
{
  return distance > 1024 ? length - 1 : length;
}

// GetMatch
// file zopfli/src/zopfli/lz77.c line 119
static const unsigned char * GetMatch(const unsigned char *scan, const unsigned char *match, const unsigned char *end, const unsigned char *safe_end)
{
  for( ; !(scan >= safe_end); match = match + (signed long int)8)
  {
    if(!(*((unsigned long int *)scan) == *((unsigned long int *)match)))
      break;

    scan = scan + (signed long int)8;
  }
  for( ; !(scan == end); match = match + 1l)
  {
    if(!(*scan == *match))
      break;

    scan = scan + 1l;
  }
  return scan;
}

// GetStatistics
// file zopfli/src/zopfli/squeeze.c line 399
static void GetStatistics(const struct ZopfliLZ77Store *store, struct SymbolStats *stats)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= store->size); i = i + 1ul)
    if((signed int)store->dists[(signed long int)i] == 0)
      stats->litlens[(signed long int)store->litlens[(signed long int)i]] = stats->litlens[(signed long int)store->litlens[(signed long int)i]] + 1ul;

    else
    {
      signed int return_value_ZopfliGetLengthSymbol_1;
      return_value_ZopfliGetLengthSymbol_1=ZopfliGetLengthSymbol((signed int)store->litlens[(signed long int)i]);
      stats->litlens[(signed long int)return_value_ZopfliGetLengthSymbol_1] = stats->litlens[(signed long int)return_value_ZopfliGetLengthSymbol_1] + 1ul;
      signed int return_value_ZopfliGetDistSymbol_2;
      return_value_ZopfliGetDistSymbol_2=ZopfliGetDistSymbol((signed int)store->dists[(signed long int)i]);
      stats->dists[(signed long int)return_value_ZopfliGetDistSymbol_2] = stats->dists[(signed long int)return_value_ZopfliGetDistSymbol_2] + 1ul;
    }
  stats->litlens[(signed long int)256] = (unsigned long int)1;
  CalculateStatistics(stats);
}

// InitLists
// file zopfli/src/zopfli/katajainen.c line 145
static void InitLists(struct NodePool *pool, const struct Node *leaves, signed int maxbits, struct Node *(*lists)[2l])
{
  signed int i;
  struct Node *node0;
  node0=GetFreeNode(((struct Node *(*)[2l])NULL), maxbits, pool);
  struct Node *node1;
  node1=GetFreeNode(((struct Node *(*)[2l])NULL), maxbits, pool);
  InitNode((leaves + (signed long int)0)->weight, 1, ((struct Node *)NULL), node0);
  InitNode((leaves + (signed long int)1)->weight, 2, ((struct Node *)NULL), node1);
  i = 0;
  for( ; !(i >= maxbits); i = i + 1)
  {
    lists[(signed long int)i][(signed long int)0] = node0;
    lists[(signed long int)i][(signed long int)1] = node1;
  }
}

// InitNode
// file zopfli/src/zopfli/katajainen.c line 54
static void InitNode(unsigned long int weight, signed int count, struct Node *tail, struct Node *node)
{
  node->weight = weight;
  node->count = count;
  node->tail = tail;
  node->inuse = (char)1;
}

// InitRanState
// file zopfli/src/zopfli/squeeze.c line 79
static void InitRanState(struct RanState *state)
{
  state->m_w = (unsigned int)1;
  state->m_z = (unsigned int)2;
}

// InitStats
// file zopfli/src/zopfli/squeeze.c line 42
static void InitStats(struct SymbolStats *stats)
{
  memset((void *)stats->litlens, 0, (unsigned long int)288 * sizeof(unsigned long int) /*8ul*/ );
  memset((void *)stats->dists, 0, (unsigned long int)32 * sizeof(unsigned long int) /*8ul*/ );
  memset((void *)stats->ll_symbols, 0, (unsigned long int)288 * sizeof(double) /*8ul*/ );
  memset((void *)stats->d_symbols, 0, (unsigned long int)32 * sizeof(double) /*8ul*/ );
}

// LZ77OptimalRun
// file zopfli/src/zopfli/squeeze.c line 431
static double LZ77OptimalRun(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned short int **path, unsigned long int *pathsize, unsigned short int *length_array, double (*costmodel)(unsigned int, unsigned int, void *), void *costcontext, struct ZopfliLZ77Store *store)
{
  double cost;
  cost=GetBestLengths(s, in, instart, inend, costmodel, costcontext, length_array);
  free((void *)*path);
  *path = ((unsigned short int *)NULL);
  *pathsize = (unsigned long int)0;
  TraceBackwards(inend - instart, length_array, path, pathsize);
  FollowPath(s, in, instart, inend, *path, *pathsize, store);
  /* assertion cost < 1e30 */
  assert(cost < 1e30);
  return cost;
}

// LeafComparator
// file zopfli/src/zopfli/katajainen.c line 176
static signed int LeafComparator(const void *a, const void *b)
{
  return (signed int)(((const struct Node *)a)->weight - ((const struct Node *)b)->weight);
}

// OptimizeHuffmanForRle
// file zopfli/src/zopfli/deflate.c line 381
void OptimizeHuffmanForRle(signed int length, unsigned long int *counts)
{
  signed int i;
  signed int k;
  signed int stride;
  unsigned long int symbol;
  unsigned long int sum;
  unsigned long int limit;
  signed int *good_for_rle;
  for( ; length >= 0; length = length - 1)
  {
    if(length == 0)
      goto __CPROVER_DUMP_L30;

    if(!(counts[(signed long int)(length + -1)] == 0ul))
      break;

  }
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)length * sizeof(signed int) /*4ul*/ );
  good_for_rle = (signed int *)return_value_malloc_1;
  i = 0;
  for( ; !(i >= length); i = i + 1)
    good_for_rle[(signed long int)i] = 0;
  symbol = counts[(signed long int)0];
  stride = 0;
  i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= 1 + length); i = i + 1)
  {
    if(i == length)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = counts[(signed long int)i] != symbol ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      if(symbol == 0ul && stride >= 5 || stride >= 7 && !(symbol == 0ul))
      {
        k = 0;
        for( ; !(k >= stride); k = k + 1)
          good_for_rle[(signed long int)((i - k) - 1)] = 1;
      }

      stride = 1;
      if(!(i == length))
        symbol = counts[(signed long int)i];

    }

    else
      stride = stride + 1;
  }
  stride = 0;
  limit = counts[(signed long int)0];
  sum = (unsigned long int)0;
  i = 0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_AbsDiff_4;
  for( ; !(i >= 1 + length); i = i + 1)
  {
    if(i == length)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = good_for_rle[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_AbsDiff_4=AbsDiff(counts[(signed long int)i], limit);
      tmp_if_expr_5 = return_value_AbsDiff_4 >= (unsigned long int)4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      if(stride >= 4 || sum == 0ul && stride >= 3)
      {
        signed int count = (signed int)((sum + (unsigned long int)(stride / 2)) / (unsigned long int)stride);
        if(!(count >= 1))
          count = 1;

        if(sum == 0ul)
          count = 0;

        k = 0;
        for( ; !(k >= stride); k = k + 1)
          counts[(signed long int)((i - k) - 1)] = (unsigned long int)count;
      }

      stride = 0;
      sum = (unsigned long int)0;
      if(!(i >= length + -3))
        limit = (counts[(signed long int)i] + counts[(signed long int)(i + 1)] + counts[(signed long int)(i + 2)] + counts[(signed long int)(i + 3)] + (unsigned long int)2) / (unsigned long int)4;

      else
        if(!(i >= length))
          limit = counts[(signed long int)i];

        else
          limit = (unsigned long int)0;
    }

    stride = stride + 1;
    if(!(i == length))
      sum = sum + counts[(signed long int)i];

  }
  free((void *)good_for_rle);

__CPROVER_DUMP_L30:
  ;
}

// PatchDistanceCodesForBuggyDecoders
// file zopfli/src/zopfli/deflate.c line 86
static void PatchDistanceCodesForBuggyDecoders(unsigned int *d_lengths)
{
  signed int num_dist_codes = 0;
  signed int i = 0;
  for( ; !(i >= 30); i = i + 1)
  {
    if(!(d_lengths[(signed long int)i] == 0u))
      num_dist_codes = num_dist_codes + 1;

    if(num_dist_codes >= 2)
      goto __CPROVER_DUMP_L7;

  }
  if(num_dist_codes == 0)
  {
    d_lengths[(signed long int)1] = (unsigned int)1;
    d_lengths[(signed long int)0] = d_lengths[(signed long int)1];
  }

  else
    if(num_dist_codes == 1)
      d_lengths[(signed long int)(d_lengths[(signed long int)0] != 0u ? 1 : 0)] = (unsigned int)1;


__CPROVER_DUMP_L7:
  ;
}

// PrintBlockSplitPoints
// file zopfli/src/zopfli/blocksplitter.c line 150
static void PrintBlockSplitPoints(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int llsize, const unsigned long int *lz77splitpoints, unsigned long int nlz77points)
{
  unsigned long int *splitpoints = ((unsigned long int *)NULL);
  unsigned long int npoints = (unsigned long int)0;
  unsigned long int i;
  unsigned long int pos = (unsigned long int)0;
  signed int tmp_if_expr_1;
  void *tmp_if_expr_4;
  void *return_value_malloc_2;
  void *return_value_realloc_3;
  if(nlz77points >= 1ul)
  {
    i = (unsigned long int)0;
    for( ; !(i >= llsize); i = i + 1ul)
    {
      unsigned long int length;
      if((signed int)dists[(signed long int)i] == 0)
        tmp_if_expr_1 = 1;

      else
        tmp_if_expr_1 = (signed int)litlens[(signed long int)i];
      length = (unsigned long int)tmp_if_expr_1;
      if(lz77splitpoints[(signed long int)npoints] == i)
      {
        if((npoints + 18446744073709551615ul & npoints) == 0ul)
        {
          if(npoints == 0ul)
          {
            return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/ );
            tmp_if_expr_4 = return_value_malloc_2;
          }

          else
          {
            return_value_realloc_3=realloc((void *)*(&splitpoints), *(&npoints) * (unsigned long int)2 * sizeof(unsigned long int) /*8ul*/ );
            tmp_if_expr_4 = return_value_realloc_3;
          }
          *(&splitpoints) = (unsigned long int *)tmp_if_expr_4;
        }

        (*(&splitpoints))[(signed long int)*(&npoints)] = pos;
        *(&npoints) = *(&npoints) + 1ul;
        if(npoints == nlz77points)
          break;

      }

      pos = pos + length;
    }
  }

  /* assertion npoints == nlz77points */
  assert(npoints == nlz77points);
  fprintf(stderr, "block split points: ");
  i = (unsigned long int)0;
  for( ; !(i >= npoints); i = i + 1ul)
    fprintf(stderr, "%d ", (signed int)splitpoints[(signed long int)i]);
  fprintf(stderr, "(hex:");
  i = (unsigned long int)0;
  for( ; !(i >= npoints); i = i + 1ul)
    fprintf(stderr, " %x", (signed int)splitpoints[(signed long int)i]);
  fprintf(stderr, ")\n");
  free((void *)splitpoints);
}

// Ran
// file zopfli/src/zopfli/squeeze.c line 85
static unsigned int Ran(struct RanState *state)
{
  state->m_z = (unsigned int)36969 * (state->m_z & (unsigned int)65535) + (state->m_z >> 16);
  state->m_w = (unsigned int)18000 * (state->m_w & (unsigned int)65535) + (state->m_w >> 16);
  return (state->m_z << 16) + state->m_w;
}

// RandomizeFreqs
// file zopfli/src/zopfli/squeeze.c line 91
static void RandomizeFreqs(struct RanState *state, unsigned long int *freqs, signed int n)
{
  signed int i = 0;
  unsigned int return_value_Ran_1;
  for( ; !(i >= n); i = i + 1)
  {
    unsigned int return_value_Ran_2;
    return_value_Ran_2=Ran(state);
    if((return_value_Ran_2 >> 4) % 3u == 0u)
    {
      return_value_Ran_1=Ran(state);
      freqs[(signed long int)i] = freqs[(signed long int)(return_value_Ran_1 % (unsigned int)n)];
    }

  }
}

// RandomizeStatFreqs
// file zopfli/src/zopfli/squeeze.c line 98
static void RandomizeStatFreqs(struct RanState *state, struct SymbolStats *stats)
{
  RandomizeFreqs(state, stats->litlens, 288);
  RandomizeFreqs(state, stats->dists, 32);
  stats->litlens[(signed long int)256] = (unsigned long int)1;
}

// SplitCost
// file zopfli/src/zopfli/blocksplitter.c line 126
static double SplitCost(unsigned long int i, void *context)
{
  struct SplitCostContext *c = (struct SplitCostContext *)context;
  double return_value_EstimateCost_1;
  return_value_EstimateCost_1=EstimateCost(c->litlens, c->dists, c->start, i);
  double return_value_EstimateCost_2;
  return_value_EstimateCost_2=EstimateCost(c->litlens, c->dists, i, c->end);
  return return_value_EstimateCost_1 + return_value_EstimateCost_2;
}

// StoreInLongestMatchCache
// file zopfli/src/zopfli/lz77.c line 206
static void StoreInLongestMatchCache(struct ZopfliBlockState *s, unsigned long int pos, unsigned long int limit, const unsigned short int *sublen, unsigned short int distance, unsigned short int length)
{
  unsigned long int lmcpos = pos - s->blockstart;
  unsigned char cache_available;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(s->lmc == ((struct ZopfliLongestMatchCache *)NULL)))
  {
    if((signed int)s->lmc->length[(signed long int)lmcpos] == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)s->lmc->dist[(signed long int)lmcpos] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  cache_available = (unsigned char)tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(s->lmc == ((struct ZopfliLongestMatchCache *)NULL)))
  {
    if(limit == 258ul)
    {
      if(!(sublen == ((const unsigned short int *)NULL)))
      {
        if(cache_available == 0)
        {
          if((signed int)s->lmc->length[(signed long int)lmcpos] == 1)
            tmp_if_expr_3 = (signed int)s->lmc->dist[(signed long int)lmcpos] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          /* assertion s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0 */
          assert(tmp_if_expr_3);
          s->lmc->dist[(signed long int)lmcpos] = (unsigned short int)((signed int)length < 3 ? 0 : (signed int)distance);
          s->lmc->length[(signed long int)lmcpos] = (unsigned short int)((signed int)length < 3 ? 0 : (signed int)length);
          if((signed int)s->lmc->length[(signed long int)lmcpos] == 1)
            tmp_if_expr_4 = (signed int)s->lmc->dist[(signed long int)lmcpos] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          /* assertion !(s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0) */
          assert(!tmp_if_expr_4);
          ZopfliSublenToCache(sublen, lmcpos, (unsigned long int)length, s->lmc);
        }

      }

    }

  }

}

// TraceBackwards
// file zopfli/src/zopfli/squeeze.c line 313
static void TraceBackwards(unsigned long int size, const unsigned short int *length_array, unsigned short int **path, unsigned long int *pathsize)
{
  unsigned long int index = size;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(size == 0ul))
  {
    while((_Bool)1)
    {
      if((*pathsize + 18446744073709551615ul & *pathsize) == 0ul)
      {
        if(*pathsize == 0ul)
        {
          return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/ );
          tmp_if_expr_3 = return_value_malloc_1;
        }

        else
        {
          return_value_realloc_2=realloc((void *)*path, *pathsize * (unsigned long int)2 * sizeof(unsigned short int) /*2ul*/ );
          tmp_if_expr_3 = return_value_realloc_2;
        }
        *path = (unsigned short int *)tmp_if_expr_3;
      }

      (*path)[(signed long int)*pathsize] = length_array[(signed long int)index];
      *pathsize = *pathsize + 1ul;
      /* assertion length_array[index] <= index */
      assert((unsigned long int)length_array[(signed long int)index] <= index);
      /* assertion length_array[index] <= 258 */
      assert((signed int)length_array[(signed long int)index] <= 258);
      /* assertion length_array[index] != 0 */
      assert((signed int)length_array[(signed long int)index] != 0);
      index = index - (unsigned long int)length_array[(signed long int)index];
      if(index == 0ul)
        break;

    }
    index = (unsigned long int)0;
    for( ; !(index >= *pathsize / 2ul); index = index + 1ul)
    {
      unsigned short int temp = (*path)[(signed long int)index];
      (*path)[(signed long int)index] = (*path)[(signed long int)((*pathsize - index) - (unsigned long int)1)];
      (*path)[(signed long int)((*pathsize - index) - (unsigned long int)1)] = temp;
    }
  }

}

// TryGetFromLongestMatchCache
// file zopfli/src/zopfli/lz77.c line 162
static signed int TryGetFromLongestMatchCache(struct ZopfliBlockState *s, unsigned long int pos, unsigned long int *limit, unsigned short int *sublen, unsigned short int *distance, unsigned short int *length)
{
  unsigned long int lmcpos = pos - s->blockstart;
  unsigned char cache_available;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(s->lmc == ((struct ZopfliLongestMatchCache *)NULL)))
  {
    if((signed int)s->lmc->length[(signed long int)lmcpos] == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)s->lmc->dist[(signed long int)lmcpos] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  cache_available = (unsigned char)tmp_if_expr_2;
  unsigned char limit_ok_for_cache;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  unsigned int return_value_ZopfliMaxCachedSublen_4;
  if(!(cache_available == 0))
  {
    if(*limit == 258ul)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (unsigned long int)s->lmc->length[(signed long int)lmcpos] <= *limit ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      if(!(sublen == ((unsigned short int *)NULL)))
      {
        return_value_ZopfliMaxCachedSublen_4=ZopfliMaxCachedSublen(s->lmc, lmcpos, (unsigned long int)s->lmc->length[(signed long int)lmcpos]);
        tmp_if_expr_5 = (unsigned long int)return_value_ZopfliMaxCachedSublen_4 >= *limit ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  limit_ok_for_cache = (unsigned char)tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_ZopfliMaxCachedSublen_8;
  if(!(s->lmc == ((struct ZopfliLongestMatchCache *)NULL)))
  {
    if(!(limit_ok_for_cache == 0))
    {
      if(!(cache_available == 0))
      {
        if(sublen == ((unsigned short int *)NULL))
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_ZopfliMaxCachedSublen_8=ZopfliMaxCachedSublen(s->lmc, lmcpos, (unsigned long int)s->lmc->length[(signed long int)lmcpos]);
          tmp_if_expr_9 = (unsigned int)s->lmc->length[(signed long int)lmcpos] <= return_value_ZopfliMaxCachedSublen_8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
        {
          *length = s->lmc->length[(signed long int)lmcpos];
          if(!(*limit >= (unsigned long int)*length))
            *length = (unsigned short int)*limit;

          if(!(sublen == ((unsigned short int *)NULL)))
          {
            ZopfliCacheToSublen(s->lmc, lmcpos, (unsigned long int)*length, sublen);
            *distance = sublen[(signed long int)*length];
            if(*limit == 258ul)
            {
              if((signed int)*length >= 3)
                /* assertion sublen[*length] == s->lmc->dist[lmcpos] */
                assert(sublen[(signed long int)*length] == s->lmc->dist[(signed long int)lmcpos]);

            }

          }

          else
            *distance = s->lmc->dist[(signed long int)lmcpos];
          return 1;
        }

        *limit = (unsigned long int)s->lmc->length[(signed long int)lmcpos];
      }

    }

  }

  return 0;
}

// UpdateHashValue
// file zopfli/src/zopfli/hash.c line 87
static void UpdateHashValue(struct ZopfliHash *h, unsigned char c)
{
  h->val = (h->val << 5 ^ (signed int)c) & 32767;
}

// ZopfliBlockSplit
// file zopfli/src/zopfli/blocksplitter.h line 64
void ZopfliBlockSplit(const struct ZopfliOptions *options, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned long int maxblocks, unsigned long int **splitpoints, unsigned long int *npoints)
{
  unsigned long int pos = (unsigned long int)0;
  unsigned long int i;
  struct ZopfliBlockState s;
  unsigned long int *lz77splitpoints = ((unsigned long int *)NULL);
  unsigned long int nlz77points = (unsigned long int)0;
  struct ZopfliLZ77Store store;
  ZopfliInitLZ77Store(&store);
  s.options = options;
  s.blockstart = instart;
  s.blockend = inend;
  s.lmc = ((struct ZopfliLongestMatchCache *)NULL);
  *npoints = (unsigned long int)0;
  *splitpoints = ((unsigned long int *)NULL);
  ZopfliLZ77Greedy(&s, in, instart, inend, &store);
  ZopfliBlockSplitLZ77(options, store.litlens, store.dists, store.size, maxblocks, &lz77splitpoints, &nlz77points);
  pos = instart;
  signed int tmp_if_expr_1;
  void *tmp_if_expr_4;
  void *return_value_malloc_2;
  void *return_value_realloc_3;
  if(nlz77points >= 1ul)
  {
    i = (unsigned long int)0;
    for( ; !(i >= store.size); i = i + 1ul)
    {
      unsigned long int length;
      if((signed int)store.dists[(signed long int)i] == 0)
        tmp_if_expr_1 = 1;

      else
        tmp_if_expr_1 = (signed int)store.litlens[(signed long int)i];
      length = (unsigned long int)tmp_if_expr_1;
      if(lz77splitpoints[(signed long int)*npoints] == i)
      {
        if((*npoints + 18446744073709551615ul & *npoints) == 0ul)
        {
          if(*npoints == 0ul)
          {
            return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/ );
            tmp_if_expr_4 = return_value_malloc_2;
          }

          else
          {
            return_value_realloc_3=realloc((void *)*splitpoints, *npoints * (unsigned long int)2 * sizeof(unsigned long int) /*8ul*/ );
            tmp_if_expr_4 = return_value_realloc_3;
          }
          *splitpoints = (unsigned long int *)tmp_if_expr_4;
        }

        (*splitpoints)[(signed long int)*npoints] = pos;
        *npoints = *npoints + 1ul;
        if(*npoints == nlz77points)
          break;

      }

      pos = pos + length;
    }
  }

  /* assertion *npoints == nlz77points */
  assert(*npoints == nlz77points);
  free((void *)lz77splitpoints);
  ZopfliCleanLZ77Store(&store);
}

// ZopfliBlockSplitLZ77
// file zopfli/src/zopfli/blocksplitter.h line 44
void ZopfliBlockSplitLZ77(const struct ZopfliOptions *options, const unsigned short int *litlens, const unsigned short int *dists, unsigned long int llsize, unsigned long int maxblocks, unsigned long int **splitpoints, unsigned long int *npoints)
{
  unsigned long int lstart;
  unsigned long int lend;
  unsigned long int i;
  unsigned long int llpos = (unsigned long int)0;
  unsigned long int numblocks = (unsigned long int)1;
  unsigned char *done;
  double splitcost;
  double origcost;
  if(llsize >= 10ul)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(llsize);
    done = (unsigned char *)return_value_malloc_1;
    if(done == ((unsigned char *)NULL))
      exit(-1);

    i = (unsigned long int)0;
    for( ; !(i >= llsize); i = i + 1ul)
      done[(signed long int)i] = (unsigned char)0;
    lstart = (unsigned long int)0;
    lend = llsize;
    do
    {
      struct SplitCostContext c;
      if(numblocks >= maxblocks && maxblocks >= 1ul)
        break;

      c.litlens = litlens;
      c.dists = dists;
      c.llsize = llsize;
      c.start = lstart;
      c.end = lend;
      /* assertion lstart < lend */
      assert(lstart < lend);
      llpos=FindMinimum(SplitCost, (void *)&c, lstart + (unsigned long int)1, lend);
      /* assertion llpos > lstart */
      assert(llpos > lstart);
      /* assertion llpos < lend */
      assert(llpos < lend);
      double return_value_EstimateCost_2;
      return_value_EstimateCost_2=EstimateCost(litlens, dists, lstart, llpos);
      double return_value_EstimateCost_3;
      return_value_EstimateCost_3=EstimateCost(litlens, dists, llpos, lend);
      splitcost = return_value_EstimateCost_2 + return_value_EstimateCost_3;
      origcost=EstimateCost(litlens, dists, lstart, lend);
      if(llpos == 1ul + lstart || llpos == lend || splitcost > origcost)
        done[(signed long int)lstart] = (unsigned char)1;

      else
      {
        AddSorted(llpos, splitpoints, npoints);
        numblocks = numblocks + 1ul;
      }
      signed int return_value_FindLargestSplittableBlock_4;
      return_value_FindLargestSplittableBlock_4=FindLargestSplittableBlock(llsize, done, *splitpoints, *npoints, &lstart, &lend);
      if(return_value_FindLargestSplittableBlock_4 == 0)
        break;

      if(!(lend + -lstart >= 10ul))
        break;

    }
    while((_Bool)1);
    if(!(options->verbose == 0))
      PrintBlockSplitPoints(litlens, dists, llsize, *splitpoints, *npoints);

    free((void *)done);
  }

}

// ZopfliBlockSplitSimple
// file zopfli/src/zopfli/blocksplitter.h line 72
void ZopfliBlockSplitSimple(const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned long int blocksize, unsigned long int **splitpoints, unsigned long int *npoints)
{
  unsigned long int i = instart;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  for( ; !(i >= inend); i = i + blocksize)
  {
    if((*npoints + 18446744073709551615ul & *npoints) == 0ul)
    {
      if(*npoints == 0ul)
      {
        return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/ );
        tmp_if_expr_3 = return_value_malloc_1;
      }

      else
      {
        return_value_realloc_2=realloc((void *)*splitpoints, *npoints * (unsigned long int)2 * sizeof(unsigned long int) /*8ul*/ );
        tmp_if_expr_3 = return_value_realloc_2;
      }
      *splitpoints = (unsigned long int *)tmp_if_expr_3;
    }

    (*splitpoints)[(signed long int)*npoints] = i;
    *npoints = *npoints + 1ul;
  }
  (void)in;
}

// ZopfliCacheToSublen
// file zopfli/src/zopfli/cache.h line 57
void ZopfliCacheToSublen(const struct ZopfliLongestMatchCache *lmc, unsigned long int pos, unsigned long int length, unsigned short int *sublen)
{
  unsigned long int i;
  unsigned long int j;
  unsigned int maxlength;
  maxlength=ZopfliMaxCachedSublen(lmc, pos, length);
  unsigned int prevlength = (unsigned int)0;
  unsigned char *cache;
  if(length >= 3ul)
  {
    cache = &lmc->sublen[(signed long int)((unsigned long int)8 * pos * (unsigned long int)3)];
    j = (unsigned long int)0;
    for( ; !(j >= 8ul); j = j + 1ul)
    {
      unsigned int ZopfliCacheToSublen__1__1__1__length = (unsigned int)((signed int)cache[(signed long int)(j * (unsigned long int)3)] + 3);
      unsigned int dist = (unsigned int)((signed int)cache[(signed long int)(j * (unsigned long int)3 + (unsigned long int)1)] + 256 * (signed int)cache[(signed long int)(j * (unsigned long int)3 + (unsigned long int)2)]);
      i = (unsigned long int)prevlength;
      for( ; (unsigned long int)ZopfliCacheToSublen__1__1__1__length >= i; i = i + 1ul)
        sublen[(signed long int)i] = (unsigned short int)dist;
      if(ZopfliCacheToSublen__1__1__1__length == maxlength)
        break;

      prevlength = ZopfliCacheToSublen__1__1__1__length + (unsigned int)1;
    }
  }

}

// ZopfliCalculateBitLengths
// file zopfli/src/zopfli/tree.h line 33
void ZopfliCalculateBitLengths(const unsigned long int *count, unsigned long int n, signed int maxbits, unsigned int *bitlengths)
{
  signed int error;
  error=ZopfliLengthLimitedCodeLengths(count, (signed int)n, maxbits, bitlengths);
  (void)error;
  /* assertion !error */
  assert(!(error != 0));
}

// ZopfliCalculateBlockSize
// file zopfli/src/zopfli/deflate.c line 488
double ZopfliCalculateBlockSize(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int lstart, unsigned long int lend, signed int btype)
{
  unsigned int ll_lengths[288l];
  unsigned int d_lengths[32l];
  double result = (double)3;
  /* assertion btype == 1 || btype == 2 */
  assert(btype == 1 || btype == 2);
  if(btype == 1)
    GetFixedTree(ll_lengths, d_lengths);

  else
  {
    GetDynamicLengths(litlens, dists, lstart, lend, ll_lengths, d_lengths);
    unsigned long int return_value_CalculateTreeSize_1;
    return_value_CalculateTreeSize_1=CalculateTreeSize(ll_lengths, d_lengths);
    result = result + (double)return_value_CalculateTreeSize_1;
  }
  unsigned long int return_value_CalculateBlockSymbolSize_2;
  return_value_CalculateBlockSymbolSize_2=CalculateBlockSymbolSize(ll_lengths, d_lengths, litlens, dists, lstart, lend);
  result = result + (double)return_value_CalculateBlockSymbolSize_2;
  return result;
}

// ZopfliCalculateEntropy
// file zopfli/src/zopfli/tree.c line 71
void ZopfliCalculateEntropy(const unsigned long int *count, unsigned long int n, double *bitlengths)
{
  unsigned int sum = (unsigned int)0;
  unsigned int i;
  double log2sum;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= n); i = i + 1u)
    sum = sum + (unsigned int)count[(signed long int)i];
  double tmp_if_expr_3;
  double return_value_log_1;
  double return_value_log_2;
  if(sum == 0u)
  {
    return_value_log_1=log((double)n);
    tmp_if_expr_3 = return_value_log_1;
  }

  else
  {
    return_value_log_2=log((double)sum);
    tmp_if_expr_3 = return_value_log_2;
  }
  static const double kInvLog2 = 1.4426950408889;
  log2sum = tmp_if_expr_3 * kInvLog2;
  i = (unsigned int)0;
  double return_value_log_4;
  for( ; !((unsigned long int)i >= n); i = i + 1u)
  {
    if(count[(signed long int)i] == 0ul)
      bitlengths[(signed long int)i] = log2sum;

    else
    {
      return_value_log_4=log((double)count[(signed long int)i]);
      bitlengths[(signed long int)i] = log2sum - return_value_log_4 * kInvLog2;
    }
    if(bitlengths[(signed long int)i] < 0.000000)
    {
      if(bitlengths[(signed long int)i] > -1.000000e-5)
        bitlengths[(signed long int)i] = (double)0;

    }

    /* assertion bitlengths[i] >= 0 */
    assert(bitlengths[(signed long int)i] >= (double)0);
  }
}

// ZopfliCleanCache
// file zopfli/src/zopfli/cache.h line 49
void ZopfliCleanCache(struct ZopfliLongestMatchCache *lmc)
{
  free((void *)lmc->length);
  free((void *)lmc->dist);
  free((void *)lmc->sublen);
}

// ZopfliCleanHash
// file zopfli/src/zopfli/hash.h line 53
void ZopfliCleanHash(struct ZopfliHash *h)
{
  free((void *)h->head);
  free((void *)h->prev);
  free((void *)h->hashval);
  free((void *)h->head2);
  free((void *)h->prev2);
  free((void *)h->hashval2);
  free((void *)h->same);
}

// ZopfliCleanLZ77Store
// file zopfli/src/zopfli/lz77.h line 52
void ZopfliCleanLZ77Store(struct ZopfliLZ77Store *store)
{
  free((void *)store->litlens);
  free((void *)store->dists);
}

// ZopfliCopyLZ77Store
// file zopfli/src/zopfli/lz77.c line 38
void ZopfliCopyLZ77Store(const struct ZopfliLZ77Store *source, struct ZopfliLZ77Store *dest)
{
  unsigned long int i;
  ZopfliCleanLZ77Store(dest);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * source->size);
  dest->litlens = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned short int) /*2ul*/  * source->size);
  dest->dists = (unsigned short int *)return_value_malloc_2;
  _Bool tmp_if_expr_3;
  if(dest->litlens == ((unsigned short int *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(dest->dists != ((unsigned short int *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    exit(-1);

  dest->size = source->size;
  i = (unsigned long int)0;
  for( ; !(i >= source->size); i = i + 1ul)
  {
    dest->litlens[(signed long int)i] = source->litlens[(signed long int)i];
    dest->dists[(signed long int)i] = source->dists[(signed long int)i];
  }
}

// ZopfliDeflate
// file zopfli/src/zopfli/deflate.c line 844
void ZopfliDeflate(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int insize, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  unsigned long int i = (unsigned long int)0;
  while(!(i >= insize))
  {
    signed int masterfinal = (signed int)(i + (unsigned long int)20000000 >= insize);
    signed int final2 = (signed int)(final != 0 && masterfinal != 0);
    unsigned long int size = masterfinal != 0 ? insize - i : (unsigned long int)20000000;
    ZopfliDeflatePart(options, btype, final2, in, i, i + size, bp, out, outsize);
    i = i + size;
  }
  if(!(options->verbose == 0))
    fprintf(stderr, "Original Size: %d, Deflate: %d, Compression: %f%% Removed\n", (signed int)insize, (signed int)*outsize, (100.0 * (double)(insize - *outsize)) / (double)insize);

}

// ZopfliDeflatePart
// file zopfli/src/zopfli/deflate.h line 66
void ZopfliDeflatePart(const struct ZopfliOptions *options, signed int btype, signed int final, const unsigned char *in, unsigned long int instart, unsigned long int inend, unsigned char *bp, unsigned char **out, unsigned long int *outsize)
{
  if(!(options->blocksplitting == 0))
  {
    if(!(options->blocksplittinglast == 0))
      DeflateSplittingLast(options, btype, final, in, instart, inend, bp, out, outsize);

    else
      DeflateSplittingFirst(options, btype, final, in, instart, inend, bp, out, outsize);
  }

  else
    DeflateBlock(options, btype, final, in, instart, inend, bp, out, outsize);
}

// ZopfliFindLongestMatch
// file zopfli/src/zopfli/lz77.c line 229
void ZopfliFindLongestMatch(struct ZopfliBlockState *s, const struct ZopfliHash *h, const unsigned char *array, unsigned long int pos, unsigned long int size, unsigned long int limit, unsigned short int *sublen, unsigned short int *distance, unsigned short int *length)
{
  unsigned short int hpos = (unsigned short int)(pos & (unsigned long int)(32768 - 1));
  unsigned short int p;
  unsigned short int pp;
  unsigned short int bestdist = (unsigned short int)0;
  unsigned short int bestlength = (unsigned short int)1;
  const unsigned char *scan;
  const unsigned char *match;
  const unsigned char *arrayend;
  const unsigned char *arrayend_safe;
  signed int chain_counter = 8192;
  unsigned int dist = (unsigned int)0;
  signed int *hhead = h->head;
  unsigned short int *hprev = h->prev;
  signed int *hhashval = h->hashval;
  signed int hval = h->val;
  signed int return_value_TryGetFromLongestMatchCache_1;
  return_value_TryGetFromLongestMatchCache_1=TryGetFromLongestMatchCache(s, pos, &limit, sublen, distance, length);
  _Bool tmp_if_expr_2;
  if(!(return_value_TryGetFromLongestMatchCache_1 == 0))
    /* assertion pos + *length <= size */
    assert(pos + (unsigned long int)*length <= size);

  else
  {
    /* assertion limit <= 258 */
    assert(limit <= (unsigned long int)258);
    /* assertion limit >= 3 */
    assert(limit >= (unsigned long int)3);
    /* assertion pos < size */
    assert(pos < size);
    if(!(size + -pos >= 3ul))
    {
      *length = (unsigned short int)0;
      *distance = (unsigned short int)0;
    }

    else
    {
      if(!(size >= limit + pos))
        limit = size - pos;

      arrayend = &array[(signed long int)pos] + (signed long int)limit;
      arrayend_safe = arrayend - (signed long int)8;
      /* assertion hval < 65536 */
      assert(hval < 65536);
      pp = (unsigned short int)hhead[(signed long int)hval];
      p = hprev[(signed long int)pp];
      /* assertion pp == hpos */
      assert(pp == hpos);
      dist = (unsigned int)((signed int)p < (signed int)pp ? (signed int)pp - (signed int)p : (32768 - (signed int)p) + (signed int)pp);
      while(!(dist >= 32768u))
      {
        unsigned short int currentlength = (unsigned short int)0;
        /* assertion p < 32768 */
        assert((signed int)p < 32768);
        /* assertion p == hprev[pp] */
        assert(p == hprev[(signed long int)pp]);
        /* assertion hhashval[p] == hval */
        assert(hhashval[(signed long int)p] == hval);
        if(dist >= 1u)
        {
          /* assertion pos < size */
          assert(pos < size);
          /* assertion dist <= pos */
          assert((unsigned long int)dist <= pos);
          scan = &array[(signed long int)pos];
          match = &array[(signed long int)(pos - (unsigned long int)dist)];
          if(pos + (unsigned long int)bestlength >= size)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = scan[(signed long int)bestlength] == match[(signed long int)bestlength] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            unsigned short int same0 = h->same[(signed long int)(pos & (unsigned long int)(32768 - 1))];
            if((signed int)same0 >= 3)
            {
              if(*scan == *match)
              {
                unsigned short int same1 = h->same[(signed long int)(pos - (unsigned long int)dist & (unsigned long int)(32768 - 1))];
                unsigned short int same = (unsigned short int)((signed int)same0 < (signed int)same1 ? (signed int)same0 : (signed int)same1);
                if(!(limit >= (unsigned long int)same))
                  same = (unsigned short int)limit;

                scan = scan + (signed long int)same;
                match = match + (signed long int)same;
              }

            }

            scan=GetMatch(scan, match, arrayend, arrayend_safe);
            currentlength = (unsigned short int)(scan - &array[(signed long int)pos]);
          }

          if(!((signed int)bestlength >= (signed int)currentlength))
          {
            if(!(sublen == ((unsigned short int *)NULL)))
            {
              unsigned short int j = (unsigned short int)((signed int)bestlength + 1);
              for( ; (signed int)currentlength >= (signed int)j; j = j + 1)
                sublen[(signed long int)j] = (unsigned short int)dist;
            }

            bestdist = (unsigned short int)dist;
            bestlength = currentlength;
            if((unsigned long int)currentlength >= limit)
              break;

          }

        }

        if(!(hhead == h->head2))
        {
          if((signed int)bestlength >= (signed int)h->same[(signed long int)hpos])
          {
            if(h->val2 == h->hashval2[(signed long int)p])
            {
              hhead = h->head2;
              hprev = h->prev2;
              hhashval = h->hashval2;
              hval = h->val2;
            }

          }

        }

        pp = p;
        p = hprev[(signed long int)p];
        if(p == pp)
          break;

        dist = dist + (unsigned int)((signed int)p < (signed int)pp ? (signed int)pp - (signed int)p : (32768 - (signed int)p) + (signed int)pp);
        chain_counter = chain_counter - 1;
        if(!(chain_counter >= 1))
          break;

      }
      StoreInLongestMatchCache(s, pos, limit, sublen, bestdist, bestlength);
      /* assertion bestlength <= limit */
      assert((unsigned long int)bestlength <= limit);
      *distance = bestdist;
      *length = bestlength;
      /* assertion pos + *length <= size */
      assert(pos + (unsigned long int)*length <= size);
    }
  }
}

// ZopfliGetDistExtraBits
// file zopfli/src/zopfli/util.h line 135
signed int ZopfliGetDistExtraBits(signed int dist)
{
  if(!(dist >= 5))
    return 0;

  else
  {
    signed int return_value___builtin_clz_1;
    return_value___builtin_clz_1=__builtin_clz((unsigned int)(dist - 1));
    return (31 ^ return_value___builtin_clz_1) - 1;
  }
}

// ZopfliGetDistExtraBitsValue
// file zopfli/src/zopfli/util.h line 138
signed int ZopfliGetDistExtraBitsValue(signed int dist)
{
  if(!(dist >= 5))
    return 0;

  else
  {
    signed int l;
    signed int return_value___builtin_clz_1;
    return_value___builtin_clz_1=__builtin_clz((unsigned int)(dist - 1));
    l = 31 ^ return_value___builtin_clz_1;
    return dist - (1 + (1 << l)) & (1 << l - 1) - 1;
  }
}

// ZopfliGetDistSymbol
// file zopfli/src/zopfli/util.h line 132
signed int ZopfliGetDistSymbol(signed int dist)
{
  if(!(dist >= 5))
    return dist - 1;

  else
  {
    signed int l;
    signed int return_value___builtin_clz_1;
    return_value___builtin_clz_1=__builtin_clz((unsigned int)(dist - 1));
    l = 31 ^ return_value___builtin_clz_1;
    signed int r = dist - 1 >> l - 1 & 1;
    return l * 2 + r;
  }
}

// ZopfliGetLengthExtraBits
// file zopfli/src/zopfli/util.h line 126
signed int ZopfliGetLengthExtraBits(signed int l)
{
  static const signed int table[259l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0 };
  return table[(signed long int)l];
}

// ZopfliGetLengthExtraBitsValue
// file zopfli/src/zopfli/util.h line 129
signed int ZopfliGetLengthExtraBitsValue(signed int l)
{
  static const signed int table[259l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 0 };
  return table[(signed long int)l];
}

// ZopfliGetLengthSymbol
// file zopfli/src/zopfli/util.h line 123
signed int ZopfliGetLengthSymbol(signed int l)
{
  static const signed int table[259l] = { 0, 0, 0, 257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285 };
  return table[(signed long int)l];
}

// ZopfliInitCache
// file zopfli/src/zopfli/cache.h line 46
void ZopfliInitCache(unsigned long int blocksize, struct ZopfliLongestMatchCache *lmc)
{
  unsigned long int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * blocksize);
  lmc->length = (unsigned short int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned short int) /*2ul*/  * blocksize);
  lmc->dist = (unsigned short int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(8 * 3) * blocksize);
  lmc->sublen = (unsigned char *)return_value_malloc_3;
  i = (unsigned long int)0;
  for( ; !(i >= blocksize); i = i + 1ul)
    lmc->length[(signed long int)i] = (unsigned short int)1;
  i = (unsigned long int)0;
  for( ; !(i >= blocksize); i = i + 1ul)
    lmc->dist[(signed long int)i] = (unsigned short int)0;
  i = (unsigned long int)0;
  for( ; !(i >= 24ul * blocksize); i = i + 1ul)
    lmc->sublen[(signed long int)i] = (unsigned char)0;
}

// ZopfliInitHash
// file zopfli/src/zopfli/hash.h line 50
void ZopfliInitHash(unsigned long int window_size, struct ZopfliHash *h)
{
  unsigned long int i;
  h->val = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)65536);
  h->head = (signed int *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned short int) /*2ul*/  * window_size);
  h->prev = (unsigned short int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * window_size);
  h->hashval = (signed int *)return_value_malloc_3;
  i = (unsigned long int)0;
  for( ; !(i >= 65536ul); i = i + 1ul)
    h->head[(signed long int)i] = -1;
  i = (unsigned long int)0;
  for( ; !(i >= window_size); i = i + 1ul)
  {
    h->prev[(signed long int)i] = (unsigned short int)i;
    h->hashval[(signed long int)i] = -1;
  }
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(unsigned short int) /*2ul*/  * window_size);
  h->same = (unsigned short int *)return_value_malloc_4;
  i = (unsigned long int)0;
  for( ; !(i >= window_size); i = i + 1ul)
    h->same[(signed long int)i] = (unsigned short int)0;
  h->val2 = 0;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)65536);
  h->head2 = (signed int *)return_value_malloc_5;
  void *return_value_malloc_6;
  return_value_malloc_6=malloc(sizeof(unsigned short int) /*2ul*/  * window_size);
  h->prev2 = (unsigned short int *)return_value_malloc_6;
  void *return_value_malloc_7;
  return_value_malloc_7=malloc(sizeof(signed int) /*4ul*/  * window_size);
  h->hashval2 = (signed int *)return_value_malloc_7;
  i = (unsigned long int)0;
  for( ; !(i >= 65536ul); i = i + 1ul)
    h->head2[(signed long int)i] = -1;
  i = (unsigned long int)0;
  for( ; !(i >= window_size); i = i + 1ul)
  {
    h->prev2[(signed long int)i] = (unsigned short int)i;
    h->hashval2[(signed long int)i] = -1;
  }
}

// ZopfliInitLZ77Store
// file zopfli/src/zopfli/lz77.h line 51
void ZopfliInitLZ77Store(struct ZopfliLZ77Store *store)
{
  store->size = (unsigned long int)0;
  store->litlens = ((unsigned short int *)NULL);
  store->dists = ((unsigned short int *)NULL);
}

// ZopfliInitOptions
// file zopfli/src/zopfli/zopfli.h line 70
void ZopfliInitOptions(struct ZopfliOptions *options)
{
  options->verbose = 0;
  options->verbose_more = 0;
  options->numiterations = 15;
  options->blocksplitting = 1;
  options->blocksplittinglast = 0;
  options->blocksplittingmax = 15;
}

// ZopfliLZ77Counts
// file zopfli/src/zopfli/lz77.h line 113
void ZopfliLZ77Counts(const unsigned short int *litlens, const unsigned short int *dists, unsigned long int start, unsigned long int end, unsigned long int *ll_count, unsigned long int *d_count)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 288ul); i = i + 1ul)
    ll_count[(signed long int)i] = (unsigned long int)0;
  i = (unsigned long int)0;
  for( ; !(i >= 32ul); i = i + 1ul)
    d_count[(signed long int)i] = (unsigned long int)0;
  i = start;
  for( ; !(i >= end); i = i + 1ul)
    if((signed int)dists[(signed long int)i] == 0)
      ll_count[(signed long int)litlens[(signed long int)i]] = ll_count[(signed long int)litlens[(signed long int)i]] + 1ul;

    else
    {
      signed int return_value_ZopfliGetLengthSymbol_1;
      return_value_ZopfliGetLengthSymbol_1=ZopfliGetLengthSymbol((signed int)litlens[(signed long int)i]);
      ll_count[(signed long int)return_value_ZopfliGetLengthSymbol_1] = ll_count[(signed long int)return_value_ZopfliGetLengthSymbol_1] + 1ul;
      signed int return_value_ZopfliGetDistSymbol_2;
      return_value_ZopfliGetDistSymbol_2=ZopfliGetDistSymbol((signed int)dists[(signed long int)i]);
      d_count[(signed long int)return_value_ZopfliGetDistSymbol_2] = d_count[(signed long int)return_value_ZopfliGetDistSymbol_2] + 1ul;
    }
  ll_count[(signed long int)256] = (unsigned long int)1;
}

// ZopfliLZ77Greedy
// file zopfli/src/zopfli/lz77.h line 125
void ZopfliLZ77Greedy(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store)
{
  unsigned long int i = (unsigned long int)0;
  unsigned long int j;
  unsigned short int leng;
  unsigned short int dist;
  signed int lengthscore;
  unsigned long int windowstart = instart > (unsigned long int)32768 ? instart - (unsigned long int)32768 : (unsigned long int)0;
  unsigned short int dummysublen[259l];
  struct ZopfliHash hash;
  struct ZopfliHash *h = &hash;
  unsigned int prev_length = (unsigned int)0;
  unsigned int prev_match = (unsigned int)0;
  signed int prevlengthscore;
  signed int match_available = 0;
  if(!(instart == inend))
  {
    ZopfliInitHash((unsigned long int)32768, h);
    ZopfliWarmupHash(in, windowstart, inend, h);
    i = windowstart;
    for( ; !(i >= instart); i = i + 1ul)
      ZopfliUpdateHash(in, i, inend, h);
    i = instart;
    for( ; !(i >= inend); i = i + 1ul)
    {
      ZopfliUpdateHash(in, i, inend, h);
      ZopfliFindLongestMatch(s, h, in, i, inend, (unsigned long int)258, dummysublen, &dist, &leng);
      lengthscore=GetLengthScore((signed int)leng, (signed int)dist);
      prevlengthscore=GetLengthScore((signed int)prev_length, (signed int)prev_match);
      if(!(match_available == 0))
      {
        match_available = 0;
        if(!(1 + prevlengthscore >= lengthscore))
        {
          ZopfliStoreLitLenDist((unsigned short int)in[(signed long int)(i - (unsigned long int)1)], (unsigned short int)0, store);
          if(lengthscore >= 3 && !((signed int)leng >= 258))
          {
            match_available = 1;
            prev_length = (unsigned int)leng;
            prev_match = (unsigned int)dist;
            goto __CPROVER_DUMP_L15;
          }

        }

        else
        {
          leng = (unsigned short int)prev_length;
          dist = (unsigned short int)prev_match;
          lengthscore = prevlengthscore;
          ZopfliVerifyLenDist(in, inend, i - (unsigned long int)1, dist, leng);
          ZopfliStoreLitLenDist(leng, dist, store);
          j = (unsigned long int)2;
          for( ; !(j >= (unsigned long int)leng); j = j + 1ul)
          {
            /* assertion i < inend */
            assert(i < inend);
            i = i + 1ul;
            ZopfliUpdateHash(in, i, inend, h);
          }
          goto __CPROVER_DUMP_L15;
        }
      }

      else
        if(lengthscore >= 3 && !((signed int)leng >= 258))
        {
          match_available = 1;
          prev_length = (unsigned int)leng;
          prev_match = (unsigned int)dist;
          goto __CPROVER_DUMP_L15;
        }

      if(lengthscore >= 3)
      {
        ZopfliVerifyLenDist(in, inend, i, dist, leng);
        ZopfliStoreLitLenDist(leng, dist, store);
      }

      else
      {
        leng = (unsigned short int)1;
        ZopfliStoreLitLenDist((unsigned short int)in[(signed long int)i], (unsigned short int)0, store);
      }
      j = (unsigned long int)1;
      for( ; !(j >= (unsigned long int)leng); j = j + 1ul)
      {
        /* assertion i < inend */
        assert(i < inend);
        i = i + 1ul;
        ZopfliUpdateHash(in, i, inend, h);
      }

    __CPROVER_DUMP_L15:
      ;
    }
    ZopfliCleanHash(h);
  }

}

// ZopfliLZ77Optimal
// file zopfli/src/zopfli/squeeze.h line 41
void ZopfliLZ77Optimal(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store)
{
  unsigned long int blocksize = inend - instart;
  unsigned short int *length_array;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (blocksize + (unsigned long int)1));
  length_array = (unsigned short int *)return_value_malloc_1;
  unsigned short int *path = ((unsigned short int *)NULL);
  unsigned long int pathsize = (unsigned long int)0;
  struct ZopfliLZ77Store currentstore;
  struct SymbolStats stats;
  struct SymbolStats beststats;
  struct SymbolStats laststats;
  signed int i;
  double cost;
  double bestcost = 1e30;
  double lastcost = (double)0;
  struct RanState ran_state;
  signed int lastrandomstep = -1;
  if(length_array == ((unsigned short int *)NULL))
    exit(-1);

  InitRanState(&ran_state);
  InitStats(&stats);
  ZopfliInitLZ77Store(&currentstore);
  ZopfliLZ77Greedy(s, in, instart, inend, &currentstore);
  GetStatistics(&currentstore, &stats);
  i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= s->options->numiterations); i = i + 1)
  {
    ZopfliCleanLZ77Store(&currentstore);
    ZopfliInitLZ77Store(&currentstore);
    LZ77OptimalRun(s, in, instart, inend, &path, &pathsize, length_array, GetCostStat, (void *)&stats, &currentstore);
    cost=ZopfliCalculateBlockSize(currentstore.litlens, currentstore.dists, (unsigned long int)0, currentstore.size, 2);
    if(!(s->options->verbose_more == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (s->options->verbose != 0 ? (cost < bestcost ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      fprintf(stderr, "Iteration %d: %d bit\n", i, (signed int)cost);

    if(cost < bestcost)
    {
      ZopfliCopyLZ77Store(&currentstore, store);
      CopyStats(&stats, &beststats);
      bestcost = cost;
    }

    CopyStats(&stats, &laststats);
    ClearStatFreqs(&stats);
    GetStatistics(&currentstore, &stats);
    if(!(lastrandomstep == -1))
    {
      AddWeighedStatFreqs(&stats, 1.0, &laststats, 0.5, &stats);
      CalculateStatistics(&stats);
    }

    if(i >= 6 && IEEE_FLOAT_EQUAL(cost, lastcost))
    {
      CopyStats(&beststats, &stats);
      RandomizeStatFreqs(&ran_state, &stats);
      CalculateStatistics(&stats);
      lastrandomstep = i;
    }

    lastcost = cost;
  }
  free((void *)length_array);
  free((void *)path);
  ZopfliCleanLZ77Store(&currentstore);
}

// ZopfliLZ77OptimalFixed
// file zopfli/src/zopfli/squeeze.h line 55
void ZopfliLZ77OptimalFixed(struct ZopfliBlockState *s, const unsigned char *in, unsigned long int instart, unsigned long int inend, struct ZopfliLZ77Store *store)
{
  unsigned long int blocksize = inend - instart;
  unsigned short int *length_array;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/  * (blocksize + (unsigned long int)1));
  length_array = (unsigned short int *)return_value_malloc_1;
  unsigned short int *path = ((unsigned short int *)NULL);
  unsigned long int pathsize = (unsigned long int)0;
  if(length_array == ((unsigned short int *)NULL))
    exit(-1);

  s->blockstart = instart;
  s->blockend = inend;
  LZ77OptimalRun(s, in, instart, inend, &path, &pathsize, length_array, GetCostFixed, NULL, store);
  free((void *)length_array);
  free((void *)path);
}

// ZopfliLengthLimitedCodeLengths
// file zopfli/src/zopfli/katajainen.h line 39
signed int ZopfliLengthLimitedCodeLengths(const unsigned long int *frequencies, signed int n, signed int maxbits, unsigned int *bitlengths)
{
  struct NodePool pool;
  signed int i;
  signed int numsymbols = 0;
  signed int numBoundaryPMRuns;
  struct Node *(*lists)[2l];
  struct Node *leaves;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)n * sizeof(struct Node) /*24ul*/ );
  leaves = (struct Node *)return_value_malloc_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    bitlengths[(signed long int)i] = (unsigned int)0;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    if(!(frequencies[(signed long int)i] == 0ul))
    {
      (leaves + (signed long int)numsymbols)->weight = frequencies[(signed long int)i];
      (leaves + (signed long int)numsymbols)->count = i;
      numsymbols = numsymbols + 1;
    }

  if(!(1 << maxbits >= numsymbols))
  {
    free((void *)leaves);
    return 1;
  }

  else
    if(numsymbols == 0)
    {
      free((void *)leaves);
      return 0;
    }

    else
      if(numsymbols == 1)
      {
        bitlengths[(signed long int)(leaves + (signed long int)0)->count] = (unsigned int)1;
        free((void *)leaves);
        return 0;
      }

      else
      {
        qsort((void *)leaves, (unsigned long int)numsymbols, sizeof(struct Node) /*24ul*/ , LeafComparator);
        pool.size = 2 * maxbits * (maxbits + 1);
        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)pool.size * sizeof(struct Node) /*24ul*/ );
        pool.nodes = (struct Node *)return_value_malloc_2;
        pool.next = pool.nodes;
        i = 0;
        for( ; !(i >= pool.size); i = i + 1)
          (pool.nodes + (signed long int)i)->inuse = (char)0;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)maxbits * sizeof(struct Node *[2l]) /*16ul*/ );
        lists = (struct Node *(*)[2l])return_value_malloc_3;
        InitLists(&pool, leaves, maxbits, lists);
        numBoundaryPMRuns = 2 * numsymbols - 4;
        i = 0;
        for( ; !(i >= numBoundaryPMRuns); i = i + 1)
        {
          char final = (char)(i == numBoundaryPMRuns - 1);
          BoundaryPM(lists, maxbits, leaves, numsymbols, &pool, maxbits - 1, final);
        }
        ExtractBitLengths(lists[(signed long int)(maxbits - 1)][(signed long int)1], leaves, bitlengths);
        free((void *)lists);
        free((void *)leaves);
        free((void *)pool.nodes);
        return 0;
      }
}

// ZopfliLengthsToSymbols
// file zopfli/src/zopfli/tree.h line 39
void ZopfliLengthsToSymbols(const unsigned int *lengths, unsigned long int n, unsigned int maxbits, unsigned int *symbols)
{
  unsigned long int *bl_count;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(maxbits + (unsigned int)1));
  bl_count = (unsigned long int *)return_value_malloc_1;
  unsigned long int *next_code;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)(maxbits + (unsigned int)1));
  next_code = (unsigned long int *)return_value_malloc_2;
  unsigned int bits;
  unsigned int i;
  unsigned int code;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= n); i = i + 1u)
    symbols[(signed long int)i] = (unsigned int)0;
  bits = (unsigned int)0;
  for( ; maxbits >= bits; bits = bits + 1u)
    bl_count[(signed long int)bits] = (unsigned long int)0;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= n); i = i + 1u)
  {
    /* assertion lengths[i] <= maxbits */
    assert(lengths[(signed long int)i] <= maxbits);
    bl_count[(signed long int)lengths[(signed long int)i]] = bl_count[(signed long int)lengths[(signed long int)i]] + 1ul;
  }
  code = (unsigned int)0;
  bl_count[(signed long int)0] = (unsigned long int)0;
  bits = (unsigned int)1;
  for( ; maxbits >= bits; bits = bits + 1u)
  {
    code = (unsigned int)((unsigned long int)code + bl_count[(signed long int)(bits - (unsigned int)1)] << 1);
    next_code[(signed long int)bits] = (unsigned long int)code;
  }
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= n); i = i + 1u)
  {
    unsigned int len = lengths[(signed long int)i];
    if(!(len == 0u))
    {
      symbols[(signed long int)i] = (unsigned int)next_code[(signed long int)len];
      next_code[(signed long int)len] = next_code[(signed long int)len] + 1ul;
    }

  }
  free((void *)bl_count);
  free((void *)next_code);
}

// ZopfliMaxCachedSublen
// file zopfli/src/zopfli/cache.h line 61
unsigned int ZopfliMaxCachedSublen(const struct ZopfliLongestMatchCache *lmc, unsigned long int pos, unsigned long int length)
{
  unsigned char *cache = &lmc->sublen[(signed long int)((unsigned long int)8 * pos * (unsigned long int)3)];
  (void)length;
  if((signed int)cache[1l] == 0)
  {
    if(!((signed int)cache[2l] == 0))
      goto __CPROVER_DUMP_L1;

    return (unsigned int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (unsigned int)((signed int)cache[(signed long int)((8 - 1) * 3)] + 3);
  }
}

// ZopfliStoreLitLenDist
// file zopfli/src/zopfli/lz77.c line 59
void ZopfliStoreLitLenDist(unsigned short int length, unsigned short int dist, struct ZopfliLZ77Store *store)
{
  unsigned long int size2 = store->size;
  void *tmp_if_expr_3;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if((store->size + 18446744073709551615ul & store->size) == 0ul)
  {
    if(store->size == 0ul)
    {
      return_value_malloc_1=malloc(sizeof(unsigned short int) /*2ul*/ );
      tmp_if_expr_3 = return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)*(&store->litlens), *(&store->size) * (unsigned long int)2 * sizeof(unsigned short int) /*2ul*/ );
      tmp_if_expr_3 = return_value_realloc_2;
    }
    *(&store->litlens) = (unsigned short int *)tmp_if_expr_3;
  }

  (*(&store->litlens))[(signed long int)*(&store->size)] = length;
  *(&store->size) = *(&store->size) + 1ul;
  void *tmp_if_expr_6;
  void *return_value_malloc_4;
  void *return_value_realloc_5;
  if((size2 + 18446744073709551615ul & size2) == 0ul)
  {
    if(size2 == 0ul)
    {
      return_value_malloc_4=malloc(sizeof(unsigned short int) /*2ul*/ );
      tmp_if_expr_6 = return_value_malloc_4;
    }

    else
    {
      return_value_realloc_5=realloc((void *)*(&store->dists), *(&size2) * (unsigned long int)2 * sizeof(unsigned short int) /*2ul*/ );
      tmp_if_expr_6 = return_value_realloc_5;
    }
    *(&store->dists) = (unsigned short int *)tmp_if_expr_6;
  }

  (*(&store->dists))[(signed long int)*(&size2)] = dist;
  *(&size2) = *(&size2) + 1ul;
}

// ZopfliSublenToCache
// file zopfli/src/zopfli/cache.h line 52
void ZopfliSublenToCache(const unsigned short int *sublen, unsigned long int pos, unsigned long int length, struct ZopfliLongestMatchCache *lmc)
{
  unsigned long int i;
  unsigned long int j = (unsigned long int)0;
  unsigned int bestlength = (unsigned int)0;
  unsigned char *cache = &lmc->sublen[(signed long int)((unsigned long int)8 * pos * (unsigned long int)3)];
  _Bool tmp_if_expr_1;
  if(length >= 3ul)
  {
    i = (unsigned long int)3;
    for( ; length >= i; i = i + 1ul)
    {
      if(i == length)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = sublen[(signed long int)i] != sublen[(signed long int)(i + (unsigned long int)1)] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        cache[(signed long int)(j * (unsigned long int)3)] = (unsigned char)(i - (unsigned long int)3);
        cache[(signed long int)(j * (unsigned long int)3 + (unsigned long int)1)] = (unsigned char)((signed int)sublen[(signed long int)i] % 256);
        cache[(signed long int)(j * (unsigned long int)3 + (unsigned long int)2)] = (unsigned char)(((signed int)sublen[(signed long int)i] >> 8) % 256);
        bestlength = (unsigned int)i;
        j = j + 1ul;
        if(j >= 8ul)
          break;

      }

    }
    if(!(j >= 8ul))
    {
      /* assertion bestlength == length */
      assert((unsigned long int)bestlength == length);
      cache[(signed long int)((8 - 1) * 3)] = (unsigned char)(bestlength - (unsigned int)3);
    }

    else
      /* assertion bestlength <= length */
      assert((unsigned long int)bestlength <= length);
    unsigned int return_value_ZopfliMaxCachedSublen_2;
    return_value_ZopfliMaxCachedSublen_2=ZopfliMaxCachedSublen(lmc, pos, length);
    /* assertion bestlength == ZopfliMaxCachedSublen(lmc, pos, length) */
    assert(bestlength == return_value_ZopfliMaxCachedSublen_2);
  }

}

// ZopfliUpdateHash
// file zopfli/src/zopfli/hash.h line 59
void ZopfliUpdateHash(const unsigned char *array, unsigned long int pos, unsigned long int end, struct ZopfliHash *h)
{
  unsigned short int hpos = (unsigned short int)(pos & (unsigned long int)(32768 - 1));
  unsigned long int amount = (unsigned long int)0;
  signed int tmp_if_expr_1;
  if(end >= 3ul + pos)
    tmp_if_expr_1 = (signed int)array[(signed long int)((pos + (unsigned long int)3) - (unsigned long int)1)];

  else
    tmp_if_expr_1 = 0;
  UpdateHashValue(h, (unsigned char)tmp_if_expr_1);
  h->hashval[(signed long int)hpos] = h->val;
  _Bool tmp_if_expr_2;
  if(!(h->head[(signed long int)h->val] == -1))
    tmp_if_expr_2 = h->hashval[(signed long int)h->head[(signed long int)h->val]] == h->val ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    h->prev[(signed long int)hpos] = (unsigned short int)h->head[(signed long int)h->val];

  else
    h->prev[(signed long int)hpos] = hpos;
  h->head[(signed long int)h->val] = (signed int)hpos;
  if((signed int)h->same[-1l + (signed long int)pos & 32767l] >= 2)
    amount = (unsigned long int)((signed int)h->same[(signed long int)(pos - (unsigned long int)1 & (unsigned long int)(32768 - 1))] - 1);

  for( ; !(1ul + amount + pos >= end); amount = amount + 1ul)
  {
    if(!(array[(signed long int)pos] == array[1l + (signed long int)amount + (signed long int)pos]))
      break;

    if(amount >= 65535ul)
      break;

  }
  h->same[(signed long int)hpos] = (unsigned short int)amount;
  h->val2 = (signed int)h->same[(signed long int)hpos] - 3 & 255 ^ h->val;
  h->hashval2[(signed long int)hpos] = h->val2;
  _Bool tmp_if_expr_3;
  if(!(h->head2[(signed long int)h->val2] == -1))
    tmp_if_expr_3 = h->hashval2[(signed long int)h->head2[(signed long int)h->val2]] == h->val2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    h->prev2[(signed long int)hpos] = (unsigned short int)h->head2[(signed long int)h->val2];

  else
    h->prev2[(signed long int)hpos] = hpos;
  h->head2[(signed long int)h->val2] = (signed int)hpos;
}

// ZopfliVerifyLenDist
// file zopfli/src/zopfli/lz77.c line 95
void ZopfliVerifyLenDist(const unsigned char *data, unsigned long int datasize, unsigned long int pos, unsigned short int dist, unsigned short int length)
{
  unsigned long int i;
  /* assertion pos + length <= datasize */
  assert(pos + (unsigned long int)length <= datasize);
  i = (unsigned long int)0;
  for( ; !(i >= (unsigned long int)length); i = i + 1ul)
    if(!(data[(signed long int)i + (signed long int)pos + -((signed long int)(unsigned long int)dist)] == data[(signed long int)i + (signed long int)pos]))
    {
      /* assertion data[pos - dist + i] == data[pos + i] */
      assert(data[(signed long int)((pos - (unsigned long int)dist) + i)] == data[(signed long int)(pos + i)]);
      break;
    }

}

// ZopfliWarmupHash
// file zopfli/src/zopfli/hash.h line 67
void ZopfliWarmupHash(const unsigned char *array, unsigned long int pos, unsigned long int end, struct ZopfliHash *h)
{
  (void)end;
  UpdateHashValue(h, array[(signed long int)(pos + (unsigned long int)0)]);
  UpdateHashValue(h, array[(signed long int)(pos + (unsigned long int)1)]);
}

// adler32_comb
// file pigz.c line 1192
static unsigned long int adler32_comb(unsigned long int adler1, unsigned long int adler2, unsigned long int len2)
{
  unsigned long int sum1;
  unsigned long int sum2;
  unsigned int rem = (unsigned int)(len2 % (unsigned long int)65521U);
  sum1 = adler1 & (unsigned long int)0xffff;
  sum2 = ((unsigned long int)rem * sum1) % (unsigned long int)65521U;
  sum1 = sum1 + (((adler2 & (unsigned long int)0xffff) + (unsigned long int)65521U) - (unsigned long int)1);
  sum2 = sum2 + (((adler1 >> 16 & (unsigned long int)0xffff) + (adler2 >> 16 & (unsigned long int)0xffff) + (unsigned long int)65521U) - (unsigned long int)rem);
  if(sum1 >= 65521ul)
    sum1 = sum1 - (unsigned long int)65521U;

  if(sum1 >= 65521ul)
    sum1 = sum1 - (unsigned long int)65521U;

  if(sum2 >= 131042ul)
    sum2 = sum2 - (unsigned long int)(65521U << 1);

  if(sum2 >= 65521ul)
    sum2 = sum2 - (unsigned long int)65521U;

  return sum1 | sum2 << 16;
}

// alloc
// file pigz.c line 656
static void * alloc(void *ptr, unsigned long int size)
{
  ptr=realloc(ptr, size);
  if(ptr == NULL)
    try_throw_(12, "not enough memory", (void *)0);

  return ptr;
}

// append_len
// file pigz.c line 1792
static void append_len(struct job *job, unsigned long int len)
{
  struct space *lens;
  /* assertion len < 539000896UL */
  assert(len < 539000896UL);
  if(job->lens == ((struct space *)NULL))
    job->lens=get_space(&lens_pool);

  lens = job->lens;
  if(!(lens->size >= 3ul + lens->len))
    grow_space(lens);

  unsigned long int tmp_post_1;
  unsigned long int tmp_post_2;
  unsigned long int tmp_post_3;
  unsigned long int tmp_post_4;
  unsigned long int tmp_post_5;
  unsigned long int tmp_post_6;
  unsigned long int tmp_post_7;
  unsigned long int tmp_post_8;
  unsigned long int tmp_post_9;
  unsigned long int tmp_post_10;
  if(!(len >= 64ul))
  {
    tmp_post_1 = lens->len;
    lens->len = lens->len + 1ul;
    lens->buf[(signed long int)tmp_post_1] = (unsigned char)(len + (unsigned long int)128);
  }

  else
    if(!(len >= 32832ul))
    {
      len = len - (unsigned long int)64;
      tmp_post_2 = lens->len;
      lens->len = lens->len + 1ul;
      lens->buf[(signed long int)tmp_post_2] = (unsigned char)(len >> 8);
      tmp_post_3 = lens->len;
      lens->len = lens->len + 1ul;
      lens->buf[(signed long int)tmp_post_3] = (unsigned char)len;
    }

    else
      if(!(len >= 2129984UL))
      {
        len = len - (unsigned long int)32832U;
        tmp_post_4 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_4] = (unsigned char)((len >> 16) + (unsigned long int)192);
        tmp_post_5 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_5] = (unsigned char)(len >> 8);
        tmp_post_6 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_6] = (unsigned char)len;
      }

      else
      {
        len = len - 2129984UL;
        tmp_post_7 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_7] = (unsigned char)((len >> 24) + (unsigned long int)224);
        tmp_post_8 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_8] = (unsigned char)(len >> 16);
        tmp_post_9 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_9] = (unsigned char)(len >> 8);
        tmp_post_10 = lens->len;
        lens->len = lens->len + 1ul;
        lens->buf[(signed long int)tmp_post_10] = (unsigned char)len;
      }
}

// cat
// file pigz.c line 2877
static void cat(void)
{
  writen(g.outd, &g.magic1, (unsigned long int)1);
  g.out_tot = (signed long int)1;
  while(!(g.in_left == 0ul))
  {
    writen(g.outd, g.in_next, g.in_left);
    g.out_tot = g.out_tot + (signed long int)g.in_left;
    g.in_left = (unsigned long int)0;
    load();
  }
}

// complain
// file pigz.c line 528
static signed int complain(char *fmt, ...)
{
  void **ap;
  if(g.verbosity >= 1)
  {
    fprintf(stderr, "%s: ", g.prog);
    ap = (void **)&fmt;
    vfprintf(stderr, fmt, ap);
    ap = ((void **)NULL);
    _IO_putc(10, stderr);
    fflush(stderr);
  }

  return 0;
}

// compress_thread
// file pigz.c line 1482
static void compress_thread(void *dummy)
{
  struct job *job;
  struct job *here;
  struct job **prior;
  unsigned long int check;
  unsigned char *next;
  unsigned long int left;
  unsigned long int len;
  signed int bits;
  struct space *temp = (struct space *)(void *)0;
  signed int ret;
  struct z_stream_s strm;
  struct anonymous err;
  (void)dummy;
  unsigned char *tmp_if_expr_2;
  signed int tmp_if_expr_4;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_19;
  unsigned long int tmp_post_13;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_15;
  unsigned long int tmp_post_16;
  unsigned long int tmp_post_17;
  unsigned long int tmp_post_18;
  unsigned long int tmp_if_expr_22;
  unsigned long int return_value_adler32_20;
  unsigned long int return_value_crc32_21;
  unsigned long int tmp_if_expr_25;
  unsigned long int return_value_adler32_23;
  unsigned long int return_value_crc32_24;
  unsigned long int tmp_if_expr_28;
  unsigned long int return_value_adler32_26;
  unsigned long int return_value_crc32_27;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int compress_thread__1__1__1__try_ret_;
      compress_thread__1__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(compress_thread__1__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_29;
    return_value__setjmp_29=_setjmp(try_this_.env);
    if(!(return_value__setjmp_29 >= 2))
      do
      {
        strm.zfree = ((void (*)(void *, void *))NULL);
        strm.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
        strm.opaque = NULL;
        ret=deflateInit2_(&strm, 6, 8, -15, 8, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
        if(ret == -4)
          try_throw_(12, "not enough memory", (void *)0);

        if(!(ret == 0))
          try_throw_(22, "internal error", (void *)0);

        do
        {
          possess(compress_have);
          wait_for(compress_have, (enum wait_op)NOT_TO_BE, (signed long int)0);
          job = compress_head;
          /* assertion job != ((void *)0) */
          assert(job != (struct job *)(void *)0);
          if(job->seq == -1l)
            break;

          compress_head = job->next;
          if(job->next == ((struct job *)NULL))
            compress_tail = &compress_head;

          twist(compress_have, (enum twist_op)BY, (signed long int)-1);
          if(!(g.level >= 10))
          {
            deflateReset(&strm);
            deflateParams(&strm, g.level, 0);
          }

          else
          {
            if(temp == ((struct space *)NULL))
              temp=get_space(&out_pool);

            temp->len = (unsigned long int)0;
          }
          if(!(job->out == ((struct space *)NULL)))
          {
            len = job->out->len;
            left = len < (unsigned long int)32768U ? len : (unsigned long int)32768U;
            if(!(g.level >= 10))
              deflateSetDictionary(&strm, job->out->buf + (signed long int)(len - left), (unsigned int)left);

            else
            {
              memcpy((void *)temp->buf, (const void *)(job->out->buf + (signed long int)(len - left)), left);
              temp->len = left;
            }
            drop_space(job->out);
          }

          job->out=get_space(&out_pool);
          if(!(g.level >= 10))
          {
            strm.next_in = job->in->buf;
            strm.next_out = job->out->buf;
          }

          else
            memcpy((void *)(temp->buf + (signed long int)temp->len), (const void *)job->in->buf, job->in->len);
          if(job->lens == ((struct space *)NULL))
            tmp_if_expr_2 = (unsigned char *)(void *)0;

          else
            tmp_if_expr_2 = job->lens->buf;
          next = tmp_if_expr_2;
          left = job->in->len;
          job->out->len = (unsigned long int)0;
          do
          {
            if(next == ((unsigned char *)NULL))
              tmp_if_expr_4 = 128;

            else
            {
              tmp_post_3 = next;
              next = next + 1l;
              tmp_if_expr_4 = (signed int)*tmp_post_3;
            }
            len = (unsigned long int)tmp_if_expr_4;
            if(!(len >= 128ul))
            {
              tmp_post_5 = next;
              next = next + 1l;
              len = (len << 8) + (unsigned long int)*tmp_post_5 + (unsigned long int)64;
            }

            else
              if(len == 128ul)
                len = left;

              else
                if(!(len >= 192ul))
                  len = len & (unsigned long int)0x3f;

                else
                  if(!(len >= 224ul))
                  {
                    tmp_post_6 = next;
                    next = next + 1l;
                    len = ((len & (unsigned long int)0x1f) << 16) + (unsigned long int)((signed int)*tmp_post_6 << 8);
                    tmp_post_7 = next;
                    next = next + 1l;
                    len = len + (unsigned long int)((unsigned int)*tmp_post_7 + 32832U);
                  }

                  else
                  {
                    tmp_post_8 = next;
                    next = next + 1l;
                    len = ((len & (unsigned long int)0x1f) << 24) + (unsigned long int)((signed int)*tmp_post_8 << 16);
                    tmp_post_9 = next;
                    next = next + 1l;
                    len = len + (unsigned long int)((signed int)*tmp_post_9 << 8);
                    tmp_post_10 = next;
                    next = next + 1l;
                    len = len + (unsigned long int)*tmp_post_10 + 2129984UL;
                  }
            left = left - len;
            if(!(g.level >= 10))
            {
              for( ; len >= 2147483649ul; len = len - (unsigned long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1)))
              {
                strm.avail_in = ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1);
                deflate_engine(&strm, job->out, 0);
              }
              strm.avail_in = (unsigned int)len;
              if(!(left == 0ul))
                tmp_if_expr_11 = (_Bool)1;

              else
                tmp_if_expr_11 = job->more != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_11)
              {
                deflate_engine(&strm, job->out, 5);
                deflatePending(&strm, ((unsigned int *)NULL), &bits);
                if(!((1 & bits) == 0))
                  deflate_engine(&strm, job->out, 2);

                else
                  if(!((7 & bits) == 0))
                  {
                    do
                    {
                      bits=deflatePrime(&strm, 10, 2);
                      /* assertion bits == 0 */
                      assert(bits == 0);
                      deflatePending(&strm, ((unsigned int *)NULL), &bits);
                    }
                    while(!((7 & bits) == 0));
                    deflate_engine(&strm, job->out, 5);
                  }

              }

              else
                deflate_engine(&strm, job->out, 4);
            }

            else
            {
              unsigned char compress_thread__1__1__2__1__1__1__5__4__bits;
              unsigned char *out;
              unsigned long int outsize;
              out = (unsigned char *)(void *)0;
              outsize = (unsigned long int)0;
              compress_thread__1__1__2__1__1__1__5__4__bits = (unsigned char)0;
              if(!(left == 0ul))
                tmp_if_expr_12 = (_Bool)1;

              else
                tmp_if_expr_12 = job->more != 0 ? (_Bool)1 : (_Bool)0;
              ZopfliDeflatePart(&g.zopts, 2, (signed int)!tmp_if_expr_12, temp->buf, temp->len, temp->len + len, &compress_thread__1__1__2__1__1__1__5__4__bits, &out, &outsize);
              /* assertion job->out->len + outsize + 5 <= job->out->size */
              assert(job->out->len + outsize + (unsigned long int)5 <= job->out->size);
              memcpy((void *)(job->out->buf + (signed long int)job->out->len), (const void *)out, outsize);
              free((void *)out);
              job->out->len = job->out->len + outsize;
              if(!(left == 0ul))
                tmp_if_expr_19 = (_Bool)1;

              else
                tmp_if_expr_19 = job->more != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_19)
              {
                compress_thread__1__1__2__1__1__1__5__4__bits = compress_thread__1__1__2__1__1__1__5__4__bits & (unsigned char)7;
                if(!((1 & (signed int)compress_thread__1__1__2__1__1__1__5__4__bits) == 0))
                {
                  if((signed int)compress_thread__1__1__2__1__1__1__5__4__bits == 7)
                  {
                    tmp_post_13 = job->out->len;
                    job->out->len = job->out->len + 1ul;
                    job->out->buf[(signed long int)tmp_post_13] = (unsigned char)0;
                  }

                  tmp_post_14 = job->out->len;
                  job->out->len = job->out->len + 1ul;
                  job->out->buf[(signed long int)tmp_post_14] = (unsigned char)0;
                  tmp_post_15 = job->out->len;
                  job->out->len = job->out->len + 1ul;
                  job->out->buf[(signed long int)tmp_post_15] = (unsigned char)0;
                  tmp_post_16 = job->out->len;
                  job->out->len = job->out->len + 1ul;
                  job->out->buf[(signed long int)tmp_post_16] = (unsigned char)0xff;
                  tmp_post_17 = job->out->len;
                  job->out->len = job->out->len + 1ul;
                  job->out->buf[(signed long int)tmp_post_17] = (unsigned char)0xff;
                }

                else
                  if(!(compress_thread__1__1__2__1__1__1__5__4__bits == 0))
                    do
                    {
                      job->out->buf[(signed long int)(job->out->len - (unsigned long int)1)] = job->out->buf[(signed long int)(job->out->len - (unsigned long int)1)] + (unsigned char)(2 << (signed int)compress_thread__1__1__2__1__1__1__5__4__bits);
                      tmp_post_18 = job->out->len;
                      job->out->len = job->out->len + 1ul;
                      job->out->buf[(signed long int)tmp_post_18] = (unsigned char)0;
                      compress_thread__1__1__2__1__1__1__5__4__bits = compress_thread__1__1__2__1__1__1__5__4__bits + (unsigned char)2;
                    }
                    while(!((signed int)compress_thread__1__1__2__1__1__1__5__4__bits >= 8));

              }

              temp->len = temp->len + len;
            }
          }
          while(!(left == 0ul));
          drop_space(job->lens);
          job->lens = (struct space *)(void *)0;
          use_space(job->in);
          possess(write_first);
          prior = &write_head;
          do
          {
            here = *prior;
            if(here == ((struct job *)NULL))
              break;

            if(!(job->seq >= here->seq))
              break;

            prior = &here->next;
          }
          while((_Bool)1);
          job->next = here;
          *prior = job;
          twist(write_first, (enum twist_op)TO, write_head->seq);
          len = job->in->len;
          next = job->in->buf;
          if(g.form == 1)
          {
            return_value_adler32_20=adler32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
            tmp_if_expr_22 = return_value_adler32_20;
          }

          else
          {
            return_value_crc32_21=crc32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
            tmp_if_expr_22 = return_value_crc32_21;
          }
          check = tmp_if_expr_22;
          while(len >= 2147483649ul)
          {
            if(g.form == 1)
            {
              return_value_adler32_23=adler32(check, next, ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
              tmp_if_expr_25 = return_value_adler32_23;
            }

            else
            {
              return_value_crc32_24=crc32(check, next, ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
              tmp_if_expr_25 = return_value_crc32_24;
            }
            check = tmp_if_expr_25;
            len = len - (unsigned long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
            next = next + (signed long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
          }
          if(g.form == 1)
          {
            return_value_adler32_26=adler32(check, next, (unsigned int)len);
            tmp_if_expr_28 = return_value_adler32_26;
          }

          else
          {
            return_value_crc32_27=crc32(check, next, (unsigned int)len);
            tmp_if_expr_28 = return_value_crc32_27;
          }
          check = tmp_if_expr_28;
          drop_space(job->in);
          job->check = check;
          possess(job->calc);
          twist(job->calc, (enum twist_op)TO, (signed long int)1);
        }
        while((_Bool)1);
        drop_space(temp);
        release(compress_have);
        deflateEnd(&strm);
      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

}

// compressed_suffix
// file pigz.c line 2642
static unsigned long int compressed_suffix(char *nm)
{
  unsigned long int len;
  len=strlen(nm);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(len >= 5ul)
  {
    nm = nm + (signed long int)(len - (unsigned long int)4);
    len = (unsigned long int)4;
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(nm, ".zip");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(nm, ".ZIP");
      tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(nm, ".tgz");
      tmp_if_expr_5 = return_value_strcmp_4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return (unsigned long int)4;

  }

  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_7;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  if(len >= 4ul)
  {
    nm = nm + (signed long int)(len - (unsigned long int)3);
    len = (unsigned long int)3;
    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(nm, ".gz");
    if(return_value_strcmp_6 == 0)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_strcmp_7=strcmp(nm, "-gz");
      tmp_if_expr_8 = return_value_strcmp_7 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(nm, ".zz");
      tmp_if_expr_10 = return_value_strcmp_9 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      return_value_strcmp_11=strcmp(nm, "-zz");
      tmp_if_expr_12 = return_value_strcmp_11 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_12)
      return (unsigned long int)3;

  }

  _Bool tmp_if_expr_15;
  signed int return_value_strcmp_14;
  _Bool tmp_if_expr_17;
  signed int return_value_strcmp_16;
  _Bool tmp_if_expr_19;
  signed int return_value_strcmp_18;
  if(len >= 3ul)
  {
    nm = nm + (signed long int)(len - (unsigned long int)2);
    signed int return_value_strcmp_13;
    return_value_strcmp_13=strcmp(nm, ".z");
    if(return_value_strcmp_13 == 0)
      tmp_if_expr_15 = (_Bool)1;

    else
    {
      return_value_strcmp_14=strcmp(nm, "-z");
      tmp_if_expr_15 = return_value_strcmp_14 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_15)
      tmp_if_expr_17 = (_Bool)1;

    else
    {
      return_value_strcmp_16=strcmp(nm, "_z");
      tmp_if_expr_17 = return_value_strcmp_16 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_17)
      tmp_if_expr_19 = (_Bool)1;

    else
    {
      return_value_strcmp_18=strcmp(nm, ".Z");
      tmp_if_expr_19 = return_value_strcmp_18 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_19)
      return (unsigned long int)2;

  }

  return (unsigned long int)0;
}

// copymeta
// file pigz.c line 3386
static void copymeta(char *from, char *to)
{
  struct stat st;
  struct timeval times[2l];
  signed int return_value_stat_1;
  return_value_stat_1=stat(from, &st);
  if((61440u & st.st_mode) == 32768u && return_value_stat_1 == 0)
  {
    chmod(to, st.st_mode & (unsigned int)07777);
    chown(to, st.st_uid, st.st_gid);
    times[(signed long int)0].tv_sec = st.st_atim.tv_sec;
    times[(signed long int)0].tv_usec = (signed long int)0;
    times[(signed long int)1].tv_sec = st.st_mtim.tv_sec;
    times[(signed long int)1].tv_usec = (signed long int)0;
    utimes(to, times);
  }

}

// crc32_comb
// file pigz.c line 1136
static unsigned long int crc32_comb(unsigned long int crc1, unsigned long int crc2, unsigned long int len2)
{
  signed int n;
  unsigned long int row;
  unsigned long int even[32l];
  unsigned long int odd[32l];
  if(len2 == 0ul)
    return crc1;

  else
  {
    odd[(signed long int)0] = 0xedb88320UL;
    row = (unsigned long int)1;
    n = 1;
    for( ; !(n >= 32); n = n + 1)
    {
      odd[(signed long int)n] = row;
      row = row << 1;
    }
    gf2_matrix_square(even, odd);
    gf2_matrix_square(odd, even);
    do
    {
      gf2_matrix_square(even, odd);
      if(!((1ul & len2) == 0ul))
        crc1=gf2_matrix_times(even, crc1);

      len2 = len2 >> 1;
      if(len2 == 0ul)
        break;

      gf2_matrix_square(odd, even);
      if(!((1ul & len2) == 0ul))
        crc1=gf2_matrix_times(odd, crc1);

      len2 = len2 >> 1;
    }
    while(!(len2 == 0ul));
    crc1 = crc1 ^ crc2;
    return crc1;
  }
}

// cut_short
// file pigz.c line 824
static void cut_short(signed int sig)
{
  if(!(g.outd == 1) && !(g.outd == -1))
  {
    unlink(g.outf);
    do
      if(!(g.outf == ((char *)NULL)))
      {
        free((void *)g.outf);
        g.outf = (char *)(void *)0;
      }

    while((_Bool)0);
    g.outd = -1;
  }

  _exit(sig < 0 ? -sig : 125);
}

// cut_yarn
// file pigz.c line 4049
static void cut_yarn(signed int err)
{
  try_throw_(err, err == 12 ? "not enough memory" : "internal threads error", (void *)0);
}

// defaults
// file pigz.c line 3826
static void defaults(void)
{
  g.level = -1;
  ZopfliInitOptions(&g.zopts);
  g.procs=nprocs(8);
  g.block = 131072UL;
  g.rsync = 0;
  g.setdict = 1;
  g.verbosity = 1;
  g.headis = 3;
  g.pipeout = 0;
  g.sufx = ".gz";
  g.decode = 0;
  g.list = 0;
  g.keep = 0;
  g.force = 0;
  g.recurse = 0;
  g.form = 0;
}

// deflate_engine
// file pigz.c line 1459
static void deflate_engine(struct z_stream_s *strm, struct space *out, signed int flush)
{
  unsigned long int room;
  do
  {
    room = out->size - out->len;
    if(room == 0ul)
    {
      grow_space(out);
      room = out->size - out->len;
    }

    strm->next_out = out->buf + (signed long int)out->len;
    strm->avail_out = room < (unsigned long int)((unsigned int)0x7fffffff * 2U + 1U) ? (unsigned int)room : (unsigned int)0x7fffffff * 2U + 1U;
    deflate(strm, flush);
    out->len = (unsigned long int)(strm->next_out - out->buf);
  }
  while(strm->avail_out == 0u);
  /* assertion strm->avail_in == 0 */
  assert(strm->avail_in == (unsigned int)0);
}

// destruct
// file yarn.h line 121
void destruct(struct thread_s *off_course)
{
  signed int ret;
  ret=pthread_cancel(off_course->id);
  if(!(ret == 0))
    fail(ret);

  join(off_course);
}

// dos2time
// file pigz.c line 2415
static signed long int dos2time(unsigned long int dos)
{
  struct tm tm;
  signed long int return_value_time_1;
  if(dos == 0ul)
  {
    return_value_time_1=time((signed long int *)(void *)0);
    return return_value_time_1;
  }

  else
  {
    tm.tm_year = ((signed int)(dos >> 25) & 0x7f) + 80;
    tm.tm_mon = ((signed int)(dos >> 21) & 0xf) - 1;
    tm.tm_mday = (signed int)(dos >> 16) & 0x1f;
    tm.tm_hour = (signed int)(dos >> 11) & 0x1f;
    tm.tm_min = (signed int)(dos >> 5) & 0x3f;
    tm.tm_sec = (signed int)(dos << 1) & 0x3e;
    tm.tm_isdst = -1;
    signed long int return_value_mktime_2;
    return_value_mktime_2=mktime(&tm);
    return return_value_mktime_2;
  }
}

// drop_space
// file pigz.c line 1315
static void drop_space(struct space *space)
{
  signed int use;
  struct pool *pool;
  if(!(space == ((struct space *)NULL)))
  {
    possess(space->use);
    signed long int return_value_peek_lock_1;
    return_value_peek_lock_1=peek_lock(space->use);
    use = (signed int)return_value_peek_lock_1;
    /* assertion use != 0 */
    assert(use != 0);
    if(use == 1)
    {
      pool = space->pool;
      possess(pool->have);
      space->next = pool->head;
      pool->head = space;
      twist(pool->have, (enum twist_op)BY, (signed long int)+1);
    }

    twist(space->use, (enum twist_op)BY, (signed long int)-1);
  }

}

// fail
// file yarn.c line 57
static void fail(signed int err)
{
  if(!(yarn_abort == ((void (*)(signed int))NULL)))
    yarn_abort(err);

  fprintf(stderr, "%s: %s (%d) -- aborting\n", yarn_prefix, err == 12 ? "out of memory" : "internal pthread error", err);
  exit(err == 12 || err == 11 ? err : 22);
}

// finish_jobs
// file pigz.c line 1418
static void finish_jobs(void)
{
  struct job job;
  signed int caught;
  if(!(compress_have == ((struct lock_s *)NULL)))
  {
    possess(compress_have);
    job.seq = (signed long int)-1;
    job.next = (struct job *)(void *)0;
    compress_head = &job;
    compress_tail = &job.next;
    twist(compress_have, (enum twist_op)BY, (signed long int)+1);
    caught=join_all();
    /* assertion caught == cthreads */
    assert(caught == cthreads);
    cthreads = 0;
    caught=free_pool(&lens_pool);
    caught=free_pool(&dict_pool);
    caught=free_pool(&out_pool);
    caught=free_pool(&in_pool);
    free_lock(write_first);
    free_lock(compress_have);
    compress_have = (struct lock_s *)(void *)0;
  }

}

// free_lock
// file yarn.h line 134
void free_lock(struct lock_s *bolt)
{
  signed int ret;
  _Bool tmp_if_expr_1;
  if(!(bolt == ((struct lock_s *)NULL)))
  {
    ret=pthread_cond_destroy(&bolt->cond);
    if(!(ret == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      ret=pthread_mutex_destroy(&bolt->mutex);
      tmp_if_expr_1 = ret != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      fail(ret);

    my_free((void *)bolt);
  }

}

// free_pool
// file pigz.c line 1337
static signed int free_pool(struct pool *pool)
{
  signed int count;
  struct space *space;
  possess(pool->have);
  count = 0;
  do
  {
    space = pool->head;
    if(space == ((struct space *)NULL))
      break;

    pool->head = space->next;
    free((void *)space->buf);
    free_lock(space->use);
    free((void *)space);
    count = count + 1;
  }
  while((_Bool)1);
  /* assertion count == pool->made */
  assert(count == pool->made);
  release(pool->have);
  free_lock(pool->have);
  return count;
}

// get_header
// file pigz.c line 2498
static signed int get_header(signed int save)
{
  unsigned int magic;
  signed int method;
  signed int flags;
  unsigned int fname;
  unsigned int extra;
  unsigned int tmp2;
  unsigned long int tmp4;
  unsigned long int crc;
  if(!(save == 0))
  {
    g.stamp = (signed long int)0;
    do
      if(!(g.hname == ((char *)NULL)))
      {
        free((void *)g.hname);
        g.hname = (char *)(void *)0;
      }

    while((_Bool)0);
  }

  g.form = -1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_load_1;
  if(g.in_left == 0ul)
  {
    if(!(g.in_eof == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_load_1=load();
      tmp_if_expr_2 = return_value_load_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  signed int tmp_if_expr_5;
  unsigned char *tmp_post_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = 0;

  else
  {
    g.in_left = g.in_left - 1ul;
    tmp_post_4 = g.in_next;
    g.in_next = g.in_next + 1l;
    tmp_if_expr_5 = (signed int)*tmp_post_4;
  }
  g.magic1 = (unsigned char)tmp_if_expr_5;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_load_6;
  signed int tmp_if_expr_10;
  unsigned char *tmp_post_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_load_11;
  signed int tmp_if_expr_15;
  unsigned char *tmp_post_14;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  unsigned long int return_value_load_16;
  signed int tmp_if_expr_20;
  unsigned char *tmp_post_19;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_23;
  unsigned long int return_value_load_22;
  signed int tmp_if_expr_26;
  unsigned char *tmp_post_25;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_28;
  unsigned long int return_value_load_27;
  signed int tmp_if_expr_31;
  unsigned char *tmp_post_30;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_33;
  unsigned long int return_value_load_32;
  signed int tmp_if_expr_36;
  unsigned char *tmp_post_35;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_38;
  unsigned long int return_value_load_37;
  signed int tmp_if_expr_41;
  unsigned char *tmp_post_40;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_43;
  unsigned long int return_value_load_42;
  signed int tmp_if_expr_46;
  unsigned char *tmp_post_45;
  _Bool tmp_if_expr_49;
  _Bool tmp_if_expr_48;
  unsigned long int return_value_load_47;
  signed int tmp_if_expr_51;
  unsigned char *tmp_post_50;
  _Bool tmp_if_expr_54;
  _Bool tmp_if_expr_53;
  unsigned long int return_value_load_52;
  signed int tmp_if_expr_56;
  unsigned char *tmp_post_55;
  _Bool tmp_if_expr_59;
  _Bool tmp_if_expr_58;
  unsigned long int return_value_load_57;
  signed int tmp_if_expr_61;
  unsigned char *tmp_post_60;
  _Bool tmp_if_expr_65;
  _Bool tmp_if_expr_64;
  unsigned long int return_value_load_63;
  signed int tmp_if_expr_67;
  unsigned char *tmp_post_66;
  _Bool tmp_if_expr_70;
  _Bool tmp_if_expr_69;
  unsigned long int return_value_load_68;
  signed int tmp_if_expr_72;
  unsigned char *tmp_post_71;
  _Bool tmp_if_expr_75;
  _Bool tmp_if_expr_74;
  unsigned long int return_value_load_73;
  signed int tmp_if_expr_77;
  unsigned char *tmp_post_76;
  _Bool tmp_if_expr_80;
  _Bool tmp_if_expr_79;
  unsigned long int return_value_load_78;
  signed int tmp_if_expr_82;
  unsigned char *tmp_post_81;
  _Bool tmp_if_expr_85;
  _Bool tmp_if_expr_84;
  unsigned long int return_value_load_83;
  signed int tmp_if_expr_87;
  unsigned char *tmp_post_86;
  _Bool tmp_if_expr_90;
  _Bool tmp_if_expr_89;
  unsigned long int return_value_load_88;
  signed int tmp_if_expr_92;
  unsigned char *tmp_post_91;
  _Bool tmp_if_expr_95;
  _Bool tmp_if_expr_94;
  unsigned long int return_value_load_93;
  signed int tmp_if_expr_97;
  unsigned char *tmp_post_96;
  _Bool tmp_if_expr_100;
  _Bool tmp_if_expr_99;
  unsigned long int return_value_load_98;
  signed int tmp_if_expr_102;
  unsigned char *tmp_post_101;
  _Bool tmp_if_expr_105;
  _Bool tmp_if_expr_104;
  unsigned long int return_value_load_103;
  signed int tmp_if_expr_107;
  unsigned char *tmp_post_106;
  _Bool tmp_if_expr_110;
  _Bool tmp_if_expr_109;
  unsigned long int return_value_load_108;
  signed int tmp_if_expr_112;
  unsigned char *tmp_post_111;
  _Bool tmp_if_expr_115;
  _Bool tmp_if_expr_114;
  unsigned long int return_value_load_113;
  signed int tmp_if_expr_117;
  unsigned char *tmp_post_116;
  _Bool tmp_if_expr_120;
  _Bool tmp_if_expr_119;
  unsigned long int return_value_load_118;
  signed int tmp_if_expr_122;
  unsigned char *tmp_post_121;
  _Bool tmp_if_expr_125;
  _Bool tmp_if_expr_124;
  unsigned long int return_value_load_123;
  signed int tmp_if_expr_127;
  unsigned char *tmp_post_126;
  _Bool tmp_if_expr_130;
  _Bool tmp_if_expr_129;
  unsigned long int return_value_load_128;
  signed int tmp_if_expr_132;
  unsigned char *tmp_post_131;
  _Bool tmp_if_expr_135;
  _Bool tmp_if_expr_134;
  unsigned long int return_value_load_133;
  signed int tmp_if_expr_137;
  unsigned char *tmp_post_136;
  _Bool tmp_if_expr_140;
  _Bool tmp_if_expr_139;
  unsigned long int return_value_load_138;
  signed int tmp_if_expr_142;
  unsigned char *tmp_post_141;
  _Bool tmp_if_expr_148;
  _Bool tmp_if_expr_147;
  unsigned long int return_value_load_146;
  signed int tmp_if_expr_150;
  unsigned char *tmp_post_149;
  _Bool tmp_if_expr_153;
  _Bool tmp_if_expr_152;
  unsigned long int return_value_load_151;
  signed int tmp_if_expr_155;
  unsigned char *tmp_post_154;
  _Bool tmp_if_expr_158;
  _Bool tmp_if_expr_157;
  unsigned long int return_value_load_156;
  signed int tmp_if_expr_160;
  unsigned char *tmp_post_159;
  _Bool tmp_if_expr_163;
  _Bool tmp_if_expr_162;
  unsigned long int return_value_load_161;
  signed int tmp_if_expr_165;
  unsigned char *tmp_post_164;
  _Bool tmp_if_expr_168;
  _Bool tmp_if_expr_167;
  unsigned long int return_value_load_166;
  signed int tmp_if_expr_170;
  unsigned char *tmp_post_169;
  _Bool tmp_if_expr_173;
  _Bool tmp_if_expr_172;
  unsigned long int return_value_load_171;
  signed int tmp_if_expr_175;
  unsigned char *tmp_post_174;
  _Bool tmp_if_expr_180;
  _Bool tmp_if_expr_179;
  unsigned long int return_value_load_178;
  signed int tmp_if_expr_182;
  unsigned char *tmp_post_181;
  _Bool tmp_if_expr_185;
  _Bool tmp_if_expr_184;
  unsigned long int return_value_load_183;
  signed int tmp_if_expr_187;
  unsigned char *tmp_post_186;
  unsigned long int return_value_load_189;
  _Bool tmp_if_expr_193;
  _Bool tmp_if_expr_192;
  unsigned long int return_value_load_191;
  signed int tmp_if_expr_195;
  unsigned char *tmp_post_194;
  _Bool tmp_if_expr_198;
  _Bool tmp_if_expr_197;
  unsigned long int return_value_load_196;
  signed int tmp_if_expr_200;
  unsigned char *tmp_post_199;
  _Bool tmp_if_expr_203;
  _Bool tmp_if_expr_202;
  unsigned long int return_value_load_201;
  signed int tmp_if_expr_205;
  unsigned char *tmp_post_204;
  _Bool tmp_if_expr_208;
  _Bool tmp_if_expr_207;
  unsigned long int return_value_load_206;
  signed int tmp_if_expr_210;
  unsigned char *tmp_post_209;
  if(!(g.in_eof == 0))
    return -1;

  else
  {
    magic = (unsigned int)((signed int)g.magic1 << 8);
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_load_6=load();
        tmp_if_expr_7 = return_value_load_6 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_10 = 0;

    else
    {
      g.in_left = g.in_left - 1ul;
      tmp_post_9 = g.in_next;
      g.in_next = g.in_next + 1l;
      tmp_if_expr_10 = (signed int)*tmp_post_9;
    }
    magic = magic + (unsigned int)tmp_if_expr_10;
    if(!(g.in_eof == 0))
      return -2;

    else
      if((36640u & magic) == 2048u && magic % 31u == 0u)
      {
        g.form = 1;
        return 8;
      }

      else
        if(magic == 8093u)
          return 257;

        else
        {
          if(magic == 20555u)
          {
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_12 = (_Bool)1;

              else
              {
                return_value_load_11=load();
                tmp_if_expr_12 = return_value_load_11 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_13 = (_Bool)0;
            if(tmp_if_expr_13)
              tmp_if_expr_15 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_14 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_15 = (signed int)*tmp_post_14;
            }
            tmp2 = (unsigned int)tmp_if_expr_15;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_17 = (_Bool)1;

              else
              {
                return_value_load_16=load();
                tmp_if_expr_17 = return_value_load_16 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_18 = (_Bool)0;
            if(tmp_if_expr_18)
              tmp_if_expr_20 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_19 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_20 = (signed int)*tmp_post_19;
            }
            magic = tmp2 + ((unsigned int)tmp_if_expr_20 << 8);
            if(!(g.in_eof == 0))
              return -3;

            if(magic == 513u || magic == 2054u)
              return -5;

            if(!(magic == 1027u))
              return -4;

            do
            {
              unsigned long int get_header__1__3__1__togo = (unsigned long int)2;
              while(!(g.in_left >= get_header__1__3__1__togo))
              {
                get_header__1__3__1__togo = get_header__1__3__1__togo - g.in_left;
                unsigned long int return_value_load_21;
                return_value_load_21=load();
                if(return_value_load_21 == 0ul)
                  return -3;

              }
              g.in_left = g.in_left - get_header__1__3__1__togo;
              g.in_next = g.in_next + (signed long int)get_header__1__3__1__togo;
            }
            while((_Bool)0);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_23 = (_Bool)1;

              else
              {
                return_value_load_22=load();
                tmp_if_expr_23 = return_value_load_22 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_24 = tmp_if_expr_23 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_24 = (_Bool)0;
            if(tmp_if_expr_24)
              tmp_if_expr_26 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_25 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_26 = (signed int)*tmp_post_25;
            }
            tmp2 = (unsigned int)tmp_if_expr_26;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_28 = (_Bool)1;

              else
              {
                return_value_load_27=load();
                tmp_if_expr_28 = return_value_load_27 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_29 = tmp_if_expr_28 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_29 = (_Bool)0;
            if(tmp_if_expr_29)
              tmp_if_expr_31 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_30 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_31 = (signed int)*tmp_post_30;
            }
            flags = (signed int)(tmp2 + ((unsigned int)tmp_if_expr_31 << 8));
            if(!((0xfff0 & flags) == 0))
              return -4;

            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_33 = (_Bool)1;

              else
              {
                return_value_load_32=load();
                tmp_if_expr_33 = return_value_load_32 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_34 = tmp_if_expr_33 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_34 = (_Bool)0;
            if(tmp_if_expr_34)
              tmp_if_expr_36 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_35 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_36 = (signed int)*tmp_post_35;
            }
            method = tmp_if_expr_36;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_38 = (_Bool)1;

              else
              {
                return_value_load_37=load();
                tmp_if_expr_38 = return_value_load_37 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_39 = tmp_if_expr_38 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_39 = (_Bool)0;
            if(tmp_if_expr_39)
              tmp_if_expr_41 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_40 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_41 = (signed int)*tmp_post_40;
            }
            if(!((1 & flags) == 0) || !(tmp_if_expr_41 == 0))
              method = 256;

            if(!(save == 0))
            {
              if(g.in_left == 0ul)
              {
                if(!(g.in_eof == 0))
                  tmp_if_expr_43 = (_Bool)1;

                else
                {
                  return_value_load_42=load();
                  tmp_if_expr_43 = return_value_load_42 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_44 = tmp_if_expr_43 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_44 = (_Bool)0;
              if(tmp_if_expr_44)
                tmp_if_expr_46 = 0;

              else
              {
                g.in_left = g.in_left - 1ul;
                tmp_post_45 = g.in_next;
                g.in_next = g.in_next + 1l;
                tmp_if_expr_46 = (signed int)*tmp_post_45;
              }
              tmp2 = (unsigned int)tmp_if_expr_46;
              if(g.in_left == 0ul)
              {
                if(!(g.in_eof == 0))
                  tmp_if_expr_48 = (_Bool)1;

                else
                {
                  return_value_load_47=load();
                  tmp_if_expr_48 = return_value_load_47 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_49 = tmp_if_expr_48 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_49 = (_Bool)0;
              if(tmp_if_expr_49)
                tmp_if_expr_51 = 0;

              else
              {
                g.in_left = g.in_left - 1ul;
                tmp_post_50 = g.in_next;
                g.in_next = g.in_next + 1l;
                tmp_if_expr_51 = (signed int)*tmp_post_50;
              }
              tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_51 << 8));
              if(g.in_left == 0ul)
              {
                if(!(g.in_eof == 0))
                  tmp_if_expr_53 = (_Bool)1;

                else
                {
                  return_value_load_52=load();
                  tmp_if_expr_53 = return_value_load_52 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_54 = tmp_if_expr_53 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_54 = (_Bool)0;
              if(tmp_if_expr_54)
                tmp_if_expr_56 = 0;

              else
              {
                g.in_left = g.in_left - 1ul;
                tmp_post_55 = g.in_next;
                g.in_next = g.in_next + 1l;
                tmp_if_expr_56 = (signed int)*tmp_post_55;
              }
              tmp2 = (unsigned int)tmp_if_expr_56;
              if(g.in_left == 0ul)
              {
                if(!(g.in_eof == 0))
                  tmp_if_expr_58 = (_Bool)1;

                else
                {
                  return_value_load_57=load();
                  tmp_if_expr_58 = return_value_load_57 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_59 = tmp_if_expr_58 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_59 = (_Bool)0;
              if(tmp_if_expr_59)
                tmp_if_expr_61 = 0;

              else
              {
                g.in_left = g.in_left - 1ul;
                tmp_post_60 = g.in_next;
                g.in_next = g.in_next + 1l;
                tmp_if_expr_61 = (signed int)*tmp_post_60;
              }
              g.stamp=dos2time(tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_61 << 8)) << 16));
            }

            else
              do
              {
                unsigned long int togo = (unsigned long int)4;
                while(!(g.in_left >= togo))
                {
                  togo = togo - g.in_left;
                  unsigned long int return_value_load_62;
                  return_value_load_62=load();
                  if(return_value_load_62 == 0ul)
                    return -3;

                }
                g.in_left = g.in_left - togo;
                g.in_next = g.in_next + (signed long int)togo;
              }
              while((_Bool)0);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_64 = (_Bool)1;

              else
              {
                return_value_load_63=load();
                tmp_if_expr_64 = return_value_load_63 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_65 = tmp_if_expr_64 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_65 = (_Bool)0;
            if(tmp_if_expr_65)
              tmp_if_expr_67 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_66 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_67 = (signed int)*tmp_post_66;
            }
            tmp2 = (unsigned int)tmp_if_expr_67;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_69 = (_Bool)1;

              else
              {
                return_value_load_68=load();
                tmp_if_expr_69 = return_value_load_68 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_70 = tmp_if_expr_69 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_70 = (_Bool)0;
            if(tmp_if_expr_70)
              tmp_if_expr_72 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_71 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_72 = (signed int)*tmp_post_71;
            }
            tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_72 << 8));
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_74 = (_Bool)1;

              else
              {
                return_value_load_73=load();
                tmp_if_expr_74 = return_value_load_73 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_75 = tmp_if_expr_74 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_75 = (_Bool)0;
            if(tmp_if_expr_75)
              tmp_if_expr_77 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_76 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_77 = (signed int)*tmp_post_76;
            }
            tmp2 = (unsigned int)tmp_if_expr_77;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_79 = (_Bool)1;

              else
              {
                return_value_load_78=load();
                tmp_if_expr_79 = return_value_load_78 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_80 = tmp_if_expr_79 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_80 = (_Bool)0;
            if(tmp_if_expr_80)
              tmp_if_expr_82 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_81 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_82 = (signed int)*tmp_post_81;
            }
            g.zip_crc = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_82 << 8)) << 16);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_84 = (_Bool)1;

              else
              {
                return_value_load_83=load();
                tmp_if_expr_84 = return_value_load_83 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_85 = tmp_if_expr_84 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_85 = (_Bool)0;
            if(tmp_if_expr_85)
              tmp_if_expr_87 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_86 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_87 = (signed int)*tmp_post_86;
            }
            tmp2 = (unsigned int)tmp_if_expr_87;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_89 = (_Bool)1;

              else
              {
                return_value_load_88=load();
                tmp_if_expr_89 = return_value_load_88 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_90 = tmp_if_expr_89 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_90 = (_Bool)0;
            if(tmp_if_expr_90)
              tmp_if_expr_92 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_91 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_92 = (signed int)*tmp_post_91;
            }
            tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_92 << 8));
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_94 = (_Bool)1;

              else
              {
                return_value_load_93=load();
                tmp_if_expr_94 = return_value_load_93 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_95 = tmp_if_expr_94 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_95 = (_Bool)0;
            if(tmp_if_expr_95)
              tmp_if_expr_97 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_96 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_97 = (signed int)*tmp_post_96;
            }
            tmp2 = (unsigned int)tmp_if_expr_97;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_99 = (_Bool)1;

              else
              {
                return_value_load_98=load();
                tmp_if_expr_99 = return_value_load_98 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_100 = tmp_if_expr_99 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_100 = (_Bool)0;
            if(tmp_if_expr_100)
              tmp_if_expr_102 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_101 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_102 = (signed int)*tmp_post_101;
            }
            g.zip_clen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_102 << 8)) << 16);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_104 = (_Bool)1;

              else
              {
                return_value_load_103=load();
                tmp_if_expr_104 = return_value_load_103 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_105 = tmp_if_expr_104 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_105 = (_Bool)0;
            if(tmp_if_expr_105)
              tmp_if_expr_107 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_106 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_107 = (signed int)*tmp_post_106;
            }
            tmp2 = (unsigned int)tmp_if_expr_107;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_109 = (_Bool)1;

              else
              {
                return_value_load_108=load();
                tmp_if_expr_109 = return_value_load_108 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_110 = tmp_if_expr_109 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_110 = (_Bool)0;
            if(tmp_if_expr_110)
              tmp_if_expr_112 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_111 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_112 = (signed int)*tmp_post_111;
            }
            tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_112 << 8));
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_114 = (_Bool)1;

              else
              {
                return_value_load_113=load();
                tmp_if_expr_114 = return_value_load_113 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_115 = tmp_if_expr_114 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_115 = (_Bool)0;
            if(tmp_if_expr_115)
              tmp_if_expr_117 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_116 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_117 = (signed int)*tmp_post_116;
            }
            tmp2 = (unsigned int)tmp_if_expr_117;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_119 = (_Bool)1;

              else
              {
                return_value_load_118=load();
                tmp_if_expr_119 = return_value_load_118 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_120 = tmp_if_expr_119 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_120 = (_Bool)0;
            if(tmp_if_expr_120)
              tmp_if_expr_122 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_121 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_122 = (signed int)*tmp_post_121;
            }
            g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_122 << 8)) << 16);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_124 = (_Bool)1;

              else
              {
                return_value_load_123=load();
                tmp_if_expr_124 = return_value_load_123 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_125 = tmp_if_expr_124 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_125 = (_Bool)0;
            if(tmp_if_expr_125)
              tmp_if_expr_127 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_126 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_127 = (signed int)*tmp_post_126;
            }
            tmp2 = (unsigned int)tmp_if_expr_127;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_129 = (_Bool)1;

              else
              {
                return_value_load_128=load();
                tmp_if_expr_129 = return_value_load_128 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_130 = tmp_if_expr_129 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_130 = (_Bool)0;
            if(tmp_if_expr_130)
              tmp_if_expr_132 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_131 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_132 = (signed int)*tmp_post_131;
            }
            fname = tmp2 + ((unsigned int)tmp_if_expr_132 << 8);
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_134 = (_Bool)1;

              else
              {
                return_value_load_133=load();
                tmp_if_expr_134 = return_value_load_133 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_135 = tmp_if_expr_134 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_135 = (_Bool)0;
            if(tmp_if_expr_135)
              tmp_if_expr_137 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_136 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_137 = (signed int)*tmp_post_136;
            }
            tmp2 = (unsigned int)tmp_if_expr_137;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_139 = (_Bool)1;

              else
              {
                return_value_load_138=load();
                tmp_if_expr_139 = return_value_load_138 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_140 = tmp_if_expr_139 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_140 = (_Bool)0;
            if(tmp_if_expr_140)
              tmp_if_expr_142 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_141 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_142 = (signed int)*tmp_post_141;
            }
            extra = tmp2 + ((unsigned int)tmp_if_expr_142 << 8);
            if(!(save == 0))
            {
              char *next;
              if(!(g.in_eof == 0))
                return -3;

              void *return_value_alloc_143;
              return_value_alloc_143=alloc((void *)0, (unsigned long int)(fname + (unsigned int)1));
              g.hname = (char *)return_value_alloc_143;
              next = g.hname;
              while(!(g.in_left >= (unsigned long int)fname))
              {
                memcpy((void *)next, (const void *)g.in_next, g.in_left);
                fname = fname - (unsigned int)g.in_left;
                next = next + (signed long int)g.in_left;
                unsigned long int return_value_load_144;
                return_value_load_144=load();
                if(return_value_load_144 == 0ul)
                  return -3;

              }
              memcpy((void *)next, (const void *)g.in_next, (unsigned long int)fname);
              g.in_left = g.in_left - (unsigned long int)fname;
              g.in_next = g.in_next + (signed long int)fname;
              next = next + (signed long int)fname;
              *next = (char)0;
            }

            else
              do
              {
                unsigned long int get_header__1__3__4__togo = (unsigned long int)fname;
                while(!(g.in_left >= get_header__1__3__4__togo))
                {
                  get_header__1__3__4__togo = get_header__1__3__4__togo - g.in_left;
                  unsigned long int return_value_load_145;
                  return_value_load_145=load();
                  if(return_value_load_145 == 0ul)
                    return -3;

                }
                g.in_left = g.in_left - get_header__1__3__4__togo;
                g.in_next = g.in_next + (signed long int)get_header__1__3__4__togo;
              }
              while((_Bool)0);
            read_extra(extra, save);
            g.form = 2 + ((flags & 8) >> 3);
            return g.in_eof != 0 ? -3 : method;
          }

          if(!(magic == 8075u))
          {
            g.in_left = g.in_left + 1ul;
            g.in_next = g.in_next - 1l;
            return -2;
          }

          else
          {
            crc = (unsigned long int)0xf6e946c9;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_147 = (_Bool)1;

              else
              {
                return_value_load_146=load();
                tmp_if_expr_147 = return_value_load_146 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_148 = tmp_if_expr_147 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_148 = (_Bool)0;
            if(tmp_if_expr_148)
              tmp_if_expr_150 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              crc=crc32(crc, g.in_next, (unsigned int)1);
              tmp_post_149 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_150 = (signed int)*tmp_post_149;
            }
            method = tmp_if_expr_150;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_152 = (_Bool)1;

              else
              {
                return_value_load_151=load();
                tmp_if_expr_152 = return_value_load_151 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_153 = tmp_if_expr_152 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_153 = (_Bool)0;
            if(tmp_if_expr_153)
              tmp_if_expr_155 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              crc=crc32(crc, g.in_next, (unsigned int)1);
              tmp_post_154 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_155 = (signed int)*tmp_post_154;
            }
            flags = tmp_if_expr_155;
            if(!((0xe0 & flags) == 0))
              return -4;

            else
            {
              if(!(save == 0))
              {
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_157 = (_Bool)1;

                  else
                  {
                    return_value_load_156=load();
                    tmp_if_expr_157 = return_value_load_156 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_158 = tmp_if_expr_157 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_158 = (_Bool)0;
                if(tmp_if_expr_158)
                  tmp_if_expr_160 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  crc=crc32(crc, g.in_next, (unsigned int)1);
                  tmp_post_159 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_160 = (signed int)*tmp_post_159;
                }
                tmp2 = (unsigned int)tmp_if_expr_160;
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_162 = (_Bool)1;

                  else
                  {
                    return_value_load_161=load();
                    tmp_if_expr_162 = return_value_load_161 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_163 = tmp_if_expr_162 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_163 = (_Bool)0;
                if(tmp_if_expr_163)
                  tmp_if_expr_165 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  crc=crc32(crc, g.in_next, (unsigned int)1);
                  tmp_post_164 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_165 = (signed int)*tmp_post_164;
                }
                tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_165 << 8));
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_167 = (_Bool)1;

                  else
                  {
                    return_value_load_166=load();
                    tmp_if_expr_167 = return_value_load_166 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_168 = tmp_if_expr_167 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_168 = (_Bool)0;
                if(tmp_if_expr_168)
                  tmp_if_expr_170 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  crc=crc32(crc, g.in_next, (unsigned int)1);
                  tmp_post_169 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_170 = (signed int)*tmp_post_169;
                }
                tmp2 = (unsigned int)tmp_if_expr_170;
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_172 = (_Bool)1;

                  else
                  {
                    return_value_load_171=load();
                    tmp_if_expr_172 = return_value_load_171 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_173 = tmp_if_expr_172 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_173 = (_Bool)0;
                if(tmp_if_expr_173)
                  tmp_if_expr_175 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  crc=crc32(crc, g.in_next, (unsigned int)1);
                  tmp_post_174 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_175 = (signed int)*tmp_post_174;
                }
                g.stamp=tolong(tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_175 << 8)) << 16));
              }

              else
                do
                {
                  unsigned long int get_header__1__5__togo = (unsigned long int)4;
                  while(!(g.in_left >= get_header__1__5__togo))
                  {
                    crc=crc32(crc, g.in_next, (unsigned int)g.in_left);
                    get_header__1__5__togo = get_header__1__5__togo - g.in_left;
                    unsigned long int return_value_load_176;
                    return_value_load_176=load();
                    if(return_value_load_176 == 0ul)
                      return -3;

                  }
                  crc=crc32(crc, g.in_next, (unsigned int)get_header__1__5__togo);
                  g.in_left = g.in_left - get_header__1__5__togo;
                  g.in_next = g.in_next + (signed long int)get_header__1__5__togo;
                }
                while((_Bool)0);
              do
              {
                unsigned long int get_header__1__6__togo = (unsigned long int)2;
                while(!(g.in_left >= get_header__1__6__togo))
                {
                  crc=crc32(crc, g.in_next, (unsigned int)g.in_left);
                  get_header__1__6__togo = get_header__1__6__togo - g.in_left;
                  unsigned long int return_value_load_177;
                  return_value_load_177=load();
                  if(return_value_load_177 == 0ul)
                    return -3;

                }
                crc=crc32(crc, g.in_next, (unsigned int)get_header__1__6__togo);
                g.in_left = g.in_left - get_header__1__6__togo;
                g.in_next = g.in_next + (signed long int)get_header__1__6__togo;
              }
              while((_Bool)0);
              if(!((4 & flags) == 0))
                do
                {
                  unsigned long int get_header__1__7__togo;
                  if(g.in_left == 0ul)
                  {
                    if(!(g.in_eof == 0))
                      tmp_if_expr_179 = (_Bool)1;

                    else
                    {
                      return_value_load_178=load();
                      tmp_if_expr_179 = return_value_load_178 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                    }
                    tmp_if_expr_180 = tmp_if_expr_179 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_180 = (_Bool)0;
                  if(tmp_if_expr_180)
                    tmp_if_expr_182 = 0;

                  else
                  {
                    g.in_left = g.in_left - 1ul;
                    crc=crc32(crc, g.in_next, (unsigned int)1);
                    tmp_post_181 = g.in_next;
                    g.in_next = g.in_next + 1l;
                    tmp_if_expr_182 = (signed int)*tmp_post_181;
                  }
                  tmp2 = (unsigned int)tmp_if_expr_182;
                  if(g.in_left == 0ul)
                  {
                    if(!(g.in_eof == 0))
                      tmp_if_expr_184 = (_Bool)1;

                    else
                    {
                      return_value_load_183=load();
                      tmp_if_expr_184 = return_value_load_183 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                    }
                    tmp_if_expr_185 = tmp_if_expr_184 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_185 = (_Bool)0;
                  if(tmp_if_expr_185)
                    tmp_if_expr_187 = 0;

                  else
                  {
                    g.in_left = g.in_left - 1ul;
                    crc=crc32(crc, g.in_next, (unsigned int)1);
                    tmp_post_186 = g.in_next;
                    g.in_next = g.in_next + 1l;
                    tmp_if_expr_187 = (signed int)*tmp_post_186;
                  }
                  get_header__1__7__togo = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_187 << 8));
                  while(!(g.in_left >= get_header__1__7__togo))
                  {
                    crc=crc32(crc, g.in_next, (unsigned int)g.in_left);
                    get_header__1__7__togo = get_header__1__7__togo - g.in_left;
                    unsigned long int return_value_load_188;
                    return_value_load_188=load();
                    if(return_value_load_188 == 0ul)
                      return -3;

                  }
                  crc=crc32(crc, g.in_next, (unsigned int)get_header__1__7__togo);
                  g.in_left = g.in_left - get_header__1__7__togo;
                  g.in_next = g.in_next + (signed long int)get_header__1__7__togo;
                }
                while((_Bool)0);

              if(!((8 & flags) == 0) && !(save == 0))
              {
                unsigned char *end;
                unsigned long int copy;
                unsigned long int have;
                unsigned long int size = (unsigned long int)0;
                have = (unsigned long int)0;
                while((_Bool)1)
                {
                  if(g.in_left == 0ul)
                  {
                    return_value_load_189=load();
                    if(return_value_load_189 == 0ul)
                      return -3;

                  }

                  void *return_value_memchr_190;
                  return_value_memchr_190=memchr((const void *)g.in_next, 0, g.in_left);
                  end = (unsigned char *)return_value_memchr_190;
                  copy = end == (unsigned char *)(void *)0 ? g.in_left : (unsigned long int)(end - g.in_next) + (unsigned long int)1;
                  have=vmemcpy(&g.hname, &size, have, (void *)g.in_next, copy);
                  g.in_left = g.in_left - copy;
                  g.in_next = g.in_next + (signed long int)copy;
                  if(!(end == ((unsigned char *)NULL)))
                    break;

                }
                crc=crc32(crc, (unsigned char *)g.hname, (unsigned int)have);
              }

              else
                if(!((8 & flags) == 0))
                  do
                  {
                    if(g.in_left == 0ul)
                    {
                      if(!(g.in_eof == 0))
                        tmp_if_expr_192 = (_Bool)1;

                      else
                      {
                        return_value_load_191=load();
                        tmp_if_expr_192 = return_value_load_191 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                      }
                      tmp_if_expr_193 = tmp_if_expr_192 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_193 = (_Bool)0;
                    if(tmp_if_expr_193)
                      tmp_if_expr_195 = 0;

                    else
                    {
                      g.in_left = g.in_left - 1ul;
                      crc=crc32(crc, g.in_next, (unsigned int)1);
                      tmp_post_194 = g.in_next;
                      g.in_next = g.in_next + 1l;
                      tmp_if_expr_195 = (signed int)*tmp_post_194;
                    }
                    if(tmp_if_expr_195 == 0)
                      break;

                  }
                  while((_Bool)1);

              if(!((16 & flags) == 0))
                do
                {
                  if(g.in_left == 0ul)
                  {
                    if(!(g.in_eof == 0))
                      tmp_if_expr_197 = (_Bool)1;

                    else
                    {
                      return_value_load_196=load();
                      tmp_if_expr_197 = return_value_load_196 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                    }
                    tmp_if_expr_198 = tmp_if_expr_197 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_198 = (_Bool)0;
                  if(tmp_if_expr_198)
                    tmp_if_expr_200 = 0;

                  else
                  {
                    g.in_left = g.in_left - 1ul;
                    crc=crc32(crc, g.in_next, (unsigned int)1);
                    tmp_post_199 = g.in_next;
                    g.in_next = g.in_next + 1l;
                    tmp_if_expr_200 = (signed int)*tmp_post_199;
                  }
                  if(tmp_if_expr_200 == 0)
                    break;

                }
                while((_Bool)1);

              if(!((2 & flags) == 0))
              {
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_202 = (_Bool)1;

                  else
                  {
                    return_value_load_201=load();
                    tmp_if_expr_202 = return_value_load_201 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_203 = tmp_if_expr_202 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_203 = (_Bool)0;
                if(tmp_if_expr_203)
                  tmp_if_expr_205 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  tmp_post_204 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_205 = (signed int)*tmp_post_204;
                }
                tmp2 = (unsigned int)tmp_if_expr_205;
                if(g.in_left == 0ul)
                {
                  if(!(g.in_eof == 0))
                    tmp_if_expr_207 = (_Bool)1;

                  else
                  {
                    return_value_load_206=load();
                    tmp_if_expr_207 = return_value_load_206 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
                  }
                  tmp_if_expr_208 = tmp_if_expr_207 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_208 = (_Bool)0;
                if(tmp_if_expr_208)
                  tmp_if_expr_210 = 0;

                else
                {
                  g.in_left = g.in_left - 1ul;
                  tmp_post_209 = g.in_next;
                  g.in_next = g.in_next + 1l;
                  tmp_if_expr_210 = (signed int)*tmp_post_209;
                }
                if((unsigned long int)(((unsigned int)tmp_if_expr_210 << 8) + tmp2) == (65535ul & crc))
                  goto __CPROVER_DUMP_L295;

                return -6;
              }

              else
              {

              __CPROVER_DUMP_L295:
                ;
                g.form = 0;
                return g.in_eof != 0 ? -3 : method;
              }
            }
          }
        }
  }
}

// get_space
// file pigz.c line 1256
static struct space * get_space(struct pool *pool)
{
  struct space *space;
  possess(pool->have);
  if(pool->limit == 0)
    wait_for(pool->have, (enum wait_op)NOT_TO_BE, (signed long int)0);

  if(!(pool->head == ((struct space *)NULL)))
  {
    space = pool->head;
    possess(space->use);
    pool->head = space->next;
    twist(pool->have, (enum twist_op)BY, (signed long int)-1);
    twist(space->use, (enum twist_op)TO, (signed long int)1);
    space->len = (unsigned long int)0;
    return space;
  }

  else
  {
    /* assertion pool->limit != 0 */
    assert(pool->limit != 0);
    if(pool->limit >= 1)
      pool->limit = pool->limit - 1;

    pool->made = pool->made + 1;
    release(pool->have);
    void *return_value_alloc_1;
    return_value_alloc_1=alloc((void *)0, sizeof(struct space) /*48ul*/ );
    space = (struct space *)return_value_alloc_1;
    space->use=new_lock((signed long int)1);
    void *return_value_alloc_2;
    return_value_alloc_2=alloc((void *)0, pool->size);
    space->buf = (unsigned char *)return_value_alloc_2;
    space->size = pool->size;
    space->len = (unsigned long int)0;
    space->pool = pool;
    return space;
  }
}

// gf2_matrix_square
// file pigz.c line 1128
static void gf2_matrix_square(unsigned long int *square, unsigned long int *mat)
{
  signed int n = 0;
  for( ; !(n >= 32); n = n + 1)
    square[(signed long int)n]=gf2_matrix_times(mat, mat[(signed long int)n]);
}

// gf2_matrix_times
// file pigz.c line 1114
static unsigned long int gf2_matrix_times(unsigned long int *mat, unsigned long int vec)
{
  unsigned long int sum = (unsigned long int)0;
  for( ; !(vec == 0ul); mat = mat + 1l)
  {
    if(!((1ul & vec) == 0ul))
      sum = sum ^ *mat;

    vec = vec >> 1;
  }
  return sum;
}

// grow
// file pigz.c line 849
static inline unsigned long int grow(unsigned long int size)
{
  unsigned long int was;
  unsigned long int top;
  signed int shift;
  was = size;
  size = size + (size >> 2);
  top = size;
  shift = 0;
  for( ; top >= 8ul; shift = shift + 1)
    top = top >> 1;
  if(top == 7ul)
    size = (unsigned long int)1 << shift + 3;

  if(!(size >= 16ul))
    size = (unsigned long int)16;

  if(was >= size)
    size = (unsigned long int)0 - (unsigned long int)1;

  return size;
}

// grow_space
// file pigz.c line 1292
static void grow_space(struct space *space)
{
  unsigned long int more;
  more=grow(space->size);
  if(more == space->size)
    try_throw_(75, "overflow", (void *)0);

  void *return_value_alloc_1;
  return_value_alloc_1=alloc((void *)space->buf, more);
  space->buf = (unsigned char *)return_value_alloc_1;
  space->size = more;
}

// help
// file pigz.c line 3789
static void help(void)
{
  signed int n;
  if(!(g.verbosity == 0))
  {
    n = 0;
    for( ; !(n >= 36); n = n + 1)
      fprintf(stderr, "%s\n", helptext[(signed long int)n]);
    fflush(stderr);
    exit(0);
  }

}

// ignition
// file yarn.c line 245
static void * ignition(void *arg)
{
  struct capsule *capsule = (struct capsule *)arg;
  struct anonymous_5 __cancel_buf;
  void (*__cancel_routine)(void *) = reenter;
  void *__cancel_arg = (void *)0;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);
  capsule->probe(capsule->payload);
  my_free((void *)capsule);
  __pthread_unregister_cancel(&__cancel_buf);
  __cancel_routine(__cancel_arg);
  return (void *)0;
}

// in_init
// file pigz.c line 2360
static void in_init(void)
{
  g.in_left = (unsigned long int)0;
  g.in_eof = 0;
  g.in_short = 0;
  g.in_tot = (signed long int)0;
  g.in_which = -1;
}

// inb
// file pigz.c line 2897
static unsigned int inb(void *desc, unsigned char **buf)
{
  (void)desc;
  load();
  *buf = g.in_next;
  return (unsigned int)g.in_left;
}

// infchk
// file pigz.c line 3040
static void infchk(void)
{
  signed int ret;
  signed int cont;
  signed int was;
  unsigned long int check;
  unsigned long int len;
  struct z_stream_s strm;
  unsigned int tmp2;
  unsigned long int tmp4;
  signed long int clen;
  cont = 0;
  unsigned long int tmp_if_expr_4;
  unsigned long int return_value_adler32_2;
  unsigned long int return_value_crc32_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_load_5;
  signed int tmp_if_expr_9;
  unsigned char *tmp_post_8;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_load_10;
  signed int tmp_if_expr_14;
  unsigned char *tmp_post_13;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  unsigned long int return_value_load_15;
  signed int tmp_if_expr_19;
  unsigned char *tmp_post_18;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_21;
  unsigned long int return_value_load_20;
  signed int tmp_if_expr_24;
  unsigned char *tmp_post_23;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_26;
  unsigned long int return_value_load_25;
  signed int tmp_if_expr_29;
  unsigned char *tmp_post_28;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_31;
  unsigned long int return_value_load_30;
  signed int tmp_if_expr_34;
  unsigned char *tmp_post_33;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_36;
  unsigned long int return_value_load_35;
  signed int tmp_if_expr_39;
  unsigned char *tmp_post_38;
  _Bool tmp_if_expr_42;
  _Bool tmp_if_expr_41;
  unsigned long int return_value_load_40;
  signed int tmp_if_expr_44;
  unsigned char *tmp_post_43;
  _Bool tmp_if_expr_47;
  _Bool tmp_if_expr_46;
  unsigned long int return_value_load_45;
  signed int tmp_if_expr_49;
  unsigned char *tmp_post_48;
  _Bool tmp_if_expr_52;
  _Bool tmp_if_expr_51;
  unsigned long int return_value_load_50;
  signed int tmp_if_expr_54;
  unsigned char *tmp_post_53;
  _Bool tmp_if_expr_57;
  _Bool tmp_if_expr_56;
  unsigned long int return_value_load_55;
  signed int tmp_if_expr_59;
  unsigned char *tmp_post_58;
  _Bool tmp_if_expr_62;
  _Bool tmp_if_expr_61;
  unsigned long int return_value_load_60;
  signed int tmp_if_expr_64;
  unsigned char *tmp_post_63;
  _Bool tmp_if_expr_67;
  _Bool tmp_if_expr_66;
  unsigned long int return_value_load_65;
  signed int tmp_if_expr_69;
  unsigned char *tmp_post_68;
  _Bool tmp_if_expr_72;
  _Bool tmp_if_expr_71;
  unsigned long int return_value_load_70;
  signed int tmp_if_expr_74;
  unsigned char *tmp_post_73;
  _Bool tmp_if_expr_77;
  _Bool tmp_if_expr_76;
  unsigned long int return_value_load_75;
  signed int tmp_if_expr_79;
  unsigned char *tmp_post_78;
  _Bool tmp_if_expr_82;
  _Bool tmp_if_expr_81;
  unsigned long int return_value_load_80;
  signed int tmp_if_expr_84;
  unsigned char *tmp_post_83;
  _Bool tmp_if_expr_87;
  _Bool tmp_if_expr_86;
  unsigned long int return_value_load_85;
  signed int tmp_if_expr_89;
  unsigned char *tmp_post_88;
  _Bool tmp_if_expr_92;
  _Bool tmp_if_expr_91;
  unsigned long int return_value_load_90;
  signed int tmp_if_expr_94;
  unsigned char *tmp_post_93;
  _Bool tmp_if_expr_97;
  _Bool tmp_if_expr_96;
  unsigned long int return_value_load_95;
  signed int tmp_if_expr_99;
  unsigned char *tmp_post_98;
  _Bool tmp_if_expr_102;
  _Bool tmp_if_expr_101;
  unsigned long int return_value_load_100;
  signed int tmp_if_expr_104;
  unsigned char *tmp_post_103;
  _Bool tmp_if_expr_107;
  _Bool tmp_if_expr_106;
  unsigned long int return_value_load_105;
  signed int tmp_if_expr_109;
  unsigned char *tmp_post_108;
  _Bool tmp_if_expr_112;
  _Bool tmp_if_expr_111;
  unsigned long int return_value_load_110;
  signed int tmp_if_expr_114;
  unsigned char *tmp_post_113;
  _Bool tmp_if_expr_117;
  _Bool tmp_if_expr_116;
  unsigned long int return_value_load_115;
  signed int tmp_if_expr_119;
  unsigned char *tmp_post_118;
  _Bool tmp_if_expr_122;
  _Bool tmp_if_expr_121;
  unsigned long int return_value_load_120;
  signed int tmp_if_expr_124;
  unsigned char *tmp_post_123;
  _Bool tmp_if_expr_127;
  _Bool tmp_if_expr_126;
  unsigned long int return_value_load_125;
  signed int tmp_if_expr_129;
  unsigned char *tmp_post_128;
  _Bool tmp_if_expr_132;
  _Bool tmp_if_expr_131;
  unsigned long int return_value_load_130;
  signed int tmp_if_expr_134;
  unsigned char *tmp_post_133;
  _Bool tmp_if_expr_137;
  _Bool tmp_if_expr_136;
  unsigned long int return_value_load_135;
  signed int tmp_if_expr_139;
  unsigned char *tmp_post_138;
  _Bool tmp_if_expr_142;
  _Bool tmp_if_expr_141;
  unsigned long int return_value_load_140;
  signed int tmp_if_expr_144;
  unsigned char *tmp_post_143;
  _Bool tmp_if_expr_147;
  _Bool tmp_if_expr_146;
  unsigned long int return_value_load_145;
  signed int tmp_if_expr_149;
  unsigned char *tmp_post_148;
  _Bool tmp_if_expr_152;
  _Bool tmp_if_expr_151;
  unsigned long int return_value_load_150;
  signed int tmp_if_expr_154;
  unsigned char *tmp_post_153;
  _Bool tmp_if_expr_157;
  _Bool tmp_if_expr_156;
  unsigned long int return_value_load_155;
  signed int tmp_if_expr_159;
  unsigned char *tmp_post_158;
  _Bool tmp_if_expr_162;
  _Bool tmp_if_expr_161;
  unsigned long int return_value_load_160;
  signed int tmp_if_expr_164;
  unsigned char *tmp_post_163;
  _Bool tmp_if_expr_167;
  _Bool tmp_if_expr_166;
  unsigned long int return_value_load_165;
  signed int tmp_if_expr_169;
  unsigned char *tmp_post_168;
  _Bool tmp_if_expr_172;
  _Bool tmp_if_expr_171;
  unsigned long int return_value_load_170;
  signed int tmp_if_expr_174;
  unsigned char *tmp_post_173;
  _Bool tmp_if_expr_177;
  _Bool tmp_if_expr_176;
  unsigned long int return_value_load_175;
  signed int tmp_if_expr_179;
  unsigned char *tmp_post_178;
  _Bool tmp_if_expr_182;
  _Bool tmp_if_expr_181;
  unsigned long int return_value_load_180;
  signed int tmp_if_expr_184;
  unsigned char *tmp_post_183;
  _Bool tmp_if_expr_187;
  _Bool tmp_if_expr_186;
  unsigned long int return_value_load_185;
  signed int tmp_if_expr_189;
  unsigned char *tmp_post_188;
  _Bool tmp_if_expr_192;
  _Bool tmp_if_expr_191;
  unsigned long int return_value_load_190;
  signed int tmp_if_expr_194;
  unsigned char *tmp_post_193;
  _Bool tmp_if_expr_197;
  _Bool tmp_if_expr_196;
  unsigned long int return_value_load_195;
  signed int tmp_if_expr_199;
  unsigned char *tmp_post_198;
  _Bool tmp_if_expr_202;
  _Bool tmp_if_expr_201;
  unsigned long int return_value_load_200;
  signed int tmp_if_expr_204;
  unsigned char *tmp_post_203;
  _Bool tmp_if_expr_1;
  do
  {
    g.in_tot = (signed long int)g.in_left;
    g.out_tot = (signed long int)0;
    if(g.form == 1)
    {
      return_value_adler32_2=adler32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
      tmp_if_expr_4 = return_value_adler32_2;
    }

    else
    {
      return_value_crc32_3=crc32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
      tmp_if_expr_4 = return_value_crc32_3;
    }
    g.out_check = tmp_if_expr_4;
    strm.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    strm.zfree = ((void (*)(void *, void *))NULL);
    strm.opaque = NULL;
    ret=inflateBackInit_(&strm, 15, out_buf, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(ret == -4)
      try_throw_(12, "not enough memory", (void *)0);

    if(!(ret == 0))
      try_throw_(22, "internal error", (void *)0);

    strm.avail_in = (unsigned int)g.in_left;
    strm.next_in = g.in_next;
    ret=inflateBack(&strm, inb, (void *)0, outb, (void *)0);
    inflateBackEnd(&strm);
    if(ret == -3)
      try_throw_(33, "%s: corrupted -- invalid deflate data (%s)", g.inf, strm.msg, (void *)0);

    if(ret == -5)
      try_throw_(33, "%s: corrupted -- incomplete deflate data", g.inf, (void *)0);

    if(!(ret == 1))
      try_throw_(22, "internal error", (void *)0);

    g.in_left = (unsigned long int)strm.avail_in;
    g.in_next = strm.next_in;
    outb((void *)0, (unsigned char *)(void *)0, (unsigned int)0);
    clen = (signed long int)((unsigned long int)g.in_tot - g.in_left);
    if(g.form >= 2)
    {
      if(g.form == 3)
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_load_5=load();
            tmp_if_expr_6 = return_value_load_5 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_9 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_8 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_9 = (signed int)*tmp_post_8;
        }
        tmp2 = (unsigned int)tmp_if_expr_9;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_load_10=load();
            tmp_if_expr_11 = return_value_load_10 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        if(tmp_if_expr_12)
          tmp_if_expr_14 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_13 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_14 = (signed int)*tmp_post_13;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_14 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_16 = (_Bool)1;

          else
          {
            return_value_load_15=load();
            tmp_if_expr_16 = return_value_load_15 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_19 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_18 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_19 = (signed int)*tmp_post_18;
        }
        tmp2 = (unsigned int)tmp_if_expr_19;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            return_value_load_20=load();
            tmp_if_expr_21 = return_value_load_20 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_22 = tmp_if_expr_21 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_22 = (_Bool)0;
        if(tmp_if_expr_22)
          tmp_if_expr_24 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_23 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_24 = (signed int)*tmp_post_23;
        }
        g.zip_crc = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_24 << 8)) << 16);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_26 = (_Bool)1;

          else
          {
            return_value_load_25=load();
            tmp_if_expr_26 = return_value_load_25 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_27 = tmp_if_expr_26 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_27 = (_Bool)0;
        if(tmp_if_expr_27)
          tmp_if_expr_29 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_28 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_29 = (signed int)*tmp_post_28;
        }
        tmp2 = (unsigned int)tmp_if_expr_29;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_31 = (_Bool)1;

          else
          {
            return_value_load_30=load();
            tmp_if_expr_31 = return_value_load_30 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_32 = tmp_if_expr_31 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_32 = (_Bool)0;
        if(tmp_if_expr_32)
          tmp_if_expr_34 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_33 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_34 = (signed int)*tmp_post_33;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_34 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_36 = (_Bool)1;

          else
          {
            return_value_load_35=load();
            tmp_if_expr_36 = return_value_load_35 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_37 = tmp_if_expr_36 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_37 = (_Bool)0;
        if(tmp_if_expr_37)
          tmp_if_expr_39 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_38 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_39 = (signed int)*tmp_post_38;
        }
        tmp2 = (unsigned int)tmp_if_expr_39;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_41 = (_Bool)1;

          else
          {
            return_value_load_40=load();
            tmp_if_expr_41 = return_value_load_40 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_42 = tmp_if_expr_41 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_42 = (_Bool)0;
        if(tmp_if_expr_42)
          tmp_if_expr_44 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_43 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_44 = (signed int)*tmp_post_43;
        }
        g.zip_clen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_44 << 8)) << 16);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_46 = (_Bool)1;

          else
          {
            return_value_load_45=load();
            tmp_if_expr_46 = return_value_load_45 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_47 = tmp_if_expr_46 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_47 = (_Bool)0;
        if(tmp_if_expr_47)
          tmp_if_expr_49 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_48 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_49 = (signed int)*tmp_post_48;
        }
        tmp2 = (unsigned int)tmp_if_expr_49;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_51 = (_Bool)1;

          else
          {
            return_value_load_50=load();
            tmp_if_expr_51 = return_value_load_50 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_52 = tmp_if_expr_51 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_52 = (_Bool)0;
        if(tmp_if_expr_52)
          tmp_if_expr_54 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_53 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_54 = (signed int)*tmp_post_53;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_54 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_56 = (_Bool)1;

          else
          {
            return_value_load_55=load();
            tmp_if_expr_56 = return_value_load_55 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_57 = tmp_if_expr_56 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_57 = (_Bool)0;
        if(tmp_if_expr_57)
          tmp_if_expr_59 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_58 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_59 = (signed int)*tmp_post_58;
        }
        tmp2 = (unsigned int)tmp_if_expr_59;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_61 = (_Bool)1;

          else
          {
            return_value_load_60=load();
            tmp_if_expr_61 = return_value_load_60 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_62 = tmp_if_expr_61 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_62 = (_Bool)0;
        if(tmp_if_expr_62)
          tmp_if_expr_64 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_63 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_64 = (signed int)*tmp_post_63;
        }
        g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_64 << 8)) << 16);
        if(!(g.in_eof == 0))
          try_throw_(33, "%s: corrupted entry -- missing trailer", g.inf, (void *)0);

        if(!(g.zip_crc == g.out_check))
        {
          if(!(g.zip_clen == g.out_check) || !(g.zip_crc == 0x08074b50UL))
            try_throw_(33, "%s: corrupted entry -- crc32 mismatch", g.inf, (void *)0);

          g.zip_crc = g.zip_clen;
          g.zip_clen = g.zip_ulen;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_66 = (_Bool)1;

            else
            {
              return_value_load_65=load();
              tmp_if_expr_66 = return_value_load_65 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_67 = tmp_if_expr_66 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_67 = (_Bool)0;
          if(tmp_if_expr_67)
            tmp_if_expr_69 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_68 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_69 = (signed int)*tmp_post_68;
          }
          tmp2 = (unsigned int)tmp_if_expr_69;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_71 = (_Bool)1;

            else
            {
              return_value_load_70=load();
              tmp_if_expr_71 = return_value_load_70 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_72 = tmp_if_expr_71 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_72 = (_Bool)0;
          if(tmp_if_expr_72)
            tmp_if_expr_74 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_73 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_74 = (signed int)*tmp_post_73;
          }
          tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_74 << 8));
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_76 = (_Bool)1;

            else
            {
              return_value_load_75=load();
              tmp_if_expr_76 = return_value_load_75 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_77 = tmp_if_expr_76 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_77 = (_Bool)0;
          if(tmp_if_expr_77)
            tmp_if_expr_79 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_78 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_79 = (signed int)*tmp_post_78;
          }
          tmp2 = (unsigned int)tmp_if_expr_79;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_81 = (_Bool)1;

            else
            {
              return_value_load_80=load();
              tmp_if_expr_81 = return_value_load_80 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_82 = tmp_if_expr_81 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_82 = (_Bool)0;
          if(tmp_if_expr_82)
            tmp_if_expr_84 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_83 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_84 = (signed int)*tmp_post_83;
          }
          g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_84 << 8)) << 16);
        }

        else
          if(g.zip_clen == g.zip_crc && g.zip_crc == 0x08074b50UL && (g.zip_ulen == g.zip_crc || !((0xffffffffUL & (unsigned long int)clen) == g.zip_crc)))
          {
            g.zip_crc = g.zip_clen;
            g.zip_clen = g.zip_ulen;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_86 = (_Bool)1;

              else
              {
                return_value_load_85=load();
                tmp_if_expr_86 = return_value_load_85 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_87 = tmp_if_expr_86 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_87 = (_Bool)0;
            if(tmp_if_expr_87)
              tmp_if_expr_89 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_88 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_89 = (signed int)*tmp_post_88;
            }
            tmp2 = (unsigned int)tmp_if_expr_89;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_91 = (_Bool)1;

              else
              {
                return_value_load_90=load();
                tmp_if_expr_91 = return_value_load_90 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_92 = tmp_if_expr_91 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_92 = (_Bool)0;
            if(tmp_if_expr_92)
              tmp_if_expr_94 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_93 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_94 = (signed int)*tmp_post_93;
            }
            tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_94 << 8));
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_96 = (_Bool)1;

              else
              {
                return_value_load_95=load();
                tmp_if_expr_96 = return_value_load_95 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_97 = tmp_if_expr_96 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_97 = (_Bool)0;
            if(tmp_if_expr_97)
              tmp_if_expr_99 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_98 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_99 = (signed int)*tmp_post_98;
            }
            tmp2 = (unsigned int)tmp_if_expr_99;
            if(g.in_left == 0ul)
            {
              if(!(g.in_eof == 0))
                tmp_if_expr_101 = (_Bool)1;

              else
              {
                return_value_load_100=load();
                tmp_if_expr_101 = return_value_load_100 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr_102 = tmp_if_expr_101 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_102 = (_Bool)0;
            if(tmp_if_expr_102)
              tmp_if_expr_104 = 0;

            else
            {
              g.in_left = g.in_left - 1ul;
              tmp_post_103 = g.in_next;
              g.in_next = g.in_next + 1l;
              tmp_if_expr_104 = (signed int)*tmp_post_103;
            }
            g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_104 << 8)) << 16);
          }

        if(!(g.zip_ulen == (0xffffffffUL & (unsigned long int)g.out_tot)))
        {
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_106 = (_Bool)1;

            else
            {
              return_value_load_105=load();
              tmp_if_expr_106 = return_value_load_105 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_107 = tmp_if_expr_106 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_107 = (_Bool)0;
          if(tmp_if_expr_107)
            tmp_if_expr_109 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_108 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_109 = (signed int)*tmp_post_108;
          }
          tmp2 = (unsigned int)tmp_if_expr_109;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_111 = (_Bool)1;

            else
            {
              return_value_load_110=load();
              tmp_if_expr_111 = return_value_load_110 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_112 = tmp_if_expr_111 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_112 = (_Bool)0;
          if(tmp_if_expr_112)
            tmp_if_expr_114 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_113 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_114 = (signed int)*tmp_post_113;
          }
          tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_114 << 8));
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_116 = (_Bool)1;

            else
            {
              return_value_load_115=load();
              tmp_if_expr_116 = return_value_load_115 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_117 = tmp_if_expr_116 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_117 = (_Bool)0;
          if(tmp_if_expr_117)
            tmp_if_expr_119 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_118 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_119 = (signed int)*tmp_post_118;
          }
          tmp2 = (unsigned int)tmp_if_expr_119;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_121 = (_Bool)1;

            else
            {
              return_value_load_120=load();
              tmp_if_expr_121 = return_value_load_120 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_122 = tmp_if_expr_121 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_122 = (_Bool)0;
          if(tmp_if_expr_122)
            tmp_if_expr_124 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_123 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_124 = (signed int)*tmp_post_123;
          }
          g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_124 << 8)) << 16);
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_126 = (_Bool)1;

            else
            {
              return_value_load_125=load();
              tmp_if_expr_126 = return_value_load_125 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_127 = tmp_if_expr_126 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_127 = (_Bool)0;
          if(tmp_if_expr_127)
            tmp_if_expr_129 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_128 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_129 = (signed int)*tmp_post_128;
          }
          tmp2 = (unsigned int)tmp_if_expr_129;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_131 = (_Bool)1;

            else
            {
              return_value_load_130=load();
              tmp_if_expr_131 = return_value_load_130 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_132 = tmp_if_expr_131 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_132 = (_Bool)0;
          if(tmp_if_expr_132)
            tmp_if_expr_134 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_133 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_134 = (signed int)*tmp_post_133;
          }
          tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_134 << 8));
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_136 = (_Bool)1;

            else
            {
              return_value_load_135=load();
              tmp_if_expr_136 = return_value_load_135 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_137 = tmp_if_expr_136 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_137 = (_Bool)0;
          if(tmp_if_expr_137)
            tmp_if_expr_139 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_138 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_139 = (signed int)*tmp_post_138;
          }
          tmp2 = (unsigned int)tmp_if_expr_139;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_141 = (_Bool)1;

            else
            {
              return_value_load_140=load();
              tmp_if_expr_141 = return_value_load_140 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_142 = tmp_if_expr_141 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_142 = (_Bool)0;
          if(tmp_if_expr_142)
            tmp_if_expr_144 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_143 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_144 = (signed int)*tmp_post_143;
          }
          tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_144 << 8)) << 16);
        }

        if(!(g.in_eof == 0))
          try_throw_(33, "%s: corrupted entry -- missing trailer", g.inf, (void *)0);

      }

      if(!(g.zip_clen == (0xffffffffUL & (unsigned long int)clen)) || !(g.zip_ulen == (0xffffffffUL & (unsigned long int)g.out_tot)))
        try_throw_(33, "%s: corrupted entry -- length mismatch", g.inf, (void *)0);

      check = g.zip_crc;
    }

    else
      if(g.form == 1)
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_146 = (_Bool)1;

          else
          {
            return_value_load_145=load();
            tmp_if_expr_146 = return_value_load_145 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_147 = tmp_if_expr_146 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_147 = (_Bool)0;
        if(tmp_if_expr_147)
          tmp_if_expr_149 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_148 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_149 = (signed int)*tmp_post_148;
        }
        check = (unsigned long int)tmp_if_expr_149 << 24;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_151 = (_Bool)1;

          else
          {
            return_value_load_150=load();
            tmp_if_expr_151 = return_value_load_150 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_152 = tmp_if_expr_151 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_152 = (_Bool)0;
        if(tmp_if_expr_152)
          tmp_if_expr_154 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_153 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_154 = (signed int)*tmp_post_153;
        }
        check = check + ((unsigned long int)tmp_if_expr_154 << 16);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_156 = (_Bool)1;

          else
          {
            return_value_load_155=load();
            tmp_if_expr_156 = return_value_load_155 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_157 = tmp_if_expr_156 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_157 = (_Bool)0;
        if(tmp_if_expr_157)
          tmp_if_expr_159 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_158 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_159 = (signed int)*tmp_post_158;
        }
        check = check + (unsigned long int)((unsigned int)tmp_if_expr_159 << 8);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_161 = (_Bool)1;

          else
          {
            return_value_load_160=load();
            tmp_if_expr_161 = return_value_load_160 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_162 = tmp_if_expr_161 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_162 = (_Bool)0;
        if(tmp_if_expr_162)
          tmp_if_expr_164 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_163 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_164 = (signed int)*tmp_post_163;
        }
        check = check + (unsigned long int)tmp_if_expr_164;
        if(!(g.in_eof == 0))
          try_throw_(33, "%s: corrupted -- missing trailer", g.inf, (void *)0);

        if(!(check == g.out_check))
          try_throw_(33, "%s: corrupted -- adler32 mismatch", g.inf, (void *)0);

      }

      else
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_166 = (_Bool)1;

          else
          {
            return_value_load_165=load();
            tmp_if_expr_166 = return_value_load_165 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_167 = tmp_if_expr_166 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_167 = (_Bool)0;
        if(tmp_if_expr_167)
          tmp_if_expr_169 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_168 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_169 = (signed int)*tmp_post_168;
        }
        tmp2 = (unsigned int)tmp_if_expr_169;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_171 = (_Bool)1;

          else
          {
            return_value_load_170=load();
            tmp_if_expr_171 = return_value_load_170 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_172 = tmp_if_expr_171 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_172 = (_Bool)0;
        if(tmp_if_expr_172)
          tmp_if_expr_174 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_173 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_174 = (signed int)*tmp_post_173;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_174 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_176 = (_Bool)1;

          else
          {
            return_value_load_175=load();
            tmp_if_expr_176 = return_value_load_175 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_177 = tmp_if_expr_176 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_177 = (_Bool)0;
        if(tmp_if_expr_177)
          tmp_if_expr_179 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_178 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_179 = (signed int)*tmp_post_178;
        }
        tmp2 = (unsigned int)tmp_if_expr_179;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_181 = (_Bool)1;

          else
          {
            return_value_load_180=load();
            tmp_if_expr_181 = return_value_load_180 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_182 = tmp_if_expr_181 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_182 = (_Bool)0;
        if(tmp_if_expr_182)
          tmp_if_expr_184 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_183 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_184 = (signed int)*tmp_post_183;
        }
        check = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_184 << 8)) << 16);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_186 = (_Bool)1;

          else
          {
            return_value_load_185=load();
            tmp_if_expr_186 = return_value_load_185 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_187 = tmp_if_expr_186 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_187 = (_Bool)0;
        if(tmp_if_expr_187)
          tmp_if_expr_189 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_188 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_189 = (signed int)*tmp_post_188;
        }
        tmp2 = (unsigned int)tmp_if_expr_189;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_191 = (_Bool)1;

          else
          {
            return_value_load_190=load();
            tmp_if_expr_191 = return_value_load_190 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_192 = tmp_if_expr_191 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_192 = (_Bool)0;
        if(tmp_if_expr_192)
          tmp_if_expr_194 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_193 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_194 = (signed int)*tmp_post_193;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_194 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_196 = (_Bool)1;

          else
          {
            return_value_load_195=load();
            tmp_if_expr_196 = return_value_load_195 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_197 = tmp_if_expr_196 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_197 = (_Bool)0;
        if(tmp_if_expr_197)
          tmp_if_expr_199 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_198 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_199 = (signed int)*tmp_post_198;
        }
        tmp2 = (unsigned int)tmp_if_expr_199;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_201 = (_Bool)1;

          else
          {
            return_value_load_200=load();
            tmp_if_expr_201 = return_value_load_200 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_202 = tmp_if_expr_201 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_202 = (_Bool)0;
        if(tmp_if_expr_202)
          tmp_if_expr_204 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_203 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_204 = (signed int)*tmp_post_203;
        }
        len = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_204 << 8)) << 16);
        if(!(g.in_eof == 0))
          try_throw_(33, "%s: corrupted -- missing trailer", g.inf, (void *)0);

        if(!(check == g.out_check))
          try_throw_(33, "%s: corrupted -- crc32 mismatch", g.inf, (void *)0);

        if(!(len == (0xffffffffUL & (unsigned long int)g.out_tot)))
          try_throw_(33, "%s: corrupted -- length mismatch", g.inf, (void *)0);

      }
    if(!(g.list == 0))
    {
      g.in_tot = clen;
      show_info(8, check, g.out_tot, cont);
      cont = 1;
    }

    was = g.form;
    if(was == 0)
    {
      ret=get_header(0);
      tmp_if_expr_1 = ret == 8 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
  }
  while(g.form == 0 && tmp_if_expr_1);
  _Bool tmp_if_expr_212;
  signed int return_value_get_header_211;
  _Bool tmp_if_expr_210;
  _Bool tmp_if_expr_209;
  _Bool tmp_if_expr_207;
  _Bool tmp_if_expr_206;
  unsigned long int return_value_load_205;
  unsigned char *tmp_post_208;
  if(g.list == 0 && ret == -2 && was == 0 && !(g.decode == 2) && !(g.force == 0) && !(g.pipeout == 0))
    cat();

  else
  {
    if(was >= 2)
    {
      return_value_get_header_211=get_header(0);
      tmp_if_expr_212 = return_value_get_header_211 != -5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_212 = (_Bool)0;
    if(tmp_if_expr_212)
      complain("warning: %s: entries after the first were ignored", g.inf);

    else
    {
      if(was == 0 && !(ret == -1))
        tmp_if_expr_210 = (_Bool)1;

      else
      {
        if(was == 1)
        {
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_206 = (_Bool)1;

            else
            {
              return_value_load_205=load();
              tmp_if_expr_206 = return_value_load_205 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_207 = tmp_if_expr_206 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_207 = (_Bool)0;
          if(tmp_if_expr_207)
            0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_208 = g.in_next;
            g.in_next = g.in_next + 1l;
            *tmp_post_208;
          }
          tmp_if_expr_209 = !(g.in_eof != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_209 = (_Bool)0;
        tmp_if_expr_210 = tmp_if_expr_209 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_210)
        complain("warning: %s: trailing junk was ignored", g.inf);

    }
  }
}

// join
// file yarn.h line 119
void join(struct thread_s *ally)
{
  signed int ret;
  struct thread_s *match;
  struct thread_s **prior;
  ret=pthread_join(ally->id, (void **)(void *)0);
  if(!(ret == 0))
    fail(ret);

  possess(&threads_lock);
  prior = &threads;
  do
  {
    match = *prior;
    if(match == ((struct thread_s *)NULL))
      break;

    if(match == ally)
      break;

    prior = &match->next;
  }
  while((_Bool)1);
  if(match == ((struct thread_s *)NULL))
    fail(22);

  if(!(match->done == 0))
    threads_lock.value = threads_lock.value - 1l;

  *prior = match->next;
  release(&threads_lock);
  my_free((void *)ally);
}

// join_all
// file yarn.h line 120
signed int join_all(void)
{
  signed int ret;
  signed int count;
  struct thread_s *match;
  struct thread_s **prior;
  count = 0;
  possess(&threads_lock);
  if(!(threads == ((struct thread_s *)NULL)))
  {
    wait_for(&threads_lock, (enum wait_op)NOT_TO_BE, (signed long int)0);
    prior = &threads;
    do
    {
      match = *prior;
      if(match == ((struct thread_s *)NULL))
        break;

      if(!(match->done == 0))
        break;

      prior = &match->next;
    }
    while((_Bool)1);
    if(match == ((struct thread_s *)NULL))
      fail(22);

    ret=pthread_join(match->id, (void **)(void *)0);
    if(!(ret == 0))
      fail(ret);

    threads_lock.value = threads_lock.value - 1l;
    *prior = match->next;
    my_free((void *)match);
    count = count + 1;
  }

  release(&threads_lock);
  return count;
}

// justname
// file pigz.c line 3374
static char * justname(char *path)
{
  char *p;
  p=strrchr(path, 47);
  return p == (char *)(void *)0 ? path : p + (signed long int)1;
}

// launch
// file yarn.h line 118
struct thread_s * launch(void (*probe)(void *), void *payload)
{
  signed int ret;
  struct thread_s *th;
  struct capsule *capsule;
  union pthread_attr_t attr;
  void *return_value_my_malloc_1;
  return_value_my_malloc_1=my_malloc(sizeof(struct capsule) /*16ul*/ );
  capsule = (struct capsule *)return_value_my_malloc_1;
  capsule->probe = probe;
  capsule->payload = payload;
  possess(&threads_lock);
  void *return_value_my_malloc_2;
  return_value_my_malloc_2=my_malloc(sizeof(struct thread_s) /*24ul*/ );
  th = (struct thread_s *)return_value_my_malloc_2;
  ret=pthread_attr_init(&attr);
  _Bool tmp_if_expr_3;
  if(!(ret == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    ret=pthread_attr_setdetachstate(&attr, 0);
    tmp_if_expr_3 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    ret=pthread_create(&th->id, &attr, ignition, (void *)capsule);
    tmp_if_expr_4 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    ret=pthread_attr_destroy(&attr);
    tmp_if_expr_5 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    fail(ret);

  th->done = 0;
  th->next = threads;
  threads = th;
  release(&threads_lock);
  return th;
}

// list_info
// file pigz.c line 2761
static void list_info(void)
{
  signed int method;
  unsigned long int n;
  signed long int at;
  unsigned char tail[8l];
  unsigned long int check;
  unsigned long int len;
  in_init();
  method=get_header(1);
  unsigned long int tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned long int return_value_load_1;
  unsigned long int return_value_load_4;
  if(!(method >= 0))
  {
    do
      if(!(g.hname == ((char *)NULL)))
      {
        free((void *)g.hname);
        g.hname = (char *)(void *)0;
      }

    while((_Bool)0);
    if(g.verbosity >= 2 && !(method == -1))
      complain(method != -6 ? "skipping: %s not compressed" : "skipping: %s corrupted: invalid header crc", g.inf);

  }

  else
    if(g.form >= 2)
    {
      g.in_tot = (signed long int)g.zip_clen;
      show_info(method, g.zip_crc, (signed long int)g.zip_ulen, 0);
    }

    else
      if(g.form == 1)
      {
        at=lseek(g.ind, (signed long int)0, 2);
        if(at == -1l)
        {
          check = (unsigned long int)0;
          do
          {
            len = g.in_left < (unsigned long int)4 ? g.in_left : (unsigned long int)4;
            g.in_next = g.in_next + (signed long int)(g.in_left - len);
            do
            {
              tmp_post_2 = len;
              len = len - 1ul;
              if(tmp_post_2 == 0ul)
                break;

              tmp_post_3 = g.in_next;
              g.in_next = g.in_next + 1l;
              check = (check << 8) + (unsigned long int)*tmp_post_3;
            }
            while((_Bool)1);
            return_value_load_1=load();
          }
          while(!(return_value_load_1 == 0ul));
          check = check & 0xffffffffUL;
        }

        else
        {
          g.in_tot = at;
          lseek(g.ind, (signed long int)-4, 2);
          readn(g.ind, tail, (unsigned long int)4);
          check = ((unsigned long int)(((unsigned int)tail[(signed long int)0] << 8) + (unsigned int)tail[(signed long int)1]) << 16) + (unsigned long int)(((unsigned int)(tail + (signed long int)2)[(signed long int)0] << 8) + (unsigned int)(tail + (signed long int)2)[(signed long int)1]);
        }
        g.in_tot = g.in_tot - (signed long int)6;
        show_info(method, check, (signed long int)0, 0);
      }

      else
      {
        if(method == 257)
        {
          at=lseek(g.ind, (signed long int)0, 2);
          if(at == -1l)
            do
            {
              return_value_load_4=load();
              if(return_value_load_4 == 0ul)
                break;

            }
            while((_Bool)1);

          else
            g.in_tot = at;
          g.in_tot = g.in_tot - (signed long int)3;
          show_info(method, (unsigned long int)0, (signed long int)0, 0);
          goto __CPROVER_DUMP_L30;
        }

        if(!(g.in_short == 0))
        {
          if(!(g.in_left >= 8ul))
          {
            complain("skipping: %s not a valid gzip file", g.inf);
            goto __CPROVER_DUMP_L30;
          }

          g.in_tot = (signed long int)(g.in_left - (unsigned long int)8);
          memcpy((void *)tail, (const void *)(g.in_next + (signed long int)(g.in_left - (unsigned long int)8)), (unsigned long int)8);
        }

        else
        {
          at=lseek(g.ind, (signed long int)-8, 2);
          if(!(at == -1l))
          {
            g.in_tot = (signed long int)((unsigned long int)(at - g.in_tot) + g.in_left);
            readn(g.ind, tail, (unsigned long int)8);
          }

          else
          {
            at = (signed long int)((unsigned long int)g.in_tot - g.in_left);
            do
            {
              n = g.in_left < (unsigned long int)8 ? g.in_left : (unsigned long int)8;
              memcpy((void *)tail, (const void *)(g.in_next + (signed long int)(g.in_left - n)), n);
              load();
            }
            while(g.in_left == 32768ul);
            if(!(g.in_left >= 8ul))
            {
              if(!(g.in_left + n >= 8ul))
              {
                complain("skipping: %s not a valid gzip file", g.inf);
                goto __CPROVER_DUMP_L30;
              }

              if(!(g.in_left == 0ul))
              {
                if(g.in_left + n >= 9ul)
                  memcpy((void *)tail, (const void *)((tail + (signed long int)n) - (signed long int)((unsigned long int)8 - g.in_left)), (unsigned long int)8 - g.in_left);

                memcpy((void *)((tail + (signed long int)8) - (signed long int)g.in_left), (const void *)g.in_next, g.in_left);
              }

            }

            else
              memcpy((void *)tail, (const void *)(g.in_next + (signed long int)(g.in_left - (unsigned long int)8)), (unsigned long int)8);
            g.in_tot = g.in_tot - (at + (signed long int)8);
          }
        }
        if(!(g.in_tot >= 2l))
          complain("skipping: %s not a valid gzip file", g.inf);

        else
        {
          check = (unsigned long int)((unsigned int)tail[(signed long int)0] + ((unsigned int)tail[(signed long int)1] << 8)) + ((unsigned long int)((unsigned int)(tail + (signed long int)2)[(signed long int)0] + ((unsigned int)(tail + (signed long int)2)[(signed long int)1] << 8)) << 16);
          len = (unsigned long int)((unsigned int)(tail + (signed long int)4)[(signed long int)0] + ((unsigned int)(tail + (signed long int)4)[(signed long int)1] << 8)) + ((unsigned long int)((unsigned int)(tail + (signed long int)4 + (signed long int)2)[(signed long int)0] + ((unsigned int)(tail + (signed long int)4 + (signed long int)2)[(signed long int)1] << 8)) << 16);
          show_info(method, check, (signed long int)len, 0);
          do
            if(!(g.hname == ((char *)NULL)))
            {
              free((void *)g.hname);
              g.hname = (char *)(void *)0;
            }

          while((_Bool)0);
        }
      }

__CPROVER_DUMP_L30:
  ;
}

// load
// file pigz.c line 2294
static unsigned long int load(void)
{
  unsigned char *tmp_if_expr_1;
  if(!(g.in_short == 0))
  {
    g.in_eof = 1;
    g.in_left = (unsigned long int)0;
    return (unsigned long int)0;
  }

  else
  {
    if(g.procs >= 2)
    {
      if(g.in_which == -1)
      {
        g.in_which = 1;
        g.load_state=new_lock((signed long int)1);
        g.load_thread=launch(load_read, (void *)0);
      }

      possess(g.load_state);
      wait_for(g.load_state, (enum wait_op)TO_BE, (signed long int)0);
      release(g.load_state);
      if(!(g.in_which == 0))
        tmp_if_expr_1 = g.in_buf;

      else
        tmp_if_expr_1 = g.in_buf2;
      g.in_next = tmp_if_expr_1;
      g.in_left = g.in_len;
      if(g.in_len == 32768ul)
      {
        g.in_which = 1 - g.in_which;
        possess(g.load_state);
        twist(g.load_state, (enum twist_op)TO, (signed long int)1);
      }

      else
      {
        join(g.load_thread);
        free_lock(g.load_state);
        g.in_which = -1;
      }
    }

    else
    {
      g.in_next = g.in_buf;
      g.in_left=readn(g.ind, g.in_next, (unsigned long int)32768U);
    }
    if(!(g.in_left >= 32768ul))
    {
      g.in_short = 1;
      if(g.in_left == 0ul)
        g.in_eof = 1;

    }

    g.in_tot = g.in_tot + (signed long int)g.in_left;
    return g.in_left;
  }
}

// load_read
// file pigz.c line 2264
static void load_read(void *dummy)
{
  unsigned long int len;
  struct anonymous err;
  (void)dummy;
  unsigned char *tmp_if_expr_2;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int load_read__1__1__1__try_ret_;
      load_read__1__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(load_read__1__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_3;
    return_value__setjmp_3=_setjmp(try_this_.env);
    if(!(return_value__setjmp_3 >= 2))
      do
      {

      __CPROVER_DUMP_L3:
        ;
        possess(g.load_state);
        wait_for(g.load_state, (enum wait_op)TO_BE, (signed long int)1);
        if(!(g.in_which == 0))
          tmp_if_expr_2 = g.in_buf;

        else
          tmp_if_expr_2 = g.in_buf2;
        len=readn(g.ind, tmp_if_expr_2, (unsigned long int)32768U);
        g.in_len = len;
        twist(g.load_state, (enum twist_op)TO, (signed long int)0);
        if(len == 32768ul)
          goto __CPROVER_DUMP_L3;

      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

}

// main
// file pigz.c line 4056
signed int main(signed int argc, char **argv)
{
  signed int n;
  signed int noop;
  unsigned long int done;
  char *opts;
  char *p;
  struct anonymous err;
  char *tmp_if_expr_2;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_8;
  signed int return_value_isatty_10;
  _Bool tmp_if_expr_16;
  signed int return_value_strcmp_15;
  _Bool tmp_if_expr_14;
  signed int return_value_option_13;
  char *tmp_if_expr_12;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int main__1__1__1__try_ret_;
      main__1__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(main__1__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_17;
    return_value__setjmp_17=_setjmp(try_this_.env);
    if(!(return_value__setjmp_17 >= 2))
      do
      {
        g.inf = (char *)(void *)0;
        g.inz = (unsigned long int)0;
        g.outf = (char *)(void *)0;
        g.first = 1;
        g.hname = (char *)(void *)0;
        p=strrchr(argv[(signed long int)0], 47);
        if(p == ((char *)NULL))
          tmp_if_expr_2 = argv[(signed long int)0];

        else
          tmp_if_expr_2 = p + (signed long int)1;
        p = tmp_if_expr_2;
        g.prog = *p != 0 ? p : "pigz";
        signal(2, cut_short);
        yarn_prefix = g.prog;
        yarn_abort = cut_yarn;
        defaults();
        opts=getenv("GZIP");
        if(!(opts == ((char *)NULL)))
        {
          while(!(*opts == 0))
          {
            for( ; (_Bool)1; opts = opts + 1l)
              if(!((signed int)*opts == 32))
              {
                if(!((signed int)*opts == 9))
                  goto __CPROVER_DUMP_L9;

              }


          __CPROVER_DUMP_L9:
            ;
            p = opts;
            for( ; !(*p == 0); p = p + 1l)
            {
              if((signed int)*p == 32)
                break;

              if((signed int)*p == 9)
                break;

            }
            n = (signed int)*p;
            *p = (char)0;
            signed int return_value_option_3;
            return_value_option_3=option(opts);
            if(!(return_value_option_3 == 0))
              try_throw_(22, "cannot provide files in GZIP environment variable", (void *)0);

            opts = p + (signed long int)(n != 0 ? 1 : 0);
          }
          option((char *)(void *)0);
        }

        opts=getenv("PIGZ");
        if(!(opts == ((char *)NULL)))
        {
          while(!(*opts == 0))
          {
            for( ; (_Bool)1; opts = opts + 1l)
              if(!((signed int)*opts == 32))
              {
                if(!((signed int)*opts == 9))
                  goto __CPROVER_DUMP_L18;

              }


          __CPROVER_DUMP_L18:
            ;
            p = opts;
            for( ; !(*p == 0); p = p + 1l)
            {
              if((signed int)*p == 32)
                break;

              if((signed int)*p == 9)
                break;

            }
            n = (signed int)*p;
            *p = (char)0;
            signed int return_value_option_4;
            return_value_option_4=option(opts);
            if(!(return_value_option_4 == 0))
              try_throw_(22, "cannot provide files in PIGZ environment variable", (void *)0);

            opts = p + (signed long int)(n != 0 ? 1 : 0);
          }
          option((char *)(void *)0);
        }

        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(g.prog, "unpigz");
        if(return_value_strcmp_5 == 0)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_strcmp_6=strcmp(g.prog, "gunzip");
          tmp_if_expr_7 = return_value_strcmp_6 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          if(g.decode == 0)
            g.headis = g.headis >> 2;

          g.decode = 1;
        }

        unsigned long int return_value_strlen_9;
        return_value_strlen_9=strlen(g.prog);
        n = (signed int)return_value_strlen_9;
        if(n >= 3)
        {
          return_value_strcmp_8=strcmp((g.prog + (signed long int)n) - (signed long int)3, "cat");
          if(return_value_strcmp_8 == 0)
          {
            if(g.decode == 0)
              g.headis = g.headis >> 2;

            g.decode = 1;
            g.pipeout = 1;
          }

        }

        if(!(argc >= 2))
        {
          return_value_isatty_10=isatty(g.decode != 0 ? 0 : 1);
          if(!(return_value_isatty_10 == 0))
            help();

        }

        noop = 0;
        done = (unsigned long int)noop;
        n = 1;
        for( ; !(n >= argc); n = n + 1)
        {
          if(noop == 0)
          {
            return_value_strcmp_15=strcmp(argv[(signed long int)n], "--");
            tmp_if_expr_16 = return_value_strcmp_15 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_16 = (_Bool)0;
          if(tmp_if_expr_16)
          {
            noop = 1;
            option((char *)(void *)0);
          }

          else
          {
            if(!(noop == 0))
              tmp_if_expr_14 = (_Bool)1;

            else
            {
              return_value_option_13=option(argv[(signed long int)n]);
              tmp_if_expr_14 = return_value_option_13 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_14)
            {
              if(g.decode == 0 && g.list == 0 && done == 1ul && g.form >= 2 && !(g.pipeout == 0))
                complain("warning: output will be concatenated zip files -- %s will not be able to extract", g.prog);

              signed int return_value_strcmp_11;
              return_value_strcmp_11=strcmp(argv[(signed long int)n], "-");
              if(!(return_value_strcmp_11 == 0))
                tmp_if_expr_12 = argv[(signed long int)n];

              else
                tmp_if_expr_12 = (char *)(void *)0;
              process(tmp_if_expr_12);
              done = done + 1ul;
            }

          }
        }
        option((char *)(void *)0);
        if(done == 0ul)
          process((char *)(void *)0);

      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int main__1__1__3__1__try_ret_;
        main__1__1__3__1__try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(main__1__1__3__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }


  __CPROVER_DUMP_L45:
    ;
    do
    {
      if(!(g.inf == ((char *)NULL)))
      {
        free((void *)g.inf);
        g.inf = (char *)(void *)0;
      }

      g.inz = (unsigned long int)0;
      new_opts();
    }
    while((_Bool)0);
    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

  return 0;
}

// my_malloc
// file yarn.c line 81
static void * my_malloc(unsigned long int size)
{
  void *block;
  block=my_malloc_f(size);
  if(block == NULL)
    fail(12);

  return block;
}

// new_lock
// file yarn.h line 124
struct lock_s * new_lock(signed long int initial)
{
  signed int ret;
  struct lock_s *bolt;
  void *return_value_my_malloc_1;
  return_value_my_malloc_1=my_malloc(sizeof(struct lock_s) /*96ul*/ );
  bolt = (struct lock_s *)return_value_my_malloc_1;
  ret=pthread_mutex_init(&bolt->mutex, (const union anonymous_7 *)(void *)0);
  _Bool tmp_if_expr_2;
  if(!(ret == 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    ret=pthread_cond_init(&bolt->cond, (const union anonymous_7 *)(void *)0);
    tmp_if_expr_2 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    fail(ret);

  bolt->value = initial;
  return bolt;
}

// new_opts
// file pigz.c line 3873
static void new_opts(void)
{
  single_compress(1);
  finish_jobs();
}

// new_pool
// file pigz.c line 1245
static void new_pool(struct pool *pool, unsigned long int size, signed int limit)
{
  pool->have=new_lock((signed long int)0);
  pool->head = (struct space *)(void *)0;
  pool->size = size;
  pool->limit = limit;
  pool->made = 0;
}

// nprocs
// file pigz.c line 3804
static signed int nprocs(signed int n)
{
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(84);
  n = (signed int)return_value_sysconf_1;
  return n;
}

// num
// file pigz.c line 3882
static unsigned long int num(char *arg)
{
  char *str = arg;
  unsigned long int val = (unsigned long int)0;
  if((signed int)*str == 0)
    try_throw_(22, "internal error: empty parameter", (void *)0);

  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  do
  {
    if(!((signed int)*str >= 48))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*str > 57 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(val == 0ul))
        tmp_if_expr_2 = (~((unsigned long int)0) - (unsigned long int)((signed int)*str - 48)) / val < (unsigned long int)10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      try_throw_(22, "invalid numeric parameter: %s", arg, (void *)0);

    val = val * (unsigned long int)10 + (unsigned long int)((signed int)*str - 48);
    str = str + 1l;
  }
  while(!(*str == 0));
  return val;
}

// option
// file pigz.c line 3899
static signed int option(char *arg)
{
  char bad[3l] = { '-', 'X', 0 };
  _Bool tmp_if_expr_1;
  static signed int get = 0;
  if(!(get == 0))
  {
    if(arg == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*arg == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      bad[(signed long int)1] = "bpSIM"[(signed long int)(get - 1)];
      try_throw_(22, "missing parameter after %s", (const void *)bad, (void *)0);
    }

  }

  signed int return_value_strcmp_2;
  unsigned long int return_value_num_3;
  unsigned long int return_value_num_4;
  if(arg == ((char *)NULL))
    return 0;

  else
    if((signed int)*arg == 45)
    {
      arg = arg + 1l;
      if((signed int)*arg == 0)
        return 1;

      if((signed int)*arg == 45)
      {
        signed int j;
        arg = arg + 1l;
        j = (signed int)(sizeof(char *[34l][2l]) /*544ul*/  / (sizeof(char *) /*8ul*/  << 1) - (unsigned long int)1);
        for( ; j >= 0; j = j - 1)
        {
          return_value_strcmp_2=strcmp(arg, longopts[(signed long int)j][(signed long int)0]);
          if(return_value_strcmp_2 == 0)
          {
            arg = longopts[(signed long int)j][(signed long int)1];
            break;
          }

        }
        if(!(j >= 0))
          try_throw_(22, "invalid option: %s", arg - (signed long int)2, (void *)0);

      }

      while((_Bool)1)
      {
        if(!(get == 0))
        {
          if(get == 3)
            try_throw_(22, "invalid usage: -s must be followed by space", (void *)0);

          goto __CPROVER_DUMP_L49;
        }

        bad[(signed long int)1] = *arg;
        switch((signed int)*arg)
        {
          case 48:

          case 49:

          case 50:

          case 51:

          case 52:

          case 53:

          case 54:

          case 55:

          case 56:

          case 57:
          {
            g.level = (signed int)*arg - 48;
            for( ; (signed int)arg[1l] >= 48; g.level = (g.level * 10 + (signed int)*arg) - 48)
            {
              if((signed int)arg[1l] >= 58)
                break;

              if(!(g.level == 0))
              {
                if(!((0x7fffffff + -((signed int)arg[1l] + -48)) / g.level >= 10))
                  try_throw_(22, "only levels 0..9 and 11 are allowed", (void *)0);

              }

              arg = arg + 1l;
            }
            if(g.level == 10 || g.level >= 12)
              try_throw_(22, "only levels 0..9 and 11 are allowed", (void *)0);

            new_opts();
            break;
          }
          case 70:
          {
            g.zopts.blocksplittinglast = 1;
            break;
          }
          case 73:
          {
            get = 4;
            break;
          }
          case 75:
          {
            g.form = 2;
            g.sufx = ".zip";
            break;
          }
          case 76:
          {
            fputs("pigz 2.3.3\n", stderr);
            fputs("Copyright (C) 2007-2015 Mark Adler\n", stderr);
            fputs("Subject to the terms of the zlib license.\n", stderr);
            fputs("No warranty is provided or implied.\n", stderr);
            exit(0);
          }
          case 77:
          {
            get = 5;
            break;
          }
          case 78:
          {
            g.headis = g.headis | 0xf;
            break;
          }
          case 79:
          {
            g.zopts.blocksplitting = 0;
            break;
          }
          case 82:
          {
            g.rsync = 1;
            break;
          }
          case 83:
          {
            get = 3;
            break;
          }
          case 84:
          {
            g.headis = g.headis & ~0xa;
            break;
          }
          case 86:
          {
            fputs("pigz 2.3.3\n", stderr);
            exit(0);
          }
          case 90:
            try_throw_(22, "invalid option: LZW output not supported: %s", (const void *)bad, (void *)0);
          case 97:
            try_throw_(22, "invalid option: no ascii conversion: %s", (const void *)bad, (void *)0);
          case 98:
          {
            get = 1;
            break;
          }
          case 99:
          {
            g.pipeout = 1;
            break;
          }
          case 100:
          {
            if(g.decode == 0)
              g.headis = g.headis >> 2;

            g.decode = 1;
            break;
          }
          case 102:
          {
            g.force = 1;
            break;
          }
          case 104:
          {
            help();
            break;
          }
          case 105:
          {
            g.setdict = 0;
            break;
          }
          case 107:
          {
            g.keep = 1;
            break;
          }
          case 108:
          {
            g.list = 1;
            break;
          }
          case 110:
          {
            g.headis = g.headis & ~5;
            break;
          }
          case 112:
          {
            get = 2;
            break;
          }
          case 113:
          {
            g.verbosity = 0;
            break;
          }
          case 114:
          {
            g.recurse = 1;
            break;
          }
          case 116:
          {
            g.decode = 2;
            break;
          }
          case 118:
          {
            g.verbosity = g.verbosity + 1;
            break;
          }
          case 122:
          {
            g.form = 1;
            g.sufx = ".zz";
            break;
          }
          default:
            try_throw_(22, "invalid option: %s", (const void *)bad, (void *)0);
        }
        arg = arg + 1l;
        if(*arg == 0)
          break;

      }

    __CPROVER_DUMP_L49:
      ;
      if(!((signed int)*arg == 0))
        goto __CPROVER_DUMP_L50;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L50:
      ;
      if(!(get == 0))
      {
        unsigned long int n;
        if(get == 1)
        {
          n=num(arg);
          g.block = n << 10;
          if(!(g.block >= 32768ul))
            try_throw_(22, "block size too small (must be >= 32K)", (void *)0);

          if(g.block >= 536870913ul || !(n == g.block >> 10) || !(32768l + (signed long int)(g.block >> 4) + (signed long int)g.block >= 0l) || !(32768ul + (g.block >> 4) + g.block >= g.block))
            try_throw_(22, "block size too large: %s", arg, (void *)0);

          new_opts();
        }

        else
          if(get == 2)
          {
            n=num(arg);
            g.procs = (signed int)n;
            if(!(g.procs >= 1))
              try_throw_(22, "invalid number of processes: %s", arg, (void *)0);

            if(!((unsigned long int)g.procs == n) || !(3 + (g.procs << 1) >= 1))
              try_throw_(22, "too many processes: %s", arg, (void *)0);

            new_opts();
          }

          else
            if(get == 3)
              g.sufx = arg;

            else
              if(get == 4)
              {
                return_value_num_3=num(arg);
                g.zopts.numiterations = (signed int)return_value_num_3;
              }

              else
                if(get == 5)
                {
                  return_value_num_4=num(arg);
                  g.zopts.blocksplittingmax = (signed int)return_value_num_4;
                }

        get = 0;
        return 0;
      }

      return 1;
    }
}

// outb
// file pigz.c line 2974
static signed int outb(void *desc, unsigned char *buf, unsigned int len)
{
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_adler32_1;
  unsigned long int return_value_crc32_2;
  if(g.procs >= 2)
  {
    static struct thread_s *ch;
    static struct thread_s *wr;
    if(outb_write_more == ((struct lock_s *)NULL))
    {
      outb_write_more=new_lock((signed long int)0);
      outb_check_more=new_lock((signed long int)0);
      wr=launch(outb_write, (void *)0);
      ch=launch(outb_check, (void *)0);
    }

    possess(outb_check_more);
    wait_for(outb_check_more, (enum wait_op)TO_BE, (signed long int)0);
    possess(outb_write_more);
    wait_for(outb_write_more, (enum wait_op)TO_BE, (signed long int)0);
    out_len = (unsigned long int)len;
    g.out_tot = g.out_tot + (signed long int)len;
    memcpy((void *)out_copy, (const void *)buf, (unsigned long int)len);
    twist(outb_write_more, (enum twist_op)TO, (signed long int)1);
    twist(outb_check_more, (enum twist_op)TO, (signed long int)1);
    if(len == 0u && !(outb_write_more == ((struct lock_s *)NULL)))
    {
      if(!(desc == NULL))
      {
        destruct(ch);
        destruct(wr);
      }

      else
      {
        join(ch);
        join(wr);
      }
      free_lock(outb_check_more);
      free_lock(outb_write_more);
      outb_write_more = (struct lock_s *)(void *)0;
    }

    return 0;
  }

  else
  {
    (void)desc;
    if(!(len == 0u))
    {
      if(g.decode == 1)
        writen(g.outd, buf, (unsigned long int)len);

      if(g.form == 1)
      {
        return_value_adler32_1=adler32(g.out_check, buf, len);
        tmp_if_expr_3 = return_value_adler32_1;
      }

      else
      {
        return_value_crc32_2=crc32(g.out_check, buf, len);
        tmp_if_expr_3 = return_value_crc32_2;
      }
      g.out_check = tmp_if_expr_3;
      g.out_tot = g.out_tot + (signed long int)len;
    }

    return 0;
  }
}

// outb_check
// file pigz.c line 2945
static void outb_check(void *dummy)
{
  unsigned long int len;
  struct anonymous err;
  (void)dummy;
  unsigned long int tmp_if_expr_4;
  unsigned long int return_value_adler32_2;
  unsigned long int return_value_crc32_3;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int outb_check__1__1__1__try_ret_;
      outb_check__1__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(outb_check__1__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_5;
    return_value__setjmp_5=_setjmp(try_this_.env);
    if(!(return_value__setjmp_5 >= 2))
      do
      {

      __CPROVER_DUMP_L3:
        ;
        possess(outb_check_more);
        wait_for(outb_check_more, (enum wait_op)TO_BE, (signed long int)1);
        len = out_len;
        if(g.form == 1)
        {
          return_value_adler32_2=adler32(g.out_check, out_copy, (unsigned int)len);
          tmp_if_expr_4 = return_value_adler32_2;
        }

        else
        {
          return_value_crc32_3=crc32(g.out_check, out_copy, (unsigned int)len);
          tmp_if_expr_4 = return_value_crc32_3;
        }
        g.out_check = tmp_if_expr_4;
        twist(outb_check_more, (enum twist_op)TO, (signed long int)0);
        if(!(len == 0ul))
          goto __CPROVER_DUMP_L3;

      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

}

// outb_write
// file pigz.c line 2919
static void outb_write(void *dummy)
{
  unsigned long int len;
  struct anonymous err;
  (void)dummy;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int try_ret_;
      try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_2;
    return_value__setjmp_2=_setjmp(try_this_.env);
    if(!(return_value__setjmp_2 >= 2))
      do
      {

      __CPROVER_DUMP_L3:
        ;
        possess(outb_write_more);
        wait_for(outb_write_more, (enum wait_op)TO_BE, (signed long int)1);
        len = out_len;
        if(g.decode == 1 && !(len == 0ul))
          writen(g.outd, out_copy, len);

        twist(outb_write_more, (enum twist_op)TO, (signed long int)0);
        if(!(len == 0ul))
          goto __CPROVER_DUMP_L3;

      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int outb_write__1__1__3__1__try_ret_;
        outb_write__1__1__3__1__try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(outb_write__1__1__3__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

}

// parallel_compress
// file pigz.c line 1828
static void parallel_compress(void)
{
  signed long int seq;
  struct space *curr;
  struct space *next;
  struct space *hold;
  struct space *dict;
  struct job *job;
  signed int more;
  unsigned int hash;
  unsigned char *scan;
  unsigned char *end;
  unsigned char *last;
  unsigned long int left;
  unsigned long int len;
  setup_jobs();
  writeth=launch(write_thread, (void *)0);
  seq = (signed long int)0;
  next=get_space(&in_pool);
  next->len=readn(g.ind, next->buf, next->size);
  hold = (struct space *)(void *)0;
  dict = (struct space *)(void *)0;
  scan = next->buf;
  hash = (1U << 12) - (unsigned int)1 >> 1;
  left = (unsigned long int)0;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  do
  {
    void *return_value_alloc_1;
    return_value_alloc_1=alloc((void *)0, sizeof(struct job) /*64ul*/ );
    job = (struct job *)return_value_alloc_1;
    job->calc=new_lock((signed long int)0);
    curr = next;
    next = hold;
    hold = (struct space *)(void *)0;
    if(next == ((struct space *)NULL))
    {
      next=get_space(&in_pool);
      next->len=readn(g.ind, next->buf, next->size);
    }

    job->lens = (struct space *)(void *)0;
    if(!(g.rsync == 0))
    {
      if(!(curr->len == 0ul))
      {
        if(left == 0ul)
        {
          last = curr->buf;
          end = curr->buf + (signed long int)curr->len;
          while(!(scan >= end))
          {
            tmp_post_2 = scan;
            scan = scan + 1l;
            hash = (hash << 1 ^ (unsigned int)*tmp_post_2) & (1U << 12) - (unsigned int)1;
            if(hash == 2047u)
            {
              len = (unsigned long int)(scan - last);
              append_len(job, len);
              last = scan;
            }

          }
          left = (unsigned long int)(scan - last);
          scan = next->buf;
        }

        last = next->buf;
        len = curr->size - curr->len;
        if(!(next->len >= len))
          len = next->len;

        end = next->buf + (signed long int)len;
        while(!(scan >= end))
        {
          tmp_post_3 = scan;
          scan = scan + 1l;
          hash = (hash << 1 ^ (unsigned int)*tmp_post_3) & (1U << 12) - (unsigned int)1;
          if(hash == 2047u)
          {
            len = (unsigned long int)(scan - last) + left;
            left = (unsigned long int)0;
            append_len(job, len);
            last = scan;
          }

        }
        append_len(job, (unsigned long int)0);
        len = (unsigned long int)((job->lens->len == (unsigned long int)1 ? scan : last) - next->buf);
        if(!(len == 0ul))
        {
          memcpy((void *)(curr->buf + (signed long int)curr->len), (const void *)next->buf, len);
          curr->len = curr->len + len;
          memmove((void *)next->buf, (const void *)(next->buf + (signed long int)len), next->len - len);
          next->len = next->len - len;
          scan = scan - (signed long int)len;
          left = (unsigned long int)0;
        }

        else
        {
          if(!(job->lens->len == 1ul) && !(left == 0ul))
            tmp_if_expr_4 = next->len != 0ul ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            hold = next;
            next=get_space(&in_pool);
            memcpy((void *)next->buf, (const void *)(curr->buf + (signed long int)(curr->len - left)), left);
            next->len = left;
            curr->len = curr->len - left;
          }

          else
            left = (unsigned long int)0;
        }
      }

    }

    job->in = curr;
    more = (signed int)(next->len != (unsigned long int)0);
    job->more = more;
    job->out = dict;
    if(!(g.setdict == 0) && !(more == 0))
    {
      if(curr->len >= 32768ul)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = job->out == (struct space *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        dict = curr;
        use_space(dict);
      }

      else
      {
        dict=get_space(&dict_pool);
        len = (unsigned long int)32768U - curr->len;
        memcpy((void *)dict->buf, (const void *)(job->out->buf + (signed long int)(job->out->len - len)), len);
        memcpy((void *)(dict->buf + (signed long int)len), (const void *)curr->buf, curr->len);
        dict->len = (unsigned long int)32768U;
      }
    }

    job->seq = seq;
    seq = seq + 1l;
    if(!(seq >= 1l))
      try_throw_(75, "overflow", (void *)0);

    if(!(cthreads >= g.procs) && !((signed long int)cthreads >= seq))
    {
      launch(compress_thread, (void *)0);
      cthreads = cthreads + 1;
    }

    possess(compress_have);
    job->next = (struct job *)(void *)0;
    *compress_tail = job;
    compress_tail = &job->next;
    twist(compress_have, (enum twist_op)BY, (signed long int)+1);
  }
  while(!(more == 0));
  drop_space(next);
  join(writeth);
  writeth = (struct thread_s *)(void *)0;
}

// peek_lock
// file yarn.h line 133
signed long int peek_lock(struct lock_s *bolt)
{
  return bolt->value;
}

// possess
// file yarn.h line 125
void possess(struct lock_s *bolt)
{
  signed int ret;
  ret=pthread_mutex_lock(&bolt->mutex);
  if(!(ret == 0))
    fail(ret);

}

// process
// file pigz.c line 3423
static void process(char *path)
{
  volatile signed int method = -1;
  unsigned long int len;
  struct stat st;
  struct anonymous err;
  signed long int tmp_if_expr_4;
  signed int return_value_fstat_1;
  signed long int tmp_if_expr_3;
  signed long int return_value_time_2;
  char **tmp_post_8;
  signed int return_value_lstat_5;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_13;
  signed int *return_value___errno_location_12;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_20;
  unsigned long int tmp_if_expr_22;
  unsigned long int return_value_vstrcpy_21;
  unsigned long int return_value_strlen_23;
  unsigned long int return_value_strlen_26;
  unsigned long int return_value_strlen_24;
  signed int return_value_strcmp_25;
  signed int *return_value___errno_location_28;
  signed int *return_value___errno_location_29;
  char *return_value_strerror_30;
  char *tmp_if_expr_32;
  char *return_value_justname_31;
  if(path == ((char *)NULL))
  {
    vstrcpy(&g.inf, &g.inz, (unsigned long int)0, (void *)"<stdin>");
    g.ind = 0;
    g.name = (char *)(void *)0;
    if(!((2 & g.headis) == 0))
    {
      return_value_fstat_1=fstat(g.ind, &st);
      if(!(return_value_fstat_1 == 0))
      {
        return_value_time_2=time((signed long int *)(void *)0);
        tmp_if_expr_3 = return_value_time_2;
      }

      else
        tmp_if_expr_3 = st.st_mtim.tv_sec;
      tmp_if_expr_4 = tmp_if_expr_3;
    }

    else
      tmp_if_expr_4 = (signed long int)0;
    g.mtime = tmp_if_expr_4;
    len = (unsigned long int)0;
  }

  else
  {
    if(!(path == g.inf))
      vstrcpy(&g.inf, &g.inz, (unsigned long int)0, (void *)path);

    len=strlen(g.inf);
    signed int return_value_lstat_15;
    return_value_lstat_15=lstat(g.inf, &st);
    if(!(return_value_lstat_15 == 0))
    {
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      if(*return_value___errno_location_10 == 2)
      {
        if(!(g.decode == 0) || !(g.list == 0))
        {
          static char *sufs[12l] = { ".z", "-z", "_z", ".Z", ".gz", "-gz", ".zz", "-zz", ".zip", ".ZIP", ".tgz", (char *)(void *)0 };
          char **sufx = sufs;
          while(!(*sufx == ((char *)NULL)))
          {
            tmp_post_8 = sufx;
            sufx = sufx + 1l;
            vstrcpy(&g.inf, &g.inz, len, (void *)*tmp_post_8);
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            *return_value___errno_location_9 = 0;
            return_value_lstat_5=lstat(g.inf, &st);
            if(!(return_value_lstat_5 == 0))
            {
              return_value___errno_location_6=__errno_location();
              tmp_if_expr_7 = *return_value___errno_location_6 == 2 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_7 = (_Bool)0;
            if(!tmp_if_expr_7)
              break;

          }
        }

      }

      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      if(*return_value___errno_location_11 == 75)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value___errno_location_12=__errno_location();
        tmp_if_expr_13 = *return_value___errno_location_12 == 27 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        try_throw_(33, "%s too large -- not compiled with large file support", g.inf, (void *)0);

      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      if(!(*return_value___errno_location_14 == 0))
      {
        g.inf[(signed long int)len] = (char)0;
        complain("skipping: %s does not exist", g.inf);
        goto __CPROVER_DUMP_L117;
      }

      len=strlen(g.inf);
    }

    if(!((61440u & st.st_mode) == 16384u) && !((61440u & st.st_mode) == 32768u) && !((61440u & st.st_mode) == 40960u))
    {
      complain("skipping: %s is a special file or device", g.inf);
      goto __CPROVER_DUMP_L117;
    }

    if((61440u & st.st_mode) == 40960u && g.force == 0 && g.pipeout == 0)
    {
      complain("skipping: %s is a symbolic link", g.inf);
      goto __CPROVER_DUMP_L117;
    }

    if((61440u & st.st_mode) == 16384u && g.recurse == 0)
    {
      complain("skipping: %s is a directory", g.inf);
      goto __CPROVER_DUMP_L117;
    }

    if((61440u & st.st_mode) == 16384u)
    {
      char *roll = (char *)(void *)0;
      unsigned long int size = (unsigned long int)0;
      unsigned long int off = (unsigned long int)0;
      unsigned long int base;
      struct __dirstream *here;
      struct dirent *next;
      here=opendir(g.inf);
      if(here == ((struct __dirstream *)NULL))
        goto __CPROVER_DUMP_L117;

      do
      {
        next=readdir(here);
        if(next == ((struct dirent *)NULL))
          break;

        if((signed int)next->d_name[0l] == 0)
          tmp_if_expr_19 = (_Bool)1;

        else
        {
          if((signed int)next->d_name[0l] == 46)
          {
            if((signed int)next->d_name[1l] == 0)
              tmp_if_expr_17 = (_Bool)1;

            else
            {
              if((signed int)next->d_name[1l] == 46)
                tmp_if_expr_16 = (signed int)next->d_name[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_16 = (_Bool)0;
              tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_18 = (_Bool)0;
          tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_19)
          off=vstrcpy(&roll, &size, off, (void *)next->d_name);

      }
      while((_Bool)1);
      closedir(here);
      vstrcpy(&roll, &size, off, (void *)"");
      if(!(len == 0ul))
        tmp_if_expr_20 = (signed int)g.inf[(signed long int)(len - (unsigned long int)1)] != (signed int)(unsigned char)47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_20 = (_Bool)0;
      if(tmp_if_expr_20)
      {
        return_value_vstrcpy_21=vstrcpy(&g.inf, &g.inz, len, (void *)"/");
        tmp_if_expr_22 = return_value_vstrcpy_21;
      }

      else
        tmp_if_expr_22 = len;
      base = tmp_if_expr_22;
      off = (unsigned long int)0;
      for( ; !(roll[(signed long int)off] == 0); off = off + return_value_strlen_23 + (unsigned long int)1)
      {
        vstrcpy(&g.inf, &g.inz, base, (void *)(roll + (signed long int)off));
        process(g.inf);
        return_value_strlen_23=strlen(roll + (signed long int)off);
      }
      g.inf[(signed long int)len] = (char)0;
      free((void *)roll);
      goto __CPROVER_DUMP_L117;
    }

    if(g.decode == 0 && g.force == 0 && g.list == 0)
    {
      return_value_strlen_26=strlen(g.sufx);
      if(len >= return_value_strlen_26)
      {
        return_value_strlen_24=strlen(g.sufx);
        return_value_strcmp_25=strcmp((g.inf + (signed long int)len) - (signed long int)return_value_strlen_24, g.sufx);
        if(return_value_strcmp_25 == 0)
        {
          complain("skipping: %s ends with %s", g.inf, g.sufx);
          goto __CPROVER_DUMP_L117;
        }

      }

    }

    if(g.decode == 1 && g.list == 0 && g.pipeout == 0)
    {
      signed int suf;
      unsigned long int return_value_compressed_suffix_27;
      return_value_compressed_suffix_27=compressed_suffix(g.inf);
      suf = (signed int)return_value_compressed_suffix_27;
      if(suf == 0)
      {
        complain("skipping: %s does not have compressed suffix", g.inf);
        goto __CPROVER_DUMP_L117;
      }

      len = len - (unsigned long int)suf;
    }

    g.ind=open(g.inf, 00, 0);
    if(!(g.ind >= 0))
    {
      return_value___errno_location_28=__errno_location();
      return_value___errno_location_29=__errno_location();
      return_value_strerror_30=strerror(*return_value___errno_location_29);
      try_throw_(*return_value___errno_location_28, "read error on %s (%s)", g.inf, return_value_strerror_30, (void *)0);
    }

    if(!((1 & g.headis) == 0))
    {
      return_value_justname_31=justname(g.inf);
      tmp_if_expr_32 = return_value_justname_31;
    }

    else
      tmp_if_expr_32 = (char *)(void *)0;
    g.name = tmp_if_expr_32;
    g.mtime = (g.headis & 2) != 0 ? st.st_mtim.tv_sec : (signed long int)0;
  }
  do
    if(!(g.hname == ((char *)NULL)))
    {
      free((void *)g.hname);
      g.hname = (char *)(void *)0;
    }

  while((_Bool)0);
  signed int return_value_isatty_40;
  signed int return_value_strcmp_42;
  signed int *return_value___errno_location_46;
  signed int return_value_isatty_45;
  signed int *return_value___errno_location_47;
  signed int *return_value___errno_location_48;
  signed int *return_value___errno_location_49;
  char *return_value_strerror_50;
  signed int *return_value___errno_location_56;
  signed int *return_value___errno_location_57;
  char *return_value_strerror_58;
  if(!(g.decode == 0))
  {
    in_init();
    method=get_header(1);
    if(!(method == 8) && !(method == 257) && (!(g.list == 0) || !(method == -2) || g.decode == 2 || g.force == 0 || g.pipeout == 0))
    {
      do
        if(!(g.hname == ((char *)NULL)))
        {
          free((void *)g.hname);
          g.hname = (char *)(void *)0;
        }

      while((_Bool)0);
      if(!(g.ind == 0))
        close(g.ind);

      if(!(method == -1))
        complain(method < 0 ? (method != -6 ? "skipping: %s is not compressed" : "skipping: %s corrupted: invalid header crc") : "skipping: %s has unknown compression method", g.inf);

      goto __CPROVER_DUMP_L117;
    }

    if(!(g.decode == 2))
      goto __CPROVER_DUMP_L66;

    do
    {
      struct try_s_ try_this_;
      signed int try_pushed_ = 1;
      try_this_.ball.code = 0;
      try_this_.ball.free = 0;
      try_this_.ball.why = (char *)(void *)0;
      try_setup_();
      void *return_value_pthread_getspecific_33;
      return_value_pthread_getspecific_33=pthread_getspecific(try_key_);
      try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_33;
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      signed int return_value__setjmp_34;
      return_value__setjmp_34=_setjmp(try_this_.env);
      if(!(return_value__setjmp_34 >= 2))
        do
          if(method == 8)
            infchk();

          else
          {
            unlzw();
            if(!(g.list == 0))
            {
              g.in_tot = g.in_tot - (signed long int)3;
              show_info(method, (unsigned long int)0, g.out_tot, 0);
            }

          }
        while((_Bool)0);

      if(!(try_pushed_ == 0))
      {
        do
        {
          signed int process__1__4__2__1__3__1__try_ret_;
          process__1__4__2__1__3__1__try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
          /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
          assert(process__1__4__2__1__3__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
        }
        while((_Bool)0);
        try_pushed_ = 0;
      }

      err = try_this_.ball;
    }
    while((_Bool)0);
    if(!(err.code == 0))
    {
      if(!(err.code == 33))
        do
        {
          try_setup_();
          void *return_value_pthread_getspecific_35;
          return_value_pthread_getspecific_35=pthread_getspecific(try_key_);
          /* assertion ((try_t_ *)pthread_getspecific(try_key_)) != ((void *)0) && "try: naked punt" */
          assert((struct try_s_ *)return_value_pthread_getspecific_35 != (struct try_s_ *)(void *)0 ? ((_Bool)"try: naked punt" ? (_Bool)1 : (_Bool)0) : (_Bool)0);
          void *return_value_pthread_getspecific_36;
          return_value_pthread_getspecific_36=pthread_getspecific(try_key_);
          ((struct try_s_ *)return_value_pthread_getspecific_36)->ball = err;
          void *return_value_pthread_getspecific_37;
          return_value_pthread_getspecific_37=pthread_getspecific(try_key_);
          longjmp(((struct try_s_ *)return_value_pthread_getspecific_37)->env, 2);
        }
        while((_Bool)0);

      complain("skipping: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      outb((void *)&g, (unsigned char *)(void *)0, (unsigned int)0);
    }

    do
      if(!(g.hname == ((char *)NULL)))
      {
        free((void *)g.hname);
        g.hname = (char *)(void *)0;
      }

    while((_Bool)0);
    if(!(g.ind == 0))
      close(g.ind);

  }

  else
  {

  __CPROVER_DUMP_L66:
    ;
    if(!(g.list == 0))
    {
      list_info();
      do
        if(!(g.hname == ((char *)NULL)))
        {
          free((void *)g.hname);
          g.hname = (char *)(void *)0;
        }

      while((_Bool)0);
      if(!(g.ind == 0))
        close(g.ind);

    }

    else
    {
      if(path == ((char *)NULL) || !(g.pipeout == 0))
      {
        unsigned long int return_value_strlen_38;
        return_value_strlen_38=strlen("<stdout>");
        void *return_value_alloc_39;
        return_value_alloc_39=alloc((void *)0, return_value_strlen_38 + (unsigned long int)1);
        g.outf = (char *)return_value_alloc_39;
        strcpy(g.outf, "<stdout>");
        g.outd = 1;
        if(g.decode == 0 && g.force == 0)
        {
          return_value_isatty_40=isatty(g.outd);
          if(!(return_value_isatty_40 == 0))
            try_throw_(22, "trying to write compressed data to a terminal (use -f to force)", (void *)0);

        }

      }

      else
      {
        char *to = g.inf;
        char *process__1__7__sufx = "";
        unsigned long int pre = (unsigned long int)0;
        if(!(g.decode == 0))
        {
          if(!((1 & g.headis) == 0) && !(g.hname == ((char *)NULL)))
          {
            char *return_value_justname_41;
            return_value_justname_41=justname(g.inf);
            pre = (unsigned long int)(return_value_justname_41 - g.inf);
            to=justname(g.hname);
            len=strlen(to);
          }

          else
          {
            return_value_strcmp_42=strcmp(to + (signed long int)len, ".tgz");
            if(return_value_strcmp_42 == 0)
              process__1__7__sufx = ".tar";

          }
        }

        else
          process__1__7__sufx = g.sufx;
        unsigned long int return_value_strlen_43;
        return_value_strlen_43=strlen(process__1__7__sufx);
        void *return_value_alloc_44;
        return_value_alloc_44=alloc((void *)0, pre + len + return_value_strlen_43 + (unsigned long int)1);
        g.outf = (char *)return_value_alloc_44;
        memcpy((void *)g.outf, (const void *)g.inf, pre);
        memcpy((void *)(g.outf + (signed long int)pre), (const void *)to, len);
        strcpy(g.outf + (signed long int)pre + (signed long int)len, process__1__7__sufx);
        g.outd=open(g.outf, 0100 | 01000 | 01 | (g.force != 0 ? 0 : 0200), 0600);
        if(!(g.outd >= 0))
        {
          return_value___errno_location_46=__errno_location();
          if(*return_value___errno_location_46 == 17)
          {
            return_value_isatty_45=isatty(0);
            if(!(return_value_isatty_45 == 0))
            {
              if(!(g.verbosity == 0))
              {
                signed int ch;
                signed int reply;
                fprintf(stderr, "%s exists -- overwrite (y/n)? ", g.outf);
                fflush(stderr);
                reply = -1;
                do
                {
                  ch=getchar();
                  if(!(ch == 9) && !(ch == 32) && !(reply >= 0))
                    reply = ch == 121 || ch == 89 ? 1 : 0;

                }
                while(!(ch == 10) && !(ch == 13) && !(ch == -1));
                if(reply == 1)
                  g.outd=open(g.outf, 0100 | 01000 | 01, 0600);

              }

            }

          }

        }

        if(!(g.outd >= 0))
        {
          return_value___errno_location_47=__errno_location();
          if(*return_value___errno_location_47 == 17)
          {
            complain("skipping: %s exists", g.outf);
            do
              if(!(g.outf == ((char *)NULL)))
              {
                free((void *)g.outf);
                g.outf = (char *)(void *)0;
              }

            while((_Bool)0);
            do
              if(!(g.hname == ((char *)NULL)))
              {
                free((void *)g.hname);
                g.hname = (char *)(void *)0;
              }

            while((_Bool)0);
            if(!(g.ind == 0))
              close(g.ind);

            goto __CPROVER_DUMP_L117;
          }

        }

        if(!(g.outd >= 0))
        {
          return_value___errno_location_48=__errno_location();
          return_value___errno_location_49=__errno_location();
          return_value_strerror_50=strerror(*return_value___errno_location_49);
          try_throw_(*return_value___errno_location_48, "write error on %s (%s)", g.outf, return_value_strerror_50, (void *)0);
        }

      }
      do
        if(!(g.hname == ((char *)NULL)))
        {
          free((void *)g.hname);
          g.hname = (char *)(void *)0;
        }

      while((_Bool)0);
      if(g.verbosity >= 2)
        fprintf(stderr, "%s to %s ", g.inf, g.outf);

      if(!(g.decode == 0))
      {
        do
        {
          struct try_s_ process__1__9__1__try_this_;
          signed int process__1__9__1__try_pushed_ = 1;
          process__1__9__1__try_this_.ball.code = 0;
          process__1__9__1__try_this_.ball.free = 0;
          process__1__9__1__try_this_.ball.why = (char *)(void *)0;
          try_setup_();
          void *return_value_pthread_getspecific_51;
          return_value_pthread_getspecific_51=pthread_getspecific(try_key_);
          process__1__9__1__try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_51;
          do
          {
            signed int process__1__9__1__1__try_ret_;
            process__1__9__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&process__1__9__1__try_this_);
            /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
            assert(process__1__9__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
          }
          while((_Bool)0);
          signed int return_value__setjmp_52;
          return_value__setjmp_52=_setjmp(process__1__9__1__try_this_.env);
          if(!(return_value__setjmp_52 >= 2))
            do
              if(method == 8)
                infchk();

              else
                if(method == 257)
                  unlzw();

                else
                  cat();
            while((_Bool)0);

          if(!(process__1__9__1__try_pushed_ == 0))
          {
            do
            {
              signed int process__1__9__1__3__1__try_ret_;
              process__1__9__1__3__1__try_ret_=pthread_setspecific(try_key_, (const void *)process__1__9__1__try_this_.next);
              /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
              assert(process__1__9__1__3__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
            }
            while((_Bool)0);
            process__1__9__1__try_pushed_ = 0;
          }

          err = process__1__9__1__try_this_.ball;
        }
        while((_Bool)0);
        if(!(err.code == 0))
        {
          if(!(err.code == 33))
            do
            {
              try_setup_();
              void *return_value_pthread_getspecific_53;
              return_value_pthread_getspecific_53=pthread_getspecific(try_key_);
              /* assertion ((try_t_ *)pthread_getspecific(try_key_)) != ((void *)0) && "try: naked punt" */
              assert((struct try_s_ *)return_value_pthread_getspecific_53 != (struct try_s_ *)(void *)0 ? ((_Bool)"try: naked punt" ? (_Bool)1 : (_Bool)0) : (_Bool)0);
              void *return_value_pthread_getspecific_54;
              return_value_pthread_getspecific_54=pthread_getspecific(try_key_);
              ((struct try_s_ *)return_value_pthread_getspecific_54)->ball = err;
              void *return_value_pthread_getspecific_55;
              return_value_pthread_getspecific_55=pthread_getspecific(try_key_);
              longjmp(((struct try_s_ *)return_value_pthread_getspecific_55)->env, 2);
            }
            while((_Bool)0);

          complain("skipping: %s", err.why);
          do
            if(!(err.free == 0))
            {
              free((void *)err.why);
              err.free = 0;
              err.why = (char *)(void *)0;
            }

          while((_Bool)0);
          outb((void *)g.outf, (unsigned char *)(void *)0, (unsigned int)0);
          if(!(g.outd == 1) && !(g.outd == -1))
          {
            close(g.outd);
            g.outd = -1;
            unlink(g.outf);
            do
              if(!(g.outf == ((char *)NULL)))
              {
                free((void *)g.outf);
                g.outf = (char *)(void *)0;
              }

            while((_Bool)0);
          }

        }

      }

      else
        if(g.procs >= 2)
          parallel_compress();

        else
          single_compress(0);
      if(g.verbosity >= 2)
      {
        _IO_putc(10, stderr);
        fflush(stderr);
      }

      if(!(g.ind == 0))
        close(g.ind);

      if(!(g.outd == 1) && !(g.outd == -1))
      {
        signed int return_value_close_59;
        return_value_close_59=close(g.outd);
        if(!(return_value_close_59 == 0))
        {
          return_value___errno_location_56=__errno_location();
          return_value___errno_location_57=__errno_location();
          return_value_strerror_58=strerror(*return_value___errno_location_57);
          try_throw_(*return_value___errno_location_56, "write error on %s (%s)", g.outf, return_value_strerror_58, (void *)0);
        }

        g.outd = -1;
        if(!(g.ind == 0))
        {
          copymeta(g.inf, g.outf);
          if(g.keep == 0)
            unlink(g.inf);

        }

        if(!((2 & g.headis) == 0) && !(g.decode == 0) && !(g.stamp == 0l))
          touch(g.outf, g.stamp);

      }

      do
        if(!(g.outf == ((char *)NULL)))
        {
          free((void *)g.outf);
          g.outf = (char *)(void *)0;
        }

      while((_Bool)0);
    }
  }

__CPROVER_DUMP_L117:
  ;
}

// put_header
// file pigz.c line 960
static unsigned long int put_header(void)
{
  unsigned long int len;
  unsigned char head[30l];
  unsigned long int tmp_if_expr_6;
  unsigned long int return_value_strlen_5;
  unsigned long int tmp_if_expr_8;
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_9;
  unsigned long int tmp_if_expr_11;
  unsigned long int return_value_strlen_10;
  unsigned long int return_value_strlen_12;
  unsigned long int return_value_strlen_13;
  if(g.form >= 2)
  {
    head[0l] = (unsigned char)(0x04034b50UL & (unsigned long int)0xffff & (unsigned long int)0xff);
    head[(signed long int)1] = (unsigned char)((0x04034b50UL & (unsigned long int)0xffff) >> 8);
    head[(signed long int)2] = (unsigned char)(0x04034b50UL >> 16 & (unsigned long int)0xff);
    (head + (signed long int)2)[(signed long int)1] = (unsigned char)((0x04034b50UL >> 16) >> 8);
    head[(signed long int)4] = (unsigned char)(20 & 0xff);
    (head + (signed long int)4)[(signed long int)1] = (unsigned char)(20 >> 8);
    head[(signed long int)6] = (unsigned char)(8 & 0xff);
    (head + (signed long int)6)[(signed long int)1] = (unsigned char)(8 >> 8);
    head[(signed long int)8] = (unsigned char)(8 & 0xff);
    (head + (signed long int)8)[(signed long int)1] = (unsigned char)(8 >> 8);
    unsigned long int return_value_time2dos_1;
    return_value_time2dos_1=time2dos(g.mtime);
    head[(signed long int)10] = (unsigned char)(return_value_time2dos_1 & (unsigned long int)0xffff & (unsigned long int)0xff);
    unsigned long int return_value_time2dos_2;
    return_value_time2dos_2=time2dos(g.mtime);
    (head + (signed long int)10)[(signed long int)1] = (unsigned char)((return_value_time2dos_2 & (unsigned long int)0xffff) >> 8);
    unsigned long int return_value_time2dos_3;
    return_value_time2dos_3=time2dos(g.mtime);
    (head + (signed long int)10)[(signed long int)2] = (unsigned char)(return_value_time2dos_3 >> 16 & (unsigned long int)0xff);
    unsigned long int return_value_time2dos_4;
    return_value_time2dos_4=time2dos(g.mtime);
    (head + (signed long int)10 + (signed long int)2)[(signed long int)1] = (unsigned char)((return_value_time2dos_4 >> 16) >> 8);
    head[(signed long int)14] = (unsigned char)(0 & 0xffff & 0xff);
    (head + (signed long int)14)[(signed long int)1] = (unsigned char)((0 & 0xffff) >> 8);
    (head + (signed long int)14)[(signed long int)2] = (unsigned char)(0 >> 16 & 0xff);
    (head + (signed long int)14 + (signed long int)2)[(signed long int)1] = (unsigned char)((0 >> 16) >> 8);
    head[(signed long int)18] = (unsigned char)(0 & 0xffff & 0xff);
    (head + (signed long int)18)[(signed long int)1] = (unsigned char)((0 & 0xffff) >> 8);
    (head + (signed long int)18)[(signed long int)2] = (unsigned char)(0 >> 16 & 0xff);
    (head + (signed long int)18 + (signed long int)2)[(signed long int)1] = (unsigned char)((0 >> 16) >> 8);
    head[(signed long int)22] = (unsigned char)(0 & 0xffff & 0xff);
    (head + (signed long int)22)[(signed long int)1] = (unsigned char)((0 & 0xffff) >> 8);
    (head + (signed long int)22)[(signed long int)2] = (unsigned char)(0 >> 16 & 0xff);
    (head + (signed long int)22 + (signed long int)2)[(signed long int)1] = (unsigned char)((0 >> 16) >> 8);
    if(g.name == ((char *)NULL))
      tmp_if_expr_6 = (unsigned long int)1;

    else
    {
      return_value_strlen_5=strlen(g.name);
      tmp_if_expr_6 = return_value_strlen_5;
    }
    head[(signed long int)26] = (unsigned char)(tmp_if_expr_6 & (unsigned long int)0xff);
    if(g.name == ((char *)NULL))
      tmp_if_expr_8 = (unsigned long int)1;

    else
    {
      return_value_strlen_7=strlen(g.name);
      tmp_if_expr_8 = return_value_strlen_7;
    }
    (head + (signed long int)26)[(signed long int)1] = (unsigned char)(tmp_if_expr_8 >> 8);
    head[(signed long int)28] = (unsigned char)(9 & 0xff);
    (head + (signed long int)28)[(signed long int)1] = (unsigned char)(9 >> 8);
    writen(g.outd, head, (unsigned long int)30);
    len = (unsigned long int)30;
    if(g.name == ((char *)NULL))
      writen(g.outd, (unsigned char *)"-", (unsigned long int)1);

    else
    {
      return_value_strlen_9=strlen(g.name);
      writen(g.outd, (unsigned char *)g.name, return_value_strlen_9);
    }
    if(g.name == ((char *)NULL))
      tmp_if_expr_11 = (unsigned long int)1;

    else
    {
      return_value_strlen_10=strlen(g.name);
      tmp_if_expr_11 = return_value_strlen_10;
    }
    len = len + tmp_if_expr_11;
    head[0l] = (unsigned char)(0x5455 & 0xff);
    head[(signed long int)1] = (unsigned char)(0x5455 >> 8);
    head[(signed long int)2] = (unsigned char)(5 & 0xff);
    (head + (signed long int)2)[(signed long int)1] = (unsigned char)(5 >> 8);
    head[(signed long int)4] = (unsigned char)1;
    head[(signed long int)5] = (unsigned char)(g.mtime & (signed long int)0xffff & (signed long int)0xff);
    (head + (signed long int)5)[(signed long int)1] = (unsigned char)((g.mtime & (signed long int)0xffff) >> 8);
    (head + (signed long int)5)[(signed long int)2] = (unsigned char)(g.mtime >> 16 & (signed long int)0xff);
    (head + (signed long int)5 + (signed long int)2)[(signed long int)1] = (unsigned char)((g.mtime >> 16) >> 8);
    writen(g.outd, head, (unsigned long int)9);
    len = len + (unsigned long int)9;
  }

  else
    if(!(g.form == 0))
    {
      head[(signed long int)0] = (unsigned char)0x78;
      head[(signed long int)1] = (unsigned char)((g.level >= 9 ? 3 : (g.level == 1 ? 0 : (g.level >= 6 || g.level == -1 ? 1 : 2))) << 6);
      head[(signed long int)1] = head[(signed long int)1] + (unsigned char)(31 - (((signed int)head[(signed long int)0] << 8) + (signed int)head[(signed long int)1]) % 31);
      writen(g.outd, head, (unsigned long int)2);
      len = (unsigned long int)2;
    }

    else
    {
      head[(signed long int)0] = (unsigned char)31;
      head[(signed long int)1] = (unsigned char)139;
      head[(signed long int)2] = (unsigned char)8;
      head[(signed long int)3] = (unsigned char)(g.name != (char *)(void *)0 ? 8 : 0);
      head[(signed long int)4] = (unsigned char)(g.mtime & (signed long int)0xffff & (signed long int)0xff);
      (head + (signed long int)4)[(signed long int)1] = (unsigned char)((g.mtime & (signed long int)0xffff) >> 8);
      (head + (signed long int)4)[(signed long int)2] = (unsigned char)(g.mtime >> 16 & (signed long int)0xff);
      (head + (signed long int)4 + (signed long int)2)[(signed long int)1] = (unsigned char)((g.mtime >> 16) >> 8);
      head[(signed long int)8] = (unsigned char)(g.level >= 9 ? 2 : (g.level == 1 ? 4 : 0));
      head[(signed long int)9] = (unsigned char)3;
      writen(g.outd, head, (unsigned long int)10);
      len = (unsigned long int)10;
      if(!(g.name == ((char *)NULL)))
      {
        return_value_strlen_12=strlen(g.name);
        writen(g.outd, (unsigned char *)g.name, return_value_strlen_12 + (unsigned long int)1);
      }

      if(!(g.name == ((char *)NULL)))
      {
        return_value_strlen_13=strlen(g.name);
        len = len + return_value_strlen_13 + (unsigned long int)1;
      }

    }
  return len;
}

// put_trailer
// file pigz.c line 1025
static void put_trailer(unsigned long int ulen, unsigned long int clen, unsigned long int check, unsigned long int head)
{
  unsigned char tail[46l];
  unsigned long int tmp_if_expr_6;
  unsigned long int return_value_strlen_5;
  unsigned long int tmp_if_expr_8;
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_9;
  unsigned long int tmp_if_expr_11;
  unsigned long int return_value_strlen_10;
  if(g.form >= 2)
  {
    unsigned long int cent;
    tail[0l] = (unsigned char)(0x08074b50UL & (unsigned long int)0xffff & (unsigned long int)0xff);
    tail[(signed long int)1] = (unsigned char)((0x08074b50UL & (unsigned long int)0xffff) >> 8);
    tail[(signed long int)2] = (unsigned char)(0x08074b50UL >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)2)[(signed long int)1] = (unsigned char)((0x08074b50UL >> 16) >> 8);
    tail[(signed long int)4] = (unsigned char)(check & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)4)[(signed long int)1] = (unsigned char)((check & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)4)[(signed long int)2] = (unsigned char)(check >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)4 + (signed long int)2)[(signed long int)1] = (unsigned char)((check >> 16) >> 8);
    tail[(signed long int)8] = (unsigned char)(clen & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)8)[(signed long int)1] = (unsigned char)((clen & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)8)[(signed long int)2] = (unsigned char)(clen >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)8 + (signed long int)2)[(signed long int)1] = (unsigned char)((clen >> 16) >> 8);
    tail[(signed long int)12] = (unsigned char)(ulen & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)12)[(signed long int)1] = (unsigned char)((ulen & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)12)[(signed long int)2] = (unsigned char)(ulen >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)12 + (signed long int)2)[(signed long int)1] = (unsigned char)((ulen >> 16) >> 8);
    writen(g.outd, tail, (unsigned long int)16);
    tail[0l] = (unsigned char)(0x02014b50UL & (unsigned long int)0xffff & (unsigned long int)0xff);
    tail[(signed long int)1] = (unsigned char)((0x02014b50UL & (unsigned long int)0xffff) >> 8);
    tail[(signed long int)2] = (unsigned char)(0x02014b50UL >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)2)[(signed long int)1] = (unsigned char)((0x02014b50UL >> 16) >> 8);
    tail[(signed long int)4] = (unsigned char)63;
    tail[(signed long int)5] = (unsigned char)255;
    tail[(signed long int)6] = (unsigned char)(20 & 0xff);
    (tail + (signed long int)6)[(signed long int)1] = (unsigned char)(20 >> 8);
    tail[(signed long int)8] = (unsigned char)(8 & 0xff);
    (tail + (signed long int)8)[(signed long int)1] = (unsigned char)(8 >> 8);
    tail[(signed long int)10] = (unsigned char)(8 & 0xff);
    (tail + (signed long int)10)[(signed long int)1] = (unsigned char)(8 >> 8);
    unsigned long int return_value_time2dos_1;
    return_value_time2dos_1=time2dos(g.mtime);
    tail[(signed long int)12] = (unsigned char)(return_value_time2dos_1 & (unsigned long int)0xffff & (unsigned long int)0xff);
    unsigned long int return_value_time2dos_2;
    return_value_time2dos_2=time2dos(g.mtime);
    (tail + (signed long int)12)[(signed long int)1] = (unsigned char)((return_value_time2dos_2 & (unsigned long int)0xffff) >> 8);
    unsigned long int return_value_time2dos_3;
    return_value_time2dos_3=time2dos(g.mtime);
    (tail + (signed long int)12)[(signed long int)2] = (unsigned char)(return_value_time2dos_3 >> 16 & (unsigned long int)0xff);
    unsigned long int return_value_time2dos_4;
    return_value_time2dos_4=time2dos(g.mtime);
    (tail + (signed long int)12 + (signed long int)2)[(signed long int)1] = (unsigned char)((return_value_time2dos_4 >> 16) >> 8);
    tail[(signed long int)16] = (unsigned char)(check & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)16)[(signed long int)1] = (unsigned char)((check & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)16)[(signed long int)2] = (unsigned char)(check >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)16 + (signed long int)2)[(signed long int)1] = (unsigned char)((check >> 16) >> 8);
    tail[(signed long int)20] = (unsigned char)(clen & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)20)[(signed long int)1] = (unsigned char)((clen & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)20)[(signed long int)2] = (unsigned char)(clen >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)20 + (signed long int)2)[(signed long int)1] = (unsigned char)((clen >> 16) >> 8);
    tail[(signed long int)24] = (unsigned char)(ulen & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)24)[(signed long int)1] = (unsigned char)((ulen & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)24)[(signed long int)2] = (unsigned char)(ulen >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)24 + (signed long int)2)[(signed long int)1] = (unsigned char)((ulen >> 16) >> 8);
    if(g.name == ((char *)NULL))
      tmp_if_expr_6 = (unsigned long int)1;

    else
    {
      return_value_strlen_5=strlen(g.name);
      tmp_if_expr_6 = return_value_strlen_5;
    }
    tail[(signed long int)28] = (unsigned char)(tmp_if_expr_6 & (unsigned long int)0xff);
    if(g.name == ((char *)NULL))
      tmp_if_expr_8 = (unsigned long int)1;

    else
    {
      return_value_strlen_7=strlen(g.name);
      tmp_if_expr_8 = return_value_strlen_7;
    }
    (tail + (signed long int)28)[(signed long int)1] = (unsigned char)(tmp_if_expr_8 >> 8);
    tail[(signed long int)30] = (unsigned char)(9 & 0xff);
    (tail + (signed long int)30)[(signed long int)1] = (unsigned char)(9 >> 8);
    tail[(signed long int)32] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)32)[(signed long int)1] = (unsigned char)(0 >> 8);
    tail[(signed long int)34] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)34)[(signed long int)1] = (unsigned char)(0 >> 8);
    tail[(signed long int)36] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)36)[(signed long int)1] = (unsigned char)(0 >> 8);
    tail[(signed long int)38] = (unsigned char)(0 & 0xffff & 0xff);
    (tail + (signed long int)38)[(signed long int)1] = (unsigned char)((0 & 0xffff) >> 8);
    (tail + (signed long int)38)[(signed long int)2] = (unsigned char)(0 >> 16 & 0xff);
    (tail + (signed long int)38 + (signed long int)2)[(signed long int)1] = (unsigned char)((0 >> 16) >> 8);
    tail[(signed long int)42] = (unsigned char)(0 & 0xffff & 0xff);
    (tail + (signed long int)42)[(signed long int)1] = (unsigned char)((0 & 0xffff) >> 8);
    (tail + (signed long int)42)[(signed long int)2] = (unsigned char)(0 >> 16 & 0xff);
    (tail + (signed long int)42 + (signed long int)2)[(signed long int)1] = (unsigned char)((0 >> 16) >> 8);
    writen(g.outd, tail, (unsigned long int)46);
    cent = (unsigned long int)46;
    if(g.name == ((char *)NULL))
      writen(g.outd, (unsigned char *)"-", (unsigned long int)1);

    else
    {
      return_value_strlen_9=strlen(g.name);
      writen(g.outd, (unsigned char *)g.name, return_value_strlen_9);
    }
    if(g.name == ((char *)NULL))
      tmp_if_expr_11 = (unsigned long int)1;

    else
    {
      return_value_strlen_10=strlen(g.name);
      tmp_if_expr_11 = return_value_strlen_10;
    }
    cent = cent + tmp_if_expr_11;
    tail[0l] = (unsigned char)(0x5455 & 0xff);
    tail[(signed long int)1] = (unsigned char)(0x5455 >> 8);
    tail[(signed long int)2] = (unsigned char)(5 & 0xff);
    (tail + (signed long int)2)[(signed long int)1] = (unsigned char)(5 >> 8);
    tail[(signed long int)4] = (unsigned char)1;
    tail[(signed long int)5] = (unsigned char)(g.mtime & (signed long int)0xffff & (signed long int)0xff);
    (tail + (signed long int)5)[(signed long int)1] = (unsigned char)((g.mtime & (signed long int)0xffff) >> 8);
    (tail + (signed long int)5)[(signed long int)2] = (unsigned char)(g.mtime >> 16 & (signed long int)0xff);
    (tail + (signed long int)5 + (signed long int)2)[(signed long int)1] = (unsigned char)((g.mtime >> 16) >> 8);
    writen(g.outd, tail, (unsigned long int)9);
    cent = cent + (unsigned long int)9;
    tail[0l] = (unsigned char)(0x06054b50UL & (unsigned long int)0xffff & (unsigned long int)0xff);
    tail[(signed long int)1] = (unsigned char)((0x06054b50UL & (unsigned long int)0xffff) >> 8);
    tail[(signed long int)2] = (unsigned char)(0x06054b50UL >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)2)[(signed long int)1] = (unsigned char)((0x06054b50UL >> 16) >> 8);
    tail[(signed long int)4] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)4)[(signed long int)1] = (unsigned char)(0 >> 8);
    tail[(signed long int)6] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)6)[(signed long int)1] = (unsigned char)(0 >> 8);
    tail[(signed long int)8] = (unsigned char)(1 & 0xff);
    (tail + (signed long int)8)[(signed long int)1] = (unsigned char)(1 >> 8);
    tail[(signed long int)10] = (unsigned char)(1 & 0xff);
    (tail + (signed long int)10)[(signed long int)1] = (unsigned char)(1 >> 8);
    tail[(signed long int)12] = (unsigned char)(cent & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)12)[(signed long int)1] = (unsigned char)((cent & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)12)[(signed long int)2] = (unsigned char)(cent >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)12 + (signed long int)2)[(signed long int)1] = (unsigned char)((cent >> 16) >> 8);
    tail[(signed long int)16] = (unsigned char)(head + clen + (unsigned long int)16 & (unsigned long int)0xffff & (unsigned long int)0xff);
    (tail + (signed long int)16)[(signed long int)1] = (unsigned char)((head + clen + (unsigned long int)16 & (unsigned long int)0xffff) >> 8);
    (tail + (signed long int)16)[(signed long int)2] = (unsigned char)(head + clen + (unsigned long int)16 >> 16 & (unsigned long int)0xff);
    (tail + (signed long int)16 + (signed long int)2)[(signed long int)1] = (unsigned char)((head + clen + (unsigned long int)16 >> 16) >> 8);
    tail[(signed long int)20] = (unsigned char)(0 & 0xff);
    (tail + (signed long int)20)[(signed long int)1] = (unsigned char)(0 >> 8);
    writen(g.outd, tail, (unsigned long int)22);
  }

  else
    if(!(g.form == 0))
    {
      tail[0l] = (unsigned char)(check >> 24);
      tail[(signed long int)1] = (unsigned char)(check >> 16);
      tail[(signed long int)2] = (unsigned char)(check >> 8);
      tail[(signed long int)3] = (unsigned char)check;
      writen(g.outd, tail, (unsigned long int)4);
    }

    else
    {
      tail[0l] = (unsigned char)(check & (unsigned long int)0xffff & (unsigned long int)0xff);
      tail[(signed long int)1] = (unsigned char)((check & (unsigned long int)0xffff) >> 8);
      tail[(signed long int)2] = (unsigned char)(check >> 16 & (unsigned long int)0xff);
      (tail + (signed long int)2)[(signed long int)1] = (unsigned char)((check >> 16) >> 8);
      tail[(signed long int)4] = (unsigned char)(ulen & (unsigned long int)0xffff & (unsigned long int)0xff);
      (tail + (signed long int)4)[(signed long int)1] = (unsigned char)((ulen & (unsigned long int)0xffff) >> 8);
      (tail + (signed long int)4)[(signed long int)2] = (unsigned char)(ulen >> 16 & (unsigned long int)0xff);
      (tail + (signed long int)4 + (signed long int)2)[(signed long int)1] = (unsigned char)((ulen >> 16) >> 8);
      writen(g.outd, tail, (unsigned long int)8);
    }
}

// read_extra
// file pigz.c line 2440
static signed int read_extra(unsigned int len, signed int save)
{
  unsigned int id;
  unsigned int size;
  unsigned int tmp2;
  unsigned long int tmp4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_load_1;
  signed int tmp_if_expr_5;
  unsigned char *tmp_post_4;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_load_6;
  signed int tmp_if_expr_10;
  unsigned char *tmp_post_9;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_load_11;
  signed int tmp_if_expr_15;
  unsigned char *tmp_post_14;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  unsigned long int return_value_load_16;
  signed int tmp_if_expr_20;
  unsigned char *tmp_post_19;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_22;
  unsigned long int return_value_load_21;
  signed int tmp_if_expr_25;
  unsigned char *tmp_post_24;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_27;
  unsigned long int return_value_load_26;
  signed int tmp_if_expr_30;
  unsigned char *tmp_post_29;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_32;
  unsigned long int return_value_load_31;
  signed int tmp_if_expr_35;
  unsigned char *tmp_post_34;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_37;
  unsigned long int return_value_load_36;
  signed int tmp_if_expr_40;
  unsigned char *tmp_post_39;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_43;
  unsigned long int return_value_load_42;
  signed int tmp_if_expr_46;
  unsigned char *tmp_post_45;
  _Bool tmp_if_expr_49;
  _Bool tmp_if_expr_48;
  unsigned long int return_value_load_47;
  signed int tmp_if_expr_51;
  unsigned char *tmp_post_50;
  _Bool tmp_if_expr_54;
  _Bool tmp_if_expr_53;
  unsigned long int return_value_load_52;
  signed int tmp_if_expr_56;
  unsigned char *tmp_post_55;
  _Bool tmp_if_expr_59;
  _Bool tmp_if_expr_58;
  unsigned long int return_value_load_57;
  signed int tmp_if_expr_61;
  unsigned char *tmp_post_60;
  _Bool tmp_if_expr_66;
  _Bool tmp_if_expr_65;
  unsigned long int return_value_load_64;
  signed int tmp_if_expr_68;
  unsigned char *tmp_post_67;
  _Bool tmp_if_expr_71;
  _Bool tmp_if_expr_70;
  unsigned long int return_value_load_69;
  signed int tmp_if_expr_73;
  unsigned char *tmp_post_72;
  _Bool tmp_if_expr_76;
  _Bool tmp_if_expr_75;
  unsigned long int return_value_load_74;
  signed int tmp_if_expr_78;
  unsigned char *tmp_post_77;
  _Bool tmp_if_expr_81;
  _Bool tmp_if_expr_80;
  unsigned long int return_value_load_79;
  signed int tmp_if_expr_83;
  unsigned char *tmp_post_82;
  _Bool tmp_if_expr_106;
  _Bool tmp_if_expr_105;
  unsigned long int return_value_load_104;
  signed int tmp_if_expr_108;
  unsigned char *tmp_post_107;
  _Bool tmp_if_expr_86;
  _Bool tmp_if_expr_85;
  unsigned long int return_value_load_84;
  signed int tmp_if_expr_88;
  unsigned char *tmp_post_87;
  _Bool tmp_if_expr_91;
  _Bool tmp_if_expr_90;
  unsigned long int return_value_load_89;
  signed int tmp_if_expr_93;
  unsigned char *tmp_post_92;
  _Bool tmp_if_expr_96;
  _Bool tmp_if_expr_95;
  unsigned long int return_value_load_94;
  signed int tmp_if_expr_98;
  unsigned char *tmp_post_97;
  _Bool tmp_if_expr_101;
  _Bool tmp_if_expr_100;
  unsigned long int return_value_load_99;
  signed int tmp_if_expr_103;
  unsigned char *tmp_post_102;
  while(len >= 4u)
  {
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_load_1=load();
        tmp_if_expr_2 = return_value_load_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = 0;

    else
    {
      g.in_left = g.in_left - 1ul;
      tmp_post_4 = g.in_next;
      g.in_next = g.in_next + 1l;
      tmp_if_expr_5 = (signed int)*tmp_post_4;
    }
    tmp2 = (unsigned int)tmp_if_expr_5;
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_load_6=load();
        tmp_if_expr_7 = return_value_load_6 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_10 = 0;

    else
    {
      g.in_left = g.in_left - 1ul;
      tmp_post_9 = g.in_next;
      g.in_next = g.in_next + 1l;
      tmp_if_expr_10 = (signed int)*tmp_post_9;
    }
    id = tmp2 + ((unsigned int)tmp_if_expr_10 << 8);
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_load_11=load();
        tmp_if_expr_12 = return_value_load_11 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_13 = (_Bool)0;
    if(tmp_if_expr_13)
      tmp_if_expr_15 = 0;

    else
    {
      g.in_left = g.in_left - 1ul;
      tmp_post_14 = g.in_next;
      g.in_next = g.in_next + 1l;
      tmp_if_expr_15 = (signed int)*tmp_post_14;
    }
    tmp2 = (unsigned int)tmp_if_expr_15;
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        return_value_load_16=load();
        tmp_if_expr_17 = return_value_load_16 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_18 = (_Bool)0;
    if(tmp_if_expr_18)
      tmp_if_expr_20 = 0;

    else
    {
      g.in_left = g.in_left - 1ul;
      tmp_post_19 = g.in_next;
      g.in_next = g.in_next + 1l;
      tmp_if_expr_20 = (signed int)*tmp_post_19;
    }
    size = tmp2 + ((unsigned int)tmp_if_expr_20 << 8);
    if(!(g.in_eof == 0))
      return -1;

    len = len - (unsigned int)4;
    if(!(len >= size))
      break;

    len = len - size;
    if(id == 1u)
    {
      if(g.zip_ulen == 0xffffffffUL && size >= 8u)
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_22 = (_Bool)1;

          else
          {
            return_value_load_21=load();
            tmp_if_expr_22 = return_value_load_21 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_23 = tmp_if_expr_22 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_23 = (_Bool)0;
        if(tmp_if_expr_23)
          tmp_if_expr_25 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_24 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_25 = (signed int)*tmp_post_24;
        }
        tmp2 = (unsigned int)tmp_if_expr_25;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_27 = (_Bool)1;

          else
          {
            return_value_load_26=load();
            tmp_if_expr_27 = return_value_load_26 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_28 = tmp_if_expr_27 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_28 = (_Bool)0;
        if(tmp_if_expr_28)
          tmp_if_expr_30 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_29 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_30 = (signed int)*tmp_post_29;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_30 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_32 = (_Bool)1;

          else
          {
            return_value_load_31=load();
            tmp_if_expr_32 = return_value_load_31 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_33 = tmp_if_expr_32 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_33 = (_Bool)0;
        if(tmp_if_expr_33)
          tmp_if_expr_35 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_34 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_35 = (signed int)*tmp_post_34;
        }
        tmp2 = (unsigned int)tmp_if_expr_35;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_37 = (_Bool)1;

          else
          {
            return_value_load_36=load();
            tmp_if_expr_37 = return_value_load_36 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_38 = tmp_if_expr_37 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_38 = (_Bool)0;
        if(tmp_if_expr_38)
          tmp_if_expr_40 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_39 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_40 = (signed int)*tmp_post_39;
        }
        g.zip_ulen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_40 << 8)) << 16);
        do
        {
          unsigned long int togo = (unsigned long int)4;
          while(!(g.in_left >= togo))
          {
            togo = togo - g.in_left;
            unsigned long int return_value_load_41;
            return_value_load_41=load();
            if(return_value_load_41 == 0ul)
              return -3;

          }
          g.in_left = g.in_left - togo;
          g.in_next = g.in_next + (signed long int)togo;
        }
        while((_Bool)0);
        size = size - (unsigned int)8;
      }

      if(g.zip_clen == 0xffffffffUL && size >= 8u)
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_43 = (_Bool)1;

          else
          {
            return_value_load_42=load();
            tmp_if_expr_43 = return_value_load_42 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_44 = tmp_if_expr_43 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_44 = (_Bool)0;
        if(tmp_if_expr_44)
          tmp_if_expr_46 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_45 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_46 = (signed int)*tmp_post_45;
        }
        tmp2 = (unsigned int)tmp_if_expr_46;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_48 = (_Bool)1;

          else
          {
            return_value_load_47=load();
            tmp_if_expr_48 = return_value_load_47 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_49 = tmp_if_expr_48 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_49 = (_Bool)0;
        if(tmp_if_expr_49)
          tmp_if_expr_51 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_50 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_51 = (signed int)*tmp_post_50;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_51 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_53 = (_Bool)1;

          else
          {
            return_value_load_52=load();
            tmp_if_expr_53 = return_value_load_52 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_54 = tmp_if_expr_53 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_54 = (_Bool)0;
        if(tmp_if_expr_54)
          tmp_if_expr_56 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_55 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_56 = (signed int)*tmp_post_55;
        }
        tmp2 = (unsigned int)tmp_if_expr_56;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_58 = (_Bool)1;

          else
          {
            return_value_load_57=load();
            tmp_if_expr_58 = return_value_load_57 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_59 = tmp_if_expr_58 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_59 = (_Bool)0;
        if(tmp_if_expr_59)
          tmp_if_expr_61 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_60 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_61 = (signed int)*tmp_post_60;
        }
        g.zip_clen = tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_61 << 8)) << 16);
        do
        {
          unsigned long int read_extra__1__1__1__2__1__togo = (unsigned long int)4;
          while(!(g.in_left >= read_extra__1__1__1__2__1__togo))
          {
            read_extra__1__1__1__2__1__togo = read_extra__1__1__1__2__1__togo - g.in_left;
            unsigned long int return_value_load_62;
            return_value_load_62=load();
            if(return_value_load_62 == 0ul)
              return -3;

          }
          g.in_left = g.in_left - read_extra__1__1__1__2__1__togo;
          g.in_next = g.in_next + (signed long int)read_extra__1__1__1__2__1__togo;
        }
        while((_Bool)0);
        size = size - (unsigned int)8;
      }

    }

    if(!(save == 0))
    {
      if(size >= 8u && (id == 13u || id == 22613u))
      {
        do
        {
          unsigned long int read_extra__1__1__2__1__1__togo = (unsigned long int)4;
          while(!(g.in_left >= read_extra__1__1__2__1__1__togo))
          {
            read_extra__1__1__2__1__1__togo = read_extra__1__1__2__1__1__togo - g.in_left;
            unsigned long int return_value_load_63;
            return_value_load_63=load();
            if(return_value_load_63 == 0ul)
              return -3;

          }
          g.in_left = g.in_left - read_extra__1__1__2__1__1__togo;
          g.in_next = g.in_next + (signed long int)read_extra__1__1__2__1__1__togo;
        }
        while((_Bool)0);
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_65 = (_Bool)1;

          else
          {
            return_value_load_64=load();
            tmp_if_expr_65 = return_value_load_64 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_66 = tmp_if_expr_65 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_66 = (_Bool)0;
        if(tmp_if_expr_66)
          tmp_if_expr_68 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_67 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_68 = (signed int)*tmp_post_67;
        }
        tmp2 = (unsigned int)tmp_if_expr_68;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_70 = (_Bool)1;

          else
          {
            return_value_load_69=load();
            tmp_if_expr_70 = return_value_load_69 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_71 = tmp_if_expr_70 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_71 = (_Bool)0;
        if(tmp_if_expr_71)
          tmp_if_expr_73 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_72 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_73 = (signed int)*tmp_post_72;
        }
        tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_73 << 8));
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_75 = (_Bool)1;

          else
          {
            return_value_load_74=load();
            tmp_if_expr_75 = return_value_load_74 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_76 = tmp_if_expr_75 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_76 = (_Bool)0;
        if(tmp_if_expr_76)
          tmp_if_expr_78 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_77 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_78 = (signed int)*tmp_post_77;
        }
        tmp2 = (unsigned int)tmp_if_expr_78;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_80 = (_Bool)1;

          else
          {
            return_value_load_79=load();
            tmp_if_expr_80 = return_value_load_79 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_81 = tmp_if_expr_80 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_81 = (_Bool)0;
        if(tmp_if_expr_81)
          tmp_if_expr_83 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_82 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_83 = (signed int)*tmp_post_82;
        }
        g.stamp=tolong(tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_83 << 8)) << 16));
        size = size - (unsigned int)8;
      }

      if(id == 21589u && size >= 5u)
      {
        size = size - 1u;
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_105 = (_Bool)1;

          else
          {
            return_value_load_104=load();
            tmp_if_expr_105 = return_value_load_104 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_106 = tmp_if_expr_105 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_106 = (_Bool)0;
        if(tmp_if_expr_106)
          tmp_if_expr_108 = 0;

        else
        {
          g.in_left = g.in_left - 1ul;
          tmp_post_107 = g.in_next;
          g.in_next = g.in_next + 1l;
          tmp_if_expr_108 = (signed int)*tmp_post_107;
        }
        if(!((1 & tmp_if_expr_108) == 0))
        {
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_85 = (_Bool)1;

            else
            {
              return_value_load_84=load();
              tmp_if_expr_85 = return_value_load_84 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_86 = tmp_if_expr_85 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_86 = (_Bool)0;
          if(tmp_if_expr_86)
            tmp_if_expr_88 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_87 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_88 = (signed int)*tmp_post_87;
          }
          tmp2 = (unsigned int)tmp_if_expr_88;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_90 = (_Bool)1;

            else
            {
              return_value_load_89=load();
              tmp_if_expr_90 = return_value_load_89 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_91 = tmp_if_expr_90 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_91 = (_Bool)0;
          if(tmp_if_expr_91)
            tmp_if_expr_93 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_92 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_93 = (signed int)*tmp_post_92;
          }
          tmp4 = (unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_93 << 8));
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_95 = (_Bool)1;

            else
            {
              return_value_load_94=load();
              tmp_if_expr_95 = return_value_load_94 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_96 = tmp_if_expr_95 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_96 = (_Bool)0;
          if(tmp_if_expr_96)
            tmp_if_expr_98 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_97 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_98 = (signed int)*tmp_post_97;
          }
          tmp2 = (unsigned int)tmp_if_expr_98;
          if(g.in_left == 0ul)
          {
            if(!(g.in_eof == 0))
              tmp_if_expr_100 = (_Bool)1;

            else
            {
              return_value_load_99=load();
              tmp_if_expr_100 = return_value_load_99 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_101 = tmp_if_expr_100 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_101 = (_Bool)0;
          if(tmp_if_expr_101)
            tmp_if_expr_103 = 0;

          else
          {
            g.in_left = g.in_left - 1ul;
            tmp_post_102 = g.in_next;
            g.in_next = g.in_next + 1l;
            tmp_if_expr_103 = (signed int)*tmp_post_102;
          }
          g.stamp=tolong(tmp4 + ((unsigned long int)(tmp2 + ((unsigned int)tmp_if_expr_103 << 8)) << 16));
          size = size - (unsigned int)4;
        }

      }

    }

    do
    {
      unsigned long int read_extra__1__1__3__togo = (unsigned long int)size;
      while(!(g.in_left >= read_extra__1__1__3__togo))
      {
        read_extra__1__1__3__togo = read_extra__1__1__3__togo - g.in_left;
        unsigned long int return_value_load_109;
        return_value_load_109=load();
        if(return_value_load_109 == 0ul)
          return -3;

      }
      g.in_left = g.in_left - read_extra__1__1__3__togo;
      g.in_next = g.in_next + (signed long int)read_extra__1__1__3__togo;
    }
    while((_Bool)0);
  }
  do
  {
    unsigned long int read_extra__1__2__togo = (unsigned long int)len;
    while(!(g.in_left >= read_extra__1__2__togo))
    {
      read_extra__1__2__togo = read_extra__1__2__togo - g.in_left;
      unsigned long int return_value_load_110;
      return_value_load_110=load();
      if(return_value_load_110 == 0ul)
        return -3;

    }
    g.in_left = g.in_left - read_extra__1__2__togo;
    g.in_next = g.in_next + (signed long int)read_extra__1__2__togo;
  }
  while((_Bool)0);
  return 0;
}

// readn
// file pigz.c line 900
static unsigned long int readn(signed int desc, unsigned char *buf, unsigned long int len)
{
  signed long int ret;
  unsigned long int got = (unsigned long int)0;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!(len == 0ul))
  {
    ret=read(desc, (void *)buf, len);
    if(!(ret >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      try_throw_(*return_value___errno_location_1, "read error on %s (%s)", g.inf, return_value_strerror_3, (void *)0);
    }

    if(ret == 0l)
      break;

    buf = buf + ret;
    len = len - (unsigned long int)ret;
    got = got + (unsigned long int)ret;
  }
  return got;
}

// reenter
// file yarn.c line 210
static void reenter(void *dummy)
{
  struct thread_s *match;
  struct thread_s **prior;
  unsigned long int me;
  (void)dummy;
  me=pthread_self();
  possess(&threads_lock);
  prior = &threads;
  do
  {
    match = *prior;
    if(match == ((struct thread_s *)NULL))
      break;

    signed int return_value_pthread_equal_1;
    return_value_pthread_equal_1=pthread_equal(match->id, me);
    if(!(return_value_pthread_equal_1 == 0))
      break;

    prior = &match->next;
  }
  while((_Bool)1);
  if(match == ((struct thread_s *)NULL))
    fail(22);

  match->done = 1;
  if(!(threads == match))
  {
    *prior = match->next;
    match->next = threads;
    threads = match;
  }

  twist(&threads_lock, (enum twist_op)BY, (signed long int)+1);
}

// release
// file yarn.h line 126
void release(struct lock_s *bolt)
{
  signed int ret;
  ret=pthread_mutex_unlock(&bolt->mutex);
  if(!(ret == 0))
    fail(ret);

}

// setup_jobs
// file pigz.c line 1394
static void setup_jobs(void)
{
  if(compress_have == ((struct lock_s *)NULL))
  {
    compress_have=new_lock((signed long int)0);
    compress_head = (struct job *)(void *)0;
    compress_tail = &compress_head;
    write_first=new_lock((signed long int)-1);
    write_head = (struct job *)(void *)0;
    new_pool(&in_pool, g.block, (g.procs << 1) + 3);
    new_pool(&out_pool, g.block + (g.block >> 4) + (unsigned long int)32768U, -1);
    new_pool(&dict_pool, (unsigned long int)32768U, -1);
    new_pool(&lens_pool, g.block >> 12 - 1, -1);
  }

}

// show_info
// file pigz.c line 2675
static void show_info(signed int method, unsigned long int check, signed long int len, signed int cont)
{
  unsigned long int max;
  unsigned long int n;
  signed long int now;
  char mod[26l];
  char tag[49l];
  max = (unsigned long int)(g.verbosity > 1 ? 16 : 48);
  memset((void *)tag, 0, max + (unsigned long int)1);
  if(!(cont == 0))
    strncpy(tag, "<...>", max + (unsigned long int)1);

  else
    if(g.hname == ((char *)NULL))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(g.inf);
      unsigned long int return_value_compressed_suffix_2;
      return_value_compressed_suffix_2=compressed_suffix(g.inf);
      n = return_value_strlen_1 - return_value_compressed_suffix_2;
      strncpy(tag, g.inf, n > max + (unsigned long int)1 ? max + (unsigned long int)1 : n);
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(g.inf + (signed long int)n, ".tgz");
      if(return_value_strcmp_3 == 0)
      {
        if(!(n >= 1ul + max))
          strncpy(tag + (signed long int)n, ".tar", (max + (unsigned long int)1) - n);

      }

    }

    else
      strncpy(tag, g.hname, max + (unsigned long int)1);
  if(!(tag[(signed long int)max] == 0))
    strcpy((tag + (signed long int)max) - (signed long int)3, "...");

  if(!(g.stamp == 0l))
  {
    char *return_value_ctime_4;
    return_value_ctime_4=ctime(&g.stamp);
    strcpy(mod, return_value_ctime_4);
    now=time((signed long int *)(void *)0);
    char *return_value_ctime_5;
    return_value_ctime_5=ctime(&now);
    signed int return_value_strcmp_6;
    return_value_strcmp_6=strcmp(mod + (signed long int)20, return_value_ctime_5 + (signed long int)20);
    if(!(return_value_strcmp_6 == 0))
      strcpy(mod + (signed long int)11, mod + (signed long int)19);

  }

  else
    strcpy(mod + (signed long int)4, "------ -----");
  mod[(signed long int)16] = (char)0;
  if(!(g.first == 0))
  {
    if(g.verbosity >= 2)
      fputs("method    check    timestamp    ", stdout);

    if(g.verbosity >= 1)
      puts("compressed   original reduced  name");

    g.first = 0;
  }

  if(g.verbosity >= 2)
  {
    if(g.decode == 0 && g.form == 3)
      printf("zip%3d  --------  %s  ", method, mod + (signed long int)4);

    else
      if(g.form >= 2)
        printf("zip%3d  %08lx  %s  ", method, check, mod + (signed long int)4);

      else
        if(g.form == 1)
          printf("zlib%2d  %08lx  %s  ", method, check, mod + (signed long int)4);

        else
          if(method == 257)
            printf("lzw     --------  %s  ", mod + (signed long int)4);

          else
            printf("gzip%2d  %08lx  %s  ", method, check, mod + (signed long int)4);
  }

  if(g.verbosity >= 1)
  {
    if(g.decode == 0 && g.form == 3 || method == 8 && !((len >> 10) + 12l + len >= g.in_tot) || method == 257 && !((len >> 1) + 3l + len >= g.in_tot))
      printf("%10jd %10jd?  unk    %s\n", (signed long int)g.in_tot, (signed long int)len, (const void *)tag);

    else
      printf("%10jd %10jd %6.1f%%  %s\n", (signed long int)g.in_tot, (signed long int)len, len == (signed long int)0 ? (double)0 : (double)((signed long int)100 * (len - g.in_tot)) / (double)len, (const void *)tag);
  }

}

// single_compress
// file pigz.c line 2022
static void single_compress(signed int reset)
{
  unsigned long int got;
  unsigned long int more;
  unsigned long int start;
  unsigned long int have;
  unsigned long int hist;
  signed int fresh;
  unsigned int hash;
  unsigned char *scan;
  unsigned long int left;
  unsigned long int head;
  unsigned long int ulen;
  unsigned long int clen;
  unsigned long int check;
  unsigned long int tmp_if_expr_7;
  unsigned long int return_value_adler32_5;
  unsigned long int return_value_crc32_6;
  unsigned char *tmp_post_8;
  unsigned long int tmp_if_expr_11;
  unsigned long int return_value_adler32_9;
  unsigned long int return_value_crc32_10;
  unsigned long int tmp_if_expr_14;
  unsigned long int return_value_adler32_12;
  unsigned long int return_value_crc32_13;
  unsigned long int tmp_if_expr_17;
  unsigned long int return_value_adler32_15;
  unsigned long int return_value_crc32_16;
  unsigned long int tmp_if_expr_20;
  unsigned long int return_value_adler32_18;
  unsigned long int return_value_crc32_19;
  static unsigned char *in;
  static unsigned char *next;
  static unsigned char *single_compress__1__out;
  static struct z_stream_s *strm = (struct z_stream_s *)(void *)0;
  if(!(reset == 0))
  {
    if(!(strm == ((struct z_stream_s *)NULL)))
    {
      deflateEnd(strm);
      free((void *)strm);
      free((void *)single_compress__1__out);
      free((void *)next);
      free((void *)in);
      strm = (struct z_stream_s *)(void *)0;
    }

  }

  else
  {
    static unsigned int out_size;
    if(strm == ((struct z_stream_s *)NULL))
    {
      signed int ret;
      out_size = g.block > (unsigned long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1)) ? ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1) : (unsigned int)g.block;
      void *return_value_alloc_1;
      return_value_alloc_1=alloc((void *)0, g.block + (unsigned long int)32768U);
      in = (unsigned char *)return_value_alloc_1;
      void *return_value_alloc_2;
      return_value_alloc_2=alloc((void *)0, g.block + (unsigned long int)32768U);
      next = (unsigned char *)return_value_alloc_2;
      void *return_value_alloc_3;
      return_value_alloc_3=alloc((void *)0, (unsigned long int)out_size);
      single_compress__1__out = (unsigned char *)return_value_alloc_3;
      void *return_value_alloc_4;
      return_value_alloc_4=alloc((void *)0, sizeof(struct z_stream_s) /*112ul*/ );
      strm = (struct z_stream_s *)return_value_alloc_4;
      strm->zfree = ((void (*)(void *, void *))NULL);
      strm->zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
      strm->opaque = NULL;
      ret=deflateInit2_(strm, 6, 8, -15, 8, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
      if(ret == -4)
        try_throw_(12, "not enough memory", (void *)0);

      if(!(ret == 0))
        try_throw_(22, "internal error", (void *)0);

    }

    head=put_header();
    if(!(g.level >= 10))
    {
      deflateReset(strm);
      deflateParams(strm, g.level, 0);
    }

    got = (unsigned long int)0;
    more=readn(g.ind, next, g.block);
    ulen = (unsigned long int)more;
    start = (unsigned long int)0;
    hist = (unsigned long int)0;
    clen = (unsigned long int)0;
    have = (unsigned long int)0;
    if(g.form == 1)
    {
      return_value_adler32_5=adler32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
      tmp_if_expr_7 = return_value_adler32_5;
    }

    else
    {
      return_value_crc32_6=crc32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
      tmp_if_expr_7 = return_value_crc32_6;
    }
    check = tmp_if_expr_7;
    hash = (1U << 12) - (unsigned int)1 >> 1;
    while((_Bool)1)
    {
      if(got == 0ul)
      {
        scan = in;
        in = next;
        next = scan;
        strm->next_in = in + (signed long int)start;
        got = more;
        if(g.level >= 10)
        {
          left = (start + more) - hist;
          if(left >= 32769ul)
            left = (unsigned long int)32768U;

          memcpy((void *)next, (const void *)(in + (signed long int)((start + more) - left)), left);
          start = left;
          hist = (unsigned long int)0;
        }

        else
          start = (unsigned long int)0;
        more=readn(g.ind, next + (signed long int)start, g.block);
        ulen = ulen + (unsigned long int)more;
      }

      left = (unsigned long int)0;
      if(!(g.rsync == 0) && !(got == 0ul))
      {
        scan = strm->next_in;
        left = got;
        while((_Bool)1)
        {
          if(left == 0ul)
          {
            if(got == g.block || more == 0ul)
              goto __CPROVER_DUMP_L17;

            if(g.level >= 10)
            {
              left = (unsigned long int)(strm->next_in - in) - hist;
              if(left >= 32769ul)
                left = (unsigned long int)32768U;

            }

            memmove((void *)in, (const void *)(strm->next_in - (signed long int)left), left + got);
            hist = (unsigned long int)0;
            strm->next_in = in + (signed long int)left;
            scan = in + (signed long int)left + (signed long int)got;
            left = more > g.block - got ? g.block - got : more;
            memcpy((void *)scan, (const void *)(next + (signed long int)start), left);
            got = got + left;
            more = more - left;
            start = start + left;
            if(more == 0ul)
            {
              more=readn(g.ind, next, g.block);
              ulen = ulen + (unsigned long int)more;
              start = (unsigned long int)0;
            }

          }

          left = left - 1ul;
          tmp_post_8 = scan;
          scan = scan + 1l;
          hash = (hash << 1 ^ (unsigned int)*tmp_post_8) & (1U << 12) - (unsigned int)1;
          if(hash == 2047u)
            break;

        }

      __CPROVER_DUMP_L17:
        ;
        got = got - left;
      }

      fresh = 0;
      if(g.setdict == 0)
      {
        have = have + got;
        if(!(g.block >= have))
        {
          fresh = 1;
          have = got;
        }

      }

      if(!(g.level >= 10))
      {
        if(!(fresh == 0))
          deflateReset(strm);

        while(got >= 2147483649ul)
        {
          strm->avail_in = ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1);
          if(g.form == 1)
          {
            return_value_adler32_9=adler32(check, strm->next_in, strm->avail_in);
            tmp_if_expr_11 = return_value_adler32_9;
          }

          else
          {
            return_value_crc32_10=crc32(check, strm->next_in, strm->avail_in);
            tmp_if_expr_11 = return_value_crc32_10;
          }
          check = tmp_if_expr_11;
          do
          {

          __CPROVER_DUMP_L23:
            ;
            strm->avail_out = out_size;
            strm->next_out = single_compress__1__out;
            deflate(strm, 0);
            writen(g.outd, single_compress__1__out, (unsigned long int)(out_size - strm->avail_out));
            clen = clen + (unsigned long int)(out_size - strm->avail_out);
            if(strm->avail_out == 0u)
              goto __CPROVER_DUMP_L23;

            /* assertion strm->avail_in == 0 */
            assert(strm->avail_in == (unsigned int)0);
          }
          while((_Bool)0);
          got = got - (unsigned long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
        }
        strm->avail_in = (unsigned int)got;
        got = left;
        if(g.form == 1)
        {
          return_value_adler32_12=adler32(check, strm->next_in, strm->avail_in);
          tmp_if_expr_14 = return_value_adler32_12;
        }

        else
        {
          return_value_crc32_13=crc32(check, strm->next_in, strm->avail_in);
          tmp_if_expr_14 = return_value_crc32_13;
        }
        check = tmp_if_expr_14;
        if(!(got == 0ul) || !(more == 0ul))
        {
          signed int single_compress__1__4__4__2__bits;
          do
          {

          __CPROVER_DUMP_L27:
            ;
            strm->avail_out = out_size;
            strm->next_out = single_compress__1__out;
            deflate(strm, 5);
            writen(g.outd, single_compress__1__out, (unsigned long int)(out_size - strm->avail_out));
            clen = clen + (unsigned long int)(out_size - strm->avail_out);
            if(strm->avail_out == 0u)
              goto __CPROVER_DUMP_L27;

            /* assertion strm->avail_in == 0 */
            assert(strm->avail_in == (unsigned int)0);
          }
          while((_Bool)0);
          deflatePending(strm, ((unsigned int *)NULL), &single_compress__1__4__4__2__bits);
          if(!((1 & single_compress__1__4__4__2__bits) == 0))
            do
            {

            __CPROVER_DUMP_L28:
              ;
              strm->avail_out = out_size;
              strm->next_out = single_compress__1__out;
              deflate(strm, 2);
              writen(g.outd, single_compress__1__out, (unsigned long int)(out_size - strm->avail_out));
              clen = clen + (unsigned long int)(out_size - strm->avail_out);
              if(strm->avail_out == 0u)
                goto __CPROVER_DUMP_L28;

              /* assertion strm->avail_in == 0 */
              assert(strm->avail_in == (unsigned int)0);
            }
            while((_Bool)0);

          else
            if(!((7 & single_compress__1__4__4__2__bits) == 0))
            {
              do
              {
                single_compress__1__4__4__2__bits=deflatePrime(strm, 10, 2);
                /* assertion bits == 0 */
                assert(single_compress__1__4__4__2__bits == 0);
                deflatePending(strm, ((unsigned int *)NULL), &single_compress__1__4__4__2__bits);
              }
              while(!((7 & single_compress__1__4__4__2__bits) == 0));
              do
              {

              __CPROVER_DUMP_L31:
                ;
                strm->avail_out = out_size;
                strm->next_out = single_compress__1__out;
                deflate(strm, 0);
                writen(g.outd, single_compress__1__out, (unsigned long int)(out_size - strm->avail_out));
                clen = clen + (unsigned long int)(out_size - strm->avail_out);
                if(strm->avail_out == 0u)
                  goto __CPROVER_DUMP_L31;

                /* assertion strm->avail_in == 0 */
                assert(strm->avail_in == (unsigned int)0);
              }
              while((_Bool)0);
            }

        }

        else
          do
          {

          __CPROVER_DUMP_L33:
            ;
            strm->avail_out = out_size;
            strm->next_out = single_compress__1__out;
            deflate(strm, 4);
            writen(g.outd, single_compress__1__out, (unsigned long int)(out_size - strm->avail_out));
            clen = clen + (unsigned long int)(out_size - strm->avail_out);
            if(strm->avail_out == 0u)
              goto __CPROVER_DUMP_L33;

            /* assertion strm->avail_in == 0 */
            assert(strm->avail_in == (unsigned int)0);
          }
          while((_Bool)0);
      }

      else
      {
        unsigned char bits;
        unsigned char *out;
        unsigned long int outsize;
        unsigned long int off = (unsigned long int)(strm->next_in - in);
        if(!(fresh == 0))
          hist = off;

        out = (unsigned char *)(void *)0;
        outsize = (unsigned long int)0;
        bits = (unsigned char)0;
        ZopfliDeflatePart(&g.zopts, 2, (signed int)!(more != 0ul || left != 0ul), in + (signed long int)hist, off - hist, (off - hist) + got, &bits, &out, &outsize);
        bits = bits & (unsigned char)7;
        if(!(bits == 0) && (!(left == 0ul) || !(more == 0ul)))
        {
          if(!((1 & (signed int)bits) == 0))
          {
            writen(g.outd, out, outsize);
            if((signed int)bits == 7)
              writen(g.outd, (unsigned char *)"\0", (unsigned long int)1);

            writen(g.outd, (unsigned char *)"\0\0", (unsigned long int)4);
          }

          else
          {
            /* assertion outsize > 0 */
            assert(outsize > (unsigned long int)0);
            writen(g.outd, out, outsize - (unsigned long int)1);
            do
            {
              out[(signed long int)(outsize - (unsigned long int)1)] = out[(signed long int)(outsize - (unsigned long int)1)] + (unsigned char)(2 << (signed int)bits);
              writen(g.outd, (out + (signed long int)outsize) - (signed long int)1, (unsigned long int)1);
              out[(signed long int)(outsize - (unsigned long int)1)] = (unsigned char)0;
              bits = bits + (unsigned char)2;
            }
            while(!((signed int)bits >= 8));
            writen(g.outd, (out + (signed long int)outsize) - (signed long int)1, (unsigned long int)1);
          }
        }

        else
          writen(g.outd, out, outsize);
        free((void *)out);
        while(got >= 2147483649ul)
        {
          if(g.form == 1)
          {
            return_value_adler32_15=adler32(check, strm->next_in, ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
            tmp_if_expr_17 = return_value_adler32_15;
          }

          else
          {
            return_value_crc32_16=crc32(check, strm->next_in, ((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
            tmp_if_expr_17 = return_value_crc32_16;
          }
          check = tmp_if_expr_17;
          strm->next_in = strm->next_in + (signed long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
          got = got - (unsigned long int)(((unsigned int)0x7fffffff * 2U + 1U) - ((unsigned int)0x7fffffff * 2U + 1U >> 1));
        }
        if(g.form == 1)
        {
          return_value_adler32_18=adler32(check, strm->next_in, (unsigned int)got);
          tmp_if_expr_20 = return_value_adler32_18;
        }

        else
        {
          return_value_crc32_19=crc32(check, strm->next_in, (unsigned int)got);
          tmp_if_expr_20 = return_value_crc32_19;
        }
        check = tmp_if_expr_20;
        strm->next_in = strm->next_in + (signed long int)got;
        got = left;
      }
      if(got == 0ul && more == 0ul)
        break;

    }
    put_trailer(ulen, clen, check, head);
  }
}

// time2dos
// file pigz.c line 935
static unsigned long int time2dos(signed long int t)
{
  struct tm *tm;
  unsigned long int dos;
  if(t == 0l)
    t=time((signed long int *)(void *)0);

  tm=localtime(&t);
  _Bool tmp_if_expr_1;
  if(!(tm->tm_year >= 80))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = tm->tm_year > 207 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (unsigned long int)0;

  else
  {
    dos = (unsigned long int)(tm->tm_year - 80 << 25);
    dos = dos + (unsigned long int)(tm->tm_mon + 1 << 21);
    dos = dos + (unsigned long int)(tm->tm_mday << 16);
    dos = dos + (unsigned long int)(tm->tm_hour << 11);
    dos = dos + (unsigned long int)(tm->tm_min << 5);
    dos = dos + (unsigned long int)(tm->tm_sec + 1 >> 1);
    return dos;
  }
}

// tolong
// file pigz.c line 2432
static signed long int tolong(unsigned long int val)
{
  return (signed long int)(val & 0x7fffffffUL) - (signed long int)(val & 0x80000000UL);
}

// touch
// file pigz.c line 3410
static void touch(char *path, signed long int t)
{
  struct timeval times[2l];
  times[(signed long int)0].tv_sec = t;
  times[(signed long int)0].tv_usec = (signed long int)0;
  times[(signed long int)1].tv_sec = t;
  times[(signed long int)1].tv_usec = (signed long int)0;
  utimes(path, times);
}

// try_create_
// file try.c line 21
static void try_create_(void)
{
  signed int ret;
  ret=pthread_key_create(&try_key_, (void (*)(void *))(void *)0);
  /* assertion ret == 0 && "try: pthread_key_create() failed" */
  assert(ret == 0 && (_Bool)"try: pthread_key_create() failed");
}

// try_setup_
// file try.h line 303
void try_setup_(void)
{
  signed int ret;
  ret=pthread_once(&try_once_, try_create_);
  /* assertion ret == 0 && "try: pthread_once() failed" */
  assert(ret == 0 && (_Bool)"try: pthread_once() failed");
}

// try_throw_
// file try.h line 421
void try_throw_(signed int code, char *fmt, ...)
{
  try_setup_();
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
  /* assertion ((try_t_ *)pthread_getspecific(try_key_)) != ((void *)0) && "try: naked throw" */
  assert((struct try_s_ *)return_value_pthread_getspecific_1 != (struct try_s_ *)(void *)0 ? ((_Bool)"try: naked throw" ? (_Bool)1 : (_Bool)0) : (_Bool)0);
  void *return_value_pthread_getspecific_2;
  return_value_pthread_getspecific_2=pthread_getspecific(try_key_);
  ((struct try_s_ *)return_value_pthread_getspecific_2)->ball.code = code;
  void *return_value_pthread_getspecific_3;
  return_value_pthread_getspecific_3=pthread_getspecific(try_key_);
  ((struct try_s_ *)return_value_pthread_getspecific_3)->ball.free = 0;
  void *return_value_pthread_getspecific_4;
  return_value_pthread_getspecific_4=pthread_getspecific(try_key_);
  ((struct try_s_ *)return_value_pthread_getspecific_4)->ball.why = fmt;
  char *return_value_strchr_10;
  void *return_value_pthread_getspecific_7;
  if(!(fmt == ((char *)NULL)))
  {
    return_value_strchr_10=strchr(fmt, 37);
    if(!(return_value_strchr_10 == ((char *)NULL)))
    {
      char *why;
      char nul[1l];
      unsigned long int len;
      void **ap1;
      void **ap2;
      ap1 = (void **)&fmt;
      ap2 = (void **)ap1;
      signed int return_value_vsnprintf_5;
      return_value_vsnprintf_5=vsnprintf(nul, (unsigned long int)1, fmt, ap1);
      len = (unsigned long int)return_value_vsnprintf_5;
      ap1 = ((void **)NULL);
      void *return_value_malloc_6;
      return_value_malloc_6=malloc(len + (unsigned long int)1);
      why = (char *)return_value_malloc_6;
      if(why == ((char *)NULL))
      {
        return_value_pthread_getspecific_7=pthread_getspecific(try_key_);
        ((struct try_s_ *)return_value_pthread_getspecific_7)->ball.why = "try: out of memory";
      }

      else
      {
        vsnprintf(why, len + (unsigned long int)1, fmt, ap2);
        ap2 = ((void **)NULL);
        void *return_value_pthread_getspecific_8;
        return_value_pthread_getspecific_8=pthread_getspecific(try_key_);
        ((struct try_s_ *)return_value_pthread_getspecific_8)->ball.free = 1;
        void *return_value_pthread_getspecific_9;
        return_value_pthread_getspecific_9=pthread_getspecific(try_key_);
        ((struct try_s_ *)return_value_pthread_getspecific_9)->ball.why = why;
      }
    }

  }

  void *return_value_pthread_getspecific_11;
  return_value_pthread_getspecific_11=pthread_getspecific(try_key_);
  longjmp(((struct try_s_ *)return_value_pthread_getspecific_11)->env, 2);
}

// twist
// file yarn.h line 128
void twist(struct lock_s *bolt, enum twist_op op, signed long int val)
{
  signed int ret;
  if((signed int)op == TO)
    bolt->value = val;

  else
    if((signed int)op == BY)
      bolt->value = bolt->value + val;

  ret=pthread_cond_broadcast(&bolt->cond);
  _Bool tmp_if_expr_1;
  if(!(ret == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=pthread_mutex_unlock(&bolt->mutex);
    tmp_if_expr_1 = ret != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    fail(ret);

}

// unlzw
// file pigz.c line 3183
static void unlzw(void)
{
  unsigned int bits;
  unsigned int mask;
  unsigned int buf;
  unsigned int left;
  signed long int mark;
  unsigned int code;
  unsigned int max;
  unsigned int flags;
  unsigned int end;
  unsigned int prev;
  unsigned int final;
  unsigned int stack;
  unsigned int outcnt;
  unsigned short int prefix[65536l];
  unsigned char suffix[65536l];
  unsigned char match[65282l];
  g.out_tot = (signed long int)0;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_load_1;
  if(g.in_left == 0ul)
  {
    if(!(g.in_eof == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_load_1=load();
      tmp_if_expr_2 = return_value_load_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      try_throw_(33, "%s: lzw premature end", g.inf, (void *)0);

  }

  g.in_left = g.in_left - 1ul;
  unsigned char *tmp_post_3 = g.in_next;
  g.in_next = g.in_next + 1l;
  flags = (unsigned int)*tmp_post_3;
  if(!((96u & flags) == 0u))
    try_throw_(33, "%s: unknown lzw flags set", g.inf, (void *)0);

  max = flags & (unsigned int)0x1f;
  if(max >= 17u || !(max >= 9u))
    try_throw_(33, "%s: lzw bits out of range", g.inf, (void *)0);

  if(max == 9u)
    max = (unsigned int)10;

  flags = flags & (unsigned int)0x80;
  mark = (signed long int)((unsigned long int)g.in_tot - g.in_left);
  bits = (unsigned int)9;
  mask = (unsigned int)0x1ff;
  end = (unsigned int)(flags != 0u ? 256 : 255);
  _Bool tmp_if_expr_5;
  unsigned long int return_value_load_4;
  unsigned char *tmp_post_6;
  _Bool tmp_if_expr_8;
  unsigned long int return_value_load_7;
  unsigned char *tmp_post_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_load_11;
  unsigned char *tmp_post_13;
  _Bool tmp_if_expr_15;
  unsigned long int return_value_load_14;
  unsigned char *tmp_post_16;
  unsigned int tmp_post_18;
  unsigned int tmp_post_19;
  unsigned int tmp_post_20;
  unsigned int tmp_post_21;
  unsigned int tmp_post_22;
  if(g.in_left == 0ul)
  {
    if(!(g.in_eof == 0))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_load_4=load();
      tmp_if_expr_5 = return_value_load_4 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_5)
      goto __CPROVER_DUMP_L9;

  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    g.in_left = g.in_left - 1ul;
    tmp_post_6 = g.in_next;
    g.in_next = g.in_next + 1l;
    buf = (unsigned int)*tmp_post_6;
    if(g.in_left == 0ul)
    {
      if(!(g.in_eof == 0))
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_load_7=load();
        tmp_if_expr_8 = return_value_load_7 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        try_throw_(33, "%s: lzw premature end", g.inf, (void *)0);

    }

    g.in_left = g.in_left - 1ul;
    tmp_post_9 = g.in_next;
    g.in_next = g.in_next + 1l;
    buf = buf + (unsigned int)((signed int)*tmp_post_9 << 8);
    prev = buf & mask;
    final = prev;
    buf = buf >> bits;
    left = (unsigned int)16 - bits;
    if(prev >= 256u)
      try_throw_(33, "%s: invalid lzw code", g.inf, (void *)0);

    out_buf[(signed long int)0] = (unsigned char)final;
    outcnt = (unsigned int)1;
    stack = (unsigned int)0;
    while((_Bool)1)
    {
      if(end >= mask && !(bits >= max))
      {
        unsigned int unlzw__1__1__1__1__1__rem = (unsigned int)((((unsigned long int)g.in_tot - g.in_left) - (unsigned long int)mark) % (unsigned long int)bits);
        if(!(unlzw__1__1__1__1__1__rem == 0u))
          unlzw__1__1__1__1__1__rem = bits - unlzw__1__1__1__1__1__rem;

        while(!(g.in_left >= (unsigned long int)unlzw__1__1__1__1__1__rem))
        {
          unlzw__1__1__1__1__1__rem = unlzw__1__1__1__1__1__rem - (unsigned int)g.in_left;
          unsigned long int return_value_load_10;
          return_value_load_10=load();
          if(return_value_load_10 == 0ul)
            break;

        }
        g.in_left = g.in_left - (unsigned long int)unlzw__1__1__1__1__1__rem;
        g.in_next = g.in_next + (signed long int)unlzw__1__1__1__1__1__rem;
        buf = (unsigned int)0;
        left = (unsigned int)0;
        mark = (signed long int)((unsigned long int)g.in_tot - g.in_left);
        bits = bits + 1u;
        mask = mask << 1;
        mask = mask + 1u;
      }

      if(g.in_left == 0ul)
      {
        if(!(g.in_eof == 0))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_load_11=load();
          tmp_if_expr_12 = return_value_load_11 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          break;

      }

      g.in_left = g.in_left - 1ul;
      tmp_post_13 = g.in_next;
      g.in_next = g.in_next + 1l;
      buf = buf + ((unsigned int)*tmp_post_13 << left);
      left = left + (unsigned int)8;
      if(!(left >= bits))
      {
        if(g.in_left == 0ul)
        {
          if(!(g.in_eof == 0))
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_load_14=load();
            tmp_if_expr_15 = return_value_load_14 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
            try_throw_(33, "%s: lzw premature end", g.inf, (void *)0);

        }

        g.in_left = g.in_left - 1ul;
        tmp_post_16 = g.in_next;
        g.in_next = g.in_next + 1l;
        buf = buf + ((unsigned int)*tmp_post_16 << left);
        left = left + (unsigned int)8;
      }

      code = buf & mask;
      buf = buf >> bits;
      left = left - bits;
      if(code == 256u && !(flags == 0u))
      {
        unsigned int rem = (unsigned int)((((unsigned long int)g.in_tot - g.in_left) - (unsigned long int)mark) % (unsigned long int)bits);
        if(!(rem == 0u))
          rem = bits - rem;

        while(!(g.in_left >= (unsigned long int)rem))
        {
          rem = rem - (unsigned int)g.in_left;
          unsigned long int return_value_load_17;
          return_value_load_17=load();
          if(return_value_load_17 == 0ul)
            break;

        }
        g.in_left = g.in_left - (unsigned long int)rem;
        g.in_next = g.in_next + (signed long int)rem;
        buf = (unsigned int)0;
        left = (unsigned int)0;
        mark = (signed long int)((unsigned long int)g.in_tot - g.in_left);
        bits = (unsigned int)9;
        mask = (unsigned int)0x1ff;
        end = (unsigned int)255;
      }

      else
      {
        unsigned int temp = code;
        if(!(end >= code))
        {
          if(!(code == 1u + end) || !(end >= prev))
            try_throw_(33, "%s: invalid lzw code", g.inf, (void *)0);

          tmp_post_18 = stack;
          stack = stack + 1u;
          match[(signed long int)tmp_post_18] = (unsigned char)final;
          code = prev;
        }

        for( ; code >= 256u; code = (unsigned int)prefix[(signed long int)code])
        {
          tmp_post_19 = stack;
          stack = stack + 1u;
          match[(signed long int)tmp_post_19] = suffix[(signed long int)code];
        }
        tmp_post_20 = stack;
        stack = stack + 1u;
        match[(signed long int)tmp_post_20] = (unsigned char)code;
        final = code;
        if(!(end >= mask))
        {
          end = end + 1u;
          prefix[(signed long int)end] = (unsigned short int)prev;
          suffix[(signed long int)end] = (unsigned char)final;
        }

        prev = temp;
        for( ; !(32768U + -outcnt >= stack); outcnt = (unsigned int)0)
        {
          for( ; !(outcnt >= 32768U); out_buf[(signed long int)tmp_post_21] = match[(signed long int)stack])
          {
            tmp_post_21 = outcnt;
            outcnt = outcnt + 1u;
            stack = stack - 1u;
          }
          g.out_tot = g.out_tot + (signed long int)outcnt;
          if(g.decode == 1)
            writen(g.outd, out_buf, (unsigned long int)outcnt);

        }
        do
        {
          tmp_post_22 = outcnt;
          outcnt = outcnt + 1u;
          stack = stack - 1u;
          out_buf[(signed long int)tmp_post_22] = match[(signed long int)stack];
        }
        while(!(stack == 0u));
      }
    }
    g.out_tot = g.out_tot + (signed long int)outcnt;
    if(g.decode == 1 && !(outcnt == 0u))
      writen(g.outd, out_buf, (unsigned long int)outcnt);

  }
}

// use_space
// file pigz.c line 1308
static void use_space(struct space *space)
{
  possess(space->use);
  twist(space->use, (enum twist_op)BY, (signed long int)+1);
}

// vmemcpy
// file pigz.c line 870
static inline unsigned long int vmemcpy(char **mem, unsigned long int *size, unsigned long int off, void *cpy, unsigned long int len)
{
  unsigned long int need = off + len;
  if(!(need >= off))
    try_throw_(75, "overflow", (void *)0);

  if(!(*size >= need))
  {
    need=grow(need);
    if(off == 0ul)
    {
      do
        if(!(*mem == ((char *)NULL)))
        {
          free((void *)*mem);
          *mem = (char *)(void *)0;
        }

      while((_Bool)0);
      *size = (unsigned long int)0;
    }

    void *return_value_alloc_1;
    return_value_alloc_1=alloc((void *)*mem, need);
    *mem = (char *)return_value_alloc_1;
    *size = need;
  }

  memcpy((void *)(*mem + (signed long int)off), cpy, len);
  return off + len;
}

// vstrcpy
// file pigz.c line 894
static inline unsigned long int vstrcpy(char **str, unsigned long int *size, unsigned long int off, void *cpy)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen((const char *)cpy);
  unsigned long int return_value_vmemcpy_2;
  return_value_vmemcpy_2=vmemcpy(str, size, off, cpy, return_value_strlen_1 + (unsigned long int)1);
  return return_value_vmemcpy_2;
}

// wait_for
// file yarn.h line 132
void wait_for(struct lock_s *bolt, enum wait_op op, signed long int val)
{
  signed int ret;
  switch((signed int)op)
  {
    case TO_BE:
    {
      while(!(bolt->value == val))
      {
        ret=pthread_cond_wait(&bolt->cond, &bolt->mutex);
        if(!(ret == 0))
          fail(ret);

      }
      goto __CPROVER_DUMP_L12;
    }
    case NOT_TO_BE:
    {
      while(bolt->value == val)
      {
        ret=pthread_cond_wait(&bolt->cond, &bolt->mutex);
        if(!(ret == 0))
          fail(ret);

      }
      goto __CPROVER_DUMP_L12;
    }
    case TO_BE_MORE_THAN:
    {
      while(val >= bolt->value)
      {
        ret=pthread_cond_wait(&bolt->cond, &bolt->mutex);
        if(!(ret == 0))
          fail(ret);

      }
      goto __CPROVER_DUMP_L12;
    }
    case TO_BE_LESS_THAN:
      while(bolt->value >= val)
      {
        ret=pthread_cond_wait(&bolt->cond, &bolt->mutex);
        if(!(ret == 0))
          fail(ret);

      }
    default:

      __CPROVER_DUMP_L12:
        ;
  }
}

// write_thread
// file pigz.c line 1716
static void write_thread(void *dummy)
{
  signed long int seq;
  struct job *job;
  unsigned long int len;
  signed int more;
  unsigned long int head;
  unsigned long int ulen;
  unsigned long int clen;
  unsigned long int check;
  struct anonymous err;
  (void)dummy;
  unsigned long int tmp_if_expr_4;
  unsigned long int return_value_adler32_2;
  unsigned long int return_value_crc32_3;
  signed long int tmp_if_expr_5;
  unsigned long int tmp_if_expr_8;
  unsigned long int return_value_adler32_comb_6;
  unsigned long int return_value_crc32_comb_7;
  _Bool tmp_if_expr_10;
  signed long int return_value_peek_lock_9;
  do
  {
    struct try_s_ try_this_;
    signed int try_pushed_ = 1;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)(void *)0;
    try_setup_();
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(try_key_);
    try_this_.next = (struct try_s_ *)return_value_pthread_getspecific_1;
    do
    {
      signed int write_thread__1__1__1__try_ret_;
      write_thread__1__1__1__try_ret_=pthread_setspecific(try_key_, (const void *)&try_this_);
      /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
      assert(write_thread__1__1__1__try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
    }
    while((_Bool)0);
    signed int return_value__setjmp_11;
    return_value__setjmp_11=_setjmp(try_this_.env);
    if(!(return_value__setjmp_11 >= 2))
      do
      {
        head=put_header();
        clen = (unsigned long int)0;
        ulen = clen;
        if(g.form == 1)
        {
          return_value_adler32_2=adler32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
          tmp_if_expr_4 = return_value_adler32_2;
        }

        else
        {
          return_value_crc32_3=crc32((unsigned long int)0L, ((const unsigned char *)NULL), (unsigned int)0);
          tmp_if_expr_4 = return_value_crc32_3;
        }
        check = tmp_if_expr_4;
        seq = (signed long int)0;
        do
        {
          possess(write_first);
          wait_for(write_first, (enum wait_op)TO_BE, seq);
          job = write_head;
          write_head = job->next;
          if(write_head == ((struct job *)NULL))
            tmp_if_expr_5 = (signed long int)-1;

          else
            tmp_if_expr_5 = write_head->seq;
          twist(write_first, (enum twist_op)TO, tmp_if_expr_5);
          more = job->more;
          len = job->in->len;
          drop_space(job->in);
          ulen = ulen + (unsigned long int)len;
          clen = clen + (unsigned long int)job->out->len;
          writen(g.outd, job->out->buf, job->out->len);
          drop_space(job->out);
          possess(job->calc);
          wait_for(job->calc, (enum wait_op)TO_BE, (signed long int)1);
          release(job->calc);
          if(g.form == 1)
          {
            return_value_adler32_comb_6=adler32_comb(check, job->check, len);
            tmp_if_expr_8 = return_value_adler32_comb_6;
          }

          else
          {
            return_value_crc32_comb_7=crc32_comb(check, job->check, len);
            tmp_if_expr_8 = return_value_crc32_comb_7;
          }
          check = tmp_if_expr_8;
          free_lock(job->calc);
          free((void *)job);
          seq = seq + 1l;
        }
        while(!(more == 0));
        put_trailer(ulen, clen, check, head);
        possess(compress_have);
        if(compress_head == ((struct job *)NULL))
        {
          return_value_peek_lock_9=peek_lock(compress_have);
          tmp_if_expr_10 = return_value_peek_lock_9 == (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        /* assertion compress_head == ((void *)0) && peek_lock(compress_have) == 0 */
        assert(tmp_if_expr_10);
        release(compress_have);
        possess(write_first);
        /* assertion write_head == ((void *)0) */
        assert(write_head == (struct job *)(void *)0);
        twist(write_first, (enum twist_op)TO, (signed long int)-1);
      }
      while((_Bool)0);

    if(!(try_pushed_ == 0))
    {
      do
      {
        signed int try_ret_;
        try_ret_=pthread_setspecific(try_key_, (const void *)try_this_.next);
        /* assertion try_ret_ == 0 && "try: pthread_setspecific() failed" */
        assert(try_ret_ == 0 && (_Bool)"try: pthread_setspecific() failed");
      }
      while((_Bool)0);
      try_pushed_ = 0;
    }

    err = try_this_.ball;
  }
  while((_Bool)0);
  if(!(err.code == 0))
    do
    {
      complain("abort: %s", err.why);
      do
        if(!(err.free == 0))
        {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)(void *)0;
        }

      while((_Bool)0);
      cut_short(-err.code);
    }
    while((_Bool)0);

}

// writen
// file pigz.c line 920
static void writen(signed int desc, unsigned char *buf, unsigned long int len)
{
  signed long int ret;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  while(!(len == 0ul))
  {
    ret=write(desc, (const void *)buf, len);
    if(!(ret >= 1l))
    {
      return_value___errno_location_1=__errno_location();
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      try_throw_(*return_value___errno_location_1, "write error on %s (%s)", g.outf, return_value_strerror_3, (void *)0);
    }

    buf = buf + ret;
    len = len - (unsigned long int)ret;
  }
}

// yarn_mem
// file yarn.c line 74
void yarn_mem(void * (*lease)(unsigned long int), void (*vacate)(void *))
{
  my_malloc_f = lease;
  my_free = vacate;
}

