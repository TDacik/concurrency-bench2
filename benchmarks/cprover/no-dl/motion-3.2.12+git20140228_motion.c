// #anon_enum$AVLINK_UNINIT=0$AVLINK_STARTINIT=1$AVLINK_INIT=2
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 760
enum anonymous$33 { AVLINK_UNINIT=0, AVLINK_STARTINIT=1, AVLINK_INIT=2 };

// #anon_enum$AV_CLASS_CATEGORY_NA=0$AV_CLASS_CATEGORY_INPUT=1$AV_CLASS_CATEGORY_OUTPUT=2$AV_CLASS_CATEGORY_MUXER=3$AV_CLASS_CATEGORY_DEMUXER=4$AV_CLASS_CATEGORY_ENCODER=5$AV_CLASS_CATEGORY_DECODER=6$AV_CLASS_CATEGORY_FILTER=7$AV_CLASS_CATEGORY_BITSTREAM_FILTER=8$AV_CLASS_CATEGORY_SWSCALER=9$AV_CLASS_CATEGORY_SWRESAMPLER=10$AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40$AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41$AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42$AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43$AV_CLASS_CATEGORY_DEVICE_OUTPUT=44$AV_CLASS_CATEGORY_DEVICE_INPUT=45$AV_CLASS_CATEGORY_NB=46
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 29
enum anonymous$36 { AV_CLASS_CATEGORY_NA=0, AV_CLASS_CATEGORY_INPUT=1, AV_CLASS_CATEGORY_OUTPUT=2, AV_CLASS_CATEGORY_MUXER=3, AV_CLASS_CATEGORY_DEMUXER=4, AV_CLASS_CATEGORY_ENCODER=5, AV_CLASS_CATEGORY_DECODER=6, AV_CLASS_CATEGORY_FILTER=7, AV_CLASS_CATEGORY_BITSTREAM_FILTER=8, AV_CLASS_CATEGORY_SWSCALER=9, AV_CLASS_CATEGORY_SWRESAMPLER=10, AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40, AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41, AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42, AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43, AV_CLASS_CATEGORY_DEVICE_OUTPUT=44, AV_CLASS_CATEGORY_DEVICE_INPUT=45, AV_CLASS_CATEGORY_NB=46 };

// #anon_enum$CONNECTION_OK=0$CONNECTION_BAD=1$CONNECTION_STARTED=2$CONNECTION_MADE=3$CONNECTION_AWAITING_RESPONSE=4$CONNECTION_AUTH_OK=5$CONNECTION_SETENV=6$CONNECTION_SSL_STARTUP=7$CONNECTION_NEEDED=8
// file /usr/include/postgresql/libpq-fe.h line 47
enum anonymous$41 { CONNECTION_OK=0, CONNECTION_BAD=1, CONNECTION_STARTED=2, CONNECTION_MADE=3, CONNECTION_AWAITING_RESPONSE=4, CONNECTION_AUTH_OK=5, CONNECTION_SETENV=6, CONNECTION_SSL_STARTUP=7, CONNECTION_NEEDED=8 };

// #anon_enum$JCS_UNKNOWN=0$JCS_GRAYSCALE=1$JCS_RGB=2$JCS_YCbCr=3$JCS_CMYK=4$JCS_YCCK=5$JCS_EXT_RGB=6$JCS_EXT_RGBX=7$JCS_EXT_BGR=8$JCS_EXT_BGRX=9$JCS_EXT_XBGR=10$JCS_EXT_XRGB=11$JCS_EXT_RGBA=12$JCS_EXT_BGRA=13$JCS_EXT_ABGR=14$JCS_EXT_ARGB=15$JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous$10 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum$JDCT_ISLOW=0$JDCT_IFAST=1$JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous$11 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum$JDITHER_NONE=0$JDITHER_ORDERED=1$JDITHER_FS=2
// file /usr/include/jpeglib.h line 259
enum anonymous$12 { JDITHER_NONE=0, JDITHER_ORDERED=1, JDITHER_FS=2 };

// #anon_enum$KMOD_NONE=0$KMOD_LSHIFT=1$KMOD_RSHIFT=2$KMOD_LCTRL=64$KMOD_RCTRL=128$KMOD_LALT=256$KMOD_RALT=512$KMOD_LMETA=1024$KMOD_RMETA=2048$KMOD_NUM=4096$KMOD_CAPS=8192$KMOD_MODE=16384$KMOD_RESERVED=32768
// file /usr/include/SDL/SDL_keysym.h line 305
enum anonymous$38 { KMOD_NONE=0, KMOD_LSHIFT=1, KMOD_RSHIFT=2, KMOD_LCTRL=64, KMOD_RCTRL=128, KMOD_LALT=256, KMOD_RALT=512, KMOD_LMETA=1024, KMOD_RMETA=2048, KMOD_NUM=4096, KMOD_CAPS=8192, KMOD_MODE=16384, KMOD_RESERVED=32768 };

// #anon_enum$PGRES_EMPTY_QUERY=0$PGRES_COMMAND_OK=1$PGRES_TUPLES_OK=2$PGRES_COPY_OUT=3$PGRES_COPY_IN=4$PGRES_BAD_RESPONSE=5$PGRES_NONFATAL_ERROR=6$PGRES_FATAL_ERROR=7$PGRES_COPY_BOTH=8$PGRES_SINGLE_TUPLE=9
// file /usr/include/postgresql/libpq-fe.h line 78
enum anonymous$4 { PGRES_EMPTY_QUERY=0, PGRES_COMMAND_OK=1, PGRES_TUPLES_OK=2, PGRES_COPY_OUT=3, PGRES_COPY_IN=4, PGRES_BAD_RESPONSE=5, PGRES_NONFATAL_ERROR=6, PGRES_FATAL_ERROR=7, PGRES_COPY_BOTH=8, PGRES_SINGLE_TUPLE=9 };

// #anon_enum$SDLK_UNKNOWN=0$SDLK_FIRST=0$SDLK_BACKSPACE=8$SDLK_TAB=9$SDLK_CLEAR=12$SDLK_RETURN=13$SDLK_PAUSE=19$SDLK_ESCAPE=27$SDLK_SPACE=32$SDLK_EXCLAIM=33$SDLK_QUOTEDBL=34$SDLK_HASH=35$SDLK_DOLLAR=36$SDLK_AMPERSAND=38$SDLK_QUOTE=39$SDLK_LEFTPAREN=40$SDLK_RIGHTPAREN=41$SDLK_ASTERISK=42$SDLK_PLUS=43$SDLK_COMMA=44$SDLK_MINUS=45$SDLK_PERIOD=46$SDLK_SLASH=47$SDLK_0=48$SDLK_1=49$SDLK_2=50$SDLK_3=51$SDLK_4=52$SDLK_5=53$SDLK_6=54$SDLK_7=55$SDLK_8=56$SDLK_9=57$SDLK_COLON=58$SDLK_SEMICOLON=59$SDLK_LESS=60$SDLK_EQUALS=61$SDLK_GREATER=62$SDLK_QUESTION=63$SDLK_AT=64$SDLK_LEFTBRACKET=91$SDLK_BACKSLASH=92$SDLK_RIGHTBRACKET=93$SDLK_CARET=94$SDLK_UNDERSCORE=95$SDLK_BACKQUOTE=96$SDLK_a=97$SDLK_b=98$SDLK_c=99$SDLK_d=100$SDLK_e=101$SDLK_f=102$SDLK_g=103$SDLK_h=104$SDLK_i=105$SDLK_j=106$SDLK_k=107$SDLK_l=108$SDLK_m=109$SDLK_n=110$SDLK_o=111$SDLK_p=112$SDLK_q=113$SDLK_r=114$SDLK_s=115$SDLK_t=116$SDLK_u=117$SDLK_v=118$SDLK_w=119$SDLK_x=120$SDLK_y=121$SDLK_z=122$SDLK_DELETE=127$SDLK_WORLD_0=160$SDLK_WORLD_1=161$SDLK_WORLD_2=162$SDLK_WORLD_3=163$SDLK_WORLD_4=164$SDLK_WORLD_5=165$SDLK_WORLD_6=166$SDLK_WORLD_7=167$SDLK_WORLD_8=168$SDLK_WORLD_9=169$SDLK_WORLD_10=170$SDLK_WORLD_11=171$SDLK_WORLD_12=172$SDLK_WORLD_13=173$SDLK_WORLD_14=174$SDLK_WORLD_15=175$SDLK_WORLD_16=176$SDLK_WORLD_17=177$SDLK_WORLD_18=178$SDLK_WORLD_19=179$SDLK_WORLD_20=180$SDLK_WORLD_21=181$SDLK_WORLD_22=182$SDLK_WORLD_23=183$SDLK_WORLD_24=184$SDLK_WORLD_25=185$SDLK_WORLD_26=186$SDLK_WORLD_27=187$SDLK_WORLD_28=188$SDLK_WORLD_29=189$SDLK_WORLD_30=190$SDLK_WORLD_31=191$SDLK_WORLD_32=192$SDLK_WORLD_33=193$SDLK_WORLD_34=194$SDLK_WORLD_35=195$SDLK_WORLD_36=196$SDLK_WORLD_37=197$SDLK_WORLD_38=198$SDLK_WORLD_39=199$SDLK_WORLD_40=200$SDLK_WORLD_41=201$SDLK_WORLD_42=202$SDLK_WORLD_43=203$SDLK_WORLD_44=204$SDLK_WORLD_45=205$SDLK_WORLD_46=206$SDLK_WORLD_47=207$SDLK_WORLD_48=208$SDLK_WORLD_49=209$SDLK_WORLD_50=210$SDLK_WORLD_51=211$SDLK_WORLD_52=212$SDLK_WORLD_53=213$SDLK_WORLD_54=214$SDLK_WORLD_55=215$SDLK_WORLD_56=216$SDLK_WORLD_57=217$SDLK_WORLD_58=218$SDLK_WORLD_59=219$SDLK_WORLD_60=220$SDLK_WORLD_61=221$SDLK_WORLD_62=222$SDLK_WORLD_63=223$SDLK_WORLD_64=224$SDLK_WORLD_65=225$SDLK_WORLD_66=226$SDLK_WORLD_67=227$SDLK_WORLD_68=228$SDLK_WORLD_69=229$SDLK_WORLD_70=230$SDLK_WORLD_71=231$SDLK_WORLD_72=232$SDLK_WORLD_73=233$SDLK_WORLD_74=234$SDLK_WORLD_75=235$SDLK_WORLD_76=236$SDLK_WORLD_77=237$SDLK_WORLD_78=238$SDLK_WORLD_79=239$SDLK_WORLD_80=240$SDLK_WORLD_81=241$SDLK_WORLD_82=242$SDLK_WORLD_83=243$SDLK_WORLD_84=244$SDLK_WORLD_85=245$SDLK_WORLD_86=246$SDLK_WORLD_87=247$SDLK_WORLD_88=248$SDLK_WORLD_89=249$SDLK_WORLD_90=250$SDLK_WORLD_91=251$SDLK_WORLD_92=252$SDLK_WORLD_93=253$SDLK_WORLD_94=254$SDLK_WORLD_95=255$SDLK_KP0=256$SDLK_KP1=257$SDLK_KP2=258$SDLK_KP3=259$SDLK_KP4=260$SDLK_KP5=261$SDLK_KP6=262$SDLK_KP7=263$SDLK_KP8=264$SDLK_KP9=265$SDLK_KP_PERIOD=266$SDLK_KP_DIVIDE=267$SDLK_KP_MULTIPLY=268$SDLK_KP_MINUS=269$SDLK_KP_PLUS=270$SDLK_KP_ENTER=271$SDLK_KP_EQUALS=272$SDLK_UP=273$SDLK_DOWN=274$SDLK_RIGHT=275$SDLK_LEFT=276$SDLK_INSERT=277$SDLK_HOME=278$SDLK_END=279$SDLK_PAGEUP=280$SDLK_PAGEDOWN=281$SDLK_F1=282$SDLK_F2=283$SDLK_F3=284$SDLK_F4=285$SDLK_F5=286$SDLK_F6=287$SDLK_F7=288$SDLK_F8=289$SDLK_F9=290$SDLK_F10=291$SDLK_F11=292$SDLK_F12=293$SDLK_F13=294$SDLK_F14=295$SDLK_F15=296$SDLK_NUMLOCK=300$SDLK_CAPSLOCK=301$SDLK_SCROLLOCK=302$SDLK_RSHIFT=303$SDLK_LSHIFT=304$SDLK_RCTRL=305$SDLK_LCTRL=306$SDLK_RALT=307$SDLK_LALT=308$SDLK_RMETA=309$SDLK_LMETA=310$SDLK_LSUPER=311$SDLK_RSUPER=312$SDLK_MODE=313$SDLK_COMPOSE=314$SDLK_HELP=315$SDLK_PRINT=316$SDLK_SYSREQ=317$SDLK_BREAK=318$SDLK_MENU=319$SDLK_POWER=320$SDLK_EURO=321$SDLK_UNDO=322$SDLK_LAST=323
// file /usr/include/SDL/SDL_keysym.h line 31
enum anonymous$37 { SDLK_UNKNOWN=0, SDLK_FIRST=0, SDLK_BACKSPACE=8, SDLK_TAB=9, SDLK_CLEAR=12, SDLK_RETURN=13, SDLK_PAUSE=19, SDLK_ESCAPE=27, SDLK_SPACE=32, SDLK_EXCLAIM=33, SDLK_QUOTEDBL=34, SDLK_HASH=35, SDLK_DOLLAR=36, SDLK_AMPERSAND=38, SDLK_QUOTE=39, SDLK_LEFTPAREN=40, SDLK_RIGHTPAREN=41, SDLK_ASTERISK=42, SDLK_PLUS=43, SDLK_COMMA=44, SDLK_MINUS=45, SDLK_PERIOD=46, SDLK_SLASH=47, SDLK_0=48, SDLK_1=49, SDLK_2=50, SDLK_3=51, SDLK_4=52, SDLK_5=53, SDLK_6=54, SDLK_7=55, SDLK_8=56, SDLK_9=57, SDLK_COLON=58, SDLK_SEMICOLON=59, SDLK_LESS=60, SDLK_EQUALS=61, SDLK_GREATER=62, SDLK_QUESTION=63, SDLK_AT=64, SDLK_LEFTBRACKET=91, SDLK_BACKSLASH=92, SDLK_RIGHTBRACKET=93, SDLK_CARET=94, SDLK_UNDERSCORE=95, SDLK_BACKQUOTE=96, SDLK_a=97, SDLK_b=98, SDLK_c=99, SDLK_d=100, SDLK_e=101, SDLK_f=102, SDLK_g=103, SDLK_h=104, SDLK_i=105, SDLK_j=106, SDLK_k=107, SDLK_l=108, SDLK_m=109, SDLK_n=110, SDLK_o=111, SDLK_p=112, SDLK_q=113, SDLK_r=114, SDLK_s=115, SDLK_t=116, SDLK_u=117, SDLK_v=118, SDLK_w=119, SDLK_x=120, SDLK_y=121, SDLK_z=122, SDLK_DELETE=127, SDLK_WORLD_0=160, SDLK_WORLD_1=161, SDLK_WORLD_2=162, SDLK_WORLD_3=163, SDLK_WORLD_4=164, SDLK_WORLD_5=165, SDLK_WORLD_6=166, SDLK_WORLD_7=167, SDLK_WORLD_8=168, SDLK_WORLD_9=169, SDLK_WORLD_10=170, SDLK_WORLD_11=171, SDLK_WORLD_12=172, SDLK_WORLD_13=173, SDLK_WORLD_14=174, SDLK_WORLD_15=175, SDLK_WORLD_16=176, SDLK_WORLD_17=177, SDLK_WORLD_18=178, SDLK_WORLD_19=179, SDLK_WORLD_20=180, SDLK_WORLD_21=181, SDLK_WORLD_22=182, SDLK_WORLD_23=183, SDLK_WORLD_24=184, SDLK_WORLD_25=185, SDLK_WORLD_26=186, SDLK_WORLD_27=187, SDLK_WORLD_28=188, SDLK_WORLD_29=189, SDLK_WORLD_30=190, SDLK_WORLD_31=191, SDLK_WORLD_32=192, SDLK_WORLD_33=193, SDLK_WORLD_34=194, SDLK_WORLD_35=195, SDLK_WORLD_36=196, SDLK_WORLD_37=197, SDLK_WORLD_38=198, SDLK_WORLD_39=199, SDLK_WORLD_40=200, SDLK_WORLD_41=201, SDLK_WORLD_42=202, SDLK_WORLD_43=203, SDLK_WORLD_44=204, SDLK_WORLD_45=205, SDLK_WORLD_46=206, SDLK_WORLD_47=207, SDLK_WORLD_48=208, SDLK_WORLD_49=209, SDLK_WORLD_50=210, SDLK_WORLD_51=211, SDLK_WORLD_52=212, SDLK_WORLD_53=213, SDLK_WORLD_54=214, SDLK_WORLD_55=215, SDLK_WORLD_56=216, SDLK_WORLD_57=217, SDLK_WORLD_58=218, SDLK_WORLD_59=219, SDLK_WORLD_60=220, SDLK_WORLD_61=221, SDLK_WORLD_62=222, SDLK_WORLD_63=223, SDLK_WORLD_64=224, SDLK_WORLD_65=225, SDLK_WORLD_66=226, SDLK_WORLD_67=227, SDLK_WORLD_68=228, SDLK_WORLD_69=229, SDLK_WORLD_70=230, SDLK_WORLD_71=231, SDLK_WORLD_72=232, SDLK_WORLD_73=233, SDLK_WORLD_74=234, SDLK_WORLD_75=235, SDLK_WORLD_76=236, SDLK_WORLD_77=237, SDLK_WORLD_78=238, SDLK_WORLD_79=239, SDLK_WORLD_80=240, SDLK_WORLD_81=241, SDLK_WORLD_82=242, SDLK_WORLD_83=243, SDLK_WORLD_84=244, SDLK_WORLD_85=245, SDLK_WORLD_86=246, SDLK_WORLD_87=247, SDLK_WORLD_88=248, SDLK_WORLD_89=249, SDLK_WORLD_90=250, SDLK_WORLD_91=251, SDLK_WORLD_92=252, SDLK_WORLD_93=253, SDLK_WORLD_94=254, SDLK_WORLD_95=255, SDLK_KP0=256, SDLK_KP1=257, SDLK_KP2=258, SDLK_KP3=259, SDLK_KP4=260, SDLK_KP5=261, SDLK_KP6=262, SDLK_KP7=263, SDLK_KP8=264, SDLK_KP9=265, SDLK_KP_PERIOD=266, SDLK_KP_DIVIDE=267, SDLK_KP_MULTIPLY=268, SDLK_KP_MINUS=269, SDLK_KP_PLUS=270, SDLK_KP_ENTER=271, SDLK_KP_EQUALS=272, SDLK_UP=273, SDLK_DOWN=274, SDLK_RIGHT=275, SDLK_LEFT=276, SDLK_INSERT=277, SDLK_HOME=278, SDLK_END=279, SDLK_PAGEUP=280, SDLK_PAGEDOWN=281, SDLK_F1=282, SDLK_F2=283, SDLK_F3=284, SDLK_F4=285, SDLK_F5=286, SDLK_F6=287, SDLK_F7=288, SDLK_F8=289, SDLK_F9=290, SDLK_F10=291, SDLK_F11=292, SDLK_F12=293, SDLK_F13=294, SDLK_F14=295, SDLK_F15=296, SDLK_NUMLOCK=300, SDLK_CAPSLOCK=301, SDLK_SCROLLOCK=302, SDLK_RSHIFT=303, SDLK_LSHIFT=304, SDLK_RCTRL=305, SDLK_LCTRL=306, SDLK_RALT=307, SDLK_LALT=308, SDLK_RMETA=309, SDLK_LMETA=310, SDLK_LSUPER=311, SDLK_RSUPER=312, SDLK_MODE=313, SDLK_COMPOSE=314, SDLK_HELP=315, SDLK_PRINT=316, SDLK_SYSREQ=317, SDLK_BREAK=318, SDLK_MENU=319, SDLK_POWER=320, SDLK_EURO=321, SDLK_UNDO=322, SDLK_LAST=323 };

// tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous$27;

// tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous$24;

// tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$25;

// tag-#anon#ST[*{cS8}$cS8$'param_name'|*{cS8}$cS8$'param_help'|U32'main_thread'|S32'conf_value'|*{*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$(*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$|*{cS8}$cS8$|S32)->*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$}$*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$(*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$|*{cS8}$cS8$|S32)->*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$$'copy'|*{*{cS8}$cS8$(*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$|*{*{S8}$S8$}$*{S8}$S8$$|S32|U32)->*{cS8}$cS8$}$*{cS8}$cS8$(*{*{SYM#tag-context#}$SYM#tag-context#$}$*{SYM#tag-context#}$SYM#tag-context#$$|*{*{S8}$S8$}$*{S8}$S8$$|S32|U32)->*{cS8}$cS8$$'print']
// file conf.h line 149
struct anonymous;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$45;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$16;

// tag-#anon#ST[ARR17{U8}$U8$'bits'|ARR256{U8}$U8$'huffval'|U24'$pad0'|S32'sent_table']
// file /usr/include/jpeglib.h line 101
struct anonymous$14;

// tag-#anon#ST[ARR4{S8}$S8$'mh_magic'|U32'mh_framesize'|U16'mh_framewidth'|U16'mh_frameheight'|U32'mh_frameoffset'|U16'mh_chunksize'|ARR30{S8}$S8$'mh_reserved']
// file netcam.h line 274
struct anonymous$47;

// tag-#anon#ST[ARR4{U32}$U32$'state'|ARR2{U32}$U32$'count'|ARR64{U8}$U8$'buffer']
// file md5.h line 66
struct anonymous$30;

// tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']
// file /usr/include/jpeglib.h line 84
struct anonymous$13;

// tag-#anon#ST[S16'y'|S16'xl'|S16'xr'|S16'dy']
// file alg.c line 451
struct anonymous$1;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$9;

// tag-#anon#ST[S32'component_id'|S32'component_index'|S32'h_samp_factor'|S32'v_samp_factor'|S32'quant_tbl_no'|S32'dc_tbl_no'|S32'ac_tbl_no'|U32'width_in_blocks'|U32'height_in_blocks'|S32'DCT_scaled_size'|U32'downsampled_width'|U32'downsampled_height'|S32'component_needed'|S32'MCU_width'|S32'MCU_height'|S32'MCU_blocks'|S32'MCU_sample_width'|S32'last_col_width'|S32'last_row_height'|U32'$pad0'|*{SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']#}$SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']#$'quant_table'|*{V}$V$'dct_table']
// file /usr/include/jpeglib.h line 117
struct anonymous$15;

// tag-#anon#ST[S32'comps_in_scan'|ARR4{S32}$S32$'component_index'|S32'Ss'|S32'Se'|S32'Ah'|S32'Al']
// file /usr/include/jpeglib.h line 190
struct anonymous$22;

// tag-#anon#ST[S32'fd'|U32'fps'|SYM#tag-v4l2_capability#'cap'|SYM#tag-v4l2_format#'src_fmt'|SYM#tag-v4l2_format#'dst_fmt'|SYM#tag-v4l2_requestbuffers#'req'|U32'$pad0'|SYM#tag-v4l2_buffer#'buf'|*{SYM#tag-video_image_buff#}$SYM#tag-video_image_buff#$'buffers'|S32'pframe'|U32'ctrl_flags'|*{SYM#tag-v4l2_queryctrl#}$SYM#tag-v4l2_queryctrl#$'controls']
// file video2.c line 160
struct anonymous$29;

// tag-#anon#ST[S32'is_abs'|S32'len'|S32'val']
// file video_common.c line 23
struct anonymous$39;

// tag-#anon#ST[S32'rm_so'|S32'rm_eo']
// file /usr/include/regex.h line 452
struct anonymous$46;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$19;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$23;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$21;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$18;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$20;

// tag-#anon#ST[S64'last_dts'|S64'duration_gcd'|S32'duration_count'|U32'$pad0'|S64'rfps_duration_sum'|*{ARR2{ARR399{F64}$F64$}$ARR399{F64}$F64$$}$ARR2{ARR399{F64}$F64$}$ARR399{F64}$F64$$$'duration_error'|S64'codec_info_duration'|S64'codec_info_duration_fields'|S32'found_decoder'|U32'$pad1'|S64'last_duration'|S64'fps_first_dts'|S32'fps_first_dts_idx'|U32'$pad2'|S64'fps_last_dts'|S32'fps_last_dts_idx'|U32'$pad3']
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 984
struct anonymous$6;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous$26;

// tag-#anon#ST[SYM#tag-jpeg_destination_mgr#'pub'|*{U8}$U8$'buf'|U64'bufsize'|U64'jpegsize']
// file picture.c line 25
struct anonymous$8;

// tag-#anon#ST[SYM#tag-jpeg_source_mgr#'pub'|*{S8}$S8$'data'|S32'length'|U32'$pad0'|*{U8}$U8$'buffer'|S32'start_of_file'|U32'$pad1']
// file netcam_jpeg.c line 24
struct anonymous$0;

// tag-#anon#UN[*{S8}$S8$'client_ip'|*{S8}$S8$'bind_address']
// file /usr/include/mysql/mysql.h line 208
union anonymous$3;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V$'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$17;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$42;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$28;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$31;

// tag-#anon#UN[ARR8{S32}$S32$'i'|ARR80{S8}$S8$'s']
// file /usr/include/jpeglib.h line 736
union anonymous$40;

// tag-#anon#UN[S64'q'|U64'uq'|ARR2{S32}$S32$'d'|ARR2{U32}$U32$'ud'|ARR4{S16}$S16$'w'|ARR4{U16}$U16$'uw'|ARR8{S8}$S8$'b'|ARR8{U8}$U8$'ub'|ARR2{F32}$F32$'s']
// file mmx.h line 14
union anonymous$2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$44;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$5;

// tag-#anon#UN[SYM#tag-v4l2_pix_format#'pix'|SYM#tag-v4l2_pix_format_mplane#'pix_mp'|SYM#tag-v4l2_window#'win'|SYM#tag-v4l2_vbi_format#'vbi'|SYM#tag-v4l2_sliced_vbi_format#'sliced'|SYM#tag-v4l2_sdr_format#'sdr'|ARR200{U8}$U8$'raw_data']
// file /usr/include/linux/videodev2.h line 2002
union anonymous$35;

// tag-#anon#UN[U32'mem_offset'|U64'userptr'|S32'fd']
// file /usr/include/linux/videodev2.h line 810
union anonymous$32;

// tag-#anon#UN[U32'offset'|U64'userptr'|*{SYM#tag-v4l2_plane#}$SYM#tag-v4l2_plane#$'planes'|S32'fd']
// file /usr/include/linux/videodev2.h line 861
union anonymous$34;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$43;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$7;

// tag-AVAudioServiceType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 692
enum AVAudioServiceType { AV_AUDIO_SERVICE_TYPE_MAIN=0, AV_AUDIO_SERVICE_TYPE_EFFECTS=1, AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED=2, AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED=3, AV_AUDIO_SERVICE_TYPE_DIALOGUE=4, AV_AUDIO_SERVICE_TYPE_COMMENTARY=5, AV_AUDIO_SERVICE_TYPE_EMERGENCY=6, AV_AUDIO_SERVICE_TYPE_VOICE_OVER=7, AV_AUDIO_SERVICE_TYPE_KARAOKE=8, AV_AUDIO_SERVICE_TYPE_NB=9 };

// tag-AVBuffer
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 73
struct AVBuffer;

// tag-AVBufferRef
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 81
struct AVBufferRef;

// tag-AVChapter
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1239
struct AVChapter;

// tag-AVChromaLocation
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 559
enum AVChromaLocation { AVCHROMA_LOC_UNSPECIFIED=0, AVCHROMA_LOC_LEFT=1, AVCHROMA_LOC_CENTER=2, AVCHROMA_LOC_TOPLEFT=3, AVCHROMA_LOC_TOP=4, AVCHROMA_LOC_BOTTOMLEFT=5, AVCHROMA_LOC_BOTTOM=6, AVCHROMA_LOC_NB=7 };

// tag-AVClass
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 67
struct AVClass;

// tag-AVCodec
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1511
struct AVCodec;

// tag-AVCodecContext
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 408
struct AVCodecContext;

// tag-AVCodecDefault
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3465
struct AVCodecDefault;

// tag-AVCodecDescriptor
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 566
struct AVCodecDescriptor;

// tag-AVCodecID
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 102
enum AVCodecID { AV_CODEC_ID_NONE=0, AV_CODEC_ID_MPEG1VIDEO=1, AV_CODEC_ID_MPEG2VIDEO=2, AV_CODEC_ID_MPEG2VIDEO_XVMC=3, AV_CODEC_ID_H261=4, AV_CODEC_ID_H263=5, AV_CODEC_ID_RV10=6, AV_CODEC_ID_RV20=7, AV_CODEC_ID_MJPEG=8, AV_CODEC_ID_MJPEGB=9, AV_CODEC_ID_LJPEG=10, AV_CODEC_ID_SP5X=11, AV_CODEC_ID_JPEGLS=12, AV_CODEC_ID_MPEG4=13, AV_CODEC_ID_RAWVIDEO=14, AV_CODEC_ID_MSMPEG4V1=15, AV_CODEC_ID_MSMPEG4V2=16, AV_CODEC_ID_MSMPEG4V3=17, AV_CODEC_ID_WMV1=18, AV_CODEC_ID_WMV2=19, AV_CODEC_ID_H263P=20, AV_CODEC_ID_H263I=21, AV_CODEC_ID_FLV1=22, AV_CODEC_ID_SVQ1=23, AV_CODEC_ID_SVQ3=24, AV_CODEC_ID_DVVIDEO=25, AV_CODEC_ID_HUFFYUV=26, AV_CODEC_ID_CYUV=27, AV_CODEC_ID_H264=28, AV_CODEC_ID_INDEO3=29, AV_CODEC_ID_VP3=30, AV_CODEC_ID_THEORA=31, AV_CODEC_ID_ASV1=32, AV_CODEC_ID_ASV2=33, AV_CODEC_ID_FFV1=34, AV_CODEC_ID_4XM=35, AV_CODEC_ID_VCR1=36, AV_CODEC_ID_CLJR=37, AV_CODEC_ID_MDEC=38, AV_CODEC_ID_ROQ=39, AV_CODEC_ID_INTERPLAY_VIDEO=40, AV_CODEC_ID_XAN_WC3=41, AV_CODEC_ID_XAN_WC4=42, AV_CODEC_ID_RPZA=43, AV_CODEC_ID_CINEPAK=44, AV_CODEC_ID_WS_VQA=45, AV_CODEC_ID_MSRLE=46, AV_CODEC_ID_MSVIDEO1=47, AV_CODEC_ID_IDCIN=48, AV_CODEC_ID_8BPS=49, AV_CODEC_ID_SMC=50, AV_CODEC_ID_FLIC=51, AV_CODEC_ID_TRUEMOTION1=52, AV_CODEC_ID_VMDVIDEO=53, AV_CODEC_ID_MSZH=54, AV_CODEC_ID_ZLIB=55, AV_CODEC_ID_QTRLE=56, AV_CODEC_ID_TSCC=57, AV_CODEC_ID_ULTI=58, AV_CODEC_ID_QDRAW=59, AV_CODEC_ID_VIXL=60, AV_CODEC_ID_QPEG=61, AV_CODEC_ID_PNG=62, AV_CODEC_ID_PPM=63, AV_CODEC_ID_PBM=64, AV_CODEC_ID_PGM=65, AV_CODEC_ID_PGMYUV=66, AV_CODEC_ID_PAM=67, AV_CODEC_ID_FFVHUFF=68, AV_CODEC_ID_RV30=69, AV_CODEC_ID_RV40=70, AV_CODEC_ID_VC1=71, AV_CODEC_ID_WMV3=72, AV_CODEC_ID_LOCO=73, AV_CODEC_ID_WNV1=74, AV_CODEC_ID_AASC=75, AV_CODEC_ID_INDEO2=76, AV_CODEC_ID_FRAPS=77, AV_CODEC_ID_TRUEMOTION2=78, AV_CODEC_ID_BMP=79, AV_CODEC_ID_CSCD=80, AV_CODEC_ID_MMVIDEO=81, AV_CODEC_ID_ZMBV=82, AV_CODEC_ID_AVS=83, AV_CODEC_ID_SMACKVIDEO=84, AV_CODEC_ID_NUV=85, AV_CODEC_ID_KMVC=86, AV_CODEC_ID_FLASHSV=87, AV_CODEC_ID_CAVS=88, AV_CODEC_ID_JPEG2000=89, AV_CODEC_ID_VMNC=90, AV_CODEC_ID_VP5=91, AV_CODEC_ID_VP6=92, AV_CODEC_ID_VP6F=93, AV_CODEC_ID_TARGA=94, AV_CODEC_ID_DSICINVIDEO=95, AV_CODEC_ID_TIERTEXSEQVIDEO=96, AV_CODEC_ID_TIFF=97, AV_CODEC_ID_GIF=98, AV_CODEC_ID_DXA=99, AV_CODEC_ID_DNXHD=100, AV_CODEC_ID_THP=101, AV_CODEC_ID_SGI=102, AV_CODEC_ID_C93=103, AV_CODEC_ID_BETHSOFTVID=104, AV_CODEC_ID_PTX=105, AV_CODEC_ID_TXD=106, AV_CODEC_ID_VP6A=107, AV_CODEC_ID_AMV=108, AV_CODEC_ID_VB=109, AV_CODEC_ID_PCX=110, AV_CODEC_ID_SUNRAST=111, AV_CODEC_ID_INDEO4=112, AV_CODEC_ID_INDEO5=113, AV_CODEC_ID_MIMIC=114, AV_CODEC_ID_RL2=115, AV_CODEC_ID_ESCAPE124=116, AV_CODEC_ID_DIRAC=117, AV_CODEC_ID_BFI=118, AV_CODEC_ID_CMV=119, AV_CODEC_ID_MOTIONPIXELS=120, AV_CODEC_ID_TGV=121, AV_CODEC_ID_TGQ=122, AV_CODEC_ID_TQI=123, AV_CODEC_ID_AURA=124, AV_CODEC_ID_AURA2=125, AV_CODEC_ID_V210X=126, AV_CODEC_ID_TMV=127, AV_CODEC_ID_V210=128, AV_CODEC_ID_DPX=129, AV_CODEC_ID_MAD=130, AV_CODEC_ID_FRWU=131, AV_CODEC_ID_FLASHSV2=132, AV_CODEC_ID_CDGRAPHICS=133, AV_CODEC_ID_R210=134, AV_CODEC_ID_ANM=135, AV_CODEC_ID_BINKVIDEO=136, AV_CODEC_ID_IFF_ILBM=137, AV_CODEC_ID_IFF_BYTERUN1=138, AV_CODEC_ID_KGV1=139, AV_CODEC_ID_YOP=140, AV_CODEC_ID_VP8=141, AV_CODEC_ID_PICTOR=142, AV_CODEC_ID_ANSI=143, AV_CODEC_ID_A64_MULTI=144, AV_CODEC_ID_A64_MULTI5=145, AV_CODEC_ID_R10K=146, AV_CODEC_ID_MXPEG=147, AV_CODEC_ID_LAGARITH=148, AV_CODEC_ID_PRORES=149, AV_CODEC_ID_JV=150, AV_CODEC_ID_DFA=151, AV_CODEC_ID_WMV3IMAGE=152, AV_CODEC_ID_VC1IMAGE=153, AV_CODEC_ID_UTVIDEO=154, AV_CODEC_ID_BMV_VIDEO=155, AV_CODEC_ID_VBLE=156, AV_CODEC_ID_DXTORY=157, AV_CODEC_ID_V410=158, AV_CODEC_ID_XWD=159, AV_CODEC_ID_CDXL=160, AV_CODEC_ID_XBM=161, AV_CODEC_ID_ZEROCODEC=162, AV_CODEC_ID_MSS1=163, AV_CODEC_ID_MSA1=164, AV_CODEC_ID_TSCC2=165, AV_CODEC_ID_MTS2=166, AV_CODEC_ID_CLLC=167, AV_CODEC_ID_MSS2=168, AV_CODEC_ID_VP9=169, AV_CODEC_ID_AIC=170, AV_CODEC_ID_ESCAPE130_DEPRECATED=171, AV_CODEC_ID_G2M_DEPRECATED=172, AV_CODEC_ID_WEBP_DEPRECATED=173, AV_CODEC_ID_HNM4_VIDEO=174, AV_CODEC_ID_HEVC_DEPRECATED=175, AV_CODEC_ID_FIC=176, AV_CODEC_ID_ALIAS_PIX=177, AV_CODEC_ID_BRENDER_PIX_DEPRECATED=178, AV_CODEC_ID_PAF_VIDEO_DEPRECATED=179, AV_CODEC_ID_EXR_DEPRECATED=180, AV_CODEC_ID_VP7_DEPRECATED=181, AV_CODEC_ID_SANM_DEPRECATED=182, AV_CODEC_ID_SGIRLE_DEPRECATED=183, AV_CODEC_ID_MVC1_DEPRECATED=184, AV_CODEC_ID_MVC2_DEPRECATED=185, AV_CODEC_ID_HQX=186, AV_CODEC_ID_TDSC=187, AV_CODEC_ID_HQ_HQA=188, AV_CODEC_ID_HAP=189, AV_CODEC_ID_DDS=190, AV_CODEC_ID_BRENDER_PIX=1112557912, AV_CODEC_ID_Y41P=1496592720, AV_CODEC_ID_ESCAPE130=1160852272, AV_CODEC_ID_EXR=809850962, AV_CODEC_ID_AVRP=1096176208, AV_CODEC_ID_012V=808530518, AV_CODEC_ID_G2M=4665933, AV_CODEC_ID_AVUI=1096176969, AV_CODEC_ID_AYUV=1096373590, AV_CODEC_ID_TARGA_Y216=1412575542, AV_CODEC_ID_V308=1446195256, AV_CODEC_ID_V408=1446260792, AV_CODEC_ID_YUV4=1498764852, AV_CODEC_ID_SANM=1396788813, AV_CODEC_ID_PAF_VIDEO=1346455126, AV_CODEC_ID_AVRN=1096176238, AV_CODEC_ID_CPIA=1129335105, AV_CODEC_ID_XFACE=1480999235, AV_CODEC_ID_SGIRLE=1397180754, AV_CODEC_ID_MVC1=1297498929, AV_CODEC_ID_MVC2=1297498930, AV_CODEC_ID_SNOW=1397641047, AV_CODEC_ID_WEBP=1464156752, AV_CODEC_ID_SMVJPEG=1397577290, AV_CODEC_ID_HEVC=1211250229, AV_CODEC_ID_VP7=1448097584, AV_CODEC_ID_APNG=1095781959, AV_CODEC_ID_FIRST_AUDIO=65536, AV_CODEC_ID_PCM_S16LE=65536, AV_CODEC_ID_PCM_S16BE=65537, AV_CODEC_ID_PCM_U16LE=65538, AV_CODEC_ID_PCM_U16BE=65539, AV_CODEC_ID_PCM_S8=65540, AV_CODEC_ID_PCM_U8=65541, AV_CODEC_ID_PCM_MULAW=65542, AV_CODEC_ID_PCM_ALAW=65543, AV_CODEC_ID_PCM_S32LE=65544, AV_CODEC_ID_PCM_S32BE=65545, AV_CODEC_ID_PCM_U32LE=65546, AV_CODEC_ID_PCM_U32BE=65547, AV_CODEC_ID_PCM_S24LE=65548, AV_CODEC_ID_PCM_S24BE=65549, AV_CODEC_ID_PCM_U24LE=65550, AV_CODEC_ID_PCM_U24BE=65551, AV_CODEC_ID_PCM_S24DAUD=65552, AV_CODEC_ID_PCM_ZORK=65553, AV_CODEC_ID_PCM_S16LE_PLANAR=65554, AV_CODEC_ID_PCM_DVD=65555, AV_CODEC_ID_PCM_F32BE=65556, AV_CODEC_ID_PCM_F32LE=65557, AV_CODEC_ID_PCM_F64BE=65558, AV_CODEC_ID_PCM_F64LE=65559, AV_CODEC_ID_PCM_BLURAY=65560, AV_CODEC_ID_PCM_LXF=65561, AV_CODEC_ID_S302M=65562, AV_CODEC_ID_PCM_S8_PLANAR=65563, AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED=65564, AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED=65565, AV_CODEC_ID_PCM_S16BE_PLANAR_DEPRECATED=65566, AV_CODEC_ID_PCM_S24LE_PLANAR=407917392, AV_CODEC_ID_PCM_S32LE_PLANAR=542135120, AV_CODEC_ID_PCM_S16BE_PLANAR=1347637264, AV_CODEC_ID_ADPCM_IMA_QT=69632, AV_CODEC_ID_ADPCM_IMA_WAV=69633, AV_CODEC_ID_ADPCM_IMA_DK3=69634, AV_CODEC_ID_ADPCM_IMA_DK4=69635, AV_CODEC_ID_ADPCM_IMA_WS=69636, AV_CODEC_ID_ADPCM_IMA_SMJPEG=69637, AV_CODEC_ID_ADPCM_MS=69638, AV_CODEC_ID_ADPCM_4XM=69639, AV_CODEC_ID_ADPCM_XA=69640, AV_CODEC_ID_ADPCM_ADX=69641, AV_CODEC_ID_ADPCM_EA=69642, AV_CODEC_ID_ADPCM_G726=69643, AV_CODEC_ID_ADPCM_CT=69644, AV_CODEC_ID_ADPCM_SWF=69645, AV_CODEC_ID_ADPCM_YAMAHA=69646, AV_CODEC_ID_ADPCM_SBPRO_4=69647, AV_CODEC_ID_ADPCM_SBPRO_3=69648, AV_CODEC_ID_ADPCM_SBPRO_2=69649, AV_CODEC_ID_ADPCM_THP=69650, AV_CODEC_ID_ADPCM_IMA_AMV=69651, AV_CODEC_ID_ADPCM_EA_R1=69652, AV_CODEC_ID_ADPCM_EA_R3=69653, AV_CODEC_ID_ADPCM_EA_R2=69654, AV_CODEC_ID_ADPCM_IMA_EA_SEAD=69655, AV_CODEC_ID_ADPCM_IMA_EA_EACS=69656, AV_CODEC_ID_ADPCM_EA_XAS=69657, AV_CODEC_ID_ADPCM_EA_MAXIS_XA=69658, AV_CODEC_ID_ADPCM_IMA_ISS=69659, AV_CODEC_ID_ADPCM_G722=69660, AV_CODEC_ID_ADPCM_IMA_APC=69661, AV_CODEC_ID_ADPCM_VIMA_DEPRECATED=69662, AV_CODEC_ID_ADPCM_VIMA=1447644481, AV_CODEC_ID_VIMA=1447644481, AV_CODEC_ID_ADPCM_AFC=1095123744, AV_CODEC_ID_ADPCM_IMA_OKI=1330333984, AV_CODEC_ID_ADPCM_DTK=1146374944, AV_CODEC_ID_ADPCM_IMA_RAD=1380008992, AV_CODEC_ID_ADPCM_G726LE=909260615, AV_CODEC_ID_ADPCM_THP_LE=1414025292, AV_CODEC_ID_AMR_NB=73728, AV_CODEC_ID_AMR_WB=73729, AV_CODEC_ID_RA_144=77824, AV_CODEC_ID_RA_288=77825, AV_CODEC_ID_ROQ_DPCM=81920, AV_CODEC_ID_INTERPLAY_DPCM=81921, AV_CODEC_ID_XAN_DPCM=81922, AV_CODEC_ID_SOL_DPCM=81923, AV_CODEC_ID_MP2=86016, AV_CODEC_ID_MP3=86017, AV_CODEC_ID_AAC=86018, AV_CODEC_ID_AC3=86019, AV_CODEC_ID_DTS=86020, AV_CODEC_ID_VORBIS=86021, AV_CODEC_ID_DVAUDIO=86022, AV_CODEC_ID_WMAV1=86023, AV_CODEC_ID_WMAV2=86024, AV_CODEC_ID_MACE3=86025, AV_CODEC_ID_MACE6=86026, AV_CODEC_ID_VMDAUDIO=86027, AV_CODEC_ID_FLAC=86028, AV_CODEC_ID_MP3ADU=86029, AV_CODEC_ID_MP3ON4=86030, AV_CODEC_ID_SHORTEN=86031, AV_CODEC_ID_ALAC=86032, AV_CODEC_ID_WESTWOOD_SND1=86033, AV_CODEC_ID_GSM=86034, AV_CODEC_ID_QDM2=86035, AV_CODEC_ID_COOK=86036, AV_CODEC_ID_TRUESPEECH=86037, AV_CODEC_ID_TTA=86038, AV_CODEC_ID_SMACKAUDIO=86039, AV_CODEC_ID_QCELP=86040, AV_CODEC_ID_WAVPACK=86041, AV_CODEC_ID_DSICINAUDIO=86042, AV_CODEC_ID_IMC=86043, AV_CODEC_ID_MUSEPACK7=86044, AV_CODEC_ID_MLP=86045, AV_CODEC_ID_GSM_MS=86046, AV_CODEC_ID_ATRAC3=86047, AV_CODEC_ID_VOXWARE=86048, AV_CODEC_ID_APE=86049, AV_CODEC_ID_NELLYMOSER=86050, AV_CODEC_ID_MUSEPACK8=86051, AV_CODEC_ID_SPEEX=86052, AV_CODEC_ID_WMAVOICE=86053, AV_CODEC_ID_WMAPRO=86054, AV_CODEC_ID_WMALOSSLESS=86055, AV_CODEC_ID_ATRAC3P=86056, AV_CODEC_ID_EAC3=86057, AV_CODEC_ID_SIPR=86058, AV_CODEC_ID_MP1=86059, AV_CODEC_ID_TWINVQ=86060, AV_CODEC_ID_TRUEHD=86061, AV_CODEC_ID_MP4ALS=86062, AV_CODEC_ID_ATRAC1=86063, AV_CODEC_ID_BINKAUDIO_RDFT=86064, AV_CODEC_ID_BINKAUDIO_DCT=86065, AV_CODEC_ID_AAC_LATM=86066, AV_CODEC_ID_QDMC=86067, AV_CODEC_ID_CELT=86068, AV_CODEC_ID_G723_1=86069, AV_CODEC_ID_G729=86070, AV_CODEC_ID_8SVX_EXP=86071, AV_CODEC_ID_8SVX_FIB=86072, AV_CODEC_ID_BMV_AUDIO=86073, AV_CODEC_ID_RALF=86074, AV_CODEC_ID_IAC=86075, AV_CODEC_ID_ILBC=86076, AV_CODEC_ID_OPUS_DEPRECATED=86077, AV_CODEC_ID_COMFORT_NOISE=86078, AV_CODEC_ID_TAK_DEPRECATED=86079, AV_CODEC_ID_METASOUND=86080, AV_CODEC_ID_PAF_AUDIO_DEPRECATED=86081, AV_CODEC_ID_ON2AVC=86082, AV_CODEC_ID_DSS_SP=86083, AV_CODEC_ID_FFWAVESYNTH=1179014995, AV_CODEC_ID_SONIC=1397706307, AV_CODEC_ID_SONIC_LS=1397706316, AV_CODEC_ID_PAF_AUDIO=1346455105, AV_CODEC_ID_OPUS=1330664787, AV_CODEC_ID_TAK=1950507339, AV_CODEC_ID_EVRC=1936029283, AV_CODEC_ID_SMV=1936944502, AV_CODEC_ID_DSD_LSBF=1146307660, AV_CODEC_ID_DSD_MSBF=1146307661, AV_CODEC_ID_DSD_LSBF_PLANAR=1146307633, AV_CODEC_ID_DSD_MSBF_PLANAR=1146307640, AV_CODEC_ID_4GV=1932814198, AV_CODEC_ID_FIRST_SUBTITLE=94208, AV_CODEC_ID_DVD_SUBTITLE=94208, AV_CODEC_ID_DVB_SUBTITLE=94209, AV_CODEC_ID_TEXT=94210, AV_CODEC_ID_XSUB=94211, AV_CODEC_ID_SSA=94212, AV_CODEC_ID_MOV_TEXT=94213, AV_CODEC_ID_HDMV_PGS_SUBTITLE=94214, AV_CODEC_ID_DVB_TELETEXT=94215, AV_CODEC_ID_SRT=94216, AV_CODEC_ID_MICRODVD=1833195076, AV_CODEC_ID_EIA_608=1664495672, AV_CODEC_ID_JACOSUB=1246975298, AV_CODEC_ID_SAMI=1396788553, AV_CODEC_ID_REALTEXT=1381259348, AV_CODEC_ID_STL=1399870540, AV_CODEC_ID_SUBVIEWER1=1398953521, AV_CODEC_ID_SUBVIEWER=1400201814, AV_CODEC_ID_SUBRIP=1397909872, AV_CODEC_ID_WEBVTT=1465275476, AV_CODEC_ID_MPL2=1297108018, AV_CODEC_ID_VPLAYER=1448111218, AV_CODEC_ID_PJS=1349012051, AV_CODEC_ID_ASS=1095979808, AV_CODEC_ID_HDMV_TEXT_SUBTITLE=1111774296, AV_CODEC_ID_FIRST_UNKNOWN=98304, AV_CODEC_ID_TTF=98304, AV_CODEC_ID_BINTEXT=1112823892, AV_CODEC_ID_XBIN=1480739150, AV_CODEC_ID_IDF=4801606, AV_CODEC_ID_OTF=5198918, AV_CODEC_ID_SMPTE_KLV=1263294017, AV_CODEC_ID_DVD_NAV=1145979222, AV_CODEC_ID_TIMED_ID3=1414087731, AV_CODEC_ID_BIN_DATA=1145132097, AV_CODEC_ID_PROBE=102400, AV_CODEC_ID_MPEG2TS=131072, AV_CODEC_ID_MPEG4SYSTEMS=131073, AV_CODEC_ID_FFMETADATA=135168, CODEC_ID_NONE=0, CODEC_ID_MPEG1VIDEO=1, CODEC_ID_MPEG2VIDEO=2, CODEC_ID_MPEG2VIDEO_XVMC=3, CODEC_ID_H261=4, CODEC_ID_H263=5, CODEC_ID_RV10=6, CODEC_ID_RV20=7, CODEC_ID_MJPEG=8, CODEC_ID_MJPEGB=9, CODEC_ID_LJPEG=10, CODEC_ID_SP5X=11, CODEC_ID_JPEGLS=12, CODEC_ID_MPEG4=13, CODEC_ID_RAWVIDEO=14, CODEC_ID_MSMPEG4V1=15, CODEC_ID_MSMPEG4V2=16, CODEC_ID_MSMPEG4V3=17, CODEC_ID_WMV1=18, CODEC_ID_WMV2=19, CODEC_ID_H263P=20, CODEC_ID_H263I=21, CODEC_ID_FLV1=22, CODEC_ID_SVQ1=23, CODEC_ID_SVQ3=24, CODEC_ID_DVVIDEO=25, CODEC_ID_HUFFYUV=26, CODEC_ID_CYUV=27, CODEC_ID_H264=28, CODEC_ID_INDEO3=29, CODEC_ID_VP3=30, CODEC_ID_THEORA=31, CODEC_ID_ASV1=32, CODEC_ID_ASV2=33, CODEC_ID_FFV1=34, CODEC_ID_4XM=35, CODEC_ID_VCR1=36, CODEC_ID_CLJR=37, CODEC_ID_MDEC=38, CODEC_ID_ROQ=39, CODEC_ID_INTERPLAY_VIDEO=40, CODEC_ID_XAN_WC3=41, CODEC_ID_XAN_WC4=42, CODEC_ID_RPZA=43, CODEC_ID_CINEPAK=44, CODEC_ID_WS_VQA=45, CODEC_ID_MSRLE=46, CODEC_ID_MSVIDEO1=47, CODEC_ID_IDCIN=48, CODEC_ID_8BPS=49, CODEC_ID_SMC=50, CODEC_ID_FLIC=51, CODEC_ID_TRUEMOTION1=52, CODEC_ID_VMDVIDEO=53, CODEC_ID_MSZH=54, CODEC_ID_ZLIB=55, CODEC_ID_QTRLE=56, CODEC_ID_TSCC=57, CODEC_ID_ULTI=58, CODEC_ID_QDRAW=59, CODEC_ID_VIXL=60, CODEC_ID_QPEG=61, CODEC_ID_PNG=62, CODEC_ID_PPM=63, CODEC_ID_PBM=64, CODEC_ID_PGM=65, CODEC_ID_PGMYUV=66, CODEC_ID_PAM=67, CODEC_ID_FFVHUFF=68, CODEC_ID_RV30=69, CODEC_ID_RV40=70, CODEC_ID_VC1=71, CODEC_ID_WMV3=72, CODEC_ID_LOCO=73, CODEC_ID_WNV1=74, CODEC_ID_AASC=75, CODEC_ID_INDEO2=76, CODEC_ID_FRAPS=77, CODEC_ID_TRUEMOTION2=78, CODEC_ID_BMP=79, CODEC_ID_CSCD=80, CODEC_ID_MMVIDEO=81, CODEC_ID_ZMBV=82, CODEC_ID_AVS=83, CODEC_ID_SMACKVIDEO=84, CODEC_ID_NUV=85, CODEC_ID_KMVC=86, CODEC_ID_FLASHSV=87, CODEC_ID_CAVS=88, CODEC_ID_JPEG2000=89, CODEC_ID_VMNC=90, CODEC_ID_VP5=91, CODEC_ID_VP6=92, CODEC_ID_VP6F=93, CODEC_ID_TARGA=94, CODEC_ID_DSICINVIDEO=95, CODEC_ID_TIERTEXSEQVIDEO=96, CODEC_ID_TIFF=97, CODEC_ID_GIF=98, CODEC_ID_DXA=99, CODEC_ID_DNXHD=100, CODEC_ID_THP=101, CODEC_ID_SGI=102, CODEC_ID_C93=103, CODEC_ID_BETHSOFTVID=104, CODEC_ID_PTX=105, CODEC_ID_TXD=106, CODEC_ID_VP6A=107, CODEC_ID_AMV=108, CODEC_ID_VB=109, CODEC_ID_PCX=110, CODEC_ID_SUNRAST=111, CODEC_ID_INDEO4=112, CODEC_ID_INDEO5=113, CODEC_ID_MIMIC=114, CODEC_ID_RL2=115, CODEC_ID_ESCAPE124=116, CODEC_ID_DIRAC=117, CODEC_ID_BFI=118, CODEC_ID_CMV=119, CODEC_ID_MOTIONPIXELS=120, CODEC_ID_TGV=121, CODEC_ID_TGQ=122, CODEC_ID_TQI=123, CODEC_ID_AURA=124, CODEC_ID_AURA2=125, CODEC_ID_V210X=126, CODEC_ID_TMV=127, CODEC_ID_V210=128, CODEC_ID_DPX=129, CODEC_ID_MAD=130, CODEC_ID_FRWU=131, CODEC_ID_FLASHSV2=132, CODEC_ID_CDGRAPHICS=133, CODEC_ID_R210=134, CODEC_ID_ANM=135, CODEC_ID_BINKVIDEO=136, CODEC_ID_IFF_ILBM=137, CODEC_ID_IFF_BYTERUN1=138, CODEC_ID_KGV1=139, CODEC_ID_YOP=140, CODEC_ID_VP8=141, CODEC_ID_PICTOR=142, CODEC_ID_ANSI=143, CODEC_ID_A64_MULTI=144, CODEC_ID_A64_MULTI5=145, CODEC_ID_R10K=146, CODEC_ID_MXPEG=147, CODEC_ID_LAGARITH=148, CODEC_ID_PRORES=149, CODEC_ID_JV=150, CODEC_ID_DFA=151, CODEC_ID_WMV3IMAGE=152, CODEC_ID_VC1IMAGE=153, CODEC_ID_UTVIDEO=154, CODEC_ID_BMV_VIDEO=155, CODEC_ID_VBLE=156, CODEC_ID_DXTORY=157, CODEC_ID_V410=158, CODEC_ID_XWD=159, CODEC_ID_CDXL=160, CODEC_ID_XBM=161, CODEC_ID_ZEROCODEC=162, CODEC_ID_MSS1=163, CODEC_ID_MSA1=164, CODEC_ID_TSCC2=165, CODEC_ID_MTS2=166, CODEC_ID_CLLC=167, CODEC_ID_Y41P=1496592720, CODEC_ID_ESCAPE130=1160852272, CODEC_ID_EXR=809850962, CODEC_ID_AVRP=1096176208, CODEC_ID_G2M=4665933, CODEC_ID_AVUI=1096176969, CODEC_ID_AYUV=1096373590, CODEC_ID_V308=1446195256, CODEC_ID_V408=1446260792, CODEC_ID_YUV4=1498764852, CODEC_ID_SANM=1396788813, CODEC_ID_PAF_VIDEO=1346455126, CODEC_ID_SNOW=1397641047, CODEC_ID_FIRST_AUDIO=65536, CODEC_ID_PCM_S16LE=65536, CODEC_ID_PCM_S16BE=65537, CODEC_ID_PCM_U16LE=65538, CODEC_ID_PCM_U16BE=65539, CODEC_ID_PCM_S8=65540, CODEC_ID_PCM_U8=65541, CODEC_ID_PCM_MULAW=65542, CODEC_ID_PCM_ALAW=65543, CODEC_ID_PCM_S32LE=65544, CODEC_ID_PCM_S32BE=65545, CODEC_ID_PCM_U32LE=65546, CODEC_ID_PCM_U32BE=65547, CODEC_ID_PCM_S24LE=65548, CODEC_ID_PCM_S24BE=65549, CODEC_ID_PCM_U24LE=65550, CODEC_ID_PCM_U24BE=65551, CODEC_ID_PCM_S24DAUD=65552, CODEC_ID_PCM_ZORK=65553, CODEC_ID_PCM_S16LE_PLANAR=65554, CODEC_ID_PCM_DVD=65555, CODEC_ID_PCM_F32BE=65556, CODEC_ID_PCM_F32LE=65557, CODEC_ID_PCM_F64BE=65558, CODEC_ID_PCM_F64LE=65559, CODEC_ID_PCM_BLURAY=65560, CODEC_ID_PCM_LXF=65561, CODEC_ID_S302M=65562, CODEC_ID_PCM_S8_PLANAR=65563, CODEC_ID_ADPCM_IMA_QT=69632, CODEC_ID_ADPCM_IMA_WAV=69633, CODEC_ID_ADPCM_IMA_DK3=69634, CODEC_ID_ADPCM_IMA_DK4=69635, CODEC_ID_ADPCM_IMA_WS=69636, CODEC_ID_ADPCM_IMA_SMJPEG=69637, CODEC_ID_ADPCM_MS=69638, CODEC_ID_ADPCM_4XM=69639, CODEC_ID_ADPCM_XA=69640, CODEC_ID_ADPCM_ADX=69641, CODEC_ID_ADPCM_EA=69642, CODEC_ID_ADPCM_G726=69643, CODEC_ID_ADPCM_CT=69644, CODEC_ID_ADPCM_SWF=69645, CODEC_ID_ADPCM_YAMAHA=69646, CODEC_ID_ADPCM_SBPRO_4=69647, CODEC_ID_ADPCM_SBPRO_3=69648, CODEC_ID_ADPCM_SBPRO_2=69649, CODEC_ID_ADPCM_THP=69650, CODEC_ID_ADPCM_IMA_AMV=69651, CODEC_ID_ADPCM_EA_R1=69652, CODEC_ID_ADPCM_EA_R3=69653, CODEC_ID_ADPCM_EA_R2=69654, CODEC_ID_ADPCM_IMA_EA_SEAD=69655, CODEC_ID_ADPCM_IMA_EA_EACS=69656, CODEC_ID_ADPCM_EA_XAS=69657, CODEC_ID_ADPCM_EA_MAXIS_XA=69658, CODEC_ID_ADPCM_IMA_ISS=69659, CODEC_ID_ADPCM_G722=69660, CODEC_ID_ADPCM_IMA_APC=69661, CODEC_ID_VIMA=1447644481, CODEC_ID_AMR_NB=73728, CODEC_ID_AMR_WB=73729, CODEC_ID_RA_144=77824, CODEC_ID_RA_288=77825, CODEC_ID_ROQ_DPCM=81920, CODEC_ID_INTERPLAY_DPCM=81921, CODEC_ID_XAN_DPCM=81922, CODEC_ID_SOL_DPCM=81923, CODEC_ID_MP2=86016, CODEC_ID_MP3=86017, CODEC_ID_AAC=86018, CODEC_ID_AC3=86019, CODEC_ID_DTS=86020, CODEC_ID_VORBIS=86021, CODEC_ID_DVAUDIO=86022, CODEC_ID_WMAV1=86023, CODEC_ID_WMAV2=86024, CODEC_ID_MACE3=86025, CODEC_ID_MACE6=86026, CODEC_ID_VMDAUDIO=86027, CODEC_ID_FLAC=86028, CODEC_ID_MP3ADU=86029, CODEC_ID_MP3ON4=86030, CODEC_ID_SHORTEN=86031, CODEC_ID_ALAC=86032, CODEC_ID_WESTWOOD_SND1=86033, CODEC_ID_GSM=86034, CODEC_ID_QDM2=86035, CODEC_ID_COOK=86036, CODEC_ID_TRUESPEECH=86037, CODEC_ID_TTA=86038, CODEC_ID_SMACKAUDIO=86039, CODEC_ID_QCELP=86040, CODEC_ID_WAVPACK=86041, CODEC_ID_DSICINAUDIO=86042, CODEC_ID_IMC=86043, CODEC_ID_MUSEPACK7=86044, CODEC_ID_MLP=86045, CODEC_ID_GSM_MS=86046, CODEC_ID_ATRAC3=86047, CODEC_ID_VOXWARE=86048, CODEC_ID_APE=86049, CODEC_ID_NELLYMOSER=86050, CODEC_ID_MUSEPACK8=86051, CODEC_ID_SPEEX=86052, CODEC_ID_WMAVOICE=86053, CODEC_ID_WMAPRO=86054, CODEC_ID_WMALOSSLESS=86055, CODEC_ID_ATRAC3P=86056, CODEC_ID_EAC3=86057, CODEC_ID_SIPR=86058, CODEC_ID_MP1=86059, CODEC_ID_TWINVQ=86060, CODEC_ID_TRUEHD=86061, CODEC_ID_MP4ALS=86062, CODEC_ID_ATRAC1=86063, CODEC_ID_BINKAUDIO_RDFT=86064, CODEC_ID_BINKAUDIO_DCT=86065, CODEC_ID_AAC_LATM=86066, CODEC_ID_QDMC=86067, CODEC_ID_CELT=86068, CODEC_ID_G723_1=86069, CODEC_ID_G729=86070, CODEC_ID_8SVX_EXP=86071, CODEC_ID_8SVX_FIB=86072, CODEC_ID_BMV_AUDIO=86073, CODEC_ID_RALF=86074, CODEC_ID_IAC=86075, CODEC_ID_ILBC=86076, CODEC_ID_FFWAVESYNTH=1179014995, CODEC_ID_SONIC=1397706307, CODEC_ID_SONIC_LS=1397706316, CODEC_ID_PAF_AUDIO=1346455105, CODEC_ID_OPUS=1330664787, CODEC_ID_FIRST_SUBTITLE=94208, CODEC_ID_DVD_SUBTITLE=94208, CODEC_ID_DVB_SUBTITLE=94209, CODEC_ID_TEXT=94210, CODEC_ID_XSUB=94211, CODEC_ID_SSA=94212, CODEC_ID_MOV_TEXT=94213, CODEC_ID_HDMV_PGS_SUBTITLE=94214, CODEC_ID_DVB_TELETEXT=94215, CODEC_ID_SRT=94216, CODEC_ID_MICRODVD=1833195076, CODEC_ID_EIA_608=1664495672, CODEC_ID_JACOSUB=1246975298, CODEC_ID_SAMI=1396788553, CODEC_ID_REALTEXT=1381259348, CODEC_ID_SUBVIEWER=1400201814, CODEC_ID_FIRST_UNKNOWN=98304, CODEC_ID_TTF=98304, CODEC_ID_BINTEXT=1112823892, CODEC_ID_XBIN=1480739150, CODEC_ID_IDF=4801606, CODEC_ID_OTF=5198918, CODEC_ID_PROBE=102400, CODEC_ID_MPEG2TS=131072, CODEC_ID_MPEG4SYSTEMS=131073, CODEC_ID_FFMETADATA=135168 };

// tag-AVCodecInternal
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1482
struct AVCodecInternal;

// tag-AVCodecParser
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4541
struct AVCodecParser;

// tag-AVCodecParserContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4539
struct AVCodecParserContext;

// tag-AVCodecTag
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 455
struct AVCodecTag;

// tag-AVColorPrimaries
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 476
enum AVColorPrimaries { AVCOL_PRI_RESERVED0=0, AVCOL_PRI_BT709=1, AVCOL_PRI_UNSPECIFIED=2, AVCOL_PRI_RESERVED=3, AVCOL_PRI_BT470M=4, AVCOL_PRI_BT470BG=5, AVCOL_PRI_SMPTE170M=6, AVCOL_PRI_SMPTE240M=7, AVCOL_PRI_FILM=8, AVCOL_PRI_BT2020=9, AVCOL_PRI_NB=10 };

// tag-AVColorRange
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 537
enum AVColorRange { AVCOL_RANGE_UNSPECIFIED=0, AVCOL_RANGE_MPEG=1, AVCOL_RANGE_JPEG=2, AVCOL_RANGE_NB=3 };

// tag-AVColorSpace
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 517
enum AVColorSpace { AVCOL_SPC_RGB=0, AVCOL_SPC_BT709=1, AVCOL_SPC_UNSPECIFIED=2, AVCOL_SPC_RESERVED=3, AVCOL_SPC_FCC=4, AVCOL_SPC_BT470BG=5, AVCOL_SPC_SMPTE170M=6, AVCOL_SPC_SMPTE240M=7, AVCOL_SPC_YCOCG=8, AVCOL_SPC_BT2020_NCL=9, AVCOL_SPC_BT2020_CL=10, AVCOL_SPC_NB=11 };

// tag-AVColorTransferCharacteristic
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 494
enum AVColorTransferCharacteristic { AVCOL_TRC_RESERVED0=0, AVCOL_TRC_BT709=1, AVCOL_TRC_UNSPECIFIED=2, AVCOL_TRC_RESERVED=3, AVCOL_TRC_GAMMA22=4, AVCOL_TRC_GAMMA28=5, AVCOL_TRC_SMPTE170M=6, AVCOL_TRC_SMPTE240M=7, AVCOL_TRC_LINEAR=8, AVCOL_TRC_LOG=9, AVCOL_TRC_LOG_SQRT=10, AVCOL_TRC_IEC61966_2_4=11, AVCOL_TRC_BT1361_ECG=12, AVCOL_TRC_IEC61966_2_1=13, AVCOL_TRC_BT2020_10=14, AVCOL_TRC_BT2020_12=15, AVCOL_TRC_NB=16 };

// tag-AVDeviceCapabilitiesQuery
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 328
struct AVDeviceCapabilitiesQuery;

// tag-AVDeviceInfoList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 327
struct AVDeviceInfoList;

// tag-AVDictionary
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 87
struct AVDictionary;

// tag-AVDiscard
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 680
enum AVDiscard { AVDISCARD_NONE=-16, AVDISCARD_DEFAULT=0, AVDISCARD_NONREF=8, AVDISCARD_BIDIR=16, AVDISCARD_NONINTRA=24, AVDISCARD_NONKEY=32, AVDISCARD_ALL=48 };

// tag-AVDurationEstimationMethod
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1260
enum AVDurationEstimationMethod { AVFMT_DURATION_FROM_PTS=0, AVFMT_DURATION_FROM_STREAM=1, AVFMT_DURATION_FROM_BITRATE=2 };

// tag-AVFieldOrder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1484
enum AVFieldOrder { AV_FIELD_UNKNOWN=0, AV_FIELD_PROGRESSIVE=1, AV_FIELD_TT=2, AV_FIELD_BB=3, AV_FIELD_TB=4, AV_FIELD_BT=5 };

// tag-AVFilter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 470
struct AVFilter;

// tag-AVFilterBuffer
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 75
struct AVFilterBuffer;

// tag-AVFilterBufferRef
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 158
struct AVFilterBufferRef;

// tag-AVFilterBufferRefAudioProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 125
struct AVFilterBufferRefAudioProps;

// tag-AVFilterBufferRefVideoProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 137
struct AVFilterBufferRefVideoProps;

// tag-AVFilterChannelLayouts
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 747
struct AVFilterChannelLayouts;

// tag-AVFilterCommand
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 681
struct AVFilterCommand;

// tag-AVFilterContext
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 64
struct AVFilterContext;

// tag-AVFilterFormats
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 67
struct AVFilterFormats;

// tag-AVFilterGraph
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 656
struct AVFilterGraph;

// tag-AVFilterGraphInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1140
struct AVFilterGraphInternal;

// tag-AVFilterInOut
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1355
struct AVFilterInOut;

// tag-AVFilterInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 630
struct AVFilterInternal;

// tag-AVFilterLink
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 65
struct AVFilterLink;

// tag-AVFilterPad
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 66
struct AVFilterPad;

// tag-AVFilterPool
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 767
struct AVFilterPool;

// tag-AVFormatContext
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 325
struct AVFormatContext;

// tag-AVFormatInternal
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1266
struct AVFormatInternal;

// tag-AVFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 447
struct AVFrac;

// tag-AVFrame
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 171
struct AVFrame;

// tag-AVFrameSideData
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 134
struct AVFrameSideData;

// tag-AVFrameSideDataType
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 48
enum AVFrameSideDataType { AV_FRAME_DATA_PANSCAN=0, AV_FRAME_DATA_A53_CC=1, AV_FRAME_DATA_STEREO3D=2, AV_FRAME_DATA_MATRIXENCODING=3, AV_FRAME_DATA_DOWNMIX_INFO=4, AV_FRAME_DATA_REPLAYGAIN=5, AV_FRAME_DATA_DISPLAYMATRIX=6, AV_FRAME_DATA_AFD=7, AV_FRAME_DATA_MOTION_VECTORS=8, AV_FRAME_DATA_SKIP_SAMPLES=9, AV_FRAME_DATA_AUDIO_SERVICE_TYPE=10 };

// tag-AVHWAccel
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 2922
struct AVHWAccel;

// tag-AVIOContext
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 111
struct AVIOContext;

// tag-AVIOInterruptCB
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 50
struct AVIOInterruptCB;

// tag-AVIndexEntry
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 787
struct AVIndexEntry;

// tag-AVInputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 627
struct AVInputFormat;

// tag-AVMediaType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 191
enum AVMediaType { AVMEDIA_TYPE_UNKNOWN=-1, AVMEDIA_TYPE_VIDEO=0, AVMEDIA_TYPE_AUDIO=1, AVMEDIA_TYPE_DATA=2, AVMEDIA_TYPE_SUBTITLE=3, AVMEDIA_TYPE_ATTACHMENT=4, AVMEDIA_TYPE_NB=5 };

// tag-AVOption
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 85
const struct AVOption;

// tag-AVOptionRanges
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 60
struct AVOptionRanges;

// tag-AVOutputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 516
struct AVOutputFormat;

// tag-AVPacket
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1400
struct AVPacket;

// tag-AVPacketList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1044
struct AVPacketList;

// tag-AVPacketSideData
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1372
struct AVPacketSideData;

// tag-AVPacketSideDataType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1224
enum AVPacketSideDataType { AV_PKT_DATA_PALETTE=0, AV_PKT_DATA_NEW_EXTRADATA=1, AV_PKT_DATA_PARAM_CHANGE=2, AV_PKT_DATA_H263_MB_INFO=3, AV_PKT_DATA_REPLAYGAIN=4, AV_PKT_DATA_DISPLAYMATRIX=5, AV_PKT_DATA_STEREO3D=6, AV_PKT_DATA_AUDIO_SERVICE_TYPE=7, AV_PKT_DATA_QUALITY_STATS=8, AV_PKT_DATA_SKIP_SAMPLES=70, AV_PKT_DATA_JP_DUALMONO=71, AV_PKT_DATA_STRINGS_METADATA=72, AV_PKT_DATA_SUBTITLE_POSITION=73, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL=74, AV_PKT_DATA_WEBVTT_IDENTIFIER=75, AV_PKT_DATA_WEBVTT_SETTINGS=76, AV_PKT_DATA_METADATA_UPDATE=77 };

// tag-AVPanScan
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 387
struct AVPanScan;

// tag-AVPicture
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3744
struct AVPicture;

// tag-AVPictureStructure
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4532
enum AVPictureStructure { AV_PICTURE_STRUCTURE_UNKNOWN=0, AV_PICTURE_STRUCTURE_TOP_FIELD=1, AV_PICTURE_STRUCTURE_BOTTOM_FIELD=2, AV_PICTURE_STRUCTURE_FRAME=3 };

// tag-AVPictureType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 264
enum AVPictureType { AV_PICTURE_TYPE_NONE=0, AV_PICTURE_TYPE_I=1, AV_PICTURE_TYPE_P=2, AV_PICTURE_TYPE_B=3, AV_PICTURE_TYPE_S=4, AV_PICTURE_TYPE_SI=5, AV_PICTURE_TYPE_SP=6, AV_PICTURE_TYPE_BI=7 };

// tag-AVPixelFormat
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 61
enum AVPixelFormat { AV_PIX_FMT_NONE=-1, AV_PIX_FMT_YUV420P=0, AV_PIX_FMT_YUYV422=1, AV_PIX_FMT_RGB24=2, AV_PIX_FMT_BGR24=3, AV_PIX_FMT_YUV422P=4, AV_PIX_FMT_YUV444P=5, AV_PIX_FMT_YUV410P=6, AV_PIX_FMT_YUV411P=7, AV_PIX_FMT_GRAY8=8, AV_PIX_FMT_MONOWHITE=9, AV_PIX_FMT_MONOBLACK=10, AV_PIX_FMT_PAL8=11, AV_PIX_FMT_YUVJ420P=12, AV_PIX_FMT_YUVJ422P=13, AV_PIX_FMT_YUVJ444P=14, AV_PIX_FMT_XVMC_MPEG2_MC=15, AV_PIX_FMT_XVMC_MPEG2_IDCT=16, AV_PIX_FMT_UYVY422=17, AV_PIX_FMT_UYYVYY411=18, AV_PIX_FMT_BGR8=19, AV_PIX_FMT_BGR4=20, AV_PIX_FMT_BGR4_BYTE=21, AV_PIX_FMT_RGB8=22, AV_PIX_FMT_RGB4=23, AV_PIX_FMT_RGB4_BYTE=24, AV_PIX_FMT_NV12=25, AV_PIX_FMT_NV21=26, AV_PIX_FMT_ARGB=27, AV_PIX_FMT_RGBA=28, AV_PIX_FMT_ABGR=29, AV_PIX_FMT_BGRA=30, AV_PIX_FMT_GRAY16BE=31, AV_PIX_FMT_GRAY16LE=32, AV_PIX_FMT_YUV440P=33, AV_PIX_FMT_YUVJ440P=34, AV_PIX_FMT_YUVA420P=35, AV_PIX_FMT_VDPAU_H264=36, AV_PIX_FMT_VDPAU_MPEG1=37, AV_PIX_FMT_VDPAU_MPEG2=38, AV_PIX_FMT_VDPAU_WMV3=39, AV_PIX_FMT_VDPAU_VC1=40, AV_PIX_FMT_RGB48BE=41, AV_PIX_FMT_RGB48LE=42, AV_PIX_FMT_RGB565BE=43, AV_PIX_FMT_RGB565LE=44, AV_PIX_FMT_RGB555BE=45, AV_PIX_FMT_RGB555LE=46, AV_PIX_FMT_BGR565BE=47, AV_PIX_FMT_BGR565LE=48, AV_PIX_FMT_BGR555BE=49, AV_PIX_FMT_BGR555LE=50, AV_PIX_FMT_VAAPI_MOCO=51, AV_PIX_FMT_VAAPI_IDCT=52, AV_PIX_FMT_VAAPI_VLD=53, AV_PIX_FMT_VAAPI=53, AV_PIX_FMT_YUV420P16LE=54, AV_PIX_FMT_YUV420P16BE=55, AV_PIX_FMT_YUV422P16LE=56, AV_PIX_FMT_YUV422P16BE=57, AV_PIX_FMT_YUV444P16LE=58, AV_PIX_FMT_YUV444P16BE=59, AV_PIX_FMT_VDPAU_MPEG4=60, AV_PIX_FMT_DXVA2_VLD=61, AV_PIX_FMT_RGB444LE=62, AV_PIX_FMT_RGB444BE=63, AV_PIX_FMT_BGR444LE=64, AV_PIX_FMT_BGR444BE=65, AV_PIX_FMT_YA8=66, AV_PIX_FMT_Y400A=66, AV_PIX_FMT_GRAY8A=66, AV_PIX_FMT_BGR48BE=67, AV_PIX_FMT_BGR48LE=68, AV_PIX_FMT_YUV420P9BE=69, AV_PIX_FMT_YUV420P9LE=70, AV_PIX_FMT_YUV420P10BE=71, AV_PIX_FMT_YUV420P10LE=72, AV_PIX_FMT_YUV422P10BE=73, AV_PIX_FMT_YUV422P10LE=74, AV_PIX_FMT_YUV444P9BE=75, AV_PIX_FMT_YUV444P9LE=76, AV_PIX_FMT_YUV444P10BE=77, AV_PIX_FMT_YUV444P10LE=78, AV_PIX_FMT_YUV422P9BE=79, AV_PIX_FMT_YUV422P9LE=80, AV_PIX_FMT_VDA_VLD=81, AV_PIX_FMT_GBRP=82, AV_PIX_FMT_GBRP9BE=83, AV_PIX_FMT_GBRP9LE=84, AV_PIX_FMT_GBRP10BE=85, AV_PIX_FMT_GBRP10LE=86, AV_PIX_FMT_GBRP16BE=87, AV_PIX_FMT_GBRP16LE=88, AV_PIX_FMT_YUVA422P_LIBAV=89, AV_PIX_FMT_YUVA444P_LIBAV=90, AV_PIX_FMT_YUVA420P9BE=91, AV_PIX_FMT_YUVA420P9LE=92, AV_PIX_FMT_YUVA422P9BE=93, AV_PIX_FMT_YUVA422P9LE=94, AV_PIX_FMT_YUVA444P9BE=95, AV_PIX_FMT_YUVA444P9LE=96, AV_PIX_FMT_YUVA420P10BE=97, AV_PIX_FMT_YUVA420P10LE=98, AV_PIX_FMT_YUVA422P10BE=99, AV_PIX_FMT_YUVA422P10LE=100, AV_PIX_FMT_YUVA444P10BE=101, AV_PIX_FMT_YUVA444P10LE=102, AV_PIX_FMT_YUVA420P16BE=103, AV_PIX_FMT_YUVA420P16LE=104, AV_PIX_FMT_YUVA422P16BE=105, AV_PIX_FMT_YUVA422P16LE=106, AV_PIX_FMT_YUVA444P16BE=107, AV_PIX_FMT_YUVA444P16LE=108, AV_PIX_FMT_VDPAU=109, AV_PIX_FMT_XYZ12LE=110, AV_PIX_FMT_XYZ12BE=111, AV_PIX_FMT_NV16=112, AV_PIX_FMT_NV20LE=113, AV_PIX_FMT_NV20BE=114, AV_PIX_FMT_RGBA64BE_LIBAV=115, AV_PIX_FMT_RGBA64LE_LIBAV=116, AV_PIX_FMT_BGRA64BE_LIBAV=117, AV_PIX_FMT_BGRA64LE_LIBAV=118, AV_PIX_FMT_YVYU422=119, AV_PIX_FMT_VDA=120, AV_PIX_FMT_YA16BE=121, AV_PIX_FMT_YA16LE=122, AV_PIX_FMT_GBRAP_LIBAV=123, AV_PIX_FMT_GBRAP16BE_LIBAV=124, AV_PIX_FMT_GBRAP16LE_LIBAV=125, AV_PIX_FMT_QSV=126, AV_PIX_FMT_MMAL=127, AV_PIX_FMT_D3D11VA_VLD=128, AV_PIX_FMT_RGBA64BE=291, AV_PIX_FMT_RGBA64LE=292, AV_PIX_FMT_BGRA64BE=293, AV_PIX_FMT_BGRA64LE=294, AV_PIX_FMT_0RGB=295, AV_PIX_FMT_RGB0=296, AV_PIX_FMT_0BGR=297, AV_PIX_FMT_BGR0=298, AV_PIX_FMT_YUVA444P=299, AV_PIX_FMT_YUVA422P=300, AV_PIX_FMT_YUV420P12BE=301, AV_PIX_FMT_YUV420P12LE=302, AV_PIX_FMT_YUV420P14BE=303, AV_PIX_FMT_YUV420P14LE=304, AV_PIX_FMT_YUV422P12BE=305, AV_PIX_FMT_YUV422P12LE=306, AV_PIX_FMT_YUV422P14BE=307, AV_PIX_FMT_YUV422P14LE=308, AV_PIX_FMT_YUV444P12BE=309, AV_PIX_FMT_YUV444P12LE=310, AV_PIX_FMT_YUV444P14BE=311, AV_PIX_FMT_YUV444P14LE=312, AV_PIX_FMT_GBRP12BE=313, AV_PIX_FMT_GBRP12LE=314, AV_PIX_FMT_GBRP14BE=315, AV_PIX_FMT_GBRP14LE=316, AV_PIX_FMT_GBRAP=317, AV_PIX_FMT_GBRAP16BE=318, AV_PIX_FMT_GBRAP16LE=319, AV_PIX_FMT_YUVJ411P=320, AV_PIX_FMT_BAYER_BGGR8=321, AV_PIX_FMT_BAYER_RGGB8=322, AV_PIX_FMT_BAYER_GBRG8=323, AV_PIX_FMT_BAYER_GRBG8=324, AV_PIX_FMT_BAYER_BGGR16LE=325, AV_PIX_FMT_BAYER_BGGR16BE=326, AV_PIX_FMT_BAYER_RGGB16LE=327, AV_PIX_FMT_BAYER_RGGB16BE=328, AV_PIX_FMT_BAYER_GBRG16LE=329, AV_PIX_FMT_BAYER_GBRG16BE=330, AV_PIX_FMT_BAYER_GRBG16LE=331, AV_PIX_FMT_BAYER_GRBG16BE=332, AV_PIX_FMT_YUV440P10LE=333, AV_PIX_FMT_YUV440P10BE=334, AV_PIX_FMT_YUV440P12LE=335, AV_PIX_FMT_YUV440P12BE=336, AV_PIX_FMT_AYUV64LE=337, AV_PIX_FMT_AYUV64BE=338, AV_PIX_FMT_VIDEOTOOLBOX=339, AV_PIX_FMT_NB=340, PIX_FMT_NONE=-1, PIX_FMT_YUV420P=0, PIX_FMT_YUYV422=1, PIX_FMT_RGB24=2, PIX_FMT_BGR24=3, PIX_FMT_YUV422P=4, PIX_FMT_YUV444P=5, PIX_FMT_YUV410P=6, PIX_FMT_YUV411P=7, PIX_FMT_GRAY8=8, PIX_FMT_MONOWHITE=9, PIX_FMT_MONOBLACK=10, PIX_FMT_PAL8=11, PIX_FMT_YUVJ420P=12, PIX_FMT_YUVJ422P=13, PIX_FMT_YUVJ444P=14, PIX_FMT_XVMC_MPEG2_MC=15, PIX_FMT_XVMC_MPEG2_IDCT=16, PIX_FMT_UYVY422=17, PIX_FMT_UYYVYY411=18, PIX_FMT_BGR8=19, PIX_FMT_BGR4=20, PIX_FMT_BGR4_BYTE=21, PIX_FMT_RGB8=22, PIX_FMT_RGB4=23, PIX_FMT_RGB4_BYTE=24, PIX_FMT_NV12=25, PIX_FMT_NV21=26, PIX_FMT_ARGB=27, PIX_FMT_RGBA=28, PIX_FMT_ABGR=29, PIX_FMT_BGRA=30, PIX_FMT_GRAY16BE=31, PIX_FMT_GRAY16LE=32, PIX_FMT_YUV440P=33, PIX_FMT_YUVJ440P=34, PIX_FMT_YUVA420P=35, PIX_FMT_VDPAU_H264=36, PIX_FMT_VDPAU_MPEG1=37, PIX_FMT_VDPAU_MPEG2=38, PIX_FMT_VDPAU_WMV3=39, PIX_FMT_VDPAU_VC1=40, PIX_FMT_RGB48BE=41, PIX_FMT_RGB48LE=42, PIX_FMT_RGB565BE=43, PIX_FMT_RGB565LE=44, PIX_FMT_RGB555BE=45, PIX_FMT_RGB555LE=46, PIX_FMT_BGR565BE=47, PIX_FMT_BGR565LE=48, PIX_FMT_BGR555BE=49, PIX_FMT_BGR555LE=50, PIX_FMT_VAAPI_MOCO=51, PIX_FMT_VAAPI_IDCT=52, PIX_FMT_VAAPI_VLD=53, PIX_FMT_YUV420P16LE=54, PIX_FMT_YUV420P16BE=55, PIX_FMT_YUV422P16LE=56, PIX_FMT_YUV422P16BE=57, PIX_FMT_YUV444P16LE=58, PIX_FMT_YUV444P16BE=59, PIX_FMT_VDPAU_MPEG4=60, PIX_FMT_DXVA2_VLD=61, PIX_FMT_RGB444LE=62, PIX_FMT_RGB444BE=63, PIX_FMT_BGR444LE=64, PIX_FMT_BGR444BE=65, PIX_FMT_GRAY8A=66, PIX_FMT_BGR48BE=67, PIX_FMT_BGR48LE=68, PIX_FMT_YUV420P9BE=69, PIX_FMT_YUV420P9LE=70, PIX_FMT_YUV420P10BE=71, PIX_FMT_YUV420P10LE=72, PIX_FMT_YUV422P10BE=73, PIX_FMT_YUV422P10LE=74, PIX_FMT_YUV444P9BE=75, PIX_FMT_YUV444P9LE=76, PIX_FMT_YUV444P10BE=77, PIX_FMT_YUV444P10LE=78, PIX_FMT_YUV422P9BE=79, PIX_FMT_YUV422P9LE=80, PIX_FMT_VDA_VLD=81, PIX_FMT_GBRP=82, PIX_FMT_GBRP9BE=83, PIX_FMT_GBRP9LE=84, PIX_FMT_GBRP10BE=85, PIX_FMT_GBRP10LE=86, PIX_FMT_GBRP16BE=87, PIX_FMT_GBRP16LE=88, PIX_FMT_RGBA64BE=291, PIX_FMT_RGBA64LE=292, PIX_FMT_BGRA64BE=293, PIX_FMT_BGRA64LE=294, PIX_FMT_0RGB=295, PIX_FMT_RGB0=296, PIX_FMT_0BGR=297, PIX_FMT_BGR0=298, PIX_FMT_YUVA444P=299, PIX_FMT_YUVA422P=300, PIX_FMT_YUV420P12BE=301, PIX_FMT_YUV420P12LE=302, PIX_FMT_YUV420P14BE=303, PIX_FMT_YUV420P14LE=304, PIX_FMT_YUV422P12BE=305, PIX_FMT_YUV422P12LE=306, PIX_FMT_YUV422P14BE=307, PIX_FMT_YUV422P14LE=308, PIX_FMT_YUV444P12BE=309, PIX_FMT_YUV444P12LE=310, PIX_FMT_YUV444P14BE=311, PIX_FMT_YUV444P14LE=312, PIX_FMT_GBRP12BE=313, PIX_FMT_GBRP12LE=314, PIX_FMT_GBRP14BE=315, PIX_FMT_GBRP14LE=316, PIX_FMT_NB=317 };

// tag-AVProbeData
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 460
struct AVProbeData;

// tag-AVProfile
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3460
struct AVProfile;

// tag-AVProgram
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1210
struct AVProgram;

// tag-AVRational
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 43
struct AVRational;

// tag-AVSampleFormat
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 59
enum AVSampleFormat { AV_SAMPLE_FMT_NONE=-1, AV_SAMPLE_FMT_U8=0, AV_SAMPLE_FMT_S16=1, AV_SAMPLE_FMT_S32=2, AV_SAMPLE_FMT_FLT=3, AV_SAMPLE_FMT_DBL=4, AV_SAMPLE_FMT_U8P=5, AV_SAMPLE_FMT_S16P=6, AV_SAMPLE_FMT_S32P=7, AV_SAMPLE_FMT_FLTP=8, AV_SAMPLE_FMT_DBLP=9, AV_SAMPLE_FMT_NB=10 };

// tag-AVStream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 846
struct AVStream;

// tag-AVStreamParseType
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 776
enum AVStreamParseType { AVSTREAM_PARSE_NONE=0, AVSTREAM_PARSE_FULL=1, AVSTREAM_PARSE_HEADERS=2, AVSTREAM_PARSE_TIMESTAMPS=3, AVSTREAM_PARSE_FULL_ONCE=4, AVSTREAM_PARSE_FULL_RAW=1463898624 };

// tag-AVSubtitle
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3467
struct AVSubtitle;

// tag-AVSubtitleRect
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3773
struct AVSubtitleRect;

// tag-AVSubtitleType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3753
enum AVSubtitleType { SUBTITLE_NONE=0, SUBTITLE_BITMAP=1, SUBTITLE_TEXT=2, SUBTITLE_ASS=3 };

// tag-FFFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1186
struct FFFrac;

// tag-MpegEncContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3571
struct MpegEncContext;

// tag-MyBuffer
// file motion.c line 2957
struct MyBuffer;

// tag-RcOverride
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 708
struct RcOverride;

// tag-SDL_ActiveEvent
// file /usr/include/SDL/SDL_events.h line 119
struct SDL_ActiveEvent;

// tag-SDL_BlitMap
// file /usr/include/SDL/SDL_video.h line 115
struct SDL_BlitMap;

// tag-SDL_Color
// file /usr/include/SDL/SDL_video.h line 55
struct SDL_Color;

// tag-SDL_Event
// file /usr/include/SDL/SDL_events.h line 227
union SDL_Event;

// tag-SDL_ExposeEvent
// file /usr/include/SDL/SDL_events.h line 201
struct SDL_ExposeEvent;

// tag-SDL_JoyAxisEvent
// file /usr/include/SDL/SDL_events.h line 153
struct SDL_JoyAxisEvent;

// tag-SDL_JoyBallEvent
// file /usr/include/SDL/SDL_events.h line 161
struct SDL_JoyBallEvent;

// tag-SDL_JoyButtonEvent
// file /usr/include/SDL/SDL_events.h line 183
struct SDL_JoyButtonEvent;

// tag-SDL_JoyHatEvent
// file /usr/include/SDL/SDL_events.h line 170
struct SDL_JoyHatEvent;

// tag-SDL_KeyboardEvent
// file /usr/include/SDL/SDL_events.h line 126
struct SDL_KeyboardEvent;

// tag-SDL_MouseButtonEvent
// file /usr/include/SDL/SDL_events.h line 144
struct SDL_MouseButtonEvent;

// tag-SDL_MouseMotionEvent
// file /usr/include/SDL/SDL_events.h line 134
struct SDL_MouseMotionEvent;

// tag-SDL_Overlay
// file /usr/include/SDL/SDL_video.h line 208
struct SDL_Overlay;

// tag-SDL_Palette
// file /usr/include/SDL/SDL_video.h line 63
struct SDL_Palette;

// tag-SDL_PixelFormat
// file /usr/include/SDL/SDL_video.h line 70
struct SDL_PixelFormat;

// tag-SDL_QuitEvent
// file /usr/include/SDL/SDL_events.h line 206
struct SDL_QuitEvent;

// tag-SDL_Rect
// file /usr/include/SDL/SDL_video.h line 50
struct SDL_Rect;

// tag-SDL_ResizeEvent
// file /usr/include/SDL/SDL_events.h line 194
struct SDL_ResizeEvent;

// tag-SDL_Surface
// file /usr/include/SDL/SDL_video.h line 96
struct SDL_Surface;

// tag-SDL_SysWMEvent
// file /usr/include/SDL/SDL_events.h line 221
struct SDL_SysWMEvent;

// tag-SDL_SysWMmsg
// file /usr/include/SDL/SDL_events.h line 219
struct SDL_SysWMmsg;

// tag-SDL_UserEvent
// file /usr/include/SDL/SDL_events.h line 211
struct SDL_UserEvent;

// tag-SDL_VideoInfo
// file /usr/include/SDL/SDL_video.h line 171
struct SDL_VideoInfo;

// tag-SDL_keysym
// file /usr/include/SDL/SDL_keyboard.h line 59
struct SDL_keysym;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 742
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-auth_param
// file stream.c line 34
struct auth_param;

// tag-big_char
// file draw.c line 27
struct big_char;

// tag-charset_info_st
// file /usr/include/mysql/mysql.h line 269
struct charset_info_st;

// tag-config
// file conf.h line 21
struct config;

// tag-context
// file conf.h line 143
struct context;

// tag-coord
// file alg.h line 15
struct coord;

// tag-draw_char
// file draw.c line 22
struct draw_char;

// tag-enum_field_types
// file /usr/include/mysql/mysql_com.h line 369
enum enum_field_types { MYSQL_TYPE_DECIMAL=0, MYSQL_TYPE_TINY=1, MYSQL_TYPE_SHORT=2, MYSQL_TYPE_LONG=3, MYSQL_TYPE_FLOAT=4, MYSQL_TYPE_DOUBLE=5, MYSQL_TYPE_NULL=6, MYSQL_TYPE_TIMESTAMP=7, MYSQL_TYPE_LONGLONG=8, MYSQL_TYPE_INT24=9, MYSQL_TYPE_DATE=10, MYSQL_TYPE_TIME=11, MYSQL_TYPE_DATETIME=12, MYSQL_TYPE_YEAR=13, MYSQL_TYPE_NEWDATE=14, MYSQL_TYPE_VARCHAR=15, MYSQL_TYPE_BIT=16, MYSQL_TYPE_TIMESTAMP2=17, MYSQL_TYPE_DATETIME2=18, MYSQL_TYPE_TIME2=19, MYSQL_TYPE_NEWDECIMAL=246, MYSQL_TYPE_ENUM=247, MYSQL_TYPE_SET=248, MYSQL_TYPE_TINY_BLOB=249, MYSQL_TYPE_MEDIUM_BLOB=250, MYSQL_TYPE_LONG_BLOB=251, MYSQL_TYPE_BLOB=252, MYSQL_TYPE_VAR_STRING=253, MYSQL_TYPE_STRING=254, MYSQL_TYPE_GEOMETRY=255 };

// tag-event_handlers
// file event.c line 778
struct event_handlers;

// tag-ffmpeg
// file ffmpeg.h line 41
struct ffmpeg;

// tag-file_context
// file netcam.h line 99
struct file_context;

// tag-ftp_context
// file netcam.h line 197
struct ftp_context;

// tag-header_get_flags
// file netcam_wget.h line 85
enum header_get_flags { HG_NONE=0, HG_NO_CONTINUATIONS=2 };

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-image_data
// file motion.h line 234
struct image_data;

// tag-images
// file motion.h line 213
struct images;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_color_deconverter
// file /usr/include/jpeglib.h line 703
struct jpeg_color_deconverter;

// tag-jpeg_color_quantizer
// file /usr/include/jpeglib.h line 704
struct jpeg_color_quantizer;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_d_coef_controller
// file /usr/include/jpeglib.h line 696
struct jpeg_d_coef_controller;

// tag-jpeg_d_main_controller
// file /usr/include/jpeglib.h line 695
struct jpeg_d_main_controller;

// tag-jpeg_d_post_controller
// file /usr/include/jpeglib.h line 697
struct jpeg_d_post_controller;

// tag-jpeg_decomp_master
// file /usr/include/jpeglib.h line 694
struct jpeg_decomp_master;

// tag-jpeg_decompress_struct
// file /usr/include/jpeglib.h line 290
struct jpeg_decompress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_decoder
// file /usr/include/jpeglib.h line 700
struct jpeg_entropy_decoder;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_input_controller
// file /usr/include/jpeglib.h line 698
struct jpeg_input_controller;

// tag-jpeg_inverse_dct
// file /usr/include/jpeglib.h line 701
struct jpeg_inverse_dct;

// tag-jpeg_marker_reader
// file /usr/include/jpeglib.h line 699
struct jpeg_marker_reader;

// tag-jpeg_marker_struct
// file /usr/include/jpeglib.h line 199
struct jpeg_marker_struct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jpeg_source_mgr
// file /usr/include/jpeglib.h line 474
struct jpeg_source_mgr;

// tag-jpeg_upsampler
// file /usr/include/jpeglib.h line 702
struct jpeg_upsampler;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-my_error_mgr
// file jpegutils.c line 256
struct my_error_mgr;

// tag-mysql_option
// file /usr/include/mysql/mysql.h line 159
enum mysql_option { MYSQL_OPT_CONNECT_TIMEOUT=0, MYSQL_OPT_COMPRESS=1, MYSQL_OPT_NAMED_PIPE=2, MYSQL_INIT_COMMAND=3, MYSQL_READ_DEFAULT_FILE=4, MYSQL_READ_DEFAULT_GROUP=5, MYSQL_SET_CHARSET_DIR=6, MYSQL_SET_CHARSET_NAME=7, MYSQL_OPT_LOCAL_INFILE=8, MYSQL_OPT_PROTOCOL=9, MYSQL_SHARED_MEMORY_BASE_NAME=10, MYSQL_OPT_READ_TIMEOUT=11, MYSQL_OPT_WRITE_TIMEOUT=12, MYSQL_OPT_USE_RESULT=13, MYSQL_OPT_USE_REMOTE_CONNECTION=14, MYSQL_OPT_USE_EMBEDDED_CONNECTION=15, MYSQL_OPT_GUESS_CONNECTION=16, MYSQL_SET_CLIENT_IP=17, MYSQL_SECURE_AUTH=18, MYSQL_REPORT_DATA_TRUNCATION=19, MYSQL_OPT_RECONNECT=20, MYSQL_OPT_SSL_VERIFY_SERVER_CERT=21, MYSQL_PLUGIN_DIR=22, MYSQL_DEFAULT_AUTH=23, MYSQL_OPT_BIND=24, MYSQL_OPT_SSL_KEY=25, MYSQL_OPT_SSL_CERT=26, MYSQL_OPT_SSL_CA=27, MYSQL_OPT_SSL_CAPATH=28, MYSQL_OPT_SSL_CIPHER=29, MYSQL_OPT_SSL_CRL=30, MYSQL_OPT_SSL_CRLPATH=31, MYSQL_OPT_CONNECT_ATTR_RESET=32, MYSQL_OPT_CONNECT_ATTR_ADD=33, MYSQL_OPT_CONNECT_ATTR_DELETE=34, MYSQL_SERVER_PUBLIC_KEY=35, MYSQL_ENABLE_CLEARTEXT_PLUGIN=36, MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS=37 };

// tag-mysql_status
// file /usr/include/mysql/mysql.h line 236
enum mysql_status { MYSQL_STATUS_READY=0, MYSQL_STATUS_GET_RESULT=1, MYSQL_STATUS_USE_RESULT=2, MYSQL_STATUS_STATEMENT_GET_RESULT=3 };

// tag-netcam_caps
// file netcam.h line 214
struct netcam_caps;

// tag-netcam_context
// file netcam.h line 50
struct netcam_context;

// tag-netcam_image_buff
// file netcam.h line 90
struct netcam_image_buff;

// tag-pg_conn
// file /usr/include/postgresql/libpq-fe.h line 129
struct pg_conn;

// tag-pg_result
// file /usr/include/postgresql/libpq-fe.h line 136
struct pg_result;

// tag-private_hwdata
// file /usr/include/SDL/SDL_video.h line 105
struct private_hwdata;

// tag-private_yuvhwdata
// file /usr/include/SDL/SDL_video.h line 218
struct private_yuvhwdata;

// tag-private_yuvhwfuncs
// file /usr/include/SDL/SDL_video.h line 217
struct private_yuvhwfuncs;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rbuf
// file netcam_wget.h line 32
struct rbuf;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-rotdata
// file motion.h line 315
struct rotdata;

// tag-rtsp_context
// file netcam.h line 203
struct rtsp_context;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 166
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sqlite3
// file /usr/include/sqlite3.h line 232
struct sqlite3;

// tag-st_dynamic_array
// file /usr/include/mysql/mysql.h line 192
struct st_dynamic_array;

// tag-st_list
// file /usr/include/mysql/my_list.h line 23
struct st_list;

// tag-st_mem_root
// file /usr/include/mysql/my_alloc.h line 38
struct st_mem_root;

// tag-st_mysql
// file /usr/include/mysql/mysql.h line 263
struct st_mysql;

// tag-st_mysql_field
// file /usr/include/mysql/mysql.h line 94
struct st_mysql_field;

// tag-st_mysql_methods
// file /usr/include/mysql/mysql.h line 260
struct st_mysql_methods;

// tag-st_mysql_options
// file /usr/include/mysql/mysql.h line 187
struct st_mysql_options;

// tag-st_mysql_options_extention
// file /usr/include/mysql/mysql.h line 185
struct st_mysql_options_extention;

// tag-st_net
// file /usr/include/mysql/mysql_com.h line 316
struct st_net;

// tag-st_used_mem
// file /usr/include/mysql/my_alloc.h line 30
struct st_used_mem;

// tag-st_vio
// file /usr/include/mysql/mysql_com.h line 305
struct st_vio;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stream
// file stream.h line 30
struct stream;

// tag-stream_buffer
// file stream.h line 24
struct stream_buffer;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-tiff_writing
// file picture.c line 165
struct tiff_writing;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-trackoptions
// file track.h line 15
struct trackoptions;

// tag-url_t
// file netcam.h line 77
struct url_t;

// tag-v4l2_buf_type
// file /usr/include/linux/videodev2.h line 131
enum v4l2_buf_type { V4L2_BUF_TYPE_VIDEO_CAPTURE=1, V4L2_BUF_TYPE_VIDEO_OUTPUT=2, V4L2_BUF_TYPE_VIDEO_OVERLAY=3, V4L2_BUF_TYPE_VBI_CAPTURE=4, V4L2_BUF_TYPE_VBI_OUTPUT=5, V4L2_BUF_TYPE_SLICED_VBI_CAPTURE=6, V4L2_BUF_TYPE_SLICED_VBI_OUTPUT=7, V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY=8, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE=9, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE=10, V4L2_BUF_TYPE_SDR_CAPTURE=11, V4L2_BUF_TYPE_SDR_OUTPUT=12, V4L2_BUF_TYPE_PRIVATE=128 };

// tag-v4l2_buffer
// file /usr/include/linux/videodev2.h line 849
struct v4l2_buffer;

// tag-v4l2_capability
// file /usr/include/linux/videodev2.h line 399
struct v4l2_capability;

// tag-v4l2_clip
// file /usr/include/linux/videodev2.h line 971
struct v4l2_clip;

// tag-v4l2_control
// file /usr/include/linux/videodev2.h line 1456
struct v4l2_control;

// tag-v4l2_fmtdesc
// file /usr/include/linux/videodev2.h line 639
struct v4l2_fmtdesc;

// tag-v4l2_format
// file /usr/include/linux/videodev2.h line 2000
struct v4l2_format;

// tag-v4l2_fract
// file /usr/include/linux/videodev2.h line 383
struct v4l2_fract;

// tag-v4l2_frequency
// file /usr/include/linux/videodev2.h line 1630
struct v4l2_frequency;

// tag-v4l2_input
// file /usr/include/linux/videodev2.h line 1383
struct v4l2_input;

// tag-v4l2_pix_format
// file /usr/include/linux/videodev2.h line 449
struct v4l2_pix_format;

// tag-v4l2_pix_format_mplane
// file /usr/include/linux/videodev2.h line 1963
struct v4l2_pix_format_mplane;

// tag-v4l2_plane
// file /usr/include/linux/videodev2.h line 807
struct v4l2_plane;

// tag-v4l2_plane_pix_format
// file /usr/include/linux/videodev2.h line 1943
struct v4l2_plane_pix_format;

// tag-v4l2_queryctrl
// file /usr/include/linux/videodev2.h line 1508
struct v4l2_queryctrl;

// tag-v4l2_rect
// file /usr/include/linux/videodev2.h line 376
struct v4l2_rect;

// tag-v4l2_requestbuffers
// file /usr/include/linux/videodev2.h line 780
struct v4l2_requestbuffers;

// tag-v4l2_sdr_format
// file /usr/include/linux/videodev2.h line 1984
struct v4l2_sdr_format;

// tag-v4l2_sliced_vbi_format
// file /usr/include/linux/videodev2.h line 1842
struct v4l2_sliced_vbi_format;

// tag-v4l2_standard
// file /usr/include/linux/videodev2.h line 1180
struct v4l2_standard;

// tag-v4l2_timecode
// file /usr/include/linux/videodev2.h line 723
struct v4l2_timecode;

// tag-v4l2_tuner
// file /usr/include/linux/videodev2.h line 1573
struct v4l2_tuner;

// tag-v4l2_vbi_format
// file /usr/include/linux/videodev2.h line 1814
struct v4l2_vbi_format;

// tag-v4l2_window
// file /usr/include/linux/videodev2.h line 976
struct v4l2_window;

// tag-video_dev
// file video.h line 51
struct video_dev;

// tag-video_image_buff
// file video.h line 42
struct video_image_buff;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// CvtHex
// file stream.c line 269
static void CvtHex(char *Bin, char *Hex);
// Decode
// file md5.c line 302
static void Decode(unsigned int *output, unsigned char *input, unsigned int len);
// DigestCalcHA1
// file stream.c line 293
static void DigestCalcHA1(char *pszAlg, char *pszUserName, char *pszRealm, char *pszPassword, char *pszNonce, char *pszCNonce, char *SessionKey);
// DigestCalcResponse
// file stream.c line 330
static void DigestCalcResponse(char *HA1, char *pszNonce, char *pszNonceCount, char *pszCNonce, char *pszQop, char *pszMethod, char *pszDigestUri, char *HEntity, char *Response);
// Encode
// file md5.c line 283
static void Encode(unsigned char *output, unsigned int *input, unsigned int len);
// MD5
// file md5.c line 339
void MD5(unsigned char *message, unsigned long int message_length, unsigned char *md);
// MD5Final
// file md5.h line 74
void MD5Final(unsigned char *digest, struct anonymous$30 *context);
// MD5Init
// file md5.h line 72
void MD5Init(struct anonymous$30 *context);
// MD5Transform
// file md5.c line 190
static void MD5Transform(unsigned int *state, unsigned char *block);
// MD5Update
// file md5.h line 73
void MD5Update(struct anonymous$30 *context, unsigned char *input, unsigned int inputLen);
// MD5_memcpy
// file md5.c line 316
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len);
// MD5_memset
// file md5.c line 328
static void MD5_memset(unsigned char *output, signed int value, unsigned int len);
// PQclear
// file /usr/include/postgresql/libpq-fe.h line 484
extern void PQclear(struct pg_result *);
// PQconnectdb
// file /usr/include/postgresql/libpq-fe.h line 250
extern struct pg_conn * PQconnectdb(const char *);
// PQerrorMessage
// file /usr/include/postgresql/libpq-fe.h line 313
extern char * PQerrorMessage(const struct pg_conn *);
// PQexec
// file /usr/include/postgresql/libpq-fe.h line 366
extern struct pg_result * PQexec(struct pg_conn *, const char *);
// PQfinish
// file /usr/include/postgresql/libpq-fe.h line 262
extern void PQfinish(struct pg_conn *);
// PQreset
// file /usr/include/postgresql/libpq-fe.h line 285
extern void PQreset(struct pg_conn *);
// PQresultStatus
// file /usr/include/postgresql/libpq-fe.h line 452
extern enum anonymous$4 PQresultStatus(const struct pg_result *);
// PQstatus
// file /usr/include/postgresql/libpq-fe.h line 307
extern enum anonymous$41 PQstatus(const struct pg_conn *);
// SDL_CreateYUVOverlay
// file /usr/include/SDL/SDL_video.h line 807
extern struct SDL_Overlay * SDL_CreateYUVOverlay(signed int, signed int, unsigned int, struct SDL_Surface *);
// SDL_DisplayYUVOverlay
// file /usr/include/SDL/SDL_video.h line 820
extern signed int SDL_DisplayYUVOverlay(struct SDL_Overlay *, struct SDL_Rect *);
// SDL_EventState
// file /usr/include/SDL/SDL_events.h line 348
extern unsigned char SDL_EventState(unsigned char, signed int);
// SDL_FreeYUVOverlay
// file /usr/include/SDL/SDL_video.h line 823
extern void SDL_FreeYUVOverlay(struct SDL_Overlay *);
// SDL_GetError
// file /usr/include/SDL/SDL_error.h line 44
extern char * SDL_GetError(void);
// SDL_GetVideoInfo
// file /usr/include/SDL/SDL_video.h line 300
extern const struct SDL_VideoInfo * SDL_GetVideoInfo(void);
// SDL_Init
// file /usr/include/SDL/SDL.h line 76
extern signed int SDL_Init(unsigned int);
// SDL_LockSurface
// file /usr/include/SDL/SDL_video.h line 580
extern signed int SDL_LockSurface(struct SDL_Surface *);
// SDL_LockYUVOverlay
// file /usr/include/SDL/SDL_video.h line 811
extern signed int SDL_LockYUVOverlay(struct SDL_Overlay *);
// SDL_PollEvent
// file /usr/include/SDL/SDL_events.h line 284
extern signed int SDL_PollEvent(union SDL_Event *);
// SDL_Quit
// file /usr/include/SDL/SDL.h line 93
extern void SDL_Quit(void);
// SDL_SetVideoMode
// file /usr/include/SDL/SDL_video.h line 384
extern struct SDL_Surface * SDL_SetVideoMode(signed int, signed int, signed int, unsigned int);
// SDL_ShowCursor
// file /usr/include/SDL/SDL_mouse.h line 112
extern signed int SDL_ShowCursor(signed int);
// SDL_UnlockSurface
// file /usr/include/SDL/SDL_video.h line 581
extern void SDL_UnlockSurface(struct SDL_Surface *);
// SDL_UnlockYUVOverlay
// file /usr/include/SDL/SDL_video.h line 812
extern void SDL_UnlockYUVOverlay(struct SDL_Overlay *);
// SDL_WM_SetCaption
// file /usr/include/SDL/SDL_video.h line 885
extern void SDL_WM_SetCaption(const char *, const char *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _jpeg_mem_dest
// file picture.c line 59
static void _jpeg_mem_dest(struct jpeg_compress_struct *cinfo, unsigned char *buf, unsigned long int bufsize);
// _jpeg_mem_size
// file picture.c line 80
static signed int _jpeg_mem_size(struct jpeg_compress_struct *cinfo);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$7, unsigned int *);
// acceptnonblocking
// file webhttpd.c line 2359
static signed int acceptnonblocking(signed int serverfd, signed int timeout);
// action
// file webhttpd.c line 926
static unsigned int action(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata);
// add_huff_table
// file jpegutils.c line 306
static void add_huff_table(struct jpeg_decompress_struct *dinfo, struct anonymous$14 **htblptr, const unsigned char *bits, const unsigned char *val);
// alg_despeckle
// file alg.h line 43
signed int alg_despeckle(struct context *cnt, signed int olddiffs);
// alg_diff
// file alg.h line 37
signed int alg_diff(struct context *cnt, unsigned char *new);
// alg_diff_fast
// file alg.c line 1202
static char alg_diff_fast(struct context *cnt, signed int max_n_changes, unsigned char *new);
// alg_diff_standard
// file alg.h line 38
signed int alg_diff_standard(struct context *cnt, unsigned char *new);
// alg_draw_location
// file alg.h line 35
void alg_draw_location(struct coord *cent, struct images *imgs, signed int width, unsigned char *new, signed int style, signed int mode, signed int process_thisframe);
// alg_draw_red_location
// file alg.h line 36
void alg_draw_red_location(struct coord *cent, struct images *imgs, signed int width, unsigned char *new, signed int style, signed int mode, signed int process_thisframe);
// alg_labeling
// file alg.c line 519
static signed int alg_labeling(struct context *cnt);
// alg_lightswitch
// file alg.h line 39
signed int alg_lightswitch(struct context *cnt, signed int diffs);
// alg_locate_center_size
// file alg.h line 34
void alg_locate_center_size(struct images *imgs, signed int width, signed int height, struct coord *cent);
// alg_noise_tune
// file alg.h line 41
void alg_noise_tune(struct context *cnt, unsigned char *new);
// alg_switchfilter
// file alg.h line 40
signed int alg_switchfilter(struct context *cnt, signed int diffs, unsigned char *newimg);
// alg_threshold_tune
// file alg.h line 42
void alg_threshold_tune(struct context *cnt, signed int diffs, signed int motion);
// alg_tune_smartmask
// file alg.h line 44
void alg_tune_smartmask(struct context *cnt);
// alg_update_reference_frame
// file alg.h line 45
void alg_update_reference_frame(struct context *cnt, signed int action);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// av_buffersink_get_frame
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersink.h line 179
signed int av_buffersink_get_frame(struct AVFilterContext *, struct AVFrame *);
// av_buffersrc_add_frame
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersrc.h line 138
signed int av_buffersrc_add_frame(struct AVFilterContext *, struct AVFrame *);
// av_dict_set
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 128
signed int av_dict_set(struct AVDictionary **, const char *, const char *, signed int);
// av_find_best_stream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2161
signed int av_find_best_stream(struct AVFormatContext *, enum AVMediaType, signed int, signed int, struct AVCodec **, signed int);
// av_frame_alloc
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 630
struct AVFrame * av_frame_alloc(void);
// av_frame_free
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 639
void av_frame_free(struct AVFrame **);
// av_frame_unref
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 666
void av_frame_unref(struct AVFrame *);
// av_free
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 195
void av_free(void *);
// av_free_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4108
void av_free_packet(struct AVPacket *);
// av_freep
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 269
void av_freep(void *);
// av_get_media_type_string
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 205
const char * av_get_media_type_string(enum AVMediaType);
// av_guess_format
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2434
struct AVOutputFormat * av_guess_format(const char *, const char *, const char *);
// av_image_copy_to_buffer
// file /usr/include/x86_64-linux-gnu/libavutil/imgutils.h line 178
signed int av_image_copy_to_buffer(unsigned char *, signed int, const unsigned char * const *, const signed int *, enum AVPixelFormat, signed int, signed int, signed int);
// av_image_get_buffer_size
// file /usr/include/x86_64-linux-gnu/libavutil/imgutils.h line 159
signed int av_image_get_buffer_size(enum AVPixelFormat, signed int, signed int, signed int);
// av_init_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4040
void av_init_packet(struct AVPacket *);
// av_log_set_callback
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 282
void av_log_set_callback(void (*)(void *, signed int, const char *, void **));
// av_log_set_level
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 270
void av_log_set_level(signed int);
// av_make_error_string
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 109
static inline char * av_make_error_string(char *errbuf, unsigned long int errbuf_size, signed int errnum);
// av_picture_copy
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 5147
void av_picture_copy(struct AVPicture *, const struct AVPicture *, enum AVPixelFormat, signed int, signed int);
// av_read_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2192
signed int av_read_frame(struct AVFormatContext *, struct AVPacket *);
// av_read_play
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2262
signed int av_read_play(struct AVFormatContext *);
// av_register_all
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1896
void av_register_all(void);
// av_strerror
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 97
signed int av_strerror(signed int, char *, unsigned long int);
// av_write_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2336
signed int av_write_frame(struct AVFormatContext *, struct AVPacket *);
// av_write_trailer
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2420
signed int av_write_trailer(struct AVFormatContext *);
// avcodec_close
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4005
signed int avcodec_close(struct AVCodecContext *);
// avcodec_decode_video2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4492
signed int avcodec_decode_video2(struct AVCodecContext *, struct AVFrame *, signed int *, const struct AVPacket *);
// avcodec_encode_video2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4934
signed int avcodec_encode_video2(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
// avcodec_find_decoder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4256
struct AVCodec * avcodec_find_decoder(enum AVCodecID);
// avcodec_find_encoder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4798
struct AVCodec * avcodec_find_encoder(enum AVCodecID);
// avcodec_open2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3994
signed int avcodec_open2(struct AVCodecContext *, const struct AVCodec *, struct AVDictionary **);
// avfilter_graph_alloc
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1255
struct AVFilterGraph * avfilter_graph_alloc(void);
// avfilter_graph_config
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1338
signed int avfilter_graph_config(struct AVFilterGraph *, void *);
// avfilter_graph_free
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1344
void avfilter_graph_free(struct AVFilterGraph **);
// avfilter_graph_get_filter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1283
struct AVFilterContext * avfilter_graph_get_filter(struct AVFilterGraph *, const char *);
// avfilter_graph_parse2
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1468
signed int avfilter_graph_parse2(struct AVFilterGraph *, const char *, struct AVFilterInOut **, struct AVFilterInOut **);
// avformat_alloc_context
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1935
struct AVFormatContext * avformat_alloc_context(void);
// avformat_close_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2275
void avformat_close_input(struct AVFormatContext **);
// avformat_find_stream_info
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2123
signed int avformat_find_stream_info(struct AVFormatContext *, struct AVDictionary **);
// avformat_new_stream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1970
struct AVStream * avformat_new_stream(struct AVFormatContext *, const struct AVCodec *);
// avformat_open_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2097
signed int avformat_open_input(struct AVFormatContext **, const char *, struct AVInputFormat *, struct AVDictionary **);
// avformat_write_header
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2304
signed int avformat_write_header(struct AVFormatContext *, struct AVDictionary **);
// avio_close
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 561
signed int avio_close(struct AVIOContext *);
// avio_flush
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 427
void avio_flush(struct AVIOContext *);
// avio_open
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 528
signed int avio_open(struct AVIOContext **, const char *, signed int);
// avio_write
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 325
void avio_write(struct AVIOContext *, const unsigned char *, signed int);
// base64_encode
// file netcam_wget.h line 75
void base64_encode(const char *s, char *store, signed int length);
// bayer2rgb24
// file video.h line 98
void bayer2rgb24(unsigned char *dst, unsigned char *src, signed long int width, signed long int height);
// become_daemon
// file motion.c line 2271
static void become_daemon(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$7, unsigned int);
// bzero
// file /usr/include/string.h line 454
extern void bzero(void *, unsigned long int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 500
extern signed int chdir(const char *);
// check_quote
// file netcam.c line 271
static void check_quote(char *str);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// cntlist_create
// file motion.c line 2372
static void cntlist_create(signed int argc, char **argv);
// conf_cmdline
// file conf.c line 1544
static void conf_cmdline(struct context *cnt, signed int thread);
// conf_cmdparse
// file conf.h line 161
struct context ** conf_cmdparse(struct context **cnt, const char *cmd, const char *arg1);
// conf_load
// file conf.h line 160
struct context ** conf_load(struct context **cnt);
// conf_print
// file conf.c line 1740
void conf_print(struct context **cnt);
// conf_process
// file conf.c line 1666
static struct context ** conf_process(struct context **cnt, struct _IO_FILE *fp);
// config
// file webhttpd.c line 393
static unsigned int config(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata);
// config_thread
// file conf.c line 2289
static struct context ** config_thread(struct context **cnt, const char *str, signed int val);
// config_type
// file conf.c line 2177
const char * config_type(struct anonymous *configparam);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$7, unsigned int);
// context_destroy
// file motion.c line 270
static void context_destroy(struct context *cnt);
// context_init
// file motion.c line 236
static void context_init(struct context *cnt);
// conv_rgb24toyuv420p
// file video.h line 96
void conv_rgb24toyuv420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height);
// conv_uyvyto420p
// file video.h line 95
void conv_uyvyto420p(unsigned char *map, unsigned char *cap_map, unsigned int width, unsigned int height);
// conv_yuv422to420p
// file video.h line 94
void conv_yuv422to420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height);
// copy_bool
// file conf.c line 2016
static struct context ** copy_bool(struct context **cnt, const char *str, signed int val_ptr);
// copy_int
// file conf.c line 2046
static struct context ** copy_int(struct context **cnt, const char *str, signed int val_ptr);
// copy_string
// file conf.h line 167
struct context ** copy_string(struct context **cnt, const char *str, signed int val_ptr);
// create_path
// file motion.c line 2924
signed int create_path(const char *path);
// decode_jpeg_gray_raw
// file jpegutils.c line 768
signed int decode_jpeg_gray_raw(unsigned char *jpeg_data, signed int len, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2);
// decode_jpeg_raw
// file jpegutils.c line 442
signed int decode_jpeg_raw(unsigned char *jpeg_data, signed int len, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2);
// decode_packet
// file netcam_rtsp.c line 54
static signed int decode_packet(struct AVPacket *packet, struct netcam_image_buff *buffer, struct AVFrame *frame, struct AVCodecContext *cc);
// delete_filter_graph
// file ffmpeg.c line 1042
static void delete_filter_graph();
// detection
// file webhttpd.c line 1108
static unsigned int detection(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata);
// dilate5
// file alg.c line 677
static signed int dilate5(unsigned char *img, signed int width, signed int height, void *buffer);
// dilate9
// file alg.c line 590
static signed int dilate9(unsigned char *img, signed int width, signed int height, void *buffer);
// do_client_auth
// file stream.c line 628
static void do_client_auth(struct context *cnt, signed int sc);
// do_client_auth::1::handle_func$object
//
void * handle_func$object(void *);
// draw_text
// file motion.h line 281
signed int draw_text(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, unsigned int factor);
// draw_textn
// file draw.c line 1081
static signed int draw_textn(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, signed int len, unsigned int factor);
// dup2
// file /usr/include/unistd.h line 537
extern signed int dup2(signed int, signed int);
// empty_output_buffer
// file jpegutils.c line 190
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo);
// empty_output_buffer$link1
// file picture.c line 43
static signed int empty_output_buffer$link1(struct jpeg_compress_struct *cinfo$link1);
// encode_jpeg_raw
// file jpegutils.c line 1044
signed int encode_jpeg_raw(unsigned char *jpeg_data, signed int len, signed int quality, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2);
// erode5
// file alg.c line 792
static signed int erode5(unsigned char *img, signed int width, signed int height, void *buffer, unsigned char flag);
// erode9
// file alg.c line 748
static signed int erode9(unsigned char *img, signed int width, signed int height, void *buffer, unsigned char flag);
// event
// file event.h line 38
void event(struct context *cnt, signed int type, unsigned char *image, char *filename, void *eventdata, struct tm *tm);
// event_beep
// file event.c line 72
static void event_beep(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *ftype, struct tm *tm);
// event_camera_lost
// file event.c line 394
static void event_camera_lost(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_create_extpipe
// file event.c line 427
static void event_create_extpipe(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_extpipe_end
// file event.c line 412
static void event_extpipe_end(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *tm);
// event_extpipe_put
// file event.c line 493
static void event_extpipe_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm);
// event_ffmpeg_closefile
// file event.c line 728
static void event_ffmpeg_closefile(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// event_ffmpeg_newfile
// file event.c line 540
static void event_ffmpeg_newfile(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_ffmpeg_put
// file event.c line 698
static void event_ffmpeg_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm);
// event_ffmpeg_timelapse
// file event.c line 628
static void event_ffmpeg_timelapse(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_ffmpeg_timelapseend
// file event.c line 755
static void event_ffmpeg_timelapseend(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// event_image_detect
// file event.c line 292
static void event_image_detect(struct context *cnt, signed int type, unsigned char *newimg, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_image_snapshot
// file event.c line 348
static void event_image_snapshot(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_imagem_detect
// file event.c line 318
static void event_imagem_detect(struct context *cnt, signed int type, unsigned char *newimg, char *dummy1, void *dummy2, struct tm *currenttime_tm);
// event_new_video
// file event.c line 514
static void event_new_video(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *tm);
// event_newfile
// file event.c line 63
static void event_newfile(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *ftype, struct tm *tm);
// event_sdl_put
// file event.c line 263
static void event_sdl_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm);
// event_sqlnewfile
// file event.c line 114
static void event_sqlnewfile(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm);
// event_stop_stream
// file event.c line 245
static void event_stop_stream(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// event_stream_put
// file event.c line 254
static void event_stream_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm);
// exec_command
// file event.c line 28
static void exec_command(struct context *cnt, char *command, char *filename, signed int filetype);
// execl
// file /usr/include/unistd.h line 576
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// ffmpeg_avcodec_log
// file ffmpeg.c line 1158
void ffmpeg_avcodec_log(void *ignoreme, signed int errno_flag, const char *fmt, void **vl);
// ffmpeg_cleanups
// file ffmpeg.c line 792
void ffmpeg_cleanups(struct ffmpeg *ffmpeg);
// ffmpeg_close
// file ffmpeg.h line 93
void ffmpeg_close(struct ffmpeg *ffmpeg);
// ffmpeg_deinterlace
// file ffmpeg.h line 96
void ffmpeg_deinterlace(unsigned char *img, signed int width, signed int height);
// ffmpeg_init
// file ffmpeg.h line 60
void ffmpeg_init(void);
// ffmpeg_open
// file ffmpeg.h line 68
struct ffmpeg * ffmpeg_open(char *ffmpeg_video_codec, char *filename, unsigned char *y, unsigned char *u, unsigned char *v, signed int width, signed int height, signed int rate, signed int bps, signed int vbr);
// ffmpeg_prepare_frame
// file ffmpeg.c line 1007
struct AVFrame * ffmpeg_prepare_frame(struct ffmpeg *ffmpeg, unsigned char *y, unsigned char *u, unsigned char *v);
// ffmpeg_put_frame
// file ffmpeg.c line 914
signed int ffmpeg_put_frame(struct ffmpeg *ffmpeg, struct AVFrame *pic);
// ffmpeg_put_image
// file ffmpeg.h line 82
signed int ffmpeg_put_image(struct ffmpeg *ffmpeg);
// ffmpeg_put_other_image
// file ffmpeg.h line 85
signed int ffmpeg_put_other_image(struct ffmpeg *ffmpeg, unsigned char *y, unsigned char *u, unsigned char *v);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_free_context
// file netcam.c line 1865
void file_free_context(struct file_context *ctxt);
// file_new_context
// file netcam.c line 1852
struct file_context * file_new_context(void);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill_input_buffer
// file jpegutils.c line 86
static signed int fill_input_buffer(struct jpeg_decompress_struct *cinfo);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// ftp_close
// file netcam_ftp.c line 872
signed int ftp_close(struct ftp_context *ctxt);
// ftp_close_connection
// file netcam_ftp.c line 663
static signed int ftp_close_connection(struct ftp_context *ctxt);
// ftp_connect
// file netcam_ftp.h line 38
signed int ftp_connect(struct netcam_context *netcam);
// ftp_free_context
// file netcam_ftp.h line 36
void ftp_free_context(struct ftp_context *ctxt);
// ftp_get_connection
// file netcam_ftp.c line 494
static signed int ftp_get_connection(struct ftp_context *ctxt);
// ftp_get_more
// file netcam_ftp.c line 135
static signed int ftp_get_more(struct ftp_context *ctxt);
// ftp_get_response
// file netcam_ftp.c line 193
static signed int ftp_get_response(struct ftp_context *ctxt);
// ftp_get_socket
// file netcam_ftp.h line 40
signed int ftp_get_socket(struct ftp_context *ctxt);
// ftp_new_context
// file netcam_ftp.h line 35
struct ftp_context * ftp_new_context(void);
// ftp_parse_response
// file netcam_ftp.c line 90
static signed int ftp_parse_response(char *buf, signed int len);
// ftp_quit
// file netcam_ftp.c line 327
static signed int ftp_quit(struct ftp_context *ctxt);
// ftp_read
// file netcam_ftp.h line 41
signed int ftp_read(struct ftp_context *ctxt, void *dest, signed int len);
// ftp_send_passwd
// file netcam_ftp.c line 293
static signed int ftp_send_passwd(struct ftp_context *ctxt);
// ftp_send_type
// file netcam_ftp.h line 39
signed int ftp_send_type(struct ftp_context *ctxt, char type);
// ftp_send_user
// file netcam_ftp.c line 267
static signed int ftp_send_user(struct ftp_context *ctxt);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_current_dir_name
// file /usr/include/unistd.h line 520
extern char * get_current_dir_name(void);
// get_log_level_str
// file logger.h line 57
const char * get_log_level_str(unsigned int level);
// get_log_type
// file logger.h line 54
signed int get_log_type(const char *type);
// get_log_type_str
// file logger.h line 55
const char * get_log_type_str(unsigned int type);
// get_oformat
// file ffmpeg.c line 386
static struct AVOutputFormat * get_oformat(const char *codec, char *filename);
// get_pgm
// file picture.h line 22
unsigned char * get_pgm(struct _IO_FILE *picture, signed int width, signed int height);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getdtablesize
// file /usr/include/unistd.h line 986
extern signed int getdtablesize(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$7, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// grey2yuv420p
// file event.c line 533
static void grey2yuv420p(unsigned char *u, unsigned char *v, signed int width, signed int height);
// guarantee_huff_tables
// file jpegutils.c line 412
static void guarantee_huff_tables(struct jpeg_decompress_struct *dinfo);
// handle_basic_auth
// file stream.c line 167
static void * handle_basic_auth(void *param);
// handle_get
// file webhttpd.c line 1944
static unsigned int handle_get(signed int client_socket, const char *url, void *userdata);
// handle_md5_digest
// file stream.c line 386
static void * handle_md5_digest(void *param);
// header_extract_number
// file netcam_wget.h line 94
signed int header_extract_number(const char *header, void *closure);
// header_get
// file netcam_wget.h line 90
signed int header_get(struct netcam_context *netcam, char **hdr, enum header_get_flags flags);
// header_process
// file netcam_wget.h line 91
signed int header_process(const char *header, const char *name, signed int (*procfun)(const char *, void *), void *arg);
// header_process::procfun$object
//
signed int procfun$object(const char *, void *);
// header_strdup
// file netcam_wget.c line 189
signed int header_strdup(const char *header, void *closure);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// http_acceptsock
// file stream.c line 797
static signed int http_acceptsock(signed int sl);
// http_bindsock
// file stream.c line 711
signed int http_bindsock(signed int port, signed int local, signed int ipv6_enabled);
// http_process_type
// file netcam_wget.h line 77
signed int http_process_type(const char *hdr, void *arg);
// http_result_code
// file netcam_wget.h line 97
signed int http_result_code(const char *header);
// httpd_run
// file webhttpd.c line 2388
void httpd_run(struct context **cnt);
// iflood
// file alg.c line 459
static signed int iflood(signed int x, signed int y, signed int width, signed int height, unsigned char *out, signed int *labels, signed int newvalue, signed int oldvalue);
// image_ring_destroy
// file motion.c line 153
static void image_ring_destroy(struct context *cnt);
// image_ring_resize
// file motion.c line 89
static void image_ring_resize(struct context *cnt, signed int new_size);
// image_save_as_preview
// file motion.c line 185
static void image_save_as_preview(struct context *cnt, struct image_data *img);
// imageext
// file event.c line 284
const char * imageext(struct context *cnt);
// init_destination
// file jpegutils.c line 177
static void init_destination(struct jpeg_compress_struct *cinfo);
// init_destination$link1
// file picture.c line 35
static void init_destination$link1(struct jpeg_compress_struct *cinfo$link1);
// init_filter_graph
// file ffmpeg.c line 1049
static signed int init_filter_graph(enum AVPixelFormat pixfmt, signed int width, signed int height);
// init_source
// file jpegutils.c line 71
static void init_source(struct jpeg_decompress_struct *cinfo);
// initialize_chars
// file motion.h line 282
signed int initialize_chars(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// iomojo_center
// file track.c line 661
static unsigned int iomojo_center(struct context *cnt, signed int x_offset, signed int y_offset);
// iomojo_command
// file track.c line 619
static char iomojo_command(struct context *cnt, char *command, signed int len, unsigned int ret);
// iomojo_move
// file track.c line 725
static unsigned int iomojo_move(struct context *cnt, signed int dev, struct coord *cent, struct images *imgs);
// iomojo_movehome
// file track.c line 651
static void iomojo_movehome(struct context *cnt);
// iomojo_setspeed
// file track.c line 639
static void iomojo_setspeed(struct context *cnt, unsigned int speed);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_CreateDecompress
// file /usr/include/jpeglib.h line 906
extern void jpeg_CreateDecompress(struct jpeg_decompress_struct *, signed int, unsigned long int);
// jpeg_alloc_huff_table
// file /usr/include/jpeglib.h line 946
extern struct anonymous$14 * jpeg_alloc_huff_table(struct jpeg_common_struct *);
// jpeg_buffer_dest
// file jpegutils.c line 219
static void jpeg_buffer_dest(struct jpeg_compress_struct *cinfo, unsigned char *buf, signed long int len);
// jpeg_buffer_src
// file jpegutils.c line 123
static void jpeg_buffer_src(struct jpeg_decompress_struct *cinfo, unsigned char *buffer, signed long int num);
// jpeg_destroy
// file /usr/include/jpeglib.h line 1048
extern void jpeg_destroy(struct jpeg_common_struct *);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_destroy_decompress
// file /usr/include/jpeglib.h line 910
extern void jpeg_destroy_decompress(struct jpeg_decompress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_finish_decompress
// file /usr/include/jpeglib.h line 993
extern signed int jpeg_finish_decompress(struct jpeg_decompress_struct *);
// jpeg_read_header
// file /usr/include/jpeglib.h line 977
extern signed int jpeg_read_header(struct jpeg_decompress_struct *, signed int);
// jpeg_read_raw_data
// file /usr/include/jpeglib.h line 996
extern unsigned int jpeg_read_raw_data(struct jpeg_decompress_struct *, unsigned char ***, unsigned int);
// jpeg_read_scanlines
// file /usr/include/jpeglib.h line 990
extern unsigned int jpeg_read_scanlines(struct jpeg_decompress_struct *, unsigned char **, unsigned int);
// jpeg_resync_to_restart
// file /usr/include/jpeglib.h line 1051
extern signed int jpeg_resync_to_restart(struct jpeg_decompress_struct *, signed int);
// jpeg_set_colorspace
// file /usr/include/jpeglib.h line 928
extern void jpeg_set_colorspace(struct jpeg_compress_struct *, enum anonymous$10);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_skip_ff
// file jpegutils.c line 153
static void jpeg_skip_ff(struct jpeg_decompress_struct *cinfo);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_start_decompress
// file /usr/include/jpeglib.h line 989
extern signed int jpeg_start_decompress(struct jpeg_decompress_struct *);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_write_marker
// file /usr/include/jpeglib.h line 966
extern void jpeg_write_marker(struct jpeg_compress_struct *, signed int, const unsigned char *, unsigned int);
// jpeg_write_raw_data
// file /usr/include/jpeglib.h line 962
extern unsigned int jpeg_write_raw_data(struct jpeg_compress_struct *, unsigned char ***, unsigned int);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_strings
// file conf.c line 1963
void malloc_strings(struct context *cnt);
// memchr
// file /usr/include/string.h line 92
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mjpegtoyuv420p
// file video.h line 100
signed int mjpegtoyuv420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height, unsigned int size);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// motion_cleanup
// file motion.c line 960
static void motion_cleanup(struct context *cnt);
// motion_detected
// file motion.c line 411
static void motion_detected(struct context *cnt, signed int dev, struct image_data *img);
// motion_init
// file motion.c line 666
static signed int motion_init(struct context *cnt);
// motion_log
// file logger.h line 61
void motion_log(signed int level, unsigned int type, signed int errno_flag, const char *fmt, ...);
// motion_loop
// file motion.c line 1078
static void * motion_loop(void *arg);
// motion_remove_pid
// file motion.c line 380
static void motion_remove_pid(void);
// motion_shutdown
// file motion.c line 2412
static void motion_shutdown(void);
// motion_startup
// file motion.c line 2443
static void motion_startup(signed int daemonize, signed int argc, char **argv);
// motion_web_control
// file webhttpd.h line 20
void * motion_web_control(void *arg);
// mpeg1_write_trailer
// file ffmpeg.c line 318
static signed int mpeg1_write_trailer(struct AVFormatContext *s);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// my_emit_message
// file jpegutils.c line 281
static void my_emit_message(struct jpeg_common_struct *cinfo, signed int msg_level);
// my_error_exit
// file jpegutils.c line 266
static void my_error_exit(struct jpeg_common_struct *cinfo);
// myfclose
// file motion.c line 3077
signed int myfclose(struct _IO_FILE *fh);
// myfopen
// file motion.c line 2982
struct _IO_FILE * myfopen(const char *path, const char *mode, unsigned long int bufsize);
// mymalloc
// file motion.c line 2855
void * mymalloc(unsigned long int nbytes);
// myrealloc
// file motion.c line 2885
void * myrealloc(void *ptr, unsigned long int size, const char *desc);
// mysql_close
// file /usr/include/mysql/mysql.h line 718
void mysql_close(struct st_mysql *);
// mysql_errno
// file /usr/include/mysql/mysql.h line 392
unsigned int mysql_errno(struct st_mysql *);
// mysql_error
// file /usr/include/mysql/mysql.h line 393
const char * mysql_error(struct st_mysql *);
// mysql_init
// file /usr/include/mysql/mysql.h line 401
struct st_mysql * mysql_init(struct st_mysql *);
// mysql_options
// file /usr/include/mysql/mysql.h line 466
signed int mysql_options(struct st_mysql *, enum mysql_option, const void *);
// mysql_query
// file /usr/include/mysql/mysql.h line 416
signed int mysql_query(struct st_mysql *, const char *);
// mysql_real_connect
// file /usr/include/mysql/mysql.h line 408
struct st_mysql * mysql_real_connect(struct st_mysql *, const char *, const char *, const char *, const char *, unsigned int, const char *, unsigned long int);
// mystrcpy
// file conf.h line 166
char * mystrcpy(char *to, const char *from);
// mystrdup
// file conf.h line 165
char * mystrdup(const char *from);
// mystrftime
// file motion.c line 3119
unsigned long int mystrftime(struct context *cnt, char *s, unsigned long int max, const char *userformat, struct tm *tm, const char *filename, signed int sqltype);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// netcam_check_buffsize
// file netcam.c line 1049
static void netcam_check_buffsize(struct netcam_image_buff *buff, unsigned long int numbytes);
// netcam_check_buffsize$link1
// file netcam_rtsp.c line 24
static void netcam_check_buffsize$link1(struct netcam_image_buff *buff$link1, unsigned long int numbytes$link1);
// netcam_check_close
// file netcam.c line 364
static signed int netcam_check_close(char *header);
// netcam_check_content_length
// file netcam.c line 301
static signed long int netcam_check_content_length(char *header);
// netcam_check_content_type
// file netcam.c line 398
static signed int netcam_check_content_type(char *header);
// netcam_check_keepalive
// file netcam.c line 336
static signed int netcam_check_keepalive(char *header);
// netcam_cleanup
// file netcam.h line 298
void netcam_cleanup(struct netcam_context *netcam, signed int init_retry_flag);
// netcam_connect
// file netcam.c line 861
static signed int netcam_connect(struct netcam_context *netcam, signed int err_flag);
// netcam_disconnect
// file netcam.c line 834
static void netcam_disconnect(struct netcam_context *netcam);
// netcam_error_exit
// file netcam_jpeg.c line 167
static void netcam_error_exit(struct jpeg_common_struct *cinfo);
// netcam_fill_input_buffer
// file netcam_jpeg.c line 59
static signed int netcam_fill_input_buffer(struct jpeg_decompress_struct *cinfo);
// netcam_get_dimensions
// file netcam.h line 294
void netcam_get_dimensions(struct netcam_context *netcam);
// netcam_handler_loop
// file netcam.c line 1913
static void * netcam_handler_loop(void *arg);
// netcam_http_build_url
// file netcam.c line 2104
static signed int netcam_http_build_url(struct netcam_context *netcam, struct url_t *url);
// netcam_http_request
// file netcam.c line 1387
static signed int netcam_http_request(struct netcam_context *netcam);
// netcam_image_conv
// file netcam_jpeg.c line 347
static signed int netcam_image_conv(struct netcam_context *netcam, struct jpeg_decompress_struct *cinfo, unsigned char *image);
// netcam_init_jpeg
// file netcam_jpeg.c line 242
static signed int netcam_init_jpeg(struct netcam_context *netcam, struct jpeg_decompress_struct *cinfo);
// netcam_init_source
// file netcam_jpeg.c line 48
static void netcam_init_source(struct jpeg_decompress_struct *cinfo);
// netcam_memory_src
// file netcam_jpeg.c line 129
static void netcam_memory_src(struct jpeg_decompress_struct *cinfo, char *data, signed int length);
// netcam_mjpg_buffer_refill
// file netcam.c line 1446
static signed int netcam_mjpg_buffer_refill(struct netcam_context *netcam);
// netcam_next
// file netcam.h line 297
signed int netcam_next(struct context *cnt, unsigned char *image);
// netcam_output_message
// file netcam_jpeg.c line 199
static void netcam_output_message(struct jpeg_common_struct *cinfo);
// netcam_proc_jpeg
// file netcam.h line 293
signed int netcam_proc_jpeg(struct netcam_context *netcam, unsigned char *image);
// netcam_read_file_jpeg
// file netcam.c line 1732
static signed int netcam_read_file_jpeg(struct netcam_context *netcam);
// netcam_read_first_header
// file netcam.c line 552
static signed int netcam_read_first_header(struct netcam_context *netcam);
// netcam_read_ftp_jpeg
// file netcam.c line 1650
static signed int netcam_read_ftp_jpeg(struct netcam_context *netcam);
// netcam_read_html_jpeg
// file netcam.c line 1132
static signed int netcam_read_html_jpeg(struct netcam_context *netcam);
// netcam_read_mjpg_jpeg
// file netcam.c line 1511
static signed int netcam_read_mjpg_jpeg(struct netcam_context *netcam);
// netcam_read_next_header
// file netcam.c line 439
static signed int netcam_read_next_header(struct netcam_context *netcam);
// netcam_read_rtsp_image
// file netcam_rtsp.h line 22
signed int netcam_read_rtsp_image(struct netcam_context *netcam);
// netcam_recv
// file netcam.c line 2499
signed long int netcam_recv(struct netcam_context *netcam, void *buffptr, unsigned long int buffsize);
// netcam_setup_file
// file netcam.c line 1876
static signed int netcam_setup_file(struct netcam_context *netcam, struct url_t *url);
// netcam_setup_ftp
// file netcam.c line 2361
static signed int netcam_setup_ftp(struct netcam_context *netcam, struct url_t *url);
// netcam_setup_html
// file netcam.c line 2285
static signed int netcam_setup_html(struct netcam_context *netcam, struct url_t *url);
// netcam_setup_mjpg
// file netcam.c line 2333
static signed int netcam_setup_mjpg(struct netcam_context *netcam, struct url_t *url);
// netcam_setup_rtsp
// file netcam.c line 2417
static signed int netcam_setup_rtsp(struct netcam_context *netcam, struct url_t *url);
// netcam_shutdown_rtsp
// file netcam_rtsp.c line 324
void netcam_shutdown_rtsp(struct netcam_context *netcam);
// netcam_skip_input_data
// file netcam_jpeg.c line 97
static void netcam_skip_input_data(struct jpeg_decompress_struct *cinfo, signed long int num_bytes);
// netcam_start
// file netcam.h line 296
signed int netcam_start(struct context *cnt);
// netcam_term_source
// file netcam_jpeg.c line 111
static void netcam_term_source(struct jpeg_decompress_struct *cinfo);
// netcam_url_free
// file netcam.c line 235
static void netcam_url_free(struct url_t *parse_url);
// netcam_url_match
// file netcam.c line 118
static char * netcam_url_match(struct anonymous$46 m, const char *input);
// netcam_url_parse
// file netcam.c line 148
static void netcam_url_parse(struct url_t *parse_url, const char *text_url);
// on_area_command
// file event.c line 218
static void on_area_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// on_event_end_command
// file event.c line 236
static void on_event_end_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// on_event_start_command
// file event.c line 227
static void on_event_start_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// on_motion_detected_command
// file event.c line 103
static void on_motion_detected_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm);
// on_movie_end_command
// file event.c line 402
static void on_movie_end_command(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm);
// on_picture_save_command
// file event.c line 90
static void on_picture_save_command(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// open_codec_context
// file netcam_rtsp.c line 83
static signed int open_codec_context(signed int *stream_idx, struct AVFormatContext *fmt_ctx, enum AVMediaType type);
// overlay_fixed_mask
// file picture.h line 16
void overlay_fixed_mask(struct context *cnt, unsigned char *out);
// overlay_largest_label
// file picture.h line 18
void overlay_largest_label(struct context *cnt, unsigned char *out);
// overlay_smartmask
// file picture.h line 15
void overlay_smartmask(struct context *cnt, unsigned char *out);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// preview_save
// file picture.h line 23
void preview_save(struct context *cnt);
// print_bool
// file conf.c line 2196
static const char * print_bool(struct context **cnt, char **str, signed int parm, unsigned int threadnr);
// print_int
// file conf.c line 2238
static const char * print_int(struct context **cnt, char **str, signed int parm, unsigned int threadnr);
// print_string
// file conf.c line 2221
static const char * print_string(struct context **cnt, char **str, signed int parm, unsigned int threadnr);
// print_thread
// file conf.c line 2254
static const char * print_thread(struct context **cnt, char **str, signed int parm, unsigned int threadnr);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_filter_graph
// file ffmpeg.c line 1082
static signed int process_filter_graph(struct AVPicture *dst, const struct AVPicture *src, enum AVPixelFormat pixfmt, signed int width, signed int height);
// process_image_ring
// file motion.c line 517
static void process_image_ring(struct context *cnt, unsigned int max_images);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 513
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous$44 *);
// pthread_cond_init
// file /usr/include/pthread.h line 968
extern signed int pthread_cond_init(union anonymous$44 *, const union anonymous$31 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 977
extern signed int pthread_cond_signal(union anonymous$44 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_timedwait(union anonymous$44 *, union anonymous$5 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous$44 *, union anonymous$5 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 242
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1119
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1111
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1116
extern signed int pthread_key_delete(unsigned int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous$5 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous$5 *, const union anonymous$31 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous$5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous$5 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 810
extern signed int pthread_mutexattr_destroy(union anonymous$31 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 806
extern signed int pthread_mutexattr_init(union anonymous$31 *);
// pthread_setspecific
// file /usr/include/pthread.h line 1122
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$16 *, struct anonymous$16 *);
// put_direntry
// file picture.c line 171
static void put_direntry(struct tiff_writing *into, const char *data, unsigned int length);
// put_fixed_mask
// file picture.h line 17
void put_fixed_mask(struct context *cnt, const char *file);
// put_jpeg_exif
// file picture.c line 224
static void put_jpeg_exif(struct jpeg_compress_struct *cinfo, struct context *cnt, struct tm *timestamp, struct coord *box);
// put_jpeg_grey_file
// file picture.c line 626
static void put_jpeg_grey_file(struct _IO_FILE *picture, unsigned char *image, signed int width, signed int height, signed int quality);
// put_jpeg_grey_memory
// file picture.c line 497
static signed int put_jpeg_grey_memory(unsigned char *dest_image, signed int image_size, unsigned char *input_image, signed int width, signed int height, signed int quality);
// put_jpeg_yuv420p_file
// file picture.c line 550
static void put_jpeg_yuv420p_file(struct _IO_FILE *fp, unsigned char *image, signed int width, signed int height, signed int quality, struct context *cnt, struct tm *tm, struct coord *box);
// put_jpeg_yuv420p_memory
// file picture.c line 416
static signed int put_jpeg_yuv420p_memory(unsigned char *dest_image, signed int image_size, unsigned char *input_image, signed int width, signed int height, signed int quality, struct context *cnt, struct tm *tm, struct coord *box);
// put_picture
// file picture.h line 21
void put_picture(struct context *cnt, char *file, unsigned char *image, signed int ftype);
// put_picture_fd
// file picture.c line 900
void put_picture_fd(struct context *cnt, struct _IO_FILE *picture, unsigned char *image, signed int quality);
// put_picture_memory
// file picture.c line 882
signed int put_picture_memory(struct context *cnt, unsigned char *dest_image, signed int image_size, unsigned char *image, signed int quality);
// put_ppm_bgr24_file
// file picture.c line 675
static void put_ppm_bgr24_file(struct _IO_FILE *picture, unsigned char *image, signed int width, signed int height);
// put_sint16
// file picture.c line 151
static void put_sint16(unsigned char *buf, signed int value);
// put_stringentry
// file picture.c line 192
static void put_stringentry(struct tiff_writing *into, unsigned int tag, const char *str, signed int with_nul);
// put_subjectarea
// file picture.c line 204
static void put_subjectarea(struct tiff_writing *into, struct coord *box);
// put_uint16
// file picture.c line 145
static void put_uint16(unsigned char *buf, unsigned int value);
// put_uint32
// file picture.c line 157
static void put_uint32(unsigned char *buf, unsigned int value);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// rbuf_flush
// file netcam_wget.h line 67
signed int rbuf_flush(struct netcam_context *netcam, char *where, signed int maxsize);
// rbuf_initialize
// file netcam_wget.h line 62
void rbuf_initialize(struct netcam_context *netcam);
// rbuf_peek
// file netcam_wget.c line 308
signed int rbuf_peek(struct netcam_context *netcam, char *store);
// rbuf_read_bufferful
// file netcam_wget.h line 70
signed int rbuf_read_bufferful(struct netcam_context *netcam);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_client
// file webhttpd.c line 2207
static unsigned int read_client(signed int client_socket, void *userdata, char *auth);
// read_http_request
// file stream.c line 69
static signed int read_http_request(signed int sock, char *buffer, signed int buflen, char *uri, signed int uri_len);
// read_nonblock
// file webhttpd.c line 220
static signed long int read_nonblock(signed int fd, void *buf, signed long int size);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$46 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// replace
// file webhttpd.c line 311
static char * replace(const char *str, const char *old, const char *new);
// response_client
// file webhttpd.c line 298
static void response_client(signed int client_socket, const char *template, char *back);
// reverse_inplace_quad
// file rotate.c line 137
static void reverse_inplace_quad(unsigned char *src, signed int size);
// rot90ccw
// file rotate.c line 200
static inline void rot90ccw(unsigned char *src, unsigned char *dst, signed int size, signed int width, signed int height);
// rot90cw
// file rotate.c line 167
static void rot90cw(unsigned char *src, unsigned char *dst, signed int size, signed int width, signed int height);
// rotate_deinit
// file rotate.h line 39
void rotate_deinit(struct context *cnt);
// rotate_init
// file rotate.h line 28
void rotate_init(struct context *cnt);
// rotate_map
// file rotate.h line 65
signed int rotate_map(struct context *cnt, unsigned char *map);
// rtsp_connect
// file netcam_rtsp.h line 21
signed int rtsp_connect(struct netcam_context *netcam);
// rtsp_free_context
// file netcam_rtsp.c line 147
static void rtsp_free_context(struct rtsp_context *ctxt);
// rtsp_new_context
// file netcam_rtsp.h line 19
struct rtsp_context * rtsp_new_context(void);
// sdl_put
// file sdl.h line 14
void sdl_put(unsigned char *image, signed int width, signed int height);
// sdl_start
// file sdl.h line 13
signed int sdl_start(signed int width, signed int height);
// sdl_stop
// file sdl.h line 15
void sdl_stop(void);
// sdl_video_open
// file sdl.c line 21
static signed int sdl_video_open(signed int width, signed int height);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$45 *, struct anonymous$45 *, struct anonymous$45 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_template
// file webhttpd.c line 269
static void send_template(signed int client_socket, char *res);
// send_template_end_client
// file webhttpd.c line 289
static void send_template_end_client(signed int client_socket);
// send_template_ini_client
// file webhttpd.c line 246
static void send_template_ini_client(signed int client_socket, const char *template);
// send_template_ini_client_raw
// file webhttpd.c line 258
static void send_template_ini_client_raw(signed int client_socket);
// send_template_raw
// file webhttpd.c line 280
static void send_template_raw(signed int client_socket, char *res);
// servo_center
// file track.c line 564
static unsigned int servo_center(struct context *cnt, signed int x_offset, signed int y_offset);
// servo_command
// file track.c line 327
static unsigned int servo_command(struct context *cnt, unsigned int motor, unsigned int command, unsigned int data);
// servo_move
// file track.c line 376
static unsigned int servo_move(struct context *cnt, struct coord *cent, struct images *imgs, unsigned int manual);
// servo_open
// file track.c line 294
static signed int servo_open(struct context *cnt);
// servo_position
// file track.c line 361
static unsigned int servo_position(struct context *cnt, unsigned int motor);
// set_log_level
// file logger.h line 58
void set_log_level(unsigned int level);
// set_log_mode
// file logger.h line 59
void set_log_mode(signed int mode);
// set_log_type
// file logger.h line 56
void set_log_type(unsigned int type);
// set_logfile
// file logger.h line 60
struct _IO_FILE * set_logfile(const char *logfile_name);
// set_sock_timeout
// file stream.c line 49
static signed int set_sock_timeout(signed int sock, signed int sec);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setpgrp
// file /usr/include/unistd.h line 663
extern signed int setpgrp(void);
// setsid
// file /usr/include/unistd.h line 670
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_signals
// file motion.c line 2531
static void setup_signals(struct sigaction *sig_handler_action, struct sigaction *sigchild_action);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// sig_handler
// file motion.c line 294
static void sig_handler(signed int signo);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous$16 *, signed int);
// sigchild_handler
// file motion.c line 367
static void sigchild_handler(signed int signo);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous$16 *);
// skip_input_data
// file jpegutils.c line 99
static void skip_input_data(struct jpeg_decompress_struct *cinfo, signed long int num_bytes);
// skip_lws
// file netcam_wget.c line 201
signed int skip_lws(const char *string);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sonix_decompress
// file video.h line 97
signed int sonix_decompress(unsigned char *outp, unsigned char *inp, signed int width, signed int height);
// sonix_decompress_init
// file video_common.c line 37
static void sonix_decompress_init(struct anonymous$39 *table);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqlite3_close
// file /usr/include/sqlite3.h line 313
signed int sqlite3_close(struct sqlite3 *);
// sqlite3_errmsg
// file /usr/include/sqlite3.h line 3131
const char * sqlite3_errmsg(struct sqlite3 *);
// sqlite3_exec
// file /usr/include/sqlite3.h line 385
signed int sqlite3_exec(struct sqlite3 *, const char *, signed int (*)(void *, signed int, char **, char **), void *, char **);
// sqlite3_free
// file /usr/include/sqlite3.h line 2526
void sqlite3_free(void *);
// sqlite3_open
// file /usr/include/sqlite3.h line 3029
signed int sqlite3_open(const char *, struct sqlite3 **);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_motion_thread
// file motion.c line 2571
static void start_motion_thread(struct context *cnt, union pthread_attr_t *thread_attr);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// std_huff_tables
// file jpegutils.c line 336
static void std_huff_tables(struct jpeg_decompress_struct *dinfo);
// stepper_center
// file track.c line 173
static unsigned int stepper_center(struct context *cnt, signed int x_offset, signed int y_offset);
// stepper_command
// file track.c line 140
static unsigned int stepper_command(struct context *cnt, unsigned int motor, unsigned int command, unsigned int data);
// stepper_move
// file track.c line 232
static unsigned int stepper_move(struct context *cnt, struct coord *cent, struct images *imgs);
// stepper_status
// file track.c line 167
static unsigned int stepper_status(struct context *cnt, unsigned int motor);
// str_time
// file logger.c line 127
static char * str_time(void);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strdupdelim
// file netcam_wget.c line 258
char * strdupdelim(const char *beg, const char *end);
// stream_add_client
// file stream.c line 947
static void stream_add_client(struct stream *list, signed int sc);
// stream_add_write
// file stream.c line 984
static void stream_add_write(struct stream *list, struct stream_buffer *tmpbuffer, unsigned int fps);
// stream_check_write
// file stream.c line 1019
static signed int stream_check_write(struct stream *list);
// stream_flush
// file stream.c line 823
static void stream_flush(struct stream *list, signed int *stream_count, signed int lim);
// stream_init
// file stream.h line 41
signed int stream_init(struct context *cnt);
// stream_put
// file stream.h line 42
void stream_put(struct context *cnt, unsigned char *image);
// stream_stop
// file stream.h line 43
void stream_stop(struct context *cnt);
// stream_tmpbuffer
// file stream.c line 933
static struct stream_buffer * stream_tmpbuffer(signed int size);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 433
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 533
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// symlink
// file /usr/include/unistd.h line 806
extern signed int symlink(const char *, const char *);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tcflush
// file /usr/include/termios.h line 90
extern signed int tcflush(signed int, signed int);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// term_destination
// file jpegutils.c line 207
static void term_destination(struct jpeg_compress_struct *cinfo);
// term_destination$link1
// file picture.c line 53
static void term_destination$link1(struct jpeg_compress_struct *cinfo$link1);
// term_source
// file jpegutils.c line 114
static void term_source(struct jpeg_decompress_struct *cinfo);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// track
// file webhttpd.c line 1272
static unsigned int track(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata);
// track_center
// file track.h line 45
unsigned int track_center(struct context *cnt, signed int dev, unsigned int manual, signed int xoff, signed int yoff);
// track_move
// file track.h line 46
unsigned int track_move(struct context *cnt, signed int dev, struct coord *cent, struct images *imgs, unsigned int manual);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// url_decode
// file webhttpd.c line 347
static void url_decode(char *urlencoded, unsigned long int length);
// usage
// file conf.c line 2355
static void usage(void);
// v4l2_cleanup
// file video2.c line 1090
void v4l2_cleanup(struct video_dev *viddev);
// v4l2_close
// file video2.c line 1076
void v4l2_close(struct video_dev *viddev);
// v4l2_do_set_pix_format
// file video2.c line 394
static signed int v4l2_do_set_pix_format(unsigned int pixformat, struct anonymous$29 *vid_source, signed int *width, signed int *height);
// v4l2_get_capability
// file video2.c line 196
static signed int v4l2_get_capability(struct anonymous$29 *vid_source);
// v4l2_next
// file video2.c line 943
signed int v4l2_next(struct context *cnt, struct video_dev *viddev, unsigned char *map, signed int width, signed int height);
// v4l2_picture_controls
// file video2.c line 768
static void v4l2_picture_controls(struct context *cnt, struct video_dev *viddev);
// v4l2_scan_controls
// file video2.c line 661
static signed int v4l2_scan_controls(struct anonymous$29 *vid_source);
// v4l2_select_input
// file video2.c line 247
static signed int v4l2_select_input(struct config *conf, struct video_dev *viddev, struct anonymous$29 *vid_source, signed int in, signed int norm, unsigned long int freq_, signed int tuner_number);
// v4l2_set_control
// file video2.c line 718
static signed int v4l2_set_control(struct anonymous$29 *vid_source, unsigned int cid, signed int value);
// v4l2_set_input
// file video2.c line 868
void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, signed int width, signed int height, struct config *conf);
// v4l2_set_mmap
// file video2.c line 565
static signed int v4l2_set_mmap(struct anonymous$29 *vid_source);
// v4l2_set_pix_format
// file video2.c line 447
static signed int v4l2_set_pix_format(struct context *cnt, struct anonymous$29 *vid_source, signed int *width, signed int *height);
// v4l2_start
// file video2.c line 806
unsigned char * v4l2_start(struct context *cnt, struct video_dev *viddev, signed int width, signed int height, signed int input, signed int norm, unsigned long int freq, signed int tuner_number);
// vid_cleanup
// file video.h line 92
void vid_cleanup(void);
// vid_close
// file video.h line 91
void vid_close(struct context *cnt);
// vid_do_autobright
// file video.h line 99
signed int vid_do_autobright(struct context *cnt, struct video_dev *viddev);
// vid_init
// file video.h line 93
void vid_init(void);
// vid_next
// file video.h line 90
signed int vid_next(struct context *cnt, unsigned char *map);
// vid_start
// file video.h line 89
signed int vid_start(struct context *cnt);
// vid_v4lx_start
// file video_common.c line 649
static signed int vid_v4lx_start(struct context *cnt);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// write_nonblock
// file webhttpd.c line 194
static signed long int write_nonblock(signed int fd, const void *buf, unsigned long int size);
// xioctl
// file video2.c line 182
static signed int xioctl(signed int fd, signed int request, void *arg);

struct anonymous$27
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$24
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous$25
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous$24 si_addr_bnd;
};

struct anonymous
{
  // param_name
  const char *param_name;
  // param_help
  const char *param_help;
  // main_thread
  unsigned int main_thread;
  // conf_value
  signed int conf_value;
  // copy
  struct context ** (*copy)(struct context **, const char *, signed int);
  // print
  const char * (*print)(struct context **, char **, signed int, unsigned int);
};

struct anonymous$45
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$16
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$14
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous$47
{
  // mh_magic
  char mh_magic[4l];
  // mh_framesize
  unsigned int mh_framesize;
  // mh_framewidth
  unsigned short int mh_framewidth;
  // mh_frameheight
  unsigned short int mh_frameheight;
  // mh_frameoffset
  unsigned int mh_frameoffset;
  // mh_chunksize
  unsigned short int mh_chunksize;
  // mh_reserved
  char mh_reserved[30l];
};

struct anonymous$30
{
  // state
  unsigned int state[4l];
  // count
  unsigned int count[2l];
  // buffer
  unsigned char buffer[64l];
};

struct anonymous$13
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous$1
{
  // y
  signed short int y;
  // xl
  signed short int xl;
  // xr
  signed short int xr;
  // dy
  signed short int dy;
};

struct anonymous$9
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$15
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous$13 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous$22
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct v4l2_capability
{
  // driver
  unsigned char driver[16l];
  // card
  unsigned char card[32l];
  // bus_info
  unsigned char bus_info[32l];
  // version
  unsigned int version;
  // capabilities
  unsigned int capabilities;
  // device_caps
  unsigned int device_caps;
  // reserved
  unsigned int reserved[3l];
};

struct v4l2_pix_format
{
  // width
  unsigned int width;
  // height
  unsigned int height;
  // pixelformat
  unsigned int pixelformat;
  // field
  unsigned int field;
  // bytesperline
  unsigned int bytesperline;
  // sizeimage
  unsigned int sizeimage;
  // colorspace
  unsigned int colorspace;
  // priv
  unsigned int priv;
  // flags
  unsigned int flags;
  // ycbcr_enc
  unsigned int ycbcr_enc;
  // quantization
  unsigned int quantization;
  // xfer_func
  unsigned int xfer_func;
};

struct v4l2_plane_pix_format
{
  // sizeimage
  unsigned int sizeimage;
  // bytesperline
  unsigned int bytesperline;
  // reserved
  unsigned short int reserved[6l];
} __attribute__ ((__packed__));

struct v4l2_pix_format_mplane
{
  // width
  unsigned int width;
  // height
  unsigned int height;
  // pixelformat
  unsigned int pixelformat;
  // field
  unsigned int field;
  // colorspace
  unsigned int colorspace;
  // plane_fmt
  struct v4l2_plane_pix_format plane_fmt[8l];
  // num_planes
  unsigned char num_planes;
  // flags
  unsigned char flags;
  // ycbcr_enc
  unsigned char ycbcr_enc;
  // quantization
  unsigned char quantization;
  // xfer_func
  unsigned char xfer_func;
  // reserved
  unsigned char reserved[7l];
} __attribute__ ((__packed__));

struct v4l2_rect
{
  // left
  signed int left;
  // top
  signed int top;
  // width
  unsigned int width;
  // height
  unsigned int height;
};

struct v4l2_window
{
  // w
  struct v4l2_rect w;
  // field
  unsigned int field;
  // chromakey
  unsigned int chromakey;
  // clips
  struct v4l2_clip *clips;
  // clipcount
  unsigned int clipcount;
  // bitmap
  void *bitmap;
  // global_alpha
  unsigned char global_alpha;
};

struct v4l2_vbi_format
{
  // sampling_rate
  unsigned int sampling_rate;
  // offset
  unsigned int offset;
  // samples_per_line
  unsigned int samples_per_line;
  // sample_format
  unsigned int sample_format;
  // start
  signed int start[2l];
  // count
  unsigned int count[2l];
  // flags
  unsigned int flags;
  // reserved
  unsigned int reserved[2l];
};

struct v4l2_sliced_vbi_format
{
  // service_set
  unsigned short int service_set;
  // service_lines
  unsigned short int service_lines[2l][24l];
  // io_size
  unsigned int io_size;
  // reserved
  unsigned int reserved[2l];
};

struct v4l2_sdr_format
{
  // pixelformat
  unsigned int pixelformat;
  // buffersize
  unsigned int buffersize;
  // reserved
  unsigned char reserved[24l];
} __attribute__ ((__packed__));

union anonymous$35
{
  // pix
  struct v4l2_pix_format pix;
  // pix_mp
  struct v4l2_pix_format_mplane pix_mp;
  // win
  struct v4l2_window win;
  // vbi
  struct v4l2_vbi_format vbi;
  // sliced
  struct v4l2_sliced_vbi_format sliced;
  // sdr
  struct v4l2_sdr_format sdr;
  // raw_data
  unsigned char raw_data[200l];
};

struct v4l2_format
{
  // type
  unsigned int type;
  // fmt
  union anonymous$35 fmt;
};

struct v4l2_requestbuffers
{
  // count
  unsigned int count;
  // type
  unsigned int type;
  // memory
  unsigned int memory;
  // reserved
  unsigned int reserved[2l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct v4l2_timecode
{
  // type
  unsigned int type;
  // flags
  unsigned int flags;
  // frames
  unsigned char frames;
  // seconds
  unsigned char seconds;
  // minutes
  unsigned char minutes;
  // hours
  unsigned char hours;
  // userbits
  unsigned char userbits[4l];
};

union anonymous$34
{
  // offset
  unsigned int offset;
  // userptr
  unsigned long int userptr;
  // planes
  struct v4l2_plane *planes;
  // fd
  signed int fd;
};

struct v4l2_buffer
{
  // index
  unsigned int index;
  // type
  unsigned int type;
  // bytesused
  unsigned int bytesused;
  // flags
  unsigned int flags;
  // field
  unsigned int field;
  // timestamp
  struct timeval timestamp;
  // timecode
  struct v4l2_timecode timecode;
  // sequence
  unsigned int sequence;
  // memory
  unsigned int memory;
  // m
  union anonymous$34 m;
  // length
  unsigned int length;
  // reserved2
  unsigned int reserved2;
  // reserved
  unsigned int reserved;
};

struct anonymous$29
{
  // fd
  signed int fd;
  // fps
  unsigned int fps;
  // cap
  struct v4l2_capability cap;
  // src_fmt
  struct v4l2_format src_fmt;
  // dst_fmt
  struct v4l2_format dst_fmt;
  // req
  struct v4l2_requestbuffers req;
  // buf
  struct v4l2_buffer buf;
  // buffers
  struct video_image_buff *buffers;
  // pframe
  signed int pframe;
  // ctrl_flags
  unsigned int ctrl_flags;
  // controls
  struct v4l2_queryctrl *controls;
};

struct anonymous$39
{
  // is_abs
  signed int is_abs;
  // len
  signed int len;
  // val
  signed int val;
};

struct anonymous$46
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$19
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$23
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$21
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$20
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$26
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$28
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$19 _kill;
  // _timer
  struct anonymous$20 _timer;
  // _rt
  struct anonymous$21 _rt;
  // _sigchld
  struct anonymous$23 _sigchld;
  // _sigfault
  struct anonymous$25 _sigfault;
  // _sigpoll
  struct anonymous$26 _sigpoll;
  // _sigsys
  struct anonymous$27 _sigsys;
};

struct anonymous$18
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$28 _sifields;
};

struct anonymous$6
{
  // last_dts
  signed long int last_dts;
  // duration_gcd
  signed long int duration_gcd;
  // duration_count
  signed int duration_count;
  // rfps_duration_sum
  signed long int rfps_duration_sum;
  // duration_error
  double (*duration_error)[2l][399l];
  // codec_info_duration
  signed long int codec_info_duration;
  // codec_info_duration_fields
  signed long int codec_info_duration_fields;
  // found_decoder
  signed int found_decoder;
  // last_duration
  signed long int last_duration;
  // fps_first_dts
  signed long int fps_first_dts;
  // fps_first_dts_idx
  signed int fps_first_dts_idx;
  // fps_last_dts
  signed long int fps_last_dts;
  // fps_last_dts_idx
  signed int fps_last_dts_idx;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct anonymous$8
{
  // pub
  struct jpeg_destination_mgr pub;
  // buf
  unsigned char *buf;
  // bufsize
  unsigned long int bufsize;
  // jpegsize
  unsigned long int jpegsize;
};

struct jpeg_source_mgr
{
  // next_input_byte
  const unsigned char *next_input_byte;
  // bytes_in_buffer
  unsigned long int bytes_in_buffer;
  // init_source
  void (*init_source)(struct jpeg_decompress_struct *);
  // fill_input_buffer
  signed int (*fill_input_buffer)(struct jpeg_decompress_struct *);
  // skip_input_data
  void (*skip_input_data)(struct jpeg_decompress_struct *, signed long int);
  // resync_to_restart
  signed int (*resync_to_restart)(struct jpeg_decompress_struct *, signed int);
  // term_source
  void (*term_source)(struct jpeg_decompress_struct *);
};

struct anonymous$0
{
  // pub
  struct jpeg_source_mgr pub;
  // data
  char *data;
  // length
  signed int length;
  // buffer
  unsigned char *buffer;
  // start_of_file
  signed int start_of_file;
};

union anonymous$3
{
  // client_ip
  char *client_ip;
  // bind_address
  char *bind_address;
};

union anonymous$17
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$18 *, void *);
};

union anonymous$42
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$31
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$40
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous$2
{
  // q
  signed long long int q;
  // uq
  unsigned long long int uq;
  // d
  signed int d[2l];
  // ud
  unsigned int ud[2l];
  // w
  signed short int w[4l];
  // uw
  unsigned short int uw[4l];
  // b
  char b[8l];
  // ub
  unsigned char ub[8l];
  // s
  float s[2l];
};

union anonymous$44
{
  // __data
  struct anonymous$9 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$32
{
  // mem_offset
  unsigned int mem_offset;
  // userptr
  unsigned long int userptr;
  // fd
  signed int fd;
};

union anonymous$43
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct AVBufferRef
{
  // buffer
  struct AVBuffer *buffer;
  // data
  unsigned char *data;
  // size
  signed int size;
};

struct AVRational
{
  // num
  signed int num;
  // den
  signed int den;
};

struct AVChapter
{
  // id
  signed int id;
  // time_base
  struct AVRational time_base;
  // start
  signed long int start;
  // end
  signed long int end;
  // metadata
  struct AVDictionary *metadata;
};

struct AVClass
{
  // class_name
  const char *class_name;
  // item_name
  const char * (*item_name)(void *);
  // option
  const struct AVOption *option;
  // version
  signed int version;
  // log_level_offset_offset
  signed int log_level_offset_offset;
  // parent_log_context_offset
  signed int parent_log_context_offset;
  // child_next
  void * (*child_next)(void *, void *);
  // child_class_next
  struct AVClass * (*child_class_next)(struct AVClass *);
  // category
  enum anonymous$36 category;
  // get_category
  enum anonymous$36 (*get_category)(void *);
  // query_ranges
  signed int (*query_ranges)(struct AVOptionRanges **, void *, const char *, signed int);
};

struct AVCodec
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // capabilities
  signed int capabilities;
  // supported_framerates
  const struct AVRational *supported_framerates;
  // pix_fmts
  const enum AVPixelFormat *pix_fmts;
  // supported_samplerates
  const signed int *supported_samplerates;
  // sample_fmts
  const enum AVSampleFormat *sample_fmts;
  // channel_layouts
  const unsigned long int *channel_layouts;
  // max_lowres
  unsigned char max_lowres;
  // priv_class
  const struct AVClass *priv_class;
  // profiles
  const struct AVProfile *profiles;
  // priv_data_size
  signed int priv_data_size;
  // next
  struct AVCodec *next;
  // init_thread_copy
  signed int (*init_thread_copy)(struct AVCodecContext *);
  // update_thread_context
  signed int (*update_thread_context)(struct AVCodecContext *, const struct AVCodecContext *);
  // defaults
  const struct AVCodecDefault *defaults;
  // init_static_data
  void (*init_static_data)(struct AVCodec *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // encode_sub
  signed int (*encode_sub)(struct AVCodecContext *, unsigned char *, signed int, struct AVSubtitle *);
  // encode2
  signed int (*encode2)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
  // decode
  signed int (*decode)(struct AVCodecContext *, void *, signed int *, struct AVPacket *);
  // close
  signed int (*close)(struct AVCodecContext *);
  // flush
  void (*flush)(struct AVCodecContext *);
  // caps_internal
  signed int caps_internal;
};

struct AVCodecContext
{
  // av_class
  const struct AVClass *av_class;
  // log_level_offset
  signed int log_level_offset;
  // codec_type
  enum AVMediaType codec_type;
  // codec
  struct AVCodec *codec;
  // codec_name
  char codec_name[32l];
  // codec_id
  enum AVCodecID codec_id;
  // codec_tag
  unsigned int codec_tag;
  // stream_codec_tag
  unsigned int stream_codec_tag;
  // priv_data
  void *priv_data;
  // internal
  struct AVCodecInternal *internal;
  // opaque
  void *opaque;
  // bit_rate
  signed int bit_rate;
  // bit_rate_tolerance
  signed int bit_rate_tolerance;
  // global_quality
  signed int global_quality;
  // compression_level
  signed int compression_level;
  // flags
  signed int flags;
  // flags2
  signed int flags2;
  // extradata
  unsigned char *extradata;
  // extradata_size
  signed int extradata_size;
  // time_base
  struct AVRational time_base;
  // ticks_per_frame
  signed int ticks_per_frame;
  // delay
  signed int delay;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // gop_size
  signed int gop_size;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // me_method
  signed int me_method;
  // draw_horiz_band
  void (*draw_horiz_band)(struct AVCodecContext *, const struct AVFrame *, signed int *, signed int, signed int, signed int);
  // get_format
  enum AVPixelFormat (*get_format)(struct AVCodecContext *, const enum AVPixelFormat *);
  // max_b_frames
  signed int max_b_frames;
  // b_quant_factor
  float b_quant_factor;
  // rc_strategy
  signed int rc_strategy;
  // b_frame_strategy
  signed int b_frame_strategy;
  // b_quant_offset
  float b_quant_offset;
  // has_b_frames
  signed int has_b_frames;
  // mpeg_quant
  signed int mpeg_quant;
  // i_quant_factor
  float i_quant_factor;
  // i_quant_offset
  float i_quant_offset;
  // lumi_masking
  float lumi_masking;
  // temporal_cplx_masking
  float temporal_cplx_masking;
  // spatial_cplx_masking
  float spatial_cplx_masking;
  // p_masking
  float p_masking;
  // dark_masking
  float dark_masking;
  // slice_count
  signed int slice_count;
  // prediction_method
  signed int prediction_method;
  // slice_offset
  signed int *slice_offset;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // me_cmp
  signed int me_cmp;
  // me_sub_cmp
  signed int me_sub_cmp;
  // mb_cmp
  signed int mb_cmp;
  // ildct_cmp
  signed int ildct_cmp;
  // dia_size
  signed int dia_size;
  // last_predictor_count
  signed int last_predictor_count;
  // pre_me
  signed int pre_me;
  // me_pre_cmp
  signed int me_pre_cmp;
  // pre_dia_size
  signed int pre_dia_size;
  // me_subpel_quality
  signed int me_subpel_quality;
  // dtg_active_format
  signed int dtg_active_format;
  // me_range
  signed int me_range;
  // intra_quant_bias
  signed int intra_quant_bias;
  // inter_quant_bias
  signed int inter_quant_bias;
  // slice_flags
  signed int slice_flags;
  // xvmc_acceleration
  signed int xvmc_acceleration;
  // mb_decision
  signed int mb_decision;
  // intra_matrix
  unsigned short int *intra_matrix;
  // inter_matrix
  unsigned short int *inter_matrix;
  // scenechange_threshold
  signed int scenechange_threshold;
  // noise_reduction
  signed int noise_reduction;
  // me_threshold
  signed int me_threshold;
  // mb_threshold
  signed int mb_threshold;
  // intra_dc_precision
  signed int intra_dc_precision;
  // skip_top
  signed int skip_top;
  // skip_bottom
  signed int skip_bottom;
  // border_masking
  float border_masking;
  // mb_lmin
  signed int mb_lmin;
  // mb_lmax
  signed int mb_lmax;
  // me_penalty_compensation
  signed int me_penalty_compensation;
  // bidir_refine
  signed int bidir_refine;
  // brd_scale
  signed int brd_scale;
  // keyint_min
  signed int keyint_min;
  // refs
  signed int refs;
  // chromaoffset
  signed int chromaoffset;
  // scenechange_factor
  signed int scenechange_factor;
  // mv0_threshold
  signed int mv0_threshold;
  // b_sensitivity
  signed int b_sensitivity;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // color_range
  enum AVColorRange color_range;
  // chroma_sample_location
  enum AVChromaLocation chroma_sample_location;
  // slices
  signed int slices;
  // field_order
  enum AVFieldOrder field_order;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
  // sample_fmt
  enum AVSampleFormat sample_fmt;
  // frame_size
  signed int frame_size;
  // frame_number
  signed int frame_number;
  // block_align
  signed int block_align;
  // cutoff
  signed int cutoff;
  // request_channels
  signed int request_channels;
  // channel_layout
  unsigned long int channel_layout;
  // request_channel_layout
  unsigned long int request_channel_layout;
  // audio_service_type
  enum AVAudioServiceType audio_service_type;
  // request_sample_fmt
  enum AVSampleFormat request_sample_fmt;
  // get_buffer
  signed int (*get_buffer)(struct AVCodecContext *, struct AVFrame *);
  // release_buffer
  void (*release_buffer)(struct AVCodecContext *, struct AVFrame *);
  // reget_buffer
  signed int (*reget_buffer)(struct AVCodecContext *, struct AVFrame *);
  // get_buffer2
  signed int (*get_buffer2)(struct AVCodecContext *, struct AVFrame *, signed int);
  // refcounted_frames
  signed int refcounted_frames;
  // qcompress
  float qcompress;
  // qblur
  float qblur;
  // qmin
  signed int qmin;
  // qmax
  signed int qmax;
  // max_qdiff
  signed int max_qdiff;
  // rc_qsquish
  float rc_qsquish;
  // rc_qmod_amp
  float rc_qmod_amp;
  // rc_qmod_freq
  signed int rc_qmod_freq;
  // rc_buffer_size
  signed int rc_buffer_size;
  // rc_override_count
  signed int rc_override_count;
  // rc_override
  struct RcOverride *rc_override;
  // rc_eq
  const char *rc_eq;
  // rc_max_rate
  signed int rc_max_rate;
  // rc_min_rate
  signed int rc_min_rate;
  // rc_buffer_aggressivity
  float rc_buffer_aggressivity;
  // rc_initial_cplx
  float rc_initial_cplx;
  // rc_max_available_vbv_use
  float rc_max_available_vbv_use;
  // rc_min_vbv_overflow_use
  float rc_min_vbv_overflow_use;
  // rc_initial_buffer_occupancy
  signed int rc_initial_buffer_occupancy;
  // coder_type
  signed int coder_type;
  // context_model
  signed int context_model;
  // lmin
  signed int lmin;
  // lmax
  signed int lmax;
  // frame_skip_threshold
  signed int frame_skip_threshold;
  // frame_skip_factor
  signed int frame_skip_factor;
  // frame_skip_exp
  signed int frame_skip_exp;
  // frame_skip_cmp
  signed int frame_skip_cmp;
  // trellis
  signed int trellis;
  // min_prediction_order
  signed int min_prediction_order;
  // max_prediction_order
  signed int max_prediction_order;
  // timecode_frame_start
  signed long int timecode_frame_start;
  // rtp_callback
  void (*rtp_callback)(struct AVCodecContext *, void *, signed int, signed int);
  // rtp_payload_size
  signed int rtp_payload_size;
  // mv_bits
  signed int mv_bits;
  // header_bits
  signed int header_bits;
  // i_tex_bits
  signed int i_tex_bits;
  // p_tex_bits
  signed int p_tex_bits;
  // i_count
  signed int i_count;
  // p_count
  signed int p_count;
  // skip_count
  signed int skip_count;
  // misc_bits
  signed int misc_bits;
  // frame_bits
  signed int frame_bits;
  // stats_out
  char *stats_out;
  // stats_in
  char *stats_in;
  // workaround_bugs
  signed int workaround_bugs;
  // strict_std_compliance
  signed int strict_std_compliance;
  // error_concealment
  signed int error_concealment;
  // debug
  signed int debug;
  // debug_mv
  signed int debug_mv;
  // err_recognition
  signed int err_recognition;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel
  struct AVHWAccel *hwaccel;
  // hwaccel_context
  void *hwaccel_context;
  // error
  unsigned long int error[8l];
  // dct_algo
  signed int dct_algo;
  // idct_algo
  signed int idct_algo;
  // bits_per_coded_sample
  signed int bits_per_coded_sample;
  // bits_per_raw_sample
  signed int bits_per_raw_sample;
  // lowres
  signed int lowres;
  // coded_frame
  struct AVFrame *coded_frame;
  // thread_count
  signed int thread_count;
  // thread_type
  signed int thread_type;
  // active_thread_type
  signed int active_thread_type;
  // thread_safe_callbacks
  signed int thread_safe_callbacks;
  // execute
  signed int (*execute)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *), void *, signed int *, signed int, signed int);
  // execute2
  signed int (*execute2)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // thread_opaque
  void *thread_opaque;
  // nsse_weight
  signed int nsse_weight;
  // profile
  signed int profile;
  // level
  signed int level;
  // skip_loop_filter
  enum AVDiscard skip_loop_filter;
  // skip_idct
  enum AVDiscard skip_idct;
  // skip_frame
  enum AVDiscard skip_frame;
  // subtitle_header
  unsigned char *subtitle_header;
  // subtitle_header_size
  signed int subtitle_header_size;
  // error_rate
  signed int error_rate;
  // pkt
  struct AVPacket *pkt;
  // vbv_delay
  unsigned long int vbv_delay;
  // side_data_only_packets
  signed int side_data_only_packets;
  // initial_padding
  signed int initial_padding;
  // framerate
  struct AVRational framerate;
  // sw_pix_fmt
  enum AVPixelFormat sw_pix_fmt;
  // pkt_timebase
  struct AVRational pkt_timebase;
  // codec_descriptor
  const struct AVCodecDescriptor *codec_descriptor;
  // pts_correction_num_faulty_pts
  signed long int pts_correction_num_faulty_pts;
  // pts_correction_num_faulty_dts
  signed long int pts_correction_num_faulty_dts;
  // pts_correction_last_pts
  signed long int pts_correction_last_pts;
  // pts_correction_last_dts
  signed long int pts_correction_last_dts;
  // sub_charenc
  char *sub_charenc;
  // sub_charenc_mode
  signed int sub_charenc_mode;
  // skip_alpha
  signed int skip_alpha;
  // seek_preroll
  signed int seek_preroll;
  // chroma_intra_matrix
  unsigned short int *chroma_intra_matrix;
  // dump_separator
  unsigned char *dump_separator;
  // codec_whitelist
  char *codec_whitelist;
  // properties
  unsigned int properties;
};

struct AVCodecDescriptor
{
  // id
  enum AVCodecID id;
  // type
  enum AVMediaType type;
  // name
  const char *name;
  // long_name
  const char *long_name;
  // props
  signed int props;
  // mime_types
  const char * const *mime_types;
};

struct AVCodecParser
{
  // codec_ids
  signed int codec_ids[5l];
  // priv_data_size
  signed int priv_data_size;
  // parser_init
  signed int (*parser_init)(struct AVCodecParserContext *);
  // parser_parse
  signed int (*parser_parse)(struct AVCodecParserContext *, struct AVCodecContext *, const unsigned char **, signed int *, const unsigned char *, signed int);
  // parser_close
  void (*parser_close)(struct AVCodecParserContext *);
  // split
  signed int (*split)(struct AVCodecContext *, const unsigned char *, signed int);
  // next
  struct AVCodecParser *next;
};

struct AVCodecParserContext
{
  // priv_data
  void *priv_data;
  // parser
  struct AVCodecParser *parser;
  // frame_offset
  signed long int frame_offset;
  // cur_offset
  signed long int cur_offset;
  // next_frame_offset
  signed long int next_frame_offset;
  // pict_type
  signed int pict_type;
  // repeat_pict
  signed int repeat_pict;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // last_pts
  signed long int last_pts;
  // last_dts
  signed long int last_dts;
  // fetch_timestamp
  signed int fetch_timestamp;
  // cur_frame_start_index
  signed int cur_frame_start_index;
  // cur_frame_offset
  signed long int cur_frame_offset[4l];
  // cur_frame_pts
  signed long int cur_frame_pts[4l];
  // cur_frame_dts
  signed long int cur_frame_dts[4l];
  // flags
  signed int flags;
  // offset
  signed long int offset;
  // cur_frame_end
  signed long int cur_frame_end[4l];
  // key_frame
  signed int key_frame;
  // convergence_duration
  signed long int convergence_duration;
  // dts_sync_point
  signed int dts_sync_point;
  // dts_ref_dts_delta
  signed int dts_ref_dts_delta;
  // pts_dts_delta
  signed int pts_dts_delta;
  // cur_frame_pos
  signed long int cur_frame_pos[4l];
  // pos
  signed long int pos;
  // last_pos
  signed long int last_pos;
  // duration
  signed int duration;
  // field_order
  enum AVFieldOrder field_order;
  // picture_structure
  enum AVPictureStructure picture_structure;
  // output_picture_number
  signed int output_picture_number;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // format
  signed int format;
};

struct AVFilter
{
  // name
  const char *name;
  // description
  const char *description;
  // inputs
  const struct AVFilterPad *inputs;
  // outputs
  const struct AVFilterPad *outputs;
  // priv_class
  const struct AVClass *priv_class;
  // flags
  signed int flags;
  // init
  signed int (*init)(struct AVFilterContext *);
  // init_dict
  signed int (*init_dict)(struct AVFilterContext *, struct AVDictionary **);
  // uninit
  void (*uninit)(struct AVFilterContext *);
  // query_formats
  signed int (*query_formats)(struct AVFilterContext *);
  // priv_size
  signed int priv_size;
  // next
  struct AVFilter *next;
  // process_command
  signed int (*process_command)(struct AVFilterContext *, const char *, const char *, char *, signed int, signed int);
  // init_opaque
  signed int (*init_opaque)(struct AVFilterContext *, void *);
};

struct AVFilterBuffer
{
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // priv
  void *priv;
  // free
  void (*free)(struct AVFilterBuffer *);
  // format
  signed int format;
  // w
  signed int w;
  // h
  signed int h;
  // refcount
  unsigned int refcount;
};

struct AVFilterBufferRef
{
  // buf
  struct AVFilterBuffer *buf;
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // video
  struct AVFilterBufferRefVideoProps *video;
  // audio
  struct AVFilterBufferRefAudioProps *audio;
  // pts
  signed long int pts;
  // pos
  signed long int pos;
  // format
  signed int format;
  // perms
  signed int perms;
  // type
  enum AVMediaType type;
  // metadata
  struct AVDictionary *metadata;
};

struct AVFilterBufferRefAudioProps
{
  // channel_layout
  unsigned long int channel_layout;
  // nb_samples
  signed int nb_samples;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
};

struct AVFilterBufferRefVideoProps
{
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // interlaced
  signed int interlaced;
  // top_field_first
  signed int top_field_first;
  // pict_type
  enum AVPictureType pict_type;
  // key_frame
  signed int key_frame;
  // qp_table_linesize
  signed int qp_table_linesize;
  // qp_table_size
  signed int qp_table_size;
  // qp_table
  signed char *qp_table;
};

struct AVFilterContext
{
  // av_class
  const struct AVClass *av_class;
  // filter
  const struct AVFilter *filter;
  // name
  char *name;
  // input_pads
  struct AVFilterPad *input_pads;
  // inputs
  struct AVFilterLink **inputs;
  // input_count
  unsigned int input_count;
  // nb_inputs
  unsigned int nb_inputs;
  // output_pads
  struct AVFilterPad *output_pads;
  // outputs
  struct AVFilterLink **outputs;
  // output_count
  unsigned int output_count;
  // nb_outputs
  unsigned int nb_outputs;
  // priv
  void *priv;
  // graph
  struct AVFilterGraph *graph;
  // thread_type
  signed int thread_type;
  // internal
  struct AVFilterInternal *internal;
  // command_queue
  struct AVFilterCommand *command_queue;
  // enable_str
  char *enable_str;
  // enable
  void *enable;
  // var_values
  double *var_values;
  // is_disabled
  signed int is_disabled;
};

struct AVFilterGraph
{
  // av_class
  const struct AVClass *av_class;
  // filter_count_unused
  unsigned int filter_count_unused;
  // filters
  struct AVFilterContext **filters;
  // scale_sws_opts
  char *scale_sws_opts;
  // resample_lavr_opts
  char *resample_lavr_opts;
  // nb_filters
  unsigned int nb_filters;
  // thread_type
  signed int thread_type;
  // nb_threads
  signed int nb_threads;
  // internal
  struct AVFilterGraphInternal *internal;
  // opaque
  void *opaque;
  // execute
  signed int (*execute)(struct AVFilterContext *, signed int (*)(struct AVFilterContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // aresample_swr_opts
  char *aresample_swr_opts;
  // sink_links
  struct AVFilterLink **sink_links;
  // sink_links_count
  signed int sink_links_count;
  // disable_auto_convert
  unsigned int disable_auto_convert;
};

struct AVFilterInOut
{
  // name
  char *name;
  // filter_ctx
  struct AVFilterContext *filter_ctx;
  // pad_idx
  signed int pad_idx;
  // next
  struct AVFilterInOut *next;
};

struct AVFilterLink
{
  // src
  struct AVFilterContext *src;
  // srcpad
  struct AVFilterPad *srcpad;
  // dst
  struct AVFilterContext *dst;
  // dstpad
  struct AVFilterPad *dstpad;
  // type
  enum AVMediaType type;
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // channel_layout
  unsigned long int channel_layout;
  // sample_rate
  signed int sample_rate;
  // format
  signed int format;
  // time_base
  struct AVRational time_base;
  // in_formats
  struct AVFilterFormats *in_formats;
  // out_formats
  struct AVFilterFormats *out_formats;
  // in_samplerates
  struct AVFilterFormats *in_samplerates;
  // out_samplerates
  struct AVFilterFormats *out_samplerates;
  // in_channel_layouts
  struct AVFilterChannelLayouts *in_channel_layouts;
  // out_channel_layouts
  struct AVFilterChannelLayouts *out_channel_layouts;
  // request_samples
  signed int request_samples;
  // init_state
  enum anonymous$33 init_state;
  // pool
  struct AVFilterPool *pool;
  // graph
  struct AVFilterGraph *graph;
  // current_pts
  signed long int current_pts;
  // age_index
  signed int age_index;
  // frame_rate
  struct AVRational frame_rate;
  // partial_buf
  struct AVFrame *partial_buf;
  // partial_buf_size
  signed int partial_buf_size;
  // min_samples
  signed int min_samples;
  // max_samples
  signed int max_samples;
  // cur_buf_copy
  struct AVFilterBufferRef *cur_buf_copy;
  // closed
  signed int closed;
  // channels
  signed int channels;
  // frame_requested
  unsigned int frame_requested;
  // flags
  unsigned int flags;
  // frame_count
  signed long int frame_count;
};

struct AVFilterPad
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // min_perms
  signed int min_perms;
  // rej_perms
  signed int rej_perms;
  // start_frame
  signed int (*start_frame)(struct AVFilterLink *, struct AVFilterBufferRef *);
  // get_video_buffer
  struct AVFrame * (*get_video_buffer)(struct AVFilterLink *, signed int, signed int);
  // get_audio_buffer
  struct AVFrame * (*get_audio_buffer)(struct AVFilterLink *, signed int);
  // end_frame
  signed int (*end_frame)(struct AVFilterLink *);
  // draw_slice
  signed int (*draw_slice)(struct AVFilterLink *, signed int, signed int, signed int);
  // filter_frame
  signed int (*filter_frame)(struct AVFilterLink *, struct AVFrame *);
  // poll_frame
  signed int (*poll_frame)(struct AVFilterLink *);
  // request_frame
  signed int (*request_frame)(struct AVFilterLink *);
  // config_props
  signed int (*config_props)(struct AVFilterLink *);
  // needs_fifo
  signed int needs_fifo;
  // needs_writable
  signed int needs_writable;
};

struct AVIOInterruptCB
{
  // callback
  signed int (*callback)(void *);
  // opaque
  void *opaque;
};

struct AVFormatContext
{
  // av_class
  const struct AVClass *av_class;
  // iformat
  struct AVInputFormat *iformat;
  // oformat
  struct AVOutputFormat *oformat;
  // priv_data
  void *priv_data;
  // pb
  struct AVIOContext *pb;
  // ctx_flags
  signed int ctx_flags;
  // nb_streams
  unsigned int nb_streams;
  // streams
  struct AVStream **streams;
  // filename
  char filename[1024l];
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // bit_rate
  signed int bit_rate;
  // packet_size
  unsigned int packet_size;
  // max_delay
  signed int max_delay;
  // flags
  signed int flags;
  // probesize
  unsigned int probesize;
  // max_analyze_duration
  signed int max_analyze_duration;
  // key
  const unsigned char *key;
  // keylen
  signed int keylen;
  // nb_programs
  unsigned int nb_programs;
  // programs
  struct AVProgram **programs;
  // video_codec_id
  enum AVCodecID video_codec_id;
  // audio_codec_id
  enum AVCodecID audio_codec_id;
  // subtitle_codec_id
  enum AVCodecID subtitle_codec_id;
  // max_index_size
  unsigned int max_index_size;
  // max_picture_buffer
  unsigned int max_picture_buffer;
  // nb_chapters
  unsigned int nb_chapters;
  // chapters
  struct AVChapter **chapters;
  // metadata
  struct AVDictionary *metadata;
  // start_time_realtime
  signed long int start_time_realtime;
  // fps_probe_size
  signed int fps_probe_size;
  // error_recognition
  signed int error_recognition;
  // interrupt_callback
  struct AVIOInterruptCB interrupt_callback;
  // debug
  signed int debug;
  // max_interleave_delta
  signed long int max_interleave_delta;
  // strict_std_compliance
  signed int strict_std_compliance;
  // event_flags
  signed int event_flags;
  // max_ts_probe
  signed int max_ts_probe;
  // avoid_negative_ts
  signed int avoid_negative_ts;
  // ts_id
  signed int ts_id;
  // audio_preload
  signed int audio_preload;
  // max_chunk_duration
  signed int max_chunk_duration;
  // max_chunk_size
  signed int max_chunk_size;
  // use_wallclock_as_timestamps
  signed int use_wallclock_as_timestamps;
  // avio_flags
  signed int avio_flags;
  // duration_estimation_method
  enum AVDurationEstimationMethod duration_estimation_method;
  // skip_initial_bytes
  signed long int skip_initial_bytes;
  // correct_ts_overflow
  unsigned int correct_ts_overflow;
  // seek2any
  signed int seek2any;
  // flush_packets
  signed int flush_packets;
  // probe_score
  signed int probe_score;
  // format_probesize
  signed int format_probesize;
  // codec_whitelist
  char *codec_whitelist;
  // format_whitelist
  char *format_whitelist;
  // internal
  struct AVFormatInternal *internal;
  // io_repositioned
  signed int io_repositioned;
  // video_codec
  struct AVCodec *video_codec;
  // audio_codec
  struct AVCodec *audio_codec;
  // subtitle_codec
  struct AVCodec *subtitle_codec;
  // data_codec
  struct AVCodec *data_codec;
  // metadata_header_padding
  signed int metadata_header_padding;
  // opaque
  void *opaque;
  // control_message_cb
  signed int (*control_message_cb)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // output_ts_offset
  signed long int output_ts_offset;
  // max_analyze_duration2
  signed long int max_analyze_duration2;
  // probesize2
  signed long int probesize2;
  // dump_separator
  unsigned char *dump_separator;
  // data_codec_id
  enum AVCodecID data_codec_id;
  // open_cb
  signed int (*open_cb)(struct AVFormatContext *, struct AVIOContext **, const char *, signed int, const struct AVIOInterruptCB *, struct AVDictionary **);
};

struct AVFrac
{
  // val
  signed long int val;
  // num
  signed long int num;
  // den
  signed long int den;
};

struct AVFrame
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
  // extended_data
  unsigned char **extended_data;
  // width
  signed int width;
  // height
  signed int height;
  // nb_samples
  signed int nb_samples;
  // format
  signed int format;
  // key_frame
  signed int key_frame;
  // pict_type
  enum AVPictureType pict_type;
  // base
  unsigned char *base[8l];
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // pts
  signed long int pts;
  // pkt_pts
  signed long int pkt_pts;
  // pkt_dts
  signed long int pkt_dts;
  // coded_picture_number
  signed int coded_picture_number;
  // display_picture_number
  signed int display_picture_number;
  // quality
  signed int quality;
  // reference
  signed int reference;
  // qscale_table
  signed char *qscale_table;
  // qstride
  signed int qstride;
  // qscale_type
  signed int qscale_type;
  // mbskip_table
  unsigned char *mbskip_table;
  // motion_val
  signed short int (*motion_val[2l])[2l];
  // mb_type
  unsigned int *mb_type;
  // dct_coeff
  signed short int *dct_coeff;
  // ref_index
  signed char *ref_index[2l];
  // opaque
  void *opaque;
  // error
  unsigned long int error[8l];
  // type
  signed int type;
  // repeat_pict
  signed int repeat_pict;
  // interlaced_frame
  signed int interlaced_frame;
  // top_field_first
  signed int top_field_first;
  // palette_has_changed
  signed int palette_has_changed;
  // buffer_hints
  signed int buffer_hints;
  // pan_scan
  struct AVPanScan *pan_scan;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel_picture_private
  void *hwaccel_picture_private;
  // owner
  struct AVCodecContext *owner;
  // thread_opaque
  void *thread_opaque;
  // motion_subsample_log2
  unsigned char motion_subsample_log2;
  // sample_rate
  signed int sample_rate;
  // channel_layout
  unsigned long int channel_layout;
  // buf
  struct AVBufferRef *buf[8l];
  // extended_buf
  struct AVBufferRef **extended_buf;
  // nb_extended_buf
  signed int nb_extended_buf;
  // side_data
  struct AVFrameSideData **side_data;
  // nb_side_data
  signed int nb_side_data;
  // flags
  signed int flags;
  // color_range
  enum AVColorRange color_range;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // chroma_location
  enum AVChromaLocation chroma_location;
  // best_effort_timestamp
  signed long int best_effort_timestamp;
  // pkt_pos
  signed long int pkt_pos;
  // pkt_duration
  signed long int pkt_duration;
  // metadata
  struct AVDictionary *metadata;
  // decode_error_flags
  signed int decode_error_flags;
  // channels
  signed int channels;
  // pkt_size
  signed int pkt_size;
  // qp_table_buf
  struct AVBufferRef *qp_table_buf;
};

struct AVFrameSideData
{
  // type
  enum AVFrameSideDataType type;
  // data
  unsigned char *data;
  // size
  signed int size;
  // metadata
  struct AVDictionary *metadata;
  // buf
  struct AVBufferRef *buf;
};

struct AVHWAccel
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // capabilities
  signed int capabilities;
  // next
  struct AVHWAccel *next;
  // alloc_frame
  signed int (*alloc_frame)(struct AVCodecContext *, struct AVFrame *);
  // start_frame
  signed int (*start_frame)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // decode_slice
  signed int (*decode_slice)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // end_frame
  signed int (*end_frame)(struct AVCodecContext *);
  // frame_priv_data_size
  signed int frame_priv_data_size;
  // decode_mb
  void (*decode_mb)(struct MpegEncContext *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // uninit
  signed int (*uninit)(struct AVCodecContext *);
  // priv_data_size
  signed int priv_data_size;
};

struct AVIOContext
{
  // av_class
  const struct AVClass *av_class;
  // buffer
  unsigned char *buffer;
  // buffer_size
  signed int buffer_size;
  // buf_ptr
  unsigned char *buf_ptr;
  // buf_end
  unsigned char *buf_end;
  // opaque
  void *opaque;
  // read_packet
  signed int (*read_packet)(void *, unsigned char *, signed int);
  // write_packet
  signed int (*write_packet)(void *, unsigned char *, signed int);
  // seek
  signed long int (*seek)(void *, signed long int, signed int);
  // pos
  signed long int pos;
  // must_flush
  signed int must_flush;
  // eof_reached
  signed int eof_reached;
  // write_flag
  signed int write_flag;
  // max_packet_size
  signed int max_packet_size;
  // checksum
  unsigned long int checksum;
  // checksum_ptr
  unsigned char *checksum_ptr;
  // update_checksum
  unsigned long int (*update_checksum)(unsigned long int, const unsigned char *, unsigned int);
  // error
  signed int error;
  // read_pause
  signed int (*read_pause)(void *, signed int);
  // read_seek
  signed long int (*read_seek)(void *, signed int, signed long int, signed int);
  // seekable
  signed int seekable;
  // maxsize
  signed long int maxsize;
  // direct
  signed int direct;
  // bytes_read
  signed long int bytes_read;
  // seek_count
  signed int seek_count;
  // writeout_count
  signed int writeout_count;
  // orig_buffer_size
  signed int orig_buffer_size;
  // short_seek_threshold
  signed int short_seek_threshold;
};

struct AVIndexEntry
{
  // pos
  signed long int pos;
  // timestamp
  signed long int timestamp;
  // flags
  signed int flags : 2;
  // size
  signed int size : 30;
  // min_distance
  signed int min_distance;
};

struct AVInputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // flags
  signed int flags;
  // extensions
  const char *extensions;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // mime_type
  const char *mime_type;
  // next
  struct AVInputFormat *next;
  // raw_codec_id
  signed int raw_codec_id;
  // priv_data_size
  signed int priv_data_size;
  // read_probe
  signed int (*read_probe)(struct AVProbeData *);
  // read_header
  signed int (*read_header)(struct AVFormatContext *);
  // read_packet
  signed int (*read_packet)(struct AVFormatContext *, struct AVPacket *);
  // read_close
  signed int (*read_close)(struct AVFormatContext *);
  // read_seek
  signed int (*read_seek)(struct AVFormatContext *, signed int, signed long int, signed int);
  // read_timestamp
  signed long int (*read_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int);
  // read_play
  signed int (*read_play)(struct AVFormatContext *);
  // read_pause
  signed int (*read_pause)(struct AVFormatContext *);
  // read_seek2
  signed int (*read_seek2)(struct AVFormatContext *, signed int, signed long int, signed long int, signed long int, signed int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
};

struct AVOutputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // mime_type
  const char *mime_type;
  // extensions
  const char *extensions;
  // audio_codec
  enum AVCodecID audio_codec;
  // video_codec
  enum AVCodecID video_codec;
  // subtitle_codec
  enum AVCodecID subtitle_codec;
  // flags
  signed int flags;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // next
  struct AVOutputFormat *next;
  // priv_data_size
  signed int priv_data_size;
  // write_header
  signed int (*write_header)(struct AVFormatContext *);
  // write_packet
  signed int (*write_packet)(struct AVFormatContext *, struct AVPacket *);
  // write_trailer
  signed int (*write_trailer)(struct AVFormatContext *);
  // interleave_packet
  signed int (*interleave_packet)(struct AVFormatContext *, struct AVPacket *, struct AVPacket *, signed int);
  // query_codec
  signed int (*query_codec)(enum AVCodecID, signed int);
  // get_output_timestamp
  void (*get_output_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int *);
  // control_message
  signed int (*control_message)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // write_uncoded_frame
  signed int (*write_uncoded_frame)(struct AVFormatContext *, signed int, struct AVFrame **, unsigned int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // data_codec
  enum AVCodecID data_codec;
};

struct AVPacket
{
  // buf
  struct AVBufferRef *buf;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // data
  unsigned char *data;
  // size
  signed int size;
  // stream_index
  signed int stream_index;
  // flags
  signed int flags;
  // side_data
  struct AVPacketSideData *side_data;
  // side_data_elems
  signed int side_data_elems;
  // duration
  signed int duration;
  // destruct
  void (*destruct)(struct AVPacket *);
  // priv
  void *priv;
  // pos
  signed long int pos;
  // convergence_duration
  signed long int convergence_duration;
};

struct AVPacketList
{
  // pkt
  struct AVPacket pkt;
  // next
  struct AVPacketList *next;
};

struct AVPacketSideData
{
  // data
  unsigned char *data;
  // size
  signed int size;
  // type
  enum AVPacketSideDataType type;
};

struct AVPanScan
{
  // id
  signed int id;
  // width
  signed int width;
  // height
  signed int height;
  // position
  signed short int position[3l][2l];
};

struct AVPicture
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
};

struct AVProbeData
{
  // filename
  const char *filename;
  // buf
  unsigned char *buf;
  // buf_size
  signed int buf_size;
  // mime_type
  const char *mime_type;
};

struct AVProfile
{
  // profile
  signed int profile;
  // name
  const char *name;
};

struct AVProgram
{
  // id
  signed int id;
  // flags
  signed int flags;
  // discard
  enum AVDiscard discard;
  // stream_index
  unsigned int *stream_index;
  // nb_stream_indexes
  unsigned int nb_stream_indexes;
  // metadata
  struct AVDictionary *metadata;
  // program_num
  signed int program_num;
  // pmt_pid
  signed int pmt_pid;
  // pcr_pid
  signed int pcr_pid;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
};

struct AVStream
{
  // index
  signed int index;
  // id
  signed int id;
  // codec
  struct AVCodecContext *codec;
  // priv_data
  void *priv_data;
  // pts
  struct AVFrac pts;
  // time_base
  struct AVRational time_base;
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // nb_frames
  signed long int nb_frames;
  // disposition
  signed int disposition;
  // discard
  enum AVDiscard discard;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // metadata
  struct AVDictionary *metadata;
  // avg_frame_rate
  struct AVRational avg_frame_rate;
  // attached_pic
  struct AVPacket attached_pic;
  // side_data
  struct AVPacketSideData *side_data;
  // nb_side_data
  signed int nb_side_data;
  // event_flags
  signed int event_flags;
  // info
  struct anonymous$6 *info;
  // pts_wrap_bits
  signed int pts_wrap_bits;
  // first_dts
  signed long int first_dts;
  // cur_dts
  signed long int cur_dts;
  // last_IP_pts
  signed long int last_IP_pts;
  // last_IP_duration
  signed int last_IP_duration;
  // probe_packets
  signed int probe_packets;
  // codec_info_nb_frames
  signed int codec_info_nb_frames;
  // need_parsing
  enum AVStreamParseType need_parsing;
  // parser
  struct AVCodecParserContext *parser;
  // last_in_packet_buffer
  struct AVPacketList *last_in_packet_buffer;
  // probe_data
  struct AVProbeData probe_data;
  // pts_buffer
  signed long int pts_buffer[17l];
  // index_entries
  struct AVIndexEntry *index_entries;
  // nb_index_entries
  signed int nb_index_entries;
  // index_entries_allocated_size
  unsigned int index_entries_allocated_size;
  // r_frame_rate
  struct AVRational r_frame_rate;
  // stream_identifier
  signed int stream_identifier;
  // interleaver_chunk_size
  signed long int interleaver_chunk_size;
  // interleaver_chunk_duration
  signed long int interleaver_chunk_duration;
  // request_probe
  signed int request_probe;
  // skip_to_keyframe
  signed int skip_to_keyframe;
  // skip_samples
  signed int skip_samples;
  // start_skip_samples
  signed long int start_skip_samples;
  // first_discard_sample
  signed long int first_discard_sample;
  // last_discard_sample
  signed long int last_discard_sample;
  // nb_decoded_frames
  signed int nb_decoded_frames;
  // mux_ts_offset
  signed long int mux_ts_offset;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
  // update_initial_durations_done
  signed int update_initial_durations_done;
  // pts_reorder_error
  signed long int pts_reorder_error[17l];
  // pts_reorder_error_count
  unsigned char pts_reorder_error_count[17l];
  // last_dts_for_order_check
  signed long int last_dts_for_order_check;
  // dts_ordered
  unsigned char dts_ordered;
  // dts_misordered
  unsigned char dts_misordered;
  // inject_global_side_data
  signed int inject_global_side_data;
  // recommended_encoder_configuration
  char *recommended_encoder_configuration;
  // display_aspect_ratio
  struct AVRational display_aspect_ratio;
  // priv_pts
  struct FFFrac *priv_pts;
};

struct AVSubtitle
{
  // format
  unsigned short int format;
  // start_display_time
  unsigned int start_display_time;
  // end_display_time
  unsigned int end_display_time;
  // num_rects
  unsigned int num_rects;
  // rects
  struct AVSubtitleRect **rects;
  // pts
  signed long int pts;
};

struct AVSubtitleRect
{
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
  // nb_colors
  signed int nb_colors;
  // pict
  struct AVPicture pict;
  // type
  enum AVSubtitleType type;
  // text
  char *text;
  // ass
  char *ass;
  // flags
  signed int flags;
};

struct MyBuffer
{
  // fh
  struct _IO_FILE *fh;
  // buffer
  char *buffer;
  // bufsize
  unsigned long int bufsize;
};

struct RcOverride
{
  // start_frame
  signed int start_frame;
  // end_frame
  signed int end_frame;
  // qscale
  signed int qscale;
  // quality_factor
  float quality_factor;
};

struct SDL_ActiveEvent
{
  // type
  unsigned char type;
  // gain
  unsigned char gain;
  // state
  unsigned char state;
};

struct SDL_Color
{
  // r
  unsigned char r;
  // g
  unsigned char g;
  // b
  unsigned char b;
  // unused
  unsigned char unused;
};

struct SDL_keysym
{
  // scancode
  unsigned char scancode;
  // sym
  enum anonymous$37 sym;
  // mod
  enum anonymous$38 mod;
  // unicode
  unsigned short int unicode;
};

struct SDL_KeyboardEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // state
  unsigned char state;
  // keysym
  struct SDL_keysym keysym;
};

struct SDL_MouseMotionEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // state
  unsigned char state;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // xrel
  signed short int xrel;
  // yrel
  signed short int yrel;
};

struct SDL_MouseButtonEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // button
  unsigned char button;
  // state
  unsigned char state;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
};

struct SDL_JoyAxisEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // axis
  unsigned char axis;
  // value
  signed short int value;
};

struct SDL_JoyBallEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // ball
  unsigned char ball;
  // xrel
  signed short int xrel;
  // yrel
  signed short int yrel;
};

struct SDL_JoyHatEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // hat
  unsigned char hat;
  // value
  unsigned char value;
};

struct SDL_JoyButtonEvent
{
  // type
  unsigned char type;
  // which
  unsigned char which;
  // button
  unsigned char button;
  // state
  unsigned char state;
};

struct SDL_ResizeEvent
{
  // type
  unsigned char type;
  // w
  signed int w;
  // h
  signed int h;
};

struct SDL_ExposeEvent
{
  // type
  unsigned char type;
};

struct SDL_QuitEvent
{
  // type
  unsigned char type;
};

struct SDL_UserEvent
{
  // type
  unsigned char type;
  // code
  signed int code;
  // data1
  void *data1;
  // data2
  void *data2;
};

struct SDL_SysWMEvent
{
  // type
  unsigned char type;
  // msg
  struct SDL_SysWMmsg *msg;
};

union SDL_Event
{
  // type
  unsigned char type;
  // active
  struct SDL_ActiveEvent active;
  // key
  struct SDL_KeyboardEvent key;
  // motion
  struct SDL_MouseMotionEvent motion;
  // button
  struct SDL_MouseButtonEvent button;
  // jaxis
  struct SDL_JoyAxisEvent jaxis;
  // jball
  struct SDL_JoyBallEvent jball;
  // jhat
  struct SDL_JoyHatEvent jhat;
  // jbutton
  struct SDL_JoyButtonEvent jbutton;
  // resize
  struct SDL_ResizeEvent resize;
  // expose
  struct SDL_ExposeEvent expose;
  // quit
  struct SDL_QuitEvent quit;
  // user
  struct SDL_UserEvent user;
  // syswm
  struct SDL_SysWMEvent syswm;
};

struct SDL_Overlay
{
  // format
  unsigned int format;
  // w
  signed int w;
  // h
  signed int h;
  // planes
  signed int planes;
  // pitches
  unsigned short int *pitches;
  // pixels
  unsigned char **pixels;
  // hwfuncs
  struct private_yuvhwfuncs *hwfuncs;
  // hwdata
  struct private_yuvhwdata *hwdata;
  // hw_overlay
  unsigned int hw_overlay : 1;
  // UnusedBits
  unsigned int UnusedBits : 31;
};

struct SDL_Palette
{
  // ncolors
  signed int ncolors;
  // colors
  struct SDL_Color *colors;
};

struct SDL_PixelFormat
{
  // palette
  struct SDL_Palette *palette;
  // BitsPerPixel
  unsigned char BitsPerPixel;
  // BytesPerPixel
  unsigned char BytesPerPixel;
  // Rloss
  unsigned char Rloss;
  // Gloss
  unsigned char Gloss;
  // Bloss
  unsigned char Bloss;
  // Aloss
  unsigned char Aloss;
  // Rshift
  unsigned char Rshift;
  // Gshift
  unsigned char Gshift;
  // Bshift
  unsigned char Bshift;
  // Ashift
  unsigned char Ashift;
  // Rmask
  unsigned int Rmask;
  // Gmask
  unsigned int Gmask;
  // Bmask
  unsigned int Bmask;
  // Amask
  unsigned int Amask;
  // colorkey
  unsigned int colorkey;
  // alpha
  unsigned char alpha;
};

struct SDL_Rect
{
  // x
  signed short int x;
  // y
  signed short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
};

struct SDL_Surface
{
  // flags
  unsigned int flags;
  // format
  struct SDL_PixelFormat *format;
  // w
  signed int w;
  // h
  signed int h;
  // pitch
  unsigned short int pitch;
  // pixels
  void *pixels;
  // offset
  signed int offset;
  // hwdata
  struct private_hwdata *hwdata;
  // clip_rect
  struct SDL_Rect clip_rect;
  // unused1
  unsigned int unused1;
  // locked
  unsigned int locked;
  // map
  struct SDL_BlitMap *map;
  // format_version
  unsigned int format_version;
  // refcount
  signed int refcount;
};

struct SDL_VideoInfo
{
  // hw_available
  unsigned int hw_available : 1;
  // wm_available
  unsigned int wm_available : 1;
  // UnusedBits1
  unsigned int UnusedBits1 : 6;
  // UnusedBits2
  unsigned int UnusedBits2 : 1;
  // blit_hw
  unsigned int blit_hw : 1;
  // blit_hw_CC
  unsigned int blit_hw_CC : 1;
  // blit_hw_A
  unsigned int blit_hw_A : 1;
  // blit_sw
  unsigned int blit_sw : 1;
  // blit_sw_CC
  unsigned int blit_sw_CC : 1;
  // blit_sw_A
  unsigned int blit_sw_A : 1;
  // blit_fill
  unsigned int blit_fill : 1;
  // UnusedBits3
  unsigned int UnusedBits3 : 16;
  // video_mem
  unsigned int video_mem;
  // vfmt
  struct SDL_PixelFormat *vfmt;
  // current_w
  signed int current_w;
  // current_h
  signed int current_h;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$16 __saved_mask;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct auth_param
{
  // cnt
  struct context *cnt;
  // sock
  signed int sock;
  // sock_flags
  signed int sock_flags;
  // thread_count
  signed int *thread_count;
  // conf
  struct config *conf;
};

struct big_char
{
  // ascii
  unsigned char ascii;
  // pix
  unsigned char pix[16l][14l];
};

struct config
{
  // log_level
  unsigned int log_level;
  // log_type_str
  char *log_type_str;
  // log_file
  char *log_file;
  // setup_mode
  signed int setup_mode;
  // width
  signed int width;
  // height
  signed int height;
  // quality
  signed int quality;
  // rotate_deg
  signed int rotate_deg;
  // max_changes
  signed int max_changes;
  // threshold_tune
  signed int threshold_tune;
  // output_pictures
  const char *output_pictures;
  // motion_img
  signed int motion_img;
  // emulate_motion
  signed int emulate_motion;
  // event_gap
  signed int event_gap;
  // max_movie_time
  signed int max_movie_time;
  // snapshot_interval
  signed int snapshot_interval;
  // locate_motion_mode
  const char *locate_motion_mode;
  // locate_motion_style
  const char *locate_motion_style;
  // input
  signed int input;
  // norm
  signed int norm;
  // frame_limit
  signed int frame_limit;
  // quiet
  signed int quiet;
  // useextpipe
  signed int useextpipe;
  // extpipe
  const char *extpipe;
  // picture_type
  const char *picture_type;
  // noise
  signed int noise;
  // noise_tune
  signed int noise_tune;
  // minimum_frame_time
  signed int minimum_frame_time;
  // lightswitch
  signed int lightswitch;
  // autobright
  signed int autobright;
  // brightness
  signed int brightness;
  // contrast
  signed int contrast;
  // saturation
  signed int saturation;
  // hue
  signed int hue;
  // roundrobin_frames
  signed int roundrobin_frames;
  // roundrobin_skip
  signed int roundrobin_skip;
  // pre_capture
  signed int pre_capture;
  // post_capture
  signed int post_capture;
  // switchfilter
  signed int switchfilter;
  // ffmpeg_output
  signed int ffmpeg_output;
  // ffmpeg_output_debug
  signed int ffmpeg_output_debug;
  // ffmpeg_bps
  signed int ffmpeg_bps;
  // ffmpeg_vbr
  signed int ffmpeg_vbr;
  // ffmpeg_deinterlace
  signed int ffmpeg_deinterlace;
  // ffmpeg_video_codec
  const char *ffmpeg_video_codec;
  // sdl_threadnr
  signed int sdl_threadnr;
  // ipv6_enabled
  signed int ipv6_enabled;
  // stream_port
  signed int stream_port;
  // stream_quality
  signed int stream_quality;
  // stream_motion
  signed int stream_motion;
  // stream_maxrate
  signed int stream_maxrate;
  // stream_localhost
  signed int stream_localhost;
  // stream_limit
  signed int stream_limit;
  // stream_auth_method
  signed int stream_auth_method;
  // stream_authentication
  const char *stream_authentication;
  // webcontrol_port
  signed int webcontrol_port;
  // webcontrol_localhost
  signed int webcontrol_localhost;
  // webcontrol_html_output
  signed int webcontrol_html_output;
  // webcontrol_authentication
  const char *webcontrol_authentication;
  // frequency
  unsigned long int frequency;
  // tuner_number
  signed int tuner_number;
  // timelapse
  signed int timelapse;
  // timelapse_mode
  const char *timelapse_mode;
  // video_device
  const char *video_device;
  // v4l2_palette
  signed int v4l2_palette;
  // vidpipe
  const char *vidpipe;
  // filepath
  const char *filepath;
  // imagepath
  const char *imagepath;
  // moviepath
  const char *moviepath;
  // snappath
  const char *snappath;
  // timepath
  const char *timepath;
  // on_event_start
  char *on_event_start;
  // on_event_end
  char *on_event_end;
  // mask_file
  const char *mask_file;
  // smart_mask_speed
  signed int smart_mask_speed;
  // sql_log_image
  signed int sql_log_image;
  // sql_log_snapshot
  signed int sql_log_snapshot;
  // sql_log_movie
  signed int sql_log_movie;
  // sql_log_timelapse
  signed int sql_log_timelapse;
  // sql_query
  const char *sql_query;
  // database_type
  const char *database_type;
  // database_dbname
  const char *database_dbname;
  // database_host
  const char *database_host;
  // database_user
  const char *database_user;
  // database_password
  const char *database_password;
  // sqlite3_db
  const char *sqlite3_db;
  // database_port
  signed int database_port;
  // on_picture_save
  char *on_picture_save;
  // on_area_detected
  char *on_area_detected;
  // on_motion_detected
  char *on_motion_detected;
  // on_movie_start
  char *on_movie_start;
  // on_movie_end
  char *on_movie_end;
  // on_camera_lost
  char *on_camera_lost;
  // motionvidpipe
  const char *motionvidpipe;
  // netcam_url
  const char *netcam_url;
  // netcam_userpass
  const char *netcam_userpass;
  // netcam_keepalive
  const char *netcam_keepalive;
  // netcam_proxy
  const char *netcam_proxy;
  // netcam_tolerant_check
  unsigned int netcam_tolerant_check;
  // text_changes
  signed int text_changes;
  // text_left
  const char *text_left;
  // text_right
  const char *text_right;
  // text_event
  const char *text_event;
  // text_double
  signed int text_double;
  // despeckle_filter
  const char *despeckle_filter;
  // area_detect
  const char *area_detect;
  // minimum_motion_frames
  signed int minimum_motion_frames;
  // exif_text
  const char *exif_text;
  // pid_file
  char *pid_file;
  // argc
  signed int argc;
  // argv
  char **argv;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct coord
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // minx
  signed int minx;
  // maxx
  signed int maxx;
  // miny
  signed int miny;
  // maxy
  signed int maxy;
};

struct image_data
{
  // image
  unsigned char *image;
  // diffs
  signed int diffs;
  // timestamp
  signed long int timestamp;
  // timestamp_tm
  struct tm timestamp_tm;
  // shot
  signed int shot;
  // cent_dist
  unsigned long int cent_dist;
  // flags
  unsigned int flags;
  // location
  struct coord location;
  // total_labels
  signed int total_labels;
};

struct images
{
  // image_ring
  struct image_data *image_ring;
  // image_ring_size
  signed int image_ring_size;
  // image_ring_in
  signed int image_ring_in;
  // image_ring_out
  signed int image_ring_out;
  // ref
  unsigned char *ref;
  // out
  unsigned char *out;
  // ref_dyn
  signed int *ref_dyn;
  // image_virgin
  unsigned char *image_virgin;
  // preview_image
  struct image_data preview_image;
  // mask
  unsigned char *mask;
  // smartmask
  unsigned char *smartmask;
  // smartmask_final
  unsigned char *smartmask_final;
  // common_buffer
  unsigned char *common_buffer;
  // smartmask_buffer
  signed int *smartmask_buffer;
  // labels
  signed int *labels;
  // labelsize
  signed int *labelsize;
  // width
  signed int width;
  // height
  signed int height;
  // type
  signed int type;
  // picture_type
  signed int picture_type;
  // size
  signed int size;
  // motionsize
  signed int motionsize;
  // labelgroup_max
  signed int labelgroup_max;
  // labels_above
  signed int labels_above;
  // labelsize_max
  signed int labelsize_max;
  // largest_label
  signed int largest_label;
};

struct trackoptions
{
  // dev
  signed int dev;
  // type
  unsigned int type;
  // port
  char *port;
  // motorx
  unsigned int motorx;
  // motory
  unsigned int motory;
  // maxx
  signed int maxx;
  // maxy
  signed int maxy;
  // minx
  signed int minx;
  // miny
  signed int miny;
  // stepsize
  unsigned int stepsize;
  // speed
  unsigned int speed;
  // homex
  unsigned int homex;
  // homey
  unsigned int homey;
  // iomojo_id
  unsigned int iomojo_id;
  // active
  unsigned int active;
  // motorx_reverse
  unsigned int motorx_reverse;
  // motory_reverse
  unsigned int motory_reverse;
  // minmaxfound
  unsigned int minmaxfound;
  // step_angle_x
  unsigned int step_angle_x;
  // step_angle_y
  unsigned int step_angle_y;
  // move_wait
  unsigned int move_wait;
  // pan_angle
  signed int pan_angle;
  // tilt_angle
  signed int tilt_angle;
};

struct rotdata
{
  // temp_buf
  unsigned char *temp_buf;
  // degrees
  signed int degrees;
  // cap_width
  signed int cap_width;
  // cap_height
  signed int cap_height;
};

struct stream
{
  // socket
  signed int socket;
  // fwrite
  struct _IO_FILE *fwrite;
  // tmpbuffer
  struct stream_buffer *tmpbuffer;
  // filepos
  signed long int filepos;
  // nr
  signed int nr;
  // last
  unsigned long int last;
  // prev
  struct stream *prev;
  // next
  struct stream *next;
};

struct context
{
  // extpipe
  struct _IO_FILE *extpipe;
  // extpipe_open
  signed int extpipe_open;
  // conf_filename
  char conf_filename[4096l];
  // threadnr
  signed int threadnr;
  // daemon
  unsigned int daemon;
  // pid_file
  char pid_file[4096l];
  // log_file
  char log_file[4096l];
  // log_type_str
  char log_type_str[6l];
  // log_level
  signed int log_level;
  // log_type
  unsigned int log_type;
  // conf
  struct config conf;
  // imgs
  struct images imgs;
  // track
  struct trackoptions track;
  // netcam
  struct netcam_context *netcam;
  // current_image
  struct image_data *current_image;
  // new_img
  unsigned int new_img;
  // locate_motion_mode
  signed int locate_motion_mode;
  // locate_motion_style
  signed int locate_motion_style;
  // process_thisframe
  signed int process_thisframe;
  // rotate_data
  struct rotdata rotate_data;
  // noise
  signed int noise;
  // threshold
  signed int threshold;
  // diffs_last
  signed int diffs_last[256l];
  // smartmask_speed
  signed int smartmask_speed;
  // snapshot
  volatile unsigned int snapshot;
  // makemovie
  volatile unsigned int makemovie;
  // finish
  volatile unsigned int finish;
  // restart
  volatile unsigned int restart;
  // running
  volatile unsigned int running;
  // watchdog
  volatile signed int watchdog;
  // thread_id
  unsigned long int thread_id;
  // event_nr
  signed int event_nr;
  // prev_event
  signed int prev_event;
  // lightswitch_framecounter
  unsigned int lightswitch_framecounter;
  // text_event_string
  char text_event_string[4096l];
  // postcap
  signed int postcap;
  // shots
  signed int shots;
  // detecting_motion
  unsigned int detecting_motion;
  // currenttime_tm
  struct tm *currenttime_tm;
  // eventtime_tm
  struct tm *eventtime_tm;
  // currenttime
  signed long int currenttime;
  // lasttime
  signed long int lasttime;
  // eventtime
  signed long int eventtime;
  // connectionlosttime
  signed long int connectionlosttime;
  // lastrate
  unsigned int lastrate;
  // startup_frames
  unsigned int startup_frames;
  // moved
  unsigned int moved;
  // pause
  unsigned int pause;
  // missing_frame_counter
  signed int missing_frame_counter;
  // lost_connection
  unsigned int lost_connection;
  // video_dev
  signed int video_dev;
  // pipe
  signed int pipe;
  // mpipe
  signed int mpipe;
  // stream
  struct stream stream;
  // stream_count
  signed int stream_count;
  // sql_mask
  signed int sql_mask;
  // database_sqlite3
  struct sqlite3 *database_sqlite3;
  // database
  struct st_mysql *database;
  // database_pg
  struct pg_conn *database_pg;
  // movie_fps
  signed int movie_fps;
  // newfilename
  char newfilename[4096l];
  // extpipefilename
  char extpipefilename[4096l];
  // movie_last_shot
  signed int movie_last_shot;
  // ffmpeg_output
  struct ffmpeg *ffmpeg_output;
  // ffmpeg_output_debug
  struct ffmpeg *ffmpeg_output_debug;
  // ffmpeg_timelapse
  struct ffmpeg *ffmpeg_timelapse;
  // ffmpeg_smartmask
  struct ffmpeg *ffmpeg_smartmask;
  // timelapsefilename
  char timelapsefilename[4096l];
  // motionfilename
  char motionfilename[4096l];
};

struct draw_char
{
  // ascii
  unsigned char ascii;
  // pix
  unsigned char pix[8l][7l];
};

struct event_handlers
{
  // type
  signed int type;
  // handler
  void (*handler)(struct context *, signed int, unsigned char *, char *, void *, struct tm *);
};

struct ffmpeg
{
  // oc
  struct AVFormatContext *oc;
  // video_st
  struct AVStream *video_st;
  // c
  struct AVCodecContext *c;
  // picture
  struct AVFrame *picture;
  // video_outbuf
  unsigned char *video_outbuf;
  // video_outbuf_size
  signed int video_outbuf_size;
  // udata
  void *udata;
  // vbr
  signed int vbr;
  // codec
  char codec[20l];
};

struct file_context
{
  // path
  char *path;
  // control_file_desc
  signed int control_file_desc;
  // last_st_mtime
  signed long int last_st_mtime;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct ftp_context
{
  // path
  char *path;
  // user
  char *user;
  // passwd
  char *passwd;
  // ftp_address
  struct sockaddr_in ftp_address;
  // passive
  signed int passive;
  // control_file_desc
  signed int control_file_desc;
  // data_file_desc
  signed int data_file_desc;
  // state
  signed int state;
  // returnValue
  signed int returnValue;
  // control_buffer
  char control_buffer[1025l];
  // control_buffer_index
  signed int control_buffer_index;
  // control_buffer_used
  signed int control_buffer_used;
  // control_buffer_answer
  signed int control_buffer_answer;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$42 __in6_u;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous$10 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous$10 jpeg_color_space;
  // comp_info
  struct anonymous$15 *comp_info;
  // quant_tbl_ptrs
  struct anonymous$13 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous$14 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous$14 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous$22 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous$11 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous$15 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous$22 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_decompress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // src
  struct jpeg_source_mgr *src;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous$10 jpeg_color_space;
  // out_color_space
  enum anonymous$10 out_color_space;
  // scale_num
  unsigned int scale_num;
  // scale_denom
  unsigned int scale_denom;
  // output_gamma
  double output_gamma;
  // buffered_image
  signed int buffered_image;
  // raw_data_out
  signed int raw_data_out;
  // dct_method
  enum anonymous$11 dct_method;
  // do_fancy_upsampling
  signed int do_fancy_upsampling;
  // do_block_smoothing
  signed int do_block_smoothing;
  // quantize_colors
  signed int quantize_colors;
  // dither_mode
  enum anonymous$12 dither_mode;
  // two_pass_quantize
  signed int two_pass_quantize;
  // desired_number_of_colors
  signed int desired_number_of_colors;
  // enable_1pass_quant
  signed int enable_1pass_quant;
  // enable_external_quant
  signed int enable_external_quant;
  // enable_2pass_quant
  signed int enable_2pass_quant;
  // output_width
  unsigned int output_width;
  // output_height
  unsigned int output_height;
  // out_color_components
  signed int out_color_components;
  // output_components
  signed int output_components;
  // rec_outbuf_height
  signed int rec_outbuf_height;
  // actual_number_of_colors
  signed int actual_number_of_colors;
  // colormap
  unsigned char **colormap;
  // output_scanline
  unsigned int output_scanline;
  // input_scan_number
  signed int input_scan_number;
  // input_iMCU_row
  unsigned int input_iMCU_row;
  // output_scan_number
  signed int output_scan_number;
  // output_iMCU_row
  unsigned int output_iMCU_row;
  // coef_bits
  signed int (*coef_bits)[64l];
  // quant_tbl_ptrs
  struct anonymous$13 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous$14 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous$14 *ac_huff_tbl_ptrs[4l];
  // data_precision
  signed int data_precision;
  // comp_info
  struct anonymous$15 *comp_info;
  // progressive_mode
  signed int progressive_mode;
  // arith_code
  signed int arith_code;
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // restart_interval
  unsigned int restart_interval;
  // saw_JFIF_marker
  signed int saw_JFIF_marker;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // saw_Adobe_marker
  signed int saw_Adobe_marker;
  // Adobe_transform
  unsigned char Adobe_transform;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // marker_list
  struct jpeg_marker_struct *marker_list;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // min_DCT_scaled_size
  signed int min_DCT_scaled_size;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // sample_range_limit
  unsigned char *sample_range_limit;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous$15 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // unread_marker
  signed int unread_marker;
  // master
  struct jpeg_decomp_master *master;
  // main
  struct jpeg_d_main_controller *main;
  // coef
  struct jpeg_d_coef_controller *coef;
  // post
  struct jpeg_d_post_controller *post;
  // inputctl
  struct jpeg_input_controller *inputctl;
  // marker
  struct jpeg_marker_reader *marker;
  // entropy
  struct jpeg_entropy_decoder *entropy;
  // idct
  struct jpeg_inverse_dct *idct;
  // upsample
  struct jpeg_upsampler *upsample;
  // cconvert
  struct jpeg_color_deconverter *cconvert;
  // cquantize
  struct jpeg_color_quantizer *cquantize;
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous$40 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_marker_struct
{
  // next
  struct jpeg_marker_struct *next;
  // marker
  unsigned char marker;
  // original_length
  unsigned int original_length;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct my_error_mgr
{
  // pub
  struct jpeg_error_mgr pub;
  // setjmp_buffer
  struct __jmp_buf_tag setjmp_buffer[1l];
  // original_emit_message
  void (*original_emit_message)(struct jpeg_common_struct *, signed int);
  // warning_seen
  signed int warning_seen;
};

struct netcam_caps
{
  // streaming
  unsigned char streaming;
  // content_length
  unsigned char content_length;
};

struct netcam_context
{
  // cnt
  struct context *cnt;
  // finish
  signed int finish;
  // threadnr
  signed int threadnr;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous$5 mutex;
  // exiting
  union anonymous$44 exiting;
  // cap_cond
  union anonymous$44 cap_cond;
  // pic_ready
  union anonymous$44 pic_ready;
  // start_capture
  signed int start_capture;
  // connect_host
  char *connect_host;
  // connect_port
  signed int connect_port;
  // connect_http_10
  signed int connect_http_10;
  // connect_http_11
  signed int connect_http_11;
  // connect_keepalive
  signed int connect_keepalive;
  // keepalive_thisconn
  signed int keepalive_thisconn;
  // keepalive_timeup
  signed int keepalive_timeup;
  // connect_request
  char *connect_request;
  // sock
  signed int sock;
  // timeout
  struct timeval timeout;
  // response
  struct rbuf *response;
  // ftp
  struct ftp_context *ftp;
  // file
  struct file_context *file;
  // rtsp
  struct rtsp_context *rtsp;
  // get_image
  signed int (*get_image)(struct netcam_context *);
  // caps
  struct netcam_caps caps;
  // boundary
  char *boundary;
  // boundary_length
  unsigned long int boundary_length;
  // latest
  struct netcam_image_buff *latest;
  // receiving
  struct netcam_image_buff *receiving;
  // jpegbuf
  struct netcam_image_buff *jpegbuf;
  // imgcnt
  signed int imgcnt;
  // imgcnt_last
  signed int imgcnt_last;
  // warning_count
  signed int warning_count;
  // error_count
  signed int error_count;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // JFIF_marker
  signed int JFIF_marker;
  // netcam_tolerant_check
  unsigned int netcam_tolerant_check;
  // last_image
  struct timeval last_image;
  // av_frame_time
  float av_frame_time;
  // jerr
  struct jpeg_error_mgr jerr;
  // setjmp_buffer
  struct __jmp_buf_tag setjmp_buffer[1l];
  // jpeg_error
  signed int jpeg_error;
};

struct netcam_image_buff
{
  // ptr
  char *ptr;
  // content_length
  signed int content_length;
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // image_time
  struct timeval image_time;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rbuf
{
  // buffer
  char buffer[4096l];
  // buffer_pos
  char *buffer_pos;
  // buffer_left
  unsigned long int buffer_left;
  // ret
  signed int ret;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct rtsp_context
{
  // format_context
  struct AVFormatContext *format_context;
  // codec_context
  struct AVCodecContext *codec_context;
  // video_stream_index
  signed int video_stream_index;
  // path
  char *path;
  // user
  char *user;
  // pass
  char *pass;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$17 __sigaction_handler;
  // sa_mask
  struct anonymous$16 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct st_list
{
  // prev
  struct st_list *prev;
  // next
  struct st_list *next;
  // data
  void *data;
};

struct st_mem_root
{
  // free
  struct st_used_mem *free;
  // used
  struct st_used_mem *used;
  // pre_alloc
  struct st_used_mem *pre_alloc;
  // min_malloc
  unsigned long int min_malloc;
  // block_size
  unsigned long int block_size;
  // block_num
  unsigned int block_num;
  // first_block_usage
  unsigned int first_block_usage;
  // error_handler
  void (*error_handler)(void);
};

struct st_net
{
  // vio
  struct st_vio *vio;
  // buff
  unsigned char *buff;
  // buff_end
  unsigned char *buff_end;
  // write_pos
  unsigned char *write_pos;
  // read_pos
  unsigned char *read_pos;
  // fd
  signed int fd;
  // remain_in_buf
  unsigned long int remain_in_buf;
  // length
  unsigned long int length;
  // buf_length
  unsigned long int buf_length;
  // where_b
  unsigned long int where_b;
  // max_packet
  unsigned long int max_packet;
  // max_packet_size
  unsigned long int max_packet_size;
  // pkt_nr
  unsigned int pkt_nr;
  // compress_pkt_nr
  unsigned int compress_pkt_nr;
  // write_timeout
  unsigned int write_timeout;
  // read_timeout
  unsigned int read_timeout;
  // retry_count
  unsigned int retry_count;
  // fcntl
  signed int fcntl;
  // return_status
  unsigned int *return_status;
  // reading_or_writing
  unsigned char reading_or_writing;
  // save_char
  char save_char;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // compress
  char compress;
  // unused3
  char unused3;
  // unused
  unsigned char *unused;
  // last_errno
  unsigned int last_errno;
  // error
  unsigned char error;
  // unused4
  char unused4;
  // unused5
  char unused5;
  // last_error
  char last_error[512l];
  // sqlstate
  char sqlstate[6l];
  // extension
  void *extension;
};

struct st_mysql_options
{
  // connect_timeout
  unsigned int connect_timeout;
  // read_timeout
  unsigned int read_timeout;
  // write_timeout
  unsigned int write_timeout;
  // port
  unsigned int port;
  // protocol
  unsigned int protocol;
  // client_flag
  unsigned long int client_flag;
  // host
  char *host;
  // user
  char *user;
  // password
  char *password;
  // unix_socket
  char *unix_socket;
  // db
  char *db;
  // init_commands
  struct st_dynamic_array *init_commands;
  // my_cnf_file
  char *my_cnf_file;
  // my_cnf_group
  char *my_cnf_group;
  // charset_dir
  char *charset_dir;
  // charset_name
  char *charset_name;
  // ssl_key
  char *ssl_key;
  // ssl_cert
  char *ssl_cert;
  // ssl_ca
  char *ssl_ca;
  // ssl_capath
  char *ssl_capath;
  // ssl_cipher
  char *ssl_cipher;
  // shared_memory_base_name
  char *shared_memory_base_name;
  // max_allowed_packet
  unsigned long int max_allowed_packet;
  // use_ssl
  char use_ssl;
  // compress
  char compress;
  // named_pipe
  char named_pipe;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // unused3
  char unused3;
  // unused4
  char unused4;
  // methods_to_use
  enum mysql_option methods_to_use;
  // ci
  union anonymous$3 ci;
  // secure_auth
  char secure_auth;
  // report_data_truncation
  char report_data_truncation;
  // local_infile_init
  signed int (*local_infile_init)(void **, const char *, void *);
  // local_infile_read
  signed int (*local_infile_read)(void *, char *, unsigned int);
  // local_infile_end
  void (*local_infile_end)(void *);
  // local_infile_error
  signed int (*local_infile_error)(void *, char *, unsigned int);
  // local_infile_userdata
  void *local_infile_userdata;
  // extension
  struct st_mysql_options_extention *extension;
};

struct st_mysql
{
  // net
  struct st_net net;
  // connector_fd
  unsigned char *connector_fd;
  // host
  char *host;
  // user
  char *user;
  // passwd
  char *passwd;
  // unix_socket
  char *unix_socket;
  // server_version
  char *server_version;
  // host_info
  char *host_info;
  // info
  char *info;
  // db
  char *db;
  // charset
  struct charset_info_st *charset;
  // fields
  struct st_mysql_field *fields;
  // field_alloc
  struct st_mem_root field_alloc;
  // affected_rows
  unsigned long long int affected_rows;
  // insert_id
  unsigned long long int insert_id;
  // extra_info
  unsigned long long int extra_info;
  // thread_id
  unsigned long int thread_id;
  // packet_length
  unsigned long int packet_length;
  // port
  unsigned int port;
  // client_flag
  unsigned long int client_flag;
  // server_capabilities
  unsigned long int server_capabilities;
  // protocol_version
  unsigned int protocol_version;
  // field_count
  unsigned int field_count;
  // server_status
  unsigned int server_status;
  // server_language
  unsigned int server_language;
  // warning_count
  unsigned int warning_count;
  // options
  struct st_mysql_options options;
  // status
  enum mysql_status status;
  // free_me
  char free_me;
  // reconnect
  char reconnect;
  // scramble
  char scramble[21l];
  // unused1
  char unused1;
  // unused2
  void *unused2;
  // unused3
  void *unused3;
  // unused4
  void *unused4;
  // unused5
  void *unused5;
  // stmts
  struct st_list *stmts;
  // methods
  struct st_mysql_methods *methods;
  // thd
  void *thd;
  // unbuffered_fetch_owner
  char *unbuffered_fetch_owner;
  // info_buffer
  char *info_buffer;
  // extension
  void *extension;
};

struct st_mysql_field
{
  // name
  char *name;
  // org_name
  char *org_name;
  // table
  char *table;
  // org_table
  char *org_table;
  // db
  char *db;
  // catalog
  char *catalog;
  // def
  char *def;
  // length
  unsigned long int length;
  // max_length
  unsigned long int max_length;
  // name_length
  unsigned int name_length;
  // org_name_length
  unsigned int org_name_length;
  // table_length
  unsigned int table_length;
  // org_table_length
  unsigned int org_table_length;
  // db_length
  unsigned int db_length;
  // catalog_length
  unsigned int catalog_length;
  // def_length
  unsigned int def_length;
  // flags
  unsigned int flags;
  // decimals
  unsigned int decimals;
  // charsetnr
  unsigned int charsetnr;
  // type
  enum enum_field_types type;
  // extension
  void *extension;
};

struct st_used_mem
{
  // next
  struct st_used_mem *next;
  // left
  unsigned int left;
  // size
  unsigned int size;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stream_buffer
{
  // ptr
  unsigned char *ptr;
  // ref
  signed int ref;
  // size
  signed long int size;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct tiff_writing
{
  // base
  unsigned char * const base;
  // buf
  unsigned char *buf;
  // data_offset
  unsigned int data_offset;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct url_t
{
  // service
  char *service;
  // userpass
  char *userpass;
  // host
  char *host;
  // port
  signed int port;
  // path
  char *path;
};

struct v4l2_clip
{
  // c
  struct v4l2_rect c;
  // next
  struct v4l2_clip *next;
};

struct v4l2_control
{
  // id
  unsigned int id;
  // value
  signed int value;
};

struct v4l2_fmtdesc
{
  // index
  unsigned int index;
  // type
  unsigned int type;
  // flags
  unsigned int flags;
  // description
  unsigned char description[32l];
  // pixelformat
  unsigned int pixelformat;
  // reserved
  unsigned int reserved[4l];
};

struct v4l2_fract
{
  // numerator
  unsigned int numerator;
  // denominator
  unsigned int denominator;
};

struct v4l2_frequency
{
  // tuner
  unsigned int tuner;
  // type
  unsigned int type;
  // frequency
  unsigned int frequency;
  // reserved
  unsigned int reserved[8l];
};

struct v4l2_input
{
  // index
  unsigned int index;
  // name
  unsigned char name[32l];
  // type
  unsigned int type;
  // audioset
  unsigned int audioset;
  // tuner
  unsigned int tuner;
  // std
  unsigned long long int std;
  // status
  unsigned int status;
  // capabilities
  unsigned int capabilities;
  // reserved
  unsigned int reserved[3l];
};

struct v4l2_plane
{
  // bytesused
  unsigned int bytesused;
  // length
  unsigned int length;
  // m
  union anonymous$32 m;
  // data_offset
  unsigned int data_offset;
  // reserved
  unsigned int reserved[11l];
};

struct v4l2_queryctrl
{
  // id
  unsigned int id;
  // type
  unsigned int type;
  // name
  unsigned char name[32l];
  // minimum
  signed int minimum;
  // maximum
  signed int maximum;
  // step
  signed int step;
  // default_value
  signed int default_value;
  // flags
  unsigned int flags;
  // reserved
  unsigned int reserved[2l];
};

struct v4l2_standard
{
  // index
  unsigned int index;
  // id
  unsigned long long int id;
  // name
  unsigned char name[24l];
  // frameperiod
  struct v4l2_fract frameperiod;
  // framelines
  unsigned int framelines;
  // reserved
  unsigned int reserved[4l];
};

struct v4l2_tuner
{
  // index
  unsigned int index;
  // name
  unsigned char name[32l];
  // type
  unsigned int type;
  // capability
  unsigned int capability;
  // rangelow
  unsigned int rangelow;
  // rangehigh
  unsigned int rangehigh;
  // rxsubchans
  unsigned int rxsubchans;
  // audmode
  unsigned int audmode;
  // signal
  signed int signal;
  // afc
  signed int afc;
  // reserved
  unsigned int reserved[4l];
};

struct video_dev
{
  // next
  struct video_dev *next;
  // usage_count
  signed int usage_count;
  // fd
  signed int fd;
  // video_device
  const char *video_device;
  // input
  signed int input;
  // norm
  signed int norm;
  // width
  signed int width;
  // height
  signed int height;
  // brightness
  signed int brightness;
  // contrast
  signed int contrast;
  // saturation
  signed int saturation;
  // hue
  signed int hue;
  // freq
  unsigned long int freq;
  // tuner_number
  signed int tuner_number;
  // fps
  signed int fps;
  // mutex
  union anonymous$5 mutex;
  // attr
  union anonymous$31 attr;
  // owner
  signed int owner;
  // frames
  signed int frames;
  // v4l2
  signed int v4l2;
  // v4l2_private
  void *v4l2_private;
  // size_map
  signed int size_map;
  // v4l_fmt
  signed int v4l_fmt;
  // v4l_buffers
  unsigned char *v4l_buffers[2l];
  // v4l_curbuffer
  signed int v4l_curbuffer;
  // v4l_maxbuffer
  signed int v4l_maxbuffer;
  // v4l_bufsize
  signed int v4l_bufsize;
};

struct video_image_buff
{
  // ptr
  unsigned char *ptr;
  // content_length
  signed int content_length;
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // image_time
  struct timeval image_time;
};


// EOI_data
// file jpegutils.c line 84
static unsigned char EOI_data[2l] = { (unsigned char)0xFF, (unsigned char)0xD9 };
// PADDING
// file md5.c line 58
static unsigned char PADDING[64l] = { (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// bad_method_response_template
// file webhttpd.c line 172
static const char *bad_method_response_template = "HTTP/1.0 501 Method Not Implemented\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Method Not Implemented</h1>\n<p>The method is not implemented by this server.</p>\n</body>\n</html>\n";
// bad_method_response_template_raw
// file webhttpd.c line 182
static const char *bad_method_response_template_raw = "HTTP/1.0 501 Method Not Implemented\r\nContent-type: text/plain\r\n\r\nMethod Not Implemented\n";
// bad_request_response
// file webhttpd.c line 62
static const char *bad_request_response = "HTTP/1.0 400 Bad Request\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Bad Request</h1>\n<p>The server did not understand your request.</p>\n</body>\n</html>\n";
// bad_request_response_raw
// file webhttpd.c line 72
static const char *bad_request_response_raw = "HTTP/1.0 400 Bad Request\r\nContent-type: text/plain\r\n\r\nBad Request";
// big_char_arr_ptr
// file draw.c line 20
unsigned char *big_char_arr_ptr[127l];
// big_table
// file draw.c line 1075
struct big_char big_table[80l];
// buf0
// file jpegutils.c line 296
static unsigned char buf0[16l][4096l];
// buf1
// file jpegutils.c line 297
static unsigned char buf1[8l][2048l];
// buf2
// file jpegutils.c line 298
static unsigned char buf2[8l][2048l];
// buffers
// file motion.c line 2961
struct MyBuffer buffers[32l];
// buffersink_ctx
// file ffmpeg.c line 1034
struct AVFilterContext *buffersink_ctx;
// buffersrc_ctx
// file ffmpeg.c line 1035
struct AVFilterContext *buffersrc_ctx;
// chr1
// file jpegutils.c line 299
static unsigned char chr1[8l][2048l];
// chr2
// file jpegutils.c line 300
static unsigned char chr2[8l][2048l];
// cnt_list
// file motion.c line 51
struct context **cnt_list = (struct context **)(void *)0;
// conf_template
// file conf.c line 45
struct config conf_template = { .log_level=(unsigned int)(5 + 10), .log_type_str=(char *)(void *)0, .log_file=(char *)(void *)0,
    .setup_mode=0, .width=352,
    .height=288, .quality=75, .rotate_deg=0,
    .max_changes=1500, .threshold_tune=0, .output_pictures="on",
    .motion_img=0, .emulate_motion=0,
    .event_gap=60, .max_movie_time=3600, .snapshot_interval=0,
    .locate_motion_mode="off", .locate_motion_style="box",
    .input=-1, .norm=0,
    .frame_limit=100, .quiet=1, .useextpipe=0,
    .extpipe=(const char *)(void *)0, .picture_type="jpeg",
    .noise=32, .noise_tune=1, .minimum_frame_time=0,
    .lightswitch=0, .autobright=0,
    .brightness=0, .contrast=0, .saturation=0,
    .hue=0, .roundrobin_frames=1, .roundrobin_skip=1,
    .pre_capture=0, .post_capture=0, .switchfilter=0,
    .ffmpeg_output=0, .ffmpeg_output_debug=0, .ffmpeg_bps=400000,
    .ffmpeg_vbr=0, .ffmpeg_deinterlace=0, .ffmpeg_video_codec="mpeg4",
    .sdl_threadnr=0, .ipv6_enabled=0,
    .stream_port=0, .stream_quality=50, .stream_motion=0,
    .stream_maxrate=1, .stream_localhost=1,
    .stream_limit=0, .stream_auth_method=0,
    .stream_authentication=(const char *)(void *)0, .webcontrol_port=0,
    .webcontrol_localhost=1, .webcontrol_html_output=1,
    .webcontrol_authentication=(const char *)(void *)0, .frequency=(unsigned long int)0,
    .tuner_number=0, .timelapse=0,
    .timelapse_mode="daily", .video_device="/dev/video0",
    .v4l2_palette=17, .vidpipe=(const char *)(void *)0,
    .filepath=(const char *)(void *)0, .imagepath="%v-%Y%m%d%H%M%S-%q",
    .moviepath="%v-%Y%m%d%H%M%S", .snappath="%v-%Y%m%d%H%M%S-snapshot",
    .timepath="%Y%m%d-timelapse",
    .on_event_start=(char *)(void *)0, .on_event_end=(char *)(void *)0,
    .mask_file=(const char *)(void *)0, .smart_mask_speed=0,
    .sql_log_image=1, .sql_log_snapshot=1,
    .sql_log_movie=0, .sql_log_timelapse=0,
    .sql_query="sql_query insert into security(camera, filename, frame, file_type, time_stamp, event_time_stamp) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')", .database_type=(const char *)(void *)0,
    .database_dbname=(const char *)(void *)0,
    .database_host="localhost",
    .database_user=(const char *)(void *)0, .database_password=(const char *)(void *)0,
    .sqlite3_db=(const char *)(void *)0,
    .database_port=0,
    .on_picture_save=(char *)(void *)0, .on_area_detected=(char *)(void *)0,
    .on_motion_detected=(char *)(void *)0,
    .on_movie_start=(char *)(void *)0,
    .on_movie_end=(char *)(void *)0, .on_camera_lost=(char *)(void *)0,
    .motionvidpipe=(const char *)(void *)0, .netcam_url=(const char *)(void *)0,
    .netcam_userpass=(const char *)(void *)0,
    .netcam_keepalive="off",
    .netcam_proxy=(const char *)(void *)0, .netcam_tolerant_check=(unsigned int)0,
    .text_changes=0,
    .text_left=(const char *)(void *)0, .text_right="%Y-%m-%d\\n%T",
    .text_event="%Y%m%d%H%M%S", .text_double=0,
    .despeckle_filter=(const char *)(void *)0, .area_detect=(const char *)(void *)0,
    .minimum_motion_frames=1,
    .exif_text=(const char *)(void *)0, .pid_file=(char *)(void *)0,
    .argc=0, .argv=((char **)NULL) };
// config_params
// file conf.c line 182
struct anonymous config_params[130l];
// config_params
// file conf.c line 182
struct anonymous config_params[130l] = { { .param_name="daemon", .param_help="############################################################\n# Daemon\n############################################################\n\n# Start in daemon (background) mode and release terminal (default: off)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->daemon, .copy=copy_bool,
    .print=print_bool },
    { .param_name="process_id_file", .param_help="#File to store the process ID, also called pid file. (default: not defined)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.pid_file, .copy=copy_string,
    .print=print_string },
    { .param_name="setup_mode", .param_help="############################################################\n# Basic Setup Mode\n############################################################\n\n# Start in Setup-Mode, daemon disabled. (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.setup_mode, .copy=copy_bool,
    .print=print_bool },
    { .param_name="logfile", .param_help="# Use a file to save logs messages, if not defined stderr and syslog is used. (default: not defined)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.log_file, .copy=copy_string,
    .print=print_string },
    { .param_name="log_level", .param_help="# Level of log messages [1..9] (EMR, ALR, CRT, ERR, WRN, NTC, ERR, DBG, ALL). (default: 6 / NTC)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.log_level, .copy=copy_int,
    .print=print_int },
    { .param_name="log_type", .param_help="# Filter to log messages by type (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). (default: ALL)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.log_type_str, .copy=copy_string,
    .print=print_string },
    { .param_name="videodevice", .param_help="\n###########################################################\n# Capture device options\n############################################################\n\n# Videodevice to be used for capturing  (default /dev/video0)\n# for FreeBSD default is /dev/bktr0", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.video_device, .copy=copy_string,
    .print=print_string },
    { .param_name="v4l2_palette", .param_help="# v4l2_palette allows to choose preferable palette to be use by motion\n# to capture from those supported by your videodevice. (default: 17)\n# E.g. if your videodevice supports both V4L2_PIX_FMT_SBGGR8 and\n# V4L2_PIX_FMT_MJPEG then motion will by default use V4L2_PIX_FMT_MJPEG.\n# Setting v4l2_palette to 2 forces motion to use V4L2_PIX_FMT_SBGGR8\n# instead.\n#\n# Values :\n# V4L2_PIX_FMT_SN9C10X : 0  'S910'\n# V4L2_PIX_FMT_SBGGR16 : 1  'BYR2'\n# V4L2_PIX_FMT_SBGGR8  : 2  'BA81'\n# V4L2_PIX_FMT_SPCA561 : 3  'S561'\n# V4L2_PIX_FMT_SGBRG8  : 4  'GBRG'\n# V4L2_PIX_FMT_SGRBG8  : 5  'GRBG'\n# V4L2_PIX_FMT_PAC207  : 6  'P207'\n# V4L2_PIX_FMT_PJPG    : 7  'PJPG'\n# V4L2_PIX_FMT_MJPEG   : 8  'MJPEG'\n# V4L2_PIX_FMT_JPEG    : 9  'JPEG'\n# V4L2_PIX_FMT_RGB24   : 10 'RGB3'\n# V4L2_PIX_FMT_SPCA501 : 11 'S501'\n# V4L2_PIX_FMT_SPCA505 : 12 'S505'\n# V4L2_PIX_FMT_SPCA508 : 13 'S508'\n# V4L2_PIX_FMT_UYVY    : 14 'UYVY'\n# V4L2_PIX_FMT_YUYV    : 15 'YUYV'\n# V4L2_PIX_FMT_YUV422P : 16 '422P'\n# V4L2_PIX_FMT_YUV420  : 17 'YU12'\n#", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.v4l2_palette, .copy=copy_int,
    .print=print_int },
    { .param_name="input", .param_help="# The video input to be used (default: -1)\n# Should normally be set to 0 or 1 for video/TV cards, and -1 for USB cameras", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.input, .copy=copy_int,
    .print=print_int },
    { .param_name="norm", .param_help="# The video norm to use (only for video capture and TV tuner cards)\n# Values: 0 (PAL), 1 (NTSC), 2 (SECAM), 3 (PAL NC no colour). Default: 0 (PAL)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.norm, .copy=copy_int,
    .print=print_int },
    { .param_name="frequency", .param_help="# The frequency to set the tuner to (kHz) (only for TV tuner cards) (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.frequency, .copy=copy_int,
    .print=print_int },
    { .param_name="rotate", .param_help="# Rotate image this number of degrees. The rotation affects all saved images as\n# well as movies. Valid values: 0 (default = no rotation), 90, 180 and 270.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.rotate_deg, .copy=copy_int,
    .print=print_int },
    { .param_name="width", .param_help="# Image width (pixels). Valid range: Camera dependent, default: 352", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.width, .copy=copy_int,
    .print=print_int },
    { .param_name="height", .param_help="# Image height (pixels). Valid range: Camera dependent, default: 288", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.height, .copy=copy_int,
    .print=print_int },
    { .param_name="framerate", .param_help="# Maximum number of frames to be captured per second.\n# Valid range: 2-100. Default: 100 (almost no limit).", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.frame_limit, .copy=copy_int,
    .print=print_int },
    { .param_name="minimum_frame_time", .param_help="# Minimum time in seconds between capturing picture frames from the camera.\n# Default: 0 = disabled - the capture rate is given by the camera framerate.\n# This option is used when you want to capture images at a rate lower than 2 per second.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.minimum_frame_time, .copy=copy_int,
    .print=print_int },
    { .param_name="netcam_url", .param_help="# URL to use if you are using a network camera, size will be autodetected (incl http:// ftp:// mjpg:// or file:///)\n# Must be a URL that returns single jpeg pictures or a raw mjpeg stream. Default: Not defined", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.netcam_url, .copy=copy_string,
    .print=print_string },
    { .param_name="netcam_userpass", .param_help="# Username and password for network camera (only if required). Default: not defined\n# Syntax is user:password", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.netcam_userpass, .copy=copy_string,
    .print=print_string },
    { .param_name="netcam_keepalive", .param_help="# The setting for keep-alive of network socket, should improve performance on compatible net cameras.\n# off:   The historical implementation using HTTP/1.0, closing the socket after each http request.\n# force: Use HTTP/1.0 requests with keep alive header to reuse the same connection.\n# on:    Use HTTP/1.1 requests that support keep alive as default.\n# Default: off", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.netcam_keepalive, .copy=copy_string,
    .print=print_string },
    { .param_name="netcam_proxy", .param_help="# URL to use for a netcam proxy server, if required, e.g. \"http://myproxy\".\n# If a port number other than 80 is needed, use \"http://myproxy:1234\".\n# Default: not defined", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.netcam_proxy, .copy=copy_string,
    .print=print_string },
    { .param_name="netcam_tolerant_check", .param_help="# Set less strict jpeg checks for network cameras with a poor/buggy firmware.\n# Default: off", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.netcam_tolerant_check, .copy=copy_bool,
    .print=print_bool },
    { .param_name="auto_brightness", .param_help="# Let motion regulate the brightness of a video device (default: off).\n# The auto_brightness feature uses the brightness option as its target value.\n# If brightness is zero auto_brightness will adjust to average brightness value 128.\n# Only recommended for cameras without auto brightness", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.autobright, .copy=copy_bool,
    .print=print_bool },
    { .param_name="brightness", .param_help="# Set the initial brightness of a video device.\n# If auto_brightness is enabled, this value defines the average brightness level\n# which Motion will try and adjust to.\n# Valid range 0-255, default 0 = disabled", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.brightness, .copy=copy_int,
    .print=print_int },
    { .param_name="contrast", .param_help="# Set the contrast of a video device.\n# Valid range 0-255, default 0 = disabled", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.contrast, .copy=copy_int,
    .print=print_int },
    { .param_name="saturation", .param_help="# Set the saturation of a video device.\n# Valid range 0-255, default 0 = disabled", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.saturation, .copy=copy_int,
    .print=print_int },
    { .param_name="hue", .param_help="# Set the hue of a video device (NTSC feature).\n# Valid range 0-255, default 0 = disabled", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.hue, .copy=copy_int,
    .print=print_int },
    { .param_name="roundrobin_frames", .param_help="\n############################################################\n# Round Robin (multiple inputs on same video device name)\n############################################################\n\n# Number of frames to capture in each roundrobin step (default: 1)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.roundrobin_frames, .copy=copy_int,
    .print=print_int },
    { .param_name="roundrobin_skip", .param_help="# Number of frames to skip before each roundrobin step (default: 1)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.roundrobin_skip, .copy=copy_int,
    .print=print_int },
    { .param_name="switchfilter", .param_help="# Try to filter out noise generated by roundrobin (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.switchfilter, .copy=copy_bool,
    .print=print_bool },
    { .param_name="threshold", .param_help="\n############################################################\n# Motion Detection Settings:\n############################################################\n\n# Threshold for number of changed pixels in an image that\n# triggers motion detection (default: 1500)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.max_changes, .copy=copy_int,
    .print=print_int },
    { .param_name="threshold_tune", .param_help="# Automatically tune the threshold down if possible (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.threshold_tune, .copy=copy_bool,
    .print=print_bool },
    { .param_name="noise_level", .param_help="# Noise threshold for the motion detection (default: 32)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.noise, .copy=copy_int,
    .print=print_int },
    { .param_name="noise_tune", .param_help="# Automatically tune the noise threshold (default: on)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.noise_tune, .copy=copy_bool,
    .print=print_bool },
    { .param_name="despeckle_filter", .param_help="# Despeckle motion image using (e)rode or (d)ilate or (l)abel (Default: not defined)\n# Recommended value is EedDl. Any combination (and number of) of E, e, d, and D is valid.\n# (l)abeling must only be used once and the 'l' must be the last letter.\n# Comment out to disable", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.despeckle_filter, .copy=copy_string,
    .print=print_string },
    { .param_name="area_detect", .param_help="# Detect motion in predefined areas (1 - 9). Areas are numbered like that:  1 2 3\n# A script (on_area_detected) is started immediately when motion is         4 5 6\n# detected in one of the given areas, but only once during an event.        7 8 9\n# One or more areas can be specified with this option. Take care: This option\n# does NOT restrict detection to these areas! (Default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.area_detect, .copy=copy_string,
    .print=print_string },
    { .param_name="mask_file", .param_help="# PGM file to use as a sensitivity mask.\n# Full path name to. (Default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.mask_file, .copy=copy_string,
    .print=print_string },
    { .param_name="smart_mask_speed", .param_help="# Dynamically create a mask file during operation (default: 0)\n# Adjust speed of mask changes from 0 (off) to 10 (fast)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.smart_mask_speed, .copy=copy_int,
    .print=print_int },
    { .param_name="lightswitch", .param_help="# Ignore sudden massive light intensity changes given as a percentage of the picture\n# area that changed intensity. If set to 1, motion will do some kind of\n# auto-lightswitch. Valid range: 0 - 100 , default: 0 = disabled", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.lightswitch, .copy=copy_int,
    .print=print_int },
    { .param_name="minimum_motion_frames", .param_help="# Picture frames must contain motion at least the specified number of frames\n# in a row before they are detected as true motion. At the default of 1, all\n# motion is detected. Valid range: 1 to thousands, recommended 1-5", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.minimum_motion_frames, .copy=copy_int,
    .print=print_int },
    { .param_name="pre_capture", .param_help="# Specifies the number of pre-captured (buffered) pictures from before motion\n# was detected that will be output at motion detection.\n# Recommended range: 0 to 5 (default: 0)\n# Do not use large values! Large values will cause Motion to skip video frames and\n# cause unsmooth movies. To smooth movies use larger values of post_capture instead.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.pre_capture, .copy=copy_int,
    .print=print_int },
    { .param_name="post_capture", .param_help="# Number of frames to capture after motion is no longer detected (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.post_capture, .copy=copy_int,
    .print=print_int },
    { .param_name="event_gap", .param_help="# Event Gap is the seconds of no motion detection that triggers the end of an event.\n# An event is defined as a series of motion images taken within a short timeframe.\n# Recommended value is 60 seconds (Default). The value -1 is allowed and disables\n# events causing all Motion to be written to one single movie file and no pre_capture.\n# If set to 0, motion is running in gapless mode. Movies don't have gaps anymore. An\n# event ends right after no more motion is detected and post_capture is over.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.event_gap, .copy=copy_int,
    .print=print_int },
    { .param_name="max_movie_time", .param_help="# Maximum length in seconds of a movie\n# When value is exceeded a new movie file is created. (Default: 0 = infinite)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.max_movie_time, .copy=copy_int,
    .print=print_int },
    { .param_name="emulate_motion", .param_help="# Always save images even if there was no motion (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.emulate_motion, .copy=copy_bool,
    .print=print_bool },
    { .param_name="output_pictures", .param_help="\n############################################################\n# Image File Output\n############################################################\n\n# Output 'normal' pictures when motion is detected (default: on)\n# Valid values: on, off, first, best, center\n# When set to 'first', only the first picture of an event is saved.\n# Picture with most motion of an event is saved when set to 'best'.\n# Picture with motion nearest center of picture is saved when set to 'center'.\n# Can be used as preview shot for the corresponding movie.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.output_pictures, .copy=copy_string,
    .print=print_string },
    { .param_name="output_debug_pictures", .param_help="# Output pictures with only the pixels moving object (ghost images) (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.motion_img, .copy=copy_bool,
    .print=print_bool },
    { .param_name="quality", .param_help="# The quality (in percent) to be used by the jpeg compression (default: 75)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.quality, .copy=copy_int,
    .print=print_int },
    { .param_name="picture_type", .param_help="# Type of output images\n# Valid values: jpeg, ppm (default: jpeg)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.picture_type, .copy=copy_string,
    .print=print_string },
    { .param_name="ffmpeg_output_movies", .param_help="\n############################################################\n# FFMPEG related options\n# Film (movie) file output, and deinterlacing of the video input\n# The options movie_filename and timelapse_filename are also used\n# by the ffmpeg feature\n############################################################\n\n# Use ffmpeg to encode movies in realtime (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_output, .copy=copy_bool,
    .print=print_bool },
    { .param_name="ffmpeg_output_debug_movies", .param_help="# Use ffmpeg to make movies with only the pixels moving\n# object (ghost images) (default: off)",
    .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_output_debug, .copy=copy_bool,
    .print=print_bool },
    { .param_name="ffmpeg_timelapse", .param_help="# Use ffmpeg to encode a timelapse movie\n# Default value 0 = off - else save frame every Nth second", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.timelapse, .copy=copy_int,
    .print=print_int },
    { .param_name="ffmpeg_timelapse_mode", .param_help="# The file rollover mode of the timelapse video\n# Valid values: hourly, daily (default), weekly-sunday, weekly-monday, monthly, manual", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.timelapse_mode, .copy=copy_string,
    .print=print_string },
    { .param_name="ffmpeg_bps", .param_help="# Bitrate to be used by the ffmpeg encoder (default: 400000)\n# This option is ignored if ffmpeg_variable_bitrate is not 0 (disabled)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_bps, .copy=copy_int,
    .print=print_int },
    { .param_name="ffmpeg_variable_bitrate", .param_help="# Enables and defines variable bitrate for the ffmpeg encoder.\n# ffmpeg_bps is ignored if variable bitrate is enabled.\n# Valid values: 0 (default) = fixed bitrate defined by ffmpeg_bps,\n# or the range 2 - 31 where 2 means best quality and 31 is worst.",
    .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_vbr, .copy=copy_int,
    .print=print_int },
    { .param_name="ffmpeg_video_codec", .param_help="# Codec to used by ffmpeg for the video compression.\n# Timelapse movies are always made in mpeg1 format independent from this option.\n# Supported formats are: mpeg1 (ffmpeg-0.4.8 only), mpeg4 (default), and msmpeg4.\n# mpeg1 - gives you files with extension .mpg\n# mpeg4 or msmpeg4 - gives you files with extension .avi\n# msmpeg4 is recommended for use with Windows Media Player because\n# it requires no installation of codec on the Windows client.\n# swf - gives you a flash film with extension .swf\n# flv - gives you a flash video with extension .flv\n# ffv1 - FF video codec 1 for Lossless Encoding ( experimental )\n# mov - QuickTime ( testing )\n# ogg - Ogg/Theora ( testing )", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_video_codec, .copy=copy_string,
    .print=print_string },
    { .param_name="ffmpeg_deinterlace", .param_help="# Use ffmpeg to deinterlace video. Necessary if you use an analog camera\n# and see horizontal combing on moving objects in video or pictures.\n# (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ffmpeg_deinterlace, .copy=copy_bool,
    .print=print_bool },
    { .param_name="sdl_threadnr", .param_help="\n############################################################\n# SDL Window\n############################################################\n\n# Number of motion thread to show in SDL Window (default: 0 = disabled)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sdl_threadnr, .copy=copy_int,
    .print=print_int },
    { .param_name="use_extpipe", .param_help="\n############################################################\n# External pipe to video encoder\n# Replacement for FFMPEG builtin encoder for ffmpeg_output_movies only.\n# The options movie_filename and timelapse_filename are also used\n# by the ffmpeg feature\n############################################################\n\n# Bool to enable or disable extpipe (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.useextpipe, .copy=copy_bool,
    .print=print_bool },
    { .param_name="extpipe", .param_help="# External program (full path and opts) to pipe raw video to\n# Generally, use '-' for STDIN...", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.extpipe, .copy=copy_string,
    .print=print_string },
    { .param_name="snapshot_interval", .param_help="\n############################################################\n# Snapshots (Traditional Periodic Webcam File Output)\n############################################################\n\n# Make automated snapshot every N seconds (default: 0 = disabled)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.snapshot_interval, .copy=copy_int,
    .print=print_int },
    { .param_name="locate_motion_mode", .param_help="\n############################################################\n# Text Display\n# %Y = year, %m = month, %d = date,\n# %H = hour, %M = minute, %S = second, %T = HH:MM:SS,\n# %v = event, %q = frame number, %t = thread (camera) number,\n# %D = changed pixels, %N = noise level, \\n = new line,\n# %i and %J = width and height of motion area,\n# %K and %L = X and Y coordinates of motion center\n# %C = value defined by text_event - do not use with text_event!\n# You can put quotation marks around the text to allow\n# leading spaces\n############################################################\n\n# Locate and draw a box around the moving object.\n# Valid values: on, off, preview (default: off)\n# Set to 'preview' will only draw a box in preview_shot pictures.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.locate_motion_mode, .copy=copy_string,
    .print=print_string },
    { .param_name="locate_motion_style", .param_help="# Set the look and style of the locate box if enabled.\n# Valid values: box, redbox, cross, redcross (default: box)\n# Set to 'box' will draw the traditional box.\n# Set to 'redbox' will draw a red box.\n# Set to 'cross' will draw a little cross to mark center.\n# Set to 'redcross' will draw a little red cross to mark center.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.locate_motion_style, .copy=copy_string,
    .print=print_string },
    { .param_name="text_right", .param_help="# Draws the timestamp using same options as C function strftime(3)\n# Default: %Y-%m-%d\\n%T = date in ISO format and time in 24 hour clock\n# Text is placed in lower right corner", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.text_right, .copy=copy_string,
    .print=print_string },
    { .param_name="text_left", .param_help="# Draw a user defined text on the images using same options as C function strftime(3)\n# Default: Not defined = no text\n# Text is placed in lower left corner", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.text_left, .copy=copy_string,
    .print=print_string },
    { .param_name="text_changes", .param_help="# Draw the number of changed pixed on the images (default: off)\n# Will normally be set to off except when you setup and adjust the motion settings\n# Text is placed in upper right corner", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.text_changes, .copy=copy_bool,
    .print=print_bool },
    { .param_name="text_event", .param_help="# This option defines the value of the special event conversion specifier %C\n# You can use any conversion specifier in this option except %C. Date and time\n# values are from the timestamp of the first image in the current event.\n# Default: %Y%m%d%H%M%S\n# The idea is that %C can be used filenames and text_left/right for creating\n# a unique identifier for each event.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.text_event, .copy=copy_string,
    .print=print_string },
    { .param_name="text_double", .param_help="# Draw characters at twice normal size on images. (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.text_double, .copy=copy_bool,
    .print=print_bool },
    { .param_name="exif_text", .param_help="# Text to include in a JPEG EXIF comment\n# May be any text, including conversion specifiers.\n# The EXIF timestamp is included independent of this text.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.exif_text, .copy=copy_string,
    .print=print_string },
    { .param_name="target_dir", .param_help="\n############################################################\n# Target Directories and filenames For Images And Films\n# For the options snapshot_, picture_, movie_ and timelapse_filename\n# you can use conversion specifiers\n# %Y = year, %m = month, %d = date,\n# %H = hour, %M = minute, %S = second,\n# %v = event, %q = frame number, %t = thread (camera) number,\n# %D = changed pixels, %N = noise level,\n# %i and %J = width and height of motion area,\n# %K and %L = X and Y coordinates of motion center\n# %C = value defined by text_event\n# Quotation marks round string are allowed.\n############################################################\n\n# Target base directory for pictures and films\n# Recommended to use absolute path. (Default: current working directory)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.filepath, .copy=copy_string,
    .print=print_string },
    { .param_name="snapshot_filename", .param_help="# File path for snapshots (jpeg or ppm) relative to target_dir\n# Default: %v-%Y%m%d%H%M%S-snapshot\n# Default value is equivalent to legacy oldlayout option\n# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H/%M/%S-snapshot\n# File extension .jpg or .ppm is automatically added so do not include this.\n# Note: A symbolic link called lastsnap.jpg created in the target_dir will always\n# point to the latest snapshot, unless snapshot_filename is exactly 'lastsnap'", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.snappath, .copy=copy_string,
    .print=print_string },
    { .param_name="picture_filename", .param_help="# File path for motion triggered images (jpeg or ppm) relative to target_dir\n# Default: %v-%Y%m%d%H%M%S-%q\n# Default value is equivalent to legacy oldlayout option\n# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H/%M/%S-%q\n# File extension .jpg or .ppm is automatically added so do not include this\n# Set to 'preview' together with best-preview feature enables special naming\n# convention for preview shots. See motion guide for details", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.imagepath, .copy=copy_string,
    .print=print_string },
    { .param_name="movie_filename", .param_help="# File path for motion triggered ffmpeg films (movies) relative to target_dir\n# Default: %v-%Y%m%d%H%M%S\n# Default value is equivalent to legacy oldlayout option\n# For Motion 3.0 compatible mode choose: %Y/%m/%d/%H%M%S\n# File extension .mpg or .avi is automatically added so do not include this\n# This option was previously called ffmpeg_filename", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.moviepath, .copy=copy_string,
    .print=print_string },
    { .param_name="timelapse_filename", .param_help="# File path for timelapse movies relative to target_dir\n# Default: %Y%m%d-timelapse\n# Default value is near equivalent to legacy oldlayout option\n# For Motion 3.0 compatible mode choose: %Y/%m/%d-timelapse\n# File extension .mpg is automatically added so do not include this", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.timepath, .copy=copy_string,
    .print=print_string },
    { .param_name="ipv6_enabled", .param_help="\n############################################################\n# Global Network Options\n############################################################\n\n# Enable or disable IPV6 for http control and stream (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.ipv6_enabled, .copy=copy_bool,
    .print=print_bool },
    { .param_name="stream_port", .param_help="\n############################################################\n# Live Stream Server\n############################################################\n\n# The mini-http server listens to this port for requests (default: 0 = disabled)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_port, .copy=copy_int,
    .print=print_int },
    { .param_name="stream_quality", .param_help="# Quality of the jpeg (in percent) images produced (default: 50)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_quality, .copy=copy_int,
    .print=print_int },
    { .param_name="stream_motion", .param_help="# Output frames at 1 fps when no motion is detected and increase to the\n# rate given by stream_maxrate when motion is detected (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_motion, .copy=copy_bool,
    .print=print_bool },
    { .param_name="stream_maxrate", .param_help="# Maximum framerate for streams (default: 1)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_maxrate, .copy=copy_int,
    .print=print_int },
    { .param_name="stream_localhost", .param_help="# Restrict stream connections to localhost only (default: on)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_localhost, .copy=copy_bool,
    .print=print_bool },
    { .param_name="stream_limit", .param_help="# Limits the number of images per connection (default: 0 = unlimited)\n# Number can be defined by multiplying actual stream rate by desired number of seconds\n# Actual stream rate is the smallest of the numbers framerate and stream_maxrate", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_limit, .copy=copy_int,
    .print=print_int },
    { .param_name="stream_auth_method", .param_help="# Set the authentication method (default: 0)\n# 0 = disabled \n# 1 = Basic authentication\n# 2 = MD5 digest (the safer authentication)\n", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_auth_method, .copy=copy_int,
    .print=print_int },
    { .param_name="stream_authentication", .param_help="# Authentication for the stream. Syntax username:password\n# Default: not defined (Disabled)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.stream_authentication, .copy=copy_string,
    .print=print_string },
    { .param_name="webcontrol_port", .param_help="\n############################################################\n# HTTP Based Control\n############################################################\n\n# TCP/IP port for the http server to listen on (default: 0 = disabled)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.webcontrol_port, .copy=copy_int,
    .print=print_int },
    { .param_name="webcontrol_localhost", .param_help="# Restrict control connections to localhost only (default: on)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.webcontrol_localhost, .copy=copy_bool,
    .print=print_bool },
    { .param_name="webcontrol_html_output", .param_help="# Output for http server, select off to choose raw text plain (default: on)", .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.webcontrol_html_output, .copy=copy_bool,
    .print=print_bool },
    { .param_name="webcontrol_authentication", .param_help="# Authentication for the http based control. Syntax username:password\n# Default: not defined (Disabled)",
    .main_thread=(unsigned int)1,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.webcontrol_authentication, .copy=copy_string,
    .print=print_string },
    { .param_name="track_type", .param_help="\n############################################################\n# Tracking (Pan/Tilt)\n############################################################\n\n# Type of tracker (0=none (default), 1=stepper, 2=iomojo, 3=pwc, 4=generic, 5=uvcvideo, 6=servo)\n# The generic type enables the definition of motion center and motion size to\n# be used with the conversion specifiers for options like on_motion_detected", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.type, .copy=copy_int,
    .print=print_int },
    { .param_name="track_auto", .param_help="# Enable auto tracking (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.active, .copy=copy_bool,
    .print=print_bool },
    { .param_name="track_port", .param_help="# Serial port of motor (default: none)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.port, .copy=copy_string,
    .print=print_string },
    { .param_name="track_motorx", .param_help="# Motor number for x-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.motorx, .copy=copy_int,
    .print=print_int },
    { .param_name="track_motorx_reverse", .param_help="# Set motorx reverse (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.motorx_reverse, .copy=copy_bool,
    .print=print_bool },
    { .param_name="track_motory", .param_help="# Motor number for y-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.motory, .copy=copy_int,
    .print=print_int },
    { .param_name="track_motory_reverse", .param_help="# Set motory reverse (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.motory_reverse, .copy=copy_bool,
    .print=print_bool },
    { .param_name="track_maxx", .param_help="# Maximum value on x-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.maxx, .copy=copy_int,
    .print=print_int },
    { .param_name="track_minx", .param_help="# Minimum value on x-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.minx, .copy=copy_int,
    .print=print_int },
    { .param_name="track_maxy", .param_help="# Maximum value on y-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.maxy, .copy=copy_int,
    .print=print_int },
    { .param_name="track_miny", .param_help="# Minimum value on y-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.miny, .copy=copy_int,
    .print=print_int },
    { .param_name="track_homex", .param_help="# Center value on x-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.homex, .copy=copy_int,
    .print=print_int },
    { .param_name="track_homey", .param_help="# Center value on y-axis (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.homey, .copy=copy_int,
    .print=print_int },
    { .param_name="track_iomojo_id", .param_help="# ID of an iomojo camera if used (default: 0)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.iomojo_id, .copy=copy_int,
    .print=print_int },
    { .param_name="track_step_angle_x", .param_help="# Angle in degrees the camera moves per step on the X-axis\n# with auto-track (default: 10)\n# Currently only used with pwc type cameras", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.step_angle_x, .copy=copy_int,
    .print=print_int },
    { .param_name="track_step_angle_y", .param_help="# Angle in degrees the camera moves per step on the Y-axis\n# with auto-track (default: 10)\n# Currently only used with pwc type cameras", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.step_angle_y, .copy=copy_int,
    .print=print_int },
    { .param_name="track_move_wait", .param_help="# Delay to wait for after tracking movement as number\n# of picture frames (default: 10)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.move_wait, .copy=copy_int,
    .print=print_int },
    { .param_name="track_speed", .param_help="# Speed to set the motor to (stepper motor option) (default: 255)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.speed, .copy=copy_int,
    .print=print_int },
    { .param_name="track_stepsize", .param_help="# Number of steps to make (stepper motor option) (default: 40)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->track.stepsize, .copy=copy_int,
    .print=print_int },
    { .param_name="quiet", .param_help="\n############################################################\n# External Commands, Warnings and Logging:\n# You can use conversion specifiers for the on_xxxx commands\n# %Y = year, %m = month, %d = date,\n# %H = hour, %M = minute, %S = second,\n# %v = event, %q = frame number, %t = thread (camera) number,\n# %D = changed pixels, %N = noise level,\n# %i and %J = width and height of motion area,\n# %K and %L = X and Y coordinates of motion center\n# %C = value defined by text_event\n# %f = filename with full path\n# %n = number indicating filetype\n# Both %f and %n are only defined for on_picture_save,\n# on_movie_start and on_movie_end\n# Quotation marks round string are allowed.\n############################################################\n\n# Do not sound beeps when detecting motion (default: on)\n# Note: Motion never beeps when running in daemon mode.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.quiet, .copy=copy_bool,
    .print=print_bool },
    { .param_name="on_event_start", .param_help="# Command to be executed when an event starts. (default: none)\n# An event starts at first motion detected after a period of no motion defined by event_gap ", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_event_start, .copy=copy_string,
    .print=print_string },
    { .param_name="on_event_end", .param_help="# Command to be executed when an event ends after a period of no motion\n# (default: none). The period of no motion is defined by option event_gap.", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_event_end, .copy=copy_string,
    .print=print_string },
    { .param_name="on_picture_save", .param_help="# Command to be executed when a picture (.ppm|.jpg) is saved (default: none)\n# To give the filename as an argument to a command append it with %f", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_picture_save, .copy=copy_string,
    .print=print_string },
    { .param_name="on_motion_detected", .param_help="# Command to be executed when a motion frame is detected (default: none)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_motion_detected, .copy=copy_string,
    .print=print_string },
    { .param_name="on_area_detected", .param_help="# Command to be executed when motion in a predefined area is detected\n# Check option 'area_detect'. (default: none)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_area_detected, .copy=copy_string,
    .print=print_string },
    { .param_name="on_movie_start", .param_help="# Command to be executed when a movie file (.mpg|.avi) is created. (default: none)\n# To give the filename as an argument to a command append it with %f", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_movie_start, .copy=copy_string,
    .print=print_string },
    { .param_name="on_movie_end", .param_help="# Command to be executed when a movie file (.mpg|.avi) is closed. (default: none)\n# To give the filename as an argument to a command append it with %f", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_movie_end, .copy=copy_string,
    .print=print_string },
    { .param_name="on_camera_lost", .param_help="# Command to be executed when a camera can't be opened or if it is lost\n# NOTE: There is situations when motion don't detect a lost camera!\n# It depends on the driver, some drivers dosn't detect a lost camera at all\n# Some hangs the motion thread. Some even hangs the PC! (default: none)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.on_camera_lost, .copy=copy_string,
    .print=print_string },
    { .param_name="sql_log_picture", .param_help="\n############################################################\n# Common Options for database features.\n# Options require the database options to be active also.\n############################################################\n\n# Log to the database when creating motion triggered image file  (default: on)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sql_log_image, .copy=copy_bool,
    .print=print_bool },
    { .param_name="sql_log_snapshot", .param_help="# Log to the database when creating a snapshot image file (default: on)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sql_log_snapshot, .copy=copy_bool,
    .print=print_bool },
    { .param_name="sql_log_movie", .param_help="# Log to the database when creating motion triggered movie file (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sql_log_movie, .copy=copy_bool,
    .print=print_bool },
    { .param_name="sql_log_timelapse", .param_help="# Log to the database when creating timelapse movie file (default: off)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sql_log_timelapse, .copy=copy_bool,
    .print=print_bool },
    { .param_name="sql_query", .param_help="# SQL query string that is sent to the database\n# Use same conversion specifiers has for text features\n# Additional special conversion specifiers are\n# %n = the number representing the file_type\n# %f = filename with full path\n# Create tables :\n##\n# Mysql\n# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp(14), event_time_stamp timestamp(14));\n#\n# Postgresql\n# CREATE TABLE security (camera int, filename char(80) not null, frame int, file_type int, time_stamp timestamp without time zone, event_time_stamp timestamp without time zone);\n#\n# Default value:\n# insert into security(camera, filename, frame, file_type, time_stamp, text_event) values('%t', '%f', '%q', '%n', '%Y-%m-%d %T', '%C')", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sql_query, .copy=copy_string,
    .print=print_string },
    { .param_name="database_type", .param_help="\n############################################################\n# Database Options \n############################################################\n\n# database type : mysql, postgresql, sqlite3 (default : not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_type, .copy=copy_string,
    .print=print_string },
    { .param_name="database_dbname", .param_help="# database to log to (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_dbname, .copy=copy_string,
    .print=print_string },
    { .param_name="database_host", .param_help="# The host on which the database is located (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_host, .copy=copy_string,
    .print=print_string },
    { .param_name="database_user", .param_help="# User account name for database (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_user, .copy=copy_string,
    .print=print_string },
    { .param_name="database_password", .param_help="# User password for database (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_password, .copy=copy_string,
    .print=print_string },
    { .param_name="database_port", .param_help="# Port on which the database is located (default: not defined)\n# mysql 3306 , postgresql 5432 (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.database_port, .copy=copy_int,
    .print=print_int },
    { .param_name="sqlite3_db", .param_help="\n############################################################\n# Database Options For SQLite3\n############################################################\n\n# SQLite3 database to log to (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.sqlite3_db, .copy=copy_string,
    .print=print_string },
    { .param_name="video_pipe", .param_help="\n############################################################\n# Video Loopback Device (vloopback project)\n############################################################\n\n# Output images to a video4linux loopback device\n# The value '-' means next available (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.vidpipe, .copy=copy_string,
    .print=print_string },
    { .param_name="motion_video_pipe", .param_help="# Output motion images to a video4linux loopback device\n# The value '-' means next available (default: not defined)", .main_thread=(unsigned int)0,
    .conf_value=(signed int)(signed long int)&((struct context *)(void *)0)->conf.motionvidpipe, .copy=copy_string,
    .print=print_string },
    { .param_name="thread", .param_help="\n##############################################################\n# Thread config files - One for each camera.\n# Except if only one camera - You only need this config file.\n# If you have more than one camera you MUST define one thread\n# config file for each camera in addition to this config file.\n##############################################################\n", .main_thread=(unsigned int)1,
    .conf_value=0, .copy=config_thread,
    .print=print_thread },
    { .param_name=(const char *)(void *)0, .param_help=(const char *)(void *)0, .main_thread=(unsigned int)0,
    .conf_value=0, .copy=(struct context ** (*)(struct context **, const char *, signed int))(void *)0,
    .print=(const char * (*)(struct context **, char **, signed int, unsigned int))(void *)0 } };
// connect_auth_req
// file netcam.c line 77
static const char *connect_auth_req = "Authorization: Basic %s\r\n";
// connect_req
// file netcam.c line 63
static const char *connect_req;
// connect_req_close
// file netcam.c line 73
static const char *connect_req_close = "Connection: close\r\n";
// connect_req_http10
// file netcam.c line 65
static const char *connect_req_http10 = "GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: Motion-netcam/3.2.12+git20140228\r\n";
// connect_req_http11
// file netcam.c line 69
static const char *connect_req_http11 = "GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: Motion-netcam/3.2.12+git20140228\r\n";
// connect_req_keepalive
// file netcam.c line 75
static const char *connect_req_keepalive = "Connection: Keep-Alive\r\n";
// cur_height
// file sdl.c line 13
static signed int cur_height;
// cur_width
// file sdl.c line 12
static signed int cur_width;
// draw_table
// file draw.c line 32
struct draw_char draw_table[80l] = { { .ascii=(unsigned char)32, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)48, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)49, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)50, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)51, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)52, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)53, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)54, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)55, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)56, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)57, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)34, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)47, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)40, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)41, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)64, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)126, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)35, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)60, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)62, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)124, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)44, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)46, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)58, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)45, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)43, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)95, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)39, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)97, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)98, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)99, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)100, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)101, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)102, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)103, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)104, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)105, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)106, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)107, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)108, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)109, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)110, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)111, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)112, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)113, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 } } },
    { .ascii=(unsigned char)114, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)115, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)116, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)117, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)118, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)119, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)120, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)121, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)122, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)65, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)66, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)67, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)68, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)69, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)70, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)71, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)72, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)73, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)74, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)75, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)76, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)77, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, 0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)78, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)79, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)80, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)81, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)82, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)83, .pix={ { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)84, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)85, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)86, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)87, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)88, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 } } },
    { .ascii=(unsigned char)89, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    { .ascii=(unsigned char)90, .pix={ { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 },
    { (unsigned char)1, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)2, (unsigned char)1 },
    { (unsigned char)0, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0 } } } };
// end_template
// file webhttpd.c line 36
static const char *end_template = "</body>\n</html>\n";
// error_value
// file webhttpd.c line 145
static const char *error_value = "HTTP/1.0 200 OK\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Value Error</h1>\n";
// error_value_raw
// file webhttpd.c line 152
static const char *error_value_raw = "HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\nValue Error";
// event_handlers
// file event.c line 783
struct event_handlers event_handlers[28l];
// event_handlers
// file event.c line 783
struct event_handlers event_handlers[28l] = { { .type=1, .handler=event_sqlnewfile }, { .type=1, .handler=on_picture_save_command },
    { .type=1, .handler=event_newfile }, { .type=2, .handler=event_beep }, { .type=2, .handler=on_motion_detected_command },
    { .type=17, .handler=on_area_command }, { .type=3, .handler=on_event_start_command },
    { .type=4, .handler=on_event_end_command },
    { .type=9, .handler=event_image_detect },
    { .type=10, .handler=event_imagem_detect },
    { .type=11, .handler=event_image_snapshot },
    { .type=20, .handler=event_sdl_put }, { .type=8, .handler=event_stream_put }, { .type=3, .handler=event_new_video }, { .type=3, .handler=event_ffmpeg_newfile },
    { .type=9, .handler=event_ffmpeg_put }, { .type=19, .handler=event_ffmpeg_put },
    { .type=4, .handler=event_ffmpeg_closefile },
    { .type=6, .handler=event_ffmpeg_timelapse },
    { .type=7, .handler=event_ffmpeg_timelapseend },
    { .type=14, .handler=on_movie_end_command },
    { .type=3, .handler=event_create_extpipe },
    { .type=9, .handler=event_extpipe_put },
    { .type=19, .handler=event_extpipe_put },
    { .type=4, .handler=event_extpipe_end },
    { .type=18, .handler=event_camera_lost },
    { .type=5, .handler=event_stop_stream },
    { .type=0, .handler=(void (*)(struct context *, signed int, unsigned char *, char *, void *, struct tm *))(void *)0 } };
// exif_marker_start
// file picture.c line 119
static const char exif_marker_start[14l] = { (const char)69, (const char)120, (const char)105, (const char)102, (const char)0, (const char)0, (const char)77, (const char)77, (const char)0, (const char)42, (const char)0, (const char)0, (const char)0, (const char)8 };
// exif_subifd_tag
// file picture.c line 132
static const char exif_subifd_tag[8l] = { (const char)0x87, (const char)0x69, (const char)0x00, (const char)0x04, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x01 };
// exif_tzoffset_tag
// file picture.c line 138
static const char exif_tzoffset_tag[12l] = { (const char)0x88, (const char)0x2A, (const char)0x00, (const char)0x08, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x01, (const char)0, (const char)0, (const char)0, (const char)0 };
// exif_version_tag
// file picture.c line 125
static const char exif_version_tag[12l] = { (const char)0x90, (const char)0x00, (const char)0x00, (const char)0x07, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x04, (const char)0x30, (const char)0x32, (const char)0x32, (const char)0x30 };
// filter_frame
// file ffmpeg.c line 1037
struct AVFrame *filter_frame;
// filter_graph
// file ffmpeg.c line 1036
struct AVFilterGraph *filter_graph;
// finish
// file motion.c line 62
volatile unsigned int finish = (volatile unsigned int)0;
// fs_screen_height
// file sdl.c line 16
static signed int fs_screen_height;
// fs_screen_width
// file sdl.c line 15
static signed int fs_screen_width;
// global_lock
// file motion.c line 44
union anonymous$5 global_lock;
// httpd_mutex
// file webhttpd.c line 19
union anonymous$5 httpd_mutex;
// ini_template
// file webhttpd.c line 24
static const char *ini_template = "<html><head><title>Motion 3.2.12+git20140228</title></head>\n<body>\n";
// is_full_screen
// file sdl.c line 14
static signed int is_full_screen;
// last_height
// file ffmpeg.c line 1039
signed int last_height = -1;
// last_pixfmt
// file ffmpeg.c line 1040
enum AVPixelFormat last_pixfmt = (enum AVPixelFormat)-1;
// last_width
// file ffmpeg.c line 1038
signed int last_width = -1;
// log_level
// file logger.c line 18
static unsigned int log_level = (unsigned int)5;
// log_level_str
// file logger.c line 22
static const char *log_level_str[10l] = { "EMG", "ALR", "CRT", "ERR", "WRN", "NTC", "INF", "DBG", "ALL", (const char *)(void *)0 };
// log_mode
// file logger.c line 16
static signed int log_mode = 1;
// log_type
// file logger.c line 19
static unsigned int log_type = (unsigned int)9;
// log_type_str
// file logger.c line 21
static const char *log_type_str[10l] = { (const char *)(void *)0, "COR", "STR", "ENC", "NET", "DBL", "EVT", "TRK", "VID", "ALL" };
// logfile
// file logger.c line 17
static struct _IO_FILE *logfile;
// mpeg1_trailer
// file ffmpeg.c line 149
static unsigned char mpeg1_trailer[4l] = { (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0xb7 };
// not_found_response_template
// file webhttpd.c line 77
static const char *not_found_response_template = "HTTP/1.0 404 Not Found\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server.</p>\n</body>\n</html>\n";
// not_found_response_template_raw
// file webhttpd.c line 87
static const char *not_found_response_template_raw = "HTTP/1.0 404 Not Found\r\nContent-type: text/plain\r\n\r\nNot Found";
// not_found_response_valid
// file webhttpd.c line 92
static const char *not_found_response_valid = "HTTP/1.0 404 Not Valid\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Not Valid</h1>\n<p>The requested URL is not valid.</p>\n</body>\n</html>\n";
// not_found_response_valid_command
// file webhttpd.c line 157
static const char *not_found_response_valid_command = "HTTP/1.0 404 Not Valid Command\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Not Valid Command</h1>\n<p>The requested URL is not valid Command.</p>\n</body>\n</html>\n";
// not_found_response_valid_command_raw
// file webhttpd.c line 167
static const char *not_found_response_valid_command_raw = "HTTP/1.0 404 Not Valid Command\r\nContent-type: text/plain\n\nNot Valid Command\n";
// not_found_response_valid_raw
// file webhttpd.c line 102
static const char *not_found_response_valid_raw = "HTTP/1.0 404 Not Valid\r\nContent-type: text/plain\r\n\r\nThe requested URL is not valid.";
// not_track
// file webhttpd.c line 121
static const char *not_track = "HTTP/1.0 200 OK\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Tracking Not Enabled</h1>\n";
// not_track_raw
// file webhttpd.c line 128
static const char *not_track_raw = "HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\nTracking Not Enabled";
// not_valid_syntax
// file webhttpd.c line 107
static const char *not_valid_syntax = "HTTP/1.0 404 Not Valid Syntax\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Not Valid Syntax</h1>\n</body>\n</html>\n";
// not_valid_syntax_raw
// file webhttpd.c line 116
static const char *not_valid_syntax_raw = "HTTP/1.0 404 Not Valid Syntax\r\nContent-type: text/plain\r\n\r\nNot Valid Syntax\n";
// ok_response
// file webhttpd.c line 40
static const char *ok_response = "HTTP/1.1 200 OK\r\nServer: Motion-httpd/3.2.12+git20140228\r\nConnection: close\r\nMax-Age: 0\r\nExpires: 0\r\nCache-Control: no-cache\r\nCache-Control: private\r\nPragma: no-cache\r\nContent-type: text/html\r\n\r\n";
// ok_response_raw
// file webhttpd.c line 51
static const char *ok_response_raw = "HTTP/1.1 200 OK\r\nServer: Motion-httpd/3.2.12+git20140228\r\nConnection: close\r\nMax-Age: 0\r\nExpires: 0\r\nCache-Control: no-cache\r\nCache-Control: private\r\nPragma: no-cache\r\nContent-type: text/plain\r\n\r\n";
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// overlay
// file sdl.c line 19
static struct SDL_Overlay *overlay;
// ptr_logfile
// file motion.c line 65
struct _IO_FILE *ptr_logfile = (struct _IO_FILE *)(void *)0;
// queried_ctrls
// file video2.c line 142
static const unsigned int queried_ctrls[13l] = { (const unsigned int)((0x00980000 | 0x900) + 0),
    (const unsigned int)((0x00980000 | 0x900) + 1),
    (const unsigned int)((0x00980000 | 0x900) + 2),
    (const unsigned int)((0x00980000 | 0x900) + 3),
    (const unsigned int)((0x00980000 | 0x900) + 14),
    (const unsigned int)((0x00980000 | 0x900) + 15),
    (const unsigned int)((0x00980000 | 0x900) + 16),
    (const unsigned int)((0x00980000 | 0x900) + 17),
    (const unsigned int)((0x00980000 | 0x900) + 18),
    (const unsigned int)((0x00980000 | 0x900) + 19),
    (const unsigned int)0x08000000, (const unsigned int)(0x08000000 + 1), (const unsigned int)0 };
// request_auth_response_template
// file webhttpd.c line 187
static const char *request_auth_response_template = "HTTP/1.0 401 Authorization Required\r\nWWW-Authenticate: Basic realm=\"Motion Security Access\"\r\n";
// restart
// file motion.c line 74
unsigned int restart = (unsigned int)0;
// screen
// file sdl.c line 18
static struct SDL_Surface *screen;
// set_template
// file webhttpd.c line 28
static const char *set_template = "<html><head><script language='javascript'>function show() {top.location.href='set?'+document.n.onames.options[document.n.onames.selectedIndex].value+'='+document.s.valor.value;}</script>\n<title>Motion 3.2.12+git20140228</title>\n</head><body>\n";
// small_char_arr_ptr
// file draw.c line 18
unsigned char *small_char_arr_ptr[127l];
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stream_auth_mutex
// file stream.c line 42
union anonymous$5 stream_auth_mutex;
// threads_running
// file motion.c line 59
volatile signed int threads_running = 0;
// tls_key_threadnr
// file motion.c line 35
unsigned int tls_key_threadnr;
// track_error
// file webhttpd.c line 133
static const char *track_error = "HTTP/1.0 200 OK\r\nContent-type: text/html\r\n\r\n<html>\n<body>\n<h1>Track Error</h1>\n";
// track_error_raw
// file webhttpd.c line 140
static const char *track_error_raw = "HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\nTrack Error";
// track_template
// file track.c line 17
struct trackoptions track_template = { .dev=-1, .type=0u, .port=(char *)(void *)0, .motorx=(unsigned int)0,
    .motory=(unsigned int)0, .maxx=0,
    .maxy=0, .minx=0, .miny=0, .stepsize=(unsigned int)40, .speed=(unsigned int)255,
    .homex=(unsigned int)128, .homey=(unsigned int)128,
    .iomojo_id=0u, .active=(unsigned int)0,
    .motorx_reverse=(unsigned int)0, .motory_reverse=(unsigned int)0,
    .minmaxfound=(unsigned int)0, .step_angle_x=(unsigned int)10,
    .step_angle_y=(unsigned int)10, .move_wait=(unsigned int)10,
    .pan_angle=0, .tilt_angle=0 };
// vid_mutex
// file video_common.c line 510
static union anonymous$5 vid_mutex;
// viddevs
// file video_common.c line 516
static struct video_dev *viddevs = (struct video_dev *)(void *)0;
// warningkill
// file webhttpd.c line 22
signed int warningkill;

// CvtHex
// file stream.c line 269
static void CvtHex(char *Bin, char *Hex)
{
  unsigned short int i;
  unsigned char j;
  i = (unsigned short int)0;
  for( ; !((signed int)i >= 16); i = i + 1)
  {
    j = (unsigned char)((signed int)Bin[(signed long int)i] >> 4 & 0xf);
    if(!((signed int)j >= 10))
      Hex[(signed long int)((signed int)i * 2)] = (char)((signed int)j + 48);

    else
      Hex[(signed long int)((signed int)i * 2)] = (char)(((signed int)j + 97) - 10);
    j = (unsigned char)((signed int)Bin[(signed long int)i] & 0xf);
    if(!((signed int)j >= 10))
      Hex[(signed long int)((signed int)i * 2 + 1)] = (char)((signed int)j + 48);

    else
      Hex[(signed long int)((signed int)i * 2 + 1)] = (char)(((signed int)j + 97) - 10);
  }
  Hex[(signed long int)32] = (char)0;
}

// Decode
// file md5.c line 302
static void Decode(unsigned int *output, unsigned char *input, unsigned int len)
{
  unsigned int i;
  unsigned int j;
  i = (unsigned int)0;
  j = (unsigned int)0;
  for( ; !(j >= len); j = j + (unsigned int)4)
  {
    output[(signed long int)i] = (unsigned int)input[(signed long int)j] | (unsigned int)input[(signed long int)(j + (unsigned int)1)] << 8 | (unsigned int)input[(signed long int)(j + (unsigned int)2)] << 16 | (unsigned int)input[(signed long int)(j + (unsigned int)3)] << 24;
    i = i + 1u;
  }
}

// DigestCalcHA1
// file stream.c line 293
static void DigestCalcHA1(char *pszAlg, char *pszUserName, char *pszRealm, char *pszPassword, char *pszNonce, char *pszCNonce, char *SessionKey)
{
  struct anonymous$30 Md5Ctx;
  char HA1[16l];
  MD5Init(&Md5Ctx);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(pszUserName);
  MD5Update(&Md5Ctx, (unsigned char *)pszUserName, (unsigned int)return_value_strlen$1);
  MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(pszRealm);
  MD5Update(&Md5Ctx, (unsigned char *)pszRealm, (unsigned int)return_value_strlen$2);
  MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(pszPassword);
  MD5Update(&Md5Ctx, (unsigned char *)pszPassword, (unsigned int)return_value_strlen$3);
  MD5Final((unsigned char *)HA1, &Md5Ctx);
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(pszAlg, "md5-sess");
  if(return_value_strcmp$6 == 0)
  {
    MD5Init(&Md5Ctx);
    MD5Update(&Md5Ctx, (unsigned char *)HA1, (unsigned int)16);
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(pszNonce);
    MD5Update(&Md5Ctx, (unsigned char *)pszNonce, (unsigned int)return_value_strlen$4);
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(pszCNonce);
    MD5Update(&Md5Ctx, (unsigned char *)pszCNonce, (unsigned int)return_value_strlen$5);
    MD5Final((unsigned char *)HA1, &Md5Ctx);
  }

  CvtHex(HA1, SessionKey);
}

// DigestCalcResponse
// file stream.c line 330
static void DigestCalcResponse(char *HA1, char *pszNonce, char *pszNonceCount, char *pszCNonce, char *pszQop, char *pszMethod, char *pszDigestUri, char *HEntity, char *Response)
{
  struct anonymous$30 Md5Ctx;
  char HA2[16l];
  char RespHash[16l];
  char HA2Hex[33l];
  MD5Init(&Md5Ctx);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(pszMethod);
  MD5Update(&Md5Ctx, (unsigned char *)pszMethod, (unsigned int)return_value_strlen$1);
  MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(pszDigestUri);
  MD5Update(&Md5Ctx, (unsigned char *)pszDigestUri, (unsigned int)return_value_strlen$2);
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(pszQop, "auth-int");
  if(return_value_strcmp$3 == 0)
  {
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
    MD5Update(&Md5Ctx, (unsigned char *)HEntity, (unsigned int)32);
  }

  MD5Final((unsigned char *)HA2, &Md5Ctx);
  CvtHex(HA2, HA2Hex);
  MD5Init(&Md5Ctx);
  MD5Update(&Md5Ctx, (unsigned char *)HA1, (unsigned int)32);
  MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(pszNonce);
  MD5Update(&Md5Ctx, (unsigned char *)pszNonce, (unsigned int)return_value_strlen$4);
  MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  if(!(*pszQop == 0))
  {
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(pszNonceCount);
    MD5Update(&Md5Ctx, (unsigned char *)pszNonceCount, (unsigned int)return_value_strlen$5);
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(pszCNonce);
    MD5Update(&Md5Ctx, (unsigned char *)pszCNonce, (unsigned int)return_value_strlen$6);
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(pszQop);
    MD5Update(&Md5Ctx, (unsigned char *)pszQop, (unsigned int)return_value_strlen$7);
    MD5Update(&Md5Ctx, (unsigned char *)":", (unsigned int)1);
  }

  MD5Update(&Md5Ctx, (unsigned char *)HA2Hex, (unsigned int)32);
  MD5Final((unsigned char *)RespHash, &Md5Ctx);
  CvtHex(RespHash, Response);
}

// Encode
// file md5.c line 283
static void Encode(unsigned char *output, unsigned int *input, unsigned int len)
{
  unsigned int i;
  unsigned int j;
  i = (unsigned int)0;
  j = (unsigned int)0;
  for( ; !(j >= len); j = j + (unsigned int)4)
  {
    output[(signed long int)j] = (unsigned char)(input[(signed long int)i] & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)1)] = (unsigned char)(input[(signed long int)i] >> 8 & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)2)] = (unsigned char)(input[(signed long int)i] >> 16 & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)3)] = (unsigned char)(input[(signed long int)i] >> 24 & (unsigned int)0xff);
    i = i + 1u;
  }
}

// MD5
// file md5.c line 339
void MD5(unsigned char *message, unsigned long int message_length, unsigned char *md)
{
  struct anonymous$30 state;
  MD5Init(&state);
  MD5Update(&state, message, (unsigned int)message_length);
  MD5Final(md, &state);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// MD5Final
// file md5.h line 74
void MD5Final(unsigned char *digest, struct anonymous$30 *context)
{
  unsigned char bits[8l];
  unsigned int index;
  unsigned int padLen;
  Encode(bits, context->count, (unsigned int)8);
  index = (unsigned int)(context->count[(signed long int)0] >> 3 & (unsigned int)0x3f);
  padLen = index < (unsigned int)56 ? (unsigned int)56 - index : (unsigned int)120 - index;
  MD5Update(context, PADDING, padLen);
  MD5Update(context, bits, (unsigned int)8);
  Encode(digest, context->state, (unsigned int)16);
  MD5_memset((unsigned char *)context, 0, (unsigned int)sizeof(struct anonymous$30) /*88ul*/ );
}

// MD5Init
// file md5.h line 72
void MD5Init(struct anonymous$30 *context)
{
  context->count[(signed long int)1] = (unsigned int)0;
  context->count[(signed long int)0] = context->count[(signed long int)1];
  context->state[(signed long int)0] = (unsigned int)0x67452301;
  context->state[(signed long int)1] = 0xefcdab89;
  context->state[(signed long int)2] = 0x98badcfe;
  context->state[(signed long int)3] = (unsigned int)0x10325476;
}

// MD5Transform
// file md5.c line 190
static void MD5Transform(unsigned int *state, unsigned char *block)
{
  unsigned int a = state[(signed long int)0];
  unsigned int b = state[(signed long int)1];
  unsigned int c = state[(signed long int)2];
  unsigned int d = state[(signed long int)3];
  unsigned int x[16l];
  Decode(x, block, (unsigned int)64);
  a = a + (b & c | ~b & d) + x[(signed long int)0] + (unsigned int)0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)1] + (unsigned int)0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)3] + (unsigned int)0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)4] + (unsigned int)0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)6] + (unsigned int)0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)7] + (unsigned int)0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)9] + (unsigned int)0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)10] + (unsigned int)0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)11] + (unsigned int)0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)13] + (unsigned int)0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)14] + (unsigned int)0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)1] + (unsigned int)0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)6] + (unsigned int)0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)0] + (unsigned int)0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)5] + (unsigned int)0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)10] + (unsigned int)0x2441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)15] + (unsigned int)0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)4] + (unsigned int)0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)14] + (unsigned int)0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)3] + (unsigned int)0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)13] + (unsigned int)0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)2] + (unsigned int)0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)12] + (unsigned int)0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)5] + (unsigned int)0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)8] + (unsigned int)0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)14] + (unsigned int)0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)1] + (unsigned int)0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)7] + (unsigned int)0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)10] + (unsigned int)0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)0] + (unsigned int)0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)3] + (unsigned int)0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)6] + (unsigned int)0x4881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)9] + (unsigned int)0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)12] + (unsigned int)0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)2] + (unsigned int)0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)0] + (unsigned int)0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)14] + (unsigned int)0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)5] + (unsigned int)0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)3] + (unsigned int)0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)10] + (unsigned int)0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)1] + (unsigned int)0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)15] + (unsigned int)0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)6] + (unsigned int)0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)4] + (unsigned int)0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)11] + (unsigned int)0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)9] + (unsigned int)0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  state[(signed long int)0] = state[(signed long int)0] + a;
  state[(signed long int)1] = state[(signed long int)1] + b;
  state[(signed long int)2] = state[(signed long int)2] + c;
  state[(signed long int)3] = state[(signed long int)3] + d;
  MD5_memset((unsigned char *)x, 0, (unsigned int)sizeof(unsigned int [16l]) /*64ul*/ );
}

// MD5Update
// file md5.h line 73
void MD5Update(struct anonymous$30 *context, unsigned char *input, unsigned int inputLen)
{
  unsigned int i;
  unsigned int index;
  unsigned int partLen;
  index = (unsigned int)(context->count[(signed long int)0] >> 3 & (unsigned int)0x3F);
  context->count[(signed long int)0] = context->count[(signed long int)0] + ((unsigned int)inputLen << 3);
  if(!(context->count[0l] >= inputLen << 3))
    context->count[(signed long int)1] = context->count[(signed long int)1] + 1u;

  context->count[(signed long int)1] = context->count[(signed long int)1] + ((unsigned int)inputLen >> 29);
  partLen = (unsigned int)64 - index;
  if(inputLen >= partLen)
  {
    MD5_memcpy((unsigned char *)&context->buffer[(signed long int)index], (unsigned char *)input, partLen);
    MD5Transform(context->state, context->buffer);
    i = partLen;
    for( ; !(63u + i >= inputLen); i = i + (unsigned int)64)
      MD5Transform(context->state, &input[(signed long int)i]);
    index = (unsigned int)0;
  }

  else
    i = (unsigned int)0;
  MD5_memcpy((unsigned char *)&context->buffer[(signed long int)index], (unsigned char *)&input[(signed long int)i], inputLen - i);
}

// MD5_memcpy
// file md5.c line 316
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= len); i = i + 1u)
    output[(signed long int)i] = input[(signed long int)i];
}

// MD5_memset
// file md5.c line 328
static void MD5_memset(unsigned char *output, signed int value, unsigned int len)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= len); i = i + 1u)
    ((char *)output)[(signed long int)i] = (char)value;
}

// _jpeg_mem_dest
// file picture.c line 59
static void _jpeg_mem_dest(struct jpeg_compress_struct *cinfo, unsigned char *buf, unsigned long int bufsize)
{
  struct anonymous$8 *dest;
  if(cinfo->dest == ((struct jpeg_destination_mgr *)NULL))
  {
    void *return_value;
    return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 0, sizeof(struct anonymous$8) /*64ul*/ );
    cinfo->dest = (struct jpeg_destination_mgr *)return_value;
  }

  dest = (struct anonymous$8 *)cinfo->dest;
  dest->pub.init_destination = init_destination$link1;
  dest->pub.empty_output_buffer = empty_output_buffer$link1;
  dest->pub.term_destination = term_destination$link1;
  dest->buf = buf;
  dest->bufsize = bufsize;
  dest->jpegsize = (unsigned long int)0;
}

// _jpeg_mem_size
// file picture.c line 80
static signed int _jpeg_mem_size(struct jpeg_compress_struct *cinfo)
{
  struct anonymous$8 *dest = (struct anonymous$8 *)cinfo->dest;
  return (signed int)dest->jpegsize;
}

// acceptnonblocking
// file webhttpd.c line 2359
static signed int acceptnonblocking(signed int serverfd, signed int timeout)
{
  signed int curfd;
  struct sockaddr_storage client;
  unsigned int namelen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct timeval tm;
  struct anonymous$45 fds;
  tm.tv_sec = (signed long int)timeout;
  tm.tv_usec = (signed long int)0;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(serverfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(serverfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << serverfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  return_value_select$1=select(serverfd + 1, &fds, (struct anonymous$45 *)(void *)0, (struct anonymous$45 *)(void *)0, &tm);
  if(return_value_select$1 >= 1)
  {
    if((fds.fds_bits[(signed long int)(serverfd / 8)] & (signed long int)(1UL << serverfd % 8)) == 0l)
      goto __CPROVER_DUMP_L2;

    curfd=accept(serverfd, (struct sockaddr *)&client, &namelen);
    if(!(curfd >= 1))
      goto __CPROVER_DUMP_L2;

    return curfd;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
}

// action
// file webhttpd.c line 926
static unsigned int action(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata)
{
  char command[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct context **cnt = (struct context **)userdata;
  unsigned int i = (unsigned int)0;
  warningkill=sscanf(pointer, "%255[a-z]", (const void *)command);
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(command, "makemovie");
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  if(return_value_strcmp$6 == 0)
  {
    pointer = pointer + (signed long int)9;
    length_uri = length_uri - (unsigned int)9;
    if(length_uri == 0u)
    {
      if(thread == 0u)
        do
        {
          i = i + 1u;
          if(cnt[(signed long int)i] == ((struct context *)NULL))
            break;

          cnt[(signed long int)i]->makemovie = (volatile unsigned int)1;
        }
        while((_Bool)1);

      else
        cnt[(signed long int)thread]->makemovie = (volatile unsigned int)1;
      if(!((*cnt)->conf.webcontrol_html_output == 0))
      {
        send_template_ini_client(client_socket, ini_template);
        sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\nmakemovie for thread %hu done<br>\n", thread, thread);
        send_template(client_socket, res);
        send_template_end_client(client_socket);
      }

      else
      {
        send_template_ini_client_raw(client_socket);
        sprintf(res, "makemovie for thread %hu\nDone\n", thread);
        send_template_raw(client_socket, res);
      }
    }

    else
      if(!((*cnt)->conf.webcontrol_html_output == 0))
        response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

      else
        response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
  }

  else
  {
    return_value_strcmp$5=strcmp(command, "snapshot");
    if(return_value_strcmp$5 == 0)
    {
      pointer = pointer + (signed long int)8;
      length_uri = length_uri - (unsigned int)8;
      if(length_uri == 0u)
      {
        if(thread == 0u)
          do
          {
            i = i + 1u;
            if(cnt[(signed long int)i] == ((struct context *)NULL))
              break;

            cnt[(signed long int)i]->snapshot = (volatile unsigned int)1;
          }
          while((_Bool)1);

        else
          cnt[(signed long int)thread]->snapshot = (volatile unsigned int)1;
        cnt[(signed long int)thread]->snapshot = (volatile unsigned int)1;
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          send_template_ini_client(client_socket, ini_template);
          sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\nsnapshot for thread %hu done<br>\n", thread, thread);
          send_template(client_socket, res);
          send_template_end_client(client_socket);
        }

        else
        {
          send_template_ini_client_raw(client_socket);
          sprintf(res, "snapshot for thread %hu\nDone\n", thread);
          send_template_raw(client_socket, res);
        }
      }

      else
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

        else
          response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
    }

    else
    {
      return_value_strcmp$4=strcmp(command, "restart");
      if(return_value_strcmp$4 == 0)
      {
        pointer = pointer + (signed long int)7;
        length_uri = length_uri - (unsigned int)7;
        if(length_uri == 0u)
        {
          if(thread == 0u)
          {
            motion_log(5, (unsigned int)2, 0, "%s: httpd is going to restart", (const void *)"action");
            signed int return_value_getpid$1;
            return_value_getpid$1=getpid();
            kill(return_value_getpid$1, 1);
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "restart in progress ... bye<br>\n<a href='/'>Home</a>");
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              sprintf(res, "restart in progress ...\nDone\n");
              send_template_raw(client_socket, res);
            }
            return (unsigned int)0;
          }

          else
          {
            motion_log(5, (unsigned int)2, 0, "%s: httpd is going to restart thread %d", (const void *)"action", thread);
            if(!(cnt[(signed long int)thread]->running == 0u))
            {
              cnt[(signed long int)thread]->makemovie = (volatile unsigned int)1;
              cnt[(signed long int)thread]->finish = (volatile unsigned int)1;
            }

            cnt[(signed long int)thread]->restart = (volatile unsigned int)1;
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\nrestart for thread %hu done<br>\n", thread, thread);
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              sprintf(res, "restart for thread %hu\nDone\n", thread);
              send_template_raw(client_socket, res);
            }
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }

      else
      {
        return_value_strcmp$3=strcmp(command, "quit");
        if(return_value_strcmp$3 == 0)
        {
          pointer = pointer + (signed long int)4;
          length_uri = length_uri - (unsigned int)4;
          if(length_uri == 0u)
          {
            if(thread == 0u)
            {
              motion_log(5, (unsigned int)2, 0, "%s: httpd quits", (const void *)"action");
              signed int return_value_getpid$2;
              return_value_getpid$2=getpid();
              kill(return_value_getpid$2, 3);
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "quit in progress ... bye");
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "quit in progress ... bye\nDone\n");
                send_template_raw(client_socket, res);
              }
              return (unsigned int)0;
            }

            else
            {
              motion_log(5, (unsigned int)2, 0, "%s: httpd quits thread %d", (const void *)"action", thread);
              cnt[(signed long int)thread]->restart = (volatile unsigned int)0;
              cnt[(signed long int)thread]->makemovie = (volatile unsigned int)1;
              cnt[(signed long int)thread]->finish = (volatile unsigned int)1;
              cnt[(signed long int)thread]->watchdog = -127;
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "<a href=/%hu/action>&lt;&ndash; back</a><br><br>\nquit for thread %hu done<br>\n", thread, thread);
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "quit for thread %hu\nDone\n", thread);
                send_template_raw(client_socket, res);
              }
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }
    }
  }
  return (unsigned int)1;
}

// add_huff_table
// file jpegutils.c line 306
static void add_huff_table(struct jpeg_decompress_struct *dinfo, struct anonymous$14 **htblptr, const unsigned char *bits, const unsigned char *val)
{
  signed int nsymbols;
  signed int len;
  if(*htblptr == ((struct anonymous$14 *)NULL))
    *htblptr=jpeg_alloc_huff_table((struct jpeg_common_struct *)dinfo);

  memcpy((void *)(*htblptr)->bits, (const void *)bits, sizeof(unsigned char [17l]) /*17ul*/ );
  nsymbols = 0;
  len = 1;
  for( ; !(len >= 17); len = len + 1)
    nsymbols = nsymbols + (signed int)bits[(signed long int)len];
  if(nsymbols >= 257 || !(nsymbols >= 1))
    motion_log(3, (unsigned int)9, 0, "%s: Given jpeg buffer was too small", (const void *)"add_huff_table");

  memcpy((void *)(*htblptr)->huffval, (const void *)val, (unsigned long int)nsymbols * sizeof(unsigned char) /*1ul*/ );
}

// alg_despeckle
// file alg.h line 43
signed int alg_despeckle(struct context *cnt, signed int olddiffs)
{
  signed int diffs = 0;
  unsigned char *out = cnt->imgs.out;
  signed int width = cnt->imgs.width;
  signed int height = cnt->imgs.height;
  signed int done = 0;
  signed int i;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cnt->conf.despeckle_filter);
  len = (signed int)return_value_strlen$1;
  unsigned char *common_buffer = cnt->imgs.common_buffer;
  i = 0;
  for( ; !(i >= len); i = i + 1)
    switch((signed int)cnt->conf.despeckle_filter[(signed long int)i])
    {
      case 69:
      {
        diffs=erode9(out, width, height, (void *)common_buffer, (unsigned char)0);
        if(diffs == 0)
          i = len;

        done = 1;
        break;
      }
      case 101:
      {
        diffs=erode5(out, width, height, (void *)common_buffer, (unsigned char)0);
        if(diffs == 0)
          i = len;

        done = 1;
        break;
      }
      case 68:
      {
        diffs=dilate9(out, width, height, (void *)common_buffer);
        done = 1;
        break;
      }
      case 100:
      {
        diffs=dilate5(out, width, height, (void *)common_buffer);
        done = 1;
        break;
      }
      case 108:
      {
        diffs=alg_labeling(cnt);
        i = len;
        done = 2;
      }
    }
  if(!(done == 0))
  {
    if(!(done == 2))
      cnt->imgs.labelsize_max = 0;

    return diffs;
  }

  else
    cnt->imgs.labelsize_max = 0;
  return olddiffs;
}

// alg_diff
// file alg.h line 37
signed int alg_diff(struct context *cnt, unsigned char *new)
{
  signed int diffs = 0;
  char return_value_alg_diff_fast$1;
  return_value_alg_diff_fast$1=alg_diff_fast(cnt, cnt->conf.max_changes / 2, new);
  if(!(return_value_alg_diff_fast$1 == 0))
    diffs=alg_diff_standard(cnt, new);

  return diffs;
}

// alg_diff_fast
// file alg.c line 1202
static char alg_diff_fast(struct context *cnt, signed int max_n_changes, unsigned char *new)
{
  struct images *imgs = &cnt->imgs;
  signed int i;
  signed int diffs = 0;
  signed int step = imgs->motionsize / 10000;
  signed int noise = cnt->noise;
  unsigned char *ref = imgs->ref;
  if(!((signed int)(step == 0) % 2 == 0))
    step = step + 1;

  max_n_changes = max_n_changes / step;
  i = imgs->motionsize;
  for( ; i >= 1; i = i - step)
  {
    unsigned char curdiff;
    signed int return_value_abs$1;
    return_value_abs$1=abs((signed int)(char)((signed int)*ref - (signed int)*new));
    curdiff = (unsigned char)(signed int)return_value_abs$1;
    if(!(noise >= (signed int)curdiff))
    {
      diffs = diffs + 1;
      if(!(max_n_changes >= diffs))
        return (char)1;

    }

    ref = ref + (signed long int)step;
    new = new + (signed long int)step;
  }
  return (char)0;
}

// alg_diff_standard
// file alg.h line 38
signed int alg_diff_standard(struct context *cnt, unsigned char *new)
{
  struct images *imgs = &cnt->imgs;
  signed int i;
  signed int diffs = 0;
  signed int noise = cnt->noise;
  signed int smartmask_speed = cnt->smartmask_speed;
  unsigned char *ref = imgs->ref;
  unsigned char *out = imgs->out;
  unsigned char *mask = imgs->mask;
  unsigned char *smartmask_final = imgs->smartmask_final;
  signed int *smartmask_buffer = imgs->smartmask_buffer;
  union anonymous$2 mmtemp;
  signed int unload;
  i = imgs->motionsize;
  memset((void *)(out + (signed long int)i), 128, (unsigned long int)(i / 2));
  memset((void *)out, 0, (unsigned long int)i);
  mmtemp.uw[(signed long int)3] = (unsigned short int)(noise * 255 + 254);
  mmtemp.uw[(signed long int)2] = mmtemp.uw[(signed long int)3];
  mmtemp.uw[(signed long int)1] = mmtemp.uw[(signed long int)2];
  mmtemp.uw[(signed long int)0] = mmtemp.uw[(signed long int)1];
  asm("movq %0, %%mm7" :  : "m"(mmtemp) : );
  asm("pcmpeqb %mm6, %mm6");
  asm("pxor %mm5, %mm5");
  asm("psrlw %0, %%mm6" :  : "i"(8) : );
  unload = 255;
  for( ; i >= 8; i = i - 8)
  {
    asm("movq %0, %%mm0" :  : "m"(*ref) : );
    asm("pxor %mm4, %mm4");
    asm("movq %0, %%mm1" :  : "m"(*new) : );
    asm("movq %mm0, %mm2");
    asm("psubusb %mm1, %mm0");
    asm("psubusb %mm2, %mm1");
    asm("por %mm1, %mm0");
    asm("movq %mm0, %mm1");
    asm("punpcklbw %mm4, %mm0");
    asm("punpckhbw %mm4, %mm1");
    if(!(mask == ((unsigned char *)NULL)))
    {
      asm("movq %0, %%mm2" :  : "m"(*mask) : );
      asm("movq %mm2, %mm3");
      asm("punpcklbw %mm4, %mm2");
      asm("punpckhbw %mm4, %mm3");
      asm("pmullw %mm2, %mm0");
      asm("pmullw %mm3, %mm1");
      mask = mask + (signed long int)8;
    }

    else
    {
      asm("movq %mm0, %mm2");
      asm("psllw %0, %%mm0" :  : "i"(8) : );
      asm("movq %mm1, %mm3");
      asm("psllw %0, %%mm1" :  : "i"(8) : );
      asm("psubusw %mm2, %mm0");
      asm("psubusw %mm3, %mm1");
    }
    asm("psubusw %mm7, %mm0");
    asm("psubusw %mm7, %mm1");
    asm("pcmpeqw %mm4, %mm0");
    asm("pcmpeqw %mm4, %mm1");
    asm("pand %mm6, %mm0");
    asm("pand %mm6, %mm1");
    asm("pxor %mm6, %mm0");
    asm("pxor %mm6, %mm1");
    asm("packuswb %mm1, %mm0");
    if(!(smartmask_speed == 0))
    {
      asm("movq %0, %%mm3" :  : "m"(*smartmask_final) : );
      asm("movq %%mm0, %0" : "=m"(mmtemp) :  : );
      asm("pcmpeqb %mm4, %mm3");
      asm("pandn %mm0, %mm3");
      asm("movq %mm3, %mm0");
      if(!(cnt->event_nr == cnt->prev_event))
      {
        if(!(mmtemp.ub[0l] == 0))
          smartmask_buffer[(signed long int)0] = smartmask_buffer[(signed long int)0] + 5;

        if(!(mmtemp.ub[1l] == 0))
          smartmask_buffer[(signed long int)1] = smartmask_buffer[(signed long int)1] + 5;

        if(!(mmtemp.ub[2l] == 0))
          smartmask_buffer[(signed long int)2] = smartmask_buffer[(signed long int)2] + 5;

        if(!(mmtemp.ub[3l] == 0))
          smartmask_buffer[(signed long int)3] = smartmask_buffer[(signed long int)3] + 5;

        if(!(mmtemp.ub[4l] == 0))
          smartmask_buffer[(signed long int)4] = smartmask_buffer[(signed long int)4] + 5;

        if(!(mmtemp.ub[5l] == 0))
          smartmask_buffer[(signed long int)5] = smartmask_buffer[(signed long int)5] + 5;

        if(!(mmtemp.ub[6l] == 0))
          smartmask_buffer[(signed long int)6] = smartmask_buffer[(signed long int)6] + 5;

        if(!(mmtemp.ub[7l] == 0))
          smartmask_buffer[(signed long int)7] = smartmask_buffer[(signed long int)7] + 5;

      }

      smartmask_buffer = smartmask_buffer + (signed long int)8;
      smartmask_final = smartmask_final + (signed long int)8;
    }

    asm("movq %0, %%mm2" :  : "m"(*new) : );
    asm("pand %mm0, %mm2");
    asm("psubb %mm0, %mm4");
    asm("movq %%mm2, %0" : "=m"(*out) :  : );
    asm("paddusb %mm4, %mm5");
    unload = unload - 1;
    if(unload == 0)
    {
      asm("movq %%mm5, %0" : "=m"(mmtemp) :  : );
      asm("pxor %mm5, %mm5");
      diffs = diffs + (signed int)mmtemp.ub[(signed long int)0] + (signed int)mmtemp.ub[(signed long int)1] + (signed int)mmtemp.ub[(signed long int)2] + (signed int)mmtemp.ub[(signed long int)3] + (signed int)mmtemp.ub[(signed long int)4] + (signed int)mmtemp.ub[(signed long int)5] + (signed int)mmtemp.ub[(signed long int)6] + (signed int)mmtemp.ub[(signed long int)7];
      unload = 255;
    }

    out = out + (signed long int)8;
    ref = ref + (signed long int)8;
    new = new + (signed long int)8;
  }
  if(!(unload >= 255))
  {
    asm("movq %%mm5, %0" : "=m"(mmtemp) :  : );
    diffs = diffs + (signed int)mmtemp.ub[(signed long int)0] + (signed int)mmtemp.ub[(signed long int)1] + (signed int)mmtemp.ub[(signed long int)2] + (signed int)mmtemp.ub[(signed long int)3] + (signed int)mmtemp.ub[(signed long int)4] + (signed int)mmtemp.ub[(signed long int)5] + (signed int)mmtemp.ub[(signed long int)6] + (signed int)mmtemp.ub[(signed long int)7];
  }

  asm("emms");
  for( ; i >= 1; i = i - 1)
  {
    unsigned char curdiff;
    signed int return_value_abs$1;
    return_value_abs$1=abs((signed int)*ref - (signed int)*new);
    curdiff = (unsigned char)(signed int)return_value_abs$1;
    if(!(mask == ((unsigned char *)NULL)))
    {
      unsigned char *tmp_post$2 = mask;
      mask = mask + 1l;
      curdiff = (unsigned char)((signed int)((signed int)curdiff * (signed int)*tmp_post$2) / 255);
    }

    if(!(smartmask_speed == 0))
    {
      if(!(noise >= (signed int)curdiff))
      {
        if(!(cnt->event_nr == cnt->prev_event))
          *smartmask_buffer = *smartmask_buffer + 5;

        if(*smartmask_final == 0)
          curdiff = (unsigned char)0;

      }

      smartmask_final = smartmask_final + 1l;
      smartmask_buffer = smartmask_buffer + 1l;
    }

    if(!(noise >= (signed int)curdiff))
    {
      *out = *new;
      diffs = diffs + 1;
    }

    out = out + 1l;
    ref = ref + 1l;
    new = new + 1l;
  }
  return diffs;
}

// alg_draw_location
// file alg.h line 35
void alg_draw_location(struct coord *cent, struct images *imgs, signed int width, unsigned char *new, signed int style, signed int mode, signed int process_thisframe)
{
  unsigned char *out = imgs->out;
  signed int x;
  signed int y;
  out = imgs->out;
  if(mode == 2 && !(process_thisframe == 0))
  {
    signed int width_miny = width * cent->miny;
    signed int width_maxy = width * cent->maxy;
    x = cent->minx;
    for( ; cent->maxx >= x; x = x + 1)
    {
      signed int width_miny_x = x + width_miny;
      signed int alg_draw_location$$1$$1$$1$$1$$width_maxy_x = x + width_maxy;
      out[(signed long int)width_miny_x] = (unsigned char)~((signed int)out[(signed long int)width_miny_x]);
      out[(signed long int)alg_draw_location$$1$$1$$1$$1$$width_maxy_x] = (unsigned char)~((signed int)out[(signed long int)alg_draw_location$$1$$1$$1$$1$$width_maxy_x]);
    }
    y = cent->miny;
    for( ; cent->maxy >= y; y = y + 1)
    {
      signed int alg_draw_location$$1$$1$$2$$1$$width_minx_y = cent->minx + y * width;
      signed int alg_draw_location$$1$$1$$2$$1$$width_maxx_y = cent->maxx + y * width;
      out[(signed long int)alg_draw_location$$1$$1$$2$$1$$width_minx_y] = (unsigned char)~((signed int)out[(signed long int)alg_draw_location$$1$$1$$2$$1$$width_minx_y]);
      out[(signed long int)alg_draw_location$$1$$1$$2$$1$$width_maxx_y] = (unsigned char)~((signed int)out[(signed long int)alg_draw_location$$1$$1$$2$$1$$width_maxx_y]);
    }
  }

  if(style == 1)
  {
    signed int alg_draw_location$$1$$2$$width_miny = width * cent->miny;
    signed int alg_draw_location$$1$$2$$width_maxy = width * cent->maxy;
    x = cent->minx;
    for( ; cent->maxx >= x; x = x + 1)
    {
      signed int alg_draw_location$$1$$2$$1$$1$$width_miny_x = x + alg_draw_location$$1$$2$$width_miny;
      signed int width_maxy_x = x + alg_draw_location$$1$$2$$width_maxy;
      new[(signed long int)alg_draw_location$$1$$2$$1$$1$$width_miny_x] = (unsigned char)~((signed int)new[(signed long int)alg_draw_location$$1$$2$$1$$1$$width_miny_x]);
      new[(signed long int)width_maxy_x] = (unsigned char)~((signed int)new[(signed long int)width_maxy_x]);
    }
    y = cent->miny;
    for( ; cent->maxy >= y; y = y + 1)
    {
      signed int width_minx_y = cent->minx + y * width;
      signed int width_maxx_y = cent->maxx + y * width;
      new[(signed long int)width_minx_y] = (unsigned char)~((signed int)new[(signed long int)width_minx_y]);
      new[(signed long int)width_maxx_y] = (unsigned char)~((signed int)new[(signed long int)width_maxx_y]);
    }
  }

  else
    if(style == 4)
    {
      signed int centy = cent->y * width;
      x = cent->x - 10;
      for( ; 10 + cent->x >= x; x = x + 1)
      {
        new[(signed long int)(centy + x)] = (unsigned char)~((signed int)new[(signed long int)(centy + x)]);
        out[(signed long int)(centy + x)] = (unsigned char)~((signed int)out[(signed long int)(centy + x)]);
      }
      y = cent->y - 10;
      for( ; 10 + cent->y >= y; y = y + 1)
      {
        new[(signed long int)(cent->x + y * width)] = (unsigned char)~((signed int)new[(signed long int)(cent->x + y * width)]);
        out[(signed long int)(cent->x + y * width)] = (unsigned char)~((signed int)out[(signed long int)(cent->x + y * width)]);
      }
    }

}

// alg_draw_red_location
// file alg.h line 36
void alg_draw_red_location(struct coord *cent, struct images *imgs, signed int width, unsigned char *new, signed int style, signed int mode, signed int process_thisframe)
{
  unsigned char *out = imgs->out;
  unsigned char *new_u;
  unsigned char *new_v;
  signed int x;
  signed int y;
  signed int v;
  signed int cwidth;
  signed int cblock;
  cwidth = width / 2;
  cblock = imgs->motionsize / 4;
  x = imgs->motionsize;
  v = x + cblock;
  out = imgs->out;
  new_u = new + (signed long int)x;
  new_v = new + (signed long int)v;
  if(mode == 2 && !(process_thisframe == 0))
  {
    signed int alg_draw_red_location$$1$$1$$width_miny = width * cent->miny;
    signed int width_maxy = width * cent->maxy;
    x = cent->minx;
    for( ; cent->maxx >= x; x = x + 1)
    {
      signed int width_miny_x = x + alg_draw_red_location$$1$$1$$width_miny;
      signed int width_maxy_x = x + width_maxy;
      out[(signed long int)width_miny_x] = (unsigned char)~((signed int)out[(signed long int)width_miny_x]);
      out[(signed long int)width_maxy_x] = (unsigned char)~((signed int)out[(signed long int)width_maxy_x]);
    }
    y = cent->miny;
    for( ; cent->maxy >= y; y = y + 1)
    {
      signed int width_minx_y = cent->minx + y * width;
      signed int width_maxx_y = cent->maxx + y * width;
      out[(signed long int)width_minx_y] = (unsigned char)~((signed int)out[(signed long int)width_minx_y]);
      out[(signed long int)width_maxx_y] = (unsigned char)~((signed int)out[(signed long int)width_maxx_y]);
    }
  }

  if(style == 2)
  {
    signed int width_miny = width * cent->miny;
    signed int alg_draw_red_location$$1$$2$$width_maxy = width * cent->maxy;
    signed int cwidth_miny = cwidth * (cent->miny / 2);
    signed int cwidth_maxy = cwidth * (cent->maxy / 2);
    x = cent->minx + 2;
    for( ; cent->maxx + -2 >= x; x = x + 2)
    {
      signed int alg_draw_red_location$$1$$2$$1$$1$$width_miny_x = x + width_miny;
      signed int alg_draw_red_location$$1$$2$$1$$1$$width_maxy_x = x + alg_draw_red_location$$1$$2$$width_maxy;
      signed int cwidth_miny_x = x / 2 + cwidth_miny;
      signed int cwidth_maxy_x = x / 2 + cwidth_maxy;
      new_u[(signed long int)cwidth_miny_x] = (unsigned char)128;
      new_u[(signed long int)cwidth_maxy_x] = (unsigned char)128;
      new_v[(signed long int)cwidth_miny_x] = (unsigned char)255;
      new_v[(signed long int)cwidth_maxy_x] = (unsigned char)255;
      new[(signed long int)alg_draw_red_location$$1$$2$$1$$1$$width_miny_x] = (unsigned char)128;
      new[(signed long int)alg_draw_red_location$$1$$2$$1$$1$$width_maxy_x] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_miny_x + 1)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_maxy_x + 1)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_miny_x + width)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_maxy_x + width)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_miny_x + 1 + width)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$1$$1$$width_maxy_x + 1 + width)] = (unsigned char)128;
    }
    y = cent->miny;
    for( ; cent->maxy >= y; y = y + 2)
    {
      signed int alg_draw_red_location$$1$$2$$2$$1$$width_minx_y = cent->minx + y * width;
      signed int alg_draw_red_location$$1$$2$$2$$1$$width_maxx_y = cent->maxx + y * width;
      signed int cwidth_minx_y = cent->minx / 2 + (y / 2) * cwidth;
      signed int cwidth_maxx_y = cent->maxx / 2 + (y / 2) * cwidth;
      new_u[(signed long int)cwidth_minx_y] = (unsigned char)128;
      new_u[(signed long int)cwidth_maxx_y] = (unsigned char)128;
      new_v[(signed long int)cwidth_minx_y] = (unsigned char)255;
      new_v[(signed long int)cwidth_maxx_y] = (unsigned char)255;
      new[(signed long int)alg_draw_red_location$$1$$2$$2$$1$$width_minx_y] = (unsigned char)128;
      new[(signed long int)alg_draw_red_location$$1$$2$$2$$1$$width_maxx_y] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_minx_y + width)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_maxx_y + width)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_minx_y + 1)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_maxx_y + 1)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_minx_y + width + 1)] = (unsigned char)128;
      new[(signed long int)(alg_draw_red_location$$1$$2$$2$$1$$width_maxx_y + width + 1)] = (unsigned char)128;
    }
  }

  else
    if(style == 8)
    {
      signed int alg_draw_red_location$$1$$3$$cwidth_maxy = cwidth * (cent->y / 2);
      x = cent->x - 10;
      for( ; 10 + cent->x >= x; x = x + 2)
      {
        signed int alg_draw_red_location$$1$$3$$1$$1$$cwidth_maxy_x = x / 2 + alg_draw_red_location$$1$$3$$cwidth_maxy;
        new_u[(signed long int)alg_draw_red_location$$1$$3$$1$$1$$cwidth_maxy_x] = (unsigned char)128;
        new_v[(signed long int)alg_draw_red_location$$1$$3$$1$$1$$cwidth_maxy_x] = (unsigned char)255;
      }
      y = cent->y - 10;
      for( ; 10 + cent->y >= y; y = y + 2)
      {
        signed int alg_draw_red_location$$1$$3$$2$$1$$cwidth_minx_y = cent->x / 2 + (y / 2) * cwidth;
        new_u[(signed long int)alg_draw_red_location$$1$$3$$2$$1$$cwidth_minx_y] = (unsigned char)128;
        new_v[(signed long int)alg_draw_red_location$$1$$3$$2$$1$$cwidth_minx_y] = (unsigned char)255;
      }
    }

}

// alg_labeling
// file alg.c line 519
static signed int alg_labeling(struct context *cnt)
{
  struct images *imgs = &cnt->imgs;
  unsigned char *out = imgs->out;
  signed int *labels = imgs->labels;
  signed int ix;
  signed int iy;
  signed int pixelpos;
  signed int width = imgs->width;
  signed int height = imgs->height;
  signed int labelsize = 0;
  signed int current_label = 2;
  cnt->current_image->total_labels = 0;
  imgs->labelsize_max = 0;
  imgs->labelgroup_max = 0;
  imgs->labels_above = 0;
  memset((void *)labels, 0, (unsigned long int)(width * height) * sizeof(signed int *) /*8ul*/ );
  pixelpos = 0;
  iy = 0;
  for( ; !(iy >= height + -1); iy = iy + 1)
  {
    ix = 0;
    for( ; !(ix >= width + -1); pixelpos = pixelpos + 1)
    {
      if((signed int)out[(signed long int)pixelpos] == 0)
        labels[(signed long int)pixelpos] = 1;

      else
        if(!(labels[(signed long int)pixelpos] >= 1))
        {
          labelsize=iflood(ix, iy, width, height, out, labels, current_label, 0);
          if(labelsize >= 1)
          {
            motion_log(7, (unsigned int)9, 0, "%s: Label: %i (%i) Size: %i (%i,%i)", (const void *)"alg_labeling", current_label, cnt->current_image->total_labels, labelsize, ix, iy);
            if(!(cnt->threshold >= labelsize))
            {
              labelsize=iflood(ix, iy, width, height, out, labels, current_label + 32768, current_label);
              imgs->labelgroup_max = imgs->labelgroup_max + labelsize;
              imgs->labels_above = imgs->labels_above + 1;
            }

            if(!(imgs->labelsize_max >= labelsize))
            {
              imgs->labelsize_max = labelsize;
              imgs->largest_label = current_label;
            }

            cnt->current_image->total_labels = cnt->current_image->total_labels + 1;
            current_label = current_label + 1;
          }

        }

      ix = ix + 1;
    }
    pixelpos = pixelpos + 1;
  }
  motion_log(7, (unsigned int)9, 0, "%s: %i Labels found. Largest connected Area: %i Pixel(s). Largest Label: %i", (const void *)"alg_labeling", imgs->largest_label, imgs->labelsize_max, cnt->current_image->total_labels);
  return imgs->labelgroup_max;
}

// alg_lightswitch
// file alg.h line 39
signed int alg_lightswitch(struct context *cnt, signed int diffs)
{
  struct images *imgs = &cnt->imgs;
  if(!(cnt->conf.lightswitch >= 0))
    cnt->conf.lightswitch = 0;

  if(cnt->conf.lightswitch >= 101)
    cnt->conf.lightswitch = 100;

  if(!((imgs->motionsize * cnt->conf.lightswitch) / 100 >= diffs))
    return 1;

  else
    return 0;
}

// alg_locate_center_size
// file alg.h line 34
void alg_locate_center_size(struct images *imgs, signed int width, signed int height, struct coord *cent)
{
  unsigned char *out = imgs->out;
  signed int *labels = imgs->labels;
  signed int x;
  signed int y;
  signed int centc = 0;
  signed int xdist = 0;
  signed int ydist = 0;
  cent->x = 0;
  cent->y = 0;
  cent->maxx = 0;
  cent->maxy = 0;
  cent->minx = width;
  cent->miny = height;
  if(!(imgs->labelsize_max == 0))
  {
    y = 0;
    for( ; !(y >= height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width); x = x + 1)
      {
        signed int *tmp_post$1 = labels;
        labels = labels + 1l;
        if(!((32768 & *tmp_post$1) == 0))
        {
          cent->x = cent->x + x;
          cent->y = cent->y + y;
          centc = centc + 1;
        }

      }
    }
  }

  else
  {
    y = 0;
    for( ; !(y >= height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width); x = x + 1)
      {
        unsigned char *tmp_post$2 = out;
        out = out + 1l;
        if(!(*tmp_post$2 == 0))
        {
          cent->x = cent->x + x;
          cent->y = cent->y + y;
          centc = centc + 1;
        }

      }
    }
  }
  if(!(centc == 0))
  {
    cent->x = cent->x / centc;
    cent->y = cent->y / centc;
  }

  centc = 0;
  labels = imgs->labels;
  out = imgs->out;
  if(!(imgs->labelsize_max == 0))
  {
    y = 0;
    for( ; !(y >= height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width); x = x + 1)
      {
        signed int *tmp_post$3 = labels;
        labels = labels + 1l;
        if(!((32768 & *tmp_post$3) == 0))
        {
          if(!(cent->x >= x))
            xdist = xdist + (x - cent->x);

          else
            if(!(x >= cent->x))
              xdist = xdist + (cent->x - x);

          if(!(cent->y >= y))
            ydist = ydist + (y - cent->y);

          else
            if(!(y >= cent->y))
              ydist = ydist + (cent->y - y);

          centc = centc + 1;
        }

      }
    }
  }

  else
  {
    y = 0;
    for( ; !(y >= height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width); x = x + 1)
      {
        unsigned char *tmp_post$4 = out;
        out = out + 1l;
        if(!(*tmp_post$4 == 0))
        {
          if(!(cent->x >= x))
            xdist = xdist + (x - cent->x);

          else
            if(!(x >= cent->x))
              xdist = xdist + (cent->x - x);

          if(!(cent->y >= y))
            ydist = ydist + (y - cent->y);

          else
            if(!(y >= cent->y))
              ydist = ydist + (cent->y - y);

          centc = centc + 1;
        }

      }
    }
  }
  if(!(centc == 0))
  {
    cent->minx = cent->x - (xdist / centc) * 2;
    cent->maxx = cent->x + (xdist / centc) * 2;
    cent->miny = cent->y - (ydist / centc) * 3;
    cent->maxy = cent->y + (ydist / centc) * 2;
  }

  if(!(width + -1 >= cent->maxx))
    cent->maxx = width - 1;

  else
    if(!(cent->maxx >= 0))
      cent->maxx = 0;

  if(!(height + -1 >= cent->maxy))
    cent->maxy = height - 1;

  else
    if(!(cent->maxy >= 0))
      cent->maxy = 0;

  if(!(width + -1 >= cent->minx))
    cent->minx = width - 1;

  else
    if(!(cent->minx >= 0))
      cent->minx = 0;

  if(!(height + -1 >= cent->miny))
    cent->miny = height - 1;

  else
    if(!(cent->miny >= 0))
      cent->miny = 0;

  cent->minx = cent->minx + cent->minx % 2;
  cent->miny = cent->miny + cent->miny % 2;
  cent->maxx = cent->maxx - cent->maxx % 2;
  cent->maxy = cent->maxy - cent->maxy % 2;
  cent->width = cent->maxx - cent->minx;
  cent->height = cent->maxy - cent->miny;
  cent->y = (cent->miny + cent->maxy) / 2;
}

// alg_noise_tune
// file alg.h line 41
void alg_noise_tune(struct context *cnt, unsigned char *new)
{
  struct images *imgs = &cnt->imgs;
  signed int i;
  unsigned char *ref = imgs->ref;
  signed int diff;
  signed int sum = 0;
  signed int count = 0;
  unsigned char *mask = imgs->mask;
  unsigned char *smartmask = imgs->smartmask_final;
  i = imgs->motionsize;
  for( ; i >= 1; i = i - 1)
  {
    signed int tmp_if_expr$1;
    if(!((signed int)*ref + -((signed int)*new) >= 0))
      tmp_if_expr$1 = -((signed int)*ref - (signed int)*new);

    else
      tmp_if_expr$1 = (signed int)*ref - (signed int)*new;
    diff = tmp_if_expr$1;
    if(!(mask == ((unsigned char *)NULL)))
    {
      unsigned char *tmp_post$2 = mask;
      mask = mask + 1l;
      diff = (diff * (signed int)*tmp_post$2) / 255;
    }

    if(!(*smartmask == 0))
    {
      sum = sum + diff + 1;
      count = count + 1;
    }

    ref = ref + 1l;
    new = new + 1l;
    smartmask = smartmask + 1l;
  }
  if(count >= 4)
    sum = sum / (count / 3);

  cnt->noise = 4 + (cnt->noise + sum) / 2;
}

// alg_switchfilter
// file alg.h line 40
signed int alg_switchfilter(struct context *cnt, signed int diffs, unsigned char *newimg)
{
  signed int linediff = diffs / cnt->imgs.height;
  unsigned char *out = cnt->imgs.out;
  signed int y;
  signed int x;
  signed int line;
  signed int lines = 0;
  signed int vertlines = 0;
  y = 0;
  for( ; !(y >= cnt->imgs.height); y = y + 1)
  {
    line = 0;
    x = 0;
    for( ; !(x >= cnt->imgs.width); x = x + 1)
    {
      unsigned char *tmp_post$1 = out;
      out = out + 1l;
      if(!(*tmp_post$1 == 0))
        line = line + 1;

    }
    if(!(cnt->imgs.width / 18 >= line))
      vertlines = vertlines + 1;

    if(!(2 * linediff >= line))
      lines = lines + 1;

  }
  if(!(cnt->imgs.height / 10 >= vertlines))
  {
    if(lines >= vertlines / 3)
      goto __CPROVER_DUMP_L9;

    if(cnt->imgs.height / 4 >= vertlines && lines / 2 >= lines + -vertlines)
      goto __CPROVER_DUMP_L9;

    if(!(cnt->conf.text_changes == 0))
    {
      char tmp[80l];
      sprintf(tmp, "%d %d", lines, vertlines);
      draw_text(newimg, (unsigned int)(cnt->imgs.width - 10), (unsigned int)20, (unsigned int)cnt->imgs.width, tmp, (unsigned int)cnt->conf.text_double);
    }

    return diffs;
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    return 0;
  }
}

// alg_threshold_tune
// file alg.h line 42
void alg_threshold_tune(struct context *cnt, signed int diffs, signed int motion)
{
  signed int i;
  signed int sum = 0;
  signed int top = diffs;
  if(!(diffs == 0))
  {
    if(!(motion == 0))
      diffs = cnt->threshold / 4;

    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      sum = sum + cnt->diffs_last[(signed long int)i];
      if(motion == 0 && !(cnt->diffs_last[(signed long int)(1 + i)] == 0))
        cnt->diffs_last[(signed long int)i] = cnt->diffs_last[(signed long int)(i + 1)];

      else
        cnt->diffs_last[(signed long int)i] = cnt->threshold / 4;
      if(!(top >= cnt->diffs_last[(signed long int)i]))
        top = cnt->diffs_last[(signed long int)i];

    }
    sum = sum + cnt->diffs_last[(signed long int)i];
    cnt->diffs_last[(signed long int)i] = diffs;
    sum = sum / (256 / 4);
    if(!(sum >= 2 * top))
      sum = top * 2;

    if(!(sum >= cnt->conf.max_changes))
      cnt->threshold = (cnt->threshold + sum) / 2;

  }

}

// alg_tune_smartmask
// file alg.h line 44
void alg_tune_smartmask(struct context *cnt)
{
  signed int i;
  signed int diff;
  signed int motionsize = cnt->imgs.motionsize;
  unsigned char *smartmask = cnt->imgs.smartmask;
  unsigned char *smartmask_final = cnt->imgs.smartmask_final;
  signed int *smartmask_buffer = cnt->imgs.smartmask_buffer;
  signed int sensitivity = (signed int)(cnt->lastrate * (unsigned int)(11 - cnt->smartmask_speed));
  i = 0;
  for( ; !(i >= motionsize); i = i + 1)
  {
    if((signed int)smartmask[(signed long int)i] >= 1)
      smartmask[(signed long int)i] = smartmask[(signed long int)i] - 1;

    diff = smartmask_buffer[(signed long int)i] / sensitivity;
    if(!(diff == 0))
    {
      if(80 + diff >= (signed int)smartmask[(signed long int)i])
        smartmask[(signed long int)i] = smartmask[(signed long int)i] + (unsigned char)diff;

      else
        smartmask[(signed long int)i] = (unsigned char)80;
      smartmask_buffer[(signed long int)i] = smartmask_buffer[(signed long int)i] % sensitivity;
    }

    if((signed int)smartmask[(signed long int)i] >= 21)
      smartmask_final[(signed long int)i] = (unsigned char)0;

    else
      smartmask_final[(signed long int)i] = (unsigned char)255;
  }
  diff=erode9(smartmask_final, cnt->imgs.width, cnt->imgs.height, (void *)cnt->imgs.common_buffer, (unsigned char)255);
  diff=erode5(smartmask_final, cnt->imgs.width, cnt->imgs.height, (void *)cnt->imgs.common_buffer, (unsigned char)255);
}

// alg_update_reference_frame
// file alg.h line 45
void alg_update_reference_frame(struct context *cnt, signed int action)
{
  signed int accept_timer = (signed int)(cnt->lastrate * (unsigned int)10);
  signed int i;
  signed int threshold_ref;
  signed int *ref_dyn = cnt->imgs.ref_dyn;
  unsigned char *image_virgin = cnt->imgs.image_virgin;
  unsigned char *ref = cnt->imgs.ref;
  unsigned char *smartmask = cnt->imgs.smartmask_final;
  unsigned char *out = cnt->imgs.out;
  if(cnt->lastrate >= 6u)
    accept_timer = accept_timer / (signed int)(cnt->lastrate / (unsigned int)3);

  if(action == 1)
  {
    threshold_ref = (cnt->noise * 20) / 100;
    i = cnt->imgs.motionsize;
    for( ; i >= 1; i = i - 1)
    {
      signed int return_value_abs$1;
      return_value_abs$1=abs((signed int)*ref - (signed int)*image_virgin);
      _Bool tmp_if_expr$2;
      if(!(threshold_ref >= return_value_abs$1))
        tmp_if_expr$2 = *smartmask != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(*ref_dyn == 0)
          *ref_dyn = 1;

        else
          if(!(accept_timer >= *ref_dyn))
          {
            *ref_dyn = 0;
            *ref = *image_virgin;
          }

          else
            if(!(*out == 0))
              *ref_dyn = *ref_dyn + 1;

            else
            {
              *ref_dyn = 0;
              *ref = (unsigned char)(((signed int)*ref + (signed int)*image_virgin) / 2);
            }
      }

      else
      {
        *ref_dyn = 0;
        *ref = *image_virgin;
      }
      ref = ref + 1l;
      image_virgin = image_virgin + 1l;
      smartmask = smartmask + 1l;
      ref_dyn = ref_dyn + 1l;
      out = out + 1l;
    }
  }

  else
  {
    memcpy((void *)cnt->imgs.ref, (const void *)cnt->imgs.image_virgin, (unsigned long int)cnt->imgs.size);
    memset((void *)cnt->imgs.ref_dyn, 0, (unsigned long int)cnt->imgs.motionsize * sizeof(signed int *) /*8ul*/ );
  }
}

// av_make_error_string
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 109
static inline char * av_make_error_string(char *errbuf, unsigned long int errbuf_size, signed int errnum)
{
  av_strerror(errnum, errbuf, errbuf_size);
  return errbuf;
}

// base64_encode
// file netcam_wget.h line 75
void base64_encode(const char *s, char *store, signed int length)
{
  signed int i;
  unsigned char *p = (unsigned char *)store;
  i = 0;
  for( ; !(i >= length); i = i + 3)
  {
    unsigned char *tmp_post$1 = p;
    p = p + 1l;
    static const char tbl[64l] = { (const char)65, (const char)66, (const char)67, (const char)68, (const char)69, (const char)70, (const char)71, (const char)72, (const char)73, (const char)74, (const char)75, (const char)76, (const char)77, (const char)78, (const char)79, (const char)80, (const char)81, (const char)82, (const char)83, (const char)84, (const char)85, (const char)86, (const char)87, (const char)88, (const char)89, (const char)90, (const char)97, (const char)98, (const char)99, (const char)100, (const char)101, (const char)102, (const char)103, (const char)104, (const char)105, (const char)106, (const char)107, (const char)108, (const char)109, (const char)110, (const char)111, (const char)112, (const char)113, (const char)114, (const char)115, (const char)116, (const char)117, (const char)118, (const char)119, (const char)120, (const char)121, (const char)122, (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54, (const char)55, (const char)56, (const char)57, (const char)43, (const char)47 };
    *tmp_post$1 = (unsigned char)tbl[(signed long int)((signed int)s[(signed long int)0] >> 2)];
    unsigned char *tmp_post$2 = p;
    p = p + 1l;
    *tmp_post$2 = (unsigned char)tbl[(signed long int)((((signed int)s[(signed long int)0] & 3) << 4) + ((signed int)s[(signed long int)1] >> 4))];
    unsigned char *tmp_post$3 = p;
    p = p + 1l;
    *tmp_post$3 = (unsigned char)tbl[(signed long int)((((signed int)s[(signed long int)1] & 0xf) << 2) + ((signed int)s[(signed long int)2] >> 6))];
    unsigned char *tmp_post$4 = p;
    p = p + 1l;
    *tmp_post$4 = (unsigned char)tbl[(signed long int)((signed int)s[(signed long int)2] & 0x3f)];
    s = s + (signed long int)3;
  }
  if(i == 1 + length)
    *(p - (signed long int)1) = (unsigned char)61;

  else
    if(i == 2 + length)
    {
      *(p - (signed long int)2) = (unsigned char)61;
      *(p - (signed long int)1) = *(p - (signed long int)2);
    }

  *p = (unsigned char)0;
}

// bayer2rgb24
// file video.h line 98
void bayer2rgb24(unsigned char *dst, unsigned char *src, signed long int width, signed long int height)
{
  signed long int i;
  unsigned char *rawpt;
  unsigned char *scanpt;
  signed long int size;
  rawpt = src;
  scanpt = dst;
  size = width * height;
  i = (signed long int)0;
  for( ; !(i >= size); i = i + 1l)
  {
    if((i / width & 1l) == 0l)
    {
      if((1l & i) == 0l)
      {
        if(i % width >= 1l && !(width >= i))
        {
          unsigned char *tmp_post$1 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$1 = *rawpt;
          unsigned char *tmp_post$2 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$2 = (unsigned char)(((signed int)*(rawpt - (signed long int)1) + (signed int)rawpt[(signed long int)1] + (signed int)rawpt[width] + (signed int)*(rawpt - width)) / 4);
          unsigned char *tmp_post$3 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$3 = (unsigned char)(((signed int)*((rawpt - width) - (signed long int)1) + (signed int)(rawpt - width)[(signed long int)1] + (signed int)*((rawpt + width) - (signed long int)1) + (signed int)(rawpt + width)[(signed long int)1]) / 4);
        }

        else
        {
          unsigned char *tmp_post$4 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$4 = *rawpt;
          unsigned char *tmp_post$5 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$5 = (unsigned char)(((signed int)rawpt[(signed long int)1] + (signed int)rawpt[width]) / 2);
          unsigned char *tmp_post$6 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$6 = (rawpt + width)[(signed long int)1];
        }
      }

      else
        if(!(i % width >= width + -1l) && !(width >= i))
        {
          unsigned char *tmp_post$7 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$7 = (unsigned char)(((signed int)*(rawpt - (signed long int)1) + (signed int)rawpt[(signed long int)1]) / 2);
          unsigned char *tmp_post$8 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$8 = *rawpt;
          unsigned char *tmp_post$9 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$9 = (unsigned char)(((signed int)rawpt[width] + (signed int)*(rawpt - width)) / 2);
        }

        else
        {
          unsigned char *tmp_post$10 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$10 = *(rawpt - (signed long int)1);
          unsigned char *tmp_post$11 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$11 = *rawpt;
          unsigned char *tmp_post$12 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$12 = rawpt[width];
        }
    }

    else
      if((1l & i) == 0l)
      {
        if(i % width >= 1l && !(i >= (height + -1l) * width))
        {
          unsigned char *tmp_post$13 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$13 = (unsigned char)(((signed int)rawpt[width] + (signed int)*(rawpt - width)) / 2);
          unsigned char *tmp_post$14 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$14 = *rawpt;
          unsigned char *tmp_post$15 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$15 = (unsigned char)(((signed int)*(rawpt - (signed long int)1) + (signed int)rawpt[(signed long int)1]) / 2);
        }

        else
        {
          unsigned char *tmp_post$16 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$16 = *(rawpt - width);
          unsigned char *tmp_post$17 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$17 = *rawpt;
          unsigned char *tmp_post$18 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$18 = rawpt[(signed long int)1];
        }
      }

      else
        if(!(i % width >= width + -1l) && !(i >= (height + -1l) * width))
        {
          unsigned char *tmp_post$19 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$19 = (unsigned char)(((signed int)*((rawpt - width) - (signed long int)1) + (signed int)(rawpt - width)[(signed long int)1] + (signed int)*((rawpt + width) - (signed long int)1) + (signed int)(rawpt + width)[(signed long int)1]) / 4);
          unsigned char *tmp_post$20 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$20 = (unsigned char)(((signed int)*(rawpt - (signed long int)1) + (signed int)rawpt[(signed long int)1] + (signed int)*(rawpt - width) + (signed int)rawpt[width]) / 4);
          unsigned char *tmp_post$21 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$21 = *rawpt;
        }

        else
        {
          unsigned char *tmp_post$22 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$22 = *((rawpt - width) - (signed long int)1);
          unsigned char *tmp_post$23 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$23 = (unsigned char)(((signed int)*(rawpt - (signed long int)1) + (signed int)*(rawpt - width)) / 2);
          unsigned char *tmp_post$24 = scanpt;
          scanpt = scanpt + 1l;
          *tmp_post$24 = *rawpt;
        }
    rawpt = rawpt + 1l;
  }
}

// become_daemon
// file motion.c line 2271
static void become_daemon(void)
{
  signed int i;
  struct _IO_FILE *pidf = (struct _IO_FILE *)(void *)0;
  struct sigaction sig_ign_action;
  sig_ign_action.sa_flags = 0x10000000;
  sig_ign_action.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigemptyset(&sig_ign_action.sa_mask);
  signed int return_value_fork$1;
  return_value_fork$1=fork();
  if(!(return_value_fork$1 == 0))
  {
    motion_log(5, (unsigned int)9, 0, "%s: Motion going to daemon mode", (const void *)"become_daemon");
    exit(0);
  }

  if(!((*cnt_list)->conf.pid_file == ((char *)NULL)))
  {
    pidf=myfopen(cnt_list[(signed long int)0]->conf.pid_file, "w+", (unsigned long int)0);
    if(!(pidf == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_getpid$2;
      return_value_getpid$2=getpid();
      fprintf(pidf, "%d\n", return_value_getpid$2);
      myfclose(pidf);
    }

    else
    {
      motion_log(0, (unsigned int)9, 1, "%s: Exit motion, cannot create process id file (pid file) %s", (const void *)"become_daemon", cnt_list[(signed long int)0]->conf.pid_file);
      if(!(ptr_logfile == ((struct _IO_FILE *)NULL)))
        myfclose(ptr_logfile);

      exit(0);
    }
  }

  signed int return_value_chdir$3;
  return_value_chdir$3=chdir("/");
  if(!(return_value_chdir$3 == 0))
    motion_log(3, (unsigned int)9, 1, "%s: Could not change directory", (const void *)"become_daemon");

  setpgrp();
  i=open("/dev/tty", 02);
  if(i >= 0)
  {
    ioctl(i, (unsigned long int)0x5422, (void *)0);
    close(i);
  }

  setsid();
  i=open("/dev/null", 00);
  if(!(i == -1))
  {
    dup2(i, 0);
    close(i);
  }

  i=open("/dev/null", 01);
  if(!(i == -1))
  {
    dup2(i, 1);
    dup2(i, 2);
    close(i);
  }

  signed int return_value_getpid$4;
  if(!(pidf == ((struct _IO_FILE *)NULL)))
  {
    return_value_getpid$4=getpid();
    motion_log(5, (unsigned int)9, 0, "%s: Created process id file %s. Process ID is %d", (const void *)"become_daemon", cnt_list[(signed long int)0]->conf.pid_file, return_value_getpid$4);
  }

  sigaction(22, &sig_ign_action, (struct sigaction *)(void *)0);
  sigaction(21, &sig_ign_action, (struct sigaction *)(void *)0);
  sigaction(20, &sig_ign_action, (struct sigaction *)(void *)0);
}

// check_quote
// file netcam.c line 271
static void check_quote(char *str)
{
  signed int len;
  char ch = *str;
  if((signed int)ch == 34 || (signed int)ch == 39)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    len = (signed int)(return_value_strlen$1 - (unsigned long int)1);
    if(str[(signed long int)len] == ch)
    {
      memmove((void *)str, (const void *)(str + (signed long int)1), (unsigned long int)(len - 1));
      str[(signed long int)(len - 1)] = (char)0;
    }

  }

}

// cntlist_create
// file motion.c line 2372
static void cntlist_create(signed int argc, char **argv)
{
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct context *) /*8ul*/  * (unsigned long int)2);
  cnt_list = (struct context **)return_value_mymalloc$1;
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc(sizeof(struct context) /*35256ul*/ );
  cnt_list[(signed long int)0] = (struct context *)return_value_mymalloc$2;
  context_init(cnt_list[(signed long int)0]);
  cnt_list[(signed long int)1] = (struct context *)(void *)0;
  cnt_list[(signed long int)0]->conf.argv = argv;
  cnt_list[(signed long int)0]->conf.argc = argc;
  cnt_list=conf_load(cnt_list);
}

// conf_cmdline
// file conf.c line 1544
static void conf_cmdline(struct context *cnt, signed int thread)
{
  struct config *conf = &cnt->conf;
  signed int c;
  signed int return_value_atoi$1;
  do
  {
    c=getopt(conf->argc, conf->argv, "c:d:hmns?p:k:l:");
    if(c == -1)
      break;

    switch(c)
    {
      case 99:
      {
        if(thread == -1)
          strcpy(cnt->conf_filename, optarg);

        break;
      }
      case 110:
      {
        cnt->daemon = (unsigned int)0;
        break;
      }
      case 115:
      {
        conf->setup_mode = 1;
        break;
      }
      case 100:
      {
        if(thread == -1)
        {
          return_value_atoi$1=atoi(optarg);
          cnt->log_level = (signed int)(unsigned int)return_value_atoi$1;
        }

        break;
      }
      case 107:
      {
        if(thread == -1)
          strcpy(cnt->log_type_str, optarg);

        break;
      }
      case 112:
      {
        if(thread == -1)
          strcpy(cnt->pid_file, optarg);

        break;
      }
      case 108:
      {
        if(thread == -1)
          strcpy(cnt->log_file, optarg);

        break;
      }
      case 109:
      {
        cnt->pause = (unsigned int)1;
        break;
      }
      case 104:

      case 63:

      default:
      {
        usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  optind = 1;
}

// conf_cmdparse
// file conf.h line 161
struct context ** conf_cmdparse(struct context **cnt, const char *cmd, const char *arg1)
{
  unsigned int i = (unsigned int)0;
  if(cmd == ((const char *)NULL))
    return cnt;

  else
  {
    while(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
    {
      signed int return_value_strncasecmp$3;
      return_value_strncasecmp$3=strncasecmp(cmd, config_params[(signed long int)i].param_name, (unsigned long int)(255 + 50));
      if(return_value_strncasecmp$3 == 0)
      {
        const char *return_value_config_type$1;
        return_value_config_type$1=config_type(&config_params[(signed long int)i]);
        signed int return_value_strcmp$2;
        return_value_strcmp$2=strcmp(return_value_config_type$1, "string");
        if(!(return_value_strcmp$2 == 0))
        {
          if(!(config_params[(signed long int)i].conf_value == 0))
          {
            if(arg1 == ((const char *)NULL))
              return cnt;

          }

        }

        cnt=config_params[(signed long int)i].copy(cnt, arg1, config_params[(signed long int)i].conf_value);
        return cnt;
      }

      i = i + 1u;
    }
    motion_log(1, (unsigned int)9, 0, "%s: Unknown config option \"%s\"", (const void *)"conf_cmdparse", cmd);
    return cnt;
  }
}

// conf_load
// file conf.h line 160
struct context ** conf_load(struct context **cnt)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  char filename[4096l];
  signed int i;
  char **argv = cnt[(signed long int)0]->conf.argv;
  signed int argc = cnt[(signed long int)0]->conf.argc;
  memcpy((void *)&cnt[(signed long int)0]->conf, (const void *)&conf_template, sizeof(struct config) /*688ul*/ );
  malloc_strings(cnt[(signed long int)0]);
  cnt[(signed long int)0]->conf.argv = argv;
  cnt[(signed long int)0]->conf.argc = argc;
  cnt[(signed long int)0]->log_type_str[(signed long int)0] = (char)0;
  cnt[(signed long int)0]->conf_filename[(signed long int)0] = (char)0;
  cnt[(signed long int)0]->pid_file[(signed long int)0] = (char)0;
  cnt[(signed long int)0]->log_file[(signed long int)0] = (char)0;
  cnt[(signed long int)0]->log_level = -1;
  conf_cmdline(cnt[(signed long int)0], -1);
  if(!((*cnt)->conf_filename[0l] == 0))
  {
    strcpy(filename, cnt[(signed long int)0]->conf_filename);
    fp=fopen(filename, "r");
  }

  if(fp == ((struct _IO_FILE *)NULL))
  {
    char *path = (char *)(void *)0;
    if(!((*cnt)->conf_filename[0l] == 0))
      motion_log(1, (unsigned int)9, 1, "%s: Configfile %s not found - trying defaults.", (const void *)"conf_load", (const void *)filename);

    path=get_current_dir_name();
    if(path == ((char *)NULL))
    {
      motion_log(3, (unsigned int)9, 1, "%s: Error get_current_dir_name", (const void *)"conf_load");
      exit(-1);
    }

    snprintf(filename, (unsigned long int)4096, "%s/motion.conf", path);
    fp=fopen(filename, "r");
    free((void *)path);
  }

  if(fp == ((struct _IO_FILE *)NULL))
  {
    char *return_value_getenv$1;
    return_value_getenv$1=getenv("HOME");
    snprintf(filename, (unsigned long int)4096, "%s/.motion/motion.conf", return_value_getenv$1);
    fp=fopen(filename, "r");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      snprintf(filename, (unsigned long int)4096, "%s/motion/motion.conf", (const void *)"/etc");
      fp=fopen(filename, "r");
      if(fp == ((struct _IO_FILE *)NULL))
        motion_log(1, (unsigned int)9, 1, "%s: could not open configfile %s", (const void *)"conf_load", (const void *)filename);

    }

  }

  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    strcpy(cnt[(signed long int)0]->conf_filename, filename);
    motion_log(5, (unsigned int)9, 0, "%s: Processing thread 0 - config file %s", (const void *)"conf_load", (const void *)filename);
    cnt=conf_process(cnt, fp);
    myfclose(fp);
  }

  else
    motion_log(2, (unsigned int)9, 0, "%s: Not config file to process using default values", (const void *)"conf_load");
  i = -1;
  do
  {
    i = i + 1;
    if(cnt[(signed long int)i] == ((struct context *)NULL))
      break;

    conf_cmdline(cnt[(signed long int)i], i);
  }
  while((_Bool)1);
  if(!((*cnt)->pid_file[0l] == 0))
    cnt[(signed long int)0]->conf.pid_file=mystrcpy(cnt[(signed long int)0]->conf.pid_file, cnt[(signed long int)0]->pid_file);

  if(!((*cnt)->log_file[0l] == 0))
    cnt[(signed long int)0]->conf.log_file=mystrcpy(cnt[(signed long int)0]->conf.log_file, cnt[(signed long int)0]->log_file);

  if(!((*cnt)->log_type_str[0l] == 0))
    cnt[(signed long int)0]->conf.log_type_str=mystrcpy(cnt[(signed long int)0]->conf.log_type_str, cnt[(signed long int)0]->log_type_str);

  if(!((*cnt)->log_level == -1))
    cnt[(signed long int)0]->conf.log_level = (unsigned int)cnt[(signed long int)0]->log_level;

  return cnt;
}

// conf_print
// file conf.c line 1740
void conf_print(struct context **cnt)
{
  const char *retval;
  char *val;
  unsigned int i;
  unsigned int thread;
  struct _IO_FILE *conffile;
  thread = (unsigned int)0;
  signed int return_value_strncmp$2;
  for( ; !(cnt[(signed long int)thread] == ((struct context *)NULL)); thread = thread + 1u)
  {
    motion_log(5, (unsigned int)9, 0, "%s: Writing config file to %s", (const void *)"conf_print", (const void *)cnt[(signed long int)thread]->conf_filename);
    conffile=myfopen(cnt[(signed long int)thread]->conf_filename, "w", (unsigned long int)0);
    if(!(conffile == ((struct _IO_FILE *)NULL)))
    {
      fprintf(conffile, "# %s\n", (const void *)cnt[(signed long int)thread]->conf_filename);
      fprintf(conffile, "#\n# This config file was generated by motion 3.2.12+git20140228\n");
      fprintf(conffile, "\n\n");
      i = (unsigned int)0;
      if(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
      {
        retval=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, thread);
        if(!(retval == ((const char *)NULL)))
        {
          fprintf(conffile, "%s\n", config_params[(signed long int)i].param_help);
          signed int return_value_strncmp$1;
          return_value_strncmp$1=strncmp(config_params[(signed long int)i].param_name, "text", (unsigned long int)4);
          _Bool tmp_if_expr$3;
          if(!(return_value_strncmp$1 == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value_strncmp$2=strncmp(retval, " ", (unsigned long int)1);
            tmp_if_expr$3 = return_value_strncmp$2 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
            fprintf(conffile, "%s %s\n\n", config_params[(signed long int)i].param_name, retval);

          else
            fprintf(conffile, "%s \"%s\"\n\n", config_params[(signed long int)i].param_name, retval);
        }

        else
        {
          val = (char *)(void *)0;
          config_params[(signed long int)i].print(cnt, &val, (signed int)i, thread);
          if(!(val == ((char *)NULL)))
          {
            fprintf(conffile, "%s\n", config_params[(signed long int)i].param_help);
            fprintf(conffile, "%s\n", val);
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(val);
            if(return_value_strlen$4 == 0ul)
              fprintf(conffile, "; thread %s/motion/thread1.conf\n", (const void *)"/etc");

            free((void *)val);
          }

          else
            if(thread == 0u)
            {
              fprintf(conffile, "%s\n", config_params[(signed long int)i].param_help);
              fprintf(conffile, "; %s value\n\n", config_params[(signed long int)i].param_name);
            }

        }
        i = i + 1u;
      }

      fprintf(conffile, "\n");
      myfclose(conffile);
      conffile = (struct _IO_FILE *)(void *)0;
    }

  }
}

// conf_process
// file conf.c line 1666
static struct context ** conf_process(struct context **cnt, struct _IO_FILE *fp)
{
  char line[4096l];
  char *cmd = (char *)(void *)0;
  char *arg1 = (char *)(void *)0;
  char *beg = (char *)(void *)0;
  char *end = (char *)(void *)0;
  char *return_value_fgets$1;
  unsigned long int return_value_strlen$12;
  unsigned long int return_value_strlen$5;
  _Bool tmp_if_expr$8;
  unsigned long int return_value_strlen$7;
  do
  {
    return_value_fgets$1=fgets(line, 4096 - 1, fp);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    _Bool tmp_if_expr$11;
    if((signed int)line[0l] == 35)
      tmp_if_expr$11 = (_Bool)1;

    else
      tmp_if_expr$11 = (signed int)line[(signed long int)0] == 59 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$13;
    if(tmp_if_expr$11)
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_strlen$12=strlen(line);
      tmp_if_expr$13 = return_value_strlen$12 < (unsigned long int)2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$13)
    {
      arg1 = (char *)(void *)0;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(line);
      end = (line + (signed long int)return_value_strlen$2) - (signed long int)1;
      for( ; (_Bool)1; end = end - 1l)
        if(!((signed int)*end == 32))
        {
          if(!((signed int)*end == 9))
          {
            if(!((signed int)*end == 10))
            {
              if(!((signed int)*end == 13))
                goto __CPROVER_DUMP_L8;

            }

          }

        }


    __CPROVER_DUMP_L8:
      ;
      end[(signed long int)1] = (char)0;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(line);
      if(return_value_strlen$3 == 0ul)
        continue;

      beg = line;
      for( ; (_Bool)1; beg = beg + 1l)
        if(!((signed int)*beg == 32))
        {
          if(!((signed int)*beg == 9))
            goto __CPROVER_DUMP_L11;

        }


    __CPROVER_DUMP_L11:
      ;
      cmd = beg;
      for( ; !((signed int)*beg == 32); beg = beg + 1l)
      {
        if((signed int)*beg == 9)
          break;

        if((signed int)*beg == 61)
          break;

        if((signed int)*beg == 0)
          break;

      }
      *beg = (char)0;
      beg = beg + 1l;
      unsigned long int return_value_strlen$10;
      return_value_strlen$10=strlen(beg);
      if(return_value_strlen$10 >= 1ul)
      {
        for( ; (_Bool)1; beg = beg + 1l)
          if(!((signed int)*beg == 32))
          {
            if(!((signed int)*beg == 9))
            {
              if(!((signed int)*beg == 61))
              {
                if(!((signed int)*beg == 10))
                {
                  if(!((signed int)*beg == 13))
                    goto __CPROVER_DUMP_L16;

                }

              }

            }

          }


      __CPROVER_DUMP_L16:
        ;
        _Bool tmp_if_expr$6;
        if((signed int)*beg == 34)
        {
          return_value_strlen$5=strlen(beg);
          tmp_if_expr$6 = (signed int)beg[(signed long int)(return_value_strlen$5 - (unsigned long int)1)] == 34 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        _Bool tmp_if_expr$9;
        if(tmp_if_expr$6)
          tmp_if_expr$9 = (_Bool)1;

        else
        {
          if((signed int)*beg == 39)
          {
            return_value_strlen$7=strlen(beg);
            tmp_if_expr$8 = (signed int)beg[(signed long int)(return_value_strlen$7 - (unsigned long int)1)] == 39 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$8 = (_Bool)0;
          tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$9)
        {
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(beg);
          beg[(signed long int)(return_value_strlen$4 - (unsigned long int)1)] = (char)0;
          beg = beg + 1l;
        }

        arg1 = beg;
      }

      cnt=conf_cmdparse(cnt, cmd, arg1);
    }

  }
  while((_Bool)1);
  return cnt;
}

// config
// file webhttpd.c line 393
static unsigned int config(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata)
{
  char question = (char)0;
  char command[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned int i;
  struct context **cnt = (struct context **)userdata;
  warningkill=sscanf(pointer, "%255[a-z]%c", (const void *)command, &question);
  signed int return_value_strcmp$34;
  return_value_strcmp$34=strcmp(command, "list");
  signed int return_value_strcmp$33;
  unsigned long int return_value_strlen$12;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  unsigned long int return_value_strlen$23;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$29;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$30;
  if(return_value_strcmp$34 == 0)
  {
    pointer = pointer + (signed long int)4;
    length_uri = length_uri - (unsigned int)4;
    if(length_uri == 0u)
    {
      const char *config$$1$$1$$1$$value = (const char *)(void *)0;
      char *retval = (char *)(void *)0;
      if(!((*cnt)->conf.webcontrol_html_output == 0))
      {
        send_template_ini_client(client_socket, ini_template);
        sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<ul>", thread, thread);
        send_template(client_socket, res);
        i = (unsigned int)0;
        for( ; !(config_params[(signed long int)i].param_name == ((const char *)NULL)); i = i + 1u)
        {
          if(!(thread == 0u))
          {
            if(!(config_params[(signed long int)i].main_thread == 0u))
              goto __CPROVER_DUMP_L15;

          }

          config$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, thread);
          if(config$$1$$1$$1$$value == ((const char *)NULL))
          {
            retval = (char *)(void *)0;
            if(thread == 0u)
              config_params[(signed long int)i].print(cnt, &retval, (signed int)i, thread);

            if(!(retval == ((char *)NULL)))
            {
              signed int return_value_strcmp$6;
              return_value_strcmp$6=strcmp(retval, "");
              if(return_value_strcmp$6 == 0)
              {
                free((void *)retval);
                retval=mystrdup("No threads");
              }

              else
              {
                char *temp = retval;
                unsigned long int retval_miss = (unsigned long int)0;
                unsigned long int retval_len;
                retval_len=strlen(retval);
                unsigned int ind = (unsigned int)0;
                char thread_strings[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                if(!(retval_miss == retval_len))
                {
                  if(!((signed int)*temp == 10))
                  {
                    unsigned int tmp_post$1 = ind;
                    ind = ind + 1u;
                    thread_strings[(signed long int)tmp_post$1] = *temp;
                    retval_miss = retval_miss + 1ul;
                    temp = temp + 1l;
                  }

                  temp = temp + 1l;
                  unsigned int tmp_post$2 = ind;
                  ind = ind + 1u;
                  thread_strings[(signed long int)tmp_post$2] = (char)60;
                  unsigned int tmp_post$3 = ind;
                  ind = ind + 1u;
                  thread_strings[(signed long int)tmp_post$3] = (char)98;
                  unsigned int tmp_post$4 = ind;
                  ind = ind + 1u;
                  thread_strings[(signed long int)tmp_post$4] = (char)114;
                  unsigned int tmp_post$5 = ind;
                  ind = ind + 1u;
                  thread_strings[(signed long int)tmp_post$5] = (char)62;
                  retval_miss = retval_miss + 1ul;
                }

                free((void *)retval);
                retval = (char *)(void *)0;
                retval=mystrdup(thread_strings);
              }
              sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, retval);
              free((void *)retval);
            }

            else
              if(!(thread == 0u))
              {
                config$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, (unsigned int)0);
                sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, config$$1$$1$$1$$value != ((const char *)NULL) ? config$$1$$1$$1$$value : "(not defined)");
              }

              else
                sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, (const void *)"(not defined)");
          }

          else
            sprintf(res, "<li><a href=/%hu/config/set?%s>%s</a> = %s</li>\n", thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, config$$1$$1$$1$$value);
          send_template(client_socket, res);

        __CPROVER_DUMP_L15:
          ;
        }
        sprintf(res, "</ul><a href=/%hu/config>&lt;&ndash; back</a>", thread);
        send_template(client_socket, res);
        send_template_end_client(client_socket);
      }

      else
      {
        send_template_ini_client_raw(client_socket);
        i = (unsigned int)0;
        if(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
        {
          config$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, thread);
          if(config$$1$$1$$1$$value == ((const char *)NULL))
            config$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, (unsigned int)0);

          sprintf(res, "%s = %s\n", config_params[(signed long int)i].param_name, config$$1$$1$$1$$value);
          send_template_raw(client_socket, res);
          i = i + 1u;
        }

      }
    }

    else
      if(!((*cnt)->conf.webcontrol_html_output == 0))
        response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

      else
        response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
  }

  else
  {
    return_value_strcmp$33=strcmp(command, "set");
    if(return_value_strcmp$33 == 0)
    {
      pointer = pointer + (signed long int)3;
      length_uri = length_uri - (unsigned int)3;
      if((signed int)question == 63 && !(length_uri == 0u))
      {
        pointer = pointer + 1l;
        length_uri = length_uri - 1u;
        warningkill=sscanf(pointer, "%255[-0-9a-z_]%c", (const void *)command, &question);
        _Bool tmp_if_expr$25;
        if((signed int)question == 61)
          tmp_if_expr$25 = (signed int)command[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$25 = (_Bool)0;
        if(tmp_if_expr$25)
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(command);
          length_uri = (unsigned int)(((unsigned long int)length_uri - return_value_strlen$7) - (unsigned long int)1);
          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(command);
          pointer = pointer + (signed long int)return_value_strlen$8 + (signed long int)1;
          i = (unsigned int)0;
          while(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
            if(!(thread == 0u))
            {
              if(config_params[(signed long int)i].main_thread == 0u)
                goto __CPROVER_DUMP_L28;

              i = i + 1u;
            }

            else
            {

            __CPROVER_DUMP_L28:
              ;
              signed int return_value_strcasecmp$9;
              return_value_strcasecmp$9=strcasecmp(command, config_params[(signed long int)i].param_name);
              if(return_value_strcasecmp$9 == 0)
                break;

              i = i + 1u;
            }
          if(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
          {
            if(length_uri >= 1u)
            {
              char Value[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
              warningkill=sscanf(pointer, "%1023s", (const void *)Value);
              unsigned long int return_value_strlen$10;
              return_value_strlen$10=strlen(Value);
              length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$10);
              _Bool tmp_if_expr$13;
              if(length_uri == 0u)
              {
                return_value_strlen$12=strlen(Value);
                tmp_if_expr$13 = return_value_strlen$12 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$13 = (_Bool)0;
              if(tmp_if_expr$13)
              {
                unsigned long int return_value_strlen$11;
                return_value_strlen$11=strlen(Value);
                url_decode(Value, return_value_strlen$11);
                conf_cmdparse(cnt + (signed long int)thread, config_params[(signed long int)i].param_name, Value);
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<ul><li><a href=/%hu/config/set?%s>%s</a> = %s</li></ul><b>Done</b>", thread, thread, thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, (const void *)Value);
                  send_template_ini_client(client_socket, ini_template);
                  send_template(client_socket, res);
                  send_template_end_client(client_socket);
                }

                else
                {
                  send_template_ini_client_raw(client_socket);
                  sprintf(res, "%s = %s\nDone\n", config_params[(signed long int)i].param_name, (const void *)Value);
                  send_template_raw(client_socket, res);
                }
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                  response_client(client_socket, not_valid_syntax, (char *)(void *)0);

                else
                  response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
            }

            else
            {
              char *type = (char *)(void *)0;
              const char *return_value_config_type$14;
              return_value_config_type$14=config_type(&config_params[(signed long int)i]);
              type=mystrdup(return_value_config_type$14);
              signed int return_value_strcmp$17;
              return_value_strcmp$17=strcmp(type, "string");
              if(return_value_strcmp$17 == 0)
              {
                char *value = (char *)(void *)0;
                conf_cmdparse(cnt + (signed long int)thread, config_params[(signed long int)i].param_name, value);
                free((void *)type);
                type=mystrdup("(null)");
              }

              else
              {
                return_value_strcmp$16=strcmp(type, "int");
                if(return_value_strcmp$16 == 0)
                {
                  free((void *)type);
                  type=mystrdup("0");
                  conf_cmdparse(cnt + (signed long int)thread, config_params[(signed long int)i].param_name, type);
                }

                else
                {
                  return_value_strcmp$15=strcmp(type, "bool");
                  if(return_value_strcmp$15 == 0)
                  {
                    free((void *)type);
                    type=mystrdup("off");
                    conf_cmdparse(cnt + (signed long int)thread, config_params[(signed long int)i].param_name, type);
                  }

                  else
                  {
                    free((void *)type);
                    type=mystrdup("unknown");
                  }
                }
              }
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<ul><li><a href=/%hu/config/set?%s>%s</a>= %s</li></ul><br><b>Done</b>", thread, thread, thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, type);
                send_template_ini_client(client_socket, ini_template);
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "%s = %s\nDone\n", config_params[(signed long int)i].param_name, type);
                send_template_raw(client_socket, res);
              }
              free((void *)type);
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }

        else
        {
          _Bool tmp_if_expr$22;
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            tmp_if_expr$22 = (signed int)command[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$22 = (_Bool)0;
          _Bool tmp_if_expr$24;
          if(tmp_if_expr$22)
          {
            return_value_strlen$23=strlen(command);
            length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$23);
            tmp_if_expr$24 = length_uri == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$24 = (_Bool)0;
          if(tmp_if_expr$24)
          {
            i = (unsigned int)0;
            while(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
              if(!(thread == 0u))
              {
                if(config_params[(signed long int)i].main_thread == 0u)
                  goto __CPROVER_DUMP_L57;

                i = i + 1u;
              }

              else
              {

              __CPROVER_DUMP_L57:
                ;
                signed int return_value_strcasecmp$18;
                return_value_strcasecmp$18=strcasecmp(command, config_params[(signed long int)i].param_name);
                if(return_value_strcasecmp$18 == 0)
                  break;

                i = i + 1u;
              }
            if(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
            {
              const char *config$$1$$2$$1$$2$$1$$2$$value = (const char *)(void *)0;
              char *text_help = (char *)(void *)0;
              char *sharp = (char *)(void *)0;
              config$$1$$2$$1$$2$$1$$2$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, thread);
              sharp=strstr(config_params[(signed long int)i].param_help, "#\n\n#");
              if(sharp == ((char *)NULL))
                sharp=strstr(config_params[(signed long int)i].param_help, "#");

              sharp = sharp + 1l;
              text_help=replace(sharp, "\n#", "<br>");
              send_template_ini_client(client_socket, ini_template);
              const char *return_value_config_type$20;
              return_value_config_type$20=config_type(&config_params[(signed long int)i]);
              signed int return_value_strcmp$21;
              return_value_strcmp$21=strcmp("bool", return_value_config_type$20);
              if(return_value_strcmp$21 == 0)
              {
                char option[80l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                if(config$$1$$2$$1$$2$$1$$2$$value == ((const char *)NULL) && !(thread == 0u))
                  config$$1$$2$$1$$2$$1$$2$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, (unsigned int)0);

                signed int return_value_strcmp$19;
                return_value_strcmp$19=strcmp("on", config$$1$$2$$1$$2$$1$$2$$value);
                if(return_value_strcmp$19 == 0)
                  sprintf(option, "<option value='on' selected>on</option>\n<option value='off'>off</option>\n");

                else
                  sprintf(option, "<option value='on'>on</option>\n<option value='off' selected>off</option>\n");
                sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<form action=set?>\n<b>%s</b>&nbsp;<select name='%s'>\n%s</select><input type='submit' value='set'>\n&nbsp;&nbsp;&nbsp;&nbsp;<a href='%s#%s' target=_blank>[help]</a></form>\n<hr><i>%s</i>", thread, thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, (const void *)option, (const void *)"http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideAlphabeticalOptionReferenceManual", config_params[(signed long int)i].param_name, text_help);
              }

              else
              {
                if(config$$1$$2$$1$$2$$1$$2$$value == ((const char *)NULL))
                {
                  if(!(thread == 0u))
                    config$$1$$2$$1$$2$$1$$2$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, (unsigned int)0);

                  if(config$$1$$2$$1$$2$$1$$2$$value == ((const char *)NULL))
                    config$$1$$2$$1$$2$$1$$2$$value = "";

                }

                sprintf(res, "<a href=/%hu/config/list>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<form action=set?>\n<b>%s</b>&nbsp;<input type=text name='%s' value='%s' size=80>\n<input type='submit' value='set'>\n&nbsp;&nbsp;&nbsp;&nbsp;<a href='%s#%s' target=_blank>[help]</a></form>\n<hr><i>%s</i>", thread, thread, config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name, config$$1$$2$$1$$2$$1$$2$$value, (const void *)"http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideAlphabeticalOptionReferenceManual", config_params[(signed long int)i].param_name, text_help);
              }
              send_template(client_socket, res);
              send_template_end_client(client_socket);
              free((void *)text_help);
            }

            else
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

              else
                response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }
      }

      else
        if(length_uri == 0u)
        {
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            send_template_ini_client(client_socket, set_template);
            sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<form name='n'>\n<select name='onames'>\n", thread, thread);
            send_template(client_socket, res);
            i = (unsigned int)0;
            for( ; !(config_params[(signed long int)i].param_name == ((const char *)NULL)); i = i + 1u)
            {
              if(!(thread == 0u))
              {
                if(!(config_params[(signed long int)i].main_thread == 0u))
                  goto __CPROVER_DUMP_L78;

              }

              sprintf(res, "<option value='%s'>%s</option>\n", config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name);
              send_template(client_socket, res);

            __CPROVER_DUMP_L78:
              ;
            }
            sprintf(res, "</select>\n</form>\n<form action=set name='s'ONSUBMIT='if (!this.submitted) return false; else return true;'>\n<input type=text name='valor' value=''>\n<input type='button' value='set' onclick='javascript:show()'>\n</form>\n");
            send_template(client_socket, res);
            send_template_end_client(client_socket);
          }

          else
          {
            send_template_ini_client_raw(client_socket);
            sprintf(res, "set needs param_name=value\n");
            send_template_raw(client_socket, res);
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
    }

    else
    {
      return_value_strcmp$32=strcmp(command, "get");
      if(return_value_strcmp$32 == 0)
      {
        pointer = pointer + (signed long int)3;
        length_uri = length_uri - (unsigned int)3;
        if((signed int)question == 63 && length_uri >= 8u)
        {
          pointer = pointer + 1l;
          length_uri = length_uri - 1u;
          warningkill=sscanf(pointer, "%255[-0-9a-z]%c", (const void *)command, &question);
          if((signed int)question == 61)
          {
            return_value_strcmp$29=strcmp(command, "query");
            if(return_value_strcmp$29 == 0)
            {
              pointer = pointer + (signed long int)6;
              length_uri = length_uri - (unsigned int)6;
              warningkill=sscanf(pointer, "%255[-0-9a-z_]", (const void *)command);
              unsigned long int return_value_strlen$26;
              return_value_strlen$26=strlen(command);
              length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$26);
              if(length_uri == 0u)
              {
                const char *config$$1$$3$$1$$1$$1$$value = (const char *)(void *)0;
                i = (unsigned int)0;
                while(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
                  if(!(thread == 0u))
                  {
                    if(config_params[(signed long int)i].main_thread == 0u)
                      goto __CPROVER_DUMP_L87;

                    i = i + 1u;
                  }

                  else
                  {

                  __CPROVER_DUMP_L87:
                    ;
                    signed int return_value_strcasecmp$27;
                    return_value_strcasecmp$27=strcasecmp(command, config_params[(signed long int)i].param_name);
                    if(return_value_strcasecmp$27 == 0)
                      break;

                    i = i + 1u;
                  }
                if(!(config_params[(signed long int)i].param_name == ((const char *)NULL)))
                {
                  const char *config$$1$$3$$1$$1$$1$$2$$type = (const char *)(void *)0;
                  config$$1$$3$$1$$1$$1$$2$$type=config_type(&config_params[(signed long int)i]);
                  signed int return_value_strcmp$28;
                  return_value_strcmp$28=strcmp(config$$1$$3$$1$$1$$1$$2$$type, "unknown");
                  if(return_value_strcmp$28 == 0)
                  {
                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                      response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                    else
                      response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
                    return (unsigned int)1;
                  }

                  else
                  {
                    char *config$$1$$3$$1$$1$$1$$2$$2$$text_help = (char *)(void *)0;
                    char *config$$1$$3$$1$$1$$1$$2$$2$$sharp = (char *)(void *)0;
                    config$$1$$3$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, thread);
                    config$$1$$3$$1$$1$$1$$2$$2$$sharp=strstr(config_params[(signed long int)i].param_help, "#\n\n#");
                    if(config$$1$$3$$1$$1$$1$$2$$2$$sharp == ((char *)NULL))
                      config$$1$$3$$1$$1$$1$$2$$2$$sharp=strstr(config_params[(signed long int)i].param_help, "#");

                    config$$1$$3$$1$$1$$1$$2$$2$$sharp = config$$1$$3$$1$$1$$1$$2$$2$$sharp + 1l;
                    config$$1$$3$$1$$1$$1$$2$$2$$text_help=replace(config$$1$$3$$1$$1$$1$$2$$2$$sharp, "\n#", "<br>");
                    if(config$$1$$3$$1$$1$$1$$value == ((const char *)NULL))
                      config$$1$$3$$1$$1$$1$$value=config_params[(signed long int)i].print(cnt, (char **)(void *)0, (signed int)i, (unsigned int)0);

                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                    {
                      send_template_ini_client(client_socket, ini_template);
                      sprintf(res, "<a href=/%hu/config/get>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n<ul><li>%s = %s &nbsp;&nbsp;&nbsp;&nbsp;<a href='%s#%s' target=_blank>[help]</a></li></ul><hr><i>%s</i>", thread, thread, config_params[(signed long int)i].param_name, config$$1$$3$$1$$1$$1$$value, (const void *)"http://www.lavrsen.dk/twiki/bin/view/Motion/MotionGuideAlphabeticalOptionReferenceManual", config_params[(signed long int)i].param_name, config$$1$$3$$1$$1$$1$$2$$2$$text_help);
                      send_template(client_socket, res);
                      send_template_end_client(client_socket);
                      free((void *)config$$1$$3$$1$$1$$1$$2$$2$$text_help);
                    }

                    else
                    {
                      send_template_ini_client_raw(client_socket);
                      sprintf(res, "%s = %s\nDone\n", config_params[(signed long int)i].param_name, config$$1$$3$$1$$1$$1$$value);
                      send_template_raw(client_socket, res);
                    }
                  }
                }

                else
                  if(!((*cnt)->conf.webcontrol_html_output == 0))
                    response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                  else
                    response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                  response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                else
                  response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
            }

          }

        }

        else
          if(length_uri == 0u)
          {
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n<form action=get>\n<select name='query'>\n", thread, thread);
              send_template(client_socket, res);
              i = (unsigned int)0;
              for( ; !(config_params[(signed long int)i].param_name == ((const char *)NULL)); i = i + 1u)
              {
                if(!(thread == 0u))
                {
                  if(!(config_params[(signed long int)i].main_thread == 0u))
                    goto __CPROVER_DUMP_L109;

                }

                sprintf(res, "<option value='%s'>%s</option>\n", config_params[(signed long int)i].param_name, config_params[(signed long int)i].param_name);
                send_template(client_socket, res);

              __CPROVER_DUMP_L109:
                ;
              }
              sprintf(res, "</select>\n<input type='submit' value='get'>\n</form>\n");
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              sprintf(res, "get needs param_name\n");
              send_template_raw(client_socket, res);
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_valid_syntax, (char *)(void *)0);

            else
              response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
      }

      else
      {
        return_value_strcmp$31=strcmp(command, "write");
        if(return_value_strcmp$31 == 0)
        {
          pointer = pointer + (signed long int)5;
          length_uri = length_uri - (unsigned int)5;
          if(length_uri == 0u)
          {
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>Are you sure? <a href=/%hu/config/writeyes>Yes</a>\n", thread, thread);
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              conf_print(cnt);
              send_template_ini_client_raw(client_socket);
              sprintf(res, "Thread %hu write\nDone\n", thread);
              send_template_raw(client_socket, res);
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }

        else
        {
          return_value_strcmp$30=strcmp(command, "writeyes");
          if(return_value_strcmp$30 == 0)
          {
            pointer = pointer + (signed long int)8;
            length_uri = length_uri - (unsigned int)8;
            if(length_uri == 0u)
            {
              conf_print(cnt);
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "<a href=/%hu/config>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>  write done !\n", thread, thread);
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "Thread %hu write\nDone\n", thread);
                send_template_raw(client_socket, res);
              }
            }

            else
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

              else
                response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }
      }
    }
  }
  return (unsigned int)1;
}

// config_thread
// file conf.c line 2289
static struct context ** config_thread(struct context **cnt, const char *str, signed int val)
{
  signed int i;
  struct _IO_FILE *fp;
  if(!((*cnt)->threadnr == 0))
    return cnt;

  else
  {
    fp=fopen(str, "r");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      motion_log(1, (unsigned int)9, 1, "%s: Thread config file %s not found", (const void *)"config_thread", str);
      return cnt;
    }

    else
    {
      i = -1;
      do
      {
        i = i + 1;
        if(cnt[(signed long int)i] == ((struct context *)NULL))
          break;

      }
      while((_Bool)1);
      void *return_value_myrealloc$1;
      return_value_myrealloc$1=myrealloc((void *)cnt, sizeof(struct context *) /*8ul*/  * (unsigned long int)(i + 2), "config_thread");
      cnt = (struct context **)return_value_myrealloc$1;
      void *return_value_mymalloc$2;
      return_value_mymalloc$2=mymalloc(sizeof(struct context) /*35256ul*/ );
      cnt[(signed long int)i] = (struct context *)return_value_mymalloc$2;
      memcpy((void *)cnt[(signed long int)i], (const void *)cnt[(signed long int)0], sizeof(struct context) /*35256ul*/ );
      malloc_strings(cnt[(signed long int)i]);
      cnt[(signed long int)(i + 1)] = (struct context *)(void *)0;
      strcpy(cnt[(signed long int)i]->conf_filename, str);
      motion_log(5, (unsigned int)9, 0, "%s: Processing config file %s", (const void *)"config_thread", str);
      conf_process(cnt + (signed long int)i, fp);
      myfclose(fp);
      return cnt;
    }
  }
}

// config_type
// file conf.c line 2177
const char * config_type(struct anonymous *configparam)
{
  if(configparam->copy == copy_string)
    return "string";

  else
    if(configparam->copy == copy_int)
      return "int";

    else
      if(configparam->copy == copy_bool)
        return "bool";

      else
        return "unknown";
}

// context_destroy
// file motion.c line 270
static void context_destroy(struct context *cnt)
{
  unsigned int j = (unsigned int)0;
  for( ; !(config_params[(signed long int)j].param_name == ((const char *)NULL)); j = j + 1u)
    if(config_params[(signed long int)j].copy == copy_string)
    {
      void **val = (void **)(void *)((char *)cnt + (signed long int)(signed int)config_params[(signed long int)j].conf_value);
      if(!(*val == NULL))
      {
        free(*val);
        *val = (void *)0;
      }

    }

  free((void *)cnt);
}

// context_init
// file motion.c line 236
static void context_init(struct context *cnt)
{
  memset((void *)cnt, 0, sizeof(struct context) /*35256ul*/ );
  cnt->noise = 255;
  cnt->lastrate = (unsigned int)25;
  memcpy((void *)&cnt->track, (const void *)&track_template, sizeof(struct trackoptions) /*96ul*/ );
  cnt->pipe = -1;
  cnt->mpipe = -1;
}

// conv_rgb24toyuv420p
// file video.h line 96
void conv_rgb24toyuv420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height)
{
  unsigned char *y;
  unsigned char *u;
  unsigned char *v;
  unsigned char *r;
  unsigned char *g;
  unsigned char *b;
  signed int i;
  signed int loop;
  b = cap_map;
  g = b + (signed long int)1;
  r = g + (signed long int)1;
  y = map;
  u = y + (signed long int)(width * height);
  v = u + (signed long int)((width * height) / 4);
  memset((void *)u, 0, (unsigned long int)((width * height) / 4));
  memset((void *)v, 0, (unsigned long int)((width * height) / 4));
  loop = 0;
  for( ; !(loop >= height); loop = loop + 1)
  {
    i = 0;
    for( ; !(i >= width); i = i + 2)
    {
      unsigned char *tmp_post$1 = y;
      y = y + 1l;
      *tmp_post$1 = (unsigned char)(9796 * (signed int)*r + 19235 * (signed int)*g + 3736 * (signed int)*b >> 15);
      *u = *u + (unsigned char)(((-4784 * (signed int)*r - 9437 * (signed int)*g) + 14221 * (signed int)*b >> 17) + 32);
      *v = *v + (unsigned char)(((20218 * (signed int)*r - 16941 * (signed int)*g) - 3277 * (signed int)*b >> 17) + 32);
      r = r + (signed long int)3;
      g = g + (signed long int)3;
      b = b + (signed long int)3;
      unsigned char *tmp_post$2 = y;
      y = y + 1l;
      *tmp_post$2 = (unsigned char)(9796 * (signed int)*r + 19235 * (signed int)*g + 3736 * (signed int)*b >> 15);
      *u = *u + (unsigned char)(((-4784 * (signed int)*r - 9437 * (signed int)*g) + 14221 * (signed int)*b >> 17) + 32);
      *v = *v + (unsigned char)(((20218 * (signed int)*r - 16941 * (signed int)*g) - 3277 * (signed int)*b >> 17) + 32);
      r = r + (signed long int)3;
      g = g + (signed long int)3;
      b = b + (signed long int)3;
      u = u + 1l;
      v = v + 1l;
    }
    if((1 & loop) == 0)
    {
      u = u - (signed long int)(width / 2);
      v = v - (signed long int)(width / 2);
    }

  }
}

// conv_uyvyto420p
// file video.h line 95
void conv_uyvyto420p(unsigned char *map, unsigned char *cap_map, unsigned int width, unsigned int height)
{
  unsigned char *pY = map;
  unsigned char *pU = pY + (signed long int)(width * height);
  unsigned char *pV = pU + (signed long int)((width * height) / (unsigned int)4);
  unsigned int uv_offset = (unsigned int)((unsigned long int)(width * (unsigned int)2) * sizeof(unsigned char) /*1ul*/ );
  unsigned int ix;
  unsigned int jx;
  ix = (unsigned int)0;
  for( ; !(ix >= height); ix = ix + 1u)
  {
    jx = (unsigned int)0;
    for( ; !(jx >= width); jx = jx + (unsigned int)2)
    {
      unsigned short int calc;
      if((1u & ix) == 0u)
      {
        calc = (unsigned short int)*cap_map;
        calc = calc + (unsigned short int)cap_map[(signed long int)uv_offset];
        calc = calc / (unsigned short int)2;
        unsigned char *tmp_post$1 = pU;
        pU = pU + 1l;
        *tmp_post$1 = (unsigned char)calc;
      }

      cap_map = cap_map + 1l;
      unsigned char *tmp_post$2 = pY;
      pY = pY + 1l;
      unsigned char *tmp_post$3 = cap_map;
      cap_map = cap_map + 1l;
      *tmp_post$2 = *tmp_post$3;
      if((1u & ix) == 0u)
      {
        calc = (unsigned short int)*cap_map;
        calc = calc + (unsigned short int)cap_map[(signed long int)uv_offset];
        calc = calc / (unsigned short int)2;
        unsigned char *tmp_post$4 = pV;
        pV = pV + 1l;
        *tmp_post$4 = (unsigned char)calc;
      }

      cap_map = cap_map + 1l;
      unsigned char *tmp_post$5 = pY;
      pY = pY + 1l;
      unsigned char *tmp_post$6 = cap_map;
      cap_map = cap_map + 1l;
      *tmp_post$5 = *tmp_post$6;
    }
  }
}

// conv_yuv422to420p
// file video.h line 94
void conv_yuv422to420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height)
{
  unsigned char *src;
  unsigned char *dest;
  unsigned char *src2;
  unsigned char *dest2;
  signed int i;
  signed int j;
  src = cap_map;
  dest = map;
  i = width * height;
  for( ; i >= 1; i = i - 1)
  {
    unsigned char *tmp_post$1 = dest;
    dest = dest + 1l;
    *tmp_post$1 = *src;
    src = src + (signed long int)2;
  }
  src = cap_map + (signed long int)1;
  src2 = cap_map + (signed long int)(width * 2) + (signed long int)1;
  dest = map + (signed long int)(width * height);
  dest2 = dest + (signed long int)((width * height) / 4);
  i = height / 2;
  for( ; i >= 1; i = i - 1)
  {
    j = width / 2;
    for( ; j >= 1; j = j - 1)
    {
      *dest = (unsigned char)(((signed int)*src + (signed int)*src2) / 2);
      src = src + (signed long int)2;
      src2 = src2 + (signed long int)2;
      dest = dest + 1l;
      *dest2 = (unsigned char)(((signed int)*src + (signed int)*src2) / 2);
      src = src + (signed long int)2;
      src2 = src2 + (signed long int)2;
      dest2 = dest2 + 1l;
    }
    src = src + (signed long int)(width * 2);
    src2 = src2 + (signed long int)(width * 2);
  }
}

// copy_bool
// file conf.c line 2016
static struct context ** copy_bool(struct context **cnt, const char *str, signed int val_ptr)
{
  void *tmp;
  signed int i = -1;
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$4;
  do
  {
    i = i + 1;
    if(cnt[(signed long int)i] == ((struct context *)NULL))
      break;

    tmp = (void *)((char *)cnt[(signed long int)i] + (signed long int)(signed int)val_ptr);
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(str, "1");
    _Bool tmp_if_expr$3;
    if(return_value_strcmp$1 == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_strcasecmp$2=strcasecmp(str, "yes");
      tmp_if_expr$3 = !(return_value_strcasecmp$2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcasecmp$4=strcasecmp(str, "on");
      tmp_if_expr$5 = !(return_value_strcasecmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      *((signed int *)tmp) = 1;

    else
      *((signed int *)tmp) = 0;
    if(!((*cnt)->threadnr == 0))
      return cnt;

  }
  while((_Bool)1);
  return cnt;
}

// copy_int
// file conf.c line 2046
static struct context ** copy_int(struct context **cnt, const char *str, signed int val_ptr)
{
  void *tmp;
  signed int i = -1;
  do
  {
    i = i + 1;
    if(cnt[(signed long int)i] == ((struct context *)NULL))
      break;

    tmp = (void *)((char *)cnt[(signed long int)i] + (signed long int)val_ptr);
    *((signed int *)tmp)=atoi(str);
    if(!((*cnt)->threadnr == 0))
      return cnt;

  }
  while((_Bool)1);
  return cnt;
}

// copy_string
// file conf.h line 167
struct context ** copy_string(struct context **cnt, const char *str, signed int val_ptr)
{
  char **tmp;
  signed int i = -1;
  do
  {
    i = i + 1;
    if(cnt[(signed long int)i] == ((struct context *)NULL))
      break;

    tmp = (char **)((char *)cnt[(signed long int)i] + (signed long int)val_ptr);
    *tmp=mystrcpy(*tmp, str);
    if(!((*cnt)->threadnr == 0))
      return cnt;

  }
  while((_Bool)1);
  return cnt;
}

// create_path
// file motion.c line 2924
signed int create_path(const char *path)
{
  char *start;
  unsigned int mode = (unsigned int)(0400 | 0200 | 0100 | 0400 >> 3 | 0100 >> 3 | (0400 >> 3) >> 3 | (0100 >> 3) >> 3);
  if((signed int)*path == 47)
    start=strchr(path + (signed long int)1, 47);

  else
    start=strchr(path, 47);
  signed int *return_value___errno_location$1;
  while(!(start == ((char *)NULL)))
  {
    char *buffer;
    buffer=mystrdup(path);
    buffer[start - path] = (char)0x00;
    signed int return_value_mkdir$2;
    return_value_mkdir$2=mkdir(buffer, mode);
    if(return_value_mkdir$2 == -1)
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 17))
      {
        motion_log(3, (unsigned int)9, 1, "%s: Problem creating directory %s", (const void *)"create_path", buffer);
        free((void *)buffer);
        return -1;
      }

    }

    start=strchr(start + (signed long int)1, 47);
    if(start == ((char *)NULL))
      motion_log(5, (unsigned int)9, 0, "%s: creating directory %s", (const void *)"create_path", buffer);

    free((void *)buffer);
  }
  return 0;
}

// decode_jpeg_gray_raw
// file jpegutils.c line 768
signed int decode_jpeg_gray_raw(unsigned char *jpeg_data, signed int len, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2)
{
  signed int numfields;
  signed int hsf[3l];
  signed int field;
  signed int yl;
  signed int yc;
  signed int xsl;
  signed int xsc;
  signed int xs;
  signed int xd;
  signed int hdown;
  unsigned int x;
  unsigned int y;
  unsigned int vsf[3l];
  unsigned char *row0[16l] = { buf0[(signed long int)0], buf0[(signed long int)1], buf0[(signed long int)2], buf0[(signed long int)3], buf0[(signed long int)4], buf0[(signed long int)5], buf0[(signed long int)6], buf0[(signed long int)7], buf0[(signed long int)8], buf0[(signed long int)9], buf0[(signed long int)10], buf0[(signed long int)11], buf0[(signed long int)12], buf0[(signed long int)13], buf0[(signed long int)14], buf0[(signed long int)15] };
  unsigned char **scanarray[3l] = { row0, ((unsigned char **)NULL), ((unsigned char **)NULL) };
  struct jpeg_decompress_struct dinfo;
  struct my_error_mgr jerr;
  dinfo.err=jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(jerr.setjmp_buffer);
  if(!(return_value__setjmp$1 == 0))
  {
    jpeg_destroy_decompress(&dinfo);
    return -1;
  }

  else
  {
    jpeg_CreateDecompress(&dinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
    jpeg_buffer_src(&dinfo, jpeg_data, (signed long int)len);
    jpeg_read_header(&dinfo, 1);
    dinfo.raw_data_out = 1;
    dinfo.out_color_space = (enum anonymous$10)JCS_GRAYSCALE;
    dinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
    if(!((signed int)dinfo.jpeg_color_space == JCS_GRAYSCALE))
      motion_log(3, (unsigned int)9, 0, "%s: Expected grayscale colorspace for JPEG raw decoding", (const void *)"decode_jpeg_gray_raw");

    else
    {
      guarantee_huff_tables(&dinfo);
      jpeg_start_decompress(&dinfo);
      hsf[(signed long int)0] = 1;
      hsf[(signed long int)1] = 1;
      hsf[(signed long int)2] = 1;
      vsf[(signed long int)0] = (unsigned int)1;
      vsf[(signed long int)1] = (unsigned int)1;
      vsf[(signed long int)2] = (unsigned int)1;
      if(dinfo.output_height == height)
        numfields = 1;

      else
        if(2u * dinfo.output_height == height)
          numfields = 2;

        else
        {
          motion_log(3, (unsigned int)9, 0, "%s: Read JPEG: requested height = %d, height of image = %d", (const void *)"decode_jpeg_gray_raw", height, dinfo.output_height);
          goto ERR_EXIT;
        }
      if(dinfo.output_width >= 4097u)
        motion_log(3, (unsigned int)9, 0, "%s: Image width of %d exceeds max", (const void *)"decode_jpeg_gray_raw", dinfo.output_width);

      else
      {
        if(!(width >= (2u * dinfo.output_width) / 3u))
        {
          hdown = 1;
          if(!(2u * width >= dinfo.output_width))
            xsl = (signed int)((dinfo.output_width - (unsigned int)2 * width) / (unsigned int)2);

          else
            xsl = 0;
        }

        else
          if(width == (2u * dinfo.output_width) / 3u)
          {
            hdown = 2;
            xsl = 0;
          }

          else
          {
            hdown = 0;
            if(!(width >= dinfo.output_width))
              xsl = (signed int)((dinfo.output_width - width) / (unsigned int)2);

            else
              xsl = 0;
          }
        xsl = xsl & ~1;
        xsc = xsl / 2;
        yc = 0;
        yl = yc;
        field = 0;
        for( ; !(field >= numfields); field = field + 1)
        {
          if(field >= 1)
          {
            jpeg_read_header(&dinfo, 1);
            dinfo.raw_data_out = 1;
            dinfo.out_color_space = (enum anonymous$10)JCS_GRAYSCALE;
            dinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
            jpeg_start_decompress(&dinfo);
          }

          if(numfields == 2)
            switch(itype)
            {
              case 1:
              {
                yc = field;
                yl = yc;
                break;
              }
              case 2:
              {
                yc = 1 - field;
                yl = yc;
                break;
              }
              default:
              {
                motion_log(3, (unsigned int)9, 0, "%s: Input is interlaced but no interlacing set", (const void *)"decode_jpeg_gray_raw");
                goto ERR_EXIT;
              }
            }

          else
          {
            yc = 0;
            yl = yc;
          }
          while(!(dinfo.output_scanline >= dinfo.output_height))
          {
            jpeg_read_raw_data(&dinfo, scanarray, (unsigned int)16);
            y = (unsigned int)0;
            for( ; !(y >= 8u * vsf[0l]); y = y + 1u)
            {
              xd = (signed int)((unsigned int)yl * width);
              xs = xsl;
              if(hdown == 0)
              {
                x = (unsigned int)0;
                for( ; !(x >= width); x = x + 1u)
                {
                  signed int tmp_post$2 = xd;
                  xd = xd + 1;
                  signed int tmp_post$3 = xs;
                  xs = xs + 1;
                  raw0[(signed long int)tmp_post$2] = row0[(signed long int)y][(signed long int)tmp_post$3];
                }
              }

              else
                if(hdown == 1)
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width); xs = xs + 2)
                  {
                    signed int tmp_post$4 = xd;
                    xd = xd + 1;
                    raw0[(signed long int)tmp_post$4] = (unsigned char)((signed int)row0[(signed long int)y][(signed long int)xs] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)] >> 1);
                    x = x + 1u;
                  }
                }

                else
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xs = xs + 3)
                  {
                    raw0[(signed long int)xd] = (unsigned char)((2 * (signed int)row0[(signed long int)y][(signed long int)xs] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                    raw0[(signed long int)(xd + 1)] = (unsigned char)((2 * (signed int)row0[(signed long int)y][(signed long int)(xs + 2)] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                    x = x + 1u;
                    xd = xd + 2;
                  }
                }
              yl = yl + numfields;
            }
            y = (unsigned int)0;
            for( ; !(y >= 8u); y = y + 1u)
            {
              xs = xsc;
              if(hdown == 0)
              {
                x = (unsigned int)0;
                for( ; !(x >= width / 2u); xs = xs + 1)
                {
                  chr1[(signed long int)y][(signed long int)x] = (unsigned char)0;
                  chr2[(signed long int)y][(signed long int)x] = (unsigned char)0;
                  x = x + 1u;
                }
              }

              else
                if(hdown == 1)
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xs = xs + 2)
                  {
                    chr1[(signed long int)y][(signed long int)x] = (unsigned char)0;
                    chr2[(signed long int)y][(signed long int)x] = (unsigned char)0;
                    x = x + 1u;
                  }
                }

                else
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xs = xs + 3)
                  {
                    chr1[(signed long int)y][(signed long int)x] = (unsigned char)0;
                    chr1[(signed long int)y][(signed long int)(x + (unsigned int)1)] = (unsigned char)0;
                    chr2[(signed long int)y][(signed long int)x] = (unsigned char)0;
                    chr2[(signed long int)y][(signed long int)(x + (unsigned int)1)] = (unsigned char)0;
                    x = x + (unsigned int)2;
                  }
                }
            }
            if(ctype == 4)
            {
              if(vsf[0l] == 1u)
              {
                y = (unsigned int)0;
                for( ; !(y >= 8u); yc = yc + numfields)
                {
                  xd = (signed int)(((unsigned int)yc * width) / (unsigned int)2);
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xd = xd + 1)
                  {
                    raw1[(signed long int)xd] = (unsigned char)127;
                    raw2[(signed long int)xd] = (unsigned char)127;
                    x = x + 1u;
                  }
                  y = y + 1u;
                }
              }

              else
              {
                y = (unsigned int)0;
                for( ; !(y >= 8u); y = y + 1u)
                {
                  xd = (signed int)(((unsigned int)yc * width) / (unsigned int)2);
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xd = xd + 1)
                  {
                    raw1[(signed long int)xd] = (unsigned char)127;
                    raw2[(signed long int)xd] = (unsigned char)127;
                    x = x + 1u;
                  }
                  yc = yc + numfields;
                  xd = (signed int)(((unsigned int)yc * width) / (unsigned int)2);
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xd = xd + 1)
                  {
                    raw1[(signed long int)xd] = (unsigned char)127;
                    raw2[(signed long int)xd] = (unsigned char)127;
                    x = x + 1u;
                  }
                  yc = yc + numfields;
                }
              }
              continue;
            }

            if(vsf[0l] == 1u)
            {
              y = (unsigned int)0;
              for( ; !(y >= 8u); yc = yc + numfields)
              {
                xd = (signed int)(((unsigned int)yc * width) / (unsigned int)2);
                x = (unsigned int)0;
                for( ; !(x >= width / 2u); xd = xd + 1)
                {
                  raw1[(signed long int)xd] = (unsigned char)127;
                  raw2[(signed long int)xd] = (unsigned char)127;
                  x = x + 1u;
                }
                y = y + (unsigned int)2;
              }
            }

            else
            {
              y = (unsigned int)0;
              for( ; !(y >= 8u); yc = yc + numfields)
              {
                xd = (signed int)(((unsigned int)yc * width) / (unsigned int)2);
                x = (unsigned int)0;
                for( ; !(x >= width / 2u); xd = xd + 1)
                {
                  raw1[(signed long int)xd] = (unsigned char)127;
                  raw2[(signed long int)xd] = (unsigned char)127;
                  x = x + 1u;
                }
                y = y + 1u;
              }
            }
          }
          jpeg_finish_decompress(&dinfo);
          if(field == 0 && numfields >= 2)
            jpeg_skip_ff(&dinfo);

        }
        jpeg_destroy_decompress(&dinfo);
        return 0;
      }
    }

  ERR_EXIT:
    ;
    jpeg_destroy_decompress(&dinfo);
    return -1;
  }
}

// decode_jpeg_raw
// file jpegutils.c line 442
signed int decode_jpeg_raw(unsigned char *jpeg_data, signed int len, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2)
{
  signed int numfields;
  signed int hsf[3l];
  signed int field;
  signed int yl;
  signed int yc;
  signed int i;
  signed int xsl;
  signed int xsc;
  signed int xs;
  signed int hdown;
  unsigned int x;
  unsigned int y = (unsigned int)0;
  unsigned int vsf[3l];
  unsigned int xd;
  unsigned char *row0[16l] = { buf0[(signed long int)0], buf0[(signed long int)1], buf0[(signed long int)2], buf0[(signed long int)3], buf0[(signed long int)4], buf0[(signed long int)5], buf0[(signed long int)6], buf0[(signed long int)7], buf0[(signed long int)8], buf0[(signed long int)9], buf0[(signed long int)10], buf0[(signed long int)11], buf0[(signed long int)12], buf0[(signed long int)13], buf0[(signed long int)14], buf0[(signed long int)15] };
  unsigned char *row1[8l] = { buf1[(signed long int)0], buf1[(signed long int)1], buf1[(signed long int)2], buf1[(signed long int)3], buf1[(signed long int)4], buf1[(signed long int)5], buf1[(signed long int)6], buf1[(signed long int)7] };
  unsigned char *row2[16l] = { buf2[(signed long int)0], buf2[(signed long int)1], buf2[(signed long int)2], buf2[(signed long int)3], buf2[(signed long int)4], buf2[(signed long int)5], buf2[(signed long int)6], buf2[(signed long int)7], ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL), ((unsigned char *)NULL) };
  unsigned char *row1_444[16l];
  unsigned char *row2_444[16l];
  unsigned char **scanarray[3l] = { row0, row1, row2 };
  struct jpeg_decompress_struct dinfo;
  struct my_error_mgr jerr;
  dinfo.err=jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  jerr.original_emit_message = jerr.pub.emit_message;
  jerr.pub.emit_message = my_emit_message;
  jerr.warning_seen = 0;
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(jerr.setjmp_buffer);
  _Bool tmp_if_expr$5;
  if(!(return_value__setjmp$1 == 0))
  {
    jpeg_destroy_decompress(&dinfo);
    return -1;
  }

  else
  {
    jpeg_CreateDecompress(&dinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
    jpeg_buffer_src(&dinfo, jpeg_data, (signed long int)len);
    jpeg_read_header(&dinfo, 1);
    dinfo.raw_data_out = 1;
    dinfo.out_color_space = (enum anonymous$10)JCS_YCbCr;
    dinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
    guarantee_huff_tables(&dinfo);
    jpeg_start_decompress(&dinfo);
    if(!(dinfo.output_components == 3))
      motion_log(3, (unsigned int)9, 0, "%s: Output components of JPEG image = %d, must be 3", (const void *)"decode_jpeg_raw", dinfo.output_components);

    else
    {
      i = 0;
      for( ; !(i >= 3); i = i + 1)
      {
        hsf[(signed long int)i] = (dinfo.comp_info + (signed long int)i)->h_samp_factor;
        vsf[(signed long int)i] = (unsigned int)(dinfo.comp_info + (signed long int)i)->v_samp_factor;
      }
      _Bool tmp_if_expr$2;
      if(!(hsf[0l] == 2))
        tmp_if_expr$2 = hsf[(signed long int)0] != 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = hsf[(signed long int)1] != 1 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = hsf[(signed long int)2] != 1 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$6;
      if(tmp_if_expr$4)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        if(!(vsf[0l] == 1u))
          tmp_if_expr$5 = vsf[(signed long int)0] != (unsigned int)2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$7;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = vsf[(signed long int)1] != (unsigned int)1 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$8;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = vsf[(signed long int)2] != (unsigned int)1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        motion_log(3, (unsigned int)9, 0, "%s: Unsupported sampling factors, hsf=(%d, %d, %d) vsf=(%d, %d, %d) !", (const void *)"decode_jpeg_raw", hsf[(signed long int)0], hsf[(signed long int)1], hsf[(signed long int)2], vsf[(signed long int)0], vsf[(signed long int)1], vsf[(signed long int)2]);

      else
      {
        if(hsf[0l] == 1)
        {
          if(!(height % 8u == 0u))
          {
            motion_log(3, (unsigned int)9, 0, "%s: YUV 4:4:4 sampling, but image height %d not dividable by 8 !", (const void *)"decode_jpeg_raw", height);
            goto ERR_EXIT;
          }

          y = (unsigned int)0;
          for( ; !(y >= 16u); y = y + 1u)
          {
            void *return_value_malloc$9;
            return_value_malloc$9=malloc((unsigned long int)dinfo.output_width * sizeof(char) /*1ul*/ );
            row1_444[(signed long int)y] = (unsigned char *)return_value_malloc$9;
            void *return_value_malloc$10;
            return_value_malloc$10=malloc((unsigned long int)dinfo.output_width * sizeof(char) /*1ul*/ );
            row2_444[(signed long int)y] = (unsigned char *)return_value_malloc$10;
          }
          scanarray[(signed long int)1] = row1_444;
          scanarray[(signed long int)2] = row2_444;
        }

        if(dinfo.output_height == height)
          numfields = 1;

        else
          if(2u * dinfo.output_height == height)
            numfields = 2;

          else
          {
            motion_log(3, (unsigned int)9, 0, "%s: Read JPEG: requested height = %d, height of image = %d", (const void *)"decode_jpeg_raw", height, dinfo.output_height);
            goto ERR_EXIT;
          }
        if(dinfo.output_width >= 4097u)
          motion_log(3, (unsigned int)9, 0, "%s: Image width of %d exceeds max", (const void *)"decode_jpeg_raw", dinfo.output_width);

        else
        {
          if(!(width >= (2u * dinfo.output_width) / 3u))
          {
            hdown = 1;
            if(!(2u * width >= dinfo.output_width))
              xsl = (signed int)((dinfo.output_width - (unsigned int)2 * width) / (unsigned int)2);

            else
              xsl = 0;
          }

          else
            if(width == (2u * dinfo.output_width) / 3u)
            {
              hdown = 2;
              xsl = 0;
            }

            else
            {
              hdown = 0;
              if(!(width >= dinfo.output_width))
                xsl = (signed int)((dinfo.output_width - width) / (unsigned int)2);

              else
                xsl = 0;
            }
          xsl = xsl & ~1;
          xsc = xsl / 2;
          yc = 0;
          yl = yc;
          field = 0;
          for( ; !(field >= numfields); field = field + 1)
          {
            if(field >= 1)
            {
              jpeg_read_header(&dinfo, 1);
              dinfo.raw_data_out = 1;
              dinfo.out_color_space = (enum anonymous$10)JCS_YCbCr;
              dinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
              jpeg_start_decompress(&dinfo);
            }

            if(numfields == 2)
              switch(itype)
              {
                case 1:
                {
                  yc = field;
                  yl = yc;
                  break;
                }
                case 2:
                {
                  yc = 1 - field;
                  yl = yc;
                  break;
                }
                default:
                {
                  motion_log(3, (unsigned int)9, 0, "%s: Input is interlaced but no interlacing set", (const void *)"decode_jpeg_raw");
                  goto ERR_EXIT;
                }
              }

            else
            {
              yc = 0;
              yl = yc;
            }
            while(!(dinfo.output_scanline >= dinfo.output_height))
            {
              jpeg_read_raw_data(&dinfo, scanarray, (unsigned int)8 * vsf[(signed long int)0]);
              y = (unsigned int)0;
              for( ; !(y >= 8u * vsf[0l]); y = y + 1u)
              {
                xd = (unsigned int)yl * width;
                xs = xsl;
                if(hdown == 0)
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width); x = x + 1u)
                  {
                    unsigned int tmp_post$11 = xd;
                    xd = xd + 1u;
                    signed int tmp_post$12 = xs;
                    xs = xs + 1;
                    raw0[(signed long int)tmp_post$11] = row0[(signed long int)y][(signed long int)tmp_post$12];
                  }
                }

                else
                  if(hdown == 1)
                  {
                    x = (unsigned int)0;
                    for( ; !(x >= width); xs = xs + 2)
                    {
                      unsigned int tmp_post$13 = xd;
                      xd = xd + 1u;
                      raw0[(signed long int)tmp_post$13] = (unsigned char)((signed int)row0[(signed long int)y][(signed long int)xs] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)] >> 1);
                      x = x + 1u;
                    }
                  }

                  else
                  {
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xs = xs + 3)
                    {
                      raw0[(signed long int)xd] = (unsigned char)((2 * (signed int)row0[(signed long int)y][(signed long int)xs] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      raw0[(signed long int)(xd + (unsigned int)1)] = (unsigned char)((2 * (signed int)row0[(signed long int)y][(signed long int)(xs + 2)] + (signed int)row0[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      x = x + 1u;
                      xd = xd + (unsigned int)2;
                    }
                  }
                yl = yl + numfields;
              }
              y = (unsigned int)0;
              for( ; !(y >= 8u); y = y + 1u)
              {
                xs = xsc;
                if(hsf[0l] == 1)
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xs = xs + 1)
                  {
                    row1[(signed long int)y][(signed long int)xs] = (unsigned char)((signed int)row1_444[(signed long int)y][(signed long int)((unsigned int)2 * x)] + (signed int)row1_444[(signed long int)y][(signed long int)((unsigned int)2 * x + (unsigned int)1)] >> 1);
                    row2[(signed long int)y][(signed long int)xs] = (unsigned char)((signed int)row2_444[(signed long int)y][(signed long int)((unsigned int)2 * x)] + (signed int)row2_444[(signed long int)y][(signed long int)((unsigned int)2 * x + (unsigned int)1)] >> 1);
                    x = x + 1u;
                  }
                }

                xs = xsc;
                if(hdown == 0)
                {
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xs = xs + 1)
                  {
                    chr1[(signed long int)y][(signed long int)x] = row1[(signed long int)y][(signed long int)xs];
                    chr2[(signed long int)y][(signed long int)x] = row2[(signed long int)y][(signed long int)xs];
                    x = x + 1u;
                  }
                }

                else
                  if(hdown == 1)
                  {
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xs = xs + 2)
                    {
                      chr1[(signed long int)y][(signed long int)x] = (unsigned char)((signed int)row1[(signed long int)y][(signed long int)xs] + (signed int)row1[(signed long int)y][(signed long int)(xs + 1)] >> 1);
                      chr2[(signed long int)y][(signed long int)x] = (unsigned char)((signed int)row2[(signed long int)y][(signed long int)xs] + (signed int)row2[(signed long int)y][(signed long int)(xs + 1)] >> 1);
                      x = x + 1u;
                    }
                  }

                  else
                  {
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xs = xs + 3)
                    {
                      chr1[(signed long int)y][(signed long int)x] = (unsigned char)((2 * (signed int)row1[(signed long int)y][(signed long int)xs] + (signed int)row1[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      chr1[(signed long int)y][(signed long int)(x + (unsigned int)1)] = (unsigned char)((2 * (signed int)row1[(signed long int)y][(signed long int)(xs + 2)] + (signed int)row1[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      chr2[(signed long int)y][(signed long int)x] = (unsigned char)((2 * (signed int)row2[(signed long int)y][(signed long int)xs] + (signed int)row2[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      chr2[(signed long int)y][(signed long int)(x + (unsigned int)1)] = (unsigned char)((2 * (signed int)row2[(signed long int)y][(signed long int)(xs + 2)] + (signed int)row2[(signed long int)y][(signed long int)(xs + 1)]) / 3);
                      x = x + (unsigned int)2;
                    }
                  }
              }
              if(ctype == 4)
              {
                if(vsf[0l] == 1u)
                {
                  y = (unsigned int)0;
                  for( ; !(y >= 8u); yc = yc + numfields)
                  {
                    xd = ((unsigned int)yc * width) / (unsigned int)2;
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xd = xd + 1u)
                    {
                      raw1[(signed long int)xd] = chr1[(signed long int)y][(signed long int)x];
                      raw2[(signed long int)xd] = chr2[(signed long int)y][(signed long int)x];
                      x = x + 1u;
                    }
                    y = y + 1u;
                  }
                }

                else
                {
                  y = (unsigned int)0;
                  for( ; !(y >= 8u); y = y + 1u)
                  {
                    xd = ((unsigned int)yc * width) / (unsigned int)2;
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xd = xd + 1u)
                    {
                      raw1[(signed long int)xd] = chr1[(signed long int)y][(signed long int)x];
                      raw2[(signed long int)xd] = chr2[(signed long int)y][(signed long int)x];
                      x = x + 1u;
                    }
                    yc = yc + numfields;
                    xd = ((unsigned int)yc * width) / (unsigned int)2;
                    x = (unsigned int)0;
                    for( ; !(x >= width / 2u); xd = xd + 1u)
                    {
                      raw1[(signed long int)xd] = chr1[(signed long int)y][(signed long int)x];
                      raw2[(signed long int)xd] = chr2[(signed long int)y][(signed long int)x];
                      x = x + 1u;
                    }
                    yc = yc + numfields;
                  }
                }
                continue;
              }

              if(vsf[0l] == 1u)
              {
                y = (unsigned int)0;
                for( ; !(y >= 8u); yc = yc + numfields)
                {
                  xd = ((unsigned int)yc * width) / (unsigned int)2;
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xd = xd + 1u)
                  {
                    /* assertion xd < (width * height / 4) */
                    assert(xd < (width * height) / (unsigned int)4);
                    raw1[(signed long int)xd] = (unsigned char)((signed int)chr1[(signed long int)y][(signed long int)x] + (signed int)chr1[(signed long int)(y + (unsigned int)1)][(signed long int)x] >> 1);
                    raw2[(signed long int)xd] = (unsigned char)((signed int)chr2[(signed long int)y][(signed long int)x] + (signed int)chr2[(signed long int)(y + (unsigned int)1)][(signed long int)x] >> 1);
                    x = x + 1u;
                  }
                  y = y + (unsigned int)2;
                }
              }

              else
              {
                y = (unsigned int)0;
                for( ; !(y >= 8u); yc = yc + numfields)
                {
                  xd = ((unsigned int)yc * width) / (unsigned int)2;
                  x = (unsigned int)0;
                  for( ; !(x >= width / 2u); xd = xd + 1u)
                  {
                    raw1[(signed long int)xd] = chr1[(signed long int)y][(signed long int)x];
                    raw2[(signed long int)xd] = chr2[(signed long int)y][(signed long int)x];
                    x = x + 1u;
                  }
                  y = y + 1u;
                }
              }
            }
            jpeg_finish_decompress(&dinfo);
            if(field == 0 && numfields >= 2)
              jpeg_skip_ff(&dinfo);

          }
          if(hsf[0l] == 1)
          {
            y = (unsigned int)0;
            for( ; !(y >= 16u); y = y + 1u)
            {
              free((void *)row1_444[(signed long int)y]);
              free((void *)row2_444[(signed long int)y]);
            }
          }

          jpeg_destroy_decompress(&dinfo);
          if(!(jerr.warning_seen == 0))
            return 1;

          else
            return 0;
        }
      }
    }

  ERR_EXIT:
    ;
    jpeg_destroy_decompress(&dinfo);
    return -1;
  }
}

// decode_packet
// file netcam_rtsp.c line 54
static signed int decode_packet(struct AVPacket *packet, struct netcam_image_buff *buffer, struct AVFrame *frame, struct AVCodecContext *cc)
{
  signed int check = 0;
  signed int ret;
  ret=avcodec_decode_video2(cc, frame, &check, packet);
  if(!(ret >= 0))
  {
    motion_log(3, (unsigned int)4, 0, "%s: Error decoding video packet", (const void *)"decode_packet");
    return 0;
  }

  else
    if(check == 0)
      return 0;

    else
    {
      signed int frame_size;
      frame_size=av_image_get_buffer_size(cc->pix_fmt, cc->width, cc->height, 1);
      netcam_check_buffsize$link1(buffer, (unsigned long int)frame_size);
      av_image_copy_to_buffer((unsigned char *)buffer->ptr, frame_size, (const unsigned char **)frame->data, frame->linesize, cc->pix_fmt, cc->width, cc->height, 1);
      buffer->used = (unsigned long int)frame_size;
      return frame_size;
    }
}

// delete_filter_graph
// file ffmpeg.c line 1042
static void delete_filter_graph()
{
  if(!(filter_graph == ((struct AVFilterGraph *)NULL)))
  {
    av_frame_free(&filter_frame);
    avfilter_graph_free(&filter_graph);
  }

}

// detection
// file webhttpd.c line 1108
static unsigned int detection(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata)
{
  char command[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct context **cnt = (struct context **)userdata;
  unsigned int i = (unsigned int)0;
  warningkill=sscanf(pointer, "%255[a-z]", (const void *)command);
  signed int return_value_strcmp$10;
  return_value_strcmp$10=strcmp(command, "status");
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  if(return_value_strcmp$10 == 0)
  {
    pointer = pointer + (signed long int)6;
    length_uri = length_uri - (unsigned int)6;
    if(length_uri == 0u)
    {
      if(!((*cnt)->conf.webcontrol_html_output == 0))
      {
        send_template_ini_client(client_socket, ini_template);
        char *tmp_if_expr$1;
        if(cnt[(signed long int)thread]->running == 0u)
          tmp_if_expr$1 = "NOT RUNNING";

        else
          tmp_if_expr$1 = cnt[(signed long int)thread]->pause != 0u ? "PAUSE" : "ACTIVE";
        sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br><b>Thread %hu</b> Detection status %s\n", thread, thread, tmp_if_expr$1);
        send_template(client_socket, res);
        send_template_end_client(client_socket);
      }

      else
      {
        char *tmp_if_expr$2;
        if(cnt[(signed long int)thread]->running == 0u)
          tmp_if_expr$2 = "NOT RUNNING";

        else
          tmp_if_expr$2 = cnt[(signed long int)thread]->pause != 0u ? "PAUSE" : "ACTIVE";
        sprintf(res, "Thread %hu Detection status %s\n", thread, tmp_if_expr$2);
        send_template_ini_client_raw(client_socket);
        send_template_raw(client_socket, res);
      }
    }

    else
      if(!((*cnt)->conf.webcontrol_html_output == 0))
        response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

      else
        response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
  }

  else
  {
    return_value_strcmp$9=strcmp(command, "start");
    if(return_value_strcmp$9 == 0)
    {
      pointer = pointer + (signed long int)5;
      length_uri = length_uri - (unsigned int)5;
      if(length_uri == 0u)
      {
        if(thread == 0u)
          do
          {
            cnt[(signed long int)i]->pause = (unsigned int)0;
            i = i + 1u;
          }
          while(!(cnt[(signed long int)i] == ((struct context *)NULL)));

        else
          cnt[(signed long int)thread]->pause = (unsigned int)0;
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          send_template_ini_client(client_socket, ini_template);
          sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b> Detection resumed\n", thread, thread);
          send_template(client_socket, res);
          send_template_end_client(client_socket);
        }

        else
        {
          send_template_ini_client_raw(client_socket);
          sprintf(res, "Thread %hu Detection resumed\nDone\n", thread);
          send_template_raw(client_socket, res);
        }
      }

      else
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

        else
          response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
    }

    else
    {
      return_value_strcmp$8=strcmp(command, "pause");
      if(return_value_strcmp$8 == 0)
      {
        pointer = pointer + (signed long int)5;
        length_uri = length_uri - (unsigned int)5;
        if(length_uri == 0u)
        {
          if(thread == 0u)
            do
            {
              cnt[(signed long int)i]->pause = (unsigned int)1;
              i = i + 1u;
            }
            while(!(cnt[(signed long int)i] == ((struct context *)NULL)));

          else
            cnt[(signed long int)thread]->pause = (unsigned int)1;
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            send_template_ini_client(client_socket, ini_template);
            sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b> Detection paused\n", thread, thread);
            send_template(client_socket, res);
            send_template_end_client(client_socket);
          }

          else
          {
            send_template_ini_client_raw(client_socket);
            sprintf(res, "<b>Thread %hu</b> Detection paused\nDone\n", thread);
            send_template_raw(client_socket, res);
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }

      else
      {
        return_value_strcmp$7=strcmp(command, "connection");
        if(return_value_strcmp$7 == 0)
        {
          pointer = pointer + (signed long int)10;
          length_uri = length_uri - (unsigned int)10;
          if(length_uri == 0u)
          {
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/detection>&lt;&ndash; back</a><br><br>\n", thread);
              send_template(client_socket, res);
              if(thread == 0u)
                do
                {
                  char *tmp_if_expr$3;
                  if(cnt[(signed long int)i]->running == 0u)
                    tmp_if_expr$3 = "NOT RUNNING";

                  else
                    tmp_if_expr$3 = cnt[(signed long int)i]->lost_connection != 0u ? "Lost connection" : "Connection OK";
                  sprintf(res, "<b>Thread %hu</b> %s<br>\n", i, tmp_if_expr$3);
                  send_template(client_socket, res);
                  i = i + 1u;
                }
                while(!(cnt[(signed long int)i] == ((struct context *)NULL)));

              else
              {
                char *tmp_if_expr$4;
                if(cnt[(signed long int)thread]->running == 0u)
                  tmp_if_expr$4 = "NOT RUNNING";

                else
                  tmp_if_expr$4 = cnt[(signed long int)thread]->lost_connection != 0u ? "Lost connection" : "Connection OK";
                sprintf(res, "<b>Thread %hu</b> %s\n", thread, tmp_if_expr$4);
                send_template(client_socket, res);
              }
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              if(thread == 0u)
                do
                {
                  char *tmp_if_expr$5;
                  if(cnt[(signed long int)i]->running == 0u)
                    tmp_if_expr$5 = "NOT RUNNING";

                  else
                    tmp_if_expr$5 = cnt[(signed long int)i]->lost_connection != 0u ? "Lost connection" : "Connection OK";
                  sprintf(res, "Thread %hu %s\n", i, tmp_if_expr$5);
                  send_template_raw(client_socket, res);
                  i = i + 1u;
                }
                while(!(cnt[(signed long int)i] == ((struct context *)NULL)));

              else
              {
                char *tmp_if_expr$6;
                if(cnt[(signed long int)thread]->running == 0u)
                  tmp_if_expr$6 = "NOT RUNNING";

                else
                  tmp_if_expr$6 = cnt[(signed long int)thread]->lost_connection != 0u ? "Lost connection" : "Connection OK";
                sprintf(res, "Thread %hu %s\n", thread, tmp_if_expr$6);
                send_template_raw(client_socket, res);
              }
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

            else
              response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }
    }
  }
  return (unsigned int)1;
}

// dilate5
// file alg.c line 677
static signed int dilate5(unsigned char *img, signed int width, signed int height, void *buffer)
{
  signed int y;
  signed int i;
  signed int sum = 0;
  unsigned char *row1;
  unsigned char *row2;
  unsigned char *row3;
  unsigned char *rowTemp;
  unsigned char *yp;
  unsigned char blob;
  unsigned char mem;
  unsigned char latest;
  row1 = (unsigned char *)buffer;
  row2 = row1 + (signed long int)width;
  row3 = row2 + (signed long int)width;
  memset((void *)row2, 0, (unsigned long int)width);
  memcpy((void *)row3, (const void *)img, (unsigned long int)width);
  yp = img;
  y = 0;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  for( ; !(y >= height); y = y + 1)
  {
    rowTemp = row1;
    row1 = row2;
    row2 = row3;
    row3 = rowTemp;
    if(y == height + -1)
      memset((void *)row3, 0, (unsigned long int)width);

    else
      memcpy((void *)row3, (const void *)(yp + (signed long int)width), (unsigned long int)width);
    signed int tmp_if_expr$1;
    if(!((signed int)row2[1l] >= (signed int)*row2))
      tmp_if_expr$1 = (signed int)row2[(signed long int)0];

    else
      tmp_if_expr$1 = (signed int)row2[(signed long int)1];
    mem = (unsigned char)tmp_if_expr$1;
    blob = (unsigned char)1;
    i = 1;
    for( ; !(i >= width + -1); i = i + 1)
    {
      signed int tmp_if_expr$4;
      if(!((signed int)row2[(signed long int)(1 + i)] >= (signed int)row1[(signed long int)i]))
      {
        if(!((signed int)row3[(signed long int)i] >= (signed int)row1[(signed long int)i]))
          tmp_if_expr$2 = (signed int)row1[(signed long int)i];

        else
          tmp_if_expr$2 = (signed int)row3[(signed long int)i];
        tmp_if_expr$4 = tmp_if_expr$2;
      }

      else
      {
        if(!((signed int)row3[(signed long int)i] >= (signed int)row2[(signed long int)(1 + i)]))
          tmp_if_expr$3 = (signed int)row2[(signed long int)(i + 1)];

        else
          tmp_if_expr$3 = (signed int)row3[(signed long int)i];
        tmp_if_expr$4 = tmp_if_expr$3;
      }
      latest = (unsigned char)tmp_if_expr$4;
      if((signed int)blob == 0)
      {
        blob = latest;
        mem = row2[(signed long int)(i + 1)];
      }

      else
      {
        blob = (unsigned char)((signed int)mem > (signed int)latest ? (signed int)mem : (signed int)latest);
        signed int tmp_if_expr$5;
        if(!((signed int)row2[(signed long int)(1 + i)] >= (signed int)row2[(signed long int)i]))
          tmp_if_expr$5 = (signed int)row2[(signed long int)i];

        else
          tmp_if_expr$5 = (signed int)row2[(signed long int)(i + 1)];
        mem = (unsigned char)tmp_if_expr$5;
      }
      if(!((signed int)blob == 0))
      {
        yp[(signed long int)i] = blob;
        sum = sum + 1;
      }

    }
    *((yp + (signed long int)width) - (signed long int)1) = (unsigned char)0;
    *yp = *((yp + (signed long int)width) - (signed long int)1);
    yp = yp + (signed long int)width;
  }
  return sum;
}

// dilate9
// file alg.c line 590
static signed int dilate9(unsigned char *img, signed int width, signed int height, void *buffer)
{
  signed int y;
  signed int i;
  signed int sum = 0;
  signed int widx;
  unsigned char *row1;
  unsigned char *row2;
  unsigned char *row3;
  unsigned char *rowTemp;
  unsigned char *yp;
  unsigned char window[3l];
  unsigned char blob;
  unsigned char latest;
  row1 = (unsigned char *)buffer;
  row2 = row1 + (signed long int)width;
  row3 = row2 + (signed long int)width;
  memset((void *)row2, 0, (unsigned long int)width);
  memcpy((void *)row3, (const void *)img, (unsigned long int)width);
  yp = img;
  y = 0;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$11;
  signed int tmp_if_expr$12;
  for( ; !(y >= height); y = y + 1)
  {
    rowTemp = row1;
    row1 = row2;
    row2 = row3;
    row3 = rowTemp;
    if(y == height + -1)
      memset((void *)row3, 0, (unsigned long int)width);

    else
      memcpy((void *)row3, (const void *)(yp + (signed long int)width), (unsigned long int)width);
    signed int tmp_if_expr$3;
    if(!((signed int)*row2 >= (signed int)*row1))
    {
      if(!((signed int)*row3 >= (signed int)*row1))
        tmp_if_expr$1 = (signed int)row1[(signed long int)0];

      else
        tmp_if_expr$1 = (signed int)row3[(signed long int)0];
      tmp_if_expr$3 = tmp_if_expr$1;
    }

    else
    {
      if(!((signed int)*row3 >= (signed int)*row2))
        tmp_if_expr$2 = (signed int)row2[(signed long int)0];

      else
        tmp_if_expr$2 = (signed int)row3[(signed long int)0];
      tmp_if_expr$3 = tmp_if_expr$2;
    }
    window[(signed long int)0] = (unsigned char)tmp_if_expr$3;
    signed int tmp_if_expr$6;
    if(!((signed int)row2[1l] >= (signed int)row1[1l]))
    {
      if(!((signed int)row3[1l] >= (signed int)row1[1l]))
        tmp_if_expr$4 = (signed int)row1[(signed long int)1];

      else
        tmp_if_expr$4 = (signed int)row3[(signed long int)1];
      tmp_if_expr$6 = tmp_if_expr$4;
    }

    else
    {
      if(!((signed int)row3[1l] >= (signed int)row2[1l]))
        tmp_if_expr$5 = (signed int)row2[(signed long int)1];

      else
        tmp_if_expr$5 = (signed int)row3[(signed long int)1];
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    window[(signed long int)1] = (unsigned char)tmp_if_expr$6;
    signed int tmp_if_expr$7;
    if(!((signed int)window[1l] >= (signed int)window[0l]))
      tmp_if_expr$7 = (signed int)window[(signed long int)0];

    else
      tmp_if_expr$7 = (signed int)window[(signed long int)1];
    blob = (unsigned char)tmp_if_expr$7;
    widx = 2;
    i = 2;
    for( ; width + -1 >= i; i = i + 1)
    {
      signed int tmp_if_expr$10;
      if(!((signed int)row2[(signed long int)i] >= (signed int)row1[(signed long int)i]))
      {
        if(!((signed int)row3[(signed long int)i] >= (signed int)row1[(signed long int)i]))
          tmp_if_expr$8 = (signed int)row1[(signed long int)i];

        else
          tmp_if_expr$8 = (signed int)row3[(signed long int)i];
        tmp_if_expr$10 = tmp_if_expr$8;
      }

      else
      {
        if(!((signed int)row3[(signed long int)i] >= (signed int)row2[(signed long int)i]))
          tmp_if_expr$9 = (signed int)row2[(signed long int)i];

        else
          tmp_if_expr$9 = (signed int)row3[(signed long int)i];
        tmp_if_expr$10 = tmp_if_expr$9;
      }
      window[(signed long int)widx] = (unsigned char)tmp_if_expr$10;
      latest = window[(signed long int)widx];
      if((signed int)latest >= (signed int)blob)
        blob = latest;

      else
      {
        signed int tmp_if_expr$13;
        if(!((signed int)window[1l] >= (signed int)window[0l]))
        {
          if(!((signed int)window[2l] >= (signed int)window[0l]))
            tmp_if_expr$11 = (signed int)window[(signed long int)0];

          else
            tmp_if_expr$11 = (signed int)window[(signed long int)2];
          tmp_if_expr$13 = tmp_if_expr$11;
        }

        else
        {
          if(!((signed int)window[2l] >= (signed int)window[1l]))
            tmp_if_expr$12 = (signed int)window[(signed long int)1];

          else
            tmp_if_expr$12 = (signed int)window[(signed long int)2];
          tmp_if_expr$13 = tmp_if_expr$12;
        }
        blob = (unsigned char)tmp_if_expr$13;
      }
      if(!((signed int)blob == 0))
      {
        *((yp + (signed long int)i) - (signed long int)1) = blob;
        sum = sum + 1;
      }

      widx = widx + 1;
      if(widx == 3)
        widx = 0;

    }
    *((yp + (signed long int)width) - (signed long int)1) = (unsigned char)0;
    *yp = *((yp + (signed long int)width) - (signed long int)1);
    yp = yp + (signed long int)width;
  }
  return sum;
}

// do_client_auth
// file stream.c line 628
static void do_client_auth(struct context *cnt, signed int sc)
{
  unsigned long int thread_id;
  union pthread_attr_t attr;
  void * (*handle_func)(void *);
  struct auth_param *handle_param = (struct auth_param *)(void *)0;
  signed int flags;
  static signed int first_call = 0;
  if(first_call == 0)
  {
    first_call = 1;
    pthread_mutex_init(&stream_auth_mutex, (const union anonymous$31 *)(void *)0);
  }

  switch(cnt->conf.stream_auth_method)
  {
    case 1:
    {
      handle_func = handle_basic_auth;
      break;
    }
    case 2:
    {
      handle_func = handle_md5_digest;
      break;
    }
    default:
    {
      motion_log(3, (unsigned int)2, 1, "%s: Error unknown stream authentication method", (const void *)"do_client_auth");
      goto Error;
    }
  }
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct auth_param) /*32ul*/ );
  handle_param = (struct auth_param *)return_value_mymalloc$1;
  handle_param->cnt = cnt;
  handle_param->sock = sc;
  handle_param->conf = &cnt->conf;
  static signed int thread_count = 0;
  handle_param->thread_count = &thread_count;
  flags=fcntl(sc, 3, 0);
  signed int return_value_fcntl$2;
  signed int return_value_pthread_attr_init$3;
  signed int return_value_pthread_create$4;
  signed int return_value_pthread_attr_destroy$5;
  if(!(flags >= 0))
    motion_log(3, (unsigned int)2, 1, "%s: fcntl", (const void *)"do_client_auth");

  else
  {
    handle_param->sock_flags = flags;
    return_value_fcntl$2=fcntl(sc, 4, flags & ~04000);
    if(!(return_value_fcntl$2 >= 0))
      motion_log(3, (unsigned int)2, 1, "%s: fcntl", (const void *)"do_client_auth");

    else
      if(!(thread_count >= 10))
      {
        return_value_pthread_attr_init$3=pthread_attr_init(&attr);
        if(!(return_value_pthread_attr_init$3 == 0))
          motion_log(3, (unsigned int)2, 1, "%s: Error pthread_attr_init", (const void *)"do_client_auth");

        else
        {
          return_value_pthread_create$4=pthread_create(&thread_id, &attr, handle_func, (void *)handle_param);
          if(!(return_value_pthread_create$4 == 0))
            motion_log(3, (unsigned int)2, 1, "%s: Error pthread_create", (const void *)"do_client_auth");

          else
          {
            pthread_detach(thread_id);
            return_value_pthread_attr_destroy$5=pthread_attr_destroy(&attr);
            if(!(return_value_pthread_attr_destroy$5 == 0))
              motion_log(3, (unsigned int)2, 1, "%s: Error pthread_attr_destroy", (const void *)"do_client_auth");

            goto __CPROVER_DUMP_L13;
          }
        }
      }

  }

Error:
  ;
  close(sc);
  if(!(handle_param == ((struct auth_param *)NULL)))
    free((void *)handle_param);


__CPROVER_DUMP_L13:
  ;
}

// draw_text
// file motion.h line 281
signed int draw_text(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, unsigned int factor)
{
  signed int num_nl = 0;
  const char *end;
  const char *begin;
  const signed int line_space = (const signed int)((factor + (unsigned int)1) * (unsigned int)9);
  end = text;
  do
  {
    end=strstr(end, "\\n");
    if(end == ((const char *)NULL))
      break;

    num_nl = num_nl + 1;
    end = end + (signed long int)(sizeof(char [3l]) /*3ul*/  - (unsigned long int)1);
  }
  while((_Bool)1);
  starty = starty - (unsigned int)(line_space * num_nl);
  end = text;
  begin = end;
  do
  {
    end=strstr(end, "\\n");
    if(end == ((const char *)NULL))
      break;

    signed int len = (signed int)(end - begin);
    draw_textn(image, startx, starty, width, begin, len, factor);
    end = end + (signed long int)(sizeof(char [3l]) /*3ul*/  - (unsigned long int)1);
    begin = end;
    starty = starty + (unsigned int)line_space;
  }
  while((_Bool)1);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(begin);
  draw_textn(image, startx, starty, width, begin, (signed int)return_value_strlen$1, factor);
  return 0;
}

// draw_textn
// file draw.c line 1081
static signed int draw_textn(unsigned char *image, unsigned int startx, unsigned int starty, unsigned int width, const char *text, signed int len, unsigned int factor)
{
  signed int pos;
  signed int x;
  signed int y;
  signed int line_offset;
  signed int next_char_offs;
  unsigned char *image_ptr;
  unsigned char *char_ptr;
  unsigned char **char_arr_ptr;
  if(!(width / 2u >= startx))
    startx = startx - (unsigned int)len * (unsigned int)6 * (factor + (unsigned int)1);

  if((1u + factor) * 6u * (unsigned int)len + startx >= width)
    len = (signed int)(((width - startx) - (unsigned int)1) / ((unsigned int)6 * (factor + (unsigned int)1)));

  line_offset = (signed int)(width - (unsigned int)7 * (factor + (unsigned int)1));
  next_char_offs = (signed int)(width * (unsigned int)8 * (factor + (unsigned int)1) - (unsigned int)6 * (factor + (unsigned int)1));
  image_ptr = image + (signed long int)startx + (signed long int)(starty * width);
  unsigned char **tmp_if_expr$1;
  if(!(factor == 0u))
    tmp_if_expr$1 = big_char_arr_ptr;

  else
    tmp_if_expr$1 = small_char_arr_ptr;
  char_arr_ptr = tmp_if_expr$1;
  pos = 0;
  signed int tmp_post$2;
  signed int tmp_post$3;
  for( ; !(pos >= len); pos = pos + 1)
  {
    signed int pos_check = (signed int)text[(signed long int)pos];
    char_ptr = char_arr_ptr[(signed long int)pos_check];
    y = (signed int)((unsigned int)8 * (factor + (unsigned int)1));
    do
    {
      tmp_post$2 = y;
      y = y - 1;
      if(tmp_post$2 == 0)
        break;

      x = (signed int)((unsigned int)7 * (factor + (unsigned int)1));
      do
      {
        tmp_post$3 = x;
        x = x - 1;
        if(tmp_post$3 == 0)
          break;

        if(!(pos_check >= 0))
        {
          image_ptr = image_ptr + 1l;
          char_ptr = char_ptr + 1l;
        }

        else
        {
          switch((signed int)*char_ptr)
          {
            case 1:
            {
              *image_ptr = (unsigned char)0;
              break;
            }
            case 2:
              *image_ptr = (unsigned char)255;
          }
          image_ptr = image_ptr + 1l;
          char_ptr = char_ptr + 1l;
        }
      }
      while((_Bool)1);
      image_ptr = image_ptr + (signed long int)line_offset;
    }
    while((_Bool)1);
    image_ptr = image_ptr - (signed long int)next_char_offs;
  }
  return 0;
}

// empty_output_buffer
// file jpegutils.c line 190
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo)
{
  motion_log(3, (unsigned int)9, 0, "%s: Given jpeg buffer was too small", (const void *)"empty_output_buffer");
  cinfo->err->msg_code = 23;
  cinfo->err->error_exit((struct jpeg_common_struct *)cinfo);
  return 1;
}

// empty_output_buffer$link1
// file picture.c line 43
static signed int empty_output_buffer$link1(struct jpeg_compress_struct *cinfo$link1)
{
  struct anonymous$8 *dest = (struct anonymous$8 *)cinfo$link1->dest;
  dest->pub.next_output_byte = dest->buf;
  dest->pub.free_in_buffer = dest->bufsize;
  return 0;
  cinfo$link1->err->msg_code = 23;
  cinfo$link1->err->error_exit((struct jpeg_common_struct *)cinfo$link1);
}

// encode_jpeg_raw
// file jpegutils.c line 1044
signed int encode_jpeg_raw(unsigned char *jpeg_data, signed int len, signed int quality, signed int itype, signed int ctype, unsigned int width, unsigned int height, unsigned char *raw0, unsigned char *raw1, unsigned char *raw2)
{
  signed int numfields;
  signed int field;
  signed int yl;
  signed int yc;
  signed int y;
  signed int i;
  unsigned char *row0[16l] = { buf0[(signed long int)0], buf0[(signed long int)1], buf0[(signed long int)2], buf0[(signed long int)3], buf0[(signed long int)4], buf0[(signed long int)5], buf0[(signed long int)6], buf0[(signed long int)7], buf0[(signed long int)8], buf0[(signed long int)9], buf0[(signed long int)10], buf0[(signed long int)11], buf0[(signed long int)12], buf0[(signed long int)13], buf0[(signed long int)14], buf0[(signed long int)15] };
  unsigned char *row1[8l] = { buf1[(signed long int)0], buf1[(signed long int)1], buf1[(signed long int)2], buf1[(signed long int)3], buf1[(signed long int)4], buf1[(signed long int)5], buf1[(signed long int)6], buf1[(signed long int)7] };
  unsigned char *row2[8l] = { buf2[(signed long int)0], buf2[(signed long int)1], buf2[(signed long int)2], buf2[(signed long int)3], buf2[(signed long int)4], buf2[(signed long int)5], buf2[(signed long int)6], buf2[(signed long int)7] };
  unsigned char **scanarray[3l] = { row0, row1, row2 };
  struct jpeg_compress_struct cinfo;
  struct my_error_mgr jerr;
  cinfo.err=jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(jerr.setjmp_buffer);
  if(!(return_value__setjmp$1 == 0))
  {
    jpeg_destroy_compress(&cinfo);
    return -1;
  }

  else
  {
    jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
    jpeg_buffer_dest(&cinfo, jpeg_data, (signed long int)len);
    cinfo.input_components = 3;
    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, quality, 0);
    cinfo.raw_data_in = 1;
    cinfo.in_color_space = (enum anonymous$10)JCS_YCbCr;
    cinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
    cinfo.input_gamma = 1.0;
    (cinfo.comp_info + (signed long int)0)->h_samp_factor = 2;
    (cinfo.comp_info + (signed long int)0)->v_samp_factor = 1;
    (cinfo.comp_info + (signed long int)1)->h_samp_factor = 1;
    (cinfo.comp_info + (signed long int)1)->v_samp_factor = 1;
    (cinfo.comp_info + (signed long int)2)->h_samp_factor = 1;
    (cinfo.comp_info + (signed long int)2)->v_samp_factor = 1;
    if(height >= 4097u || width >= 4097u)
      motion_log(3, (unsigned int)9, 0, "%s: Image dimensions (%dx%d) exceed lavtools' max (4096x4096)", (const void *)"encode_jpeg_raw", width, height);

    else
      if(!(height % 16u == 0u) || !(width % 16u == 0u))
        motion_log(3, (unsigned int)9, 0, "%s: Image dimensions (%dx%d) not multiples of 16", (const void *)"encode_jpeg_raw", width, height);

      else
      {
        cinfo.image_width = width;
        if(itype == 1 || itype == 2)
        {
          numfields = 2;
          goto __CPROVER_DUMP_L6;
        }

        numfields = 1;
        if(height >= 2049u)
          motion_log(3, (unsigned int)9, 0, "%s: Image height (%d) exceeds lavtools max for non-interlaced frames", (const void *)"encode_jpeg_raw", height);

        else
        {

        __CPROVER_DUMP_L6:
          ;
          cinfo.image_height = height / (unsigned int)numfields;
          yc = 0;
          yl = yc;
          field = 0;
          for( ; !(field >= numfields); field = field + 1)
          {
            jpeg_start_compress(&cinfo, 0);
            if(numfields == 2)
            {
              static unsigned char marker0[40l];
              jpeg_write_marker(&cinfo, 0xE0, marker0, (unsigned int)14);
              jpeg_write_marker(&cinfo, 0xE0 + 1, marker0, (unsigned int)40);
              switch(itype)
              {
                case 1:
                {
                  yc = field;
                  yl = yc;
                  break;
                }
                case 2:
                {
                  yc = 1 - field;
                  yl = yc;
                  break;
                }
                default:
                {
                  motion_log(3, (unsigned int)9, 0, "%s: Input is interlaced but no interlacing set", (const void *)"encode_jpeg_raw");
                  goto ERR_EXIT;
                }
              }
            }

            else
            {
              yc = 0;
              yl = yc;
            }
            while(!(cinfo.next_scanline >= cinfo.image_height))
            {
              y = 0;
              for( ; !(y >= 8 * cinfo.comp_info->v_samp_factor); y = y + 1)
              {
                row0[(signed long int)y] = &raw0[(signed long int)((unsigned int)yl * width)];
                yl = yl + numfields;
              }
              y = 0;
              for( ; !(y >= 8); y = y + 1)
              {
                row1[(signed long int)y] = &raw1[(signed long int)(((unsigned int)yc * width) / (unsigned int)2)];
                row2[(signed long int)y] = &raw2[(signed long int)(((unsigned int)yc * width) / (unsigned int)2)];
                if(ctype == 4 || !(y % 2 == 0))
                  yc = yc + numfields;

              }
              jpeg_write_raw_data(&cinfo, scanarray, (unsigned int)(8 * (cinfo.comp_info + (signed long int)0)->v_samp_factor));
            }
            jpeg_finish_compress(&cinfo);
          }
          i = (signed int)((unsigned long int)len - cinfo.dest->free_in_buffer);
          jpeg_destroy_compress(&cinfo);
          return i;
        }
      }

  ERR_EXIT:
    ;
    jpeg_destroy_compress(&cinfo);
    return -1;
  }
}

// erode5
// file alg.c line 792
static signed int erode5(unsigned char *img, signed int width, signed int height, void *buffer, unsigned char flag)
{
  signed int y;
  signed int i;
  signed int sum = 0;
  char *Row1;
  char *Row2;
  char *Row3;
  Row1 = (char *)buffer;
  Row2 = Row1 + (signed long int)width;
  Row3 = Row1 + (signed long int)(2 * width);
  memset((void *)Row2, (signed int)flag, (unsigned long int)width);
  memcpy((void *)Row3, (const void *)img, (unsigned long int)width);
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    memcpy((void *)Row1, (const void *)Row2, (unsigned long int)width);
    memcpy((void *)Row2, (const void *)Row3, (unsigned long int)width);
    if(y == height + -1)
      memset((void *)Row3, (signed int)flag, (unsigned long int)width);

    else
      memcpy((void *)Row3, (const void *)(img + (signed long int)((y + 1) * width)), (unsigned long int)width);
    i = width - 2;
    for( ; i >= 1; i = i - 1)
    {
      _Bool tmp_if_expr$1;
      if((signed int)Row1[(signed long int)i] == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)Row2[(signed long int)(i - 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)Row2[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)Row2[(signed long int)(i + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)Row3[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        img[(signed long int)(y * width + i)] = (unsigned char)0;

      else
        sum = sum + 1;
    }
    img[(signed long int)((y * width + width) - 1)] = flag;
    img[(signed long int)(y * width)] = img[(signed long int)((y * width + width) - 1)];
  }
  return sum;
}

// erode9
// file alg.c line 748
static signed int erode9(unsigned char *img, signed int width, signed int height, void *buffer, unsigned char flag)
{
  signed int y;
  signed int i;
  signed int sum = 0;
  char *Row1;
  char *Row2;
  char *Row3;
  Row1 = (char *)buffer;
  Row2 = Row1 + (signed long int)width;
  Row3 = Row1 + (signed long int)(2 * width);
  memset((void *)Row2, (signed int)flag, (unsigned long int)width);
  memcpy((void *)Row3, (const void *)img, (unsigned long int)width);
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    memcpy((void *)Row1, (const void *)Row2, (unsigned long int)width);
    memcpy((void *)Row2, (const void *)Row3, (unsigned long int)width);
    if(y == height + -1)
      memset((void *)Row3, (signed int)flag, (unsigned long int)width);

    else
      memcpy((void *)Row3, (const void *)(img + (signed long int)((y + 1) * width)), (unsigned long int)width);
    i = width - 2;
    for( ; i >= 1; i = i - 1)
    {
      _Bool tmp_if_expr$1;
      if((signed int)Row1[(signed long int)(i + -1)] == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)Row1[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)Row1[(signed long int)(i + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)Row2[(signed long int)(i - 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)Row2[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$5;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)Row2[(signed long int)(i + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$6;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)Row3[(signed long int)(i - 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$7;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)Row3[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$8;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)Row3[(signed long int)(i + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        img[(signed long int)(y * width + i)] = (unsigned char)0;

      else
        sum = sum + 1;
    }
    img[(signed long int)((y * width + width) - 1)] = flag;
    img[(signed long int)(y * width)] = img[(signed long int)((y * width + width) - 1)];
  }
  return sum;
}

// event
// file event.h line 38
void event(struct context *cnt, signed int type, unsigned char *image, char *filename, void *eventdata, struct tm *tm)
{
  signed int i = -1;
  do
  {
    i = i + 1;
    if(event_handlers[(signed long int)i].handler == ((void (*)(struct context *, signed int, unsigned char *, char *, void *, struct tm *))NULL))
      break;

    if(type == event_handlers[(signed long int)i].type)
      event_handlers[(signed long int)i].handler(cnt, type, image, filename, eventdata, tm);

  }
  while((_Bool)1);
}

// event_beep
// file event.c line 72
static void event_beep(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *ftype, struct tm *tm)
{
  if(cnt->conf.quiet == 0)
    printf("\a");

}

// event_camera_lost
// file event.c line 394
static void event_camera_lost(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  if(!(cnt->conf.on_camera_lost == ((char *)NULL)))
    exec_command(cnt, cnt->conf.on_camera_lost, (char *)(void *)0, 0);

}

// event_create_extpipe
// file event.c line 427
static void event_create_extpipe(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  if(!(cnt->conf.useextpipe == 0))
  {
    if(!(cnt->conf.extpipe == ((const char *)NULL)))
    {
      char stamp[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      const char *moviepath;
      struct _IO_FILE *fd_dummy = (struct _IO_FILE *)(void *)0;
      if(!(cnt->conf.moviepath == ((const char *)NULL)))
        moviepath = cnt->conf.moviepath;

      else
      {
        moviepath = "%v-%Y%m%d%H%M%S";
        motion_log(5, (unsigned int)6, 0, "%s: moviepath: %s", (const void *)"event_create_extpipe", moviepath);
      }
      mystrftime(cnt, stamp, sizeof(char [4096l]) /*4096ul*/ , moviepath, currenttime_tm, (const char *)(void *)0, 0);
      snprintf(cnt->extpipefilename, (unsigned long int)(4096 - 4), "%s/%s", cnt->conf.filepath, (const void *)stamp);
      fd_dummy=myfopen(cnt->extpipefilename, "w", (unsigned long int)0);
      if(fd_dummy == ((struct _IO_FILE *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 13)
        {
          motion_log(3, (unsigned int)6, 1, "%s: error opening file %s ...check access rights to target directory", (const void *)"event_create_extpipe", (const void *)cnt->extpipefilename);
          goto __CPROVER_DUMP_L7;
        }

        else
        {
          motion_log(3, (unsigned int)6, 1, "%s: error opening file %s", (const void *)"event_create_extpipe", (const void *)cnt->extpipefilename);
          goto __CPROVER_DUMP_L7;
        }
      }

      myfclose(fd_dummy);
      unlink(cnt->extpipefilename);
      mystrftime(cnt, stamp, sizeof(char [4096l]) /*4096ul*/ , cnt->conf.extpipe, currenttime_tm, cnt->extpipefilename, 0);
      motion_log(5, (unsigned int)6, 0, "%s: pipe: %s", (const void *)"event_create_extpipe", (const void *)stamp);
      motion_log(5, (unsigned int)6, 0, "%s: cnt->moviefps: %d", (const void *)"event_create_extpipe", cnt->movie_fps);
      event(cnt, 1, (unsigned char *)(void *)0, cnt->extpipefilename, (void *)8, (struct tm *)(void *)0);
      cnt->extpipe=popen(stamp, "w");
      if(cnt->extpipe == ((struct _IO_FILE *)NULL))
        motion_log(3, (unsigned int)6, 1, "%s: popen failed", (const void *)"event_create_extpipe");

      else
      {
        setbuf(cnt->extpipe, (char *)(void *)0);
        cnt->extpipe_open = 1;
      }
    }

  }


__CPROVER_DUMP_L7:
  ;
}

// event_extpipe_end
// file event.c line 412
static void event_extpipe_end(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *tm)
{
  if(!(cnt->extpipe_open == 0))
  {
    cnt->extpipe_open = 0;
    fflush(cnt->extpipe);
    signed int return_value_fileno$1;
    return_value_fileno$1=fileno(cnt->extpipe);
    signed int return_value_ferror$2;
    return_value_ferror$2=ferror(cnt->extpipe);
    motion_log(3, (unsigned int)6, 0, "%s: CLOSING: extpipe file desc %d, error state %d", (const void *)"event_extpipe_end", return_value_fileno$1, return_value_ferror$2);
    signed int return_value_pclose$3;
    return_value_pclose$3=pclose(cnt->extpipe);
    motion_log(3, (unsigned int)6, 0, "%s: pclose return: %d", (const void *)"event_extpipe_end", return_value_pclose$3);
    event(cnt, 14, (unsigned char *)(void *)0, cnt->extpipefilename, (void *)8, (struct tm *)(void *)0);
  }

}

// event_extpipe_put
// file event.c line 493
static void event_extpipe_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm)
{
  signed int return_value_fileno$3;
  signed int return_value_ferror$1;
  if(!(cnt->conf.useextpipe == 0))
  {
    if(!(cnt->extpipe == ((struct _IO_FILE *)NULL)))
    {
      motion_log(7, (unsigned int)6, 0, "%s:", (const void *)"event_extpipe_put");
      _Bool tmp_if_expr$4;
      if(!(cnt->extpipe_open == 0))
      {
        return_value_fileno$3=fileno(cnt->extpipe);
        tmp_if_expr$4 = return_value_fileno$3 > 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        unsigned long int return_value_fwrite$2;
        return_value_fwrite$2=fwrite((const void *)img, (unsigned long int)cnt->imgs.size, (unsigned long int)1, cnt->extpipe);
        if(return_value_fwrite$2 == 0ul)
        {
          return_value_ferror$1=ferror(cnt->extpipe);
          motion_log(3, (unsigned int)6, 1, "%s: Error writting in pipe , state error %d", (const void *)"event_extpipe_put", return_value_ferror$1);
        }

      }

      else
        motion_log(3, (unsigned int)6, 0, "%s: pipe %s not created or closed already ", (const void *)"event_extpipe_put", cnt->extpipe);
    }

  }

}

// event_ffmpeg_closefile
// file event.c line 728
static void event_ffmpeg_closefile(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
  {
    if(!(cnt->ffmpeg_output->udata == NULL))
      free(cnt->ffmpeg_output->udata);

    ffmpeg_close(cnt->ffmpeg_output);
    cnt->ffmpeg_output = (struct ffmpeg *)(void *)0;
    event(cnt, 14, (unsigned char *)(void *)0, cnt->newfilename, (void *)8, (struct tm *)(void *)0);
  }

  if(!(cnt->ffmpeg_output_debug == ((struct ffmpeg *)NULL)))
  {
    if(!(cnt->ffmpeg_output_debug->udata == NULL))
      free(cnt->ffmpeg_output_debug->udata);

    ffmpeg_close(cnt->ffmpeg_output_debug);
    cnt->ffmpeg_output_debug = (struct ffmpeg *)(void *)0;
    event(cnt, 14, (unsigned char *)(void *)0, cnt->motionfilename, (void *)16, (struct tm *)(void *)0);
  }

}

// event_ffmpeg_newfile
// file event.c line 540
static void event_ffmpeg_newfile(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  signed int width = cnt->imgs.width;
  signed int height = cnt->imgs.height;
  unsigned char *convbuf;
  unsigned char *y;
  unsigned char *u;
  unsigned char *v;
  char stamp[4096l];
  const char *moviepath;
  if(cnt->conf.ffmpeg_output == 0)
  {
    if(!(cnt->conf.ffmpeg_output_debug == 0))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(cnt->conf.moviepath == ((const char *)NULL)))
      moviepath = cnt->conf.moviepath;

    else
      moviepath = "%v-%Y%m%d%H%M%S";
    mystrftime(cnt, stamp, sizeof(char [4096l]) /*4096ul*/ , moviepath, currenttime_tm, (const char *)(void *)0, 0);
    snprintf(cnt->motionfilename, (unsigned long int)(4096 - 4), "%s/%sm", cnt->conf.filepath, (const void *)stamp);
    snprintf(cnt->newfilename, (unsigned long int)(4096 - 4), "%s/%s", cnt->conf.filepath, (const void *)stamp);
    if(!(cnt->conf.ffmpeg_output == 0))
    {
      if(cnt->imgs.type == 1)
      {
        void *return_value_mymalloc$1;
        return_value_mymalloc$1=mymalloc((unsigned long int)((width * height) / 2));
        convbuf = (unsigned char *)return_value_mymalloc$1;
        y = img;
        u = convbuf;
        v = convbuf + (signed long int)((width * height) / 4);
        grey2yuv420p(u, v, width, height);
      }

      else
      {
        convbuf = (unsigned char *)(void *)0;
        y = img;
        u = img + (signed long int)(width * height);
        v = u + (signed long int)((width * height) / 4);
      }
      cnt->ffmpeg_output=ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->newfilename, y, u, v, cnt->imgs.width, cnt->imgs.height, cnt->movie_fps, cnt->conf.ffmpeg_bps, cnt->conf.ffmpeg_vbr);
      if(cnt->ffmpeg_output == ((struct ffmpeg *)NULL))
      {
        motion_log(3, (unsigned int)6, 1, "%s: ffopen_open error creating (new) file [%s]", (const void *)"event_ffmpeg_newfile", (const void *)cnt->newfilename);
        cnt->finish = (volatile unsigned int)1;
        goto __CPROVER_DUMP_L12;
      }

      ((struct ffmpeg *)cnt->ffmpeg_output)->udata = (void *)convbuf;
      event(cnt, 1, (unsigned char *)(void *)0, cnt->newfilename, (void *)8, (struct tm *)(void *)0);
    }

    if(!(cnt->conf.ffmpeg_output_debug == 0))
    {
      if(cnt->imgs.type == 1)
      {
        void *return_value_mymalloc$2;
        return_value_mymalloc$2=mymalloc((unsigned long int)((width * height) / 2));
        convbuf = (unsigned char *)return_value_mymalloc$2;
        y = cnt->imgs.out;
        u = convbuf;
        v = convbuf + (signed long int)((width * height) / 4);
        grey2yuv420p(u, v, width, height);
      }

      else
      {
        y = cnt->imgs.out;
        u = cnt->imgs.out + (signed long int)(width * height);
        v = u + (signed long int)((width * height) / 4);
        convbuf = (unsigned char *)(void *)0;
      }
      cnt->ffmpeg_output_debug=ffmpeg_open((char *)cnt->conf.ffmpeg_video_codec, cnt->motionfilename, y, u, v, cnt->imgs.width, cnt->imgs.height, cnt->movie_fps, cnt->conf.ffmpeg_bps, cnt->conf.ffmpeg_vbr);
      if(cnt->ffmpeg_output_debug == ((struct ffmpeg *)NULL))
      {
        motion_log(3, (unsigned int)6, 1, "%s: ffopen_open error creating (motion) file [%s]", (const void *)"event_ffmpeg_newfile", (const void *)cnt->motionfilename);
        cnt->finish = (volatile unsigned int)1;
        goto __CPROVER_DUMP_L12;
      }

      cnt->ffmpeg_output_debug->udata = (void *)convbuf;
      event(cnt, 1, (unsigned char *)(void *)0, cnt->motionfilename, (void *)16, (struct tm *)(void *)0);
    }

  }

__CPROVER_DUMP_L12:
  ;
}

// event_ffmpeg_put
// file event.c line 698
static void event_ffmpeg_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm)
{
  if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
  {
    signed int width = cnt->imgs.width;
    signed int height = cnt->imgs.height;
    unsigned char *y = img;
    unsigned char *u;
    unsigned char *v;
    if(cnt->imgs.type == 1)
      u = (unsigned char *)cnt->ffmpeg_timelapse->udata;

    else
      u = y + (signed long int)(width * height);
    v = u + (signed long int)((width * height) / 4);
    signed int return_value_ffmpeg_put_other_image$1;
    return_value_ffmpeg_put_other_image$1=ffmpeg_put_other_image(cnt->ffmpeg_output, y, u, v);
    if(return_value_ffmpeg_put_other_image$1 == -1)
    {
      cnt->finish = (volatile unsigned int)1;
      cnt->restart = (volatile unsigned int)0;
    }

  }

  if(!(cnt->ffmpeg_output_debug == ((struct ffmpeg *)NULL)))
  {
    signed int return_value_ffmpeg_put_image$2;
    return_value_ffmpeg_put_image$2=ffmpeg_put_image(cnt->ffmpeg_output_debug);
    if(return_value_ffmpeg_put_image$2 == -1)
    {
      cnt->finish = (volatile unsigned int)1;
      cnt->restart = (volatile unsigned int)0;
    }

  }

}

// event_ffmpeg_timelapse
// file event.c line 628
static void event_ffmpeg_timelapse(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  signed int width = cnt->imgs.width;
  signed int height = cnt->imgs.height;
  unsigned char *convbuf;
  unsigned char *y;
  unsigned char *u;
  unsigned char *v;
  if(cnt->ffmpeg_timelapse == ((struct ffmpeg *)NULL))
  {
    char tmp[4096l];
    const char *timepath;
    if(!(cnt->conf.timepath == ((const char *)NULL)))
      timepath = cnt->conf.timepath;

    else
      timepath = "%Y%m%d-timelapse";
    mystrftime(cnt, tmp, sizeof(char [4096l]) /*4096ul*/ , timepath, currenttime_tm, (const char *)(void *)0, 0);
    snprintf(cnt->timelapsefilename, (unsigned long int)(4096 - 4), "%s/%s", cnt->conf.filepath, (const void *)tmp);
    if(cnt->imgs.type == 1)
    {
      void *return_value_mymalloc$1;
      return_value_mymalloc$1=mymalloc((unsigned long int)((width * height) / 2));
      convbuf = (unsigned char *)return_value_mymalloc$1;
      y = img;
      u = convbuf;
      v = convbuf + (signed long int)((width * height) / 4);
      grey2yuv420p(u, v, width, height);
    }

    else
    {
      convbuf = (unsigned char *)(void *)0;
      y = img;
      u = img + (signed long int)(width * height);
      v = u + (signed long int)((width * height) / 4);
    }
    cnt->ffmpeg_timelapse=ffmpeg_open((char *)"mpeg1_tl", cnt->timelapsefilename, y, u, v, cnt->imgs.width, cnt->imgs.height, 24, cnt->conf.ffmpeg_bps, cnt->conf.ffmpeg_vbr);
    if(cnt->ffmpeg_timelapse == ((struct ffmpeg *)NULL))
    {
      motion_log(3, (unsigned int)6, 1, "%s: ffopen_open error creating (timelapse) file [%s]", (const void *)"event_ffmpeg_timelapse", (const void *)cnt->timelapsefilename);
      cnt->finish = (volatile unsigned int)1;
      goto __CPROVER_DUMP_L10;
    }

    cnt->ffmpeg_timelapse->udata = (void *)convbuf;
    event(cnt, 1, (unsigned char *)(void *)0, cnt->timelapsefilename, (void *)32, (struct tm *)(void *)0);
  }

  y = img;
  if(cnt->imgs.type == 1)
    u = (unsigned char *)cnt->ffmpeg_timelapse->udata;

  else
    u = img + (signed long int)(width * height);
  v = u + (signed long int)((width * height) / 4);
  signed int return_value_ffmpeg_put_other_image$2;
  return_value_ffmpeg_put_other_image$2=ffmpeg_put_other_image(cnt->ffmpeg_timelapse, y, u, v);
  if(return_value_ffmpeg_put_other_image$2 == -1)
  {
    cnt->finish = (volatile unsigned int)1;
    cnt->restart = (volatile unsigned int)0;
  }


__CPROVER_DUMP_L10:
  ;
}

// event_ffmpeg_timelapseend
// file event.c line 755
static void event_ffmpeg_timelapseend(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->ffmpeg_timelapse == ((struct ffmpeg *)NULL)))
  {
    if(!(cnt->ffmpeg_timelapse->udata == NULL))
      free(cnt->ffmpeg_timelapse->udata);

    ffmpeg_close(cnt->ffmpeg_timelapse);
    cnt->ffmpeg_timelapse = (struct ffmpeg *)(void *)0;
    event(cnt, 14, (unsigned char *)(void *)0, cnt->timelapsefilename, (void *)32, (struct tm *)(void *)0);
  }

}

// event_image_detect
// file event.c line 292
static void event_image_detect(struct context *cnt, signed int type, unsigned char *newimg, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  char fullfilename[4096l];
  char filename[4096l];
  if(!((1u & cnt->new_img) == 0u))
  {
    const char *imagepath;
    if(!(cnt->conf.imagepath == ((const char *)NULL)))
      imagepath = cnt->conf.imagepath;

    else
      imagepath = "%v-%Y%m%d%H%M%S-%q";
    mystrftime(cnt, filename, sizeof(char [4096l]) /*4096ul*/ , imagepath, currenttime_tm, (const char *)(void *)0, 0);
    const char *return_value_imageext$1;
    return_value_imageext$1=imageext(cnt);
    snprintf(fullfilename, (unsigned long int)4096, "%s/%s.%s", cnt->conf.filepath, (const void *)filename, return_value_imageext$1);
    put_picture(cnt, fullfilename, newimg, 1);
  }

}

// event_image_snapshot
// file event.c line 348
static void event_image_snapshot(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  char fullfilename[4096l];
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(cnt->conf.snappath, "lastsnap");
  if(!(return_value_strcmp$5 == 0))
  {
    char filename[4096l];
    char filepath[4096l];
    char linkpath[4096l];
    const char *snappath;
    if(!(cnt->conf.snappath == ((const char *)NULL)))
      snappath = cnt->conf.snappath;

    else
      snappath = "%v-%Y%m%d%H%M%S-snapshot";
    mystrftime(cnt, filepath, sizeof(char [4096l]) /*4096ul*/ , snappath, currenttime_tm, (const char *)(void *)0, 0);
    const char *return_value_imageext$1;
    return_value_imageext$1=imageext(cnt);
    snprintf(filename, (unsigned long int)4096, "%s.%s", (const void *)filepath, return_value_imageext$1);
    snprintf(fullfilename, (unsigned long int)4096, "%s/%s", cnt->conf.filepath, (const void *)filename);
    put_picture(cnt, fullfilename, img, 2);
    const char *return_value_imageext$2;
    return_value_imageext$2=imageext(cnt);
    snprintf(linkpath, (unsigned long int)4096, "%s/lastsnap.%s", cnt->conf.filepath, return_value_imageext$2);
    remove(linkpath);
    signed int return_value_symlink$3;
    return_value_symlink$3=symlink(filename, linkpath);
    if(!(return_value_symlink$3 == 0))
    {
      motion_log(3, (unsigned int)6, 1, "%s: Could not create symbolic link [%s]", (const void *)"event_image_snapshot", (const void *)filename);
      goto __CPROVER_DUMP_L6;
    }

  }

  else
  {
    const char *return_value_imageext$4;
    return_value_imageext$4=imageext(cnt);
    snprintf(fullfilename, (unsigned long int)4096, "%s/lastsnap.%s", cnt->conf.filepath, return_value_imageext$4);
    remove(fullfilename);
    put_picture(cnt, fullfilename, img, 2);
  }
  cnt->snapshot = (volatile unsigned int)0;

__CPROVER_DUMP_L6:
  ;
}

// event_imagem_detect
// file event.c line 318
static void event_imagem_detect(struct context *cnt, signed int type, unsigned char *newimg, char *dummy1, void *dummy2, struct tm *currenttime_tm)
{
  struct config *conf = &cnt->conf;
  char fullfilenamem[4096l];
  char filename[4096l];
  char filenamem[4096l];
  if(!(conf->motion_img == 0))
  {
    const char *imagepath;
    if(!(cnt->conf.imagepath == ((const char *)NULL)))
      imagepath = cnt->conf.imagepath;

    else
      imagepath = "%v-%Y%m%d%H%M%S-%q";
    mystrftime(cnt, filename, sizeof(char [4096l]) /*4096ul*/ , imagepath, currenttime_tm, (const char *)(void *)0, 0);
    snprintf(filenamem, (unsigned long int)4096, "%sm", (const void *)filename);
    const char *return_value_imageext$1;
    return_value_imageext$1=imageext(cnt);
    snprintf(fullfilenamem, (unsigned long int)4096, "%s/%s.%s", cnt->conf.filepath, (const void *)filenamem, return_value_imageext$1);
    put_picture(cnt, fullfilenamem, cnt->imgs.out, 4);
  }

}

// event_new_video
// file event.c line 514
static void event_new_video(struct context *cnt, signed int type, unsigned char *dummy, char *dummy1, void *dummy2, struct tm *tm)
{
  cnt->movie_last_shot = -1;
  cnt->movie_fps = (signed int)cnt->lastrate;
  motion_log(5, (unsigned int)6, 0, "%s FPS %d", (const void *)"event_new_video", cnt->movie_fps);
  if(cnt->movie_fps >= 31)
    cnt->movie_fps = 30;

  else
    if(!(cnt->movie_fps >= 2))
      cnt->movie_fps = 2;

}

// event_newfile
// file event.c line 63
static void event_newfile(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *ftype, struct tm *tm)
{
  motion_log(5, (unsigned int)6, 0, "%s: File of type %ld saved to: %s", (const void *)"event_newfile", (unsigned long int)ftype, filename);
}

// event_sdl_put
// file event.c line 263
static void event_sdl_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm)
{
  sdl_put(img, cnt->imgs.width, cnt->imgs.height);
}

// event_sqlnewfile
// file event.c line 114
static void event_sqlnewfile(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm)
{
  signed int sqltype = (signed int)(unsigned long int)arg;
  _Bool tmp_if_expr$1;
  if(cnt->conf.database_type == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (sqltype & cnt->sql_mask) == 0 ? (_Bool)1 : (_Bool)0;
  enum anonymous$4 return_value_PQresultStatus$15;
  if(!tmp_if_expr$1)
  {
    char sqlquery[4096l];
    mystrftime(cnt, sqlquery, sizeof(char [4096l]) /*4096ul*/ , cnt->conf.sql_query, &cnt->current_image->timestamp_tm, filename, sqltype);
    signed int return_value_strcmp$11;
    return_value_strcmp$11=strcmp(cnt->conf.database_type, "mysql");
    if(return_value_strcmp$11 == 0)
    {
      signed int return_value_mysql_query$10;
      return_value_mysql_query$10=mysql_query(cnt->database, sqlquery);
      if(!(return_value_mysql_query$10 == 0))
      {
        signed int error_code;
        unsigned int return_value_mysql_errno$2;
        return_value_mysql_errno$2=mysql_errno(cnt->database);
        error_code = (signed int)return_value_mysql_errno$2;
        const char *return_value_mysql_error$3;
        return_value_mysql_error$3=mysql_error(cnt->database);
        motion_log(3, (unsigned int)5, 1, "%s: Mysql query failed %s error code %d", (const void *)"event_sqlnewfile", return_value_mysql_error$3, error_code);
        if(error_code >= 2000)
        {
          mysql_close(cnt->database);
          void *return_value_mymalloc$4;
          return_value_mymalloc$4=mymalloc(sizeof(struct st_mysql) /*1272ul*/ );
          cnt->database = (struct st_mysql *)return_value_mymalloc$4;
          mysql_init(cnt->database);
          struct st_mysql *return_value_mysql_real_connect$9;
          return_value_mysql_real_connect$9=mysql_real_connect(cnt->database, cnt->conf.database_host, cnt->conf.database_user, cnt->conf.database_password, cnt->conf.database_dbname, (unsigned int)0, (const char *)(void *)0, (unsigned long int)0);
          if(return_value_mysql_real_connect$9 == ((struct st_mysql *)NULL))
          {
            const char *return_value_mysql_error$5;
            return_value_mysql_error$5=mysql_error(cnt->database);
            motion_log(1, (unsigned int)5, 0, "%s: Cannot reconnect to MySQL database %s on host %s with user %s MySQL error was %s", (const void *)"event_sqlnewfile", cnt->conf.database_dbname, cnt->conf.database_host, cnt->conf.database_user, return_value_mysql_error$5);
          }

          else
          {
            motion_log(6, (unsigned int)5, 0, "%s: Re-Connection to Mysql database '%s' Succeed", (const void *)"event_sqlnewfile", cnt->conf.database_dbname);
            signed int return_value_mysql_query$8;
            return_value_mysql_query$8=mysql_query(cnt->database, sqlquery);
            if(!(return_value_mysql_query$8 == 0))
            {
              signed int error_my;
              unsigned int return_value_mysql_errno$6;
              return_value_mysql_errno$6=mysql_errno(cnt->database);
              error_my = (signed int)return_value_mysql_errno$6;
              const char *return_value_mysql_error$7;
              return_value_mysql_error$7=mysql_error(cnt->database);
              motion_log(3, (unsigned int)5, 1, "%s: after re-connection Mysql query failed %s error code %d", (const void *)"event_sqlnewfile", return_value_mysql_error$7, error_my);
            }

          }
        }

      }

    }

    signed int return_value_strcmp$17;
    return_value_strcmp$17=strcmp(cnt->conf.database_type, "postgresql");
    if(return_value_strcmp$17 == 0)
    {
      struct pg_result *res;
      res=PQexec(cnt->database_pg, sqlquery);
      enum anonymous$41 return_value_PQstatus$16;
      return_value_PQstatus$16=PQstatus(cnt->database_pg);
      if((signed int)return_value_PQstatus$16 == CONNECTION_BAD)
      {
        char *return_value_PQerrorMessage$12;
        return_value_PQerrorMessage$12=PQerrorMessage(cnt->database_pg);
        motion_log(3, (unsigned int)5, 0, "%s: Connection to PostgreSQL database '%s' failed: %s", (const void *)"event_sqlnewfile", cnt->conf.database_dbname, return_value_PQerrorMessage$12);
        PQreset(cnt->database_pg);
        enum anonymous$41 return_value_PQstatus$14;
        return_value_PQstatus$14=PQstatus(cnt->database_pg);
        if((signed int)return_value_PQstatus$14 == CONNECTION_BAD)
        {
          char *return_value_PQerrorMessage$13;
          return_value_PQerrorMessage$13=PQerrorMessage(cnt->database_pg);
          motion_log(3, (unsigned int)5, 0, "%s: Re-Connection to PostgreSQL database '%s' failed: %s", (const void *)"event_sqlnewfile", cnt->conf.database_dbname, return_value_PQerrorMessage$13);
        }

        else
          motion_log(6, (unsigned int)5, 0, "%s: Re-Connection to PostgreSQL database '%s' Succeed", (const void *)"event_sqlnewfile", cnt->conf.database_dbname);
      }

      else
      {
        return_value_PQresultStatus$15=PQresultStatus(res);
        if(!((signed int)return_value_PQresultStatus$15 == PGRES_COMMAND_OK))
        {
          motion_log(3, (unsigned int)5, 1, "%s: PGSQL query [%s] failed", (const void *)"event_sqlnewfile", (const void *)sqlquery);
          PQclear(res);
        }

      }
    }

    signed int return_value_strcmp$18;
    return_value_strcmp$18=strcmp(cnt->conf.database_type, "sqlite3");
    if(return_value_strcmp$18 == 0)
    {
      if(!(cnt->conf.sqlite3_db == ((const char *)NULL)))
      {
        signed int event_sqlnewfile$$1$$1$$3$$res;
        char *errmsg = ((char *)NULL);
        event_sqlnewfile$$1$$1$$3$$res=sqlite3_exec(cnt->database_sqlite3, sqlquery, (signed int (*)(void *, signed int, char **, char **))(void *)0, NULL, &errmsg);
        if(!(event_sqlnewfile$$1$$1$$3$$res == 0))
        {
          motion_log(3, (unsigned int)5, 0, "%s: SQLite error was %s", (const void *)"event_sqlnewfile", errmsg);
          sqlite3_free((void *)errmsg);
        }

      }

    }

  }

}

// event_stop_stream
// file event.c line 245
static void event_stop_stream(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->conf.stream_port == 0))
  {
    if(!(cnt->stream.socket == -1))
      stream_stop(cnt);

  }

}

// event_stream_put
// file event.c line 254
static void event_stream_put(struct context *cnt, signed int type, unsigned char *img, char *dummy1, void *dummy2, struct tm *tm)
{
  if(!(cnt->conf.stream_port == 0))
    stream_put(cnt, img);

}

// exec_command
// file event.c line 28
static void exec_command(struct context *cnt, char *command, char *filename, signed int filetype)
{
  char stamp[4096l];
  mystrftime(cnt, stamp, sizeof(char [4096l]) /*4096ul*/ , command, &cnt->current_image->timestamp_tm, filename, filetype);
  signed int return_value_fork$1;
  return_value_fork$1=fork();
  if(return_value_fork$1 == 0)
  {
    signed int i;
    setsid();
    i=getdtablesize();
    for( ; i >= 3; i = i - 1)
      close(i);
    execl("/bin/sh", "sh", (const void *)"-c", (const void *)stamp, (const void *)" &", (void *)0);
    motion_log(1, (unsigned int)6, 1, "%s: Unable to start external command '%s'", (const void *)"exec_command", (const void *)stamp);
    exit(1);
  }

  motion_log(7, (unsigned int)6, 0, "%s: Executing external command '%s'", (const void *)"exec_command", (const void *)stamp);
}

// ffmpeg_avcodec_log
// file ffmpeg.c line 1158
void ffmpeg_avcodec_log(void *ignoreme, signed int errno_flag, const char *fmt, void **vl)
{
  char buf[1024l];
  vsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, vl);
  motion_log(6, (unsigned int)3, 0, "%s: %s - flag %d", (const void *)"ffmpeg_avcodec_log", (const void *)buf, errno_flag);
}

// ffmpeg_cleanups
// file ffmpeg.c line 792
void ffmpeg_cleanups(struct ffmpeg *ffmpeg)
{
  unsigned int i;
  if(!(ffmpeg->video_st == ((struct AVStream *)NULL)))
  {
    pthread_mutex_lock(&global_lock);
    if(!(ffmpeg->video_st->codec->priv_data == NULL))
      avcodec_close(ffmpeg->video_st->codec);

    pthread_mutex_unlock(&global_lock);
    av_frame_free(&ffmpeg->picture);
    free((void *)ffmpeg->video_outbuf);
  }

  i = (unsigned int)0;
  for( ; !(i >= ffmpeg->oc->nb_streams); i = i + 1u)
    av_freep((void *)&ffmpeg->oc->streams[(signed long int)i]);
  av_free((void *)ffmpeg->oc);
  av_free((void *)ffmpeg->c);
  free((void *)ffmpeg);
}

// ffmpeg_close
// file ffmpeg.h line 93
void ffmpeg_close(struct ffmpeg *ffmpeg)
{
  unsigned int i;
  if(!(ffmpeg->video_st == ((struct AVStream *)NULL)))
  {
    pthread_mutex_lock(&global_lock);
    avcodec_close(ffmpeg->video_st->codec);
    pthread_mutex_unlock(&global_lock);
    av_frame_free(&ffmpeg->picture);
    free((void *)ffmpeg->video_outbuf);
  }

  av_write_trailer(ffmpeg->oc);
  i = (unsigned int)0;
  for( ; !(i >= ffmpeg->oc->nb_streams); i = i + 1u)
    av_freep((void *)&ffmpeg->oc->streams[(signed long int)i]);
  if((0x0001 & ffmpeg->oc->oformat->flags) == 0)
    avio_close(ffmpeg->oc->pb);

  av_free((void *)ffmpeg->oc);
  av_free((void *)ffmpeg->c);
  free((void *)ffmpeg);
}

// ffmpeg_deinterlace
// file ffmpeg.h line 96
void ffmpeg_deinterlace(unsigned char *img, signed int width, signed int height)
{
  struct AVPicture picture;
  signed int width2 = width / 2;
  picture.data[(signed long int)0] = img;
  picture.data[(signed long int)1] = img + (signed long int)(width * height);
  picture.data[(signed long int)2] = picture.data[(signed long int)1] + (signed long int)((width * height) / 4);
  picture.linesize[(signed long int)0] = width;
  picture.linesize[(signed long int)1] = width2;
  picture.linesize[(signed long int)2] = width2;
  process_filter_graph(&picture, &picture, (enum AVPixelFormat)AV_PIX_FMT_YUV420P, width, height);
  asm("emms");
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// ffmpeg_init
// file ffmpeg.h line 60
void ffmpeg_init(void)
{
  motion_log(5, (unsigned int)3, 0, "%s: ffmpeg LIBAVCODEC_BUILD %d LIBAVFORMAT_BUILD %d", (const void *)"ffmpeg_init", 56 << 16 | 60 << 8 | 100, 56 << 16 | 40 << 8 | 101);
  av_register_all();
  av_log_set_callback((void (*)(void *, signed int, const char *, void **))(void *)ffmpeg_avcodec_log);
  av_log_set_level(16);
}

// ffmpeg_open
// file ffmpeg.h line 68
struct ffmpeg * ffmpeg_open(char *ffmpeg_video_codec, char *filename, unsigned char *y, unsigned char *u, unsigned char *v, signed int width, signed int height, signed int rate, signed int bps, signed int vbr)
{
  struct AVCodecContext *c;
  struct AVCodec *codec;
  struct ffmpeg *ffmpeg;
  signed int is_mpeg1;
  signed int ret;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct ffmpeg) /*80ul*/ );
  ffmpeg = (struct ffmpeg *)return_value_mymalloc$1;
  memset((void *)ffmpeg, 0, sizeof(struct ffmpeg) /*80ul*/ );
  ffmpeg->vbr = vbr;
  snprintf(ffmpeg->codec, sizeof(char [20l]) /*20ul*/ , "%s", ffmpeg_video_codec);
  ffmpeg->oc=avformat_alloc_context();
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$6;
  signed int *return_value___errno_location$11;
  if(ffmpeg->oc == ((struct AVFormatContext *)NULL))
  {
    motion_log(3, (unsigned int)3, 1, "%s: Memory error while allocating output media context", (const void *)"ffmpeg_open");
    ffmpeg_cleanups(ffmpeg);
    return (struct ffmpeg *)(void *)0;
  }

  else
  {
    ffmpeg->oc->oformat=get_oformat(ffmpeg_video_codec, filename);
    if(ffmpeg->oc->oformat == ((struct AVOutputFormat *)NULL))
    {
      ffmpeg_cleanups(ffmpeg);
      return (struct ffmpeg *)(void *)0;
    }

    else
    {
      snprintf(ffmpeg->oc->filename, sizeof(char [1024l]) /*1024ul*/ , "%s", filename);
      ffmpeg->video_st = (struct AVStream *)(void *)0;
      if(!((signed int)ffmpeg->oc->oformat->video_codec == AV_CODEC_ID_NONE))
      {
        ffmpeg->video_st=avformat_new_stream(ffmpeg->oc, (const struct AVCodec *)(void *)0);
        if(ffmpeg->video_st == ((struct AVStream *)NULL))
        {
          motion_log(3, (unsigned int)3, 1, "%s: av_new_stream - could not alloc stream", (const void *)"ffmpeg_open");
          ffmpeg_cleanups(ffmpeg);
          return (struct ffmpeg *)(void *)0;
        }

      }

      else
      {
        motion_log(3, (unsigned int)3, 0, "%s: Failed to obtain a proper video codec", (const void *)"ffmpeg_open");
        ffmpeg_cleanups(ffmpeg);
        return (struct ffmpeg *)(void *)0;
      }
      c = ffmpeg->video_st->codec;
      ffmpeg->c = c;
      c->codec_id = ffmpeg->oc->oformat->video_codec;
      c->codec_type = (enum AVMediaType)AVMEDIA_TYPE_VIDEO;
      is_mpeg1 = (signed int)((signed int)c->codec_id == AV_CODEC_ID_MPEG1VIDEO);
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(ffmpeg_video_codec, "ffv1");
      if(return_value_strcmp$2 == 0)
        c->strict_std_compliance = -2;

      c->bit_rate = bps;
      c->width = width;
      c->height = height;
      c->time_base.num = 1;
      c->time_base.den = rate;
      motion_log(6, (unsigned int)3, 0, "%s FPS %d", (const void *)"ffmpeg_open", rate);
      if(!(vbr == 0))
        c->flags = c->flags | 1 << 1;

      c->gop_size = is_mpeg1 != 0 ? 10 : 12;
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(ffmpeg->oc->oformat->name, "mp4");
      _Bool tmp_if_expr$5;
      if(return_value_strcmp$3 == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_strcmp$4=strcmp(ffmpeg->oc->oformat->name, "mov");
        tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$7;
      if(tmp_if_expr$5)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_strcmp$6=strcmp(ffmpeg->oc->oformat->name, "3gp");
        tmp_if_expr$7 = !(return_value_strcmp$6 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        c->flags = c->flags | 1 << 22;

      codec=avcodec_find_encoder(c->codec_id);
      if(codec == ((struct AVCodec *)NULL))
      {
        motion_log(3, (unsigned int)3, 0, "%s: Codec %s not found", (const void *)"ffmpeg_open", ffmpeg_video_codec);
        ffmpeg_cleanups(ffmpeg);
        return (struct ffmpeg *)(void *)0;
      }

      else
      {
        c->pix_fmt = (enum AVPixelFormat)AV_PIX_FMT_YUV420P;
        pthread_mutex_lock(&global_lock);
        ret=avcodec_open2(c, codec, (struct AVDictionary **)(void *)0);
        if(!(ret >= 0))
        {
          pthread_mutex_unlock(&global_lock);
          motion_log(3, (unsigned int)3, 0, "%s: avcodec_open - could not open codec %s", (const void *)"ffmpeg_open", ffmpeg_video_codec);
          ffmpeg_cleanups(ffmpeg);
          return (struct ffmpeg *)(void *)0;
        }

        else
        {
          pthread_mutex_unlock(&global_lock);
          ffmpeg->video_outbuf = (unsigned char *)(void *)0;
          if((0x0020 & ffmpeg->oc->oformat->flags) == 0)
          {
            ffmpeg->video_outbuf_size = ffmpeg->c->width * 512;
            void *return_value_mymalloc$8;
            return_value_mymalloc$8=mymalloc((unsigned long int)ffmpeg->video_outbuf_size);
            ffmpeg->video_outbuf = (unsigned char *)return_value_mymalloc$8;
          }

          ffmpeg->picture=av_frame_alloc();
          if(ffmpeg->picture == ((struct AVFrame *)NULL))
          {
            motion_log(3, (unsigned int)3, 0, "%s: av_frame_alloc - could not alloc frame", (const void *)"ffmpeg_open");
            ffmpeg_cleanups(ffmpeg);
            return (struct ffmpeg *)(void *)0;
          }

          else
          {
            if(!(ffmpeg->vbr == 0))
              ffmpeg->picture->quality = ffmpeg->vbr;

            ffmpeg->picture->data[(signed long int)0] = y;
            ffmpeg->picture->data[(signed long int)1] = u;
            ffmpeg->picture->data[(signed long int)2] = v;
            ffmpeg->picture->linesize[(signed long int)0] = ffmpeg->c->width;
            ffmpeg->picture->linesize[(signed long int)1] = ffmpeg->c->width / 2;
            ffmpeg->picture->linesize[(signed long int)2] = ffmpeg->c->width / 2;
            if((0x0001 & ffmpeg->oc->oformat->flags) == 0)
            {
              char file_proto[256l];
              if(!(is_mpeg1 == 0))
                snprintf(file_proto, sizeof(char [256l]) /*256ul*/ , "%s", filename);

              else
                snprintf(file_proto, sizeof(char [256l]) /*256ul*/ , "%s", filename);
              signed int return_value_avio_open$13;
              return_value_avio_open$13=avio_open(&ffmpeg->oc->pb, file_proto, 2);
              if(!(return_value_avio_open$13 >= 0))
              {
                signed int *return_value___errno_location$12;
                return_value___errno_location$12=__errno_location();
                if(*return_value___errno_location$12 == 2)
                {
                  signed int return_value_create_path$9;
                  return_value_create_path$9=create_path(filename);
                  if(return_value_create_path$9 == -1)
                  {
                    ffmpeg_cleanups(ffmpeg);
                    return (struct ffmpeg *)(void *)0;
                  }

                  signed int return_value_avio_open$10;
                  return_value_avio_open$10=avio_open(&ffmpeg->oc->pb, file_proto, 2);
                  if(!(return_value_avio_open$10 >= 0))
                  {
                    motion_log(3, (unsigned int)3, 1, "%s: url_fopen - error opening file %s", (const void *)"ffmpeg_open", filename);
                    ffmpeg_cleanups(ffmpeg);
                    return (struct ffmpeg *)(void *)0;
                  }

                }

                else
                {
                  return_value___errno_location$11=__errno_location();
                  if(*return_value___errno_location$11 == 13)
                  {
                    motion_log(3, (unsigned int)3, 1, "%s: url_fopen - error opening file %s ... check access rights to target directory", (const void *)"ffmpeg_open", filename);
                    ffmpeg_cleanups(ffmpeg);
                    return (struct ffmpeg *)(void *)0;
                  }

                  else
                  {
                    motion_log(3, (unsigned int)3, 1, "%s: Error opening file %s", (const void *)"ffmpeg_open", filename);
                    ffmpeg_cleanups(ffmpeg);
                    return (struct ffmpeg *)(void *)0;
                  }
                }
              }

            }

            avformat_write_header(ffmpeg->oc, (struct AVDictionary **)(void *)0);
            return ffmpeg;
          }
        }
      }
    }
  }
}

// ffmpeg_prepare_frame
// file ffmpeg.c line 1007
struct AVFrame * ffmpeg_prepare_frame(struct ffmpeg *ffmpeg, unsigned char *y, unsigned char *u, unsigned char *v)
{
  struct AVFrame *picture;
  picture=av_frame_alloc();
  if(picture == ((struct AVFrame *)NULL))
  {
    motion_log(3, (unsigned int)3, 1, "%s: Could not alloc frame", (const void *)"ffmpeg_prepare_frame");
    return (struct AVFrame *)(void *)0;
  }

  else
  {
    if(!(ffmpeg->vbr == 0))
      picture->quality = ffmpeg->vbr;

    picture->data[(signed long int)0] = y;
    picture->data[(signed long int)1] = u;
    picture->data[(signed long int)2] = v;
    picture->linesize[(signed long int)0] = ffmpeg->c->width;
    picture->linesize[(signed long int)1] = ffmpeg->c->width / 2;
    picture->linesize[(signed long int)2] = ffmpeg->c->width / 2;
    return picture;
  }
}

// ffmpeg_put_frame
// file ffmpeg.c line 914
signed int ffmpeg_put_frame(struct ffmpeg *ffmpeg, struct AVFrame *pic)
{
  signed int out_size;
  signed int ret;
  signed int got_packet_ptr;
  struct AVPacket pkt;
  av_init_packet(&pkt);
  pkt.stream_index = ffmpeg->video_st->index;
  if(!((0x0020 & ffmpeg->oc->oformat->flags) == 0))
  {
    pkt.flags = pkt.flags | 0x0001;
    pkt.data = (unsigned char *)pic;
    pkt.size = (signed int)sizeof(struct AVPicture) /*96ul*/ ;
    ret=av_write_frame(ffmpeg->oc, &pkt);
  }

  else
  {
    pkt.data = ffmpeg->video_outbuf;
    pkt.size = ffmpeg->video_outbuf_size;
    out_size=avcodec_encode_video2(ffmpeg->video_st->codec, &pkt, pic, &got_packet_ptr);
    if(!(out_size >= 0))
      out_size = 0;

    else
      out_size = pkt.size;
    if(!(out_size == 0))
    {
      pkt.pts = ffmpeg->video_st->codec->coded_frame->pts;
      if(!(ffmpeg->video_st->codec->coded_frame->key_frame == 0))
        pkt.flags = pkt.flags | 0x0001;

      pkt.data = ffmpeg->video_outbuf;
      pkt.size = out_size;
      ret=av_write_frame(ffmpeg->oc, &pkt);
    }

    else
      ret = 0;
  }
  if(!(ret == 0))
  {
    motion_log(3, (unsigned int)3, 1, "%s: Error while writing video frame", (const void *)"ffmpeg_put_frame");
    ffmpeg_cleanups(ffmpeg);
    return -1;
  }

  else
    return ret;
}

// ffmpeg_put_image
// file ffmpeg.h line 82
signed int ffmpeg_put_image(struct ffmpeg *ffmpeg)
{
  signed int return_value_ffmpeg_put_frame$1;
  return_value_ffmpeg_put_frame$1=ffmpeg_put_frame(ffmpeg, ffmpeg->picture);
  return return_value_ffmpeg_put_frame$1;
}

// ffmpeg_put_other_image
// file ffmpeg.h line 85
signed int ffmpeg_put_other_image(struct ffmpeg *ffmpeg, unsigned char *y, unsigned char *u, unsigned char *v)
{
  struct AVFrame *picture;
  signed int ret = 0;
  picture=ffmpeg_prepare_frame(ffmpeg, y, u, v);
  if(!(picture == ((struct AVFrame *)NULL)))
  {
    ret=ffmpeg_put_frame(ffmpeg, picture);
    if(ret == 0)
      av_frame_free(&picture);

  }

  return ret;
}

// file_free_context
// file netcam.c line 1865
void file_free_context(struct file_context *ctxt)
{
  if(!(ctxt == ((struct file_context *)NULL)))
  {
    if(!(ctxt->path == ((char *)NULL)))
      free((void *)ctxt->path);

    free((void *)ctxt);
  }

}

// file_new_context
// file netcam.c line 1852
struct file_context * file_new_context(void)
{
  struct file_context *ret;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct file_context) /*24ul*/ );
  ret = (struct file_context *)return_value_mymalloc$1;
  if(ret == ((struct file_context *)NULL))
    return ret;

  else
  {
    memset((void *)ret, 0, sizeof(struct file_context) /*24ul*/ );
    return ret;
  }
}

// fill_input_buffer
// file jpegutils.c line 86
static signed int fill_input_buffer(struct jpeg_decompress_struct *cinfo)
{
  cinfo->src->next_input_byte = EOI_data;
  cinfo->src->bytes_in_buffer = (unsigned long int)2;
  return 1;
}

// ftp_close
// file netcam_ftp.c line 872
signed int ftp_close(struct ftp_context *ctxt)
{
  if(ctxt == ((struct ftp_context *)NULL))
    return -1;

  else
  {
    if(ctxt->data_file_desc >= 0)
    {
      close(ctxt->data_file_desc);
      ctxt->data_file_desc = -1;
    }

    if(ctxt->control_file_desc >= 0)
    {
      ftp_quit(ctxt);
      close(ctxt->control_file_desc);
      ctxt->control_file_desc = -1;
    }

    ftp_free_context(ctxt);
    return 0;
  }
}

// ftp_close_connection
// file netcam_ftp.c line 663
static signed int ftp_close_connection(struct ftp_context *ctxt)
{
  signed int res;
  struct anonymous$45 rfd;
  struct anonymous$45 efd;
  struct timeval tv;
  _Bool tmp_if_expr$1;
  if(ctxt == ((struct ftp_context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctxt->control_file_desc < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    close(ctxt->data_file_desc);
    ctxt->data_file_desc = -1;
    tv.tv_sec = (signed long int)15;
    tv.tv_usec = (signed long int)0;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfd)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rfd)->fds_bits[(signed long int)(ctxt->control_file_desc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfd)->fds_bits[(signed long int)(ctxt->control_file_desc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << ctxt->control_file_desc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    do
    {
      signed int ftp_close_connection$$1$$2$$__d0;
      signed int ftp_close_connection$$1$$2$$__d1;
      asm("cld; rep; stosq" : "=c"(ftp_close_connection$$1$$2$$__d0), "=D"(ftp_close_connection$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&efd)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&efd)->fds_bits[(signed long int)(ctxt->control_file_desc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&efd)->fds_bits[(signed long int)(ctxt->control_file_desc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << ctxt->control_file_desc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    res=select(ctxt->control_file_desc + 1, &rfd, (struct anonymous$45 *)(void *)0, &efd, &tv);
    if(!(res >= 0))
    {
      close(ctxt->control_file_desc);
      ctxt->control_file_desc = -1;
      return -1;
    }

    else
    {
      if(res == 0)
      {
        close(ctxt->control_file_desc);
        ctxt->control_file_desc = -1;
      }

      else
      {
        res=ftp_get_response(ctxt);
        if(!(res == 2))
        {
          close(ctxt->control_file_desc);
          ctxt->control_file_desc = -1;
          return -1;
        }

      }
      return 0;
    }
  }
}

// ftp_connect
// file netcam_ftp.h line 38
signed int ftp_connect(struct netcam_context *netcam)
{
  struct ftp_context *ctxt;
  struct hostent *hp;
  signed int port;
  signed int res;
  signed int addrlen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
  if(netcam == ((struct netcam_context *)NULL))
    return -1;

  else
  {
    ctxt = netcam->ftp;
    if(ctxt == ((struct ftp_context *)NULL))
      return -1;

    else
      if(netcam->connect_host == ((char *)NULL))
        return -1;

      else
      {
        port = netcam->connect_port;
        if(port == 0)
          port = 21;

        memset((void *)&ctxt->ftp_address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
        hp=gethostbyname(netcam->connect_host);
        if(hp == ((struct hostent *)NULL))
        {
          motion_log(3, (unsigned int)4, 1, "%s: gethostbyname failed in ftp_connect", (const void *)"ftp_connect");
          return -1;
        }

        else
          if((unsigned long int)(unsigned int)hp->h_length >= 5ul)
          {
            motion_log(3, (unsigned int)4, 1, "%s: gethostbyname address mismatch in ftp_connect", (const void *)"ftp_connect");
            return -1;
          }

          else
          {
            ((struct sockaddr_in *)&ctxt->ftp_address)->sin_family = (unsigned short int)2;
            memcpy((void *)&((struct sockaddr_in *)&ctxt->ftp_address)->sin_addr, (const void *)hp->h_addr_list[(signed long int)0], (unsigned long int)hp->h_length);
            unsigned short int return_value_htons$1;
            return_value_htons$1=htons((unsigned short int)port);
            ((struct sockaddr_in *)&ctxt->ftp_address)->sin_port = (unsigned short int)return_value_htons$1;
            ctxt->control_file_desc=socket(2, 1, 0);
            addrlen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
            if(!(ctxt->control_file_desc >= 0))
            {
              motion_log(3, (unsigned int)4, 1, "%s: socket failed", (const void *)"ftp_connect");
              return -1;
            }

            else
            {
              signed int return_value_connect$2;
              return_value_connect$2=connect(ctxt->control_file_desc, (struct sockaddr *)&ctxt->ftp_address, (unsigned int)addrlen);
              if(!(return_value_connect$2 >= 0))
              {
                motion_log(3, (unsigned int)4, 1, "%s: Failed to create a connection", (const void *)"ftp_connect");
                close(ctxt->control_file_desc);
                ctxt->control_file_desc = -1;
                return -1;
              }

              else
              {
                res=ftp_get_response(ctxt);
                if(!(res == 2))
                {
                  close(ctxt->control_file_desc);
                  ctxt->control_file_desc = -1;
                  return -1;
                }

                else
                {
                  res=ftp_send_user(ctxt);
                  if(!(res >= 0))
                  {
                    close(ctxt->control_file_desc);
                    ctxt->control_file_desc = -1;
                    return -1;
                  }

                  else
                  {
                    res=ftp_get_response(ctxt);
                    if(!(res == 2))
                    {
                      if(res == 3)
                        goto __CPROVER_DUMP_L12;

                      if(res == 1 || res == 4 || res == 5 || res == -1)
                        goto __CPROVER_DUMP_L13;

                    }

                    else
                    {
                      return 0;

                    __CPROVER_DUMP_L12:
                      ;
                      goto __CPROVER_DUMP_L14;
                    }

                  __CPROVER_DUMP_L13:
                    ;
                    close(ctxt->control_file_desc);
                    ctxt->control_file_desc = -1;
                    return -1;

                  __CPROVER_DUMP_L14:
                    ;
                    res=ftp_send_passwd(ctxt);
                    if(!(res >= 0))
                    {
                      close(ctxt->control_file_desc);
                      ctxt->control_file_desc = -1;
                      return -1;
                    }

                    else
                    {
                      res=ftp_get_response(ctxt);
                      if(!(res == 2))
                      {
                        if(res == 3)
                          goto __CPROVER_DUMP_L17;

                        if(res == 1 || res == 4 || res == 5 || res == -1)
                          goto __CPROVER_DUMP_L18;

                      }

                      else
                      {
                        goto __CPROVER_DUMP_L19;

                      __CPROVER_DUMP_L17:
                        ;
                        motion_log(4, (unsigned int)4, 0, "%s: FTP server asking for ACCT on anonymous", (const void *)"ftp_connect");
                      }

                    __CPROVER_DUMP_L18:
                      ;
                      close(ctxt->control_file_desc);
                      ctxt->control_file_desc = -1;
                      ctxt->control_file_desc = -1;
                      return -1;

                    __CPROVER_DUMP_L19:
                      ;
                      return 0;
                    }
                  }
                }
              }
            }
          }
      }
  }
}

// ftp_free_context
// file netcam_ftp.h line 36
void ftp_free_context(struct ftp_context *ctxt)
{
  if(!(ctxt == ((struct ftp_context *)NULL)))
  {
    if(!(ctxt->path == ((char *)NULL)))
      free((void *)ctxt->path);

    if(!(ctxt->user == ((char *)NULL)))
      free((void *)ctxt->user);

    if(!(ctxt->passwd == ((char *)NULL)))
      free((void *)ctxt->passwd);

    if(ctxt->control_file_desc >= 0)
      close(ctxt->control_file_desc);

    free((void *)ctxt);
  }

}

// ftp_get_connection
// file netcam_ftp.c line 494
static signed int ftp_get_connection(struct ftp_context *ctxt)
{
  char buf[200l];
  char *cur;
  signed int len;
  signed int i;
  signed int res;
  signed int on;
  unsigned char ad[6l];
  unsigned char *adp;
  unsigned char *portp;
  unsigned int temp[6l];
  struct sockaddr_in data_address;
  unsigned int data_address_length;
  if(ctxt == ((struct ftp_context *)NULL))
    return -1;

  else
  {
    if(!(ctxt->data_file_desc == -1))
      close(ctxt->data_file_desc);

    memset((void *)&data_address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    ctxt->data_file_desc=socket(2, 1, 6);
    if(!(ctxt->data_file_desc >= 0))
    {
      motion_log(3, (unsigned int)4, 1, "%s: socket failed", (const void *)"ftp_get_connection");
      return -1;
    }

    else
    {
      on = 1;
      signed int return_value_setsockopt$1;
      return_value_setsockopt$1=setsockopt(ctxt->data_file_desc, 1, 2, (const void *)(char *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$1 >= 0))
      {
        motion_log(3, (unsigned int)4, 1, "%s: setting socket option SO_REUSEADDR", (const void *)"ftp_get_connection");
        return -1;
      }

      else
      {
        ((struct sockaddr_in *)&data_address)->sin_family = (unsigned short int)2;
        data_address_length = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        if(!(ctxt->passive == 0))
        {
          snprintf(buf, sizeof(char [200l]) /*200ul*/ , "PASV\r\n");
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(buf);
          len = (signed int)return_value_strlen$2;
          signed long int return_value_send$3;
          return_value_send$3=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
          res = (signed int)return_value_send$3;
          if(!(res >= 0))
          {
            motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_get_connection", (const void *)"ftp_get_connection");
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return res;
          }

          res=ftp_get_response(ctxt);
          if(!(res == 2))
          {
            if(res == 5)
            {
              close(ctxt->data_file_desc);
              ctxt->data_file_desc = -1;
              return -1;
            }

            else
            {
              close(ctxt->data_file_desc);
              ctxt->data_file_desc = -1;
              ctxt->passive = 0;
            }
          }

          cur = &ctxt->control_buffer[(signed long int)ctxt->control_buffer_answer];
          for( ; (_Bool)1; cur = cur + 1l)
          {
            if((signed int)*cur >= 48)
            {
              if(!((signed int)*cur >= 58))
                goto __CPROVER_DUMP_L10;

            }

            if((signed int)*cur == 0)
              break;

          }

        __CPROVER_DUMP_L10:
          ;
          signed int return_value_sscanf$4;
          return_value_sscanf$4=sscanf(cur, "%u,%u,%u,%u,%u,%u", &temp[(signed long int)0], &temp[(signed long int)1], &temp[(signed long int)2], &temp[(signed long int)3], &temp[(signed long int)4], &temp[(signed long int)5]);
          if(!(return_value_sscanf$4 == 6))
          {
            motion_log(4, (unsigned int)4, 0, "%s: Invalid answer to PASV", (const void *)"ftp_get_connection");
            if(!(ctxt->data_file_desc == -1))
            {
              close(ctxt->data_file_desc);
              ctxt->data_file_desc = -1;
            }

            return -1;
          }

          i = 0;
          for( ; !(i >= 6); i = i + 1)
            ad[(signed long int)i] = (unsigned char)(temp[(signed long int)i] & (unsigned int)0xff);
          memcpy((void *)&((struct sockaddr_in *)&data_address)->sin_addr, (const void *)&ad[(signed long int)0], (unsigned long int)4);
          memcpy((void *)&((struct sockaddr_in *)&data_address)->sin_port, (const void *)&ad[(signed long int)4], (unsigned long int)2);
          signed int return_value_connect$5;
          return_value_connect$5=connect(ctxt->data_file_desc, (struct sockaddr *)&data_address, data_address_length);
          if(!(return_value_connect$5 >= 0))
          {
            motion_log(3, (unsigned int)4, 1, "%s: Failed to create a data connection", (const void *)"ftp_get_connection");
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return -1;
          }

        }

        else
        {
          getsockname(ctxt->control_file_desc, (struct sockaddr *)&data_address, &data_address_length);
          ((struct sockaddr_in *)&data_address)->sin_port = (unsigned short int)0;
          signed int return_value_bind$6;
          return_value_bind$6=bind(ctxt->data_file_desc, (struct sockaddr *)&data_address, data_address_length);
          if(!(return_value_bind$6 >= 0))
          {
            motion_log(3, (unsigned int)4, 1, "%s: bind failed", (const void *)"ftp_get_connection");
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return -1;
          }

          getsockname(ctxt->data_file_desc, (struct sockaddr *)&data_address, &data_address_length);
          signed int return_value_listen$7;
          return_value_listen$7=listen(ctxt->data_file_desc, 1);
          if(!(return_value_listen$7 >= 0))
          {
            motion_log(3, (unsigned int)4, 1, "%s: listen failed", (const void *)"ftp_get_connection");
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return -1;
          }

          adp = (unsigned char *)&((struct sockaddr_in *)&data_address)->sin_addr;
          portp = (unsigned char *)&((struct sockaddr_in *)&data_address)->sin_port;
          snprintf(buf, sizeof(char [200l]) /*200ul*/ , "PORT %d,%d,%d,%d,%d,%d\r\n", (signed int)adp[(signed long int)0] & 0xff, (signed int)adp[(signed long int)1] & 0xff, (signed int)adp[(signed long int)2] & 0xff, (signed int)adp[(signed long int)3] & 0xff, (signed int)portp[(signed long int)0] & 0xff, (signed int)portp[(signed long int)1] & 0xff);
          buf[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(buf);
          len = (signed int)return_value_strlen$8;
          signed long int return_value_send$9;
          return_value_send$9=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
          res = (signed int)return_value_send$9;
          if(!(res >= 0))
          {
            motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_get_connection", (const void *)"ftp_get_connection");
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return res;
          }

          res=ftp_get_response(ctxt);
          if(!(res == 2))
          {
            close(ctxt->data_file_desc);
            ctxt->data_file_desc = -1;
            return -1;
          }

        }
        return ctxt->data_file_desc;
      }
    }
  }
}

// ftp_get_more
// file netcam_ftp.c line 135
static signed int ftp_get_more(struct ftp_context *ctxt)
{
  signed int len;
  signed int size;
  _Bool tmp_if_expr$1;
  if(ctxt == ((struct ftp_context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctxt->control_file_desc < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    _Bool tmp_if_expr$2;
    if(!(ctxt->control_buffer_index >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = ctxt->control_buffer_index > 1024 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    else
    {
      _Bool tmp_if_expr$3;
      if(!(ctxt->control_buffer_used >= 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = ctxt->control_buffer_used > 1024 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return -1;

      else
        if(!(ctxt->control_buffer_used >= ctxt->control_buffer_index))
          return -1;

        else
        {
          if(ctxt->control_buffer_index >= 1)
          {
            memmove((void *)&ctxt->control_buffer[(signed long int)0], (const void *)&ctxt->control_buffer[(signed long int)ctxt->control_buffer_index], (unsigned long int)(ctxt->control_buffer_used - ctxt->control_buffer_index));
            ctxt->control_buffer_used = ctxt->control_buffer_used - ctxt->control_buffer_index;
            ctxt->control_buffer_index = 0;
          }

          size = 1024 - ctxt->control_buffer_used;
          if(size == 0)
            return 0;

          else
          {
            signed long int return_value_recv$4;
            return_value_recv$4=recv(ctxt->control_file_desc, (void *)&ctxt->control_buffer[(signed long int)ctxt->control_buffer_index], (unsigned long int)size, 0);
            len = (signed int)return_value_recv$4;
            if(!(len >= 0))
            {
              motion_log(3, (unsigned int)4, 1, "%s: recv failed in ftp_get_more", (const void *)"ftp_get_more");
              close(ctxt->control_file_desc);
              ctxt->control_file_desc = -1;
              return -1;
            }

            else
            {
              ctxt->control_buffer_used = ctxt->control_buffer_used + len;
              ctxt->control_buffer[(signed long int)ctxt->control_buffer_used] = (char)0;
              return len;
            }
          }
        }
    }
  }
}

// ftp_get_response
// file netcam_ftp.c line 193
static signed int ftp_get_response(struct ftp_context *ctxt)
{
  char *ptr;
  char *end;
  signed int len;
  signed int res = -1;
  signed int cur = -1;
  _Bool tmp_if_expr$1;
  if(ctxt == ((struct ftp_context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctxt->control_file_desc < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    do
    {

    get_more:
      ;
      len=ftp_get_more(ctxt);
      if(!(len >= 0))
        return -1;

      if(ctxt->control_buffer_used == 0)
      {
        if(len == 0)
          return -1;

      }

      ptr = &ctxt->control_buffer[(signed long int)ctxt->control_buffer_index];
      end = &ctxt->control_buffer[(signed long int)ctxt->control_buffer_used];
      while(!(ptr >= end))
      {
        cur=ftp_parse_response(ptr, (signed int)(end - ptr));
        if(cur >= 1)
        {
          res = cur;
          ptr = ptr + (signed long int)3;
          ctxt->control_buffer_answer = (signed int)(ptr - ctxt->control_buffer);
          for( ; !(ptr >= end); ptr = ptr + 1l)
            if((signed int)*ptr == 10)
              break;

          if((signed int)*ptr == 10)
            ptr = ptr + 1l;

          if((signed int)*ptr == 13)
            ptr = ptr + 1l;

          break;
        }

        for( ; !(ptr >= end); ptr = ptr + 1l)
          if((signed int)*ptr == 10)
            break;

        if(ptr >= end)
        {
          ctxt->control_buffer_index = ctxt->control_buffer_used;
          goto get_more;
        }

        if(!((signed int)*ptr == 13))
          ptr = ptr + 1l;

      }
    }
    while(!(res >= 0));
    ctxt->control_buffer_index = (signed int)(ptr - ctxt->control_buffer);
    return res / 100;
  }
}

// ftp_get_socket
// file netcam_ftp.h line 40
signed int ftp_get_socket(struct ftp_context *ctxt)
{
  char buf[300l];
  signed int res;
  signed int len;
  signed int acfd;
  _Bool tmp_if_expr$1;
  if(ctxt == ((struct ftp_context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctxt->path == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    ctxt->data_file_desc=ftp_get_connection(ctxt);
    if(ctxt->data_file_desc == -1)
      return -1;

    else
    {
      snprintf(buf, sizeof(char [300l]) /*300ul*/ , "RETR %s\r\n", ctxt->path);
      buf[(signed long int)(sizeof(char [300l]) /*300ul*/  - (unsigned long int)1)] = (char)0;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(buf);
      len = (signed int)return_value_strlen$2;
      signed long int return_value_send$3;
      return_value_send$3=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
      res = (signed int)return_value_send$3;
      if(!(res >= 0))
      {
        motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_get_socket", (const void *)"ftp_get_socket");
        close(ctxt->data_file_desc);
        ctxt->data_file_desc = -1;
        return res;
      }

      else
      {
        res=ftp_get_response(ctxt);
        if(!(res == 1))
        {
          close(ctxt->data_file_desc);
          ctxt->data_file_desc = -1;
          return -res;
        }

        else
        {
          if(ctxt->passive == 0)
          {
            struct sockaddr_in data_address;
            unsigned int data_address_length = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
            acfd=accept(ctxt->data_file_desc, (struct sockaddr *)&data_address, &data_address_length);
            if(!(acfd >= 0))
            {
              motion_log(3, (unsigned int)4, 1, "%s: accept in ftp_get_socket", (const void *)"ftp_get_socket");
              close(ctxt->data_file_desc);
              ctxt->data_file_desc = -1;
              return -1;
            }

            close(ctxt->data_file_desc);
            ctxt->data_file_desc = acfd;
          }

          return ctxt->data_file_desc;
        }
      }
    }
  }
}

// ftp_new_context
// file netcam_ftp.h line 35
struct ftp_context * ftp_new_context(void)
{
  struct ftp_context *ret;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct ftp_context) /*1104ul*/ );
  ret = (struct ftp_context *)return_value_mymalloc$1;
  memset((void *)ret, 0, sizeof(struct ftp_context) /*1104ul*/ );
  ret->control_file_desc = -1;
  ret->data_file_desc = -1;
  return ret;
}

// ftp_parse_response
// file netcam_ftp.c line 90
static signed int ftp_parse_response(char *buf, signed int len)
{
  signed int val = 0;
  if(!(len >= 3))
    return -1;

  else
  {
    _Bool tmp_if_expr$1;
    if((signed int)*buf >= 48)
      tmp_if_expr$1 = (signed int)*buf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      val = val * 10 + ((signed int)*buf - 48);

    else
      return 0;
    buf = buf + 1l;
    _Bool tmp_if_expr$2;
    if((signed int)*buf >= 48)
      tmp_if_expr$2 = (signed int)*buf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      val = val * 10 + ((signed int)*buf - 48);

    else
      return 0;
    buf = buf + 1l;
    _Bool tmp_if_expr$3;
    if((signed int)*buf >= 48)
      tmp_if_expr$3 = (signed int)*buf <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      val = val * 10 + ((signed int)*buf - 48);

    else
      return 0;
    buf = buf + 1l;
    if((signed int)*buf == 45)
      return -val;

    else
      return val;
  }
}

// ftp_quit
// file netcam_ftp.c line 327
static signed int ftp_quit(struct ftp_context *ctxt)
{
  char buf[200l];
  signed int len;
  signed int res;
  _Bool tmp_if_expr$1;
  if(ctxt == ((struct ftp_context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctxt->control_file_desc < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    snprintf(buf, sizeof(char [200l]) /*200ul*/ , "QUIT\r\n");
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    len = (signed int)return_value_strlen$2;
    signed long int return_value_send$3;
    return_value_send$3=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
    res = (signed int)return_value_send$3;
    if(!(res >= 0))
    {
      motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_quit", (const void *)"ftp_quit");
      return res;
    }

    else
      return 0;
  }
}

// ftp_read
// file netcam_ftp.h line 41
signed int ftp_read(struct ftp_context *ctxt, void *dest, signed int len)
{
  if(ctxt == ((struct ftp_context *)NULL))
    return -1;

  else
    if(!(ctxt->data_file_desc >= 0))
      return 0;

    else
      if(dest == NULL)
        return -1;

      else
        if(!(len >= 1))
          return 0;

        else
        {
          signed long int return_value_recv$1;
          return_value_recv$1=recv(ctxt->data_file_desc, dest, (unsigned long int)len, 0);
          len = (signed int)return_value_recv$1;
          if(!(len >= 1))
          {
            if(!(len >= 0))
              motion_log(3, (unsigned int)4, 1, "%s: recv failed in ftp_read", (const void *)"ftp_read");

            ftp_close_connection(ctxt);
          }

          return len;
        }
}

// ftp_send_passwd
// file netcam_ftp.c line 293
static signed int ftp_send_passwd(struct ftp_context *ctxt)
{
  char buf[200l];
  signed int len;
  signed int res;
  if(ctxt->passwd == ((char *)NULL))
    snprintf(buf, sizeof(char [200l]) /*200ul*/ , "PASS anonymous@\r\n");

  else
    snprintf(buf, sizeof(char [200l]) /*200ul*/ , "PASS %s\r\n", ctxt->passwd);
  buf[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (signed int)return_value_strlen$1;
  signed long int return_value_send$2;
  return_value_send$2=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
  res = (signed int)return_value_send$2;
  if(!(res >= 0))
  {
    motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_send_passwd", (const void *)"ftp_send_passwd");
    return res;
  }

  else
    return 0;
}

// ftp_send_type
// file netcam_ftp.h line 39
signed int ftp_send_type(struct ftp_context *ctxt, char type)
{
  char buf[100l];
  char utype;
  signed int len;
  signed int res;
  signed int return_value_toupper$1;
  return_value_toupper$1=toupper((signed int)type);
  utype = (char)return_value_toupper$1;
  snprintf(buf, sizeof(char [100l]) /*100ul*/ , "TYPE I\r\n");
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  len = (signed int)return_value_strlen$2;
  signed long int return_value_send$3;
  return_value_send$3=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
  res = (signed int)return_value_send$3;
  if(!(res >= 0))
  {
    motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_get_socket", (const void *)"ftp_send_type");
    close(ctxt->data_file_desc);
    ctxt->data_file_desc = -1;
    return res;
  }

  else
  {
    res=ftp_get_response(ctxt);
    if(!(res == 2))
    {
      close(ctxt->data_file_desc);
      ctxt->data_file_desc = -1;
      return -res;
    }

    else
      return 0;
  }
}

// ftp_send_user
// file netcam_ftp.c line 267
static signed int ftp_send_user(struct ftp_context *ctxt)
{
  char buf[200l];
  signed int len;
  signed int res;
  if(ctxt->user == ((char *)NULL))
    snprintf(buf, sizeof(char [200l]) /*200ul*/ , "USER anonymous\r\n");

  else
    snprintf(buf, sizeof(char [200l]) /*200ul*/ , "USER %s\r\n", ctxt->user);
  buf[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (signed int)return_value_strlen$1;
  signed long int return_value_send$2;
  return_value_send$2=send(ctxt->control_file_desc, (const void *)buf, (unsigned long int)len, 0);
  res = (signed int)return_value_send$2;
  if(!(res >= 0))
  {
    motion_log(3, (unsigned int)4, 1, "%s: send failed in ftp_send_user", (const void *)"ftp_send_user");
    return res;
  }

  else
    return 0;
}

// get_log_level_str
// file logger.h line 57
const char * get_log_level_str(unsigned int level)
{
  return log_level_str[(signed long int)level];
}

// get_log_type
// file logger.h line 54
signed int get_log_type(const char *type)
{
  unsigned int i;
  unsigned int ret = (unsigned int)0;
  unsigned int maxtype = (unsigned int)(sizeof(const char *[10l]) /*80ul*/  / sizeof(const char *) /*8ul*/ );
  i = (unsigned int)1;
  for( ; !(i >= maxtype); i = i + 1u)
  {
    signed int return_value_strncasecmp$1;
    return_value_strncasecmp$1=strncasecmp(type, log_type_str[(signed long int)i], (unsigned long int)3);
    if(return_value_strncasecmp$1 == 0)
    {
      ret = i;
      break;
    }

  }
  return (signed int)ret;
}

// get_log_type_str
// file logger.h line 55
const char * get_log_type_str(unsigned int type)
{
  return log_type_str[(signed long int)type];
}

// get_oformat
// file ffmpeg.c line 386
static struct AVOutputFormat * get_oformat(const char *codec, char *filename)
{
  const char *ext;
  struct AVOutputFormat *of = (struct AVOutputFormat *)(void *)0;
  signed int return_value_strcmp$9;
  return_value_strcmp$9=strcmp(codec, "mpeg1_tl");
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$9 == 0)
  {
    ext = ".mpg";
    of=av_guess_format("mpeg1video", (const char *)(void *)0, (const char *)(void *)0);
    if(!(of == ((struct AVOutputFormat *)NULL)))
      of->write_trailer = mpeg1_write_trailer;

  }

  else
  {
    return_value_strcmp$8=strcmp(codec, "mpeg1");
    if(return_value_strcmp$8 == 0)
    {
      motion_log(4, (unsigned int)3, 0, "%s: *** mpeg1 support for normal videos has been disabled ***", (const void *)"get_oformat");
      return (struct AVOutputFormat *)(void *)0;
    }

    else
    {
      return_value_strcmp$7=strcmp(codec, "mpeg4");
      if(return_value_strcmp$7 == 0)
      {
        ext = ".avi";
        of=av_guess_format("avi", (const char *)(void *)0, (const char *)(void *)0);
      }

      else
      {
        return_value_strcmp$6=strcmp(codec, "msmpeg4");
        if(return_value_strcmp$6 == 0)
        {
          ext = ".avi";
          of=av_guess_format("avi", (const char *)(void *)0, (const char *)(void *)0);
          if(!(of == ((struct AVOutputFormat *)NULL)))
            of->video_codec = (enum AVCodecID)AV_CODEC_ID_MSMPEG4V2;

        }

        else
        {
          return_value_strcmp$5=strcmp(codec, "swf");
          if(return_value_strcmp$5 == 0)
          {
            ext = ".swf";
            of=av_guess_format("swf", (const char *)(void *)0, (const char *)(void *)0);
          }

          else
          {
            return_value_strcmp$4=strcmp(codec, "flv");
            if(return_value_strcmp$4 == 0)
            {
              ext = ".flv";
              of=av_guess_format("flv", (const char *)(void *)0, (const char *)(void *)0);
              of->video_codec = (enum AVCodecID)AV_CODEC_ID_FLV1;
            }

            else
            {
              return_value_strcmp$3=strcmp(codec, "ffv1");
              if(return_value_strcmp$3 == 0)
              {
                ext = ".avi";
                of=av_guess_format("avi", (const char *)(void *)0, (const char *)(void *)0);
                if(!(of == ((struct AVOutputFormat *)NULL)))
                  of->video_codec = (enum AVCodecID)AV_CODEC_ID_FFV1;

              }

              else
              {
                return_value_strcmp$2=strcmp(codec, "mov");
                if(return_value_strcmp$2 == 0)
                {
                  ext = ".mov";
                  of=av_guess_format("mov", (const char *)(void *)0, (const char *)(void *)0);
                }

                else
                {
                  return_value_strcmp$1=strcmp(codec, "ogg");
                  if(return_value_strcmp$1 == 0)
                  {
                    ext = ".ogg";
                    of=av_guess_format("ogg", (const char *)(void *)0, (const char *)(void *)0);
                  }

                  else
                  {
                    motion_log(3, (unsigned int)3, 0, "%s: ffmpeg_video_codec option value %s is not supported", (const void *)"get_oformat", codec);
                    return (struct AVOutputFormat *)(void *)0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if(of == ((struct AVOutputFormat *)NULL))
  {
    motion_log(3, (unsigned int)3, 0, "%s: Could not guess format for %s", (const void *)"get_oformat", codec);
    return (struct AVOutputFormat *)(void *)0;
  }

  else
  {
    strncat(filename, ext, (unsigned long int)4);
    return of;
  }
}

// get_pgm
// file picture.h line 22
unsigned char * get_pgm(struct _IO_FILE *picture, signed int width, signed int height)
{
  signed int x = 0;
  signed int y = 0;
  signed int maxval;
  char line[256l];
  unsigned char *image;
  line[(signed long int)255] = (char)0;
  char *return_value_fgets$1;
  return_value_fgets$1=fgets(line, 255, picture);
  char *return_value_fgets$3;
  char *return_value_fgets$5;
  if(return_value_fgets$1 == ((char *)NULL))
  {
    motion_log(3, (unsigned int)9, 1, "%s: Could not read from ppm file", (const void *)"get_pgm");
    return (unsigned char *)(void *)0;
  }

  else
  {
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(line, "P5", (unsigned long int)2);
    if(!(return_value_strncmp$2 == 0))
    {
      motion_log(3, (unsigned int)9, 1, "%s: This is not a ppm file, starts with '%s'", (const void *)"get_pgm", (const void *)line);
      return (unsigned char *)(void *)0;
    }

    else
    {
      line[(signed long int)0] = (char)35;
      while((signed int)line[0l] == 35)
      {
        return_value_fgets$3=fgets(line, 255, picture);
        if(return_value_fgets$3 == ((char *)NULL))
          return (unsigned char *)(void *)0;

      }
      signed int return_value_sscanf$4;
      return_value_sscanf$4=sscanf(line, "%d %d", &x, &y);
      if(!(return_value_sscanf$4 == 2))
      {
        motion_log(3, (unsigned int)9, 1, "%s: Failed reading size in pgm file", (const void *)"get_pgm");
        return (unsigned char *)(void *)0;
      }

      else
        if(!(x == width) || !(y == height))
        {
          motion_log(3, (unsigned int)9, 1, "%s: Wrong image size %dx%d should be %dx%d", (const void *)"get_pgm", x, y, width, height);
          return (unsigned char *)(void *)0;
        }

        else
        {
          line[(signed long int)0] = (char)35;
          while((signed int)line[0l] == 35)
          {
            return_value_fgets$5=fgets(line, 255, picture);
            if(return_value_fgets$5 == ((char *)NULL))
              return (unsigned char *)(void *)0;

          }
          signed int return_value_sscanf$6;
          return_value_sscanf$6=sscanf(line, "%d", &maxval);
          if(!(return_value_sscanf$6 == 1))
          {
            motion_log(3, (unsigned int)9, 1, "%s: Failed reading maximum value in pgm file", (const void *)"get_pgm");
            return (unsigned char *)(void *)0;
          }

          else
          {
            void *return_value_mymalloc$7;
            return_value_mymalloc$7=mymalloc((unsigned long int)(width * height));
            image = (unsigned char *)return_value_mymalloc$7;
            y = 0;
            for( ; !(y >= height); y = y + 1)
            {
              unsigned long int return_value_fread$8;
              return_value_fread$8=fread((void *)&image[(signed long int)(y * width)], (unsigned long int)1, (unsigned long int)width, picture);
              if(!((signed int)return_value_fread$8 == width))
                motion_log(3, (unsigned int)9, 1, "%s: Failed reading image data from pgm file", (const void *)"get_pgm");

              x = 0;
              for( ; !(x >= width); x = x + 1)
                image[(signed long int)(y * width + x)] = (unsigned char)(((signed int)image[(signed long int)(y * width + x)] * 255) / maxval);
            }
            return image;
          }
        }
    }
  }
}

// grey2yuv420p
// file event.c line 533
static void grey2yuv420p(unsigned char *u, unsigned char *v, signed int width, signed int height)
{
  memset((void *)u, 128, (unsigned long int)((width * height) / 4));
  memset((void *)v, 128, (unsigned long int)((width * height) / 4));
}

// guarantee_huff_tables
// file jpegutils.c line 412
static void guarantee_huff_tables(struct jpeg_decompress_struct *dinfo)
{
  if(dinfo->dc_huff_tbl_ptrs[0l] == ((struct anonymous$14 *)NULL))
  {
    if(dinfo->dc_huff_tbl_ptrs[1l] == ((struct anonymous$14 *)NULL))
    {
      if(dinfo->ac_huff_tbl_ptrs[0l] == ((struct anonymous$14 *)NULL))
      {
        if(dinfo->ac_huff_tbl_ptrs[1l] == ((struct anonymous$14 *)NULL))
          std_huff_tables(dinfo);

      }

    }

  }

}

// handle_basic_auth
// file stream.c line 167
static void * handle_basic_auth(void *param)
{
  struct auth_param *p = (struct auth_param *)param;
  char buffer[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed long int length = (signed long int)1023;
  char *auth;
  char *h;
  char *authentication;
  pthread_mutex_lock(&stream_auth_mutex);
  p->thread_count = p->thread_count + 1l;
  pthread_mutex_unlock(&stream_auth_mutex);
  signed int return_value_read_http_request$1;
  return_value_read_http_request$1=read_http_request(p->sock, buffer, (signed int)length, (char *)(void *)0, 0);
  signed int return_value_fcntl$5;
  unsigned long int return_value_strlen$6;
  if(!(return_value_read_http_request$1 == 0))
  {
    auth=strstr(buffer, "Authorization: Basic");
    if(!(auth == ((char *)NULL)))
    {
      auth = auth + (signed long int)sizeof(char [21l]) /*21ul*/ ;
      h=strstr(auth, "\r\n");
      if(!(h == ((char *)NULL)))
      {
        *h = (char)0;
        if(!(p->conf->stream_authentication == ((const char *)NULL)))
        {
          char *userpass = (char *)(void *)0;
          unsigned long int auth_size;
          auth_size=strlen(p->conf->stream_authentication);
          void *return_value_mymalloc$2;
          return_value_mymalloc$2=mymalloc((unsigned long int)4 * ((auth_size + (unsigned long int)2) / (unsigned long int)3) + (unsigned long int)1);
          authentication = (char *)return_value_mymalloc$2;
          void *return_value_mymalloc$3;
          return_value_mymalloc$3=mymalloc(auth_size + (unsigned long int)4);
          userpass = (char *)return_value_mymalloc$3;
          memset((void *)userpass, 0, auth_size + (unsigned long int)4);
          strcpy(userpass, p->conf->stream_authentication);
          base64_encode(userpass, authentication, (signed int)auth_size);
          free((void *)userpass);
          signed int return_value_strcmp$4;
          return_value_strcmp$4=strcmp(auth, authentication);
          if(!(return_value_strcmp$4 == 0))
          {
            free((void *)authentication);
            goto Error;
          }

          free((void *)authentication);
        }

        return_value_fcntl$5=fcntl(p->sock, 4, p->sock_flags);
        if(!(return_value_fcntl$5 >= 0))
          motion_log(3, (unsigned int)2, 1, "%s: fcntl", (const void *)"handle_basic_auth");

        else
        {
          pthread_mutex_lock(&stream_auth_mutex);
          stream_add_client(&p->cnt->stream, p->sock);
          p->cnt->stream_count = p->cnt->stream_count + 1;
          p->thread_count = p->thread_count - 1l;
          pthread_mutex_unlock(&stream_auth_mutex);
          free((void *)p);
          pthread_exit((void *)0);
        }
      }

    }


  Error:
    ;
    static const char *handle_basic_auth$$1$$request_auth_response_template = "HTTP/1.0 401 Authorization Required\r\nServer: Motion/3.2.12+git20140228\r\nMax-Age: 0\r\nExpires: 0\r\nCache-Control: no-cache, private\r\nPragma: no-cache\r\nWWW-Authenticate: Basic realm=\"Motion Stream Security Access\"\r\n\r\n";
    return_value_strlen$6=strlen(handle_basic_auth$$1$$request_auth_response_template);
    write(p->sock, (const void *)handle_basic_auth$$1$$request_auth_response_template, return_value_strlen$6);
  }


Invalid_Request:
  ;
  close(p->sock);
  pthread_mutex_lock(&stream_auth_mutex);
  p->thread_count = p->thread_count - 1l;
  pthread_mutex_unlock(&stream_auth_mutex);
  free((void *)p);
  pthread_exit((void *)0);
}

// handle_get
// file webhttpd.c line 1944
static unsigned int handle_get(signed int client_socket, const char *url, void *userdata)
{
  struct context **cnt = (struct context **)userdata;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  if((signed int)*url == 47)
  {
    signed int i = 0;
    char *res = (char *)(void *)0;
    void *return_value_mymalloc$1;
    return_value_mymalloc$1=mymalloc((unsigned long int)2048);
    res = (char *)return_value_mymalloc$1;
    do
    {
      i = i + 1;
      if(cnt[(signed long int)i] == ((struct context *)NULL))
        break;

    }
    while((_Bool)1);
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(url, "/");
    if(return_value_strcmp$6 == 0)
    {
      signed int y;
      if(!((*cnt)->conf.webcontrol_html_output == 0))
      {
        send_template_ini_client(client_socket, ini_template);
        sprintf(res, "<b>Motion 3.2.12+git20140228 Running [%hu] Threads</b><br>\n<a href='/0/'>All</a><br>\n", i);
        send_template(client_socket, res);
        y = 1;
        for( ; !(y >= i); y = y + 1)
        {
          sprintf(res, "<a href='/%hu/'>Thread %hu</a><br>\n", y, y);
          send_template(client_socket, res);
        }
        send_template_end_client(client_socket);
      }

      else
      {
        send_template_ini_client_raw(client_socket);
        sprintf(res, "Motion 3.2.12+git20140228 Running [%hu] Threads\n0\n", i);
        send_template_raw(client_socket, res);
        y = 1;
        for( ; !(y >= i); y = y + 1)
        {
          sprintf(res, "%hu\n", y);
          send_template_raw(client_socket, res);
        }
      }
    }

    else
    {
      char command[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char slash;
      signed int thread = -1;
      unsigned long int length_uri = (unsigned long int)0;
      char *pointer = (char *)url;
      length_uri=strlen(url);
      pointer = pointer + 1l;
      length_uri = length_uri - 1ul;
      warningkill=sscanf(pointer, "%d%c", &thread, &slash);
      if(!(thread == -1) && !(thread >= i))
      {
        if(thread >= 10)
        {
          pointer = pointer + (signed long int)2;
          length_uri = length_uri - (unsigned long int)2;
        }

        else
        {
          pointer = pointer + 1l;
          length_uri = length_uri - 1ul;
        }
        if((signed int)slash == 47)
        {
          pointer = pointer + 1l;
          length_uri = length_uri - 1ul;
        }

        if(!(length_uri == 0ul))
        {
          warningkill=sscanf(pointer, "%255[a-z]%c", (const void *)command, &slash);
          signed int return_value_strcmp$5;
          return_value_strcmp$5=strcmp(command, "config");
          if(return_value_strcmp$5 == 0)
          {
            pointer = pointer + (signed long int)6;
            length_uri = length_uri - (unsigned long int)6;
            if(length_uri == 0ul)
            {
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n<a href=/%hd/config/list>list</a><br>\n<a href=/%hd/config/write>write</a><br>\n<a href=/%hd/config/set>set</a><br>\n<a href=/%hd/config/get>get</a><br>\n", thread, thread, thread, thread, thread, thread);
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "Thread %hd\nlist\nwrite\nset\nget\n", thread);
                send_template_raw(client_socket, res);
              }
            }

            else
              if((signed int)slash == 47 && length_uri >= 4ul)
              {
                pointer = pointer + 1l;
                length_uri = length_uri - 1ul;
                config(pointer, res, (unsigned int)length_uri, (unsigned int)thread, client_socket, (void *)cnt);
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                  response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                else
                  response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
          }

          else
          {
            return_value_strcmp$4=strcmp(command, "action");
            if(return_value_strcmp$4 == 0)
            {
              pointer = pointer + (signed long int)6;
              length_uri = length_uri - (unsigned long int)6;
              if(length_uri == 0ul)
              {
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  send_template_ini_client(client_socket, ini_template);
                  sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n<a href=/%hd/action/makemovie>makemovie</a><br>\n<a href=/%hd/action/snapshot>snapshot</a><br>\n<a href=/%hd/action/restart>restart</a><br>\n<a href=/%hd/action/quit>quit</a><br>\n", thread, thread, thread, thread, thread, thread);
                  send_template(client_socket, res);
                  send_template_end_client(client_socket);
                }

                else
                {
                  send_template_ini_client_raw(client_socket);
                  sprintf(res, "Thread %hd\nmakemovie\nsnapshot\nrestart\nquit\n", thread);
                  send_template_raw(client_socket, res);
                }
              }

              else
                if((signed int)slash == 47 && length_uri >= 5ul)
                {
                  unsigned int ret = (unsigned int)1;
                  pointer = pointer + 1l;
                  length_uri = length_uri - 1ul;
                  ret=action(pointer, res, (unsigned int)length_uri, (unsigned int)thread, client_socket, (void *)cnt);
                  free((void *)res);
                  return ret;
                }

                else
                  if(!((*cnt)->conf.webcontrol_html_output == 0))
                    response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                  else
                    response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
            }

            else
            {
              return_value_strcmp$3=strcmp(command, "detection");
              if(return_value_strcmp$3 == 0)
              {
                pointer = pointer + (signed long int)9;
                length_uri = length_uri - (unsigned long int)9;
                if(length_uri == 0ul)
                {
                  if(!((*cnt)->conf.webcontrol_html_output == 0))
                  {
                    send_template_ini_client(client_socket, ini_template);
                    sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n<a href=/%hd/detection/status>status</a><br>\n<a href=/%hd/detection/start>start</a><br>\n<a href=/%hd/detection/pause>pause</a><br>\n<a href=/%hd/detection/connection>connection</a><br>\n", thread, thread, thread, thread, thread, thread);
                    send_template(client_socket, res);
                    send_template_end_client(client_socket);
                  }

                  else
                  {
                    send_template_ini_client_raw(client_socket);
                    sprintf(res, "Thread %hd\nstatus\nstart\npause\nconnection\n", thread);
                    send_template_raw(client_socket, res);
                  }
                }

                else
                  if((signed int)slash == 47 && length_uri >= 6ul)
                  {
                    pointer = pointer + 1l;
                    length_uri = length_uri - 1ul;
                    detection(pointer, res, (unsigned int)length_uri, (unsigned int)thread, client_socket, (void *)cnt);
                  }

                  else
                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                      response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                    else
                      response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
              }

              else
              {
                return_value_strcmp$2=strcmp(command, "track");
                if(return_value_strcmp$2 == 0)
                {
                  pointer = pointer + (signed long int)5;
                  length_uri = length_uri - (unsigned long int)5;
                  if(length_uri == 0ul)
                  {
                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                    {
                      send_template_ini_client(client_socket, ini_template);
                      sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n<a href=/%hd/track/set>track set pan/tilt</a><br>\n<a href=/%hd/track/center>track center</a><br>\n<a href=/%hd/track/auto>track auto</a><br>\n<a href=/%hd/track/status>track status</a><br>\n", thread, thread, thread, thread, thread, thread);
                      send_template(client_socket, res);
                      send_template_end_client(client_socket);
                    }

                    else
                    {
                      send_template_ini_client_raw(client_socket);
                      sprintf(res, "Thread %hd\nset pan/tilt\ncenter\nauto\nstatus\n", thread);
                      send_template_raw(client_socket, res);
                    }
                  }

                  else
                    if((signed int)slash == 47 && length_uri >= 4ul)
                    {
                      pointer = pointer + 1l;
                      length_uri = length_uri - 1ul;
                      if(!(cnt[(signed long int)thread]->track.type == 0u))
                        track(pointer, res, (unsigned int)length_uri, (unsigned int)thread, client_socket, (void *)cnt);

                      else
                        if(!((*cnt)->conf.webcontrol_html_output == 0))
                        {
                          sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
                          response_client(client_socket, not_track, res);
                        }

                        else
                          response_client(client_socket, not_track_raw, (char *)(void *)0);
                    }

                    else
                      if(!((*cnt)->conf.webcontrol_html_output == 0))
                      {
                        sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
                        response_client(client_socket, not_found_response_valid_command, res);
                      }

                      else
                        response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
                }

                else
                  if(!((*cnt)->conf.webcontrol_html_output == 0))
                  {
                    sprintf(res, "<a href=/%hd/>&lt;&ndash; back</a>\n", thread);
                    response_client(client_socket, not_found_response_valid_command, res);
                  }

                  else
                    response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
              }
            }
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            send_template_ini_client(client_socket, ini_template);
            sprintf(res, "<a href=/>&lt;&ndash; back</a><br><br>\n<b>Thread %hd</b><br>\n<a href='/%hd/config'>config</a><br>\n<a href='/%hd/action'>action</a><br>\n<a href='/%hd/detection'>detection</a><br>\n<a href='/%hd/track'>track</a><br>\n", thread, thread, thread, thread, thread);
            send_template(client_socket, res);
            send_template_end_client(client_socket);
          }

          else
          {
            send_template_ini_client_raw(client_socket);
            sprintf(res, "Thread %hd\nconfig\naction\ndetection\ntrack\n", thread);
            send_template_raw(client_socket, res);
          }
      }

      else
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          sprintf(res, "<a href=/>&lt;&ndash; back</a>\n");
          response_client(client_socket, not_found_response_valid, res);
        }

        else
          response_client(client_socket, not_found_response_valid_raw, (char *)(void *)0);
    }
    free((void *)res);
  }

  else
    if(!((*cnt)->conf.webcontrol_html_output == 0))
      response_client(client_socket, not_found_response_template, (char *)(void *)0);

    else
      response_client(client_socket, not_found_response_template_raw, (char *)(void *)0);
  return (unsigned int)1;
}

// handle_md5_digest
// file stream.c line 386
static void * handle_md5_digest(void *param)
{
  struct auth_param *p = (struct auth_param *)param;
  char buffer[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed long int length = (signed long int)1023;
  char *auth;
  char *h;
  char *username;
  char *realm;
  char *uri;
  char *nonce;
  char *response;
  signed int username_len;
  signed int realm_len;
  signed int uri_len;
  signed int nonce_len;
  signed int response_len;
  char server_nonce[17l];
  char server_uri[512l];
  char *server_user = (char *)(void *)0;
  char *server_pass = (char *)(void *)0;
  unsigned int rand1;
  unsigned int rand2;
  char HA1[33l];
  char HA2[33l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char server_response[33l];
  pthread_mutex_lock(&stream_auth_mutex);
  p->thread_count = p->thread_count + 1l;
  pthread_mutex_unlock(&stream_auth_mutex);
  set_sock_timeout(p->sock, 100);
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  srand((unsigned int)return_value_time$1);
  signed int return_value_rand$2;
  return_value_rand$2=rand();
  rand1 = (unsigned int)((42000000.0 * (double)return_value_rand$2) / ((double)2147483647 + 1.0));
  signed int return_value_rand$3;
  return_value_rand$3=rand();
  rand2 = (unsigned int)((42000000.0 * (double)return_value_rand$3) / ((double)2147483647 + 1.0));
  snprintf(server_nonce, (unsigned long int)17, "%08x%08x", rand1, rand2);
  void *return_value_malloc$4;
  unsigned long int return_value_strlen$5;
  void *return_value_malloc$6;
  unsigned long int return_value_strlen$7;
  unsigned long int return_value_strlen$8;
  signed int return_value_strcmp$10;
  signed int return_value_fcntl$16;
  if(p->conf->stream_authentication == ((const char *)NULL))
    motion_log(3, (unsigned int)2, 1, "%s: Error no authentication data", (const void *)"handle_md5_digest");

  else
  {
    h=strstr(p->conf->stream_authentication, ":");
    if(h == ((char *)NULL))
      motion_log(3, (unsigned int)2, 1, "%s: Error no authentication data (no ':' found)", (const void *)"handle_md5_digest");

    else
    {
      return_value_malloc$4=malloc((unsigned long int)((h - p->conf->stream_authentication) + (signed long int)1));
      server_user = (char *)return_value_malloc$4;
      return_value_strlen$5=strlen(h);
      return_value_malloc$6=malloc(return_value_strlen$5 + (unsigned long int)1);
      server_pass = (char *)return_value_malloc$6;
      if(server_pass == ((char *)NULL) || server_user == ((char *)NULL))
        motion_log(3, (unsigned int)2, 1, "%s: Error malloc failed", (const void *)"handle_md5_digest");

      else
      {
        strncpy(server_user, p->conf->stream_authentication, (unsigned long int)(h - p->conf->stream_authentication));
        server_user[h - p->conf->stream_authentication] = (char)0;
        return_value_strlen$7=strlen(h + (signed long int)1);
        strncpy(server_pass, h + (signed long int)1, return_value_strlen$7);
        return_value_strlen$8=strlen(h + (signed long int)1);
        server_pass[(signed long int)return_value_strlen$8] = (char)0;
        while((_Bool)1)
        {
          signed int return_value_read_http_request$9;
          return_value_read_http_request$9=read_http_request(p->sock, buffer, (signed int)length, server_uri, 512 - 1);
          if(return_value_read_http_request$9 == 0)
            goto Invalid_Request;

          auth=strstr(buffer, "Authorization: Digest");
          if(!(auth == ((char *)NULL)))
          {
            auth = auth + (signed long int)sizeof(char [22l]) /*22ul*/ ;
            h=strstr(auth, "\r\n");
            if(!(h == ((char *)NULL)))
            {
              *h = (char)0;
              h=strstr(auth, "username=\"");
              if(!(h == ((char *)NULL)))
              {
                username = h + (signed long int)10;
                h=strstr(username + (signed long int)1, "\"");
                if(!(h == ((char *)NULL)))
                {
                  username_len = (signed int)(h - username);
                  h=strstr(auth, "realm=\"");
                  if(!(h == ((char *)NULL)))
                  {
                    realm = h + (signed long int)7;
                    h=strstr(realm + (signed long int)1, "\"");
                    if(!(h == ((char *)NULL)))
                    {
                      realm_len = (signed int)(h - realm);
                      h=strstr(auth, "uri=\"");
                      if(!(h == ((char *)NULL)))
                      {
                        uri = h + (signed long int)5;
                        h=strstr(uri + (signed long int)1, "\"");
                        if(!(h == ((char *)NULL)))
                        {
                          uri_len = (signed int)(h - uri);
                          h=strstr(auth, "nonce=\"");
                          if(!(h == ((char *)NULL)))
                          {
                            nonce = h + (signed long int)7;
                            h=strstr(nonce + (signed long int)1, "\"");
                            if(!(h == ((char *)NULL)))
                            {
                              nonce_len = (signed int)(h - nonce);
                              h=strstr(auth, "response=\"");
                              if(!(h == ((char *)NULL)))
                              {
                                response = h + (signed long int)10;
                                h=strstr(response + (signed long int)1, "\"");
                                if(!(h == ((char *)NULL)))
                                {
                                  response_len = (signed int)(h - response);
                                  username[(signed long int)username_len] = (char)0;
                                  realm[(signed long int)realm_len] = (char)0;
                                  uri[(signed long int)uri_len] = (char)0;
                                  nonce[(signed long int)nonce_len] = (char)0;
                                  response[(signed long int)response_len] = (char)0;
                                  DigestCalcHA1((char *)"md5", server_user, (char *)"Motion Stream Security Access", server_pass, (char *)server_nonce, (char *)(void *)0, HA1);
                                  DigestCalcResponse(HA1, server_nonce, (char *)(void *)0, (char *)(void *)0, (char *)"", (char *)"GET", server_uri, HA2, server_response);
                                  return_value_strcmp$10=strcmp(server_response, response);
                                  if(return_value_strcmp$10 == 0)
                                    break;

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }


        Error:
          ;
          signed int return_value_rand$11;
          return_value_rand$11=rand();
          rand1 = (unsigned int)((42000000.0 * (double)return_value_rand$11) / ((double)2147483647 + 1.0));
          signed int return_value_rand$12;
          return_value_rand$12=rand();
          rand2 = (unsigned int)((42000000.0 * (double)return_value_rand$12) / ((double)2147483647 + 1.0));
          snprintf(server_nonce, (unsigned long int)17, "%08x%08x", rand1, rand2);
          unsigned long int return_value_strlen$13;
          static const char *auth_failed_html_template = "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n<HTML><HEAD>\r\n<TITLE>401 Authorization Required</TITLE>\r\n</HEAD><BODY>\r\n<H1>Authorization Required</H1>\r\nThis server could not verify that you are authorized to access the document requested.  Either you supplied the wrong credentials (e.g., bad password), or your browser doesn't understand how to supply the credentials required.\r\n</BODY></HTML>\r\n";
          return_value_strlen$13=strlen(auth_failed_html_template);
          static const char *handle_md5_digest$$1$$request_auth_response_template = "HTTP/1.0 401 Authorization Required\r\nServer: Motion/3.2.12+git20140228\r\nMax-Age: 0\r\nExpires: 0\r\nCache-Control: no-cache, private\r\nPragma: no-cache\r\nWWW-Authenticate: Digest";
          snprintf(buffer, (unsigned long int)length, "%s realm=\"Motion Stream Security Access\", nonce=\"%s\"\r\nContent-Type: text/html\r\nKeep-Alive: timeout=%i\r\nConnection: keep-alive\r\nContent-Length: %Zu\r\n\r\n", handle_md5_digest$$1$$request_auth_response_template, (const void *)server_nonce, 100, return_value_strlen$13);
          unsigned long int return_value_strlen$14;
          return_value_strlen$14=strlen(buffer);
          write(p->sock, (const void *)buffer, return_value_strlen$14);
          unsigned long int return_value_strlen$15;
          return_value_strlen$15=strlen(auth_failed_html_template);
          write(p->sock, (const void *)auth_failed_html_template, return_value_strlen$15);
        }
        return_value_fcntl$16=fcntl(p->sock, 4, p->sock_flags);
        if(!(return_value_fcntl$16 >= 0))
        {
          motion_log(3, (unsigned int)2, 1, "%s: fcntl", (const void *)"handle_md5_digest");
          goto Error;
        }

        if(!(server_user == ((char *)NULL)))
          free((void *)server_user);

        if(!(server_pass == ((char *)NULL)))
          free((void *)server_pass);

        pthread_mutex_lock(&stream_auth_mutex);
        stream_add_client(&p->cnt->stream, p->sock);
        p->cnt->stream_count = p->cnt->stream_count + 1;
        p->thread_count = p->thread_count - 1l;
        pthread_mutex_unlock(&stream_auth_mutex);
        free((void *)p);
        pthread_exit((void *)0);
      }
    }
  }

InternalError:
  ;
  if(!(server_user == ((char *)NULL)))
    free((void *)server_user);

  if(!(server_pass == ((char *)NULL)))
    free((void *)server_pass);

  unsigned long int return_value_strlen$17;
  static const char *internal_error_template = "HTTP/1.0 500 Internal Server Error\r\nServer: Motion/3.2.12+git20140228\r\nContent-Type: text/html\r\nConnection: Close\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n<HTML><HEAD>\r\n<TITLE>500 Internal Server Error</TITLE>\r\n</HEAD><BODY>\r\n<H1>500 Internal Server Error</H1>\r\n</BODY></HTML>\r\n";
  return_value_strlen$17=strlen(internal_error_template);
  write(p->sock, (const void *)internal_error_template, return_value_strlen$17);

Invalid_Request:
  ;
  close(p->sock);
  pthread_mutex_lock(&stream_auth_mutex);
  p->thread_count = p->thread_count - 1l;
  pthread_mutex_unlock(&stream_auth_mutex);
  free((void *)p);
  pthread_exit((void *)0);
}

// header_extract_number
// file netcam_wget.h line 94
signed int header_extract_number(const char *header, void *closure)
{
  const char *p = header;
  signed long int result = (signed long int)0;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*p]) == 0)
      break;

    result = (signed long int)10 * result + (signed long int)((signed int)*p - 48);
    p = p + 1l;
  }
  while((_Bool)1);
  if(p == header)
    return 0;

  else
  {
    signed int return_value_skip_lws$2;
    return_value_skip_lws$2=skip_lws(p);
    p = p + (signed long int)return_value_skip_lws$2;
    *((signed long int *)closure) = result;
    if(!(*p == 0))
      return 0;

    else
      return 1;
  }
}

// header_get
// file netcam_wget.h line 90
signed int header_get(struct netcam_context *netcam, char **hdr, enum header_get_flags flags)
{
  signed int i;
  signed int bufsize = 80;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc((unsigned long int)bufsize);
  *hdr = (char *)return_value_mymalloc$1;
  i = 0;
  void *return_value_myrealloc$2;
  char *tmp_post$3;
  signed int tmp_if_expr$5;
  char *tmp_post$4;
  _Bool tmp_if_expr$7;
  const unsigned short int **return_value___ctype_b_loc$9;
  for( ; (_Bool)1; i = i + 1)
  {
    signed int res;
    if(!(bufsize + -1 >= i))
    {
      bufsize = bufsize << 1;
      return_value_myrealloc$2=myrealloc((void *)*hdr, (unsigned long int)bufsize, "");
      *hdr = (char *)return_value_myrealloc$2;
    }

    signed int tmp_if_expr$6;
    if(!(netcam->response->buffer_left == 0ul))
    {
      netcam->response->buffer_left = netcam->response->buffer_left - 1ul;
      tmp_post$3 = netcam->response->buffer_pos;
      netcam->response->buffer_pos = netcam->response->buffer_pos + 1l;
      *((char *)(*hdr + (signed long int)i)) = *tmp_post$3;
      tmp_if_expr$6 = 1;
    }

    else
    {
      netcam->response->buffer_pos = netcam->response->buffer;
      netcam->response->ret=rbuf_read_bufferful(netcam);
      if(!(netcam->response->ret >= 1))
        tmp_if_expr$5 = netcam->response->ret;

      else
      {
        netcam->response->buffer_left = (unsigned long int)(netcam->response->ret - 1);
        tmp_post$4 = netcam->response->buffer_pos;
        netcam->response->buffer_pos = netcam->response->buffer_pos + 1l;
        *((char *)(*hdr + (signed long int)i)) = *tmp_post$4;
        tmp_if_expr$5 = 1;
      }
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    res = tmp_if_expr$6;
    if(res == 1)
    {
      if((signed int)(*hdr)[(signed long int)i] == 10)
      {
        _Bool tmp_if_expr$8;
        if(i == 0 || !((HG_NO_CONTINUATIONS & (signed int)flags) == 0))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          if(i == 1)
            tmp_if_expr$7 = (signed int)(*hdr)[(signed long int)0] == 13 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$8)
        {
          char next;
          res=rbuf_peek(netcam, &next);
          if(res == 0)
          {
            (*hdr)[(signed long int)i] = (char)0;
            return 2;
          }

          else
            if(res == -1)
            {
              (*hdr)[(signed long int)i] = (char)0;
              return 1;
            }

          if((signed int)next == 9 || (signed int)next == 32)
            goto __CPROVER_DUMP_L21;

        }

        for( ; i >= 1; i = i - 1)
        {
          return_value___ctype_b_loc$9=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)(*hdr)[(signed long int)(i + -1)]]) == 0)
            break;

        }
        (*hdr)[(signed long int)i] = (char)0;
        break;
      }

    }

    else
      if(res == 0)
      {
        (*hdr)[(signed long int)i] = (char)0;
        return 2;
      }

      else
      {
        (*hdr)[(signed long int)i] = (char)0;
        return 1;
      }

  __CPROVER_DUMP_L21:
    ;
  }
  return 0;
}

// header_process
// file netcam_wget.h line 91
signed int header_process(const char *header, const char *name, signed int (*procfun)(const char *, void *), void *arg)
{
  signed int return_value_tolower$1;
  signed int return_value_tolower$2;
  for( ; !(*name == 0); header = header + 1l)
  {
    return_value_tolower$1=tolower((signed int)*name);
    return_value_tolower$2=tolower((signed int)*header);
    if(!(return_value_tolower$1 == return_value_tolower$2))
      break;

    name = name + 1l;
  }
  _Bool tmp_if_expr$4;
  const char *tmp_post$3;
  if(!(*name == 0))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    tmp_post$3 = header;
    header = header + 1l;
    tmp_if_expr$4 = (signed int)*tmp_post$3 != 58 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
    return 0;

  else
  {
    signed int return_value_skip_lws$5;
    return_value_skip_lws$5=skip_lws(header);
    header = header + (signed long int)return_value_skip_lws$5;
    signed int return_value;
    return_value=procfun(header, arg);
    return return_value;
  }
}

// header_strdup
// file netcam_wget.c line 189
signed int header_strdup(const char *header, void *closure)
{
  *((char **)closure)=mystrdup(header);
  return 1;
}

// http_acceptsock
// file stream.c line 797
static signed int http_acceptsock(signed int sl)
{
  signed int sc;
  unsigned long int i;
  struct sockaddr_storage sin;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  sc=accept(sl, (struct sockaddr *)&sin, &addrlen);
  if(sc >= 0)
  {
    i = (unsigned long int)1;
    ioctl(sc, (unsigned long int)0x5421, &i);
    return sc;
  }

  else
  {
    motion_log(2, (unsigned int)2, 1, "%s: motion-stream accept()", (const void *)"http_acceptsock");
    return -1;
  }
}

// http_bindsock
// file stream.c line 711
signed int http_bindsock(signed int port, signed int local, signed int ipv6_enabled)
{
  signed int sl = -1;
  signed int optval;
  struct addrinfo hints;
  struct addrinfo *res = (struct addrinfo *)(void *)0;
  struct addrinfo *ressave = (struct addrinfo *)(void *)0;
  char portnumber[10l];
  char hbuf[1025l];
  char sbuf[32l];
  snprintf(portnumber, sizeof(char [10l]) /*10ul*/ , "%u", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if(ipv6_enabled == 0)
    hints.ai_family = 2;

  else
    hints.ai_family = 0;
  hints.ai_socktype = 1;
  optval=getaddrinfo(local != 0 ? "localhost" : (char *)(void *)0, portnumber, &hints, &res);
  if(!(optval == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(optval);
    motion_log(2, (unsigned int)2, 1, "%s: getaddrinfo() for motion-stream socket failed: %s", (const void *)"http_bindsock", return_value_gai_strerror$1);
    if(!(res == ((struct addrinfo *)NULL)))
      freeaddrinfo(res);

    return -1;
  }

  ressave = res;
  for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
  {
    sl=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
    if(sl >= 0)
    {
      optval = 1;
      setsockopt(sl, 1, 2, (const void *)&optval, (unsigned int)sizeof(signed int) /*4ul*/ );
      motion_log(5, (unsigned int)2, 0, "%s: motion-stream testing : %s addr: %s port: %s", (const void *)"http_bindsock", res->ai_family == 2 ? "IPV4" : "IPV6", (const void *)hbuf, (const void *)sbuf);
      signed int return_value_bind$2;
      return_value_bind$2=bind(sl, res->ai_addr, res->ai_addrlen);
      if(return_value_bind$2 == 0)
      {
        motion_log(5, (unsigned int)2, 0, "%s: motion-stream Bound : %s addr: %s port: %s", (const void *)"http_bindsock", res->ai_family == 2 ? "IPV4" : "IPV6", (const void *)hbuf, (const void *)sbuf);
        break;
      }

      motion_log(2, (unsigned int)2, 1, "%s: motion-stream bind() failed, retrying", (const void *)"http_bindsock");
      close(sl);
      sl = -1;
    }

    motion_log(3, (unsigned int)2, 1, "%s: motion-stream socket failed, retrying", (const void *)"http_bindsock");
  }
  freeaddrinfo(ressave);
  if(!(sl >= 0))
  {
    motion_log(2, (unsigned int)2, 1, "%s: motion-stream creating socket/bind ERROR", (const void *)"http_bindsock");
    return -1;
  }

  else
  {
    signed int return_value_listen$3;
    return_value_listen$3=listen(sl, 10);
    if(return_value_listen$3 == -1)
    {
      motion_log(2, (unsigned int)2, 1, "%s: motion-stream listen() ERROR", (const void *)"http_bindsock");
      close(sl);
      sl = -1;
    }

    return sl;
  }
}

// http_process_type
// file netcam_wget.h line 77
signed int http_process_type(const char *hdr, void *arg)
{
  char **result = (char **)arg;
  const char *p;
  p=strchr(hdr, 59);
  unsigned long int return_value_strlen$1;
  if(p == ((const char *)NULL))
  {
    return_value_strlen$1=strlen(hdr);
    p = hdr + (signed long int)return_value_strlen$1;
  }

  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !(hdr >= p); p = p - 1l)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)p[-1l]]) == 0)
      break;

  }
  *result=strdupdelim(hdr, p);
  return 1;
}

// http_result_code
// file netcam_wget.h line 97
signed int http_result_code(const char *header)
{
  char *cptr;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(header, "HTTP", (unsigned long int)4);
  if(!(return_value_strncmp$1 == 0))
    return -1;

  else
  {
    cptr=strchr(header + (signed long int)4, 32);
    if(cptr == ((char *)NULL))
      return -1;

    else
    {
      signed int return_value_atoi$2;
      return_value_atoi$2=atoi(cptr + (signed long int)1);
      return return_value_atoi$2;
    }
  }
}

// httpd_run
// file webhttpd.c line 2388
void httpd_run(struct context **cnt)
{
  signed int sd = -1;
  signed int client_socket_fd;
  signed int val;
  unsigned int client_sent_quit_message = (unsigned int)1;
  unsigned int closehttpd = (unsigned int)0;
  struct addrinfo hints;
  struct addrinfo *res = (struct addrinfo *)(void *)0;
  struct addrinfo *ressave = (struct addrinfo *)(void *)0;
  struct sigaction act;
  char *authentication = (char *)(void *)0;
  char portnumber[10l];
  char hbuf[1025l];
  char sbuf[32l];
  pthread_mutex_init(&httpd_mutex, (const union anonymous$31 *)(void *)0);
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  sigemptyset(&act.sa_mask);
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
  sigaction(17, &act, (struct sigaction *)(void *)0);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if((*cnt)->conf.ipv6_enabled == 0)
    hints.ai_family = 2;

  else
    hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(portnumber, sizeof(char [10l]) /*10ul*/ , "%u", cnt[(signed long int)0]->conf.webcontrol_port);
  val=getaddrinfo(cnt[(signed long int)0]->conf.webcontrol_localhost != 0 ? "localhost" : (char *)(void *)0, portnumber, &hints, &res);
  if(!(val == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(val);
    motion_log(2, (unsigned int)2, 1, "%s: getaddrinfo() for httpd socket failed: %s", (const void *)"httpd_run", return_value_gai_strerror$1);
    if(!(res == ((struct addrinfo *)NULL)))
      freeaddrinfo(res);

    pthread_mutex_destroy(&httpd_mutex);
    goto __CPROVER_DUMP_L19;
  }

  ressave = res;
  for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
  {
    sd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
    motion_log(5, (unsigned int)2, 0, "%s: motion-httpd testing : %s addr: %s port: %s", (const void *)"httpd_run", res->ai_family == 2 ? "IPV4" : "IPV6", (const void *)hbuf, (const void *)sbuf);
    if(sd >= 0)
    {
      val = 1;
      setsockopt(sd, 1, 2, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_bind$2;
      return_value_bind$2=bind(sd, res->ai_addr, res->ai_addrlen);
      if(return_value_bind$2 == 0)
      {
        motion_log(5, (unsigned int)2, 0, "%s: motion-httpd Bound : %s addr: %s port: %s", (const void *)"httpd_run", res->ai_family == 2 ? "IPV4" : "IPV6", (const void *)hbuf, (const void *)sbuf);
        break;
      }

      motion_log(3, (unsigned int)2, 1, "%s: motion-httpd failed bind() interface %s / port %s, retrying", (const void *)"httpd_run", (const void *)hbuf, (const void *)sbuf);
      close(sd);
      sd = -1;
    }

    motion_log(3, (unsigned int)2, 1, "%s: motion-httpd socket failed interface %s / port %s, retrying", (const void *)"httpd_run", (const void *)hbuf, (const void *)sbuf);
  }
  freeaddrinfo(ressave);
  if(!(sd >= 0))
  {
    motion_log(2, (unsigned int)2, 1, "%s: motion-httpd ERROR bind() [interface %s port %s]", (const void *)"httpd_run", (const void *)hbuf, (const void *)sbuf);
    pthread_mutex_destroy(&httpd_mutex);
  }

  else
  {
    signed int return_value_listen$3;
    return_value_listen$3=listen(sd, 10);
    if(return_value_listen$3 == -1)
    {
      motion_log(2, (unsigned int)2, 1, "%s: motion-httpd ERROR listen() [interface %s port %s]", (const void *)"httpd_run", (const void *)hbuf, (const void *)sbuf);
      close(sd);
      pthread_mutex_destroy(&httpd_mutex);
    }

    else
    {
      motion_log(5, (unsigned int)2, 0, "%s: motion-httpd/3.2.12+git20140228 running, accepting connections", (const void *)"httpd_run");
      motion_log(5, (unsigned int)2, 0, "%s: motion-httpd: waiting for data on %s port TCP %s", (const void *)"httpd_run", (const void *)hbuf, (const void *)sbuf);
      if(!((*cnt)->conf.webcontrol_authentication == ((const char *)NULL)))
      {
        char *userpass = (char *)(void *)0;
        unsigned long int auth_size;
        auth_size=strlen(cnt[(signed long int)0]->conf.webcontrol_authentication);
        void *return_value_mymalloc$4;
        return_value_mymalloc$4=mymalloc((unsigned long int)4 * ((auth_size + (unsigned long int)2) / (unsigned long int)3) + (unsigned long int)1);
        authentication = (char *)return_value_mymalloc$4;
        void *return_value_mymalloc$5;
        return_value_mymalloc$5=mymalloc(auth_size + (unsigned long int)4);
        userpass = (char *)return_value_mymalloc$5;
        memset((void *)userpass, 0, auth_size + (unsigned long int)4);
        strcpy(userpass, cnt[(signed long int)0]->conf.webcontrol_authentication);
        base64_encode(userpass, authentication, (signed int)auth_size);
        free((void *)userpass);
      }

      while(closehttpd == 0u && !(client_sent_quit_message == 0u))
      {
        client_socket_fd=acceptnonblocking(sd, 1);
        if(!(client_socket_fd >= 0))
        {
          _Bool tmp_if_expr$6;
          if(*cnt == ((struct context *)NULL))
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = cnt[(signed long int)0]->finish != 0u ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
          {
            motion_log(5, (unsigned int)2, 0, "%s: motion-httpd - Finishing", (const void *)"httpd_run");
            closehttpd = (unsigned int)1;
          }

        }

        else
        {
          client_sent_quit_message=read_client(client_socket_fd, (void *)cnt, authentication);
          motion_log(5, (unsigned int)2, 0, "%s: motion-httpd - Read from client", (const void *)"httpd_run");
          if(!(client_socket_fd == 0))
            close(client_socket_fd);

        }
      }
      if(!(authentication == ((char *)NULL)))
        free((void *)authentication);

      close(sd);
      motion_log(5, (unsigned int)2, 0, "%s: motion-httpd Closing", (const void *)"httpd_run");
      pthread_mutex_destroy(&httpd_mutex);
    }
  }

__CPROVER_DUMP_L19:
  ;
}

// iflood
// file alg.c line 459
static signed int iflood(signed int x, signed int y, signed int width, signed int height, unsigned char *out, signed int *labels, signed int newvalue, signed int oldvalue)
{
  signed int l;
  signed int x1;
  signed int x2;
  signed int dy;
  struct anonymous$1 stack[10000l];
  struct anonymous$1 *sp = stack;
  signed int count = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(x >= width || y >= height || !(x >= 0) || !(y >= 0))
    return 0;

  else
  {
    if(!(sp >= stack + 10000l))
    {
      if(1 + y >= 0)
      {
        if(!(1 + y >= height))
        {
          sp->y = (signed short int)y;
          sp->xl = (signed short int)x;
          sp->xr = (signed short int)x;
          sp->dy = (signed short int)1;
          sp = sp + 1l;
        }

      }

    }

    if(!(sp >= stack + 10000l))
    {
      if(y >= 0)
      {
        if(!(y >= height))
        {
          sp->y = (signed short int)(y + 1);
          sp->xl = (signed short int)x;
          sp->xr = (signed short int)x;
          sp->dy = (signed short int)-1;
          sp = sp + 1l;
        }

      }

    }

    while(!(stack >= sp))
    {
      sp = sp - 1l;
      dy = (signed int)sp->dy;
      y = (signed int)sp->y + dy;
      x1 = (signed int)sp->xl;
      x2 = (signed int)sp->xr;
      x = x1;
      do
      {
        if(x >= 0)
          tmp_if_expr$1 = (signed int)out[(signed long int)(y * width + x)] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = labels[(signed long int)(y * width + x)] == oldvalue ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        labels[(signed long int)(y * width + x)] = newvalue;
        count = count + 1;
        x = x - 1;
      }
      while((_Bool)1);
      if(!(x >= x1))
      {
        l = x + 1;
        if(!(l >= x1))
        {
          if(!(sp >= stack + 10000l))
          {
            if(y + -dy >= 0)
            {
              if(!(y + -dy >= height))
              {
                sp->y = (signed short int)y;
                sp->xl = (signed short int)l;
                sp->xr = (signed short int)(x1 - 1);
                sp->dy = (signed short int)-dy;
                sp = sp + 1l;
              }

            }

          }

        }

        x = x1 + 1;
        do
        {

        __CPROVER_DUMP_L11:
          ;
          if(!(x >= width))
            tmp_if_expr$3 = (signed int)out[(signed long int)(y * width + x)] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = labels[(signed long int)(y * width + x)] == oldvalue ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(!tmp_if_expr$4)
            break;

          labels[(signed long int)(y * width + x)] = newvalue;
          count = count + 1;
          x = x + 1;
        }
        while((_Bool)1);
        if(!(sp >= stack + 10000l))
        {
          if(dy + y >= 0)
          {
            if(!(dy + y >= height))
            {
              sp->y = (signed short int)y;
              sp->xl = (signed short int)l;
              sp->xr = (signed short int)(x - 1);
              sp->dy = (signed short int)dy;
              sp = sp + 1l;
            }

          }

        }

        if(!(1 + x2 >= x))
        {
          if(!(sp >= stack + 10000l))
          {
            if(y + -dy >= 0)
            {
              if(!(y + -dy >= height))
              {
                sp->y = (signed short int)y;
                sp->xl = (signed short int)(x2 + 1);
                sp->xr = (signed short int)(x - 1);
                sp->dy = (signed short int)-dy;
                sp = sp + 1l;
              }

            }

          }

        }

      }


    skip:
      ;
      x = x + 1;
      do
      {
        if(x2 >= x)
        {
          if(!((signed int)out[(signed long int)(width * y + x)] == 0))
            tmp_if_expr$5 = labels[(signed long int)(y * width + x)] == oldvalue ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = !tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(!tmp_if_expr$6)
          break;

        x = x + 1;
      }
      while((_Bool)1);
      l = x;
      if(x2 >= x)
        goto __CPROVER_DUMP_L11;

    }
    return count;
  }
}

// image_ring_destroy
// file motion.c line 153
static void image_ring_destroy(struct context *cnt)
{
  signed int i;
  if(!(cnt->imgs.image_ring == ((struct image_data *)NULL)))
  {
    i = 0;
    for( ; !(i >= cnt->imgs.image_ring_size); i = i + 1)
      free((void *)(cnt->imgs.image_ring + (signed long int)i)->image);
    free((void *)cnt->imgs.image_ring);
    cnt->imgs.image_ring = (struct image_data *)(void *)0;
    cnt->imgs.image_ring_size = 0;
  }

}

// image_ring_resize
// file motion.c line 89
static void image_ring_resize(struct context *cnt, signed int new_size)
{
  if(!(cnt->event_nr == cnt->prev_event))
  {
    signed int smallest;
    if(!(new_size >= cnt->imgs.image_ring_size))
      smallest = new_size;

    else
      smallest = cnt->imgs.image_ring_size;
    if(cnt->imgs.image_ring_in == smallest + -1 || smallest == 0)
    {
      motion_log(5, (unsigned int)9, 0, "%s: Resizing pre_capture buffer to %d items", (const void *)"image_ring_resize", new_size);
      struct image_data *tmp;
      void *return_value_mymalloc$1;
      return_value_mymalloc$1=mymalloc((unsigned long int)new_size * sizeof(struct image_data) /*136ul*/ );
      tmp = (struct image_data *)return_value_mymalloc$1;
      if(smallest >= 1)
        memcpy((void *)tmp, (const void *)cnt->imgs.image_ring, sizeof(struct image_data) /*136ul*/  * (unsigned long int)smallest);

      signed int i = smallest;
      for( ; !(i >= new_size); i = i + 1)
      {
        void *return_value_mymalloc$2;
        return_value_mymalloc$2=mymalloc((unsigned long int)cnt->imgs.size);
        (tmp + (signed long int)i)->image = (unsigned char *)return_value_mymalloc$2;
        memset((void *)(tmp + (signed long int)i)->image, 0x80, (unsigned long int)cnt->imgs.size);
      }
      free((void *)cnt->imgs.image_ring);
      cnt->imgs.image_ring = tmp;
      cnt->imgs.image_ring_size = new_size;
    }

  }

}

// image_save_as_preview
// file motion.c line 185
static void image_save_as_preview(struct context *cnt, struct image_data *img)
{
  void *image = (void *)cnt->imgs.preview_image.image;
  memcpy((void *)&cnt->imgs.preview_image.image, (const void *)img, sizeof(struct image_data) /*136ul*/ );
  cnt->imgs.preview_image.image = (unsigned char *)image;
  memcpy((void *)cnt->imgs.preview_image.image, (const void *)img->image, (unsigned long int)cnt->imgs.size);
  if(cnt->imgs.preview_image.diffs == 0)
    cnt->imgs.preview_image.diffs = 1;

  if(cnt->locate_motion_mode == 2)
  {
    if(cnt->locate_motion_style == 1)
      alg_draw_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image, 1, 1, cnt->process_thisframe);

    else
      if(cnt->locate_motion_style == 2)
        alg_draw_red_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image, 2, 1, cnt->process_thisframe);

      else
        if(cnt->locate_motion_style == 4)
          alg_draw_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image, 4, 1, cnt->process_thisframe);

        else
          if(cnt->locate_motion_style == 8)
            alg_draw_red_location(&img->location, &cnt->imgs, cnt->imgs.width, cnt->imgs.preview_image.image, 8, 1, cnt->process_thisframe);

  }

}

// imageext
// file event.c line 284
const char * imageext(struct context *cnt)
{
  if(cnt->imgs.picture_type == 1)
    return "ppm";

  else
    return "jpg";
}

// init_destination
// file jpegutils.c line 177
static void init_destination(struct jpeg_compress_struct *cinfo)
{
  ;
}

// init_destination$link1
// file picture.c line 35
static void init_destination$link1(struct jpeg_compress_struct *cinfo$link1)
{
  struct anonymous$8 *dest = (struct anonymous$8 *)cinfo$link1->dest;
  dest->pub.next_output_byte = dest->buf;
  dest->pub.free_in_buffer = dest->bufsize;
  dest->jpegsize = (unsigned long int)0;
}

// init_filter_graph
// file ffmpeg.c line 1049
static signed int init_filter_graph(enum AVPixelFormat pixfmt, signed int width, signed int height)
{
  struct AVFilterInOut *inputs = (struct AVFilterInOut *)(void *)0;
  struct AVFilterInOut *outputs = (struct AVFilterInOut *)(void *)0;
  char args[512l];
  signed int res;
  delete_filter_graph();
  filter_graph=avfilter_graph_alloc();
  snprintf(args, sizeof(char [512l]) /*512ul*/ , "buffer=video_size=%dx%d:pix_fmt=%d:time_base=1/1:pixel_aspect=0/1[in];[in]yadif[out];[out]buffersink", width, height, pixfmt);
  res=avfilter_graph_parse2(filter_graph, args, &inputs, &outputs);
  if(!(res >= 0))
    return res;

  else
    if(!(inputs == ((struct AVFilterInOut *)NULL)) || !(outputs == ((struct AVFilterInOut *)NULL)))
      return -1;

    else
    {
      res=avfilter_graph_config(filter_graph, (void *)0);
      if(!(res >= 0))
        return res;

      else
      {
        buffersrc_ctx=avfilter_graph_get_filter(filter_graph, "Parsed_buffer_0");
        buffersink_ctx=avfilter_graph_get_filter(filter_graph, "Parsed_buffersink_2");
        if(buffersink_ctx == ((struct AVFilterContext *)NULL) || buffersrc_ctx == ((struct AVFilterContext *)NULL))
          return -1;

        else
        {
          filter_frame=av_frame_alloc();
          last_width = width;
          last_height = height;
          last_pixfmt = pixfmt;
          return 0;
        }
      }
    }
}

// init_source
// file jpegutils.c line 71
static void init_source(struct jpeg_decompress_struct *cinfo)
{
  ;
}

// initialize_chars
// file motion.h line 282
signed int initialize_chars(void)
{
  unsigned int i;
  unsigned int x;
  unsigned int y;
  unsigned long int draw_table_size = sizeof(struct draw_char [80l]) /*4560ul*/  / sizeof(struct draw_char) /*57ul*/ ;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= draw_table_size); i = i + 1u)
  {
    big_table[(signed long int)i].ascii = draw_table[(signed long int)i].ascii;
    x = (unsigned int)0;
    for( ; !(x >= 14u); x = x + 1u)
    {
      y = (unsigned int)0;
      for( ; !(y >= 16u); y = y + 1u)
        big_table[(signed long int)i].pix[(signed long int)y][(signed long int)x] = draw_table[(signed long int)i].pix[(signed long int)(y / (unsigned int)2)][(signed long int)(x / (unsigned int)2)];
    }
  }
  i = (unsigned int)0;
  for( ; !(i >= 127u); i = i + 1u)
  {
    small_char_arr_ptr[(signed long int)i] = &draw_table[(signed long int)0].pix[(signed long int)0][(signed long int)0];
    big_char_arr_ptr[(signed long int)i] = &big_table[(signed long int)0].pix[(signed long int)0][(signed long int)0];
  }
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= draw_table_size); i = i + 1u)
  {
    small_char_arr_ptr[(signed long int)(signed int)draw_table[(signed long int)i].ascii] = &draw_table[(signed long int)i].pix[(signed long int)0][(signed long int)0];
    big_char_arr_ptr[(signed long int)(signed int)draw_table[(signed long int)i].ascii] = &big_table[(signed long int)i].pix[(signed long int)0][(signed long int)0];
  }
  return 0;
}

// iomojo_center
// file track.c line 661
static unsigned int iomojo_center(struct context *cnt, signed int x_offset, signed int y_offset)
{
  struct termios adtio;
  char command[5l];
  char direction = (char)0;
  if(!(cnt->track.dev >= 0))
  {
    cnt->track.dev=open(cnt->track.port, 02 | 0400);
    if(!(cnt->track.dev >= 0))
    {
      motion_log(3, (unsigned int)7, 1, "%s: Unable to open serial device %s", (const void *)"iomojo_center", cnt->track.port);
      return (unsigned int)0;
    }

    bzero((void *)&adtio, sizeof(struct termios) /*60ul*/ );
    adtio.c_cflag = (unsigned int)(0000016 | 0000060 | 0004000 | 0000200);
    adtio.c_iflag = (unsigned int)0000004;
    adtio.c_oflag = (unsigned int)0;
    adtio.c_lflag = (unsigned int)0;
    adtio.c_cc[(signed long int)5] = (unsigned char)0;
    adtio.c_cc[(signed long int)6] = (unsigned char)0;
    tcflush(cnt->track.dev, 0);
    signed int return_value_tcsetattr$1;
    return_value_tcsetattr$1=tcsetattr(cnt->track.dev, 0, &adtio);
    if(!(return_value_tcsetattr$1 >= 0))
    {
      motion_log(3, (unsigned int)7, 1, "%s: Unable to initialize serial device %s", (const void *)"iomojo_center", cnt->track.port);
      return (unsigned int)0;
    }

  }

  iomojo_setspeed(cnt, (unsigned int)40);
  iomojo_movehome(cnt);
  if(!(x_offset == 0) || !(y_offset == 0))
  {
    if(x_offset >= 1)
      direction = direction | (char)0x01;

    else
    {
      direction = direction | (char)0x02;
      x_offset = x_offset * -1;
    }
    if(y_offset >= 1)
      direction = direction | (char)0x08;

    else
    {
      direction = direction | (char)0x04;
      y_offset = y_offset * -1;
    }
    if(x_offset >= 181)
      x_offset = 180;

    if(y_offset >= 61)
      y_offset = 60;

    command[(signed long int)0] = (char)0xfe;
    command[(signed long int)1] = (char)cnt->track.iomojo_id;
    command[(signed long int)2] = direction;
    command[(signed long int)3] = (char)x_offset;
    command[(signed long int)4] = (char)y_offset;
    iomojo_command(cnt, command, 5, (unsigned int)0);
  }

  motion_log(5, (unsigned int)7, 0, "%s: succeed", (const void *)"iomojo_center");
  return cnt->track.move_wait;
}

// iomojo_command
// file track.c line 619
static char iomojo_command(struct context *cnt, char *command, signed int len, unsigned int ret)
{
  char buffer[1l];
  signed long int timeout;
  timeout=time((signed long int *)(void *)0);
  signed long int return_value_write$1;
  return_value_write$1=write(cnt->track.dev, (const void *)command, (unsigned long int)len);
  signed long int return_value_read$2;
  signed long int return_value_time$3;
  if(!(return_value_write$1 == (signed long int)len))
    return (char)0;

  else
  {
    if(!(ret == 0u))
    {
      do
      {
        return_value_read$2=read(cnt->track.dev, (void *)buffer, (unsigned long int)1);
        if(return_value_read$2 == 1l)
          break;

        return_value_time$3=time((signed long int *)(void *)0);
        if(return_value_time$3 >= 2l + timeout)
          break;

      }
      while((_Bool)1);
      signed long int return_value_time$4;
      return_value_time$4=time((signed long int *)(void *)0);
      if(return_value_time$4 >= 2l + timeout)
      {
        motion_log(3, (unsigned int)7, 1, "%s: Return byte timeout!", (const void *)"iomojo_command");
        return (char)0;
      }

    }

    return buffer[(signed long int)0];
  }
}

// iomojo_move
// file track.c line 725
static unsigned int iomojo_move(struct context *cnt, signed int dev, struct coord *cent, struct images *imgs)
{
  char command[5l];
  signed int direction = 0;
  signed int nx = 0;
  signed int ny = 0;
  signed int i;
  unsigned int return_value_iomojo_center$1;
  if(!(dev >= 0))
  {
    return_value_iomojo_center$1=iomojo_center(cnt, 0, 0);
    if(return_value_iomojo_center$1 == 0u)
      return (unsigned int)0;

  }

  if(!(cent->x >= imgs->width / 2))
  {
    direction = direction | 0x02;
    nx = imgs->width / 2 - cent->x;
  }

  if(!(imgs->width / 2 >= cent->x))
  {
    direction = direction | 0x01;
    nx = cent->x - imgs->width / 2;
  }

  if(!(cent->y >= imgs->height / 2))
  {
    direction = direction | 0x04;
    ny = imgs->height / 2 - cent->y;
  }

  if(!(imgs->height / 2 >= cent->y))
  {
    direction = direction | 0x08;
    ny = cent->y - imgs->height / 2;
  }

  nx = (nx * 72) / imgs->width;
  ny = (ny * 72) / imgs->height;
  if(!(nx == 0) || !(ny == 0))
  {
    if(nx >= 181)
      nx = 180;

    if(ny >= 61)
      ny = 60;

    command[(signed long int)0] = (char)0xfe;
    command[(signed long int)1] = (char)cnt->track.iomojo_id;
    command[(signed long int)2] = (char)direction;
    command[(signed long int)3] = (char)nx;
    command[(signed long int)4] = (char)ny;
    iomojo_command(cnt, command, 5, (unsigned int)0);
    if(ny >= nx)
      i = (25 * ny) / 90;

    else
      i = (25 * nx) / 90;
    return (unsigned int)i;
  }

  else
    return (unsigned int)0;
}

// iomojo_movehome
// file track.c line 651
static void iomojo_movehome(struct context *cnt)
{
  char command[2l];
  command[(signed long int)0] = (char)0xf9;
  command[(signed long int)1] = (char)cnt->track.iomojo_id;
  iomojo_command(cnt, command, 2, (unsigned int)0);
}

// iomojo_setspeed
// file track.c line 639
static void iomojo_setspeed(struct context *cnt, unsigned int speed)
{
  char command[3l];
  command[(signed long int)0] = (char)0xfd;
  command[(signed long int)1] = (char)cnt->track.iomojo_id;
  command[(signed long int)2] = (char)speed;
  char return_value_iomojo_command$1;
  return_value_iomojo_command$1=iomojo_command(cnt, command, 3, (unsigned int)1);
  if(!((signed int)return_value_iomojo_command$1 == 80))
    motion_log(3, (unsigned int)7, 1, "%s: Unable to set camera speed", (const void *)"iomojo_setspeed");

}

// jpeg_buffer_dest
// file jpegutils.c line 219
static void jpeg_buffer_dest(struct jpeg_compress_struct *cinfo, unsigned char *buf, signed long int len)
{
  if(cinfo->dest == ((struct jpeg_destination_mgr *)NULL))
  {
    void *return_value;
    return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 0, sizeof(struct jpeg_destination_mgr) /*40ul*/ );
    cinfo->dest = (struct jpeg_destination_mgr *)return_value;
  }

  cinfo->dest->init_destination = init_destination;
  cinfo->dest->empty_output_buffer = empty_output_buffer;
  cinfo->dest->term_destination = term_destination;
  cinfo->dest->free_in_buffer = (unsigned long int)len;
  cinfo->dest->next_output_byte = (unsigned char *)buf;
}

// jpeg_buffer_src
// file jpegutils.c line 123
static void jpeg_buffer_src(struct jpeg_decompress_struct *cinfo, unsigned char *buffer, signed long int num)
{
  if(cinfo->src == ((struct jpeg_source_mgr *)NULL))
  {
    void *return_value;
    return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 0, sizeof(struct jpeg_source_mgr) /*56ul*/ );
    cinfo->src = (struct jpeg_source_mgr *)return_value;
  }

  cinfo->src->init_source = init_source;
  cinfo->src->fill_input_buffer = fill_input_buffer;
  cinfo->src->skip_input_data = skip_input_data;
  cinfo->src->resync_to_restart = jpeg_resync_to_restart;
  cinfo->src->term_source = term_source;
  cinfo->src->bytes_in_buffer = (unsigned long int)num;
  cinfo->src->next_input_byte = (unsigned char *)buffer;
}

// jpeg_skip_ff
// file jpegutils.c line 153
static void jpeg_skip_ff(struct jpeg_decompress_struct *cinfo)
{
  for( ; cinfo->src->bytes_in_buffer >= 2ul; cinfo->src->next_input_byte = cinfo->src->next_input_byte + 1l)
  {
    if(!((signed int)*cinfo->src->next_input_byte == 0xff))
      break;

    if(!((signed int)cinfo->src->next_input_byte[1l] == 0xff))
      break;

    cinfo->src->bytes_in_buffer = cinfo->src->bytes_in_buffer - 1ul;
  }
}

// main
// file motion.c line 2646
signed int main(signed int argc, char **argv)
{
  signed int i;
  union pthread_attr_t thread_attr;
  unsigned long int thread_id;
  struct sigaction sig_handler_action;
  struct sigaction sigchild_action;
  setup_signals(&sig_handler_action, &sigchild_action);
  motion_startup(1, argc, argv);
  ffmpeg_init();
  if(!((*cnt_list)->conf.setup_mode == 0))
    motion_log(5, (unsigned int)9, 0, "%s: Motion running in setup mode.", (const void *)"main");

  pthread_attr_init(&thread_attr);
  pthread_attr_setdetachstate(&thread_attr, 1);
  pthread_key_create(&tls_key_threadnr, (void (*)(void *))(void *)0);
  signed int return_value_nanosleep$1;
  signed int return_value_nanosleep$8;
  signed int return_value_nanosleep$10;
  while((_Bool)1)
  {
    if(!(restart == 0u))
    {
      motion_log(4, (unsigned int)9, 0, "%s: Restarting motion.", (const void *)"main");
      motion_shutdown();
      restart = (unsigned int)0;
      struct timespec main$$1$$1$$1$$1$$tv;
      main$$1$$1$$1$$1$$tv.tv_sec = (signed long int)5;
      main$$1$$1$$1$$1$$tv.tv_nsec = (signed long int)0;
      do
      {
        return_value_nanosleep$1=nanosleep(&main$$1$$1$$1$$1$$tv, &main$$1$$1$$1$$1$$tv);
        if(!(return_value_nanosleep$1 == -1))
          break;

      }
      while((_Bool)1);
      motion_startup(0, argc, argv);
      motion_log(4, (unsigned int)9, 0, "%s: Motion restarted", (const void *)"main");
    }

    i = cnt_list[(signed long int)1] != (struct context *)(void *)0 ? 1 : 0;
    for( ; !(cnt_list[(signed long int)i] == ((struct context *)NULL)); i = i + 1)
    {
      cnt_list[(signed long int)i]->threadnr = i != 0 ? i : 1;
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(cnt_list[(signed long int)i]->conf_filename, "");
      if(!(return_value_strcmp$2 == 0))
        motion_log(5, (unsigned int)9, 0, "%s: Thread %d is from %s", (const void *)"main", cnt_list[(signed long int)i]->threadnr, (const void *)cnt_list[(signed long int)i]->conf_filename);

      const char *tmp_if_expr$3;
      if(!(cnt_list[(signed long int)i]->conf.netcam_url == ((const char *)NULL)))
        tmp_if_expr$3 = cnt_list[(signed long int)i]->conf.netcam_url;

      else
        tmp_if_expr$3 = cnt_list[(signed long int)i]->conf.video_device;
      signed int tmp_if_expr$4;
      if(!(cnt_list[(signed long int)i]->conf.netcam_url == ((const char *)NULL)))
        tmp_if_expr$4 = -1;

      else
        tmp_if_expr$4 = cnt_list[(signed long int)i]->conf.input;
      motion_log(5, (unsigned int)9, 0, "%s: Thread %d is device: %s input %d", (const void *)"main", cnt_list[(signed long int)i]->threadnr, tmp_if_expr$3, tmp_if_expr$4);
      motion_log(5, (unsigned int)9, 0, "%s: Stream port %d", (const void *)"main", cnt_list[(signed long int)i]->conf.stream_port);
      start_motion_thread(cnt_list[(signed long int)i], &thread_attr);
    }
    if((*cnt_list)->conf.sdl_threadnr >= 1)
    {
      signed int tmp_if_expr$5;
      if(!(cnt_list[1l] == ((struct context *)NULL)))
        tmp_if_expr$5 = cnt_list[(signed long int)0]->conf.sdl_threadnr;

      else
        tmp_if_expr$5 = 0;
      signed int tmp_if_expr$6;
      if(!(cnt_list[1l] == ((struct context *)NULL)))
        tmp_if_expr$6 = cnt_list[(signed long int)0]->conf.sdl_threadnr;

      else
        tmp_if_expr$6 = 0;
      sdl_start(cnt_list[(signed long int)tmp_if_expr$5]->conf.width, cnt_list[(signed long int)tmp_if_expr$6]->conf.height);
    }

    if(!((*cnt_list)->conf.webcontrol_port == 0))
      pthread_create(&thread_id, &thread_attr, motion_web_control, (void *)cnt_list);

    signed int return_value_getpid$7;
    return_value_getpid$7=getpid();
    motion_log(5, (unsigned int)9, 0, "%s: Waiting for threads to finish, pid: %d", (const void *)"main", return_value_getpid$7);
    while((_Bool)1)
    {
      struct timespec main$$1$$1$$3$$1$$tv;
      main$$1$$1$$3$$1$$tv.tv_sec = (signed long int)1;
      main$$1$$1$$3$$1$$tv.tv_nsec = (signed long int)0;
      do
      {
        return_value_nanosleep$8=nanosleep(&main$$1$$1$$3$$1$$tv, &main$$1$$1$$3$$1$$tv);
        if(!(return_value_nanosleep$8 == -1))
          break;

      }
      while((_Bool)1);
      signed int motion_threads_running = 0;
      i = cnt_list[(signed long int)1] != (struct context *)(void *)0 ? 1 : 0;
      for( ; !(cnt_list[(signed long int)i] == ((struct context *)NULL)); i = i + 1)
      {
        _Bool tmp_if_expr$9;
        if(!(cnt_list[(signed long int)i]->running == 0u))
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = cnt_list[(signed long int)i]->restart != 0u ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          motion_threads_running = motion_threads_running + 1;

      }
      if(motion_threads_running == 0 && threads_running == 0 || motion_threads_running == 0 && !(finish == 0u))
      {
        motion_log(9, (unsigned int)9, 0, "%s: DEBUG-1 threads_running %d motion_threads_running %d , finish %d", (const void *)"main", threads_running, motion_threads_running, finish);
        break;
      }

      i = cnt_list[(signed long int)1] != (struct context *)(void *)0 ? 1 : 0;
      for( ; !(cnt_list[(signed long int)i] == ((struct context *)NULL)); i = i + 1)
      {
        if(cnt_list[(signed long int)i]->running == 0u)
        {
          if(!(cnt_list[(signed long int)i]->restart == 0u))
          {
            motion_log(5, (unsigned int)9, 0, "%s: Motion thread %d restart", (const void *)"main", cnt_list[(signed long int)i]->threadnr);
            start_motion_thread(cnt_list[(signed long int)i], &thread_attr);
          }

        }

        if(cnt_list[(signed long int)i]->watchdog >= -126)
        {
          cnt_list[(signed long int)i]->watchdog = cnt_list[(signed long int)i]->watchdog - 1;
          if(cnt_list[(signed long int)i]->watchdog == 0)
          {
            motion_log(3, (unsigned int)9, 0, "%s: Thread %d - Watchdog timeout, trying to do a graceful restart", (const void *)"main", cnt_list[(signed long int)i]->threadnr);
            cnt_list[(signed long int)i]->finish = (volatile unsigned int)1;
          }

          if(cnt_list[(signed long int)i]->watchdog == -60)
          {
            motion_log(3, (unsigned int)9, 0, "%s: Thread %d - Watchdog timeout, did NOT restart graceful,killing it!", (const void *)"main", cnt_list[(signed long int)i]->threadnr);
            pthread_cancel(cnt_list[(signed long int)i]->thread_id);
            pthread_mutex_lock(&global_lock);
            threads_running = threads_running - 1;
            pthread_mutex_unlock(&global_lock);
            motion_cleanup(cnt_list[(signed long int)i]);
            cnt_list[(signed long int)i]->running = (volatile unsigned int)0;
            cnt_list[(signed long int)i]->finish = (volatile unsigned int)0;
          }

        }

      }
      motion_log(9, (unsigned int)9, 0, "%s: DEBUG-2 threads_running %d motion_threads_running %d finish %d", (const void *)"main", threads_running, motion_threads_running, finish);
    }
    finish = (volatile unsigned int)0;
    motion_log(5, (unsigned int)9, 0, "%s: Threads finished", (const void *)"main");
    if(!(restart == 0u))
    {
      struct timespec main$$1$$1$$4$$tv;
      main$$1$$1$$4$$tv.tv_sec = (signed long int)2;
      main$$1$$1$$4$$tv.tv_nsec = (signed long int)0;
      do
      {
        return_value_nanosleep$10=nanosleep(&main$$1$$1$$4$$tv, &main$$1$$1$$4$$tv);
        if(!(return_value_nanosleep$10 == -1))
          break;

      }
      while((_Bool)1);
    }

    if(restart == 0u)
      break;

  }
  sdl_stop();
  cnt_list[(signed long int)0]->finish = (volatile unsigned int)1;
  struct timespec tv;
  tv.tv_sec = (signed long int)1;
  tv.tv_nsec = (signed long int)0;
  signed int return_value_nanosleep$11;
  do
  {
    return_value_nanosleep$11=nanosleep(&tv, &tv);
    if(!(return_value_nanosleep$11 == -1))
      break;

  }
  while((_Bool)1);
  motion_log(5, (unsigned int)9, 0, "%s: Motion terminating", (const void *)"main");
  pthread_key_delete(tls_key_threadnr);
  pthread_attr_destroy(&thread_attr);
  pthread_mutex_destroy(&global_lock);
  motion_shutdown();
  return 0;
}

// malloc_strings
// file conf.c line 1963
void malloc_strings(struct context *cnt)
{
  unsigned int i = (unsigned int)0;
  char **val;
  for( ; !(config_params[(signed long int)i].param_name == ((const char *)NULL)); i = i + 1u)
    if(config_params[(signed long int)i].copy == copy_string)
    {
      val = (char **)((char *)cnt + (signed long int)config_params[(signed long int)i].conf_value);
      *val=mystrdup(*val);
    }

}

// mjpegtoyuv420p
// file video.h line 100
signed int mjpegtoyuv420p(unsigned char *map, unsigned char *cap_map, signed int width, signed int height, unsigned int size)
{
  unsigned char *yuv[3l];
  unsigned char *y;
  unsigned char *u;
  unsigned char *v;
  signed int loop;
  signed int ret;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc((unsigned long int)(width * height) * sizeof(unsigned char) /*1ul*/ );
  yuv[(signed long int)0] = (unsigned char *)return_value_mymalloc$1;
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc((unsigned long int)((width * height) / 4) * sizeof(unsigned char) /*1ul*/ );
  yuv[(signed long int)1] = (unsigned char *)return_value_mymalloc$2;
  void *return_value_mymalloc$3;
  return_value_mymalloc$3=mymalloc((unsigned long int)((width * height) / 4) * sizeof(unsigned char) /*1ul*/ );
  yuv[(signed long int)2] = (unsigned char *)return_value_mymalloc$3;
  ret=decode_jpeg_raw(cap_map, (signed int)size, 0, 420, (unsigned int)width, (unsigned int)height, yuv[(signed long int)0], yuv[(signed long int)1], yuv[(signed long int)2]);
  if(ret == 1)
  {
    motion_log(2, (unsigned int)8, 0, "%s: Corrupt image ... continue", (const void *)"mjpegtoyuv420p");
    ret = 2;
  }

  y = map;
  u = y + (signed long int)(width * height);
  v = u + (signed long int)((width * height) / 4);
  memset((void *)y, 0, (unsigned long int)(width * height));
  memset((void *)u, 0, (unsigned long int)((width * height) / 4));
  memset((void *)v, 0, (unsigned long int)((width * height) / 4));
  loop = 0;
  for( ; !(loop >= height * width); loop = loop + 1)
  {
    unsigned char *tmp_post$4 = map;
    map = map + 1l;
    *tmp_post$4 = yuv[(signed long int)0][(signed long int)loop];
  }
  loop = 0;
  for( ; !(loop >= (height * width) / 4); loop = loop + 1)
  {
    unsigned char *tmp_post$5 = map;
    map = map + 1l;
    *tmp_post$5 = yuv[(signed long int)1][(signed long int)loop];
  }
  loop = 0;
  for( ; !(loop >= (height * width) / 4); loop = loop + 1)
  {
    unsigned char *tmp_post$6 = map;
    map = map + 1l;
    *tmp_post$6 = yuv[(signed long int)2][(signed long int)loop];
  }
  free((void *)yuv[(signed long int)0]);
  free((void *)yuv[(signed long int)1]);
  free((void *)yuv[(signed long int)2]);
  return ret;
}

// motion_cleanup
// file motion.c line 960
static void motion_cleanup(struct context *cnt)
{
  event(cnt, 5, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, (struct tm *)(void *)0);
  if(cnt->video_dev >= 0)
  {
    motion_log(6, (unsigned int)9, 0, "%s: Calling vid_close() from motion_cleanup", (const void *)"motion_cleanup");
    vid_close(cnt);
  }

  if(!(cnt->imgs.out == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.out);
    cnt->imgs.out = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.ref == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.ref);
    cnt->imgs.ref = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.ref_dyn == ((signed int *)NULL)))
  {
    free((void *)cnt->imgs.ref_dyn);
    cnt->imgs.ref_dyn = (signed int *)(void *)0;
  }

  if(!(cnt->imgs.image_virgin == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.image_virgin);
    cnt->imgs.image_virgin = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.labels == ((signed int *)NULL)))
  {
    free((void *)cnt->imgs.labels);
    cnt->imgs.labels = (signed int *)(void *)0;
  }

  if(!(cnt->imgs.labelsize == ((signed int *)NULL)))
  {
    free((void *)cnt->imgs.labelsize);
    cnt->imgs.labelsize = (signed int *)(void *)0;
  }

  if(!(cnt->imgs.smartmask == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.smartmask);
    cnt->imgs.smartmask = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.smartmask_final == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.smartmask_final);
    cnt->imgs.smartmask_final = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.smartmask_buffer == ((signed int *)NULL)))
  {
    free((void *)cnt->imgs.smartmask_buffer);
    cnt->imgs.smartmask_buffer = (signed int *)(void *)0;
  }

  if(!(cnt->imgs.common_buffer == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.common_buffer);
    cnt->imgs.common_buffer = (unsigned char *)(void *)0;
  }

  if(!(cnt->imgs.preview_image.image == ((unsigned char *)NULL)))
  {
    free((void *)cnt->imgs.preview_image.image);
    cnt->imgs.preview_image.image = (unsigned char *)(void *)0;
  }

  image_ring_destroy(cnt);
  rotate_deinit(cnt);
  if(!(cnt->pipe == -1))
  {
    close(cnt->pipe);
    cnt->pipe = -1;
  }

  if(!(cnt->mpipe == -1))
  {
    close(cnt->mpipe);
    cnt->mpipe = -1;
  }

  if(!(cnt->currenttime_tm == ((struct tm *)NULL)))
  {
    free((void *)cnt->currenttime_tm);
    cnt->currenttime_tm = (struct tm *)(void *)0;
  }

  if(!(cnt->eventtime_tm == ((struct tm *)NULL)))
  {
    free((void *)cnt->eventtime_tm);
    cnt->eventtime_tm = (struct tm *)(void *)0;
  }

  if(!(cnt->conf.database_type == ((const char *)NULL)))
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(cnt->conf.database_type, "mysql");
    if(return_value_strcmp$1 == 0)
    {
      if(!(cnt->conf.database_dbname == ((const char *)NULL)))
        mysql_close(cnt->database);

    }

    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(cnt->conf.database_type, "postgresql");
    if(return_value_strcmp$2 == 0)
    {
      if(!(cnt->conf.database_dbname == ((const char *)NULL)))
        PQfinish(cnt->database_pg);

    }

    if(!(cnt->conf.sqlite3_db == ((const char *)NULL)))
      sqlite3_close(cnt->database_sqlite3);

  }

}

// motion_detected
// file motion.c line 411
static void motion_detected(struct context *cnt, signed int dev, struct image_data *img)
{
  struct config *conf = &cnt->conf;
  struct images *imgs = &cnt->imgs;
  struct coord *location = &img->location;
  if(cnt->locate_motion_mode == 1)
  {
    if(cnt->locate_motion_style == 1)
      alg_draw_location(location, imgs, imgs->width, img->image, 1, 2, cnt->process_thisframe);

    else
      if(cnt->locate_motion_style == 2)
        alg_draw_red_location(location, imgs, imgs->width, img->image, 2, 2, cnt->process_thisframe);

      else
        if(cnt->locate_motion_style == 4)
          alg_draw_location(location, imgs, imgs->width, img->image, 4, 2, cnt->process_thisframe);

        else
          if(cnt->locate_motion_style == 8)
            alg_draw_red_location(location, imgs, imgs->width, img->image, 8, 2, cnt->process_thisframe);

  }

  if(!((8u & cnt->new_img) == 0u))
  {
    unsigned int distX;
    signed int return_value_abs$1;
    return_value_abs$1=abs(imgs->width / 2 - location->x);
    distX = (unsigned int)return_value_abs$1;
    unsigned int distY;
    signed int return_value_abs$2;
    return_value_abs$2=abs(imgs->height / 2 - location->y);
    distY = (unsigned int)return_value_abs$2;
    img->cent_dist = (unsigned long int)(distX * distX + distY * distY);
  }

  if(!((2u & img->flags) == 0u))
  {
    if(!(cnt->event_nr == cnt->prev_event))
    {
      cnt->prev_event = cnt->event_nr;
      cnt->eventtime = img->timestamp;
      localtime_r(&cnt->eventtime, cnt->eventtime_tm);
      mystrftime(cnt, cnt->text_event_string, sizeof(char [4096l]) /*4096ul*/ , cnt->conf.text_event, cnt->eventtime_tm, (const char *)(void *)0, 0);
      event(cnt, 3, img->image, (char *)(void *)0, (void *)0, &img->timestamp_tm);
      motion_log(5, (unsigned int)9, 0, "%s: Motion detected - starting event %d", (const void *)"motion_detected", cnt->event_nr);
      if(!((14u & cnt->new_img) == 0u))
        image_save_as_preview(cnt, img);

    }

    event(cnt, 2, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &img->timestamp_tm);
  }

  if(!(img->shot >= conf->frame_limit))
  {
    if(!(conf->stream_motion == 0))
    {
      if(conf->setup_mode == 0)
      {
        if(!(img->shot == 1))
          event(cnt, 8, img->image, (char *)(void *)0, (void *)0, &img->timestamp_tm);

      }

    }

    if(!(conf->motion_img == 0))
      event(cnt, 10, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &img->timestamp_tm);

  }

  if(!(cnt->track.type == 0u))
  {
    if(!(cnt->track.active == 0u))
      cnt->moved=track_move(cnt, dev, location, imgs, (unsigned int)0);

  }

}

// motion_init
// file motion.c line 666
static signed int motion_init(struct context *cnt)
{
  struct _IO_FILE *picture;
  pthread_setspecific(tls_key_threadnr, (void *)(unsigned long int)cnt->threadnr);
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct tm) /*56ul*/ );
  cnt->currenttime_tm = (struct tm *)return_value_mymalloc$1;
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc(sizeof(struct tm) /*56ul*/ );
  cnt->eventtime_tm = (struct tm *)return_value_mymalloc$2;
  cnt->currenttime=time((signed long int *)(void *)0);
  localtime_r(&cnt->currenttime, cnt->currenttime_tm);
  cnt->smartmask_speed = 0;
  cnt->event_nr = 1;
  cnt->prev_event = 0;
  cnt->lightswitch_framecounter = (unsigned int)0;
  cnt->detecting_motion = (unsigned int)0;
  cnt->makemovie = (volatile unsigned int)0;
  void *return_value_pthread_getspecific$3;
  return_value_pthread_getspecific$3=pthread_getspecific(tls_key_threadnr);
  motion_log(5, (unsigned int)9, 0, "%s: Thread %d started , motion detection %s", (const void *)"motion_init", (unsigned long int)return_value_pthread_getspecific$3, cnt->pause != 0u ? "Disabled" : "Enabled");
  if(cnt->conf.filepath == ((const char *)NULL))
    cnt->conf.filepath=mystrdup(".");

  cnt->video_dev=vid_start(cnt);
  if(cnt->video_dev == -1)
  {
    motion_log(4, (unsigned int)9, 0, "%s: Could not fetch initial image from camera Motion continues using width and height from config file(s)", (const void *)"motion_init");
    cnt->imgs.width = cnt->conf.width;
    cnt->imgs.height = cnt->conf.height;
    cnt->imgs.size = (cnt->conf.width * cnt->conf.height * 3) / 2;
    cnt->imgs.motionsize = cnt->conf.width * cnt->conf.height;
    cnt->imgs.type = 15;
  }

  else
    if(cnt->video_dev == -2)
    {
      motion_log(4, (unsigned int)9, 0, "%s: Could not fetch initial image from camera Motion only supports width and height modulo 16", (const void *)"motion_init");
      return -3;
    }

  image_ring_resize(cnt, 1);
  void *return_value_mymalloc$4;
  return_value_mymalloc$4=mymalloc((unsigned long int)cnt->imgs.size);
  cnt->imgs.ref = (unsigned char *)return_value_mymalloc$4;
  void *return_value_mymalloc$5;
  return_value_mymalloc$5=mymalloc((unsigned long int)cnt->imgs.size);
  cnt->imgs.out = (unsigned char *)return_value_mymalloc$5;
  memset((void *)cnt->imgs.out, 0, (unsigned long int)cnt->imgs.size);
  void *return_value_mymalloc$6;
  return_value_mymalloc$6=mymalloc((unsigned long int)cnt->imgs.motionsize * sizeof(signed int *) /*8ul*/ );
  cnt->imgs.ref_dyn = (signed int *)return_value_mymalloc$6;
  void *return_value_mymalloc$7;
  return_value_mymalloc$7=mymalloc((unsigned long int)cnt->imgs.size);
  cnt->imgs.image_virgin = (unsigned char *)return_value_mymalloc$7;
  void *return_value_mymalloc$8;
  return_value_mymalloc$8=mymalloc((unsigned long int)cnt->imgs.motionsize);
  cnt->imgs.smartmask = (unsigned char *)return_value_mymalloc$8;
  void *return_value_mymalloc$9;
  return_value_mymalloc$9=mymalloc((unsigned long int)cnt->imgs.motionsize);
  cnt->imgs.smartmask_final = (unsigned char *)return_value_mymalloc$9;
  void *return_value_mymalloc$10;
  return_value_mymalloc$10=mymalloc((unsigned long int)cnt->imgs.motionsize * sizeof(signed int *) /*8ul*/ );
  cnt->imgs.smartmask_buffer = (signed int *)return_value_mymalloc$10;
  void *return_value_mymalloc$11;
  return_value_mymalloc$11=mymalloc((unsigned long int)cnt->imgs.motionsize * sizeof(signed int *) /*8ul*/ );
  cnt->imgs.labels = (signed int *)return_value_mymalloc$11;
  void *return_value_mymalloc$12;
  return_value_mymalloc$12=mymalloc((unsigned long int)(cnt->imgs.motionsize / 2 + 1) * sizeof(signed int *) /*8ul*/ );
  cnt->imgs.labelsize = (signed int *)return_value_mymalloc$12;
  signed int return_value_strcmp$13;
  return_value_strcmp$13=strcmp(cnt->conf.picture_type, "ppm");
  if(return_value_strcmp$13 == 0)
    cnt->imgs.picture_type = 1;

  else
    cnt->imgs.picture_type = 0;
  void *return_value_mymalloc$14;
  return_value_mymalloc$14=mymalloc((unsigned long int)cnt->imgs.size);
  cnt->imgs.preview_image.image = (unsigned char *)return_value_mymalloc$14;
  void *return_value_mymalloc$15;
  return_value_mymalloc$15=mymalloc((unsigned long int)(3 * cnt->imgs.width * cnt->imgs.height));
  cnt->imgs.common_buffer = (unsigned char *)return_value_mymalloc$15;
  rotate_init(cnt);
  signed int return_value_nanosleep$17;
  if(cnt->video_dev >= 1)
  {
    signed int i = 0;
    for( ; !(i >= 5); i = i + 1)
    {
      signed int return_value_vid_next$16;
      return_value_vid_next$16=vid_next(cnt, cnt->imgs.image_virgin);
      if(return_value_vid_next$16 == 0)
        break;

      struct timespec tv;
      tv.tv_sec = (signed long int)2;
      tv.tv_nsec = (signed long int)0;
      do
      {
        return_value_nanosleep$17=nanosleep(&tv, &tv);
        if(!(return_value_nanosleep$17 == -1))
          break;

      }
      while((_Bool)1);
    }
    if(i >= 5)
    {
      memset((void *)cnt->imgs.image_virgin, 0x80, (unsigned long int)cnt->imgs.size);
      draw_text(cnt->imgs.image_virgin, (unsigned int)10, (unsigned int)20, (unsigned int)cnt->imgs.width, "Error capturing first image", (unsigned int)cnt->conf.text_double);
      motion_log(3, (unsigned int)9, 0, "%s: Error capturing first image", (const void *)"motion_init");
    }

  }

  alg_update_reference_frame(cnt, 2);
  if(!(cnt->conf.database_type == ((const char *)NULL)))
  {
    motion_log(5, (unsigned int)5, 0, "%s: Database backend %s", (const void *)"motion_init", cnt->conf.database_type);
    signed int return_value_strcmp$20;
    return_value_strcmp$20=strcmp(cnt->conf.database_type, "sqlite3");
    if(return_value_strcmp$20 == 0)
    {
      if(!(cnt->conf.sqlite3_db == ((const char *)NULL)))
      {
        motion_log(5, (unsigned int)5, 0, "%s: DB %s", (const void *)"motion_init", cnt->conf.sqlite3_db);
        signed int return_value_sqlite3_open$19;
        return_value_sqlite3_open$19=sqlite3_open(cnt->conf.sqlite3_db, &cnt->database_sqlite3);
        if(!(return_value_sqlite3_open$19 == 0))
        {
          const char *return_value_sqlite3_errmsg$18;
          return_value_sqlite3_errmsg$18=sqlite3_errmsg(cnt->database_sqlite3);
          motion_log(3, (unsigned int)5, 0, "%s: Can't open database %s : %s\n", (const void *)"motion_init", cnt->conf.sqlite3_db, return_value_sqlite3_errmsg$18);
          sqlite3_close(cnt->database_sqlite3);
          exit(1);
        }

      }

    }

    signed int return_value_strcmp$24;
    return_value_strcmp$24=strcmp(cnt->conf.database_type, "mysql");
    if(return_value_strcmp$24 == 0)
    {
      if(!(cnt->conf.database_dbname == ((const char *)NULL)))
      {
        mysql_close(cnt->database);
        void *return_value_mymalloc$21;
        return_value_mymalloc$21=mymalloc(sizeof(struct st_mysql) /*1272ul*/ );
        cnt->database = (struct st_mysql *)return_value_mymalloc$21;
        mysql_init(cnt->database);
        struct st_mysql *return_value_mysql_real_connect$23;
        return_value_mysql_real_connect$23=mysql_real_connect(cnt->database, cnt->conf.database_host, cnt->conf.database_user, cnt->conf.database_password, cnt->conf.database_dbname, (unsigned int)0, (const char *)(void *)0, (unsigned long int)0);
        if(return_value_mysql_real_connect$23 == ((struct st_mysql *)NULL))
        {
          motion_log(3, (unsigned int)5, 0, "%s: Cannot connect to MySQL database %s on host %s with user %s", (const void *)"motion_init", cnt->conf.database_dbname, cnt->conf.database_host, cnt->conf.database_user);
          const char *return_value_mysql_error$22;
          return_value_mysql_error$22=mysql_error(cnt->database);
          motion_log(3, (unsigned int)5, 0, "%s: MySQL error was %s", (const void *)"motion_init", return_value_mysql_error$22);
          return -2;
        }

        char my_true = (char)1;
        mysql_options(cnt->database, (enum mysql_option)MYSQL_OPT_RECONNECT, (const void *)&my_true);
      }

    }

    signed int return_value_strcmp$30;
    return_value_strcmp$30=strcmp(cnt->conf.database_type, "postgresql");
    if(return_value_strcmp$30 == 0)
    {
      if(!(cnt->conf.database_dbname == ((const char *)NULL)))
      {
        char connstring[255l];
        const char *tmp_if_expr$25;
        if(!(cnt->conf.database_host == ((const char *)NULL)))
          tmp_if_expr$25 = cnt->conf.database_host;

        else
          tmp_if_expr$25 = "";
        const char *tmp_if_expr$26;
        if(!(cnt->conf.database_user == ((const char *)NULL)))
          tmp_if_expr$26 = cnt->conf.database_user;

        else
          tmp_if_expr$26 = "";
        const char *tmp_if_expr$27;
        if(!(cnt->conf.database_password == ((const char *)NULL)))
          tmp_if_expr$27 = cnt->conf.database_password;

        else
          tmp_if_expr$27 = "";
        snprintf(connstring, (unsigned long int)255, "dbname='%s' host='%s' user='%s' password='%s' port='%d'", cnt->conf.database_dbname, tmp_if_expr$25, tmp_if_expr$26, tmp_if_expr$27, cnt->conf.database_port);
        cnt->database_pg=PQconnectdb(connstring);
        enum anonymous$41 return_value_PQstatus$29;
        return_value_PQstatus$29=PQstatus(cnt->database_pg);
        if((signed int)return_value_PQstatus$29 == CONNECTION_BAD)
        {
          char *return_value_PQerrorMessage$28;
          return_value_PQerrorMessage$28=PQerrorMessage(cnt->database_pg);
          motion_log(3, (unsigned int)5, 0, "%s: Connection to PostgreSQL database '%s' failed: %s", (const void *)"motion_init", cnt->conf.database_dbname, return_value_PQerrorMessage$28);
          return -2;
        }

      }

    }

    cnt->sql_mask = cnt->conf.sql_log_image * (1 + 4) + cnt->conf.sql_log_snapshot * 2 + cnt->conf.sql_log_movie * (8 + 16) + cnt->conf.sql_log_timelapse * 32;
  }

  if(!(cnt->conf.mask_file == ((const char *)NULL)))
  {
    picture=myfopen(cnt->conf.mask_file, "r", (unsigned long int)0);
    if(!(picture == ((struct _IO_FILE *)NULL)))
    {
      cnt->imgs.mask=get_pgm(picture, cnt->imgs.width, cnt->imgs.height);
      myfclose(picture);
    }

    else
    {
      motion_log(3, (unsigned int)9, 1, "%s: Error opening mask file %s", (const void *)"motion_init", cnt->conf.mask_file);
      put_fixed_mask(cnt, cnt->conf.mask_file);
    }
    if(cnt->imgs.mask == ((unsigned char *)NULL))
      motion_log(3, (unsigned int)9, 0, "%s: Failed to read mask image. Mask feature disabled.", (const void *)"motion_init");

    else
      motion_log(6, (unsigned int)9, 0, "%s: Maskfile \"%s\" loaded.", (const void *)"motion_init", cnt->conf.mask_file);
  }

  else
    cnt->imgs.mask = (unsigned char *)(void *)0;
  memset((void *)cnt->imgs.smartmask, 0, (unsigned long int)cnt->imgs.motionsize);
  memset((void *)cnt->imgs.smartmask_final, 255, (unsigned long int)cnt->imgs.motionsize);
  memset((void *)cnt->imgs.smartmask_buffer, 0, (unsigned long int)cnt->imgs.motionsize * sizeof(signed int *) /*8ul*/ );
  cnt->noise = cnt->conf.noise;
  cnt->threshold = cnt->conf.max_changes;
  if(!(cnt->conf.stream_port == 0))
  {
    signed int return_value_stream_init$31;
    return_value_stream_init$31=stream_init(cnt);
    if(return_value_stream_init$31 == -1)
    {
      motion_log(3, (unsigned int)9, 1, "%s: Problem enabling motion-stream server in port %d", (const void *)"motion_init", cnt->conf.stream_port);
      cnt->finish = (volatile unsigned int)1;
    }

    else
      motion_log(5, (unsigned int)9, 0, "%s: Started motion-stream server in port %d auth %s", (const void *)"motion_init", cnt->conf.stream_port, cnt->conf.stream_auth_method != 0 ? "Enabled" : "Disabled");
  }

  cnt->moved = (unsigned int)8;
  cnt->startup_frames = (unsigned int)(cnt->conf.frame_limit * 2);
  return 0;
}

// motion_log
// file logger.h line 61
void motion_log(signed int level, unsigned int type, signed int errno_flag, const char *fmt, ...)
{
  signed int errno_save;
  signed int n;
  char buf[1024l];
  char msg_buf[100l];
  void **ap;
  signed int threadnr;
  if(log_level >= (unsigned int)level)
  {
    if(log_type == 9u || type == log_type)
    {
      void *return_value_pthread_getspecific$1;
      return_value_pthread_getspecific$1=pthread_getspecific(tls_key_threadnr);
      threadnr = (signed int)(unsigned long int)return_value_pthread_getspecific$1;
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      errno_save = *return_value___errno_location$2;
      if(log_mode == 0)
      {
        const char *return_value_get_log_level_str$3;
        return_value_get_log_level_str$3=get_log_level_str((unsigned int)level);
        const char *return_value_get_log_type_str$4;
        return_value_get_log_type_str$4=get_log_type_str(type);
        char *return_value_str_time$5;
        return_value_str_time$5=str_time();
        n=snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "[%d] [%s] [%s] [%s] ", threadnr, return_value_get_log_level_str$3, return_value_get_log_type_str$4, return_value_str_time$5);
      }

      else
      {
        const char *return_value_get_log_level_str$6;
        return_value_get_log_level_str$6=get_log_level_str((unsigned int)level);
        const char *return_value_get_log_type_str$7;
        return_value_get_log_type_str$7=get_log_type_str(type);
        n=snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "[%d] [%s] [%s] ", threadnr, return_value_get_log_level_str$6, return_value_get_log_type_str$7);
      }
      ap = (void **)&fmt;
      signed int return_value_vsnprintf$8;
      return_value_vsnprintf$8=vsnprintf(buf + (signed long int)n, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)n, fmt, ap);
      n = n + return_value_vsnprintf$8;
      if(!(errno_flag == 0))
      {
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(buf);
        strncat(buf, ": ", (unsigned long int)1024 - return_value_strlen$9);
        n = n + 2;
        char *return_value_strerror_r$10;
        return_value_strerror_r$10=strerror_r(errno_save, msg_buf, sizeof(char [100l]) /*100ul*/ );
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen(buf);
        strncat(buf, return_value_strerror_r$10, (unsigned long int)1024 - return_value_strlen$11);
      }

      if(log_mode == 0)
      {
        unsigned long int return_value_strlen$12;
        return_value_strlen$12=strlen(buf);
        strncat(buf, "\n", (unsigned long int)1024 - return_value_strlen$12);
        fputs(buf, logfile);
        fflush(logfile);
      }

      else
      {
        syslog(level, "%s", (const void *)buf);
        unsigned long int return_value_strlen$13;
        return_value_strlen$13=strlen(buf);
        strncat(buf, "\n", (unsigned long int)1024 - return_value_strlen$13);
        fputs(buf, stderr);
        fflush(stderr);
      }
      ap = ((void **)NULL);
    }

  }

}

// motion_loop
// file motion.c line 1078
static void * motion_loop(void *arg)
{
  struct context *cnt = (struct context *)arg;
  signed int i;
  signed int j;
  signed int z = 0;
  signed long int lastframetime = (signed long int)0;
  signed int frame_buffer_size;
  unsigned int rate_limit = (unsigned int)0;
  signed int area_once = 0;
  signed int area_minx[9l];
  signed int area_miny[9l];
  signed int area_maxx[9l];
  signed int area_maxy[9l];
  signed int smartmask_ratio = 0;
  signed int smartmask_count = 20;
  unsigned int smartmask_lastrate = (unsigned int)0;
  signed int olddiffs = 0;
  signed int previous_diffs = 0;
  signed int previous_location_x = 0;
  signed int previous_location_y = 0;
  unsigned int text_size_factor;
  unsigned int passflag = (unsigned int)0;
  signed long int *rolling_average_data = (signed long int *)(void *)0;
  signed long int rolling_average_limit;
  signed long int required_frame_time;
  signed long int frame_delay;
  signed long int delay_time_nsec;
  signed int rolling_frame = 0;
  struct timeval tv1;
  struct timeval tv2;
  unsigned long int rolling_average;
  unsigned long int elapsedtime;
  unsigned long long int timenow = (unsigned long long int)0;
  unsigned long long int timebefore = (unsigned long long int)0;
  signed int vid_return_code = 0;
  signed int minimum_frame_time_downcounter = cnt->conf.minimum_frame_time;
  unsigned int get_image = (unsigned int)1;
  struct image_data *old_image;
  unsigned long int time_last_frame = (unsigned long int)1;
  unsigned long int time_current_frame;
  cnt->running = (volatile unsigned int)1;
  signed int return_value_motion_init$1;
  return_value_motion_init$1=motion_init(cnt);
  void *return_value_mymalloc$2;
  signed int return_value_abs$11;
  signed int return_value_abs$13;
  signed int return_value_abs$15;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$28;
  signed int return_value_strcasecmp$45;
  signed int return_value_strcasecmp$44;
  signed int return_value_strcasecmp$43;
  signed int return_value_strcasecmp$42;
  signed int return_value_strcasecmp$41;
  signed int return_value_strcasecmp$50;
  signed int return_value_strcasecmp$49;
  signed int return_value_strcasecmp$48;
  signed int return_value_strcasecmp$52;
  signed int return_value_strcasecmp$56;
  signed int return_value_strcasecmp$55;
  signed int return_value_strcasecmp$54;
  signed int return_value_nanosleep$60;
  if(return_value_motion_init$1 >= 0)
  {
    if(!(cnt->conf.text_double == 0))
      text_size_factor = (unsigned int)2;

    else
      text_size_factor = (unsigned int)1;
    area_minx[(signed long int)6] = 0;
    area_minx[(signed long int)3] = area_minx[(signed long int)6];
    area_minx[(signed long int)0] = area_minx[(signed long int)3];
    area_miny[(signed long int)2] = 0;
    area_miny[(signed long int)1] = area_miny[(signed long int)2];
    area_miny[(signed long int)0] = area_miny[(signed long int)1];
    area_minx[(signed long int)7] = cnt->imgs.width / 3;
    area_minx[(signed long int)4] = area_minx[(signed long int)7];
    area_minx[(signed long int)1] = area_minx[(signed long int)4];
    area_maxx[(signed long int)6] = cnt->imgs.width / 3;
    area_maxx[(signed long int)3] = area_maxx[(signed long int)6];
    area_maxx[(signed long int)0] = area_maxx[(signed long int)3];
    area_minx[(signed long int)8] = (cnt->imgs.width / 3) * 2;
    area_minx[(signed long int)5] = area_minx[(signed long int)8];
    area_minx[(signed long int)2] = area_minx[(signed long int)5];
    area_maxx[(signed long int)7] = (cnt->imgs.width / 3) * 2;
    area_maxx[(signed long int)4] = area_maxx[(signed long int)7];
    area_maxx[(signed long int)1] = area_maxx[(signed long int)4];
    area_miny[(signed long int)5] = cnt->imgs.height / 3;
    area_miny[(signed long int)4] = area_miny[(signed long int)5];
    area_miny[(signed long int)3] = area_miny[(signed long int)4];
    area_maxy[(signed long int)2] = cnt->imgs.height / 3;
    area_maxy[(signed long int)1] = area_maxy[(signed long int)2];
    area_maxy[(signed long int)0] = area_maxy[(signed long int)1];
    area_miny[(signed long int)8] = (cnt->imgs.height / 3) * 2;
    area_miny[(signed long int)7] = area_miny[(signed long int)8];
    area_miny[(signed long int)6] = area_miny[(signed long int)7];
    area_maxy[(signed long int)5] = (cnt->imgs.height / 3) * 2;
    area_maxy[(signed long int)4] = area_maxy[(signed long int)5];
    area_maxy[(signed long int)3] = area_maxy[(signed long int)4];
    area_maxx[(signed long int)8] = cnt->imgs.width;
    area_maxx[(signed long int)5] = area_maxx[(signed long int)8];
    area_maxx[(signed long int)2] = area_maxx[(signed long int)5];
    area_maxy[(signed long int)8] = cnt->imgs.height;
    area_maxy[(signed long int)7] = area_maxy[(signed long int)8];
    area_maxy[(signed long int)6] = area_maxy[(signed long int)7];
    if(!(cnt->conf.frame_limit >= 2))
      cnt->conf.frame_limit = 2;

    required_frame_time = 1000000L / (signed long int)cnt->conf.frame_limit;
    frame_delay = required_frame_time;
    rolling_average_limit = (signed long int)(10 * cnt->conf.frame_limit);
    return_value_mymalloc$2=mymalloc(sizeof(signed long int *) /*8ul*/  * (unsigned long int)rolling_average_limit);
    rolling_average_data = (signed long int *)return_value_mymalloc$2;
    j = 0;
    for( ; !((signed long int)j >= rolling_average_limit); j = j + 1)
      rolling_average_data[(signed long int)j] = required_frame_time;
    if(!(cnt->track.type == 0u))
      cnt->moved=track_center(cnt, cnt->video_dev, (unsigned int)0, 0, 0);

    while((_Bool)1)
    {
      if(!(cnt->finish == 0u))
      {
        if(cnt->makemovie == 0u)
          goto err;

      }

      cnt->watchdog = 30;
      timebefore = timenow;
      gettimeofday(&tv1, (struct timezone *)(void *)0);
      timenow = (unsigned long long int)(tv1.tv_usec + 1000000L * tv1.tv_sec);
      cnt->process_thisframe = 0;
      rate_limit = rate_limit + 1u;
      if(rate_limit >= cnt->lastrate / 3u)
      {
        rate_limit = (unsigned int)0;
        cnt->process_thisframe = 1;
      }

      if(!(cnt->conf.minimum_motion_frames >= 1))
        cnt->conf.minimum_motion_frames = 1;

      if(!(cnt->conf.pre_capture >= 0))
        cnt->conf.pre_capture = 0;

      frame_buffer_size = cnt->conf.pre_capture + cnt->conf.minimum_motion_frames;
      if(!(cnt->imgs.image_ring_size == frame_buffer_size))
        image_ring_resize(cnt, frame_buffer_size);

      cnt->currenttime=time((signed long int *)(void *)0);
      localtime_r(&cnt->currenttime, cnt->currenttime_tm);
      if(!(lastframetime == cnt->currenttime))
      {
        cnt->lastrate = (unsigned int)(cnt->shots + 1);
        cnt->shots = -1;
        lastframetime = cnt->currenttime;
        if(!(cnt->conf.minimum_frame_time == 0))
        {
          minimum_frame_time_downcounter = minimum_frame_time_downcounter - 1;
          if(minimum_frame_time_downcounter == 0)
            get_image = (unsigned int)1;

        }

        else
          get_image = (unsigned int)1;
      }

      cnt->shots = cnt->shots + 1;
      if(cnt->startup_frames >= 1u)
        cnt->startup_frames = cnt->startup_frames - 1u;

      if(!(get_image == 0u))
      {
        if(!(cnt->conf.minimum_frame_time == 0))
        {
          minimum_frame_time_downcounter = cnt->conf.minimum_frame_time;
          get_image = (unsigned int)0;
        }

        cnt->imgs.image_ring_in = cnt->imgs.image_ring_in + 1;
        if(cnt->imgs.image_ring_in >= cnt->imgs.image_ring_size)
          cnt->imgs.image_ring_in = 0;

        if(cnt->imgs.image_ring_in == cnt->imgs.image_ring_out)
        {
          cnt->imgs.image_ring_out = cnt->imgs.image_ring_out + 1;
          if(cnt->imgs.image_ring_out >= cnt->imgs.image_ring_size)
            cnt->imgs.image_ring_out = 0;

        }

        old_image = cnt->current_image;
        cnt->current_image = &cnt->imgs.image_ring[(signed long int)cnt->imgs.image_ring_in];
        if(!(cnt->process_thisframe == 0))
        {
          cnt->current_image->diffs = 0;
          cnt->current_image->flags = (unsigned int)0;
          cnt->current_image->cent_dist = (unsigned long int)0;
          memset((void *)&cnt->current_image->location, 0, sizeof(struct coord) /*32ul*/ );
          cnt->current_image->total_labels = 0;
        }

        else
          if(!(cnt->current_image == ((struct image_data *)NULL)))
          {
            if(!(old_image == ((struct image_data *)NULL)))
            {
              cnt->current_image->diffs = old_image->diffs;
              cnt->current_image->timestamp = old_image->timestamp;
              cnt->current_image->timestamp_tm = old_image->timestamp_tm;
              cnt->current_image->shot = old_image->shot;
              cnt->current_image->cent_dist = old_image->cent_dist;
              cnt->current_image->flags = old_image->flags;
              cnt->current_image->location = old_image->location;
              cnt->current_image->total_labels = old_image->total_labels;
            }

          }

        cnt->current_image->timestamp = cnt->currenttime;
        localtime_r(&cnt->current_image->timestamp, &cnt->current_image->timestamp_tm);
        cnt->current_image->shot = cnt->shots;
        if(!(cnt->video_dev >= 0))
        {
          if(cnt->currenttime % 10l == 0l)
          {
            if(cnt->shots == 0)
            {
              motion_log(4, (unsigned int)9, 0, "%s: Retrying until successful connection with camera", (const void *)"motion_loop");
              cnt->video_dev=vid_start(cnt);
              _Bool tmp_if_expr$3;
              if(!(cnt->imgs.width == cnt->conf.width))
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = cnt->imgs.height != cnt->conf.height ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
              {
                motion_log(5, (unsigned int)9, 0, "%s: Camera has finally become available\nCamera image has different width and heightfrom what is in the config file. You should fix that\nRestarting Motion thread to reinitialize all image buffers to new picture dimensions", (const void *)"motion_loop");
                cnt->conf.width = cnt->imgs.width;
                cnt->conf.height = cnt->imgs.height;
                break;
              }

            }

          }

        }

        if(cnt->video_dev >= 0)
          vid_return_code=vid_next(cnt, cnt->current_image->image);

        else
          vid_return_code = 1;
        if(vid_return_code == 0)
        {
          cnt->lost_connection = (unsigned int)0;
          cnt->connectionlosttime = (signed long int)0;
          if(cnt->missing_frame_counter >= 30 * cnt->conf.frame_limit)
            motion_log(5, (unsigned int)9, 0, "%s: Video signal re-acquired", (const void *)"motion_loop");

          cnt->missing_frame_counter = 0;
          if(!(cnt->conf.ffmpeg_deinterlace == 0))
            ffmpeg_deinterlace(cnt->current_image->image, cnt->imgs.width, cnt->imgs.height);

          memcpy((void *)cnt->imgs.image_virgin, (const void *)cnt->current_image->image, (unsigned long int)cnt->imgs.size);
          if(!(cnt->conf.netcam_url == ((const char *)NULL)))
          {
            gettimeofday(&tv1, (struct timezone *)(void *)0);
            timenow = (unsigned long long int)(tv1.tv_usec + 1000000L * tv1.tv_sec);
          }

        }

        else
          if(!(vid_return_code >= 0))
          {
            motion_log(3, (unsigned int)9, 0, "%s: Video device fatal error - Closing video device", (const void *)"motion_loop");
            vid_close(cnt);
            memcpy((void *)cnt->current_image->image, (const void *)cnt->imgs.image_virgin, (unsigned long int)cnt->imgs.size);
            cnt->lost_connection = (unsigned int)1;
          }

          else
          {
            motion_log(7, (unsigned int)9, 0, "%s: vid_return_code %d", (const void *)"motion_loop", vid_return_code);
            if(vid_return_code == 0x12)
            {
              motion_log(5, (unsigned int)9, 0, "%s: Restarting Motion thread to reinitialize all image buffers", (const void *)"motion_loop");
              cnt->lost_connection = (unsigned int)1;
              break;
            }

            if(cnt->connectionlosttime == 0l)
              cnt->connectionlosttime = cnt->currenttime;

            cnt->missing_frame_counter = cnt->missing_frame_counter + 1;
            _Bool tmp_if_expr$4;
            if(cnt->video_dev >= 0)
              tmp_if_expr$4 = cnt->missing_frame_counter < 30 * cnt->conf.frame_limit ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(tmp_if_expr$4)
              memcpy((void *)cnt->current_image->image, (const void *)cnt->imgs.image_virgin, (unsigned long int)cnt->imgs.size);

            else
            {
              const char *tmpin;
              char tmpout[80l];
              struct tm tmptime;
              cnt->lost_connection = (unsigned int)1;
              if(cnt->video_dev >= 0)
                tmpin = "CONNECTION TO CAMERA LOST\\nSINCE %Y-%m-%d %T";

              else
                tmpin = "UNABLE TO OPEN VIDEO DEVICE\\nSINCE %Y-%m-%d %T";
              localtime_r(&cnt->connectionlosttime, &tmptime);
              memset((void *)cnt->current_image->image, 0x80, (unsigned long int)cnt->imgs.size);
              mystrftime(cnt, tmpout, sizeof(char [80l]) /*80ul*/ , tmpin, &tmptime, (const char *)(void *)0, 0);
              draw_text(cnt->current_image->image, (unsigned int)10, (unsigned int)20 * text_size_factor, (unsigned int)cnt->imgs.width, tmpout, (unsigned int)cnt->conf.text_double);
              if(cnt->missing_frame_counter == 30 * cnt->conf.frame_limit)
              {
                motion_log(5, (unsigned int)9, 0, "%s: Video signal lost - Adding grey image", (const void *)"motion_loop");
                event(cnt, 18, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, cnt->currenttime_tm);
              }

              if(cnt->video_dev >= 1)
              {
                if(cnt->missing_frame_counter == 4 * cnt->conf.frame_limit)
                {
                  motion_log(3, (unsigned int)9, 0, "%s: Video signal still lost - Trying to close video device", (const void *)"motion_loop");
                  vid_close(cnt);
                }

              }

            }
          }
        if(!(cnt->process_thisframe == 0))
        {
          _Bool tmp_if_expr$8;
          if(!(cnt->threshold == 0))
            tmp_if_expr$8 = !(cnt->pause != 0u) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$8 = (_Bool)0;
          if(tmp_if_expr$8)
          {
            _Bool tmp_if_expr$5;
            if(!(cnt->detecting_motion == 0u))
              tmp_if_expr$5 = (_Bool)1;

            else
              tmp_if_expr$5 = cnt->conf.setup_mode != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$5)
              cnt->current_image->diffs=alg_diff_standard(cnt, cnt->imgs.image_virgin);

            else
              cnt->current_image->diffs=alg_diff(cnt, cnt->imgs.image_virgin);
            if(cnt->conf.lightswitch >= 2)
            {
              if(cnt->lost_connection == 0u)
              {
                signed int return_value_alg_lightswitch$6;
                return_value_alg_lightswitch$6=alg_lightswitch(cnt, cnt->current_image->diffs);
                if(!(return_value_alg_lightswitch$6 == 0))
                {
                  motion_log(6, (unsigned int)9, 0, "%s: Lightswitch detected", (const void *)"motion_loop");
                  if(!(cnt->moved >= 5u))
                    cnt->moved = (unsigned int)5;

                  cnt->current_image->diffs = 0;
                  alg_update_reference_frame(cnt, 2);
                }

              }

            }

            if(!(cnt->conf.switchfilter == 0))
            {
              if(!(cnt->threshold >= cnt->current_image->diffs))
              {
                cnt->current_image->diffs=alg_switchfilter(cnt, cnt->current_image->diffs, cnt->current_image->image);
                if(cnt->threshold >= cnt->current_image->diffs)
                {
                  cnt->current_image->diffs = 0;
                  motion_log(6, (unsigned int)9, 0, "%s: Switchfilter detected", (const void *)"motion_loop");
                }

              }

            }

            cnt->current_image->total_labels = 0;
            cnt->imgs.largest_label = 0;
            olddiffs = 0;
            _Bool tmp_if_expr$7;
            if(!(cnt->conf.despeckle_filter == ((const char *)NULL)))
              tmp_if_expr$7 = cnt->current_image->diffs > 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            if(tmp_if_expr$7)
            {
              olddiffs = cnt->current_image->diffs;
              cnt->current_image->diffs=alg_despeckle(cnt, olddiffs);
            }

            else
              if(!(cnt->imgs.labelsize_max == 0))
                cnt->imgs.labelsize_max = 0;

          }

          else
            if(cnt->conf.setup_mode == 0)
              cnt->current_image->diffs = 0;

        }

        if(!(cnt->smartmask_speed == 0))
        {
          if(!(cnt->event_nr == cnt->prev_event))
          {
            smartmask_count = smartmask_count - 1;
            if(smartmask_count == 0)
            {
              alg_tune_smartmask(cnt);
              smartmask_count = smartmask_ratio;
            }

          }

        }

        if(!(cnt->moved == 0u))
        {
          cnt->moved = cnt->moved - 1u;
          cnt->current_image->diffs = 0;
        }

        if(!(cnt->conf.noise_tune == 0))
        {
          if(cnt->shots == 0)
          {
            if(cnt->detecting_motion == 0u)
            {
              if(cnt->threshold >= cnt->current_image->diffs)
                alg_noise_tune(cnt, cnt->imgs.image_virgin);

            }

          }

        }

        if(!(cnt->process_thisframe == 0))
        {
          if(cnt->conf.noise_tune == 0)
            cnt->noise = cnt->conf.noise;

          if(!(cnt->conf.threshold_tune == 0))
            alg_threshold_tune(cnt, cnt->current_image->diffs, (signed int)cnt->detecting_motion);

          else
            cnt->threshold = cnt->conf.max_changes;
          if(!(cnt->threshold >= cnt->current_image->diffs))
            alg_locate_center_size(&cnt->imgs, cnt->imgs.width, cnt->imgs.height, &cnt->current_image->location);

          _Bool tmp_if_expr$9;
          if(!(cnt->threshold >= cnt->current_image->diffs))
            tmp_if_expr$9 = cnt->conf.lightswitch == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$9 = (_Bool)0;
          _Bool tmp_if_expr$10;
          if(tmp_if_expr$9)
            tmp_if_expr$10 = cnt->lightswitch_framecounter < cnt->lastrate * (unsigned int)2 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          _Bool tmp_if_expr$12;
          if(tmp_if_expr$10)
          {
            return_value_abs$11=abs(previous_diffs - cnt->current_image->diffs);
            tmp_if_expr$12 = return_value_abs$11 < previous_diffs / 15 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$12 = (_Bool)0;
          _Bool tmp_if_expr$14;
          if(tmp_if_expr$12)
          {
            return_value_abs$13=abs(cnt->current_image->location.x - previous_location_x);
            tmp_if_expr$14 = return_value_abs$13 <= cnt->imgs.width / 150 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$14 = (_Bool)0;
          _Bool tmp_if_expr$16;
          if(tmp_if_expr$14)
          {
            return_value_abs$15=abs(cnt->current_image->location.y - previous_location_y);
            tmp_if_expr$16 = return_value_abs$15 <= cnt->imgs.height / 150 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$16 = (_Bool)0;
          if(tmp_if_expr$16)
          {
            alg_update_reference_frame(cnt, 2);
            cnt->current_image->diffs = 0;
            cnt->lightswitch_framecounter = (unsigned int)0;
            motion_log(6, (unsigned int)9, 0, "%s: micro-lightswitch!", (const void *)"motion_loop");
          }

          else
            alg_update_reference_frame(cnt, 1);
          previous_diffs = cnt->current_image->diffs;
          previous_location_x = cnt->current_image->location.x;
          previous_location_y = cnt->current_image->location.y;
        }

        if(!(cnt->smartmask_speed == 0))
        {
          _Bool tmp_if_expr$17;
          if(!(cnt->conf.motion_img == 0))
            tmp_if_expr$17 = (_Bool)1;

          else
            tmp_if_expr$17 = cnt->conf.ffmpeg_output_debug != 0 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$18;
          if(tmp_if_expr$17)
            tmp_if_expr$18 = (_Bool)1;

          else
            tmp_if_expr$18 = cnt->conf.setup_mode != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$18)
            overlay_smartmask(cnt, cnt->imgs.out);

        }

        if(!(cnt->imgs.largest_label == 0))
        {
          _Bool tmp_if_expr$19;
          if(!(cnt->conf.motion_img == 0))
            tmp_if_expr$19 = (_Bool)1;

          else
            tmp_if_expr$19 = cnt->conf.ffmpeg_output_debug != 0 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$20;
          if(tmp_if_expr$19)
            tmp_if_expr$20 = (_Bool)1;

          else
            tmp_if_expr$20 = cnt->conf.setup_mode != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$20)
            overlay_largest_label(cnt, cnt->imgs.out);

        }

        if(!(cnt->imgs.mask == ((unsigned char *)NULL)))
        {
          _Bool tmp_if_expr$21;
          if(!(cnt->conf.motion_img == 0))
            tmp_if_expr$21 = (_Bool)1;

          else
            tmp_if_expr$21 = cnt->conf.ffmpeg_output_debug != 0 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$22;
          if(tmp_if_expr$21)
            tmp_if_expr$22 = (_Bool)1;

          else
            tmp_if_expr$22 = cnt->conf.setup_mode != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$22)
            overlay_fixed_mask(cnt, cnt->imgs.out);

        }

        if(text_size_factor == 1u && !(cnt->conf.text_double == 0))
          text_size_factor = (unsigned int)2;

        else
          if(cnt->conf.text_double == 0)
          {
            if(text_size_factor == 2u)
              text_size_factor = (unsigned int)1;

          }

        if(!(cnt->conf.text_changes == 0))
        {
          char motion_loop$$1$$2$$3$$15$$tmp[15l];
          if(cnt->pause == 0u)
            sprintf(motion_loop$$1$$2$$3$$15$$tmp, "%d", cnt->current_image->diffs);

          else
            sprintf(motion_loop$$1$$2$$3$$15$$tmp, "-");
          draw_text(cnt->current_image->image, (unsigned int)(cnt->imgs.width - 10), (unsigned int)10, (unsigned int)cnt->imgs.width, motion_loop$$1$$2$$3$$15$$tmp, (unsigned int)cnt->conf.text_double);
        }

        if(!(cnt->conf.setup_mode == 0))
        {
          char motion_loop$$1$$2$$3$$16$$tmp[4096l];
          sprintf(motion_loop$$1$$2$$3$$16$$tmp, "D:%5d L:%3d N:%3d", cnt->current_image->diffs, cnt->current_image->total_labels, cnt->noise);
          draw_text(cnt->imgs.out, (unsigned int)(cnt->imgs.width - 10), (unsigned int)cnt->imgs.height - (unsigned int)30 * text_size_factor, (unsigned int)cnt->imgs.width, motion_loop$$1$$2$$3$$16$$tmp, (unsigned int)cnt->conf.text_double);
          sprintf(motion_loop$$1$$2$$3$$16$$tmp, "THREAD %d SETUP", cnt->threadnr);
          draw_text(cnt->imgs.out, (unsigned int)(cnt->imgs.width - 10), (unsigned int)cnt->imgs.height - (unsigned int)10 * text_size_factor, (unsigned int)cnt->imgs.width, motion_loop$$1$$2$$3$$16$$tmp, (unsigned int)cnt->conf.text_double);
        }

        if(!(cnt->conf.text_left == ((const char *)NULL)))
        {
          char motion_loop$$1$$2$$3$$17$$tmp[4096l];
          mystrftime(cnt, motion_loop$$1$$2$$3$$17$$tmp, sizeof(char [4096l]) /*4096ul*/ , cnt->conf.text_left, &cnt->current_image->timestamp_tm, (const char *)(void *)0, 0);
          draw_text(cnt->current_image->image, (unsigned int)10, (unsigned int)cnt->imgs.height - (unsigned int)10 * text_size_factor, (unsigned int)cnt->imgs.width, motion_loop$$1$$2$$3$$17$$tmp, (unsigned int)cnt->conf.text_double);
        }

        if(!(cnt->conf.text_right == ((const char *)NULL)))
        {
          char tmp[4096l];
          mystrftime(cnt, tmp, sizeof(char [4096l]) /*4096ul*/ , cnt->conf.text_right, &cnt->current_image->timestamp_tm, (const char *)(void *)0, 0);
          draw_text(cnt->current_image->image, (unsigned int)(cnt->imgs.width - 10), (unsigned int)cnt->imgs.height - (unsigned int)10 * text_size_factor, (unsigned int)cnt->imgs.width, tmp, (unsigned int)cnt->conf.text_double);
        }

        if(!(cnt->threshold >= cnt->current_image->diffs))
        {
          cnt->current_image->flags = cnt->current_image->flags | (unsigned int)1;
          cnt->lightswitch_framecounter = cnt->lightswitch_framecounter + 1u;
        }

        else
          cnt->lightswitch_framecounter = (unsigned int)0;
        _Bool tmp_if_expr$32;
        if(!(cnt->conf.emulate_motion == 0))
          tmp_if_expr$32 = cnt->startup_frames == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$32 = (_Bool)0;
        if(tmp_if_expr$32)
        {
          cnt->detecting_motion = (unsigned int)1;
          motion_log(6, (unsigned int)9, 0, "%s: Emulating motion", (const void *)"motion_loop");
          _Bool tmp_if_expr$24;
          if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
            tmp_if_expr$24 = (_Bool)1;

          else
          {
            if(!(cnt->conf.useextpipe == 0))
              tmp_if_expr$23 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$23 = (_Bool)0;
            tmp_if_expr$24 = tmp_if_expr$23 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$24)
          {
            cnt->postcap = cnt->conf.post_capture;
            motion_log(7, (unsigned int)9, 0, "%s: (Em) Init post capture %d", (const void *)"motion_loop", cnt->postcap);
          }

          cnt->current_image->flags = cnt->current_image->flags | (unsigned int)(2 | 4);
          motion_detected(cnt, cnt->video_dev, cnt->current_image);
        }

        else
        {
          _Bool tmp_if_expr$31;
          if(!((1u & cnt->current_image->flags) == 0u))
            tmp_if_expr$31 = cnt->startup_frames == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$31 = (_Bool)0;
          if(tmp_if_expr$31)
          {
            signed int frame_count = 0;
            signed int pos = cnt->imgs.image_ring_in;
            i = 0;
            for( ; !(i >= cnt->conf.minimum_motion_frames); i = i + 1)
            {
              if(!((1u & (cnt->imgs.image_ring + (signed long int)pos)->flags) == 0u))
                frame_count = frame_count + 1;

              if(pos == 0)
                pos = cnt->imgs.image_ring_size - 1;

              else
                pos = pos - 1;
            }
            if(frame_count >= cnt->conf.minimum_motion_frames)
            {
              cnt->current_image->flags = cnt->current_image->flags | (unsigned int)(2 | 4);
              cnt->detecting_motion = (unsigned int)1;
              cnt->postcap = cnt->conf.post_capture;
              motion_log(7, (unsigned int)9, 0, "%s: Setup post capture %d", (const void *)"motion_loop", cnt->postcap);
              i = 0;
              for( ; !(i >= cnt->imgs.image_ring_size); i = i + 1)
                (cnt->imgs.image_ring + (signed long int)i)->flags = (cnt->imgs.image_ring + (signed long int)i)->flags | (unsigned int)4;
            }

            else
            {
              _Bool tmp_if_expr$27;
              if(!(cnt->postcap == 0))
              {
                if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
                  tmp_if_expr$26 = (_Bool)1;

                else
                {
                  if(!(cnt->conf.useextpipe == 0))
                    tmp_if_expr$25 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$25 = (_Bool)0;
                  tmp_if_expr$26 = tmp_if_expr$25 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr$27 = tmp_if_expr$26 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$27 = (_Bool)0;
              if(tmp_if_expr$27)
              {
                cnt->current_image->flags = cnt->current_image->flags | (unsigned int)(32 | 4);
                cnt->postcap = cnt->postcap - 1;
                motion_log(7, (unsigned int)9, 0, "%s: post capture %d", (const void *)"motion_loop", cnt->postcap);
              }

              else
                cnt->current_image->flags = cnt->current_image->flags | (unsigned int)16;
            }
            motion_detected(cnt, cnt->video_dev, cnt->current_image);
          }

          else
          {
            _Bool tmp_if_expr$30;
            if(!(cnt->postcap == 0))
            {
              if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
                tmp_if_expr$29 = (_Bool)1;

              else
              {
                if(!(cnt->conf.useextpipe == 0))
                  tmp_if_expr$28 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$28 = (_Bool)0;
                tmp_if_expr$29 = tmp_if_expr$28 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr$30 = tmp_if_expr$29 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$30 = (_Bool)0;
            if(tmp_if_expr$30)
            {
              cnt->current_image->flags = cnt->current_image->flags | (unsigned int)(32 | 4);
              cnt->postcap = cnt->postcap - 1;
              motion_log(7, (unsigned int)9, 0, "%s: post capture %d", (const void *)"motion_loop", cnt->postcap);
            }

            else
            {
              cnt->current_image->flags = cnt->current_image->flags | (unsigned int)16;
              if(cnt->conf.event_gap == 0)
              {
                if(cnt->detecting_motion == 1u)
                  cnt->makemovie = (volatile unsigned int)1;

              }

              cnt->detecting_motion = (unsigned int)0;
            }
          }
        }
        if(!((4u & cnt->current_image->flags) == 0u))
          cnt->lasttime = cnt->current_image->timestamp;

        if(!(cnt->conf.area_detect == ((const char *)NULL)))
        {
          if(!(cnt->event_nr == area_once))
          {
            if(!((2u & cnt->current_image->flags) == 0u))
            {
              unsigned long int return_value_strlen$33;
              return_value_strlen$33=strlen(cnt->conf.area_detect);
              j = (signed int)return_value_strlen$33;
              i = 0;
              for( ; !(i >= j); i = i + 1)
              {
                z = (signed int)cnt->conf.area_detect[(signed long int)i] - 49;
                if(z >= 0 && !(z >= 9))
                {
                  if(!(area_minx[(signed long int)z] >= cnt->current_image->location.x))
                  {
                    if(!(cnt->current_image->location.x >= area_maxx[(signed long int)z]))
                    {
                      if(!(area_miny[(signed long int)z] >= cnt->current_image->location.y))
                      {
                        if(!(cnt->current_image->location.y >= area_maxy[(signed long int)z]))
                        {
                          event(cnt, 17, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, cnt->currenttime_tm);
                          area_once = cnt->event_nr;
                          motion_log(7, (unsigned int)9, 0, "%s: Motion in area %d detected.", (const void *)"motion_loop", z + 1);
                          break;
                        }

                      }

                    }

                  }

                }

              }
            }

          }

        }

        if(!(cnt->conf.max_movie_time == 0))
        {
          if(cnt->event_nr == cnt->prev_event)
          {
            if(cnt->currenttime + -cnt->eventtime >= (signed long int)cnt->conf.max_movie_time)
              cnt->makemovie = (volatile unsigned int)1;

          }

        }

        _Bool tmp_if_expr$35;
        if(cnt->currenttime + -cnt->lasttime >= (signed long int)cnt->conf.event_gap)
          tmp_if_expr$35 = cnt->conf.event_gap > 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$35 = (_Bool)0;
        _Bool tmp_if_expr$36;
        if(tmp_if_expr$35)
          tmp_if_expr$36 = (_Bool)1;

        else
          tmp_if_expr$36 = cnt->makemovie != 0u ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$36)
        {
          _Bool tmp_if_expr$34;
          if(cnt->event_nr == cnt->prev_event)
            tmp_if_expr$34 = (_Bool)1;

          else
            tmp_if_expr$34 = cnt->makemovie != 0u ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$34)
          {
            process_image_ring(cnt, (unsigned int)-1);
            if(!(cnt->imgs.preview_image.diffs == 0))
            {
              preview_save(cnt);
              cnt->imgs.preview_image.diffs = 0;
            }

            event(cnt, 4, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, cnt->currenttime_tm);
            if(!(cnt->track.type == 0u))
              cnt->moved=track_center(cnt, cnt->video_dev, (unsigned int)0, 0, 0);

            motion_log(5, (unsigned int)9, 0, "%s: End of event %d", (const void *)"motion_loop", cnt->event_nr);
            cnt->makemovie = (volatile unsigned int)0;
            cnt->postcap = 0;
            cnt->event_nr = cnt->event_nr + 1;
            cnt->lightswitch_framecounter = (unsigned int)0;
            cnt->text_event_string[(signed long int)0] = (char)0;
          }

        }

        process_image_ring(cnt, (unsigned int)2);
        if(!(cnt->conf.setup_mode == 0))
        {
          char msg[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
          char part[100l];
          if(!(cnt->conf.despeckle_filter == ((const char *)NULL)))
          {
            snprintf(part, (unsigned long int)99, "Raw changes: %5d - changes after '%s': %5d", olddiffs, cnt->conf.despeckle_filter, cnt->current_image->diffs);
            strcat(msg, part);
            char *return_value_strchr$37;
            return_value_strchr$37=strchr(cnt->conf.despeckle_filter, 108);
            if(!(return_value_strchr$37 == ((char *)NULL)))
            {
              sprintf(part, " - labels: %3d", cnt->current_image->total_labels);
              strcat(msg, part);
            }

          }

          else
          {
            sprintf(part, "Changes: %5d", cnt->current_image->diffs);
            strcat(msg, part);
          }
          if(!(cnt->conf.noise_tune == 0))
          {
            sprintf(part, " - noise level: %2d", cnt->noise);
            strcat(msg, part);
          }

          if(!(cnt->conf.threshold_tune == 0))
          {
            sprintf(part, " - threshold: %d", cnt->threshold);
            strcat(msg, part);
          }

          motion_log(6, (unsigned int)9, 0, "%s: %s", (const void *)"motion_loop", (const void *)msg);
        }

      }

      time_current_frame = (unsigned long int)cnt->currenttime;
      _Bool tmp_if_expr$38;
      if(cnt->conf.snapshot_interval >= 1)
        tmp_if_expr$38 = cnt->shots == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$38 = (_Bool)0;
      _Bool tmp_if_expr$39;
      if(tmp_if_expr$38)
        tmp_if_expr$39 = time_current_frame % (unsigned long int)cnt->conf.snapshot_interval <= time_last_frame % (unsigned long int)cnt->conf.snapshot_interval ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$39 = (_Bool)0;
      _Bool tmp_if_expr$40;
      if(tmp_if_expr$39)
        tmp_if_expr$40 = (_Bool)1;

      else
        tmp_if_expr$40 = cnt->snapshot != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$40)
      {
        event(cnt, 11, cnt->current_image->image, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);
        cnt->snapshot = (volatile unsigned int)0;
      }

      if(!(cnt->conf.timelapse == 0))
      {
        if(cnt->current_image->timestamp_tm.tm_min == 0)
        {
          if(!(time_current_frame % 60ul >= time_last_frame % 60ul))
          {
            if(cnt->shots == 0)
            {
              signed int return_value_strcasecmp$46;
              return_value_strcasecmp$46=strcasecmp(cnt->conf.timelapse_mode, "manual");
              if(!(return_value_strcasecmp$46 == 0))
              {
                return_value_strcasecmp$45=strcasecmp(cnt->conf.timelapse_mode, "daily");
                if(return_value_strcasecmp$45 == 0)
                {
                  if(cnt->current_image->timestamp_tm.tm_hour == 0)
                    event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

                }

                else
                {
                  return_value_strcasecmp$44=strcasecmp(cnt->conf.timelapse_mode, "hourly");
                  if(return_value_strcasecmp$44 == 0)
                    event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

                  else
                  {
                    return_value_strcasecmp$43=strcasecmp(cnt->conf.timelapse_mode, "weekly-sunday");
                    if(return_value_strcasecmp$43 == 0)
                    {
                      if(cnt->current_image->timestamp_tm.tm_wday == 0)
                      {
                        if(cnt->current_image->timestamp_tm.tm_hour == 0)
                          event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

                      }

                    }

                    else
                    {
                      return_value_strcasecmp$42=strcasecmp(cnt->conf.timelapse_mode, "weekly-monday");
                      if(return_value_strcasecmp$42 == 0)
                      {
                        if(cnt->current_image->timestamp_tm.tm_wday == 1)
                        {
                          if(cnt->current_image->timestamp_tm.tm_hour == 0)
                            event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

                        }

                      }

                      else
                      {
                        return_value_strcasecmp$41=strcasecmp(cnt->conf.timelapse_mode, "monthly");
                        if(return_value_strcasecmp$41 == 0)
                        {
                          if(cnt->current_image->timestamp_tm.tm_mday == 1)
                          {
                            if(cnt->current_image->timestamp_tm.tm_hour == 0)
                              event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

                          }

                        }

                        else
                        {
                          motion_log(3, (unsigned int)9, 0, "%s: Invalid timelapse_mode argument '%s'", (const void *)"motion_loop", cnt->conf.timelapse_mode);
                          motion_log(4, (unsigned int)9, 0, "%:s Defaulting to manual timelapse mode", (const void *)"motion_loop");
                          conf_cmdparse(&cnt, (char *)"ffmpeg_timelapse_mode", (char *)"manual");
                        }
                      }
                    }
                  }
                }
              }

            }

          }

        }

        if(cnt->shots == 0)
        {
          if(time_last_frame % (unsigned long int)cnt->conf.timelapse >= time_current_frame % (unsigned long int)cnt->conf.timelapse)
            event(cnt, 6, cnt->current_image->image, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

        }

      }

      else
        if(!(cnt->ffmpeg_timelapse == ((struct ffmpeg *)NULL)))
          event(cnt, 7, (unsigned char *)(void *)0, (char *)(void *)0, (void *)0, cnt->currenttime_tm);

      time_last_frame = time_current_frame;
      if(!(cnt->conf.setup_mode == 0))
      {
        event(cnt, 12, cnt->imgs.out, (char *)(void *)0, (void *)&cnt->pipe, cnt->currenttime_tm);
        event(cnt, 8, cnt->imgs.out, (char *)(void *)0, (void *)0, cnt->currenttime_tm);
        if((*cnt_list)->conf.sdl_threadnr == cnt->threadnr)
          event(cnt, 20, cnt->imgs.out, (char *)(void *)0, (void *)0, cnt->currenttime_tm);

      }

      else
      {
        event(cnt, 12, cnt->current_image->image, (char *)(void *)0, (void *)&cnt->pipe, &cnt->current_image->timestamp_tm);
        _Bool tmp_if_expr$47;
        if(cnt->conf.stream_motion == 0)
          tmp_if_expr$47 = (_Bool)1;

        else
          tmp_if_expr$47 = cnt->shots == 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$47)
          event(cnt, 8, cnt->current_image->image, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

        if((*cnt_list)->conf.sdl_threadnr == cnt->threadnr)
          event(cnt, 20, cnt->current_image->image, (char *)(void *)0, (void *)0, &cnt->current_image->timestamp_tm);

      }
      event(cnt, 13, cnt->imgs.out, (char *)(void *)0, (void *)&cnt->mpipe, cnt->currenttime_tm);
      if(cnt->shots == 0)
      {
        signed int return_value_strcasecmp$51;
        return_value_strcasecmp$51=strcasecmp(cnt->conf.output_pictures, "on");
        if(return_value_strcasecmp$51 == 0)
          cnt->new_img = (unsigned int)1;

        else
        {
          return_value_strcasecmp$50=strcasecmp(cnt->conf.output_pictures, "first");
          if(return_value_strcasecmp$50 == 0)
            cnt->new_img = (unsigned int)2;

          else
          {
            return_value_strcasecmp$49=strcasecmp(cnt->conf.output_pictures, "best");
            if(return_value_strcasecmp$49 == 0)
              cnt->new_img = (unsigned int)4;

            else
            {
              return_value_strcasecmp$48=strcasecmp(cnt->conf.output_pictures, "center");
              if(return_value_strcasecmp$48 == 0)
                cnt->new_img = (unsigned int)8;

              else
                cnt->new_img = (unsigned int)0;
            }
          }
        }
        signed int return_value_strcasecmp$53;
        return_value_strcasecmp$53=strcasecmp(cnt->conf.locate_motion_mode, "on");
        if(return_value_strcasecmp$53 == 0)
          cnt->locate_motion_mode = 1;

        else
        {
          return_value_strcasecmp$52=strcasecmp(cnt->conf.locate_motion_mode, "preview");
          if(return_value_strcasecmp$52 == 0)
            cnt->locate_motion_mode = 2;

          else
            cnt->locate_motion_mode = 0;
        }
        signed int return_value_strcasecmp$57;
        return_value_strcasecmp$57=strcasecmp(cnt->conf.locate_motion_style, "box");
        if(return_value_strcasecmp$57 == 0)
          cnt->locate_motion_style = 1;

        else
        {
          return_value_strcasecmp$56=strcasecmp(cnt->conf.locate_motion_style, "redbox");
          if(return_value_strcasecmp$56 == 0)
            cnt->locate_motion_style = 2;

          else
          {
            return_value_strcasecmp$55=strcasecmp(cnt->conf.locate_motion_style, "cross");
            if(return_value_strcasecmp$55 == 0)
              cnt->locate_motion_style = 4;

            else
            {
              return_value_strcasecmp$54=strcasecmp(cnt->conf.locate_motion_style, "redcross");
              if(return_value_strcasecmp$54 == 0)
                cnt->locate_motion_style = 8;

              else
                cnt->locate_motion_style = 1;
            }
          }
        }
        _Bool tmp_if_expr$58;
        if(!(cnt->conf.smart_mask_speed >= 0))
          tmp_if_expr$58 = (_Bool)1;

        else
          tmp_if_expr$58 = cnt->conf.smart_mask_speed > 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$58)
          cnt->conf.smart_mask_speed = 0;

        _Bool tmp_if_expr$59;
        if(!(cnt->conf.smart_mask_speed == cnt->smartmask_speed))
          tmp_if_expr$59 = (_Bool)1;

        else
          tmp_if_expr$59 = smartmask_lastrate != cnt->lastrate ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$59)
        {
          if(cnt->conf.smart_mask_speed == 0)
          {
            memset((void *)cnt->imgs.smartmask, 0, (unsigned long int)cnt->imgs.motionsize);
            memset((void *)cnt->imgs.smartmask_final, 255, (unsigned long int)cnt->imgs.motionsize);
          }

          smartmask_lastrate = cnt->lastrate;
          cnt->smartmask_speed = cnt->conf.smart_mask_speed;
          smartmask_ratio = (signed int)((unsigned int)5 * cnt->lastrate * (unsigned int)(11 - cnt->smartmask_speed));
        }

        cnt->sql_mask = cnt->conf.sql_log_image * (1 + 4) + cnt->conf.sql_log_snapshot * 2 + cnt->conf.sql_log_movie * (8 + 16) + cnt->conf.sql_log_timelapse * 32;
      }

      if(!(cnt->conf.frame_limit == 0))
        required_frame_time = 1000000L / (signed long int)cnt->conf.frame_limit;

      else
        required_frame_time = (signed long int)0;
      gettimeofday(&tv2, (struct timezone *)(void *)0);
      elapsedtime = (unsigned long int)(tv2.tv_usec + 1000000L * tv2.tv_sec) - timenow;
      if(!(passflag == 0u))
        rolling_average_data[(signed long int)rolling_frame] = (signed long int)(timenow - timebefore);

      else
        passflag = (unsigned int)1;
      rolling_frame = rolling_frame + 1;
      if((signed long int)rolling_frame >= rolling_average_limit)
        rolling_frame = 0;

      rolling_average = (unsigned long int)0L;
      j = 0;
      for( ; !((signed long int)j >= rolling_average_limit); j = j + 1)
        rolling_average = rolling_average + (unsigned long int)rolling_average_data[(signed long int)j];
      rolling_average = rolling_average / (unsigned long int)rolling_average_limit;
      frame_delay = (signed long int)(((unsigned long int)required_frame_time - elapsedtime) - (rolling_average - (unsigned long int)required_frame_time));
      if(frame_delay >= 1l)
      {
        if(!(required_frame_time >= frame_delay))
          frame_delay = required_frame_time;

        delay_time_nsec = frame_delay * (signed long int)1000;
        if(delay_time_nsec >= 1000000000l)
          delay_time_nsec = (signed long int)999999999;

        struct timespec tv;
        tv.tv_sec = (signed long int)0;
        tv.tv_nsec = delay_time_nsec;
        do
        {
          return_value_nanosleep$60=nanosleep(&tv, &tv);
          if(!(return_value_nanosleep$60 == -1))
            break;

        }
        while((_Bool)1);
      }

    }
  }


err:
  ;
  if(!(rolling_average_data == ((signed long int *)NULL)))
    free((void *)rolling_average_data);

  cnt->lost_connection = (unsigned int)1;
  motion_log(5, (unsigned int)9, 0, "%s: Thread exiting", (const void *)"motion_loop");
  motion_cleanup(cnt);
  pthread_mutex_lock(&global_lock);
  threads_running = threads_running - 1;
  pthread_mutex_unlock(&global_lock);
  if(cnt->restart == 0u)
    cnt->watchdog = -127;

  cnt->running = (volatile unsigned int)0;
  cnt->finish = (volatile unsigned int)0;
  pthread_exit((void *)0);
}

// motion_remove_pid
// file motion.c line 380
static void motion_remove_pid(void)
{
  if(!((*cnt_list)->daemon == 0u))
  {
    if(!((*cnt_list)->conf.pid_file == ((char *)NULL)))
    {
      if(restart == 0u)
      {
        signed int return_value_unlink$1;
        return_value_unlink$1=unlink(cnt_list[(signed long int)0]->conf.pid_file);
        if(return_value_unlink$1 == 0)
          motion_log(5, (unsigned int)9, 0, "%s: Removed process id file (pid file).", (const void *)"motion_remove_pid");

        else
          motion_log(3, (unsigned int)9, 1, "%s: Error removing pid file", (const void *)"motion_remove_pid");
      }

    }

  }

  if(!(ptr_logfile == ((struct _IO_FILE *)NULL)))
  {
    motion_log(5, (unsigned int)9, 0, "%s: Closing logfile (%s).", (const void *)"motion_remove_pid", cnt_list[(signed long int)0]->conf.log_file);
    myfclose(ptr_logfile);
    set_log_mode(1);
    ptr_logfile = (struct _IO_FILE *)(void *)0;
  }

}

// motion_shutdown
// file motion.c line 2412
static void motion_shutdown(void)
{
  signed int i = -1;
  motion_remove_pid();
  do
  {
    i = i + 1;
    if(cnt_list[(signed long int)i] == ((struct context *)NULL))
      break;

    context_destroy(cnt_list[(signed long int)i]);
  }
  while((_Bool)1);
  free((void *)cnt_list);
  cnt_list = (struct context **)(void *)0;
  vid_cleanup();
}

// motion_startup
// file motion.c line 2443
static void motion_startup(signed int daemonize, signed int argc, char **argv)
{
  pthread_mutex_init(&global_lock, (const union anonymous$31 *)(void *)0);
  cntlist_create(argc, argv);
  _Bool tmp_if_expr$2;
  if((*cnt_list)->conf.log_level >= 10u)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = cnt_list[(signed long int)0]->conf.log_level == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    cnt_list[(signed long int)0]->conf.log_level = (unsigned int)5;
    cnt_list[(signed long int)0]->log_level = (signed int)cnt_list[(signed long int)0]->conf.log_level;
    const char *return_value_get_log_level_str$1;
    return_value_get_log_level_str$1=get_log_level_str((unsigned int)cnt_list[(signed long int)0]->log_level);
    motion_log(5, (unsigned int)9, 0, "%s: Using default log level (%s) (%d)", (const void *)"motion_startup", return_value_get_log_level_str$1, cnt_list[(signed long int)0]->log_level + 1);
  }

  else
    cnt_list[(signed long int)0]->log_level = (signed int)(cnt_list[(signed long int)0]->conf.log_level - (unsigned int)1);
  motion_log(5, (unsigned int)9, 0, "%s: Motion 3.2.12+git20140228 Started with SDL support", (const void *)"motion_startup");
  _Bool tmp_if_expr$4;
  signed int return_value_strncmp$3;
  if(!((*cnt_list)->conf.log_file == ((char *)NULL)))
  {
    return_value_strncmp$3=strncmp(cnt_list[(signed long int)0]->conf.log_file, "syslog", (unsigned long int)6);
    tmp_if_expr$4 = return_value_strncmp$3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  if(tmp_if_expr$4)
  {
    set_log_mode(0);
    ptr_logfile=set_logfile(cnt_list[(signed long int)0]->conf.log_file);
    if(!(ptr_logfile == ((struct _IO_FILE *)NULL)))
    {
      set_log_mode(1);
      motion_log(5, (unsigned int)9, 0, "%s: Logging to file (%s)", (const void *)"motion_startup", cnt_list[(signed long int)0]->conf.log_file);
      set_log_mode(0);
    }

    else
    {
      motion_log(0, (unsigned int)9, 1, "%s: Exit motion, cannot create log file %s", (const void *)"motion_startup", cnt_list[(signed long int)0]->conf.log_file);
      exit(0);
    }
  }

  else
    motion_log(5, (unsigned int)9, 0, "%s: Logging to syslog", (const void *)"motion_startup");
  _Bool tmp_if_expr$7;
  signed int return_value_get_log_type$6;
  if((*cnt_list)->conf.log_type_str == ((char *)NULL))
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_get_log_type$6=get_log_type(cnt_list[(signed long int)0]->conf.log_type_str);
    cnt_list[(signed long int)0]->log_type = (unsigned int)return_value_get_log_type$6;
    tmp_if_expr$7 = !(cnt_list[(signed long int)0]->log_type != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    cnt_list[(signed long int)0]->log_type = (unsigned int)9;
    cnt_list[(signed long int)0]->conf.log_type_str=mystrcpy(cnt_list[(signed long int)0]->conf.log_type_str, "ALL");
    const char *return_value_get_log_type_str$5;
    return_value_get_log_type_str$5=get_log_type_str(cnt_list[(signed long int)0]->log_type);
    motion_log(5, (unsigned int)9, 0, "%s: Using default log type (%s)", (const void *)"motion_startup", return_value_get_log_type_str$5);
  }

  const char *return_value_get_log_type_str$8;
  return_value_get_log_type_str$8=get_log_type_str(cnt_list[(signed long int)0]->log_type);
  const char *return_value_get_log_level_str$9;
  return_value_get_log_level_str$9=get_log_level_str((unsigned int)cnt_list[(signed long int)0]->log_level);
  motion_log(5, (unsigned int)9, 0, "%s: Using log type (%s) log level (%s)", (const void *)"motion_startup", return_value_get_log_type_str$8, return_value_get_log_level_str$9);
  set_log_level((unsigned int)cnt_list[(signed long int)0]->log_level);
  set_log_type(cnt_list[(signed long int)0]->log_type);
  initialize_chars();
  if(!(daemonize == 0))
  {
    if(!((*cnt_list)->daemon == 0u))
    {
      if((*cnt_list)->conf.setup_mode == 0)
      {
        become_daemon();
        motion_log(5, (unsigned int)9, 0, "%s: Motion running as daemon process", (const void *)"motion_startup");
      }

    }

  }

  vid_init();
}

// motion_web_control
// file webhttpd.h line 20
void * motion_web_control(void *arg)
{
  struct context **cnt = (struct context **)arg;
  httpd_run(cnt);
  motion_log(5, (unsigned int)2, 0, "%s: motion-httpd thread exit", (const void *)"motion_web_control");
  pthread_exit((void *)0);
}

// mpeg1_write_trailer
// file ffmpeg.c line 318
static signed int mpeg1_write_trailer(struct AVFormatContext *s)
{
  avio_write(s->pb, mpeg1_trailer, 4);
  avio_flush(s->pb);
  return 0;
}

// my_emit_message
// file jpegutils.c line 281
static void my_emit_message(struct jpeg_common_struct *cinfo, signed int msg_level)
{
  struct my_error_mgr *myerr = (struct my_error_mgr *)cinfo->err;
  if(!(msg_level >= 0))
    myerr->warning_seen = 1;

  myerr->original_emit_message(cinfo, msg_level);
}

// my_error_exit
// file jpegutils.c line 266
static void my_error_exit(struct jpeg_common_struct *cinfo)
{
  struct my_error_mgr *myerr = (struct my_error_mgr *)cinfo->err;
  cinfo->err->output_message(cinfo);
  longjmp(myerr->setjmp_buffer, 1);
}

// myfclose
// file motion.c line 3077
signed int myfclose(struct _IO_FILE *fh)
{
  signed int i = 0;
  signed int rval;
  rval=fclose(fh);
  if(!(rval == 0))
    motion_log(3, (unsigned int)9, 1, "%s: Error closing file", (const void *)"myfclose");

  i = 0;
  for( ; !(i >= 32); i = i + 1)
    if(buffers[(signed long int)i].fh == fh)
    {
      buffers[(signed long int)i].fh = (struct _IO_FILE *)(void *)0;
      if(!(finish == 0u))
      {
        if(!(buffers[(signed long int)i].buffer == ((char *)NULL)))
          free((void *)buffers[(signed long int)i].buffer);

        buffers[(signed long int)i].buffer = (char *)(void *)0;
        buffers[(signed long int)i].bufsize = (unsigned long int)0;
      }

    }

  return rval;
}

// myfopen
// file motion.c line 2982
struct _IO_FILE * myfopen(const char *path, const char *mode, unsigned long int bufsize)
{
  static signed int bufferInit = 0;
  if(bufferInit == 0)
  {
    bufferInit = 1;
    memset((void *)buffers, 0x00, sizeof(struct MyBuffer [32l]) /*768ul*/ );
  }

  struct _IO_FILE *dummy;
  dummy=fopen(path, mode);
  if(dummy == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 2)
    {
      signed int return_value_create_path$1;
      return_value_create_path$1=create_path(path);
      if(return_value_create_path$1 == -1)
        return (struct _IO_FILE *)(void *)0;

      dummy=fopen(path, mode);
    }

  }

  if(!(dummy == ((struct _IO_FILE *)NULL)))
  {
    if(bufsize >= 1ul)
    {
      signed int i = 0;
      i = 0;
      for( ; !(i >= 32); i = i + 1)
      {
        signed int first = -1;
        if(buffers[(signed long int)i].fh == ((struct _IO_FILE *)NULL))
        {
          if(first == -1)
            first = i;

          _Bool tmp_if_expr$5;
          if(buffers[(signed long int)i].buffer == ((char *)NULL))
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = buffers[(signed long int)i].bufsize >= bufsize ? (_Bool)1 : (_Bool)0;
          if(i == 32 && first >= 0 || tmp_if_expr$5)
          {
            if(buffers[(signed long int)i].buffer == ((char *)NULL))
            {
              buffers[(signed long int)i].fh = dummy;
              void *return_value_mymalloc$3;
              return_value_mymalloc$3=mymalloc(bufsize);
              buffers[(signed long int)i].buffer = (char *)return_value_mymalloc$3;
              buffers[(signed long int)i].bufsize = bufsize;
            }

            else
              if(buffers[(signed long int)i].bufsize >= bufsize)
                buffers[(signed long int)i].fh = dummy;

              else
              {
                i = first;
                buffers[(signed long int)i].fh = dummy;
                void *return_value_myrealloc$4;
                return_value_myrealloc$4=myrealloc((void *)buffers[(signed long int)i].buffer, bufsize, "myfopen");
                buffers[(signed long int)i].buffer = (char *)return_value_myrealloc$4;
                buffers[(signed long int)i].bufsize = bufsize;
              }
            if(buffers[(signed long int)i].buffer == ((char *)NULL))
            {
              buffers[(signed long int)i].fh = (struct _IO_FILE *)(void *)0;
              buffers[(signed long int)i].bufsize = (unsigned long int)0;
            }

            else
              setvbuf(buffers[(signed long int)i].fh, buffers[(signed long int)i].buffer, 0, buffers[(signed long int)i].bufsize);
            break;
          }

        }

      }
    }

  }

  else
    motion_log(3, (unsigned int)9, 1, "%s: Error opening file %s with mode %s", (const void *)"myfopen", path, mode);
  return dummy;
}

// mymalloc
// file motion.c line 2855
void * mymalloc(unsigned long int nbytes)
{
  void *dummy;
  dummy=calloc(nbytes, (unsigned long int)1);
  if(dummy == NULL)
  {
    motion_log(0, (unsigned int)9, 1, "%s: Could not allocate %llu bytes of memory!", (const void *)"mymalloc", (unsigned long long int)nbytes);
    motion_remove_pid();
    exit(1);
  }

  return dummy;
}

// myrealloc
// file motion.c line 2885
void * myrealloc(void *ptr, unsigned long int size, const char *desc)
{
  void *dummy = (void *)0;
  if(size == 0ul)
  {
    free(ptr);
    motion_log(4, (unsigned int)9, 0, "%s: Warning! Function %s tries to resize memoryblock at %p to 0 bytes!", (const void *)"myrealloc", desc, ptr);
  }

  else
  {
    dummy=realloc(ptr, size);
    if(dummy == NULL)
    {
      motion_log(0, (unsigned int)9, 0, "%s: Could not resize memory-block at offset %p to %llu bytes (function %s)!", (const void *)"myrealloc", ptr, (unsigned long long int)size, desc);
      motion_remove_pid();
      exit(1);
    }

  }
  return dummy;
}

// mystrcpy
// file conf.h line 166
char * mystrcpy(char *to, const char *from)
{
  if(!(to == ((char *)NULL)))
    free((void *)to);

  char *return_value_mystrdup$1;
  return_value_mystrdup$1=mystrdup(from);
  return return_value_mystrdup$1;
}

// mystrdup
// file conf.h line 165
char * mystrdup(const char *from)
{
  char *tmp;
  unsigned long int stringlength;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$2;
  if(from == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strlen$2=strlen(from);
    tmp_if_expr$3 = !(return_value_strlen$2 != 0ul) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    tmp = (char *)(void *)0;

  else
  {
    stringlength=strlen(from);
    stringlength = stringlength < (unsigned long int)4096 ? stringlength : (unsigned long int)4096;
    void *return_value_mymalloc$1;
    return_value_mymalloc$1=mymalloc(stringlength + (unsigned long int)1);
    tmp = (char *)return_value_mymalloc$1;
    strncpy(tmp, from, stringlength);
    tmp = tmp + (signed long int)stringlength;
    *tmp = (char)0;
    tmp = tmp - (signed long int)stringlength;
  }
  return tmp;
}

// mystrftime
// file motion.c line 3119
unsigned long int mystrftime(struct context *cnt, char *s, unsigned long int max, const char *userformat, struct tm *tm, const char *filename, signed int sqltype)
{
  char formatstring[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char tempstring[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *format;
  char *tempstr;
  const char *pos_userformat;
  format = formatstring;
  void *return_value_pthread_getspecific$1;
  char *tmp_post$4;
  if(userformat == ((const char *)NULL))
  {
    *s = (char)0;
    return (unsigned long int)0;
  }

  else
  {
    pos_userformat = userformat;
    for( ; !(*pos_userformat == 0); pos_userformat = pos_userformat + 1l)
    {
      if((signed int)*pos_userformat == 37)
      {
        tempstr = tempstring;
        tempstr[(signed long int)0] = (char)0;
        pos_userformat = pos_userformat + 1l;
        switch((signed int)*pos_userformat)
        {
          case 0:
          {
            pos_userformat = pos_userformat - 1l;
            break;
          }
          case 118:
          {
            sprintf(tempstr, "%02d", cnt->event_nr);
            break;
          }
          case 113:
          {
            sprintf(tempstr, "%02d", cnt->current_image->shot);
            break;
          }
          case 68:
          {
            sprintf(tempstr, "%d", cnt->current_image->diffs);
            break;
          }
          case 78:
          {
            sprintf(tempstr, "%d", cnt->noise);
            break;
          }
          case 105:
          {
            sprintf(tempstr, "%d", cnt->current_image->location.width);
            break;
          }
          case 74:
          {
            sprintf(tempstr, "%d", cnt->current_image->location.height);
            break;
          }
          case 75:
          {
            sprintf(tempstr, "%d", cnt->current_image->location.x);
            break;
          }
          case 76:
          {
            sprintf(tempstr, "%d", cnt->current_image->location.y);
            break;
          }
          case 111:
          {
            sprintf(tempstr, "%d", cnt->threshold);
            break;
          }
          case 81:
          {
            sprintf(tempstr, "%d", cnt->current_image->total_labels);
            break;
          }
          case 116:
          {
            return_value_pthread_getspecific$1=pthread_getspecific(tls_key_threadnr);
            sprintf(tempstr, "%d", (signed int)(unsigned long int)return_value_pthread_getspecific$1);
            break;
          }
          case 67:
          {
            if(!(cnt->text_event_string[0l] == 0))
              snprintf(tempstr, (unsigned long int)4096, "%s", (const void *)cnt->text_event_string);

            else
              pos_userformat = pos_userformat + 1l;
            break;
          }
          case 102:
          {
            if((signed int)pos_userformat[1l] == 112)
            {
              if((signed int)pos_userformat[2l] == 115)
              {
                sprintf(tempstr, "%d", cnt->movie_fps);
                pos_userformat = pos_userformat + (signed long int)2;
                break;
              }

            }

            if(!(filename == ((const char *)NULL)))
              snprintf(tempstr, (unsigned long int)4096, "%s", filename);

            else
              pos_userformat = pos_userformat + 1l;
            break;
          }
          case 110:
          {
            if(!(sqltype == 0))
              sprintf(tempstr, "%d", sqltype);

            else
              pos_userformat = pos_userformat + 1l;
            break;
          }
          default:
          {
            char *tmp_post$2 = format;
            format = format + 1l;
            *tmp_post$2 = (char)37;
            char *tmp_post$3 = format;
            format = format + 1l;
            *tmp_post$3 = *pos_userformat;
            goto __CPROVER_DUMP_L30;
          }
        }
        if(*tempstr == 0)
          goto __CPROVER_DUMP_L29;

        do
        {
          tmp_post$4 = tempstr;
          tempstr = tempstr + 1l;
          *format = *tmp_post$4;
          if((signed int)*format == 0)
            break;

          format = format + 1l;
        }
        while((_Bool)1);
      }

      else
      {

      __CPROVER_DUMP_L29:
        ;
        char *tmp_post$5 = format;
        format = format + 1l;
        *tmp_post$5 = *pos_userformat;
      }

    __CPROVER_DUMP_L30:
      ;
    }
    *format = (char)0;
    format = formatstring;
    unsigned long int return_value_strftime$6;
    return_value_strftime$6=strftime(s, max, format, tm);
    return return_value_strftime$6;
  }
}

// netcam_check_buffsize
// file netcam.c line 1049
static void netcam_check_buffsize(struct netcam_image_buff *buff, unsigned long int numbytes)
{
  signed int min_size_to_alloc;
  signed int real_alloc;
  signed int new_size;
  if(!(buff->size + -buff->used >= numbytes))
  {
    min_size_to_alloc = (signed int)(numbytes - (buff->size - buff->used));
    real_alloc = (min_size_to_alloc / 4096) * 4096;
    if(min_size_to_alloc + -real_alloc >= 1)
      real_alloc = real_alloc + 4096;

    new_size = (signed int)(buff->size + (unsigned long int)real_alloc);
    motion_log(7, (unsigned int)4, 0, "%s: expanding buffer from [%d/%d] to [%d/%d] bytes.", (const void *)"netcam_check_buffsize", (signed int)buff->used, (signed int)buff->size, (signed int)buff->used, new_size);
    void *return_value_myrealloc$1;
    return_value_myrealloc$1=myrealloc((void *)buff->ptr, (unsigned long int)new_size, "netcam_check_buf_size");
    buff->ptr = (char *)return_value_myrealloc$1;
    buff->size = (unsigned long int)new_size;
  }

}

// netcam_check_buffsize$link1
// file netcam_rtsp.c line 24
static void netcam_check_buffsize$link1(struct netcam_image_buff *buff$link1, unsigned long int numbytes$link1)
{
  signed int min_size_to_alloc$link1;
  signed int real_alloc$link1;
  signed int new_size$link1;
  if(!(buff$link1->size + -buff$link1->used >= numbytes$link1))
  {
    min_size_to_alloc$link1 = (signed int)(numbytes$link1 - (buff$link1->size - buff$link1->used));
    real_alloc$link1 = (min_size_to_alloc$link1 / 4096) * 4096;
    if(min_size_to_alloc$link1 + -real_alloc$link1 >= 1)
      real_alloc$link1 = real_alloc$link1 + 4096;

    new_size$link1 = (signed int)(buff$link1->size + (unsigned long int)real_alloc$link1);
    motion_log(7, (unsigned int)4, 0, "%s: expanding buffer from [%d/%d] to [%d/%d] bytes.", (const void *)"netcam_check_buffsize", (signed int)buff$link1->used, (signed int)buff$link1->size, (signed int)buff$link1->used, new_size$link1);
    void *return_value_myrealloc$1$link1;
    return_value_myrealloc$1$link1=myrealloc((void *)buff$link1->ptr, (unsigned long int)new_size$link1, "netcam_check_buf_size");
    buff$link1->ptr = (char *)return_value_myrealloc$1$link1;
    buff$link1->size = (unsigned long int)new_size$link1;
  }

}

// netcam_check_close
// file netcam.c line 364
static signed int netcam_check_close(char *header)
{
  char *type = (char *)(void *)0;
  signed int ret = -1;
  signed int return_value_header_process$1;
  return_value_header_process$1=header_process(header, "Connection", http_process_type, (void *)&type);
  if(return_value_header_process$1 == 0)
    return -1;

  else
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(type, "close");
    if(return_value_strcmp$2 == 0)
      ret = 1;

    if(!(type == ((char *)NULL)))
      free((void *)type);

    return ret;
  }
}

// netcam_check_content_length
// file netcam.c line 301
static signed long int netcam_check_content_length(char *header)
{
  signed long int length = (signed long int)-1;
  signed int return_value_header_process$1;
  return_value_header_process$1=header_process(header, "Content-Length", header_extract_number, (void *)&length);
  if(return_value_header_process$1 == 0)
  {
    if(length >= 1l)
      motion_log(4, (unsigned int)4, 0, "%s: malformed token Content-Length but value %ld", (const void *)"netcam_check_content_length", length);

  }

  motion_log(6, (unsigned int)4, 0, "%s: Content-Length %ld", (const void *)"netcam_check_content_length", length);
  return length;
}

// netcam_check_content_type
// file netcam.c line 398
static signed int netcam_check_content_type(char *header)
{
  char *content_type = (char *)(void *)0;
  signed int ret;
  signed int return_value_header_process$1;
  return_value_header_process$1=header_process(header, "Content-type", http_process_type, (void *)&content_type);
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$2;
  if(return_value_header_process$1 == 0)
    return -1;

  else
  {
    motion_log(6, (unsigned int)4, 0, "%s: Content-type %s", (const void *)"netcam_check_content_type", content_type);
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(content_type, "image/jpeg");
    if(return_value_strcmp$6 == 0)
      ret = 1;

    else
    {
      return_value_strcmp$3=strcmp(content_type, "multipart/x-mixed-replace");
      _Bool tmp_if_expr$5;
      if(return_value_strcmp$3 == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_strcmp$4=strcmp(content_type, "multipart/mixed");
        tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        ret = 2;

      else
      {
        return_value_strcmp$2=strcmp(content_type, "application/octet-stream");
        if(return_value_strcmp$2 == 0)
          ret = 3;

        else
          ret = 0;
      }
    }
    if(!(content_type == ((char *)NULL)))
      free((void *)content_type);

    return ret;
  }
}

// netcam_check_keepalive
// file netcam.c line 336
static signed int netcam_check_keepalive(char *header)
{
  char *content_type = (char *)(void *)0;
  signed int return_value_header_process$1;
  return_value_header_process$1=header_process(header, "Keep-Alive", http_process_type, (void *)&content_type);
  if(return_value_header_process$1 == 0)
    return -1;

  else
  {
    if(!(content_type == ((char *)NULL)))
      free((void *)content_type);

    return 1;
  }
}

// netcam_cleanup
// file netcam.h line 298
void netcam_cleanup(struct netcam_context *netcam, signed int init_retry_flag)
{
  struct timespec waittime;
  signed int return_value_pthread_cond_timedwait$2;
  if(!(netcam == ((struct netcam_context *)NULL)))
  {
    pthread_mutex_lock(&netcam->mutex);
    if(!(netcam->cnt->netcam == ((struct netcam_context *)NULL)))
    {
      netcam->cnt->netcam = (struct netcam_context *)(void *)0;
      netcam->finish = 1;
      if((signed int)netcam->caps.streaming == 0)
        pthread_cond_signal(&netcam->cap_cond);

      signed long int return_value_time$1;
      return_value_time$1=time((signed long int *)(void *)0);
      waittime.tv_sec = return_value_time$1 + (signed long int)8;
      waittime.tv_nsec = (signed long int)0;
      if(init_retry_flag == 0)
      {
        return_value_pthread_cond_timedwait$2=pthread_cond_timedwait(&netcam->exiting, &netcam->mutex, &waittime);
        if(!(return_value_pthread_cond_timedwait$2 == 0))
        {
          motion_log(3, (unsigned int)4, 0, "%s: No response from camera handler - it must have already died", (const void *)"netcam_cleanup");
          pthread_mutex_lock(&global_lock);
          threads_running = threads_running - 1;
          pthread_mutex_unlock(&global_lock);
        }

      }

      pthread_mutex_unlock(&netcam->mutex);
      if(!(netcam->connect_host == ((char *)NULL)))
        free((void *)netcam->connect_host);

      if(!(netcam->connect_request == ((char *)NULL)))
        free((void *)netcam->connect_request);

      if(!(netcam->boundary == ((char *)NULL)))
        free((void *)netcam->boundary);

      if(!(netcam->latest == ((struct netcam_image_buff *)NULL)))
      {
        if(!(netcam->latest->ptr == ((char *)NULL)))
          free((void *)netcam->latest->ptr);

        free((void *)netcam->latest);
      }

      if(!(netcam->receiving == ((struct netcam_image_buff *)NULL)))
      {
        if(!(netcam->receiving->ptr == ((char *)NULL)))
          free((void *)netcam->receiving->ptr);

        free((void *)netcam->receiving);
      }

      if(!(netcam->jpegbuf == ((struct netcam_image_buff *)NULL)))
      {
        if(!(netcam->jpegbuf->ptr == ((char *)NULL)))
          free((void *)netcam->jpegbuf->ptr);

        free((void *)netcam->jpegbuf);
      }

      if(!(netcam->ftp == ((struct ftp_context *)NULL)))
        ftp_free_context(netcam->ftp);

      else
        netcam_disconnect(netcam);
      if(!(netcam->response == ((struct rbuf *)NULL)))
        free((void *)netcam->response);

      pthread_mutex_destroy(&netcam->mutex);
      pthread_cond_destroy(&netcam->cap_cond);
      pthread_cond_destroy(&netcam->pic_ready);
      pthread_cond_destroy(&netcam->exiting);
      free((void *)netcam);
    }

  }

}

// netcam_connect
// file netcam.c line 861
static signed int netcam_connect(struct netcam_context *netcam, signed int err_flag)
{
  struct sockaddr_in server;
  struct addrinfo *res;
  signed int ret;
  signed int saveflags;
  signed int back_err;
  signed int optval;
  unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  unsigned int len;
  struct anonymous$45 fd_w;
  struct timeval selecttime;
  if(netcam->connect_keepalive == 0)
  {
    motion_log(6, (unsigned int)4, 0, "%s: disconnecting netcam since keep-alive not set.", (const void *)"netcam_connect");
    netcam_disconnect(netcam);
    netcam->sock=socket(2, 1, 0);
    if(!(netcam->sock >= 0))
    {
      motion_log(4, (unsigned int)4, 1, "%s:  with no keepalive, attempt to create socket failed.", (const void *)"netcam_connect");
      return -1;
    }

    motion_log(6, (unsigned int)4, 0, "%s: with no keepalive, new socket created fd %d", (const void *)"netcam_connect", netcam->sock);
  }

  else
    if(netcam->sock == -1)
    {
      netcam->sock=socket(2, 1, 0);
      if(!(netcam->sock >= 0))
      {
        motion_log(4, (unsigned int)4, 1, "%s: with keepalive set, invalid socket.This could be the first time. Creating a new one failed.", (const void *)"netcam_connect");
        return -1;
      }

      motion_log(6, (unsigned int)4, 0, "%s: with keepalive set, invalid socket.This could be first time, created a new one with fd %d", (const void *)"netcam_connect", netcam->sock);
      netcam->keepalive_thisconn = 0;
      signed int return_value_getsockopt$1;
      return_value_getsockopt$1=getsockopt(netcam->sock, 1, 9, (void *)&optval, &optlen);
      if(!(return_value_getsockopt$1 >= 0))
      {
        motion_log(3, (unsigned int)4, 1, "%s: getsockopt()", (const void *)"netcam_connect");
        return -1;
      }

      motion_log(6, (unsigned int)4, 0, "%s: SO_KEEPALIVE is %s", (const void *)"netcam_connect", optval != 0 ? "ON" : "OFF");
      optval = 1;
      optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
      signed int return_value_setsockopt$2;
      return_value_setsockopt$2=setsockopt(netcam->sock, 1, 9, (const void *)&optval, optlen);
      if(!(return_value_setsockopt$2 >= 0))
      {
        motion_log(3, (unsigned int)4, 1, "%s: setsockopt()", (const void *)"netcam_connect");
        return -1;
      }

      motion_log(6, (unsigned int)4, 0, "%s: SO_KEEPALIVE set on socket.", (const void *)"netcam_connect");
    }

  motion_log(6, (unsigned int)4, 0, "%s: re-using socket %d since keepalive is set.", (const void *)"netcam_connect", netcam->sock);
  ret=getaddrinfo(netcam->connect_host, (const char *)(void *)0, (struct addrinfo *)(void *)0, &res);
  const char *return_value_gai_strerror$3;
  if(!(ret == 0))
  {
    if(err_flag == 0)
    {
      return_value_gai_strerror$3=gai_strerror(ret);
      motion_log(3, (unsigned int)4, 0, "%s: getaddrinfo() failed (%s): %s", (const void *)"netcam_connect", netcam->connect_host, return_value_gai_strerror$3);
    }

    motion_log(6, (unsigned int)4, 0, "%s: disconnecting netcam (1)", (const void *)"netcam_connect");
    netcam_disconnect(netcam);
    return -1;
  }

  memset((void *)&server, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  memcpy((void *)&server, (const void *)res->ai_addr, sizeof(struct sockaddr_in) /*16ul*/ );
  freeaddrinfo(res);
  server.sin_family = (unsigned short int)2;
  server.sin_port=htons((unsigned short int)netcam->connect_port);
  saveflags=fcntl(netcam->sock, 3, 0);
  if(!(saveflags >= 0))
  {
    motion_log(3, (unsigned int)4, 1, "%s: fcntl(1) on socket", (const void *)"netcam_connect");
    netcam_disconnect(netcam);
    return -1;
  }

  else
  {
    signed int return_value_fcntl$4;
    return_value_fcntl$4=fcntl(netcam->sock, 4, saveflags | 04000);
    if(!(return_value_fcntl$4 >= 0))
    {
      motion_log(3, (unsigned int)4, 1, "%s: fcntl(2) on socket", (const void *)"netcam_connect");
      netcam_disconnect(netcam);
      return -1;
    }

    else
    {
      ret=connect(netcam->sock, (struct sockaddr *)&server, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      back_err = *return_value___errno_location$5;
      if(!(back_err == 115) && !(ret >= 0))
      {
        if(err_flag == 0)
          motion_log(3, (unsigned int)4, 1, "%s: connect() failed (%d)", (const void *)"netcam_connect", back_err);

        motion_log(6, (unsigned int)4, 0, "%s: disconnecting netcam (4)", (const void *)"netcam_connect");
        netcam_disconnect(netcam);
        return -1;
      }

      else
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fd_w)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&fd_w)->fds_bits[(signed long int)(netcam->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fd_w)->fds_bits[(signed long int)(netcam->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << netcam->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        selecttime.tv_sec = (signed long int)10;
        selecttime.tv_usec = (signed long int)0;
        ret=select(1024, (struct anonymous$45 *)(void *)0, &fd_w, (struct anonymous$45 *)(void *)0, &selecttime);
        if(ret == 0)
        {
          if(err_flag == 0)
            motion_log(3, (unsigned int)4, 0, "%s: timeout on connect()", (const void *)"netcam_connect");

          motion_log(6, (unsigned int)4, 0, "%s: disconnecting netcam (2)", (const void *)"netcam_connect");
          netcam_disconnect(netcam);
          return -1;
        }

        else
        {
          len = (unsigned int)sizeof(signed int) /*4ul*/ ;
          signed int return_value_getsockopt$6;
          return_value_getsockopt$6=getsockopt(netcam->sock, 1, 4, (void *)&ret, &len);
          if(!(return_value_getsockopt$6 >= 0))
          {
            motion_log(3, (unsigned int)4, 0, "%s: getsockopt after connect", (const void *)"netcam_connect");
            netcam_disconnect(netcam);
            return -1;
          }

          else
            if(!(ret == 0))
            {
              if(err_flag == 0)
                motion_log(3, (unsigned int)4, 1, "%s: connect returned error", (const void *)"netcam_connect");

              motion_log(6, (unsigned int)4, 0, "%s: disconnecting netcam (3)", (const void *)"netcam_connect");
              netcam_disconnect(netcam);
              return -1;
            }

            else
            {
              rbuf_initialize(netcam);
              return 0;
            }
        }
      }
    }
  }
}

// netcam_disconnect
// file netcam.c line 834
static void netcam_disconnect(struct netcam_context *netcam)
{
  if(netcam->sock >= 1)
  {
    signed int return_value_close$1;
    return_value_close$1=close(netcam->sock);
    if(!(return_value_close$1 >= 0))
      motion_log(3, (unsigned int)4, 1, "%s: netcam_disconnect", (const void *)"netcam_disconnect");

    netcam->sock = -1;
  }

}

// netcam_error_exit
// file netcam_jpeg.c line 167
static void netcam_error_exit(struct jpeg_common_struct *cinfo)
{
  struct netcam_context *netcam = (struct netcam_context *)cinfo->client_data;
  cinfo->err->output_message(cinfo);
  netcam->jpeg_error = netcam->jpeg_error | 1;
  jpeg_destroy(cinfo);
  motion_log(6, (unsigned int)4, 0, "%s: netcam->jpeg_error %d", (const void *)"netcam_error_exit", netcam->jpeg_error);
  longjmp(netcam->setjmp_buffer, 1);
}

// netcam_fill_input_buffer
// file netcam_jpeg.c line 59
static signed int netcam_fill_input_buffer(struct jpeg_decompress_struct *cinfo)
{
  struct anonymous$0 *src = (struct anonymous$0 *)cinfo->src;
  unsigned long int nbytes;
  if(!(src->start_of_file == 0))
  {
    nbytes = (unsigned long int)src->length;
    src->buffer = (unsigned char *)src->data;
  }

  else
  {
    motion_log(6, (unsigned int)4, 0, "%s: **fake EOI inserted**", (const void *)"netcam_fill_input_buffer");
    src->buffer[(signed long int)0] = (unsigned char)0xFF;
    src->buffer[(signed long int)1] = (unsigned char)0xD9;
    nbytes = (unsigned long int)2;
  }
  src->pub.next_input_byte = src->buffer;
  src->pub.bytes_in_buffer = nbytes;
  src->start_of_file = 0;
  return 1;
}

// netcam_get_dimensions
// file netcam.h line 294
void netcam_get_dimensions(struct netcam_context *netcam)
{
  struct jpeg_decompress_struct cinfo;
  signed int ret;
  ret=netcam_init_jpeg(netcam, &cinfo);
  netcam->width = cinfo.output_width;
  netcam->height = cinfo.output_height;
  netcam->JFIF_marker = cinfo.saw_JFIF_marker;
  jpeg_destroy_decompress(&cinfo);
  motion_log(6, (unsigned int)4, 0, "%s: JFIF_marker %s PRESENT ret %d", (const void *)"netcam_get_dimensions", netcam->JFIF_marker != 0 ? "IS" : "NOT", ret);
}

// netcam_handler_loop
// file netcam.c line 1913
static void * netcam_handler_loop(void *arg)
{
  signed int retval;
  signed int open_error = 0;
  struct netcam_context *netcam = (struct netcam_context *)arg;
  struct context *cnt = netcam->cnt;
  pthread_setspecific(tls_key_threadnr, (void *)(unsigned long int)cnt->threadnr);
  motion_log(1, (unsigned int)4, 0, "%s: Camera handler thread [%d] started", (const void *)"netcam_handler_loop", netcam->threadnr);
  _Bool tmp_if_expr$3;
  signed int return_value_nanosleep$1;
  signed int return_value_nanosleep$5;
  while(netcam->finish == 0)
  {
    if(!(netcam->response == ((struct rbuf *)NULL)))
    {
      if((signed int)netcam->caps.streaming == 0)
      {
        _Bool tmp_if_expr$4;
        if(netcam->connect_keepalive == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          if(!(netcam->connect_keepalive == 0))
            tmp_if_expr$3 = netcam->keepalive_timeup != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          if(!(netcam->connect_keepalive == 0))
          {
            if(!(netcam->keepalive_timeup == 0))
            {
              motion_log(4, (unsigned int)4, 0, "%s: Closing netcam socket as Keep-Alive time is up (camera sent Close field). A reconnect should happen.", (const void *)"netcam_handler_loop");
              netcam_disconnect(netcam);
              netcam->keepalive_timeup = 0;
            }

          }

          signed int return_value_netcam_connect$2;
          return_value_netcam_connect$2=netcam_connect(netcam, open_error);
          if(!(return_value_netcam_connect$2 >= 0))
          {
            if(open_error == 0)
            {
              motion_log(4, (unsigned int)4, 0, "%s: re-opening camera (non-streaming)", (const void *)"netcam_handler_loop");
              open_error = 1;
            }

            struct timespec tv;
            tv.tv_sec = (signed long int)5;
            tv.tv_nsec = (signed long int)0;
            do
            {
              return_value_nanosleep$1=nanosleep(&tv, &tv);
              if(!(return_value_nanosleep$1 == -1))
                break;

            }
            while((_Bool)1);
            continue;
          }

          if(!(open_error == 0))
          {
            motion_log(4, (unsigned int)4, 0, "%s: camera re-connected", (const void *)"netcam_handler_loop");
            open_error = 0;
          }

        }

        retval=netcam_read_first_header(netcam);
        if(!(retval == 1))
        {
          if(retval >= 1)
            motion_log(3, (unsigned int)4, 0, "%s: Unrecognized image header (%d)", (const void *)"netcam_handler_loop", retval);

          else
            if(!(retval == -1))
              motion_log(3, (unsigned int)4, 0, "%s: Error in header (%d)", (const void *)"netcam_handler_loop", retval);

          continue;
        }

      }

      else
        if((signed int)netcam->caps.streaming == 1)
        {
          signed int return_value_netcam_read_next_header$8;
          return_value_netcam_read_next_header$8=netcam_read_next_header(netcam);
          if(!(return_value_netcam_read_next_header$8 >= 0))
          {
            signed int return_value_netcam_connect$6;
            return_value_netcam_connect$6=netcam_connect(netcam, open_error);
            if(!(return_value_netcam_connect$6 >= 0))
            {
              if(open_error == 0)
              {
                motion_log(3, (unsigned int)4, 0, "%s: re-opening camera (streaming)", (const void *)"netcam_handler_loop");
                open_error = 1;
              }

              struct timespec netcam_handler_loop$$1$$1$$1$$2$$1$$1$$2$$tv;
              netcam_handler_loop$$1$$1$$1$$2$$1$$1$$2$$tv.tv_sec = (signed long int)5;
              netcam_handler_loop$$1$$1$$1$$2$$1$$1$$2$$tv.tv_nsec = (signed long int)0;
              do
              {
                return_value_nanosleep$5=nanosleep(&netcam_handler_loop$$1$$1$$1$$2$$1$$1$$2$$tv, &netcam_handler_loop$$1$$1$$1$$2$$1$$1$$2$$tv);
                if(!(return_value_nanosleep$5 == -1))
                  break;

              }
              while((_Bool)1);
              continue;
            }

            signed int return_value_netcam_read_first_header$7;
            return_value_netcam_read_first_header$7=netcam_read_first_header(netcam);
            retval = (signed int)(return_value_netcam_read_first_header$7 != 2);
            if(!(retval == 0))
            {
              if(retval >= 1)
                motion_log(3, (unsigned int)4, 0, "%s: Unrecognized image header (%d)", (const void *)"netcam_handler_loop", retval);

              else
                if(!(retval == -1))
                  motion_log(3, (unsigned int)4, 0, "%s: Error in header (%d)", (const void *)"netcam_handler_loop", retval);

              continue;
            }

          }

          if(!(open_error == 0))
          {
            motion_log(3, (unsigned int)4, 0, "%s: camera re-connected", (const void *)"netcam_handler_loop");
            open_error = 0;
          }

        }

    }

    signed int return_value;
    return_value=netcam->get_image(netcam);
    if(!(return_value >= 0))
    {
      motion_log(3, (unsigned int)4, 0, "%s: Error getting jpeg image", (const void *)"netcam_handler_loop");
      if(!(netcam->ftp == ((struct ftp_context *)NULL)))
      {
        close(netcam->ftp->control_file_desc);
        signed int return_value_ftp_connect$9;
        return_value_ftp_connect$9=ftp_connect(netcam);
        if(!(return_value_ftp_connect$9 >= 0))
          motion_log(3, (unsigned int)4, 0, "%s: Trying to re-connect", (const void *)"netcam_handler_loop");

      }

    }

    else
      if((signed int)netcam->caps.streaming == 0)
      {
        pthread_mutex_lock(&netcam->mutex);
        if(!(netcam->finish == 0))
        {
          pthread_mutex_unlock(&netcam->mutex);
          break;
        }

        if(netcam->start_capture == 0)
          pthread_cond_wait(&netcam->cap_cond, &netcam->mutex);

        netcam->start_capture = 0;
        pthread_mutex_unlock(&netcam->mutex);
      }

  }
  pthread_mutex_lock(&global_lock);
  threads_running = threads_running - 1;
  pthread_mutex_unlock(&global_lock);
  motion_log(1, (unsigned int)4, 0, "%s: netcam camera handler: finish set, exiting", (const void *)"netcam_handler_loop");
  netcam->thread_id = (unsigned long int)0;
  pthread_mutex_lock(&netcam->mutex);
  pthread_cond_signal(&netcam->exiting);
  pthread_mutex_unlock(&netcam->mutex);
  pthread_exit((void *)0);
}

// netcam_http_build_url
// file netcam.c line 2104
static signed int netcam_http_build_url(struct netcam_context *netcam, struct url_t *url)
{
  struct context *cnt = netcam->cnt;
  const char *ptr;
  char *userpass;
  char *encuserpass;
  char *request_pass = (char *)(void *)0;
  signed int ix;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct rbuf) /*4120ul*/ );
  netcam->response = (struct rbuf *)return_value_mymalloc$1;
  memset((void *)netcam->response, 0, sizeof(struct rbuf) /*4120ul*/ );
  motion_log(6, (unsigned int)4, 0, "%s: Netcam has flags: HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.", (const void *)"netcam_http_build_url", netcam->connect_http_10 != 0 ? "1" : "0", netcam->connect_http_11 != 0 ? "1" : "0", netcam->connect_keepalive != 0 ? "ON" : "OFF");
  if(!(cnt->conf.netcam_userpass == ((const char *)NULL)))
    ptr = cnt->conf.netcam_userpass;

  else
    ptr = url->userpass;
  if(!(ptr == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(ptr);
    void *return_value_mymalloc$3;
    return_value_mymalloc$3=mymalloc(return_value_strlen$2 + (unsigned long int)3);
    userpass = (char *)return_value_mymalloc$3;
    strcpy(userpass, ptr);
  }

  else
    userpass = (char *)(void *)0;
  ix = 3;
  if(!(userpass == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(userpass);
    void *return_value_mymalloc$5;
    return_value_mymalloc$5=mymalloc((unsigned long int)4 * ((return_value_strlen$4 + (unsigned long int)2) / (unsigned long int)3) + (unsigned long int)1);
    encuserpass = (char *)return_value_mymalloc$5;
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(userpass);
    base64_encode(userpass, encuserpass, (signed int)return_value_strlen$6);
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(connect_auth_req);
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(encuserpass);
    void *return_value_mymalloc$9;
    return_value_mymalloc$9=mymalloc(return_value_strlen$7 + return_value_strlen$8 + (unsigned long int)1);
    request_pass = (char *)return_value_mymalloc$9;
    signed int return_value_sprintf$10;
    return_value_sprintf$10=sprintf(request_pass, connect_auth_req, encuserpass);
    ix = ix + return_value_sprintf$10;
    free((void *)encuserpass);
  }

  if(!(cnt->conf.netcam_proxy == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen$11;
    return_value_strlen$11=strlen(url->service);
    unsigned long int return_value_strlen$12;
    return_value_strlen$12=strlen(url->host);
    unsigned long int return_value_strlen$13;
    return_value_strlen$13=strlen(url->path);
    void *return_value_mymalloc$14;
    return_value_mymalloc$14=mymalloc(return_value_strlen$11 + return_value_strlen$12 + return_value_strlen$13 + (unsigned long int)4);
    ptr = (const char *)return_value_mymalloc$14;
    sprintf((char *)ptr, "http://%s%s", url->host, url->path);
    netcam->connect_keepalive = 0;
    free((void *)netcam->cnt->conf.netcam_keepalive);
    netcam->cnt->conf.netcam_keepalive=strdup("off");
    motion_log(5, (unsigned int)4, 0, "%s: Removed netcam_keepalive flag due to proxy set.Proxy is incompatible with Keep-Alive.", (const void *)"netcam_http_build_url");
  }

  else
  {
    ptr = url->path;
    url->path = (char *)(void *)0;
  }
  unsigned long int return_value_strlen$15;
  return_value_strlen$15=strlen(ptr);
  ix = ix + (signed int)return_value_strlen$15;
  unsigned long int return_value_strlen$16;
  unsigned long int return_value_strlen$17;
  if(!(netcam->connect_keepalive == 0))
  {
    return_value_strlen$16=strlen(connect_req_keepalive);
    ix = ix + (signed int)return_value_strlen$16;
  }

  else
  {
    return_value_strlen$17=strlen(connect_req_close);
    ix = ix + (signed int)return_value_strlen$17;
  }
  if(netcam->connect_http_11 == 1)
    connect_req = connect_req_http11;

  else
    connect_req = connect_req_http10;
  unsigned long int return_value_strlen$18;
  return_value_strlen$18=strlen(connect_req);
  unsigned long int return_value_strlen$19;
  return_value_strlen$19=strlen(netcam->connect_host);
  void *return_value_mymalloc$20;
  return_value_mymalloc$20=mymalloc(return_value_strlen$18 + (unsigned long int)ix + return_value_strlen$19);
  netcam->connect_request = (char *)return_value_mymalloc$20;
  sprintf(netcam->connect_request, connect_req, ptr, netcam->connect_host);
  if(!(netcam->connect_keepalive == 0))
    strcat(netcam->connect_request, connect_req_keepalive);

  else
    strcat(netcam->connect_request, connect_req_close);
  if(!(userpass == ((char *)NULL)))
  {
    strcat(netcam->connect_request, request_pass);
    free((void *)request_pass);
    free((void *)userpass);
  }

  strcat(netcam->connect_request, "\r\n");
  free((void *)ptr);
  netcam_url_free(url);
  motion_log(6, (unsigned int)4, 0, "%s: Camera connect string is ''%s'' End of camera connect string.", (const void *)"netcam_http_build_url", netcam->connect_request);
  return 0;
}

// netcam_http_request
// file netcam.c line 1387
static signed int netcam_http_request(struct netcam_context *netcam)
{
  signed int ix = 0;
  for( ; !(ix >= 5); ix = ix + 1)
  {
    motion_log(6, (unsigned int)4, 0, "%s: about to try to connect, time #%d", (const void *)"netcam_http_request", ix);
    signed int return_value_netcam_connect$1;
    return_value_netcam_connect$1=netcam_connect(netcam, 0);
    if(!(return_value_netcam_connect$1 == 0))
    {
      motion_log(3, (unsigned int)4, 0, "Failed to open camera - check your config and that netcamera is online", (const void *)"netcam_http_request");
      ix = 5;
      break;
    }

    signed int return_value_netcam_read_first_header$2;
    return_value_netcam_read_first_header$2=netcam_read_first_header(netcam);
    if(return_value_netcam_read_first_header$2 >= 0)
      break;

    motion_log(3, (unsigned int)4, 0, "%s: Error reading first header - re-trying", (const void *)"netcam_http_request");
  }
  if(ix == 5)
  {
    motion_log(3, (unsigned int)4, 0, "%s: Failed to read first camera header - giving up for now", (const void *)"netcam_http_request");
    return -1;
  }

  else
    return 0;
}

// netcam_image_conv
// file netcam_jpeg.c line 347
static signed int netcam_image_conv(struct netcam_context *netcam, struct jpeg_decompress_struct *cinfo, unsigned char *image)
{
  unsigned char **line;
  unsigned char *wline;
  signed int linesize;
  signed int i;
  unsigned char *upic;
  unsigned char *vpic;
  unsigned char *pic = image;
  unsigned char y;
  unsigned int width;
  unsigned int height;
  width = cinfo->output_width;
  height = cinfo->output_height;
  if(!(width == 0u))
  {
    _Bool tmp_if_expr$1;
    if(!(width == netcam->width))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = height != netcam->height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      motion_log(4, (unsigned int)4, 0, "%s: JPEG image size %dx%d, JPEG was %dx%d", (const void *)"netcam_image_conv", netcam->width, netcam->height, width, height);
      jpeg_destroy_decompress(cinfo);
      netcam->jpeg_error = netcam->jpeg_error | 4;
      return netcam->jpeg_error;
    }

  }

  upic = pic + (signed long int)(width * height);
  vpic = upic + (signed long int)((width * height) / (unsigned int)4);
  linesize = (signed int)(cinfo->output_width * (unsigned int)3);
  line=cinfo->mem->alloc_sarray((struct jpeg_common_struct *)cinfo, 1, cinfo->output_width * (unsigned int)cinfo->output_components, (unsigned int)1);
  wline = line[(signed long int)0];
  y = (unsigned char)0;
  if(!(cinfo->output_scanline >= height))
  {
    jpeg_read_scanlines(cinfo, line, (unsigned int)1);
    i = 0;
    if(!(i >= linesize))
    {
      pic[(signed long int)(i / 3)] = wline[(signed long int)i];
      if(!((1 & i) == 0))
      {
        upic[(signed long int)((i / 3) / 2)] = wline[(signed long int)(i + 1)];
        vpic[(signed long int)((i / 3) / 2)] = wline[(signed long int)(i + 2)];
      }

      i = i + 3;
    }

    pic = pic + (signed long int)(linesize / 3);
    unsigned char tmp_post$2 = y;
    y = y + 1;
    if(!((1 & (signed int)tmp_post$2) == 0))
    {
      upic = upic + (signed long int)(width / (unsigned int)2);
      vpic = vpic + (signed long int)(width / (unsigned int)2);
    }

  }

  jpeg_finish_decompress(cinfo);
  jpeg_destroy_decompress(cinfo);
  if(netcam->cnt->rotate_data.degrees >= 1)
    rotate_map(netcam->cnt, image);

  motion_log(6, (unsigned int)4, 0, "%s: jpeg_error %d", (const void *)"netcam_image_conv", netcam->jpeg_error);
  return netcam->jpeg_error;
}

// netcam_init_jpeg
// file netcam_jpeg.c line 242
static signed int netcam_init_jpeg(struct netcam_context *netcam, struct jpeg_decompress_struct *cinfo)
{
  struct netcam_image_buff *buff;
  pthread_mutex_lock(&netcam->mutex);
  if(netcam->imgcnt_last == netcam->imgcnt)
  {
    struct timespec waittime;
    struct timeval curtime;
    signed int retcode;
    gettimeofday(&curtime, (struct timezone *)(void *)0);
    curtime.tv_usec = curtime.tv_usec + (signed long int)500000;
    if(curtime.tv_usec >= 1000001l)
    {
      curtime.tv_usec = curtime.tv_usec - (signed long int)1000000;
      curtime.tv_sec = curtime.tv_sec + 1l;
    }

    waittime.tv_sec = curtime.tv_sec;
    waittime.tv_nsec = 1000L * curtime.tv_usec;
    do
      retcode=pthread_cond_timedwait(&netcam->pic_ready, &netcam->mutex, &waittime);
    while(retcode == 4);
    if(!(retcode == 0))
    {
      pthread_mutex_unlock(&netcam->mutex);
      motion_log(4, (unsigned int)4, 0, "%s: no new pic, no signal rcvd", (const void *)"netcam_init_jpeg");
      return 0x02 | 0x06;
    }

    motion_log(6, (unsigned int)4, 0, "%s: ***new pic delay successful***", (const void *)"netcam_init_jpeg");
  }

  netcam->imgcnt_last = netcam->imgcnt;
  buff = netcam->latest;
  netcam->latest = netcam->jpegbuf;
  netcam->jpegbuf = buff;
  pthread_mutex_unlock(&netcam->mutex);
  netcam->jpeg_error = 0;
  buff = netcam->jpegbuf;
  jpeg_CreateDecompress(cinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
  cinfo->err=jpeg_std_error(&netcam->jerr);
  cinfo->client_data = (void *)netcam;
  netcam->jerr.error_exit = netcam_error_exit;
  netcam->jerr.output_message = netcam_output_message;
  netcam_memory_src(cinfo, buff->ptr, (signed int)buff->used);
  jpeg_read_header(cinfo, 1);
  cinfo->out_color_space = (enum anonymous$10)JCS_YCbCr;
  jpeg_start_decompress(cinfo);
  motion_log(6, (unsigned int)4, 0, "%s: jpeg_error %d", (const void *)"netcam_init_jpeg", netcam->jpeg_error);
  return netcam->jpeg_error;
}

// netcam_init_source
// file netcam_jpeg.c line 48
static void netcam_init_source(struct jpeg_decompress_struct *cinfo)
{
  struct anonymous$0 *src = (struct anonymous$0 *)cinfo->src;
  src->start_of_file = 1;
}

// netcam_memory_src
// file netcam_jpeg.c line 129
static void netcam_memory_src(struct jpeg_decompress_struct *cinfo, char *data, signed int length)
{
  struct anonymous$0 *src;
  void *return_value;
  if(cinfo->src == ((struct jpeg_source_mgr *)NULL))
  {
    return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 0, sizeof(struct anonymous$0) /*88ul*/ );
    cinfo->src = (struct jpeg_source_mgr *)return_value;
  }

  src = (struct anonymous$0 *)cinfo->src;
  src->data = data;
  src->length = length;
  src->pub.init_source = netcam_init_source;
  src->pub.fill_input_buffer = netcam_fill_input_buffer;
  src->pub.skip_input_data = netcam_skip_input_data;
  src->pub.resync_to_restart = jpeg_resync_to_restart;
  src->pub.term_source = netcam_term_source;
  src->pub.bytes_in_buffer = (unsigned long int)0;
  src->pub.next_input_byte = (const unsigned char *)(void *)0;
}

// netcam_mjpg_buffer_refill
// file netcam.c line 1446
static signed int netcam_mjpg_buffer_refill(struct netcam_context *netcam)
{
  signed int retval;
  if(netcam->response->buffer_left >= 1ul)
    return (signed int)netcam->response->buffer_left;

  else
  {
    while((_Bool)1)
    {
      retval=rbuf_read_bufferful(netcam);
      if(!(retval >= 1))
      {
        motion_log(1, (unsigned int)4, 0, "%s: Read error, trying to reconnect..", (const void *)"netcam_mjpg_buffer_refill");
        signed int return_value_netcam_http_request$1;
        return_value_netcam_http_request$1=netcam_http_request(netcam);
        if(!(return_value_netcam_http_request$1 >= 0))
        {
          motion_log(2, (unsigned int)4, 0, "%s: lost the cam.", (const void *)"netcam_mjpg_buffer_refill");
          return -1;
        }

      }

      if(retval >= 1)
        break;

    }
    netcam->response->buffer_left = (unsigned long int)retval;
    netcam->response->buffer_pos = netcam->response->buffer;
    motion_log(6, (unsigned int)4, 0, "%s: Refilled buffer with [%d] bytes from the network.", (const void *)"netcam_mjpg_buffer_refill", retval);
    return retval;
  }
}

// netcam_next
// file netcam.h line 297
signed int netcam_next(struct context *cnt, unsigned char *image)
{
  struct netcam_context *netcam;
  _Bool tmp_if_expr$1;
  if(cnt == ((struct context *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(cnt->netcam != ((struct netcam_context *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -2;

  else
  {
    netcam = cnt->netcam;
    if(netcam->latest->used == 0ul)
    {
      motion_log(4, (unsigned int)4, 0, "%s: called with no data in buffer", (const void *)"netcam_next");
      return 0x06;
    }

    else
    {
      if((signed int)netcam->caps.streaming == 0)
      {
        pthread_mutex_lock(&netcam->mutex);
        netcam->start_capture = 1;
        pthread_cond_signal(&netcam->cap_cond);
        pthread_mutex_unlock(&netcam->mutex);
      }

      if((signed int)netcam->caps.streaming == 3)
      {
        memcpy((void *)image, (const void *)netcam->latest->ptr, netcam->latest->used);
        return 0;
      }

      else
      {
        signed int return_value__setjmp$2;
        return_value__setjmp$2=_setjmp(netcam->setjmp_buffer);
        if(!(return_value__setjmp$2 == 0))
          return 0x02 | 0x0a;

        else
        {
          signed int return_value_netcam_proc_jpeg$3;
          return_value_netcam_proc_jpeg$3=netcam_proc_jpeg(netcam, image);
          return return_value_netcam_proc_jpeg$3;
        }
      }
    }
  }
}

// netcam_output_message
// file netcam_jpeg.c line 199
static void netcam_output_message(struct jpeg_common_struct *cinfo)
{
  char buffer[200l];
  struct netcam_context *netcam = (struct netcam_context *)cinfo->client_data;
  if(!(cinfo->err->msg_code == 116))
  {
    if(cinfo->err->msg_code == 122)
    {
      if(netcam->netcam_tolerant_check == 0u)
        netcam->jpeg_error = netcam->jpeg_error | 2;

    }

  }

  cinfo->err->format_message(cinfo, buffer);
  motion_log(7, (unsigned int)4, 0, "%s: %s", (const void *)"netcam_output_message", (const void *)buffer);
}

// netcam_proc_jpeg
// file netcam.h line 293
signed int netcam_proc_jpeg(struct netcam_context *netcam, unsigned char *image)
{
  struct jpeg_decompress_struct cinfo;
  signed int retval = 0;
  signed int ret;
  motion_log(6, (unsigned int)4, 0, "%s: processing jpeg image - content length %d", (const void *)"netcam_proc_jpeg", netcam->latest->content_length);
  ret=netcam_init_jpeg(netcam, &cinfo);
  if(!(ret == 0))
  {
    motion_log(6, (unsigned int)4, 0, "%s: ret %d", (const void *)"netcam_proc_jpeg", ret);
    return ret;
  }

  else
  {
    if(!(netcam->width == 0u))
    {
      _Bool tmp_if_expr$1;
      if(!(cinfo.output_width == netcam->width))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = cinfo.output_height != netcam->height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        retval = 0x12;
        motion_log(3, (unsigned int)4, 0, "%s: Camera width/height mismatch with JPEG image - expected %dx%d, JPEG %dx%d", (const void *)"netcam_proc_jpeg", (const void *)" retval %d", netcam->width, netcam->height, cinfo.output_width, cinfo.output_height, retval);
        return retval;
      }

    }

    ret=netcam_image_conv(netcam, &cinfo, image);
    if(!(ret == 0))
    {
      retval = retval | 0x0a;
      motion_log(6, (unsigned int)4, 0, "%s: ret %d retval %d", (const void *)"netcam_proc_jpeg", ret, retval);
    }

    return retval;
  }
}

// netcam_read_file_jpeg
// file netcam.c line 1732
static signed int netcam_read_file_jpeg(struct netcam_context *netcam)
{
  signed int loop_counter = 0;
  motion_log(7, (unsigned int)4, 0, "%s: Begin", (const void *)"netcam_read_file_jpeg");
  struct netcam_image_buff *buffer;
  signed int len;
  struct netcam_image_buff *xchg;
  struct timeval curtime;
  struct stat statbuf;
  buffer = netcam->receiving;
  buffer->used = (unsigned long int)0;
  signed int return_value_nanosleep$2;
  do
  {
    signed int return_value_stat$1;
    return_value_stat$1=stat(netcam->file->path, &statbuf);
    if(!(return_value_stat$1 == 0))
    {
      motion_log(2, (unsigned int)4, 1, "%s: stat(%s) error", (const void *)"netcam_read_file_jpeg", netcam->file->path);
      return -1;
    }

    motion_log(7, (unsigned int)4, 0, "%s: statbuf.st_mtime[%d] != last_st_mtime[%d]", (const void *)"netcam_read_file_jpeg", statbuf.st_mtim.tv_sec, netcam->file->last_st_mtime);
    if(loop_counter >= 11)
    {
      motion_log(2, (unsigned int)4, 0, "%s: waiting new file image timeout", (const void *)"netcam_read_file_jpeg");
      return -1;
    }

    motion_log(7, (unsigned int)4, 0, "%s: delay waiting new file image ", (const void *)"netcam_read_file_jpeg");
    struct timespec tv;
    tv.tv_sec = (signed long int)0;
    tv.tv_nsec = (signed long int)(500 * 1000 * 1000);
    do
    {
      return_value_nanosleep$2=nanosleep(&tv, &tv);
      if(!(return_value_nanosleep$2 == -1))
        break;

    }
    while((_Bool)1);
    loop_counter = loop_counter + 1;
  }
  while(statbuf.st_mtim.tv_sec == netcam->file->last_st_mtime);
  netcam->file->last_st_mtime = statbuf.st_mtim.tv_sec;
  motion_log(6, (unsigned int)4, 0, "%s: processing new file image - st_mtime %d", (const void *)"netcam_read_file_jpeg", netcam->file->last_st_mtime);
  while(!(buffer->size >= (unsigned long int)statbuf.st_size))
    netcam_check_buffsize(buffer, (unsigned long int)statbuf.st_size);
  netcam->file->control_file_desc=open(netcam->file->path, 00);
  if(!(netcam->file->control_file_desc >= 0))
  {
    motion_log(2, (unsigned int)4, 0, "%s: open(%s) error: %d", (const void *)"netcam_read_file_jpeg", netcam->file->path, netcam->file->control_file_desc);
    return -1;
  }

  else
  {
    signed long int return_value_read$3;
    return_value_read$3=read(netcam->file->control_file_desc, (void *)(buffer->ptr + (signed long int)buffer->used), (unsigned long int)statbuf.st_size);
    len = (signed int)return_value_read$3;
    if(!(len >= 0))
    {
      motion_log(2, (unsigned int)4, 0, "%s: read(%s) error: %d", (const void *)"netcam_read_file_jpeg", netcam->file->control_file_desc, len);
      return -1;
    }

    else
    {
      buffer->used = buffer->used + (unsigned long int)len;
      close(netcam->file->control_file_desc);
      signed int return_value_gettimeofday$4;
      return_value_gettimeofday$4=gettimeofday(&curtime, (struct timezone *)(void *)0);
      if(!(return_value_gettimeofday$4 >= 0))
        motion_log(4, (unsigned int)4, 1, "%s: gettimeofday", (const void *)"netcam_read_file_jpeg");

      netcam->receiving->image_time = curtime;
      if(!(netcam->last_image.tv_sec == 0l))
      {
        netcam->av_frame_time = (float)((9.0 * (double)netcam->av_frame_time + 1000000.0 * (double)(curtime.tv_sec - netcam->last_image.tv_sec) + (double)(curtime.tv_usec - netcam->last_image.tv_usec)) / 10.0);
        motion_log(7, (unsigned int)4, 0, "%s: Calculated frame time %f", (const void *)"netcam_read_file_jpeg", netcam->av_frame_time);
      }

      netcam->last_image = curtime;
      pthread_mutex_lock(&netcam->mutex);
      xchg = netcam->latest;
      netcam->latest = netcam->receiving;
      netcam->receiving = xchg;
      netcam->imgcnt = netcam->imgcnt + 1;
      pthread_cond_signal(&netcam->pic_ready);
      pthread_mutex_unlock(&netcam->mutex);
      motion_log(7, (unsigned int)4, 0, "%s: End", (const void *)"netcam_read_file_jpeg");
      return 0;
    }
  }
}

// netcam_read_first_header
// file netcam.c line 552
static signed int netcam_read_first_header(struct netcam_context *netcam)
{
  signed int retval = -3;
  signed int ret;
  signed int firstflag = 1;
  signed int aliveflag = 0;
  signed int closeflag = 0;
  char *header;
  char *boundary;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(netcam->connect_request);
  signed long int return_value_send$2;
  return_value_send$2=send(netcam->sock, (const void *)netcam->connect_request, return_value_strlen$1, 0);
  signed long int return_value_netcam_check_content_length$5;
  signed int return_value_netcam_check_keepalive$4;
  signed int return_value_netcam_check_close$3;
  if(!(return_value_send$2 >= 0l))
  {
    motion_log(3, (unsigned int)4, 1, "%s: Error sending 'connect' request", (const void *)"netcam_read_first_header");
    return -1;
  }

  else
  {
    while((_Bool)1)
    {
      ret=header_get(netcam, &header, (enum header_get_flags)HG_NONE);
      motion_log(6, (unsigned int)4, 0, "%s: Received first header ('%s')", (const void *)"netcam_read_first_header", header);
      if(!(ret == 0))
      {
        motion_log(4, (unsigned int)4, 0, "%s: Error reading first header (%s)", (const void *)"netcam_read_first_header", header);
        free((void *)header);
        return -1;
      }

      if(!(firstflag == 0))
      {
        ret=http_result_code(header);
        if(!(ret == 200))
        {
          motion_log(6, (unsigned int)4, 0, "%s: HTTP Result code %d", (const void *)"netcam_read_first_header", ret);
          free((void *)header);
          if(!(netcam->connect_keepalive == 0))
          {
            netcam->connect_keepalive = 0;
            free((void *)netcam->cnt->conf.netcam_keepalive);
            netcam->cnt->conf.netcam_keepalive=strdup("off");
            motion_log(5, (unsigned int)4, 0, "%s: Removed netcam Keep-Alive flagdue to apparent closed HTTP connection.", (const void *)"netcam_read_first_header");
          }

          return ret;
        }

        firstflag = 0;
        free((void *)header);
      }

      else
      {
        if((signed int)*header == 0)
          break;

        ret=netcam_check_content_type(header);
        if(ret >= 0)
        {
          retval = ret;
          switch(ret)
          {
            case 1:
            {
              if(!(netcam->connect_keepalive == 0))
                motion_log(5, (unsigned int)4, 0, "%s: Non-streaming camera (keep-alive set)", (const void *)"netcam_read_first_header");

              else
                motion_log(5, (unsigned int)4, 0, "%s: Non-streaming camera (keep-alive not set)", (const void *)"netcam_read_first_header");
              netcam->caps.streaming = (unsigned char)0;
              break;
            }
            case 2:
            {
              motion_log(6, (unsigned int)4, 0, "%s: Streaming camera", (const void *)"netcam_read_first_header");
              netcam->caps.streaming = (unsigned char)1;
              boundary=strstr(header, "boundary=");
              if(!(boundary == ((char *)NULL)))
              {
                if(!(netcam->boundary == ((char *)NULL)))
                  free((void *)netcam->boundary);

                netcam->boundary=mystrdup(boundary + (signed long int)9);
                check_quote(netcam->boundary);
                netcam->boundary_length=strlen(netcam->boundary);
                motion_log(6, (unsigned int)4, 0, "%s: Boundary string [%s]", (const void *)"netcam_read_first_header", netcam->boundary);
              }

              break;
            }
            case 3:
            {
              motion_log(5, (unsigned int)4, 0, "%s: Streaming camera probably using MJPG-blocks, consider using mjpg:// netcam_url.", (const void *)"netcam_read_first_header");
              break;
            }
            default:
            {
              motion_log(3, (unsigned int)4, 0, "%s: Unrecognized content type", (const void *)"netcam_read_first_header");
              free((void *)header);
              return -1;
            }
          }
        }

        else
        {
          return_value_netcam_check_content_length$5=netcam_check_content_length(header);
          ret = (signed int)return_value_netcam_check_content_length$5;
          if(ret >= 0)
          {
            motion_log(5, (unsigned int)4, 0, "%s: Content-length present", (const void *)"netcam_read_first_header");
            if(ret >= 1)
            {
              netcam->caps.content_length = (unsigned char)1;
              netcam->receiving->content_length = ret;
            }

            else
            {
              netcam->receiving->content_length = 0;
              motion_log(3, (unsigned int)4, 0, "%s: Content-length 0", (const void *)"netcam_read_first_header");
              retval = -2;
            }
          }

          else
          {
            return_value_netcam_check_keepalive$4=netcam_check_keepalive(header);
            if(return_value_netcam_check_keepalive$4 == 1)
            {
              aliveflag = 1;
              netcam->keepalive_thisconn = 1;
            }

            else
            {
              return_value_netcam_check_close$3=netcam_check_close(header);
              if(return_value_netcam_check_close$3 == 1)
              {
                closeflag = 1;
                motion_log(5, (unsigned int)4, 0, "%s: Found Conn: close header ('%s')", (const void *)"netcam_read_first_header", header);
              }

            }
          }
        }
        free((void *)header);
      }
    }
    free((void *)header);
    if((signed int)netcam->caps.streaming == 0)
    {
      if(!(netcam->connect_keepalive == 0))
      {
        if(!(aliveflag == 0))
        {
          if(!(closeflag == 0))
          {
            netcam->warning_count = netcam->warning_count + 1;
            if(netcam->warning_count >= 4)
            {
              netcam->warning_count = 0;
              motion_log(6, (unsigned int)4, 0, "%s: Both 'Connection: Keep-Alive' and 'Connection: close' header received. Motion removes keepalive.", (const void *)"netcam_read_first_header");
              netcam->connect_keepalive = 0;
              free((void *)netcam->cnt->conf.netcam_keepalive);
              netcam->cnt->conf.netcam_keepalive=strdup("off");
            }

            else
              motion_log(6, (unsigned int)4, 0, "%s: Both 'Connection: Keep-Alive' and 'Connection: close' header received. Motion continues unchanged.", (const void *)"netcam_read_first_header");
          }

          else
            motion_log(6, (unsigned int)4, 0, "%s: Received a Keep-Alive field in thisset of headers.", (const void *)"netcam_read_first_header");
        }

        else
          if(closeflag == 0)
          {
            netcam->warning_count = netcam->warning_count + 1;
            if(netcam->warning_count >= 4)
            {
              netcam->warning_count = 0;
              motion_log(6, (unsigned int)4, 0, "%s: No 'Connection: Keep-Alive' nor 'Connection: close' header received.\n Motion removes keepalive.", (const void *)"netcam_read_first_header");
              netcam->connect_keepalive = 0;
              free((void *)netcam->cnt->conf.netcam_keepalive);
              netcam->cnt->conf.netcam_keepalive=strdup("off");
            }

            else
              motion_log(6, (unsigned int)4, 0, "%s: No 'Connection: Keep-Alive' nor 'Connection: close' header received.\n Motion continues unchanged.", (const void *)"netcam_read_first_header");
          }

          else
            if(netcam->keepalive_thisconn == 0)
            {
              netcam->connect_keepalive = 0;
              free((void *)netcam->cnt->conf.netcam_keepalive);
              netcam->cnt->conf.netcam_keepalive=strdup("off");
              motion_log(6, (unsigned int)4, 0, "%s: Removed netcam Keep-Alive flag because 'Connection: close' header received.\n Netcam does not support Keep-Alive. Motion continues in non-Keep-Alive.", (const void *)"netcam_read_first_header");
            }

            else
            {
              netcam->keepalive_timeup = 1;
              motion_log(6, (unsigned int)4, 0, "Keep-Alive has reached end of valid period.\nMotion will close netcam, then resume Keep-Alive with a new socket.", (const void *)"netcam_read_first_header");
            }
      }

    }

    return retval;
  }
}

// netcam_read_ftp_jpeg
// file netcam.c line 1650
static signed int netcam_read_ftp_jpeg(struct netcam_context *netcam)
{
  struct netcam_image_buff *buffer;
  signed int len;
  struct netcam_image_buff *xchg;
  struct timeval curtime;
  buffer = netcam->receiving;
  buffer->used = (unsigned long int)0;
  signed int return_value_ftp_get_socket$1;
  return_value_ftp_get_socket$1=ftp_get_socket(netcam->ftp);
  if(!(return_value_ftp_get_socket$1 >= 1))
  {
    motion_log(3, (unsigned int)4, 0, "%s: ftp_get_socket failed", (const void *)"netcam_read_ftp_jpeg");
    return -1;
  }

  else
  {
    do
    {
      netcam_check_buffsize(buffer, (unsigned long int)1024);
      len=ftp_read(netcam->ftp, (void *)(buffer->ptr + (signed long int)buffer->used), 1024);
      if(!(len >= 0))
        return -1;

      buffer->used = buffer->used + (unsigned long int)len;
    }
    while(len >= 1);
    signed int return_value_gettimeofday$2;
    return_value_gettimeofday$2=gettimeofday(&curtime, (struct timezone *)(void *)0);
    if(!(return_value_gettimeofday$2 >= 0))
      motion_log(4, (unsigned int)4, 1, "%s: gettimeofday", (const void *)"netcam_read_ftp_jpeg");

    netcam->receiving->image_time = curtime;
    if(!(netcam->last_image.tv_sec == 0l))
    {
      netcam->av_frame_time = (float)((9.0 * (double)netcam->av_frame_time + 1000000.0 * (double)(curtime.tv_sec - netcam->last_image.tv_sec) + (double)(curtime.tv_usec - netcam->last_image.tv_usec)) / 10.0);
      motion_log(7, (unsigned int)4, 0, "%s: Calculated frame time %f", (const void *)"netcam_read_ftp_jpeg", netcam->av_frame_time);
    }

    netcam->last_image = curtime;
    pthread_mutex_lock(&netcam->mutex);
    xchg = netcam->latest;
    netcam->latest = netcam->receiving;
    netcam->receiving = xchg;
    netcam->imgcnt = netcam->imgcnt + 1;
    pthread_cond_signal(&netcam->pic_ready);
    pthread_mutex_unlock(&netcam->mutex);
    return 0;
  }
}

// netcam_read_html_jpeg
// file netcam.c line 1132
static signed int netcam_read_html_jpeg(struct netcam_context *netcam)
{
  struct netcam_image_buff *buffer;
  unsigned long int remaining;
  unsigned long int maxflush;
  unsigned long int rem;
  unsigned long int rlen;
  unsigned long int ix;
  signed int retval;
  char *ptr;
  char *bptr;
  char *rptr;
  struct netcam_image_buff *xchg;
  struct timeval curtime;
  buffer = netcam->receiving;
  buffer->used = (unsigned long int)0;
  if(!(buffer->content_length == 0))
    remaining = (unsigned long int)buffer->content_length;

  else
    remaining = (unsigned long int)999999;
  _Bool tmp_if_expr$2;
  while(!(remaining == 0ul))
  {
    if(!(netcam->response->buffer_left >= 1ul))
    {
      retval=rbuf_read_bufferful(netcam);
      if(!(retval >= 1))
        break;

      netcam->response->buffer_left = (unsigned long int)retval;
      netcam->response->buffer_pos = netcam->response->buffer;
    }

    bptr = netcam->boundary;
    if(!(bptr == ((char *)NULL)))
    {
      rptr = netcam->response->buffer_pos;
      rlen = netcam->response->buffer_left;
      while((_Bool)1)
      {
        if(!(remaining >= rlen))
          rlen = remaining;

        if(!(remaining >= netcam->boundary_length))
          break;

        void *return_value_memchr$1;
        return_value_memchr$1=memchr((const void *)rptr, (signed int)*bptr, rlen);
        ptr = (char *)return_value_memchr$1;
        if(ptr == ((char *)NULL))
          break;

        rem = rlen - (unsigned long int)(ptr - rptr);
        ix = (unsigned long int)1;
        do
        {
          if(!(ix >= rem))
            tmp_if_expr$2 = ix < netcam->boundary_length ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(!tmp_if_expr$2)
            break;

          if(!(ptr[(signed long int)ix] == bptr[(signed long int)ix]))
            break;

          ix = ix + 1ul;
        }
        while((_Bool)1);
        if(!(ix == netcam->boundary_length))
        {
          if(ix == rem)
            goto __CPROVER_DUMP_L10;

          ix = (unsigned long int)((ptr - rptr) + (signed long int)1);
          rptr = rptr + (signed long int)ix;
          rlen = rlen - ix;
          if(!(rlen >= 1ul))
            break;

        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          if(ix == netcam->boundary_length)
          {
            if(!(ptr - netcam->response->buffer >= (signed long int)(signed int)remaining))
              remaining = (unsigned long int)(ptr - netcam->response->buffer);

            break;
          }

          if(!(ptr == netcam->response->buffer))
          {
            ix = (unsigned long int)(ptr - netcam->response->buffer_pos);
            netcam_check_buffsize(buffer, ix);
            retval=rbuf_flush(netcam, buffer->ptr + (signed long int)buffer->used, (signed int)ix);
            buffer->used = buffer->used + (unsigned long int)retval;
            remaining = remaining - (unsigned long int)retval;
            motion_log(5, (unsigned int)4, 0, "%s: Potential split boundary - %d chars flushed, %d re-positioned", (const void *)"netcam_read_html_jpeg", ix, (signed int)netcam->response->buffer_left);
            memmove((void *)netcam->response->buffer, (const void *)ptr, netcam->response->buffer_left);
          }

          signed long int return_value_netcam_recv$3;
          return_value_netcam_recv$3=netcam_recv(netcam, (void *)(netcam->response->buffer + (signed long int)netcam->response->buffer_left), sizeof(char [4096l]) /*4096ul*/  - netcam->response->buffer_left);
          retval = (signed int)return_value_netcam_recv$3;
          if(!(retval >= 1))
          {
            motion_log(3, (unsigned int)4, 1, "%s: recv() fail after boundary string", (const void *)"netcam_read_html_jpeg");
            return -1;
          }

          netcam->response->buffer_left = (unsigned long int)retval + netcam->response->buffer_left;
          netcam->response->buffer_pos = netcam->response->buffer;
          bptr = (char *)(void *)0;
          break;
        }
      }
      if(bptr == ((char *)NULL))
        continue;

    }

    if(!(remaining == 0ul))
    {
      unsigned long int tmp_if_expr$4;
      if(!(netcam->response->buffer_left >= remaining))
        tmp_if_expr$4 = netcam->response->buffer_left;

      else
        tmp_if_expr$4 = remaining;
      maxflush = tmp_if_expr$4;
      netcam_check_buffsize(buffer, maxflush);
      retval=rbuf_flush(netcam, buffer->ptr + (signed long int)buffer->used, (signed int)maxflush);
      buffer->used = buffer->used + (unsigned long int)retval;
      remaining = remaining - (unsigned long int)retval;
    }

  }
  signed int return_value_gettimeofday$5;
  return_value_gettimeofday$5=gettimeofday(&curtime, (struct timezone *)(void *)0);
  if(!(return_value_gettimeofday$5 >= 0))
    motion_log(4, (unsigned int)4, 1, "%s: gettimeofday", (const void *)"netcam_read_html_jpeg");

  netcam->receiving->image_time = curtime;
  if(!(netcam->last_image.tv_sec == 0l))
  {
    netcam->av_frame_time = (float)((9.0 * (double)netcam->av_frame_time + 1000000.0 * (double)(curtime.tv_sec - netcam->last_image.tv_sec) + (double)(curtime.tv_usec - netcam->last_image.tv_usec)) / 10.0);
    motion_log(7, (unsigned int)4, 0, "%s: Calculated frame time %f", (const void *)"netcam_read_html_jpeg", netcam->av_frame_time);
  }

  netcam->last_image = curtime;
  pthread_mutex_lock(&netcam->mutex);
  xchg = netcam->latest;
  netcam->latest = netcam->receiving;
  netcam->receiving = xchg;
  netcam->imgcnt = netcam->imgcnt + 1;
  pthread_cond_signal(&netcam->pic_ready);
  pthread_mutex_unlock(&netcam->mutex);
  if((signed int)netcam->caps.streaming == 0)
  {
    if(netcam->connect_keepalive == 0)
    {
      motion_log(5, (unsigned int)4, 0, "%s: disconnecting netcam since keep-alive not set.", (const void *)"netcam_read_html_jpeg");
      netcam_disconnect(netcam);
    }

    motion_log(5, (unsigned int)4, 0, "%s: leaving netcam connected.", (const void *)"netcam_read_html_jpeg");
  }

  return 0;
}

// netcam_read_mjpg_jpeg
// file netcam.c line 1511
static signed int netcam_read_mjpg_jpeg(struct netcam_context *netcam)
{
  struct netcam_image_buff *buffer;
  struct netcam_image_buff *xchg;
  struct timeval curtime;
  struct anonymous$47 mh;
  unsigned long int read_bytes;
  signed int retval;
  buffer = netcam->receiving;
  buffer->used = (unsigned long int)0;
  signed int return_value_netcam_mjpg_buffer_refill$1;
  return_value_netcam_mjpg_buffer_refill$1=netcam_mjpg_buffer_refill(netcam);
  if(!(return_value_netcam_mjpg_buffer_refill$1 >= 0))
    return -1;

  else
  {
    while((_Bool)1)
    {
      read_bytes = (unsigned long int)0;
      while(!(read_bytes >= sizeof(struct anonymous$47) /*48ul*/ ))
      {
        retval=rbuf_flush(netcam, (char *)&mh + (signed long int)read_bytes, (signed int)(sizeof(struct anonymous$47) /*48ul*/  - read_bytes));
        read_bytes = read_bytes + (unsigned long int)retval;
        motion_log(6, (unsigned int)4, 0, "%s: Read [%d/%d] header bytes.", (const void *)"netcam_read_mjpg_jpeg", read_bytes, sizeof(struct anonymous$47) /*48ul*/ );
        if(!(read_bytes >= sizeof(struct anonymous$47) /*48ul*/ ))
        {
          signed int return_value_netcam_mjpg_buffer_refill$2;
          return_value_netcam_mjpg_buffer_refill$2=netcam_mjpg_buffer_refill(netcam);
          if(!(return_value_netcam_mjpg_buffer_refill$2 >= 0))
            return -1;

        }

      }
      signed int return_value_strncmp$4;
      return_value_strncmp$4=strncmp(mh.mh_magic, "MJPG", (unsigned long int)4);
      if(!(return_value_strncmp$4 == 0))
      {
        motion_log(4, (unsigned int)4, 0, "%s: Invalid header received, reconnecting", (const void *)"netcam_read_mjpg_jpeg");
        signed int return_value_netcam_http_request$3;
        return_value_netcam_http_request$3=netcam_http_request(netcam);
        if(!(return_value_netcam_http_request$3 >= 0))
          return -1;

        buffer->used = (unsigned long int)0;
        continue;
      }

      netcam_check_buffsize(buffer, (unsigned long int)(signed int)mh.mh_chunksize);
      read_bytes = (unsigned long int)0;
      while(!(read_bytes >= (unsigned long int)mh.mh_chunksize))
      {
        retval=rbuf_flush(netcam, buffer->ptr + (signed long int)buffer->used + (signed long int)read_bytes, (signed int)((unsigned long int)mh.mh_chunksize - read_bytes));
        read_bytes = read_bytes + (unsigned long int)retval;
        motion_log(7, (unsigned int)4, 0, "%s: Read [%d/%d] chunk bytes, [%d/%d] total", (const void *)"netcam_read_mjpg_jpeg", read_bytes, mh.mh_chunksize, buffer->used + read_bytes, mh.mh_framesize);
        if(!(retval >= (signed int)(unsigned long int)mh.mh_chunksize + -((signed int)read_bytes)))
        {
          signed int return_value_netcam_mjpg_buffer_refill$5;
          return_value_netcam_mjpg_buffer_refill$5=netcam_mjpg_buffer_refill(netcam);
          if(!(return_value_netcam_mjpg_buffer_refill$5 >= 0))
            return -1;

        }

      }
      buffer->used = buffer->used + read_bytes;
      motion_log(7, (unsigned int)4, 0, "%s: Chunk complete, buffer used [%d] bytes.", (const void *)"netcam_read_mjpg_jpeg", buffer->used);
      if((unsigned long int)mh.mh_framesize == buffer->used)
      {
        motion_log(7, (unsigned int)4, 0, "%s: Image complete, buffer used [%d] bytes.", (const void *)"netcam_read_mjpg_jpeg", buffer->used);
        break;
      }

    }
    signed int return_value_gettimeofday$6;
    return_value_gettimeofday$6=gettimeofday(&curtime, (struct timezone *)(void *)0);
    if(!(return_value_gettimeofday$6 >= 0))
      motion_log(4, (unsigned int)4, 1, "%s: gettimeofday", (const void *)"netcam_read_mjpg_jpeg");

    netcam->receiving->image_time = curtime;
    if(!(netcam->last_image.tv_sec == 0l))
    {
      netcam->av_frame_time = (float)((9.0 * (double)netcam->av_frame_time + 1000000.0 * (double)(curtime.tv_sec - netcam->last_image.tv_sec) + (double)(curtime.tv_usec - netcam->last_image.tv_usec)) / 10.0);
      motion_log(7, (unsigned int)4, 0, "%s: Calculated frame time %f", (const void *)"netcam_read_mjpg_jpeg", netcam->av_frame_time);
    }

    netcam->last_image = curtime;
    pthread_mutex_lock(&netcam->mutex);
    xchg = netcam->latest;
    netcam->latest = netcam->receiving;
    netcam->receiving = xchg;
    netcam->imgcnt = netcam->imgcnt + 1;
    pthread_cond_signal(&netcam->pic_ready);
    pthread_mutex_unlock(&netcam->mutex);
    return 0;
  }
}

// netcam_read_next_header
// file netcam.c line 439
static signed int netcam_read_next_header(struct netcam_context *netcam)
{
  signed int retval;
  char *header;
  if(netcam->sock == -1)
    return -1;

  else
  {
    netcam->caps.content_length = (unsigned char)0;
    if((signed int)netcam->caps.streaming == 1)
      while((_Bool)1)
      {
        retval=header_get(netcam, &header, (enum header_get_flags)HG_NONE);
        if(!(retval == 0))
        {
          unsigned long int return_value_strlen$1;
          return_value_strlen$1=strlen(header);
          if(return_value_strlen$1 == 0ul)
            motion_log(4, (unsigned int)4, 0, "%s: Error reading image header, streaming mode (1). Null header.", (const void *)"netcam_read_next_header");

          else
            motion_log(4, (unsigned int)4, 0, "%s: Error reading image header, streaming mode (1). Unknown header '%s'", (const void *)"netcam_read_next_header", header);
          free((void *)header);
          return -1;
        }

        char *return_value_strstr$2;
        return_value_strstr$2=strstr(header, netcam->boundary);
        retval = (signed int)(return_value_strstr$2 == (char *)(void *)0);
        free((void *)header);
        if(retval == 0)
          break;

      }

    while((_Bool)1)
    {
      retval=header_get(netcam, &header, (enum header_get_flags)HG_NONE);
      if(!(retval == 0))
      {
        motion_log(3, (unsigned int)4, 0, "%s: Error reading image header (2)", (const void *)"netcam_read_next_header");
        free((void *)header);
        return -1;
      }

      if((signed int)*header == 0)
        break;

      retval=netcam_check_content_type(header);
      if(retval >= 0)
      {
        if(!(retval == 1))
        {
          motion_log(3, (unsigned int)4, 0, "%s: Header not JPEG", (const void *)"netcam_read_next_header");
          free((void *)header);
          return -1;
        }

      }

      signed long int return_value_netcam_check_content_length$3;
      return_value_netcam_check_content_length$3=netcam_check_content_length(header);
      retval = (signed int)return_value_netcam_check_content_length$3;
      if(retval >= 0)
      {
        if(retval >= 1)
        {
          netcam->caps.content_length = (unsigned char)1;
          netcam->receiving->content_length = retval;
        }

        else
        {
          netcam->receiving->content_length = 0;
          motion_log(3, (unsigned int)4, 0, "%s: Content-Length 0", (const void *)"netcam_read_next_header");
          free((void *)header);
          return -1;
        }
      }

      free((void *)header);
    }
    motion_log(6, (unsigned int)4, 0, "%s: Found image header record", (const void *)"netcam_read_next_header");
    free((void *)header);
    return 0;
  }
}

// netcam_read_rtsp_image
// file netcam_rtsp.h line 22
signed int netcam_read_rtsp_image(struct netcam_context *netcam)
{
  if(netcam->rtsp == ((struct rtsp_context *)NULL))
  {
    signed int return_value_rtsp_connect$1;
    return_value_rtsp_connect$1=rtsp_connect(netcam);
    if(!(return_value_rtsp_connect$1 >= 0))
      return -1;

  }

  struct AVCodecContext *cc = netcam->rtsp->codec_context;
  struct AVFormatContext *fc = netcam->rtsp->format_context;
  struct netcam_image_buff *buffer = netcam->receiving;
  buffer->used = (unsigned long int)0;
  struct AVFrame *frame;
  frame=av_frame_alloc();
  struct AVPacket packet;
  av_init_packet(&packet);
  packet.data = (unsigned char *)(void *)0;
  packet.size = 0;
  signed int size_decoded = 0;
  signed int return_value_av_read_frame$2;
  while(size_decoded == 0)
  {
    return_value_av_read_frame$2=av_read_frame(fc, &packet);
    if(!(return_value_av_read_frame$2 >= 0))
      break;

    if(packet.stream_index == netcam->rtsp->video_stream_index)
      size_decoded=decode_packet(&packet, buffer, frame, cc);

  }
  if(size_decoded == 0)
  {
    motion_log(3, (unsigned int)4, 1, "%s: invalid frame!", (const void *)"netcam_read_rtsp_image");
    return -1;
  }

  else
  {
    static signed int usual_size_decoded = 0;
    if(!(size_decoded == usual_size_decoded))
    {
      motion_log(4, (unsigned int)4, 1, "%s: unusual frame size of %d!", (const void *)"netcam_read_rtsp_image", size_decoded);
      usual_size_decoded = size_decoded;
    }

    av_free_packet(&packet);
    av_frame_free(&frame);
    struct timeval curtime;
    signed int return_value_gettimeofday$3;
    return_value_gettimeofday$3=gettimeofday(&curtime, (struct timezone *)(void *)0);
    if(!(return_value_gettimeofday$3 >= 0))
      motion_log(4, (unsigned int)4, 1, "%s: gettimeofday", (const void *)"netcam_read_rtsp_image");

    netcam->receiving->image_time = curtime;
    if(!(netcam->last_image.tv_sec == 0l))
    {
      netcam->av_frame_time = (float)((9.0 * (double)netcam->av_frame_time + 1000000.0 * (double)(curtime.tv_sec - netcam->last_image.tv_sec) + (double)(curtime.tv_usec - netcam->last_image.tv_usec)) / 10.0);
      motion_log(7, (unsigned int)4, 0, "%s: Calculated frame time %f", (const void *)"netcam_read_rtsp_image", netcam->av_frame_time);
    }

    netcam->last_image = curtime;
    struct netcam_image_buff *xchg;
    pthread_mutex_lock(&netcam->mutex);
    xchg = netcam->latest;
    netcam->latest = netcam->receiving;
    netcam->receiving = xchg;
    netcam->imgcnt = netcam->imgcnt + 1;
    pthread_cond_signal(&netcam->pic_ready);
    pthread_mutex_unlock(&netcam->mutex);
    return 0;
  }
}

// netcam_recv
// file netcam.c line 2499
signed long int netcam_recv(struct netcam_context *netcam, void *buffptr, unsigned long int buffsize)
{
  signed long int retval;
  struct anonymous$45 fd_r;
  struct timeval selecttime;
  if(!(netcam->sock >= 0))
    return (signed long int)-1;

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fd_r)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fd_r)->fds_bits[(signed long int)(netcam->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fd_r)->fds_bits[(signed long int)(netcam->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << netcam->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    selecttime = netcam->timeout;
    signed int return_value_select$1;
    return_value_select$1=select(1024, &fd_r, (struct anonymous$45 *)(void *)0, (struct anonymous$45 *)(void *)0, &selecttime);
    retval = (signed long int)return_value_select$1;
    if(retval == 0l)
      return (signed long int)-1;

    else
    {
      signed long int return_value_recv$2;
      return_value_recv$2=recv(netcam->sock, buffptr, buffsize, 0);
      return return_value_recv$2;
    }
  }
}

// netcam_setup_file
// file netcam.c line 1876
static signed int netcam_setup_file(struct netcam_context *netcam, struct url_t *url)
{
  netcam->file=file_new_context();
  if(netcam->file == ((struct file_context *)NULL))
    return -1;

  else
  {
    netcam->file->path = url->path;
    url->path = (char *)(void *)0;
    motion_log(6, (unsigned int)4, 0, "%s: netcam->file->path %s", (const void *)"netcam_setup_file", netcam->file->path);
    netcam_url_free(url);
    netcam->get_image = netcam_read_file_jpeg;
    return 0;
  }
}

// netcam_setup_ftp
// file netcam.c line 2361
static signed int netcam_setup_ftp(struct netcam_context *netcam, struct url_t *url)
{
  struct context *cnt = netcam->cnt;
  const char *ptr;
  netcam->ftp=ftp_new_context();
  if(netcam->ftp == ((struct ftp_context *)NULL))
    return -1;

  else
  {
    netcam->ftp->path = url->path;
    url->path = (char *)(void *)0;
    if(!(cnt->conf.netcam_userpass == ((const char *)NULL)))
      ptr = cnt->conf.netcam_userpass;

    else
      ptr = url->userpass;
    if(!(ptr == ((const char *)NULL)))
    {
      char *cptr;
      cptr=strchr(ptr, 58);
      if(cptr == ((char *)NULL))
        netcam->ftp->user=mystrdup(ptr);

      else
      {
        void *return_value_mymalloc$1;
        return_value_mymalloc$1=mymalloc((unsigned long int)(cptr - ptr));
        netcam->ftp->user = (char *)return_value_mymalloc$1;
        memcpy((void *)netcam->ftp->user, (const void *)ptr, (unsigned long int)(cptr - ptr));
        netcam->ftp->passwd=mystrdup(cptr + (signed long int)1);
      }
    }

    netcam_url_free(url);
    signed int return_value_ftp_connect$2;
    return_value_ftp_connect$2=ftp_connect(netcam);
    if(!(return_value_ftp_connect$2 >= 0))
    {
      ftp_free_context(netcam->ftp);
      return -1;
    }

    else
    {
      signed int return_value_ftp_send_type$3;
      return_value_ftp_send_type$3=ftp_send_type(netcam->ftp, (const char)73);
      if(!(return_value_ftp_send_type$3 >= 0))
      {
        motion_log(3, (unsigned int)4, 0, "%s: Error sending TYPE I to ftp server", (const void *)"netcam_setup_ftp");
        return -1;
      }

      else
      {
        netcam->get_image = netcam_read_ftp_jpeg;
        return 0;
      }
    }
  }
}

// netcam_setup_html
// file netcam.c line 2285
static signed int netcam_setup_html(struct netcam_context *netcam, struct url_t *url)
{
  signed int return_value_netcam_http_build_url$1;
  return_value_netcam_http_build_url$1=netcam_http_build_url(netcam, url);
  if(!(return_value_netcam_http_build_url$1 >= 0))
    return -1;

  else
  {
    signed int return_value_netcam_http_request$2;
    return_value_netcam_http_request$2=netcam_http_request(netcam);
    if(!(return_value_netcam_http_request$2 >= 0))
      return -1;

    else
    {
      if((signed int)netcam->caps.streaming == 1)
      {
        signed int return_value_netcam_read_next_header$3;
        return_value_netcam_read_next_header$3=netcam_read_next_header(netcam);
        if(!(return_value_netcam_read_next_header$3 >= 0))
        {
          motion_log(3, (unsigned int)4, 0, "%s: Failed to read first stream header - giving up for now", (const void *)"netcam_setup_html");
          return -1;
        }

      }

      motion_log(5, (unsigned int)4, 0, "%s: connected, going on to read image.", (const void *)"netcam_setup_html");
      netcam->get_image = netcam_read_html_jpeg;
      return 0;
    }
  }
}

// netcam_setup_mjpg
// file netcam.c line 2333
static signed int netcam_setup_mjpg(struct netcam_context *netcam, struct url_t *url)
{
  signed int return_value_netcam_http_build_url$1;
  return_value_netcam_http_build_url$1=netcam_http_build_url(netcam, url);
  if(!(return_value_netcam_http_build_url$1 == 0))
    return -1;

  else
  {
    signed int return_value_netcam_http_request$2;
    return_value_netcam_http_request$2=netcam_http_request(netcam);
    if(!(return_value_netcam_http_request$2 >= 0))
      return -1;

    else
    {
      netcam->caps.streaming = (unsigned char)2;
      motion_log(5, (unsigned int)4, 0, "%s: connected, going on to read and decode MJPG chunks.", (const void *)"netcam_setup_mjpg");
      netcam->get_image = netcam_read_mjpg_jpeg;
      return 0;
    }
  }
}

// netcam_setup_rtsp
// file netcam.c line 2417
static signed int netcam_setup_rtsp(struct netcam_context *netcam, struct url_t *url)
{
  struct context *cnt = netcam->cnt;
  const char *ptr;
  netcam->caps.streaming = (unsigned char)3;
  netcam->rtsp=rtsp_new_context();
  if(netcam->rtsp == ((struct rtsp_context *)NULL))
  {
    motion_log(3, (unsigned int)4, 0, "%s: unable to create rtsp context", (const void *)"netcam_setup_rtsp");
    return -1;
  }

  else
  {
    if(netcam->connect_port >= 65537)
      netcam->connect_port = 65536;

    else
      if(!(netcam->connect_port >= 0))
        netcam->connect_port = 0;

    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(url->service);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(netcam->connect_host);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(url->path);
    void *return_value_mymalloc$4;
    return_value_mymalloc$4=mymalloc(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)5 + return_value_strlen$3 + (unsigned long int)5);
    ptr = (const char *)return_value_mymalloc$4;
    sprintf((char *)ptr, "%s://%s:%d%s", url->service, netcam->connect_host, netcam->connect_port, url->path);
    netcam->rtsp->path = (char *)ptr;
    if(!(cnt->conf.netcam_userpass == ((const char *)NULL)))
      ptr = cnt->conf.netcam_userpass;

    else
      ptr = url->userpass;
    if(!(ptr == ((const char *)NULL)))
    {
      char *cptr;
      cptr=strchr(ptr, 58);
      if(cptr == ((char *)NULL))
        netcam->rtsp->user=mystrdup(ptr);

      else
      {
        void *return_value_mymalloc$5;
        return_value_mymalloc$5=mymalloc((unsigned long int)(cptr - ptr));
        netcam->rtsp->user = (char *)return_value_mymalloc$5;
        memcpy((void *)netcam->rtsp->user, (const void *)ptr, (unsigned long int)(cptr - ptr));
        netcam->rtsp->pass=mystrdup(cptr + (signed long int)1);
      }
    }

    netcam_url_free(url);
    rtsp_connect(netcam);
    netcam->get_image = netcam_read_rtsp_image;
    return 0;
  }
}

// netcam_shutdown_rtsp
// file netcam_rtsp.c line 324
void netcam_shutdown_rtsp(struct netcam_context *netcam)
{
  if(!(netcam->rtsp == ((struct rtsp_context *)NULL)))
  {
    rtsp_free_context(netcam->rtsp);
    netcam->rtsp = (struct rtsp_context *)(void *)0;
  }

}

// netcam_skip_input_data
// file netcam_jpeg.c line 97
static void netcam_skip_input_data(struct jpeg_decompress_struct *cinfo, signed long int num_bytes)
{
  struct anonymous$0 *src = (struct anonymous$0 *)cinfo->src;
  if(num_bytes >= 1l)
  {
    while(!((signed long int)src->pub.bytes_in_buffer >= num_bytes))
    {
      num_bytes = num_bytes - (signed long int)src->pub.bytes_in_buffer;
      netcam_fill_input_buffer(cinfo);
    }
    src->pub.next_input_byte = src->pub.next_input_byte + (signed long int)(unsigned long int)num_bytes;
    src->pub.bytes_in_buffer = src->pub.bytes_in_buffer - (unsigned long int)num_bytes;
  }

}

// netcam_start
// file netcam.h line 296
signed int netcam_start(struct context *cnt)
{
  struct netcam_context *netcam;
  union pthread_attr_t handler_attribute;
  signed int retval;
  struct url_t url;
  memset((void *)&url, 0, sizeof(struct url_t) /*40ul*/ );
  motion_log(1, (unsigned int)4, 0, "%s: Network Camera thread starting... for url (%s)", (const void *)"netcam_start", cnt->conf.netcam_url);
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct netcam_context) /*800ul*/ );
  cnt->netcam = (struct netcam_context *)return_value_mymalloc$1;
  memset((void *)cnt->netcam, 0, sizeof(struct netcam_context) /*800ul*/ );
  netcam = cnt->netcam;
  netcam->cnt = cnt;
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc(sizeof(struct netcam_image_buff) /*48ul*/ );
  netcam->receiving = (struct netcam_image_buff *)return_value_mymalloc$2;
  memset((void *)netcam->receiving, 0, sizeof(struct netcam_image_buff) /*48ul*/ );
  void *return_value_mymalloc$3;
  return_value_mymalloc$3=mymalloc((unsigned long int)4096);
  netcam->receiving->ptr = (char *)return_value_mymalloc$3;
  void *return_value_mymalloc$4;
  return_value_mymalloc$4=mymalloc(sizeof(struct netcam_image_buff) /*48ul*/ );
  netcam->jpegbuf = (struct netcam_image_buff *)return_value_mymalloc$4;
  memset((void *)netcam->jpegbuf, 0, sizeof(struct netcam_image_buff) /*48ul*/ );
  void *return_value_mymalloc$5;
  return_value_mymalloc$5=mymalloc((unsigned long int)4096);
  netcam->jpegbuf->ptr = (char *)return_value_mymalloc$5;
  void *return_value_mymalloc$6;
  return_value_mymalloc$6=mymalloc(sizeof(struct netcam_image_buff) /*48ul*/ );
  netcam->latest = (struct netcam_image_buff *)return_value_mymalloc$6;
  memset((void *)netcam->latest, 0, sizeof(struct netcam_image_buff) /*48ul*/ );
  void *return_value_mymalloc$7;
  return_value_mymalloc$7=mymalloc((unsigned long int)4096);
  netcam->latest->ptr = (char *)return_value_mymalloc$7;
  netcam->timeout.tv_sec = (signed long int)5;
  pthread_mutex_init(&netcam->mutex, (const union anonymous$31 *)(void *)0);
  pthread_cond_init(&netcam->cap_cond, (const union anonymous$31 *)(void *)0);
  pthread_cond_init(&netcam->pic_ready, (const union anonymous$31 *)(void *)0);
  pthread_cond_init(&netcam->exiting, (const union anonymous$31 *)(void *)0);
  netcam->av_frame_time = (float)(1000000.0 / (double)cnt->conf.frame_limit);
  if(!(cnt->conf.netcam_proxy == ((const char *)NULL)))
  {
    netcam_url_parse(&url, cnt->conf.netcam_proxy);
    if(url.host == ((char *)NULL))
    {
      motion_log(2, (unsigned int)4, 0, "%s: Invalid netcam_proxy (%s)", (const void *)"netcam_start", cnt->conf.netcam_proxy);
      netcam_url_free(&url);
      return -1;
    }

    if(!(url.userpass == ((char *)NULL)))
    {
      motion_log(2, (unsigned int)4, 0, "%s: Username/password not allowed on a proxy URL", (const void *)"netcam_start");
      netcam_url_free(&url);
      return -1;
    }

    netcam->connect_host = url.host;
    url.host = (char *)(void *)0;
    netcam->connect_port = url.port;
    netcam_url_free(&url);
  }

  netcam_url_parse(&url, cnt->conf.netcam_url);
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$11;
  if(url.host == ((char *)NULL))
  {
    motion_log(2, (unsigned int)4, 0, "%s: Invalid netcam_url (%s)", (const void *)"netcam_start", cnt->conf.netcam_url);
    netcam_url_free(&url);
    return -1;
  }

  else
  {
    if(cnt->conf.netcam_proxy == ((const char *)NULL))
    {
      netcam->connect_host = url.host;
      url.host = (char *)(void *)0;
      netcam->connect_port = url.port;
    }

    signed int return_value_strcmp$10;
    return_value_strcmp$10=strcmp(cnt->conf.netcam_keepalive, "force");
    if(return_value_strcmp$10 == 0)
    {
      netcam->connect_http_10 = 1;
      netcam->connect_http_11 = 0;
      netcam->connect_keepalive = 1;
    }

    else
    {
      return_value_strcmp$9=strcmp(cnt->conf.netcam_keepalive, "off");
      if(return_value_strcmp$9 == 0)
      {
        netcam->connect_http_10 = 1;
        netcam->connect_http_11 = 0;
        netcam->connect_keepalive = 0;
      }

      else
      {
        return_value_strcmp$8=strcmp(cnt->conf.netcam_keepalive, "on");
        if(return_value_strcmp$8 == 0)
        {
          netcam->connect_http_10 = 0;
          netcam->connect_http_11 = 1;
          netcam->connect_keepalive = 1;
        }

      }
    }
    motion_log(6, (unsigned int)4, 0, "%s: Netcam_http parameter '%s' converts to flags: HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.", (const void *)"netcam_start", cnt->conf.netcam_keepalive, netcam->connect_http_10 != 0 ? "1" : "0", netcam->connect_http_11 != 0 ? "1" : "0", netcam->connect_keepalive != 0 ? "ON" : "OFF");
    netcam->sock = -1;
    _Bool tmp_if_expr$20;
    if(!(url.service == ((char *)NULL)))
    {
      return_value_strcmp$19=strcmp(url.service, "http");
      tmp_if_expr$20 = !(return_value_strcmp$19 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$20 = (_Bool)0;
    if(tmp_if_expr$20)
    {
      motion_log(6, (unsigned int)4, 0, "%s: now calling netcam_setup_html()", (const void *)"netcam_start");
      retval=netcam_setup_html(netcam, &url);
    }

    else
    {
      _Bool tmp_if_expr$18;
      if(!(url.service == ((char *)NULL)))
      {
        return_value_strcmp$17=strcmp(url.service, "ftp");
        tmp_if_expr$18 = !(return_value_strcmp$17 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$18 = (_Bool)0;
      if(tmp_if_expr$18)
      {
        motion_log(6, (unsigned int)4, 0, "%s: now calling netcam_setup_ftp", (const void *)"netcam_start");
        retval=netcam_setup_ftp(netcam, &url);
      }

      else
      {
        _Bool tmp_if_expr$16;
        if(!(url.service == ((char *)NULL)))
        {
          return_value_strcmp$15=strcmp(url.service, "file");
          tmp_if_expr$16 = !(return_value_strcmp$15 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$16 = (_Bool)0;
        if(tmp_if_expr$16)
        {
          motion_log(6, (unsigned int)4, 0, "%s: now calling netcam_setup_file()", (const void *)"netcam_start");
          retval=netcam_setup_file(netcam, &url);
        }

        else
        {
          _Bool tmp_if_expr$14;
          if(!(url.service == ((char *)NULL)))
          {
            return_value_strcmp$13=strcmp(url.service, "mjpg");
            tmp_if_expr$14 = !(return_value_strcmp$13 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$14 = (_Bool)0;
          if(tmp_if_expr$14)
          {
            motion_log(6, (unsigned int)4, 0, "%s: now calling netcam_setup_mjpg()", (const void *)"netcam_start");
            strcpy(url.service, "http");
            retval=netcam_setup_mjpg(netcam, &url);
          }

          else
          {
            _Bool tmp_if_expr$12;
            if(!(url.service == ((char *)NULL)))
            {
              return_value_strcmp$11=strcmp(url.service, "rtsp");
              tmp_if_expr$12 = !(return_value_strcmp$11 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$12 = (_Bool)0;
            if(tmp_if_expr$12)
            {
              motion_log(6, (unsigned int)4, 0, "%s: now calling netcam_setup_rtsp()", (const void *)"netcam_start");
              retval=netcam_setup_rtsp(netcam, &url);
            }

            else
            {
              motion_log(2, (unsigned int)4, 0, "%s: Invalid netcam service '%s' - must be http, ftp, mjpg or file.", (const void *)"netcam_start", url.service);
              netcam_url_free(&url);
              return -1;
            }
          }
        }
      }
    }
    if(!(retval >= 0))
      return -1;

    else
    {
      retval=netcam->get_image(netcam);
      if(!(retval == 0))
      {
        motion_log(2, (unsigned int)4, 0, "%s: Failed trying to read first image - retval:%d", (const void *)"netcam_start", retval);
        return -1;
      }

      else
      {
        if(!((signed int)netcam->caps.streaming == 3))
        {
          signed int return_value__setjmp$21;
          return_value__setjmp$21=_setjmp(netcam->setjmp_buffer);
          if(!(return_value__setjmp$21 == 0))
          {
            motion_log(2, (unsigned int)4, 0, "%s: libjpeg decompression failure on first frame - giving up!", (const void *)"netcam_start");
            return -1;
          }

          netcam->netcam_tolerant_check = cnt->conf.netcam_tolerant_check;
          netcam->JFIF_marker = 0;
          netcam_get_dimensions(netcam);
          if(!(netcam->width % 8u == 0u))
          {
            motion_log(2, (unsigned int)4, 0, "%s: netcam image width (%d) is not modulo 8", (const void *)"netcam_start", netcam->width);
            return -3;
          }

          if(!(netcam->height % 8u == 0u))
          {
            motion_log(2, (unsigned int)4, 0, "%s: netcam image height (%d) is not modulo 8", (const void *)"netcam_start", netcam->height);
            return -3;
          }

        }

        else
        {
          netcam->width = (unsigned int)netcam->rtsp->codec_context->width;
          netcam->height = (unsigned int)netcam->rtsp->codec_context->height;
        }
        cnt->imgs.width = (signed int)netcam->width;
        cnt->imgs.height = (signed int)netcam->height;
        cnt->imgs.size = (signed int)((netcam->width * netcam->height * (unsigned int)3) / (unsigned int)2);
        cnt->imgs.motionsize = (signed int)(netcam->width * netcam->height);
        cnt->imgs.type = 15;
        pthread_attr_init(&handler_attribute);
        pthread_attr_setdetachstate(&handler_attribute, 1);
        pthread_mutex_lock(&global_lock);
        threads_running = threads_running + 1;
        netcam->threadnr = threads_running;
        pthread_mutex_unlock(&global_lock);
        retval=pthread_create(&netcam->thread_id, &handler_attribute, netcam_handler_loop, (void *)netcam);
        if(!(retval >= 0))
        {
          motion_log(1, (unsigned int)4, 1, "%s: Starting camera handler thread [%d]", (const void *)"netcam_start", netcam->threadnr);
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// netcam_term_source
// file netcam_jpeg.c line 111
static void netcam_term_source(struct jpeg_decompress_struct *cinfo)
{
  ;
}

// netcam_url_free
// file netcam.c line 235
static void netcam_url_free(struct url_t *parse_url)
{
  if(!(parse_url->service == ((char *)NULL)))
  {
    free((void *)parse_url->service);
    parse_url->service = (char *)(void *)0;
  }

  if(!(parse_url->userpass == ((char *)NULL)))
  {
    free((void *)parse_url->userpass);
    parse_url->userpass = (char *)(void *)0;
  }

  if(!(parse_url->host == ((char *)NULL)))
  {
    free((void *)parse_url->host);
    parse_url->host = (char *)(void *)0;
  }

  if(!(parse_url->path == ((char *)NULL)))
  {
    free((void *)parse_url->path);
    parse_url->path = (char *)(void *)0;
  }

}

// netcam_url_match
// file netcam.c line 118
static char * netcam_url_match(struct anonymous$46 m, const char *input)
{
  char *match = (char *)(void *)0;
  signed int len;
  if(!(m.rm_so == -1))
  {
    len = m.rm_eo - m.rm_so;
    void *return_value_mymalloc$1;
    return_value_mymalloc$1=mymalloc((unsigned long int)(len + 1));
    match = (char *)return_value_mymalloc$1;
    if(!(match == ((char *)NULL)))
    {
      strncpy(match, input + (signed long int)m.rm_so, (unsigned long int)len);
      match[(signed long int)len] = (char)0;
    }

  }

  return match;
}

// netcam_url_parse
// file netcam.c line 148
static void netcam_url_parse(struct url_t *parse_url, const char *text_url)
{
  char *s;
  signed int i;
  const char *re = "(http|ftp|mjpg|rtsp)://(((.*):(.*))@)?([^/:]|[-.a-z0-9]+)(:([0-9]+))?($|(/[^:]*))";
  struct re_pattern_buffer pattbuf;
  struct anonymous$46 matches[10l];
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(text_url, "file", (unsigned long int)4);
  if(return_value_strncmp$1 == 0)
    re = "(file)://(((.*):(.*))@)?([^/:]|[-.a-z0-9]*)(:([0-9]*))?($|(/[^:][/-_.a-z0-9]+))";

  motion_log(7, (unsigned int)4, 0, "%s: Entry netcam_url_parse data %s", (const void *)"netcam_url_parse", text_url);
  memset((void *)parse_url, 0, sizeof(struct url_t) /*40ul*/ );
  signed int return_value_regcomp$3;
  return_value_regcomp$3=regcomp(&pattbuf, re, 1 | 1 << 1);
  if(return_value_regcomp$3 == 0)
  {
    signed int return_value_regexec$2;
    return_value_regexec$2=regexec(&pattbuf, text_url, (unsigned long int)10, matches, 0);
    if(!(return_value_regexec$2 == 1))
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
      {
        s=netcam_url_match(matches[(signed long int)i], text_url);
        if(!(s == ((char *)NULL)))
        {
          motion_log(7, (unsigned int)4, 0, "%s: Parse case %d data %s", (const void *)"netcam_url_parse", i, s);
          switch(i)
          {
            case 1:
            {
              parse_url->service = s;
              break;
            }
            case 3:
            {
              parse_url->userpass = s;
              break;
            }
            case 6:
            {
              parse_url->host = s;
              break;
            }
            case 8:
            {
              parse_url->port=atoi(s);
              free((void *)s);
              break;
            }
            case 9:
            {
              parse_url->path = s;
              break;
            }
            default:
              free((void *)s);
          }
        }

      }
    }

  }

  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  if(parse_url->port == 0)
  {
    if(!(parse_url->service == ((char *)NULL)))
    {
      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(parse_url->service, "http");
      if(return_value_strcmp$6 == 0)
        parse_url->port = 80;

      else
      {
        return_value_strcmp$5=strcmp(parse_url->service, "ftp");
        if(return_value_strcmp$5 == 0)
          parse_url->port = 21;

        else
        {
          return_value_strcmp$4=strcmp(parse_url->service, "rtsp");
          if(return_value_strcmp$4 == 0)
          {
            if(parse_url->port == 0)
              parse_url->port = 554;

          }

        }
      }
    }

  }

  regfree(&pattbuf);
}

// on_area_command
// file event.c line 218
static void on_area_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->conf.on_area_detected == ((char *)NULL)))
    exec_command(cnt, cnt->conf.on_area_detected, (char *)(void *)0, 0);

}

// on_event_end_command
// file event.c line 236
static void on_event_end_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->conf.on_event_end == ((char *)NULL)))
    exec_command(cnt, cnt->conf.on_event_end, (char *)(void *)0, 0);

}

// on_event_start_command
// file event.c line 227
static void on_event_start_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->conf.on_event_start == ((char *)NULL)))
    exec_command(cnt, cnt->conf.on_event_start, (char *)(void *)0, 0);

}

// on_motion_detected_command
// file event.c line 103
static void on_motion_detected_command(struct context *cnt, signed int type, unsigned char *dummy1, char *dummy2, void *dummy3, struct tm *tm)
{
  if(!(cnt->conf.on_motion_detected == ((char *)NULL)))
    exec_command(cnt, cnt->conf.on_motion_detected, (char *)(void *)0, 0);

}

// on_movie_end_command
// file event.c line 402
static void on_movie_end_command(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm)
{
  signed int filetype = (signed int)(unsigned long int)arg;
  if(!((56 & filetype) == 0))
  {
    if(!(cnt->conf.on_movie_end == ((char *)NULL)))
      exec_command(cnt, cnt->conf.on_movie_end, filename, filetype);

  }

}

// on_picture_save_command
// file event.c line 90
static void on_picture_save_command(struct context *cnt, signed int type, unsigned char *dummy, char *filename, void *arg, struct tm *tm)
{
  signed int filetype = (signed int)(unsigned long int)arg;
  if(!((7 & filetype) == 0))
  {
    if(!(cnt->conf.on_picture_save == ((char *)NULL)))
      exec_command(cnt, cnt->conf.on_picture_save, filename, filetype);

  }

  if(!((56 & filetype) == 0))
  {
    if(!(cnt->conf.on_movie_start == ((char *)NULL)))
      exec_command(cnt, cnt->conf.on_movie_start, filename, filetype);

  }

}

// open_codec_context
// file netcam_rtsp.c line 83
static signed int open_codec_context(signed int *stream_idx, struct AVFormatContext *fmt_ctx, enum AVMediaType type)
{
  signed int ret;
  struct AVStream *st;
  struct AVCodecContext *dec_ctx = (struct AVCodecContext *)(void *)0;
  struct AVCodec *dec = (struct AVCodec *)(void *)0;
  ret=av_find_best_stream(fmt_ctx, type, -1, -1, (struct AVCodec **)(void *)0, 0);
  if(!(ret >= 0))
  {
    const char *return_value_av_get_media_type_string$1;
    return_value_av_get_media_type_string$1=av_get_media_type_string(type);
    motion_log(3, (unsigned int)4, 0, "%s: Could not find stream %s in input!", (const void *)"open_codec_context", return_value_av_get_media_type_string$1);
    return ret;
  }

  else
  {
    *stream_idx = ret;
    st = fmt_ctx->streams[(signed long int)*stream_idx];
    dec_ctx = st->codec;
    dec=avcodec_find_decoder(dec_ctx->codec_id);
    if(dec == ((struct AVCodec *)NULL))
    {
      const char *return_value_av_get_media_type_string$2;
      return_value_av_get_media_type_string$2=av_get_media_type_string(type);
      motion_log(3, (unsigned int)4, 0, "%s: Failed to find %s codec!", (const void *)"open_codec_context", return_value_av_get_media_type_string$2);
      return ret;
    }

    ret=avcodec_open2(dec_ctx, dec, (struct AVDictionary **)(void *)0);
    if(!(ret >= 0))
    {
      const char *return_value_av_get_media_type_string$3;
      return_value_av_get_media_type_string$3=av_get_media_type_string(type);
      motion_log(3, (unsigned int)4, 0, "%s: Failed to open %s codec!", (const void *)"open_codec_context", return_value_av_get_media_type_string$3);
      return ret;
    }

  }
  return 0;
}

// overlay_fixed_mask
// file picture.h line 16
void overlay_fixed_mask(struct context *cnt, unsigned char *out)
{
  signed int i;
  signed int x;
  signed int v;
  signed int width;
  signed int height;
  signed int line;
  struct images *imgs = &cnt->imgs;
  unsigned char *mask = imgs->mask;
  unsigned char *out_y;
  unsigned char *out_u;
  unsigned char *out_v;
  i = imgs->motionsize;
  v = i + imgs->motionsize / 4;
  width = imgs->width;
  height = imgs->height;
  out_v = out + (signed long int)v;
  out_u = out + (signed long int)i;
  i = 0;
  for( ; !(i >= height); i = i + 2)
  {
    line = i * width;
    x = 0;
    for( ; !(x >= width); x = x + 2)
    {
      _Bool tmp_if_expr$1;
      if((signed int)mask[(signed long int)(line + x)] == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)mask[(signed long int)(line + x + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)mask[(signed long int)(line + width + x)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)mask[(signed long int)(line + width + x + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        *out_v = (unsigned char)0;
        *out_u = (unsigned char)0;
      }

      out_v = out_v + 1l;
      out_u = out_u + 1l;
    }
  }
  out_y = out;
  i = 0;
  for( ; !(i >= imgs->motionsize); i = i + 1)
  {
    if((signed int)mask[(signed long int)i] == 0)
      *out_y = (unsigned char)0;

    out_y = out_y + 1l;
  }
}

// overlay_largest_label
// file picture.h line 18
void overlay_largest_label(struct context *cnt, unsigned char *out)
{
  signed int i;
  signed int x;
  signed int v;
  signed int width;
  signed int height;
  signed int line;
  struct images *imgs = &cnt->imgs;
  signed int *labels = imgs->labels;
  unsigned char *out_y;
  unsigned char *out_u;
  unsigned char *out_v;
  i = imgs->motionsize;
  v = i + imgs->motionsize / 4;
  width = imgs->width;
  height = imgs->height;
  out_u = out + (signed long int)i;
  out_v = out + (signed long int)v;
  i = 0;
  for( ; !(i >= height); i = i + 2)
  {
    line = i * width;
    x = 0;
    for( ; !(x >= width); x = x + 2)
    {
      _Bool tmp_if_expr$1;
      if(!((32768 & labels[(signed long int)(line + x)]) == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (labels[(signed long int)(line + x + 1)] & 32768) != 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (labels[(signed long int)(line + width + x)] & 32768) != 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (labels[(signed long int)(line + width + x + 1)] & 32768) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        *out_u = (unsigned char)255;
        *out_v = (unsigned char)128;
      }

      out_u = out_u + 1l;
      out_v = out_v + 1l;
    }
  }
  out_y = out;
  i = 0;
  for( ; !(i >= imgs->motionsize); i = i + 1)
  {
    signed int *tmp_post$4 = labels;
    labels = labels + 1l;
    if(!((32768 & *tmp_post$4) == 0))
      *out_y = (unsigned char)0;

    out_y = out_y + 1l;
  }
}

// overlay_smartmask
// file picture.h line 15
void overlay_smartmask(struct context *cnt, unsigned char *out)
{
  signed int i;
  signed int x;
  signed int v;
  signed int width;
  signed int height;
  signed int line;
  struct images *imgs = &cnt->imgs;
  unsigned char *smartmask = imgs->smartmask_final;
  unsigned char *out_y;
  unsigned char *out_u;
  unsigned char *out_v;
  i = imgs->motionsize;
  v = i + imgs->motionsize / 4;
  width = imgs->width;
  height = imgs->height;
  out_v = out + (signed long int)v;
  out_u = out + (signed long int)i;
  i = 0;
  for( ; !(i >= height); i = i + 2)
  {
    line = i * width;
    x = 0;
    for( ; !(x >= width); x = x + 2)
    {
      _Bool tmp_if_expr$1;
      if((signed int)smartmask[(signed long int)(line + x)] == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)smartmask[(signed long int)(line + x + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)smartmask[(signed long int)(line + width + x)] == 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)smartmask[(signed long int)(line + width + x + 1)] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        *out_v = (unsigned char)255;
        *out_u = (unsigned char)128;
      }

      out_v = out_v + 1l;
      out_u = out_u + 1l;
    }
  }
  out_y = out;
  i = 0;
  for( ; !(i >= imgs->motionsize); i = i + 1)
  {
    if((signed int)smartmask[(signed long int)i] == 0)
      *out_y = (unsigned char)0;

    out_y = out_y + 1l;
  }
}

// preview_save
// file picture.h line 23
void preview_save(struct context *cnt)
{
  signed int use_imagepath;
  signed int basename_len;
  const char *imagepath;
  char previewname[4096l];
  char filename[4096l];
  struct image_data *saved_current_image;
  _Bool tmp_if_expr$6;
  if(!(cnt->imgs.preview_image.diffs == 0))
  {
    saved_current_image = cnt->current_image;
    cnt->current_image = &cnt->imgs.preview_image;
    use_imagepath=strcmp(cnt->conf.imagepath, "preview");
    _Bool tmp_if_expr$7;
    if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!(cnt->conf.useextpipe == 0))
        tmp_if_expr$6 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(use_imagepath == 0 && tmp_if_expr$7)
    {
      _Bool tmp_if_expr$3;
      if(!(cnt->conf.useextpipe == 0))
        tmp_if_expr$3 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(cnt->extpipefilename);
        basename_len = (signed int)(return_value_strlen$1 + (unsigned long int)1);
        strncpy(previewname, cnt->extpipefilename, (unsigned long int)basename_len);
        previewname[(signed long int)(basename_len - 1)] = (char)46;
      }

      else
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(cnt->newfilename);
        basename_len = (signed int)(return_value_strlen$2 - (unsigned long int)3);
        strncpy(previewname, cnt->newfilename, (unsigned long int)basename_len);
      }
      previewname[(signed long int)basename_len] = (char)0;
      const char *return_value_imageext$4;
      return_value_imageext$4=imageext(cnt);
      strcat(previewname, return_value_imageext$4);
      put_picture(cnt, previewname, cnt->imgs.preview_image.image, 1);
    }

    else
    {
      motion_log(5, (unsigned int)9, 0, "%s: different filename or picture only!", (const void *)"preview_save");
      if(!(cnt->conf.imagepath == ((const char *)NULL)))
        imagepath = cnt->conf.imagepath;

      else
        imagepath = (char *)"%v-%Y%m%d%H%M%S-%q";
      mystrftime(cnt, filename, sizeof(char [4096l]) /*4096ul*/ , imagepath, &cnt->imgs.preview_image.timestamp_tm, (const char *)(void *)0, 0);
      const char *return_value_imageext$5;
      return_value_imageext$5=imageext(cnt);
      snprintf(previewname, (unsigned long int)4096, "%s/%s.%s", cnt->conf.filepath, (const void *)filename, return_value_imageext$5);
      put_picture(cnt, previewname, cnt->imgs.preview_image.image, 1);
    }
    cnt->current_image = saved_current_image;
  }

}

// print_bool
// file conf.c line 2196
static const char * print_bool(struct context **cnt, char **str, signed int parm, unsigned int threadnr)
{
  signed int val = config_params[(signed long int)parm].conf_value;
  if(!(threadnr == 0u))
  {
    if(!(*((signed int *)((char *)cnt[(signed long int)threadnr] + (signed long int)val)) == *((signed int *)((char *)*cnt + (signed long int)val))))
      goto __CPROVER_DUMP_L1;

    return (const char *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(*((signed int *)((char *)cnt[(signed long int)threadnr] + (signed long int)val)) == 0))
      return "on";

    else
      return "off";
  }
}

// print_int
// file conf.c line 2238
static const char * print_int(struct context **cnt, char **str, signed int parm, unsigned int threadnr)
{
  signed int val = config_params[(signed long int)parm].conf_value;
  if(!(threadnr == 0u))
  {
    if(!(*((signed int *)((char *)cnt[(signed long int)threadnr] + (signed long int)val)) == *((signed int *)((char *)*cnt + (signed long int)val))))
      goto __CPROVER_DUMP_L1;

    return (const char *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    static char retval[20l];
    sprintf(retval, "%d", *((signed int *)((char *)cnt[(signed long int)threadnr] + (signed long int)val)));
    return retval;
  }
}

// print_string
// file conf.c line 2221
static const char * print_string(struct context **cnt, char **str, signed int parm, unsigned int threadnr)
{
  signed int val = config_params[(signed long int)parm].conf_value;
  const char **cptr0;
  const char **cptr1;
  cptr0 = (const char **)((char *)cnt[(signed long int)0] + (signed long int)val);
  cptr1 = (const char **)((char *)cnt[(signed long int)threadnr] + (signed long int)val);
  signed int return_value_strcmp$1;
  if(!(threadnr == 0u))
  {
    if(!(*cptr0 == ((const char *)NULL)))
    {
      if(!(*cptr1 == ((const char *)NULL)))
      {
        return_value_strcmp$1=strcmp(*cptr0, *cptr1);
        if(return_value_strcmp$1 == 0)
          return (const char *)(void *)0;

      }

    }

  }

  return *cptr1;
}

// print_thread
// file conf.c line 2254
static const char * print_thread(struct context **cnt, char **str, signed int parm, unsigned int threadnr)
{
  char *retval;
  unsigned int i = (unsigned int)0;
  if(str == ((char **)NULL) || !(threadnr == 0u))
    return (const char *)(void *)0;

  else
  {
    void *return_value_mymalloc$1;
    return_value_mymalloc$1=mymalloc((unsigned long int)1);
    retval = (char *)return_value_mymalloc$1;
    retval[(signed long int)0] = (char)0;
    do
    {
      i = i + 1u;
      if(cnt[(signed long int)i] == ((struct context *)NULL))
        break;

      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(retval);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(cnt[(signed long int)i]->conf_filename);
      void *return_value_myrealloc$4;
      return_value_myrealloc$4=myrealloc((void *)retval, return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)10, "print_thread");
      retval = (char *)return_value_myrealloc$4;
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(retval);
      sprintf(retval + (signed long int)return_value_strlen$5, "thread %s\n", (const void *)cnt[(signed long int)i]->conf_filename);
    }
    while((_Bool)1);
    *str = retval;
    return (const char *)(void *)0;
  }
}

// process_filter_graph
// file ffmpeg.c line 1082
static signed int process_filter_graph(struct AVPicture *dst, const struct AVPicture *src, enum AVPixelFormat pixfmt, signed int width, signed int height)
{
  signed int res;
  if(filter_graph == ((struct AVFilterGraph *)NULL) || !(pixfmt == last_pixfmt) || !(height == last_height) || !(width == last_width))
  {
    res=init_filter_graph(pixfmt, width, height);
    if(res >= 0)
      goto __CPROVER_DUMP_L1;

    return res;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    memcpy((void *)filter_frame->data, (const void *)src->data, sizeof(unsigned char *[8l]) /*64ul*/ );
    memcpy((void *)filter_frame->linesize, (const void *)src->linesize, sizeof(signed int [8l]) /*32ul*/ );
    filter_frame->width = width;
    filter_frame->height = height;
    filter_frame->format = (signed int)pixfmt;
    res=av_buffersrc_add_frame(buffersrc_ctx, filter_frame);
    if(!(res >= 0))
      return res;

    else
    {
      res=av_buffersink_get_frame(buffersink_ctx, filter_frame);
      if(!(res >= 0))
        return res;

      else
      {
        av_picture_copy(dst, (const struct AVPicture *)filter_frame, pixfmt, width, height);
        av_frame_unref(filter_frame);
        return 0;
      }
    }
  }
}

// process_image_ring
// file motion.c line 517
static void process_image_ring(struct context *cnt, unsigned int max_images)
{
  struct image_data *saved_current_image = cnt->current_image;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  while((12u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 4u)
  {
    cnt->current_image = &cnt->imgs.image_ring[(signed long int)cnt->imgs.image_ring_out];
    if(!((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->shot >= cnt->conf.frame_limit))
    {
      if(cnt->log_level >= 7)
      {
        char process_image_ring$$1$$1$$1$$1$$tmp[32l];
        const char *t;
        if(!((2u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 0u))
          t = "Trigger";

        else
          if(!((1u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 0u))
            t = "Motion";

          else
            if(!((16u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 0u))
              t = "Precap";

            else
              if(!((32u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 0u))
                t = "Postcap";

              else
                t = "Other";
        mystrftime(cnt, process_image_ring$$1$$1$$1$$1$$tmp, sizeof(char [32l]) /*32ul*/ , "%H%M%S-%q", &(cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->timestamp_tm, (const char *)(void *)0, 0);
        draw_text((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->image, (unsigned int)10, (unsigned int)20, (unsigned int)cnt->imgs.width, process_image_ring$$1$$1$$1$$1$$tmp, (unsigned int)cnt->conf.text_double);
        draw_text((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->image, (unsigned int)10, (unsigned int)30, (unsigned int)cnt->imgs.width, t, (unsigned int)cnt->conf.text_double);
      }

      event(cnt, 9, (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->image, (char *)(void *)0, (void *)0, &(cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->timestamp_tm);
      _Bool tmp_if_expr$3;
      if((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->shot == 0)
      {
        if(!(cnt->ffmpeg_output == ((struct ffmpeg *)NULL)))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          if(!(cnt->conf.useextpipe == 0))
            tmp_if_expr$1 = cnt->extpipe != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        if(cnt->movie_last_shot >= 0)
        {
          if((*cnt_list)->log_level >= 7)
          {
            signed int frames = cnt->movie_fps - (cnt->movie_last_shot + 1);
            if(frames >= 1)
            {
              char tmp[15l];
              motion_log(7, (unsigned int)9, 0, "%s: Added %d fillerframes into movie", (const void *)"process_image_ring", frames);
              sprintf(tmp, "Fillerframes %d", frames);
              draw_text((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->image, (unsigned int)10, (unsigned int)40, (unsigned int)cnt->imgs.width, tmp, (unsigned int)cnt->conf.text_double);
            }

          }

          for( ; !(1 + cnt->movie_last_shot >= cnt->movie_fps); cnt->movie_last_shot = cnt->movie_last_shot + 1)
            event(cnt, 19, (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->image, (char *)(void *)0, (void *)0, &(cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->timestamp_tm);
        }

        cnt->movie_last_shot = 0;
      }

      else
        if(!((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->shot == 1 + cnt->movie_last_shot))
          cnt->movie_last_shot = -1;

      if(cnt->movie_last_shot >= 0)
        cnt->movie_last_shot = (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->shot;

    }

    (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags = (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags | (unsigned int)8;
    if(!((1u & (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->flags) == 0u))
    {
      if(!((4u & cnt->new_img) == 0u))
      {
        if(!(cnt->imgs.preview_image.diffs >= (cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->diffs))
          image_save_as_preview(cnt, &cnt->imgs.image_ring[(signed long int)cnt->imgs.image_ring_out]);

      }

      if(!((8u & cnt->new_img) == 0u))
      {
        if(!((cnt->imgs.image_ring + (signed long int)cnt->imgs.image_ring_out)->cent_dist >= cnt->imgs.preview_image.cent_dist))
          image_save_as_preview(cnt, &cnt->imgs.image_ring[(signed long int)cnt->imgs.image_ring_out]);

      }

    }

    cnt->imgs.image_ring_out = cnt->imgs.image_ring_out + 1;
    if(cnt->imgs.image_ring_out >= cnt->imgs.image_ring_size)
      cnt->imgs.image_ring_out = 0;

    if(!(max_images == 4294967295u))
    {
      max_images = max_images - 1u;
      if(max_images == 0u)
        break;

    }

    if(cnt->imgs.image_ring_out == cnt->imgs.image_ring_in)
      break;

  }
  cnt->current_image = saved_current_image;
}

// put_direntry
// file picture.c line 171
static void put_direntry(struct tiff_writing *into, const char *data, unsigned int length)
{
  if(!(length >= 5u))
  {
    memset((void *)into->buf, 0, (unsigned long int)4);
    memcpy((void *)into->buf, (const void *)data, (unsigned long int)length);
  }

  else
  {
    unsigned int offset = into->data_offset;
    for( ; !((3u & offset) == 0u); offset = offset + 1u)
      into->base[(signed long int)offset] = (unsigned char)0;
    put_uint32(into->buf, offset);
    memcpy((void *)(into->base + (signed long int)offset), (const void *)data, (unsigned long int)length);
    into->data_offset = offset + length;
  }
}

// put_fixed_mask
// file picture.h line 17
void put_fixed_mask(struct context *cnt, const char *file)
{
  struct _IO_FILE *picture;
  picture=myfopen(file, "w", (unsigned long int)(1024 * 1024));
  if(picture == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 13)
      motion_log(3, (unsigned int)9, 1, "%s: can't write mask file %s - check access rights to target directory", (const void *)"put_fixed_mask", file);

    else
      motion_log(3, (unsigned int)9, 1, "%s: can't write mask file %s", (const void *)"put_fixed_mask", file);
    goto __CPROVER_DUMP_L5;
  }

  memset((void *)cnt->imgs.out, 255, (unsigned long int)cnt->imgs.motionsize);
  fprintf(picture, "P5\n");
  fprintf(picture, "%d %d\n", cnt->conf.width, cnt->conf.height);
  fprintf(picture, "%d\n", 255);
  unsigned long int return_value_fwrite$2;
  return_value_fwrite$2=fwrite((const void *)cnt->imgs.out, (unsigned long int)cnt->conf.width, (unsigned long int)cnt->conf.height, picture);
  if(!((signed int)return_value_fwrite$2 == cnt->conf.height))
    motion_log(3, (unsigned int)9, 1, "%s: Failed writing default mask as pgm file", (const void *)"put_fixed_mask");

  else
  {
    myfclose(picture);
    motion_log(3, (unsigned int)9, 0, "%s: Creating empty mask %s\nPlease edit this file and re-run motion to enable mask feature", (const void *)"put_fixed_mask", cnt->conf.mask_file);
  }

__CPROVER_DUMP_L5:
  ;
}

// put_jpeg_exif
// file picture.c line 224
static void put_jpeg_exif(struct jpeg_compress_struct *cinfo, struct context *cnt, struct tm *timestamp, struct coord *box)
{
  char *description;
  char *datetime;
  char *subtime;
  char datetime_buf[22l];
  if(!(timestamp == ((struct tm *)NULL)))
  {
    snprintf(datetime_buf, (unsigned long int)21, "%04d:%02d:%02d %02d:%02d:%02d", timestamp->tm_year + 1900, timestamp->tm_mon + 1, timestamp->tm_mday, timestamp->tm_hour, timestamp->tm_min, timestamp->tm_sec);
    datetime = datetime_buf;
  }

  else
    datetime = (char *)(void *)0;
  subtime = (char *)(void *)0;
  if(!(cnt->conf.exif_text == ((const char *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)4096);
    description = (char *)return_value_malloc$1;
    mystrftime(cnt, description, (unsigned long int)(4096 - 1), cnt->conf.exif_text, timestamp, (const char *)(void *)0, 0);
  }

  else
    description = (char *)(void *)0;
  signed int ifd0_tagcount = 0;
  signed int ifd1_tagcount = 0;
  unsigned int datasize = (unsigned int)0;
  if(!(description == ((char *)NULL)))
  {
    ifd0_tagcount = ifd0_tagcount + 1;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(description);
    datasize = datasize + (unsigned int)((unsigned long int)5 + return_value_strlen$2);
  }

  if(!(datetime == ((char *)NULL)))
  {
    ifd0_tagcount = ifd0_tagcount + 1;
    ifd1_tagcount = ifd1_tagcount + 1;
    ifd0_tagcount = ifd0_tagcount + 1;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(datetime);
    datasize = datasize + (unsigned int)((unsigned long int)2 * ((unsigned long int)5 + return_value_strlen$3));
  }

  if(!(subtime == ((char *)NULL)))
  {
    ifd1_tagcount = ifd1_tagcount + 1;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(subtime);
    datasize = datasize + (unsigned int)((unsigned long int)5 + return_value_strlen$4);
  }

  if(!(box == ((struct coord *)NULL)))
  {
    ifd1_tagcount = ifd1_tagcount + 1;
    datasize = datasize + (unsigned int)(2 * 4);
  }

  if(ifd1_tagcount >= 1)
  {
    ifd0_tagcount = ifd0_tagcount + 1;
    ifd1_tagcount = ifd1_tagcount + 1;
  }

  unsigned int ifds_size = (unsigned int)((ifd1_tagcount > 0 ? 12 * ifd1_tagcount + 6 : 0) + (ifd0_tagcount > 0 ? 12 * ifd0_tagcount + 6 : 0));
  if(!(ifds_size == 0u))
  {
    unsigned int buffer_size = (unsigned int)(6 + 8) + ifds_size + datasize;
    unsigned char *marker;
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)buffer_size);
    marker = (unsigned char *)return_value_malloc$5;
    memcpy((void *)marker, (const void *)exif_marker_start, (unsigned long int)14);
    struct tiff_writing writing = { .base=marker + (signed long int)6, .buf=marker + (signed long int)14, .data_offset=(unsigned int)8 + ifds_size };
    put_uint16(writing.buf, (unsigned int)ifd0_tagcount);
    writing.buf = writing.buf + (signed long int)2;
    if(!(description == ((char *)NULL)))
      put_stringentry(&writing, (unsigned int)0x010E, description, 0);

    if(!(datetime == ((char *)NULL)))
      put_stringentry(&writing, (unsigned int)0x0132, datetime, 1);

    if(ifd1_tagcount >= 1)
    {
      unsigned int ifd1_offset = (unsigned int)(8 + 6 + 12 * ifd0_tagcount);
      memcpy((void *)writing.buf, (const void *)exif_subifd_tag, (unsigned long int)8);
      put_uint32(writing.buf + (signed long int)8, ifd1_offset);
      writing.buf = writing.buf + (signed long int)12;
    }

    if(!(datetime == ((char *)NULL)))
    {
      memcpy((void *)writing.buf, (const void *)exif_tzoffset_tag, (unsigned long int)12);
      put_sint16(writing.buf + (signed long int)8, (signed int)(timestamp->tm_gmtoff / (signed long int)3600));
      writing.buf = writing.buf + (signed long int)12;
    }

    put_uint32(writing.buf, (unsigned int)0);
    writing.buf = writing.buf + (signed long int)4;
    if(ifd1_tagcount >= 1)
    {
      put_uint16(writing.buf, (unsigned int)ifd1_tagcount);
      memcpy((void *)(writing.buf + (signed long int)2), (const void *)exif_version_tag, (unsigned long int)12);
      writing.buf = writing.buf + (signed long int)14;
      if(!(datetime == ((char *)NULL)))
        put_stringentry(&writing, (unsigned int)0x9003, datetime, 1);

      if(!(box == ((struct coord *)NULL)))
        put_subjectarea(&writing, box);

      if(!(subtime == ((char *)NULL)))
        put_stringentry(&writing, (unsigned int)0x9291, subtime, 0);

      put_uint32(writing.buf, (unsigned int)0);
      writing.buf = writing.buf + (signed long int)4;
    }

    /* assertion (writing.buf - writing.base) == 8 + ifds_size */
    assert(writing.buf - writing.base == (signed long int)((unsigned int)8 + ifds_size));
    unsigned int marker_len = (unsigned int)6 + writing.data_offset;
    /* assertion marker_len <= buffer_size */
    assert(marker_len <= buffer_size);
    jpeg_write_marker(cinfo, 0xE0 + 1, marker, marker_len);
    if(!(description == ((char *)NULL)))
      free((void *)description);

    free((void *)marker);
  }

}

// put_jpeg_grey_file
// file picture.c line 626
static void put_jpeg_grey_file(struct _IO_FILE *picture, unsigned char *image, signed int width, signed int height, signed int quality)
{
  signed int y;
  unsigned char *row_ptr[1l];
  struct jpeg_compress_struct cjpeg;
  struct jpeg_error_mgr jerr;
  cjpeg.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cjpeg, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  cjpeg.image_width = (unsigned int)width;
  cjpeg.image_height = (unsigned int)height;
  cjpeg.input_components = 1;
  cjpeg.in_color_space = (enum anonymous$10)JCS_GRAYSCALE;
  jpeg_set_defaults(&cjpeg);
  jpeg_set_quality(&cjpeg, quality, 1);
  cjpeg.dct_method = (enum anonymous$11)JDCT_IFAST;
  jpeg_stdio_dest(&cjpeg, picture);
  jpeg_start_compress(&cjpeg, 1);
  put_jpeg_exif(&cjpeg, (struct context *)(void *)0, (struct tm *)(void *)0, (struct coord *)(void *)0);
  row_ptr[(signed long int)0] = image;
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    jpeg_write_scanlines(&cjpeg, row_ptr, (unsigned int)1);
    row_ptr[(signed long int)0] = row_ptr[(signed long int)0] + (signed long int)width;
  }
  jpeg_finish_compress(&cjpeg);
  jpeg_destroy_compress(&cjpeg);
}

// put_jpeg_grey_memory
// file picture.c line 497
static signed int put_jpeg_grey_memory(unsigned char *dest_image, signed int image_size, unsigned char *input_image, signed int width, signed int height, signed int quality)
{
  signed int y;
  signed int dest_image_size;
  unsigned char *row_ptr[1l];
  struct jpeg_compress_struct cjpeg;
  struct jpeg_error_mgr jerr;
  cjpeg.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cjpeg, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  cjpeg.image_width = (unsigned int)width;
  cjpeg.image_height = (unsigned int)height;
  cjpeg.input_components = 1;
  cjpeg.in_color_space = (enum anonymous$10)JCS_GRAYSCALE;
  jpeg_set_defaults(&cjpeg);
  jpeg_set_quality(&cjpeg, quality, 1);
  cjpeg.dct_method = (enum anonymous$11)JDCT_IFAST;
  _jpeg_mem_dest(&cjpeg, dest_image, (unsigned long int)image_size);
  jpeg_start_compress(&cjpeg, 1);
  put_jpeg_exif(&cjpeg, (struct context *)(void *)0, (struct tm *)(void *)0, (struct coord *)(void *)0);
  row_ptr[(signed long int)0] = input_image;
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    jpeg_write_scanlines(&cjpeg, row_ptr, (unsigned int)1);
    row_ptr[(signed long int)0] = row_ptr[(signed long int)0] + (signed long int)width;
  }
  jpeg_finish_compress(&cjpeg);
  dest_image_size=_jpeg_mem_size(&cjpeg);
  jpeg_destroy_compress(&cjpeg);
  return dest_image_size;
}

// put_jpeg_yuv420p_file
// file picture.c line 550
static void put_jpeg_yuv420p_file(struct _IO_FILE *fp, unsigned char *image, signed int width, signed int height, signed int quality, struct context *cnt, struct tm *tm, struct coord *box)
{
  signed int i;
  signed int j;
  unsigned char *y[16l];
  unsigned char *cb[16l];
  unsigned char *cr[16l];
  unsigned char **data[3l];
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  data[(signed long int)0] = y;
  data[(signed long int)1] = cb;
  data[(signed long int)2] = cr;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  cinfo.image_width = (unsigned int)width;
  cinfo.image_height = (unsigned int)height;
  cinfo.input_components = 3;
  jpeg_set_defaults(&cinfo);
  jpeg_set_colorspace(&cinfo, (enum anonymous$10)JCS_YCbCr);
  cinfo.raw_data_in = 1;
  (cinfo.comp_info + (signed long int)0)->h_samp_factor = 2;
  (cinfo.comp_info + (signed long int)0)->v_samp_factor = 2;
  (cinfo.comp_info + (signed long int)1)->h_samp_factor = 1;
  (cinfo.comp_info + (signed long int)1)->v_samp_factor = 1;
  (cinfo.comp_info + (signed long int)2)->h_samp_factor = 1;
  (cinfo.comp_info + (signed long int)2)->v_samp_factor = 1;
  jpeg_set_quality(&cinfo, quality, 1);
  cinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
  jpeg_stdio_dest(&cinfo, fp);
  jpeg_start_compress(&cinfo, 1);
  put_jpeg_exif(&cinfo, cnt, tm, box);
  j = 0;
  for( ; !(j >= height); j = j + 16)
  {
    i = 0;
    for( ; !(i >= 16); i = i + 1)
    {
      y[(signed long int)i] = image + (signed long int)(width * (i + j));
      if(i % 2 == 0)
      {
        cb[(signed long int)(i / 2)] = image + (signed long int)(width * height) + (signed long int)((width / 2) * ((i + j) / 2));
        cr[(signed long int)(i / 2)] = image + (signed long int)(width * height) + (signed long int)((width * height) / 4) + (signed long int)((width / 2) * ((i + j) / 2));
      }

    }
    jpeg_write_raw_data(&cinfo, data, (unsigned int)16);
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
}

// put_jpeg_yuv420p_memory
// file picture.c line 416
static signed int put_jpeg_yuv420p_memory(unsigned char *dest_image, signed int image_size, unsigned char *input_image, signed int width, signed int height, signed int quality, struct context *cnt, struct tm *tm, struct coord *box)
{
  signed int i;
  signed int j;
  signed int jpeg_image_size;
  unsigned char *y[16l];
  unsigned char *cb[16l];
  unsigned char *cr[16l];
  unsigned char **data[3l];
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  data[(signed long int)0] = y;
  data[(signed long int)1] = cb;
  data[(signed long int)2] = cr;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  cinfo.image_width = (unsigned int)width;
  cinfo.image_height = (unsigned int)height;
  cinfo.input_components = 3;
  jpeg_set_defaults(&cinfo);
  jpeg_set_colorspace(&cinfo, (enum anonymous$10)JCS_YCbCr);
  cinfo.raw_data_in = 1;
  (cinfo.comp_info + (signed long int)0)->h_samp_factor = 2;
  (cinfo.comp_info + (signed long int)0)->v_samp_factor = 2;
  (cinfo.comp_info + (signed long int)1)->h_samp_factor = 1;
  (cinfo.comp_info + (signed long int)1)->v_samp_factor = 1;
  (cinfo.comp_info + (signed long int)2)->h_samp_factor = 1;
  (cinfo.comp_info + (signed long int)2)->v_samp_factor = 1;
  jpeg_set_quality(&cinfo, quality, 1);
  cinfo.dct_method = (enum anonymous$11)JDCT_IFAST;
  _jpeg_mem_dest(&cinfo, dest_image, (unsigned long int)image_size);
  jpeg_start_compress(&cinfo, 1);
  put_jpeg_exif(&cinfo, cnt, tm, box);
  j = 0;
  for( ; !(j >= height); j = j + 16)
  {
    i = 0;
    for( ; !(i >= 16); i = i + 1)
    {
      y[(signed long int)i] = input_image + (signed long int)(width * (i + j));
      if(i % 2 == 0)
      {
        cb[(signed long int)(i / 2)] = input_image + (signed long int)(width * height) + (signed long int)((width / 2) * ((i + j) / 2));
        cr[(signed long int)(i / 2)] = input_image + (signed long int)(width * height) + (signed long int)((width * height) / 4) + (signed long int)((width / 2) * ((i + j) / 2));
      }

    }
    jpeg_write_raw_data(&cinfo, data, (unsigned int)16);
  }
  jpeg_finish_compress(&cinfo);
  jpeg_image_size=_jpeg_mem_size(&cinfo);
  jpeg_destroy_compress(&cinfo);
  return jpeg_image_size;
}

// put_picture
// file picture.h line 21
void put_picture(struct context *cnt, char *file, unsigned char *image, signed int ftype)
{
  struct _IO_FILE *picture;
  picture=myfopen(file, "w", (unsigned long int)(1024 * 1024));
  if(picture == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 13)
    {
      motion_log(3, (unsigned int)9, 1, "%s: Can't write picture to file %s - check access rights to target directory\nThread is going to finish due to this fatal error", (const void *)"put_picture", file);
      cnt->finish = (volatile unsigned int)1;
      cnt->restart = (volatile unsigned int)0;
      goto __CPROVER_DUMP_L4;
    }

    else
    {
      motion_log(3, (unsigned int)9, 1, "%s: Can't write picture to file %s", (const void *)"put_picture", file);
      goto __CPROVER_DUMP_L4;
    }
  }

  put_picture_fd(cnt, picture, image, cnt->conf.quality);
  myfclose(picture);
  event(cnt, 1, (unsigned char *)(void *)0, file, (void *)(unsigned long int)ftype, (struct tm *)(void *)0);

__CPROVER_DUMP_L4:
  ;
}

// put_picture_fd
// file picture.c line 900
void put_picture_fd(struct context *cnt, struct _IO_FILE *picture, unsigned char *image, signed int quality)
{
  if(cnt->imgs.picture_type == 1)
    put_ppm_bgr24_file(picture, image, cnt->imgs.width, cnt->imgs.height);

  else
    switch(cnt->imgs.type)
    {
      case 15:
      {
        put_jpeg_yuv420p_file(picture, image, cnt->imgs.width, cnt->imgs.height, quality, cnt, &cnt->current_image->timestamp_tm, &cnt->current_image->location);
        break;
      }
      case 1:
      {
        put_jpeg_grey_file(picture, image, cnt->imgs.width, cnt->imgs.height, quality);
        break;
      }
      default:
        motion_log(4, (unsigned int)9, 0, "%s: Unknow image type %d", (const void *)"put_picture_fd", cnt->imgs.type);
    }
}

// put_picture_memory
// file picture.c line 882
signed int put_picture_memory(struct context *cnt, unsigned char *dest_image, signed int image_size, unsigned char *image, signed int quality)
{
  signed int return_value_put_jpeg_yuv420p_memory$1;
  signed int return_value_put_jpeg_grey_memory$2;
  switch(cnt->imgs.type)
  {
    case 15:
    {
      return_value_put_jpeg_yuv420p_memory$1=put_jpeg_yuv420p_memory(dest_image, image_size, image, cnt->imgs.width, cnt->imgs.height, quality, cnt, &cnt->current_image->timestamp_tm, &cnt->current_image->location);
      return return_value_put_jpeg_yuv420p_memory$1;
    }
    case 1:
    {
      return_value_put_jpeg_grey_memory$2=put_jpeg_grey_memory(dest_image, image_size, image, cnt->imgs.width, cnt->imgs.height, quality);
      return return_value_put_jpeg_grey_memory$2;
    }
    default:
    {
      motion_log(4, (unsigned int)9, 0, "%s: Unknow image type %d", (const void *)"put_picture_memory", cnt->imgs.type);
      return 0;
    }
  }
}

// put_ppm_bgr24_file
// file picture.c line 675
static void put_ppm_bgr24_file(struct _IO_FILE *picture, unsigned char *image, signed int width, signed int height)
{
  signed int x;
  signed int y;
  unsigned char *l = image;
  unsigned char *u = image + (signed long int)(width * height);
  unsigned char *v = u + (signed long int)((width * height) / 4);
  signed int r;
  signed int g;
  signed int b;
  signed int warningkiller;
  unsigned char rgb[3l];
  fprintf(picture, "P6\n");
  fprintf(picture, "%d %d\n", width, height);
  fprintf(picture, "%d\n", 255);
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    x = 0;
    for( ; !(x >= width); x = x + 1)
    {
      r = 76283 * ((signed int)*l - 16) + 104595 * ((signed int)*u - 128);
      g = (76283 * ((signed int)*l - 16) - 53281 * ((signed int)*u - 128)) - 25625 * ((signed int)*v - 128);
      b = 76283 * ((signed int)*l - 16) + 132252 * ((signed int)*v - 128);
      r = r >> 16;
      g = g >> 16;
      b = b >> 16;
      if(!(r >= 0))
        r = 0;

      else
        if(r >= 256)
          r = 255;

      if(!(g >= 0))
        g = 0;

      else
        if(g >= 256)
          g = 255;

      if(!(b >= 0))
        b = 0;

      else
        if(b >= 256)
          b = 255;

      rgb[(signed long int)0] = (unsigned char)b;
      rgb[(signed long int)1] = (unsigned char)g;
      rgb[(signed long int)2] = (unsigned char)r;
      l = l + 1l;
      if(!((1 & x) == 0))
      {
        u = u + 1l;
        v = v + 1l;
      }

      unsigned long int return_value_fwrite$1;
      return_value_fwrite$1=fwrite((const void *)rgb, (unsigned long int)1, (unsigned long int)3, picture);
      warningkiller = (signed int)return_value_fwrite$1;
    }
    if(!((1 & y) == 0))
    {
      u = u - (signed long int)(width / 2);
      v = v - (signed long int)(width / 2);
    }

  }
}

// put_sint16
// file picture.c line 151
static void put_sint16(unsigned char *buf, signed int value)
{
  buf[(signed long int)0] = (unsigned char)((value & 0xFF00) >> 8);
  buf[(signed long int)1] = (unsigned char)(value & 0x00FF);
}

// put_stringentry
// file picture.c line 192
static void put_stringentry(struct tiff_writing *into, unsigned int tag, const char *str, signed int with_nul)
{
  unsigned int stringlength;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  stringlength = (unsigned int)(return_value_strlen$1 + (unsigned long int)(with_nul != 0 ? 1 : 0));
  put_uint16(into->buf, tag);
  put_uint16(into->buf + (signed long int)2, (unsigned int)2);
  put_uint32(into->buf + (signed long int)4, stringlength);
  into->buf = into->buf + (signed long int)8;
  put_direntry(into, str, stringlength);
  into->buf = into->buf + (signed long int)4;
}

// put_subjectarea
// file picture.c line 204
static void put_subjectarea(struct tiff_writing *into, struct coord *box)
{
  put_uint16(into->buf, (unsigned int)0x9214);
  put_uint16(into->buf + (signed long int)2, (unsigned int)3);
  put_uint32(into->buf + (signed long int)4, (unsigned int)4);
  put_uint32(into->buf + (signed long int)8, into->data_offset);
  into->buf = into->buf + (signed long int)12;
  unsigned char *ool = into->base + (signed long int)into->data_offset;
  put_uint16(ool, (unsigned int)box->x);
  put_uint16(ool + (signed long int)2, (unsigned int)box->y);
  put_uint16(ool + (signed long int)4, (unsigned int)box->width);
  put_uint16(ool + (signed long int)6, (unsigned int)box->height);
  into->data_offset = into->data_offset + (unsigned int)8;
}

// put_uint16
// file picture.c line 145
static void put_uint16(unsigned char *buf, unsigned int value)
{
  buf[(signed long int)0] = (unsigned char)((value & (unsigned int)0xFF00) >> 8);
  buf[(signed long int)1] = (unsigned char)(value & (unsigned int)0x00FF);
}

// put_uint32
// file picture.c line 157
static void put_uint32(unsigned char *buf, unsigned int value)
{
  buf[(signed long int)0] = (unsigned char)((value & 0xFF000000) >> 24);
  buf[(signed long int)1] = (unsigned char)((value & (unsigned int)0x00FF0000) >> 16);
  buf[(signed long int)2] = (unsigned char)((value & (unsigned int)0x0000FF00) >> 8);
  buf[(signed long int)3] = (unsigned char)(value & (unsigned int)0x000000FF);
}

// rbuf_flush
// file netcam_wget.h line 67
signed int rbuf_flush(struct netcam_context *netcam, char *where, signed int maxsize)
{
  if(netcam->response->buffer_left == 0ul)
    return 0;

  else
  {
    signed int howmuch;
    signed int tmp_if_expr$1;
    if(!((signed int)netcam->response->buffer_left >= maxsize))
      tmp_if_expr$1 = (signed int)netcam->response->buffer_left;

    else
      tmp_if_expr$1 = maxsize;
    howmuch = tmp_if_expr$1;
    if(!(where == ((char *)NULL)))
      memcpy((void *)where, (const void *)netcam->response->buffer_pos, (unsigned long int)howmuch);

    netcam->response->buffer_left = netcam->response->buffer_left - (unsigned long int)howmuch;
    netcam->response->buffer_pos = netcam->response->buffer_pos + (signed long int)howmuch;
    return howmuch;
  }
}

// rbuf_initialize
// file netcam_wget.h line 62
void rbuf_initialize(struct netcam_context *netcam)
{
  netcam->response->buffer_pos = netcam->response->buffer;
  netcam->response->buffer_left = (unsigned long int)0;
}

// rbuf_peek
// file netcam_wget.c line 308
signed int rbuf_peek(struct netcam_context *netcam, char *store)
{
  if(netcam->response->buffer_left == 0ul)
  {
    signed int res;
    rbuf_initialize(netcam);
    signed long int return_value_netcam_recv$1;
    return_value_netcam_recv$1=netcam_recv(netcam, (void *)netcam->response->buffer, sizeof(char [4096l]) /*4096ul*/ );
    res = (signed int)return_value_netcam_recv$1;
    if(!(res >= 1))
    {
      *store = (char)0;
      return res;
    }

    netcam->response->buffer_left = (unsigned long int)res;
  }

  *store = *netcam->response->buffer_pos;
  return 1;
}

// rbuf_read_bufferful
// file netcam_wget.h line 70
signed int rbuf_read_bufferful(struct netcam_context *netcam)
{
  signed long int return_value_netcam_recv$1;
  return_value_netcam_recv$1=netcam_recv(netcam, (void *)netcam->response->buffer, sizeof(char [4096l]) /*4096ul*/ );
  return (signed int)return_value_netcam_recv$1;
}

// read_client
// file webhttpd.c line 2207
static unsigned int read_client(signed int client_socket, void *userdata, char *auth)
{
  unsigned int alive = (unsigned int)1;
  unsigned int ret = (unsigned int)1;
  char buffer[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed long int length = (signed long int)1023;
  struct context **cnt = (struct context **)userdata;
  pthread_mutex_lock(&httpd_mutex);
  signed long int return_value_write_nonblock$1;
  signed long int return_value_write_nonblock$2;
  char *return_value_strstr$3;
  signed int return_value_strcmp$6;
  signed long int return_value_write_nonblock$4;
  signed long int return_value_write_nonblock$5;
  while(!(alive == 0u))
  {
    signed long int nread = (signed long int)0;
    signed long int readb = (signed long int)-1;
    nread=read_nonblock(client_socket, (void *)buffer, length);
    if(!(nread >= 1l))
    {
      motion_log(3, (unsigned int)2, 1, "%s: motion-httpd First Read Error", (const void *)"read_client");
      pthread_mutex_unlock(&httpd_mutex);
      return (unsigned int)1;
    }

    else
    {
      char method[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char url[512l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char protocol[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char *authentication = (char *)(void *)0;
      buffer[nread] = (char)0;
      warningkill=sscanf(buffer, "%9s %511s %9s", (const void *)method, (const void *)url, (const void *)protocol);
      if(!(warningkill == 3))
      {
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          return_value_write_nonblock$1=write_nonblock(client_socket, (const void *)bad_request_response, sizeof(const char *) /*8ul*/ );
          warningkill = (signed int)return_value_write_nonblock$1;
        }

        else
        {
          return_value_write_nonblock$2=write_nonblock(client_socket, (const void *)bad_request_response_raw, sizeof(const char *) /*8ul*/ );
          warningkill = (signed int)return_value_write_nonblock$2;
        }
        pthread_mutex_unlock(&httpd_mutex);
        return (unsigned int)1;
      }

      do
      {
        return_value_strstr$3=strstr(buffer, "\r\n\r\n");
        if(!(return_value_strstr$3 == ((char *)NULL)))
          break;

        if(readb == 0l)
          break;

        if(nread >= length)
          break;

        readb=read_nonblock(client_socket, (void *)(buffer + nread), (signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)nread));
        if(readb == -1l)
        {
          nread = (signed long int)-1;
          break;
        }

        nread = nread + readb;
        if(!(length >= nread))
        {
          motion_log(4, (unsigned int)2, 1, "%s: motion-httpd End buffer reached waiting for buffer ending", (const void *)"read_client");
          break;
        }

        buffer[nread] = (char)0;
      }
      while((_Bool)1);
      if(nread == -1l)
      {
        motion_log(3, (unsigned int)2, 1, "%s: motion-httpd READ give up!", (const void *)"read_client");
        pthread_mutex_unlock(&httpd_mutex);
        return (unsigned int)1;
      }

      alive = (unsigned int)0;
      signed int return_value_strcmp$7;
      return_value_strcmp$7=strcmp(protocol, "HTTP/1.0");
      if(!(return_value_strcmp$7 == 0))
      {
        return_value_strcmp$6=strcmp(protocol, "HTTP/1.1");
        if(!(return_value_strcmp$6 == 0))
        {
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            return_value_write_nonblock$4=write_nonblock(client_socket, (const void *)bad_request_response, sizeof(const char *) /*8ul*/ );
            warningkill = (signed int)return_value_write_nonblock$4;
          }

          else
          {
            return_value_write_nonblock$5=write_nonblock(client_socket, (const void *)bad_request_response_raw, sizeof(const char *) /*8ul*/ );
            warningkill = (signed int)return_value_write_nonblock$5;
          }
          pthread_mutex_unlock(&httpd_mutex);
          return (unsigned int)1;
        }

      }

      signed int return_value_strcmp$10;
      return_value_strcmp$10=strcmp(method, "GET");
      if(!(return_value_strcmp$10 == 0))
      {
        char response[1024l];
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          snprintf(response, sizeof(char [1024l]) /*1024ul*/ , bad_method_response_template, (const void *)method);

        else
          snprintf(response, sizeof(char [1024l]) /*1024ul*/ , bad_method_response_template_raw, (const void *)method);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(response);
        signed long int return_value_write_nonblock$9;
        return_value_write_nonblock$9=write_nonblock(client_socket, (const void *)response, return_value_strlen$8);
        warningkill = (signed int)return_value_write_nonblock$9;
        pthread_mutex_unlock(&httpd_mutex);
        return (unsigned int)1;
      }

      if(!(auth == ((char *)NULL)))
      {
        authentication=strstr(buffer, "Basic");
        if(!(authentication == ((char *)NULL)))
        {
          char *end_auth = (char *)(void *)0;
          authentication = authentication + (signed long int)6;
          end_auth=strstr(authentication, "\r\n");
          if(!(end_auth == ((char *)NULL)))
            authentication[end_auth - authentication] = (char)0;

          else
          {
            char read_client$$1$$1$$2$$6$$1$$2$$response[1024l];
            snprintf(read_client$$1$$1$$2$$6$$1$$2$$response, sizeof(char [1024l]) /*1024ul*/ , request_auth_response_template, (const void *)method);
            unsigned long int return_value_strlen$11;
            return_value_strlen$11=strlen(read_client$$1$$1$$2$$6$$1$$2$$response);
            signed long int return_value_write_nonblock$12;
            return_value_write_nonblock$12=write_nonblock(client_socket, (const void *)read_client$$1$$1$$2$$6$$1$$2$$response, return_value_strlen$11);
            warningkill = (signed int)return_value_write_nonblock$12;
            pthread_mutex_unlock(&httpd_mutex);
            return (unsigned int)1;
          }
          signed int return_value_strcmp$15;
          return_value_strcmp$15=strcmp(auth, authentication);
          if(!(return_value_strcmp$15 == 0))
          {
            char read_client$$1$$1$$2$$6$$1$$3$$response[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            snprintf(read_client$$1$$1$$2$$6$$1$$3$$response, sizeof(char [1024l]) /*1024ul*/ , request_auth_response_template, (const void *)method);
            unsigned long int return_value_strlen$13;
            return_value_strlen$13=strlen(read_client$$1$$1$$2$$6$$1$$3$$response);
            signed long int return_value_write_nonblock$14;
            return_value_write_nonblock$14=write_nonblock(client_socket, (const void *)read_client$$1$$1$$2$$6$$1$$3$$response, return_value_strlen$13);
            warningkill = (signed int)return_value_write_nonblock$14;
            pthread_mutex_unlock(&httpd_mutex);
            return (unsigned int)1;
          }

          else
            ret=handle_get(client_socket, url, (void *)cnt);
        }

        else
        {
          char read_client$$1$$1$$2$$6$$2$$response[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
          snprintf(read_client$$1$$1$$2$$6$$2$$response, sizeof(char [1024l]) /*1024ul*/ , request_auth_response_template, (const void *)method);
          unsigned long int return_value_strlen$16;
          return_value_strlen$16=strlen(read_client$$1$$1$$2$$6$$2$$response);
          signed long int return_value_write_nonblock$17;
          return_value_write_nonblock$17=write_nonblock(client_socket, (const void *)read_client$$1$$1$$2$$6$$2$$response, return_value_strlen$16);
          warningkill = (signed int)return_value_write_nonblock$17;
          pthread_mutex_unlock(&httpd_mutex);
          return (unsigned int)1;
        }
      }

      else
        ret=handle_get(client_socket, url, (void *)cnt);
    }
  }
  pthread_mutex_unlock(&httpd_mutex);
  return ret;
}

// read_http_request
// file stream.c line 69
static signed int read_http_request(signed int sock, char *buffer, signed int buflen, char *uri, signed int uri_len)
{
  signed int nread = 0;
  signed int ret;
  signed int readb = 1;
  char method[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char url[512l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char protocol[10l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  buffer[(signed long int)0] = (char)0;
  char *return_value_strstr$1;
  do
  {
    return_value_strstr$1=strstr(buffer, "\r\n\r\n");
    if(!(return_value_strstr$1 == ((char *)NULL)))
      break;

    if(readb == 0)
      break;

    if(nread >= buflen)
      break;

    signed long int return_value_read$2;
    return_value_read$2=read(sock, (void *)(buffer + (signed long int)nread), (unsigned long int)(buflen - nread));
    readb = (signed int)return_value_read$2;
    if(readb == -1)
    {
      nread = -1;
      break;
    }

    nread = nread + readb;
    if(!(buflen >= nread))
    {
      motion_log(3, (unsigned int)2, 1, "%s: motion-stream End buffer reached waiting for buffer ending", (const void *)"read_http_request");
      break;
    }

    buffer[(signed long int)nread] = (char)0;
  }
  while((_Bool)1);
  if(nread == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    if(*return_value___errno_location$5 == 11)
    {
      unsigned long int return_value_strlen$3;
      static const char *timeout_response_template_raw = "HTTP/1.0 408 Request Timeout\r\nContent-type: text/plain\r\n\r\nRequest Timeout\n";
      return_value_strlen$3=strlen(timeout_response_template_raw);
      signed long int return_value_write$4;
      return_value_write$4=write(sock, (const void *)timeout_response_template_raw, return_value_strlen$3);
      ret = (signed int)return_value_write$4;
      return 0;
    }

    motion_log(3, (unsigned int)2, 1, "%s: motion-stream READ give up!", (const void *)"read_http_request");
    return 0;
  }

  ret=sscanf(buffer, "%9s %511s %9s", (const void *)method, (const void *)url, (const void *)protocol);
  static const char *read_http_request$$1$$bad_request_response_raw = "HTTP/1.0 400 Bad Request\r\nContent-type: text/plain\r\n\r\nBad Request\n";
  if(!(ret == 3))
  {
    signed long int return_value_write$6;
    return_value_write$6=write(sock, (const void *)read_http_request$$1$$bad_request_response_raw, sizeof(const char *) /*8ul*/ );
    ret = (signed int)return_value_write$6;
    return 0;
  }

  signed int return_value_strcmp$9;
  return_value_strcmp$9=strcmp(protocol, "HTTP/1.0");
  signed int return_value_strcmp$8;
  if(!(return_value_strcmp$9 == 0))
  {
    return_value_strcmp$8=strcmp(protocol, "HTTP/1.1");
    if(!(return_value_strcmp$8 == 0))
    {
      signed long int return_value_write$7;
      return_value_write$7=write(sock, (const void *)read_http_request$$1$$bad_request_response_raw, sizeof(const char *) /*8ul*/ );
      ret = (signed int)return_value_write$7;
      return 0;
    }

  }

  signed int return_value_strcmp$12;
  return_value_strcmp$12=strcmp(method, "GET");
  if(!(return_value_strcmp$12 == 0))
  {
    char response[1024l];
    static const char *read_http_request$$1$$bad_method_response_template_raw = "HTTP/1.0 501 Method Not Implemented\r\nContent-type: text/plain\r\n\r\nMethod Not Implemented\n";
    snprintf(response, sizeof(char [1024l]) /*1024ul*/ , read_http_request$$1$$bad_method_response_template_raw, (const void *)method);
    unsigned long int return_value_strlen$10;
    return_value_strlen$10=strlen(response);
    signed long int return_value_write$11;
    return_value_write$11=write(sock, (const void *)response, return_value_strlen$10);
    ret = (signed int)return_value_write$11;
    return 0;
  }

  if(!(uri == ((char *)NULL)))
    strncpy(uri, url, (unsigned long int)uri_len);

  return 1;
}

// read_nonblock
// file webhttpd.c line 220
static signed long int read_nonblock(signed int fd, void *buf, signed long int size)
{
  signed long int nread = (signed long int)-1;
  struct timeval tm;
  struct anonymous$45 fds;
  tm.tv_sec = (signed long int)1;
  tm.tv_usec = (signed long int)0;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$2;
  return_value_select$2=select(fd + 1, &fds, (struct anonymous$45 *)(void *)0, (struct anonymous$45 *)(void *)0, &tm);
  if(return_value_select$2 >= 1)
  {
    if(!((fds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
    {
      nread=read(fd, buf, (unsigned long int)size);
      if(!(nread >= 0l))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(!(*return_value___errno_location$1 == 11))
          return (signed long int)-1;

      }

    }

  }

  return nread;
}

// replace
// file webhttpd.c line 311
static char * replace(const char *str, const char *old, const char *new)
{
  char *ret;
  char *r;
  const char *p;
  const char *q;
  unsigned long int oldlen;
  oldlen=strlen(old);
  unsigned long int count;
  unsigned long int retlen;
  unsigned long int newlen;
  newlen=strlen(new);
  if(!(oldlen == newlen))
  {
    count = (unsigned long int)0;
    p = str;
    do
    {
      q=strstr(p, old);
      if(q == ((const char *)NULL))
        break;

      count = count + 1ul;
      p = q + (signed long int)oldlen;
    }
    while((_Bool)1);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(p);
    retlen = (unsigned long int)(p - str) + return_value_strlen$1 + count * (newlen - oldlen);
  }

  else
    retlen=strlen(str);
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc(retlen + (unsigned long int)1);
  ret = (char *)return_value_mymalloc$2;
  r = ret;
  p = str;
  do
  {
    q=strstr(p, old);
    if(q == ((const char *)NULL))
      break;

    signed long int l = q - p;
    memcpy((void *)r, (const void *)p, (unsigned long int)l);
    r = r + l;
    memcpy((void *)r, (const void *)new, newlen);
    r = r + (signed long int)newlen;
    p = q + (signed long int)oldlen;
  }
  while((_Bool)1);
  strcpy(r, p);
  return ret;
}

// response_client
// file webhttpd.c line 298
static void response_client(signed int client_socket, const char *template, char *back)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(template);
  nwrite=write_nonblock(client_socket, (const void *)template, return_value_strlen$1);
  if(!(back == ((char *)NULL)))
  {
    send_template(client_socket, back);
    send_template_end_client(client_socket);
  }

}

// reverse_inplace_quad
// file rotate.c line 137
static void reverse_inplace_quad(unsigned char *src, signed int size)
{
  unsigned int *nsrc = (unsigned int *)src;
  unsigned int *ndst = (unsigned int *)((src + (signed long int)size) - (signed long int)4);
  unsigned int tmp;
  while(!(nsrc >= ndst))
  {
    unsigned int tmp_statement_expression$1;
    unsigned int reverse_inplace_quad$$1$$1$$1$$__x = *ndst;
    tmp_statement_expression$1 = (reverse_inplace_quad$$1$$1$$1$$__x & 0xff000000) >> 24 | (reverse_inplace_quad$$1$$1$$1$$__x & (unsigned int)0x00ff0000) >> 8 | (reverse_inplace_quad$$1$$1$$1$$__x & (unsigned int)0x0000ff00) << 8 | (reverse_inplace_quad$$1$$1$$1$$__x & (unsigned int)0x000000ff) << 24;
    tmp = tmp_statement_expression$1;
    unsigned int *tmp_post$2 = ndst;
    ndst = ndst - 1l;
    unsigned int tmp_statement_expression$3;
    unsigned int __x = *nsrc;
    tmp_statement_expression$3 = (__x & 0xff000000) >> 24 | (__x & (unsigned int)0x00ff0000) >> 8 | (__x & (unsigned int)0x0000ff00) << 8 | (__x & (unsigned int)0x000000ff) << 24;
    *tmp_post$2 = tmp_statement_expression$3;
    unsigned int *tmp_post$4 = nsrc;
    nsrc = nsrc + 1l;
    *tmp_post$4 = tmp;
  }
}

// rot90ccw
// file rotate.c line 200
static inline void rot90ccw(unsigned char *src, unsigned char *dst, signed int size, signed int width, signed int height)
{
  unsigned char *endp;
  unsigned char *base;
  signed int j;
  endp = src + (signed long int)size;
  dst = (dst + (signed long int)size) - (signed long int)1;
  base = endp - (signed long int)width;
  for( ; !(base >= endp); base = base + 1l)
  {
    src = base;
    j = 0;
    for( ; !(j >= height); src = src - (signed long int)width)
    {
      unsigned char *tmp_post$1 = dst;
      dst = dst - 1l;
      *tmp_post$1 = *src;
      j = j + 1;
    }
  }
}

// rot90cw
// file rotate.c line 167
static void rot90cw(unsigned char *src, unsigned char *dst, signed int size, signed int width, signed int height)
{
  unsigned char *endp;
  unsigned char *base;
  signed int j;
  endp = src + (signed long int)size;
  base = endp - (signed long int)width;
  for( ; !(base >= endp); base = base + 1l)
  {
    src = base;
    j = 0;
    for( ; !(j >= height); src = src - (signed long int)width)
    {
      unsigned char *tmp_post$1 = dst;
      dst = dst + 1l;
      *tmp_post$1 = *src;
      j = j + 1;
    }
  }
}

// rotate_deinit
// file rotate.h line 39
void rotate_deinit(struct context *cnt)
{
  if(!(cnt->rotate_data.temp_buf == ((unsigned char *)NULL)))
    free((void *)cnt->rotate_data.temp_buf);

}

// rotate_init
// file rotate.h line 28
void rotate_init(struct context *cnt)
{
  signed int size;
  cnt->rotate_data.temp_buf = (unsigned char *)(void *)0;
  if(cnt->conf.rotate_deg % 90 >= 1)
  {
    motion_log(4, (unsigned int)9, 0, "%s: Config option \"rotate\" not a multiple of 90: %d", (const void *)"rotate_init", cnt->conf.rotate_deg);
    cnt->conf.rotate_deg = 0;
    cnt->rotate_data.degrees = 0;
  }

  else
    cnt->rotate_data.degrees = cnt->conf.rotate_deg % 360;
  cnt->rotate_data.cap_width = cnt->imgs.width;
  cnt->rotate_data.cap_height = cnt->imgs.height;
  _Bool tmp_if_expr$1;
  if(cnt->rotate_data.degrees == 90)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = cnt->rotate_data.degrees == 270 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    cnt->imgs.width = cnt->rotate_data.cap_height;
    cnt->imgs.height = cnt->rotate_data.cap_width;
  }

  void *return_value_mymalloc$2;
  if(!(cnt->rotate_data.degrees == 0))
  {
    switch(cnt->imgs.type)
    {
      case 15:
      {
        size = (cnt->imgs.width * cnt->imgs.height * 3) / 2;
        break;
      }
      case 1:
      {
        size = cnt->imgs.width * cnt->imgs.height;
        break;
      }
      default:
      {
        cnt->rotate_data.degrees = 0;
        motion_log(4, (unsigned int)9, 0, "%s: Unsupported palette (%d), rotation is disabled", (const void *)"rotate_init", cnt->imgs.type);
        goto __CPROVER_DUMP_L14;
      }
    }
    _Bool tmp_if_expr$3;
    if(cnt->rotate_data.degrees == 90)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = cnt->rotate_data.degrees == 270 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_mymalloc$2=mymalloc((unsigned long int)size);
      cnt->rotate_data.temp_buf = (unsigned char *)return_value_mymalloc$2;
    }

  }


__CPROVER_DUMP_L14:
  ;
}

// rotate_map
// file rotate.h line 65
signed int rotate_map(struct context *cnt, unsigned char *map)
{
  signed int wh;
  signed int wh4 = 0;
  signed int w2 = 0;
  signed int h2 = 0;
  signed int size;
  signed int deg;
  signed int width;
  signed int height;
  deg = cnt->rotate_data.degrees;
  width = cnt->rotate_data.cap_width;
  height = cnt->rotate_data.cap_height;
  wh = width * height;
  if(cnt->imgs.type == 15)
  {
    size = (wh * 3) / 2;
    wh4 = wh / 4;
    w2 = width / 2;
    h2 = height / 2;
  }

  else
    size = wh;
  switch(deg)
  {
    case 90:
    {
      rot90cw(map, cnt->rotate_data.temp_buf, wh, width, height);
      if(cnt->imgs.type == 15)
      {
        rot90cw(map + (signed long int)wh, cnt->rotate_data.temp_buf + (signed long int)wh, wh4, w2, h2);
        rot90cw(map + (signed long int)wh + (signed long int)wh4, cnt->rotate_data.temp_buf + (signed long int)wh + (signed long int)wh4, wh4, w2, h2);
      }

      memcpy((void *)map, (const void *)cnt->rotate_data.temp_buf, (unsigned long int)size);
      break;
    }
    case 180:
    {
      reverse_inplace_quad(map, wh);
      if(cnt->imgs.type == 15)
      {
        reverse_inplace_quad(map + (signed long int)wh, wh4);
        reverse_inplace_quad(map + (signed long int)wh + (signed long int)wh4, wh4);
      }

      break;
    }
    case 270:
    {
      rot90ccw(map, cnt->rotate_data.temp_buf, wh, width, height);
      if(cnt->imgs.type == 15)
      {
        rot90ccw(map + (signed long int)wh, cnt->rotate_data.temp_buf + (signed long int)wh, wh4, w2, h2);
        rot90ccw(map + (signed long int)wh + (signed long int)wh4, cnt->rotate_data.temp_buf + (signed long int)wh + (signed long int)wh4, wh4, w2, h2);
      }

      memcpy((void *)map, (const void *)cnt->rotate_data.temp_buf, (unsigned long int)size);
      break;
    }
    default:
      return -1;
  }
  return 0;
}

// rtsp_connect
// file netcam_rtsp.h line 21
signed int rtsp_connect(struct netcam_context *netcam)
{
  if(netcam->rtsp == ((struct rtsp_context *)NULL))
  {
    netcam->rtsp=rtsp_new_context();
    if(!(netcam->rtsp == ((struct rtsp_context *)NULL)))
      goto __CPROVER_DUMP_L1;

    motion_log(1, (unsigned int)4, 0, "%s: unable to create context(%s)", (const void *)"rtsp_connect", netcam->rtsp->path);
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    struct AVDictionary *opts = ((struct AVDictionary *)NULL);
    av_dict_set(&opts, "rtsp_transport", "tcp", 0);
    signed int ret;
    ret=avformat_open_input(&netcam->rtsp->format_context, netcam->rtsp->path, (struct AVInputFormat *)(void *)0, &opts);
    if(!(ret >= 0))
    {
      char literal$1[64l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char *return_value_av_make_error_string$2;
      return_value_av_make_error_string$2=av_make_error_string(literal$1, (unsigned long int)64, ret);
      motion_log(1, (unsigned int)4, 0, "%s: unable to open input(%s): %d - %s", (const void *)"rtsp_connect", netcam->rtsp->path, ret, return_value_av_make_error_string$2);
      rtsp_free_context(netcam->rtsp);
      netcam->rtsp = (struct rtsp_context *)(void *)0;
      return -1;
    }

    ret=avformat_find_stream_info(netcam->rtsp->format_context, (struct AVDictionary **)(void *)0);
    if(!(ret >= 0))
    {
      motion_log(1, (unsigned int)4, 0, "%s: unable to find stream info: %d", (const void *)"rtsp_connect", ret);
      rtsp_free_context(netcam->rtsp);
      netcam->rtsp = (struct rtsp_context *)(void *)0;
      return -1;
    }

    else
    {
      ret=open_codec_context(&netcam->rtsp->video_stream_index, netcam->rtsp->format_context, (enum AVMediaType)AVMEDIA_TYPE_VIDEO);
      if(!(ret >= 0))
      {
        motion_log(1, (unsigned int)4, 0, "%s: unable to open codec context: %d", (const void *)"rtsp_connect", ret);
        rtsp_free_context(netcam->rtsp);
        netcam->rtsp = (struct rtsp_context *)(void *)0;
        return -1;
      }

      else
      {
        netcam->rtsp->codec_context = netcam->rtsp->format_context->streams[(signed long int)netcam->rtsp->video_stream_index]->codec;
        av_read_play(netcam->rtsp->format_context);
        return 0;
      }
    }
  }
}

// rtsp_free_context
// file netcam_rtsp.c line 147
static void rtsp_free_context(struct rtsp_context *ctxt)
{
  if(!(ctxt == ((struct rtsp_context *)NULL)))
  {
    if(!(ctxt->path == ((char *)NULL)))
      free((void *)ctxt->path);

    if(!(ctxt->user == ((char *)NULL)))
      free((void *)ctxt->user);

    if(!(ctxt->pass == ((char *)NULL)))
      free((void *)ctxt->pass);

    if(!(ctxt->format_context == ((struct AVFormatContext *)NULL)))
      avformat_close_input(&ctxt->format_context);

    if(!(ctxt->codec_context == ((struct AVCodecContext *)NULL)))
      avcodec_close(ctxt->codec_context);

    free((void *)ctxt);
  }

}

// rtsp_new_context
// file netcam_rtsp.h line 19
struct rtsp_context * rtsp_new_context(void)
{
  struct rtsp_context *ret;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct rtsp_context) /*48ul*/ );
  ret = (struct rtsp_context *)return_value_mymalloc$1;
  memset((void *)ret, 0, sizeof(struct rtsp_context) /*48ul*/ );
  return ret;
}

// sdl_put
// file sdl.h line 14
void sdl_put(unsigned char *image, signed int width, signed int height)
{
  union SDL_Event sdl_put$$1$$event;
  signed int return_value_SDL_LockSurface$1;
  char *return_value_SDL_GetError$4;
  if(!(overlay == ((struct SDL_Overlay *)NULL)) && !(screen == ((struct SDL_Surface *)NULL)))
  {
    struct SDL_Rect rect;
    float aspect_ratio = (float)width / (float)height;
    signed int pic_width;
    signed int pic_height;
    if(!(height == cur_height) || !(width == cur_width))
      sdl_video_open(width, height);

    _Bool tmp_if_expr$2;
    if(!(screen->offset == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (screen->flags & (unsigned int)(0x00000001 | 0x00000004 | 0x00004000)) != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      return_value_SDL_LockSurface$1=SDL_LockSurface(screen);
      if(!(return_value_SDL_LockSurface$1 >= 0))
        goto __CPROVER_DUMP_L15;

    }

    SDL_LockYUVOverlay(overlay);
    memcpy((void *)overlay->pixels[(signed long int)0], (const void *)image, (unsigned long int)(width * height));
    memcpy((void *)overlay->pixels[(signed long int)2], (const void *)(image + (signed long int)(width * height)), (unsigned long int)((width * height) / 4));
    memcpy((void *)overlay->pixels[(signed long int)1], (const void *)(image + (signed long int)((width * height * 5) / 4)), (unsigned long int)((width * height) / 4));
    SDL_UnlockYUVOverlay(overlay);
    _Bool tmp_if_expr$3;
    if(!(screen->offset == 0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (screen->flags & (unsigned int)(0x00000001 | 0x00000004 | 0x00004000)) != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      SDL_UnlockSurface(screen);

    pic_height = screen->h;
    pic_width = (signed int)((float)pic_height * aspect_ratio);
    if(!(screen->w >= pic_width))
    {
      pic_width = screen->w;
      pic_height = (signed int)((float)pic_width / aspect_ratio);
    }

    rect.x = (signed short int)((screen->w - pic_width) / 2);
    rect.y = (signed short int)((screen->h - pic_height) / 2);
    rect.w = (unsigned short int)pic_width;
    rect.h = (unsigned short int)pic_height;
    signed int return_value_SDL_DisplayYUVOverlay$5;
    return_value_SDL_DisplayYUVOverlay$5=SDL_DisplayYUVOverlay(overlay, &rect);
    if(!(return_value_SDL_DisplayYUVOverlay$5 == 0))
    {
      return_value_SDL_GetError$4=SDL_GetError();
      motion_log(3, (unsigned int)9, 1, "%s: SDL_DisplayYUVOverlay: %s", (const void *)"sdl_put", return_value_SDL_GetError$4);
    }

    signed int return_value_SDL_PollEvent$6;
    return_value_SDL_PollEvent$6=SDL_PollEvent(&sdl_put$$1$$event);
    if(!(return_value_SDL_PollEvent$6 == 0))
    {
      if((signed int)sdl_put$$1$$event.type == 12 || (signed int)sdl_put$$1$$event.key.keysym.sym == SDLK_ESCAPE && (signed int)sdl_put$$1$$event.type == 2)
        sdl_stop();

      else
        if((signed int)sdl_put$$1$$event.key.keysym.sym == SDLK_f && (signed int)sdl_put$$1$$event.type == 2)
        {
          is_full_screen = (signed int)!(is_full_screen != 0);
          sdl_video_open(width, height);
        }

        else
          if((signed int)sdl_put$$1$$event.type == 16)
            screen=SDL_SetVideoMode(sdl_put$$1$$event.resize.w, sdl_put$$1$$event.resize.h, (signed int)screen->format->BitsPerPixel, screen->flags);

    }

  }


__CPROVER_DUMP_L15:
  ;
}

// sdl_start
// file sdl.h line 13
signed int sdl_start(signed int width, signed int height)
{
  setenv("SDL_NOMOUSE", "1", 1);
  if(!(screen == ((struct SDL_Surface *)NULL)))
    return 0;

  else
  {
    motion_log(3, (unsigned int)9, 0, "%s: SDL start", (const void *)"sdl_start");
    signed int return_value_SDL_Init$2;
    return_value_SDL_Init$2=SDL_Init((unsigned int)0x00000020);
    if(!(return_value_SDL_Init$2 == 0))
    {
      char *return_value_SDL_GetError$1;
      return_value_SDL_GetError$1=SDL_GetError();
      motion_log(3, (unsigned int)9, 1, "%s: Could not initialize SDL - %s", (const void *)"sdl_start", return_value_SDL_GetError$1);
      return -1;
    }

    const struct SDL_VideoInfo *vi;
    vi=SDL_GetVideoInfo();
    fs_screen_width = vi->current_w;
    fs_screen_height = vi->current_h;
    signed int return_value_sdl_video_open$3;
    return_value_sdl_video_open$3=sdl_video_open(width, height);
    if(!(return_value_sdl_video_open$3 == 0))
      return -1;

    else
    {
      SDL_EventState((unsigned char)1, 0);
      SDL_EventState((unsigned char)4, 0);
      SDL_EventState((unsigned char)13, 0);
      SDL_EventState((unsigned char)24, 0);
      SDL_EventState((unsigned char)5, 0);
      SDL_EventState((unsigned char)6, 0);
      SDL_EventState((unsigned char)3, 0);
      SDL_EventState((unsigned char)10, 0);
      SDL_EventState((unsigned char)11, 0);
      SDL_EventState((unsigned char)7, 0);
      SDL_EventState((unsigned char)8, 0);
      SDL_EventState((unsigned char)9, 0);
      SDL_EventState((unsigned char)16, 0);
      return 0;
    }
  }
}

// sdl_stop
// file sdl.h line 15
void sdl_stop(void)
{
  if(!(screen == ((struct SDL_Surface *)NULL)))
  {
    motion_log(3, (unsigned int)9, 0, "%s: SDL quit", (const void *)"sdl_stop");
    SDL_ShowCursor(1);
    if(!(overlay == ((struct SDL_Overlay *)NULL)))
    {
      SDL_FreeYUVOverlay(overlay);
      overlay = (struct SDL_Overlay *)(void *)0;
    }

    SDL_Quit();
    screen = (struct SDL_Surface *)(void *)0;
  }

}

// sdl_video_open
// file sdl.c line 21
static signed int sdl_video_open(signed int width, signed int height)
{
  signed int flags = 0x00000001 | 0x00000004 | 0x00000100;
  signed int w;
  signed int h;
  if(!(is_full_screen == 0))
    flags = flags | (signed int)0x80000000;

  else
    flags = flags | 0x00000010;
  if(!(fs_screen_width == 0) && !(is_full_screen == 0))
  {
    w = fs_screen_width;
    h = fs_screen_height;
  }

  else
    if(!(fs_screen_height >= height) || !(fs_screen_width >= width))
    {
      w = fs_screen_width;
      h = fs_screen_height;
    }

    else
    {
      w = width;
      h = height;
    }
  screen=SDL_SetVideoMode(w, h, 32, (unsigned int)flags);
  if(screen == ((struct SDL_Surface *)NULL))
  {
    char *return_value_SDL_GetError$1;
    return_value_SDL_GetError$1=SDL_GetError();
    motion_log(3, (unsigned int)9, 1, "%s: Unable to set video mode: %s", (const void *)"sdl_video_open", return_value_SDL_GetError$1);
    return -1;
  }

  motion_log(3, (unsigned int)9, 0, "%s: SDL dimension %d x %d fullscreen %d BytesPerPixel %d", (const void *)"sdl_video_open", screen->w, screen->h, is_full_screen, screen->format->BytesPerPixel);
  SDL_WM_SetCaption("motion", "motion");
  SDL_ShowCursor(0);
  if(!(cur_height == height) || !(cur_width == width))
  {
    cur_width = width;
    cur_height = height;
    if(!(overlay == ((struct SDL_Overlay *)NULL)))
      SDL_FreeYUVOverlay(overlay);

    overlay=SDL_CreateYUVOverlay(cur_width, cur_height, (unsigned int)0x32315659, screen);
    if(overlay == ((struct SDL_Overlay *)NULL))
    {
      char *return_value_SDL_GetError$2;
      return_value_SDL_GetError$2=SDL_GetError();
      motion_log(3, (unsigned int)9, 1, "%s: Could not create overlay: %s", (const void *)"sdl_video_open", return_value_SDL_GetError$2);
      sdl_stop();
    }

    else
      motion_log(3, (unsigned int)9, 0, "%s: SDL created %dx%dx%d %s overlay", (const void *)"sdl_video_open", overlay->w, overlay->h, overlay->planes, overlay->hw_overlay != 0u ? "hardware" : "software");
  }

  return (signed int)(overlay == (struct SDL_Overlay *)(void *)0);
}

// send_template
// file webhttpd.c line 269
static void send_template(signed int client_socket, char *res)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(res);
  nwrite=write_nonblock(client_socket, (const void *)res, return_value_strlen$1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(res);
  if(!(nwrite == (signed long int)return_value_strlen$2))
    motion_log(3, (unsigned int)2, 1, "%s: failure write", (const void *)"send_template");

}

// send_template_end_client
// file webhttpd.c line 289
static void send_template_end_client(signed int client_socket)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(end_template);
  nwrite=write_nonblock(client_socket, (const void *)end_template, return_value_strlen$1);
}

// send_template_ini_client
// file webhttpd.c line 246
static void send_template_ini_client(signed int client_socket, const char *template)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(ok_response);
  nwrite=write_nonblock(client_socket, (const void *)ok_response, return_value_strlen$1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(template);
  signed long int return_value_write_nonblock$3;
  return_value_write_nonblock$3=write_nonblock(client_socket, (const void *)template, return_value_strlen$2);
  nwrite = nwrite + return_value_write_nonblock$3;
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(ok_response);
  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(template);
  if(!(nwrite == (signed long int)return_value_strlen$4 + (signed long int)return_value_strlen$5))
    motion_log(3, (unsigned int)2, 1, "%s: failure write", (const void *)"send_template_ini_client");

}

// send_template_ini_client_raw
// file webhttpd.c line 258
static void send_template_ini_client_raw(signed int client_socket)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(ok_response_raw);
  nwrite=write_nonblock(client_socket, (const void *)ok_response_raw, return_value_strlen$1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(ok_response_raw);
  if(!(nwrite == (signed long int)return_value_strlen$2))
    motion_log(3, (unsigned int)2, 1, "%s: failure write", (const void *)"send_template_ini_client_raw");

}

// send_template_raw
// file webhttpd.c line 280
static void send_template_raw(signed int client_socket, char *res)
{
  signed long int nwrite = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(res);
  nwrite=write_nonblock(client_socket, (const void *)res, return_value_strlen$1);
}

// servo_center
// file track.c line 564
static unsigned int servo_center(struct context *cnt, signed int x_offset, signed int y_offset)
{
  unsigned int ret = (unsigned int)0;
  signed int x_offset_abs;
  signed int y_offset_abs;
  if(!(cnt->track.dev >= 0))
  {
    signed int return_value_servo_open$1;
    return_value_servo_open$1=servo_open(cnt);
    if(return_value_servo_open$1 == 0)
    {
      motion_log(3, (unsigned int)7, 0, "%s: Problem opening servo!", (const void *)"servo_center");
      return (unsigned int)0;
    }

  }

  motion_log(5, (unsigned int)7, 0, "%s: X-offset %d, Y-offset %d, x-position %d. y-position %d,reversex %d, reversey %d , stepsize %d", (const void *)"servo_center", x_offset, y_offset, cnt->track.homex + (unsigned int)x_offset * cnt->track.stepsize, cnt->track.homey + (unsigned int)y_offset * cnt->track.stepsize, cnt->track.motorx_reverse, cnt->track.motory_reverse, cnt->track.stepsize);
  if(!(cnt->track.motorx_reverse == 0u))
    x_offset_abs = (signed int)((((unsigned int)128 - cnt->track.homex) - (unsigned int)x_offset * cnt->track.stepsize) + (unsigned int)128);

  else
    x_offset_abs = (signed int)(cnt->track.homex + (unsigned int)x_offset * cnt->track.stepsize);
  if(cnt->track.maxx >= x_offset_abs)
  {
    if(x_offset_abs >= cnt->track.minx)
    {
      servo_command(cnt, cnt->track.motorx, (unsigned int)7, cnt->track.speed);
      ret=servo_command(cnt, cnt->track.motorx, (unsigned int)8, (unsigned int)x_offset_abs);
    }

  }

  if(!(cnt->track.motory_reverse == 0u))
    y_offset_abs = (signed int)((((unsigned int)128 - cnt->track.homey) - (unsigned int)y_offset * cnt->track.stepsize) + (unsigned int)128);

  else
    y_offset_abs = (signed int)(cnt->track.homey + (unsigned int)y_offset * cnt->track.stepsize);
  if(cnt->track.maxy >= y_offset_abs)
  {
    if(y_offset_abs >= cnt->track.minx)
    {
      servo_command(cnt, cnt->track.motory, (unsigned int)7, cnt->track.speed);
      ret=servo_command(cnt, cnt->track.motory, (unsigned int)8, (unsigned int)y_offset_abs);
    }

  }

  return cnt->track.move_wait;
}

// servo_command
// file track.c line 327
static unsigned int servo_command(struct context *cnt, unsigned int motor, unsigned int command, unsigned int data)
{
  unsigned char buffer[3l];
  signed long int timeout;
  timeout=time((signed long int *)(void *)0);
  buffer[(signed long int)0] = (unsigned char)motor;
  buffer[(signed long int)1] = (unsigned char)command;
  buffer[(signed long int)2] = (unsigned char)data;
  motion_log(5, (unsigned int)7, 0, "%s: SENDS port %s dev fd %i, motor %hu command %hu data %hu", (const void *)"servo_command", cnt->track.port, cnt->track.dev, buffer[(signed long int)0], buffer[(signed long int)1], buffer[(signed long int)2]);
  signed long int return_value_write$1;
  return_value_write$1=write(cnt->track.dev, (const void *)buffer, (unsigned long int)3);
  signed long int return_value_read$2;
  signed long int return_value_time$3;
  if(!(return_value_write$1 == 3l))
  {
    motion_log(5, (unsigned int)7, 0, "%s: port %s dev fd %i, motor %hu command %hu data %hu", (const void *)"servo_command", cnt->track.port, cnt->track.dev, motor, command, data);
    return (unsigned int)0;
  }

  else
  {
    do
    {
      return_value_read$2=read(cnt->track.dev, (void *)buffer, (unsigned long int)1);
      if(return_value_read$2 == 1l)
        break;

      return_value_time$3=time((signed long int *)(void *)0);
      if(return_value_time$3 >= 1l + timeout)
        break;

    }
    while((_Bool)1);
    signed long int return_value_time$4;
    return_value_time$4=time((signed long int *)(void *)0);
    if(return_value_time$4 >= 2l + timeout)
    {
      motion_log(3, (unsigned int)7, 0, "%s: Status byte timeout!", (const void *)"servo_command");
      return (unsigned int)0;
    }

    else
    {
      motion_log(5, (unsigned int)7, 0, "%s: Command return %d", (const void *)"servo_command", buffer[(signed long int)0]);
      return (unsigned int)buffer[(signed long int)0];
    }
  }
}

// servo_move
// file track.c line 376
static unsigned int servo_move(struct context *cnt, struct coord *cent, struct images *imgs, unsigned int manual)
{
  unsigned int command = (unsigned int)0;
  unsigned int data = (unsigned int)0;
  unsigned int position;
  if(!(cnt->track.dev >= 0))
  {
    unsigned int return_value_servo_center$1;
    return_value_servo_center$1=servo_center(cnt, 0, 0);
    if(return_value_servo_center$1 == 0u)
    {
      motion_log(3, (unsigned int)7, 0, "%s: Problem opening servo!", (const void *)"servo_move");
      return (unsigned int)0;
    }

  }

  motion_log(5, (unsigned int)7, 0, "%s: cent->x %d, cent->y %d, reversex %d,reversey %d manual %d", (const void *)"servo_move", cent->x, cent->y, cnt->track.motorx_reverse, cnt->track.motory_reverse, manual);
  if(!(manual == 0u))
  {
    signed int offset;
    if(!(cent->x == 0))
    {
      position=servo_position(cnt, cnt->track.motorx);
      offset = (signed int)((unsigned int)cent->x * cnt->track.stepsize);
      _Bool tmp_if_expr$2;
      if(offset >= 1 && !(cnt->track.motorx_reverse == 0u))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (!(cnt->track.motorx_reverse != 0u) ? (offset < 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        command = (unsigned int)1;

      else
        command = (unsigned int)2;
      signed int return_value_abs$3;
      return_value_abs$3=abs(offset);
      data = (unsigned int)return_value_abs$3;
      _Bool tmp_if_expr$4;
      if(!((unsigned int)cnt->track.maxx >= data + position))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = position - (unsigned int)offset < (unsigned int)cnt->track.minx ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        motion_log(3, (unsigned int)7, 0, "%s: x %d value out of range! (%d - %d)", (const void *)"servo_move", data, cnt->track.minx, cnt->track.maxx);
        return (unsigned int)0;
      }

      servo_command(cnt, cnt->track.motorx, (unsigned int)7, cnt->track.speed);
      servo_command(cnt, cnt->track.motorx, command, data);
    }

    if(!(cent->y == 0))
    {
      position=servo_position(cnt, cnt->track.motory);
      offset = (signed int)((unsigned int)cent->y * cnt->track.stepsize);
      _Bool tmp_if_expr$5;
      if(offset >= 1 && !(cnt->track.motory_reverse == 0u))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (!(cnt->track.motory_reverse != 0u) ? (offset < 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        command = (unsigned int)1;

      else
        command = (unsigned int)2;
      signed int return_value_abs$6;
      return_value_abs$6=abs(offset);
      data = (unsigned int)return_value_abs$6;
      _Bool tmp_if_expr$7;
      if(!((unsigned int)cnt->track.maxy >= data + position))
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = position - (unsigned int)offset < (unsigned int)cnt->track.miny ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        motion_log(3, (unsigned int)7, 0, "%s: y %d value out of range! (%d - %d)", (const void *)"servo_move", data, cnt->track.miny, cnt->track.maxy);
        return (unsigned int)0;
      }

      servo_command(cnt, cnt->track.motory, (unsigned int)7, cnt->track.speed);
      servo_command(cnt, cnt->track.motory, command, data);
    }

  }

  else
  {
    if(!(cent->x >= imgs->width / 2))
    {
      if(!(cnt->track.motorx_reverse == 0u))
        command = (unsigned int)2;

      else
        command = (unsigned int)1;
      data = (unsigned int)(imgs->width / 2 - cent->x);
    }

    if(!(imgs->width / 2 >= cent->x))
    {
      if(!(cnt->track.motorx_reverse == 0u))
        command = (unsigned int)1;

      else
        command = (unsigned int)2;
      data = (unsigned int)(cent->x - imgs->width / 2);
    }

    motion_log(5, (unsigned int)7, 0, "%s: X offset %d", (const void *)"servo_move", data);
    data = (data * cnt->track.stepsize) / (unsigned int)imgs->width;
    if(!(command == 0u) && !(data == 0u))
    {
      position=servo_position(cnt, cnt->track.motorx);
      _Bool tmp_if_expr$8;
      if(!((unsigned int)cnt->track.maxx >= data + position))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = position - data < (unsigned int)cnt->track.minx ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
      {
        motion_log(3, (unsigned int)7, 0, "%s: x %d value out of range! (%d - %d)", (const void *)"servo_move", data, cnt->track.minx, cnt->track.maxx);
        return (unsigned int)0;
      }

      servo_command(cnt, cnt->track.motorx, (unsigned int)7, cnt->track.speed);
      servo_command(cnt, cnt->track.motorx, command, data);
      motion_log(5, (unsigned int)7, 0, "%s: X cent->x %d, cent->y %d, reversex %d,reversey %d motorx %d data %d command %d", (const void *)"servo_move", cent->x, cent->y, cnt->track.motorx_reverse, cnt->track.motory_reverse, cnt->track.motorx, data, command);
    }

    if(!(cent->y >= imgs->height / 2))
    {
      if(!(cnt->track.motory_reverse == 0u))
        command = (unsigned int)1;

      else
        command = (unsigned int)2;
      data = (unsigned int)(imgs->height / 2 - cent->y);
    }

    if(!(imgs->height / 2 >= cent->y))
    {
      if(!(cnt->track.motory_reverse == 0u))
        command = (unsigned int)2;

      else
        command = (unsigned int)1;
      data = (unsigned int)(cent->y - imgs->height / 2);
    }

    motion_log(5, (unsigned int)7, 0, "%s: Y offset %d", (const void *)"servo_move", data);
    data = (data * cnt->track.stepsize) / (unsigned int)imgs->height;
    if(!(command == 0u) && !(data == 0u))
    {
      position=servo_position(cnt, cnt->track.motory);
      _Bool tmp_if_expr$9;
      if(!((unsigned int)cnt->track.maxy >= data + position))
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = position - data < (unsigned int)cnt->track.miny ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        motion_log(3, (unsigned int)7, 0, "%s: y %d value out of range! (%d - %d)", (const void *)"servo_move", data, cnt->track.miny, cnt->track.maxy);
        return (unsigned int)0;
      }

      servo_command(cnt, cnt->track.motory, (unsigned int)7, cnt->track.speed);
      servo_command(cnt, cnt->track.motory, command, data);
      motion_log(5, (unsigned int)7, 0, "%s: Y cent->x %d, cent->y %d, reversex %d,reversey %d motory %d data %d command %d", (const void *)"servo_move", cent->x, cent->y, cnt->track.motorx_reverse, cnt->track.motory_reverse, cnt->track.motory, command);
    }

  }
  return cnt->track.move_wait;
}

// servo_open
// file track.c line 294
static signed int servo_open(struct context *cnt)
{
  struct termios adtio;
  cnt->track.dev=open(cnt->track.port, 02 | 0400);
  if(!(cnt->track.dev >= 0))
  {
    motion_log(3, (unsigned int)7, 1, "%s: Unable to open serial device %s", (const void *)"servo_open", cnt->track.port);
    return 0;
  }

  else
  {
    bzero((void *)&adtio, sizeof(struct termios) /*60ul*/ );
    adtio.c_cflag = (unsigned int)(0000015 | 0000060 | 0004000 | 0000200);
    adtio.c_iflag = (unsigned int)0000004;
    adtio.c_oflag = (unsigned int)0;
    adtio.c_lflag = (unsigned int)0;
    adtio.c_cc[(signed long int)5] = (unsigned char)0;
    adtio.c_cc[(signed long int)6] = (unsigned char)0;
    tcflush(cnt->track.dev, 0);
    signed int return_value_tcsetattr$1;
    return_value_tcsetattr$1=tcsetattr(cnt->track.dev, 0, &adtio);
    if(!(return_value_tcsetattr$1 >= 0))
    {
      motion_log(3, (unsigned int)7, 0, "%s: Unable to initialize serial device %s", (const void *)"servo_open", cnt->track.port);
      cnt->track.dev = -1;
      return 0;
    }

    else
    {
      motion_log(5, (unsigned int)7, 0, "%s: Opened serial device %s and initialize, fd %i", (const void *)"servo_open", cnt->track.port, cnt->track.dev);
      return 1;
    }
  }
}

// servo_position
// file track.c line 361
static unsigned int servo_position(struct context *cnt, unsigned int motor)
{
  unsigned int ret = (unsigned int)0;
  ret=servo_command(cnt, motor, (unsigned int)9, (unsigned int)0);
  return ret;
}

// set_log_level
// file logger.h line 58
void set_log_level(unsigned int level)
{
  log_level = level;
}

// set_log_mode
// file logger.h line 59
void set_log_mode(signed int mode)
{
  log_mode = mode;
}

// set_log_type
// file logger.h line 56
void set_log_type(unsigned int type)
{
  log_type = type;
}

// set_logfile
// file logger.h line 60
struct _IO_FILE * set_logfile(const char *logfile_name)
{
  log_mode = 1;
  logfile=myfopen(logfile_name, "a", (unsigned long int)0);
  if(!(logfile == ((struct _IO_FILE *)NULL)))
    log_mode = 0;

  return logfile;
}

// set_sock_timeout
// file stream.c line 49
static signed int set_sock_timeout(signed int sock, signed int sec)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)sec;
  tv.tv_usec = (signed long int)0;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 20, (const void *)(char *)&tv, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  if(!(return_value_setsockopt$1 == 0))
  {
    motion_log(3, (unsigned int)2, 1, "%s: set socket timeout failed", (const void *)"set_sock_timeout");
    return 1;
  }

  else
    return 0;
}

// setup_signals
// file motion.c line 2531
static void setup_signals(struct sigaction *sig_handler_action, struct sigaction *sigchild_action)
{
  sigchild_action->sa_flags = 2;
  sigchild_action->__sigaction_handler.sa_handler = sigchild_handler;
  sigemptyset(&sigchild_action->sa_mask);
  sig_handler_action->sa_flags = 0x10000000;
  sig_handler_action->__sigaction_handler.sa_handler = sig_handler;
  sigemptyset(&sig_handler_action->sa_mask);
  sigaction(17, sigchild_action, (struct sigaction *)(void *)0);
  sigaction(13, sigchild_action, (struct sigaction *)(void *)0);
  sigaction(14, sig_handler_action, (struct sigaction *)(void *)0);
  sigaction(1, sig_handler_action, (struct sigaction *)(void *)0);
  sigaction(2, sig_handler_action, (struct sigaction *)(void *)0);
  sigaction(3, sig_handler_action, (struct sigaction *)(void *)0);
  sigaction(15, sig_handler_action, (struct sigaction *)(void *)0);
  sigaction(10, sig_handler_action, (struct sigaction *)(void *)0);
}

// sig_handler
// file motion.c line 294
static void sig_handler(signed int signo)
{
  signed int i;
  switch(signo)
  {
    case 14:
    {
      if(!(cnt_list == ((struct context **)NULL)))
      {
        i = -1;
        do
        {
          i = i + 1;
          if(cnt_list[(signed long int)i] == ((struct context *)NULL))
            break;

          if(!(cnt_list[(signed long int)i]->conf.snapshot_interval == 0))
            cnt_list[(signed long int)i]->snapshot = (volatile unsigned int)1;

        }
        while((_Bool)1);
      }

      break;
    }
    case 10:
    {
      if(!(cnt_list == ((struct context **)NULL)))
      {
        i = -1;
        do
        {
          i = i + 1;
          if(cnt_list[(signed long int)i] == ((struct context *)NULL))
            break;

          cnt_list[(signed long int)i]->makemovie = (volatile unsigned int)1;
        }
        while((_Bool)1);
      }

      break;
    }
    case 1:
      restart = (unsigned int)1;
    case 2:

    case 3:

    case 15:
    {
      if(!(cnt_list == ((struct context **)NULL)))
      {
        i = -1;
        do
        {
          i = i + 1;
          if(cnt_list[(signed long int)i] == ((struct context *)NULL))
            break;

          cnt_list[(signed long int)i]->makemovie = (volatile unsigned int)1;
          cnt_list[(signed long int)i]->finish = (volatile unsigned int)1;
          cnt_list[(signed long int)i]->restart = (volatile unsigned int)0;
        }
        while((_Bool)1);
      }

      finish = (volatile unsigned int)1;
      break;
    }
    case 11:
      exit(0);
  }
}

// sigchild_handler
// file motion.c line 367
static void sigchild_handler(signed int signo)
{
  signed int return_value_waitpid$1;
  do
  {
    return_value_waitpid$1=waitpid(-1, (signed int *)(void *)0, 1);
    if(!(return_value_waitpid$1 >= 1))
      break;

  }
  while((_Bool)1);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// skip_input_data
// file jpegutils.c line 99
static void skip_input_data(struct jpeg_decompress_struct *cinfo, signed long int num_bytes)
{
  if(num_bytes >= 1l)
  {
    if(!((signed long int)cinfo->src->bytes_in_buffer >= num_bytes))
      num_bytes = (signed long int)cinfo->src->bytes_in_buffer;

    cinfo->src->next_input_byte = cinfo->src->next_input_byte + (signed long int)(unsigned long int)num_bytes;
    cinfo->src->bytes_in_buffer = cinfo->src->bytes_in_buffer - (unsigned long int)num_bytes;
  }

}

// skip_lws
// file netcam_wget.c line 201
signed int skip_lws(const char *string)
{
  const char *p = string;
  for( ; (_Bool)1; p = p + 1l)
    if(!((signed int)*p == 32))
    {
      if(!((signed int)*p == 9))
      {
        if(!((signed int)*p == 13))
        {
          if(!((signed int)*p == 10))
            goto __CPROVER_DUMP_L3;

        }

      }

    }


__CPROVER_DUMP_L3:
  ;
  return (signed int)(p - string);
}

// sonix_decompress
// file video.h line 97
signed int sonix_decompress(unsigned char *outp, unsigned char *inp, signed int width, signed int height)
{
  signed int row;
  signed int col;
  signed int val;
  signed int bitpos;
  unsigned char code;
  unsigned char *addr;
  static struct anonymous$39 table[256l];
  static signed int init_done = 0;
  if(init_done == 0)
  {
    init_done = 1;
    sonix_decompress_init(table);
  }

  bitpos = 0;
  row = 0;
  for( ; !(row >= height); row = row + 1)
  {
    col = 0;
    if(!(row >= 2))
    {
      addr = inp + (signed long int)(bitpos >> 3);
      code = (unsigned char)((signed int)addr[(signed long int)0] << (bitpos & 7) | (signed int)addr[(signed long int)1] >> 8 - (bitpos & 7));
      bitpos = bitpos + 8;
      unsigned char *tmp_post$1 = outp;
      outp = outp + 1l;
      *tmp_post$1 = code;
      addr = inp + (signed long int)(bitpos >> 3);
      code = (unsigned char)((signed int)addr[(signed long int)0] << (bitpos & 7) | (signed int)addr[(signed long int)1] >> 8 - (bitpos & 7));
      bitpos = bitpos + 8;
      unsigned char *tmp_post$2 = outp;
      outp = outp + 1l;
      *tmp_post$2 = code;
      col = col + 2;
    }

    for( ; !(col >= width); col = col + 1)
    {
      addr = inp + (signed long int)(bitpos >> 3);
      code = (unsigned char)((signed int)addr[(signed long int)0] << (bitpos & 7) | (signed int)addr[(signed long int)1] >> 8 - (bitpos & 7));
      bitpos = bitpos + table[(signed long int)code].len;
      val = table[(signed long int)code].val;
      if(table[(signed long int)code].is_abs == 0)
      {
        if(!(col >= 2))
          val = val + (signed int)outp[(signed long int)(-2 * width)];

        else
          if(!(row >= 2))
            val = val + (signed int)outp[(signed long int)-2];

          else
            val = val + ((signed int)outp[(signed long int)-2] + (signed int)outp[(signed long int)(-2 * width)]) / 2;
      }

      unsigned char *tmp_post$3 = outp;
      outp = outp + 1l;
      *tmp_post$3 = (unsigned char)(val < 0 ? 0 : (val > 255 ? 255 : val));
    }
  }
  return 0;
}

// sonix_decompress_init
// file video_common.c line 37
static void sonix_decompress_init(struct anonymous$39 *table)
{
  signed int i;
  signed int is_abs;
  signed int val;
  signed int len;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    is_abs = 0;
    val = 0;
    len = 0;
    if((0x80 & i) == 0)
    {
      val = 0;
      len = 1;
    }

    else
      if((0xE0 & i) == 0x80)
      {
        val = +4;
        len = 3;
      }

      else
        if((0xE0 & i) == 0xA0)
        {
          val = -4;
          len = 3;
        }

        else
          if((0xF0 & i) == 0xD0)
          {
            val = +11;
            len = 4;
          }

          else
            if((0xF0 & i) == 0xF0)
            {
              val = -11;
              len = 4;
            }

            else
              if((0xF8 & i) == 0xC8)
              {
                val = +20;
                len = 5;
              }

              else
                if((0xFC & i) == 0xC0)
                {
                  val = -20;
                  len = 6;
                }

                else
                  if((0xFC & i) == 0xC4)
                  {
                    val = 0;
                    len = 8;
                  }

                  else
                    if((0xF0 & i) == 0xE0)
                    {
                      is_abs = 1;
                      val = (i & 0x0F) << 4;
                      len = 8;
                    }

    (table + (signed long int)i)->is_abs = is_abs;
    (table + (signed long int)i)->val = val;
    (table + (signed long int)i)->len = len;
  }
}

// start_motion_thread
// file motion.c line 2571
static void start_motion_thread(struct context *cnt, union pthread_attr_t *thread_attr)
{
  signed int i;
  if(!(cnt->conf.stream_port == 0))
  {
    if((*cnt_list)->conf.webcontrol_port == cnt->conf.stream_port)
    {
      motion_log(3, (unsigned int)9, 0, "%s: Stream port number %d for thread %d conflicts with the control port", (const void *)"start_motion_thread", cnt->conf.stream_port, cnt->threadnr);
      motion_log(4, (unsigned int)9, 0, "%s: Stream feature for thread %d is disabled.", (const void *)"start_motion_thread", cnt->threadnr);
      cnt->conf.stream_port = 0;
    }

    i = 1;
    for( ; !(cnt_list[(signed long int)i] == ((struct context *)NULL)); i = i + 1)
      if(!(cnt_list[(signed long int)i] == cnt))
      {
        if(cnt_list[(signed long int)i]->conf.stream_port == cnt->conf.stream_port)
        {
          motion_log(3, (unsigned int)9, 0, "%s: Stream port number %d for thread %d conflicts with thread %d", (const void *)"start_motion_thread", cnt->conf.stream_port, cnt->threadnr, cnt_list[(signed long int)i]->threadnr);
          motion_log(4, (unsigned int)9, 0, "%s: Stream feature for thread %d is disabled.", (const void *)"start_motion_thread", cnt->threadnr);
          cnt->conf.stream_port = 0;
        }

      }

  }

  pthread_mutex_lock(&global_lock);
  threads_running = threads_running + 1;
  pthread_mutex_unlock(&global_lock);
  cnt->restart = (volatile unsigned int)1;
  cnt->watchdog = 30;
  pthread_create(&cnt->thread_id, thread_attr, motion_loop, (void *)cnt);
}

// std_huff_tables
// file jpegutils.c line 336
static void std_huff_tables(struct jpeg_decompress_struct *dinfo)
{
  static const unsigned char val_dc_luminance[12l] = { (const unsigned char)0, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4, (const unsigned char)5, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11 };
  static const unsigned char bits_dc_luminance[17l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)1, (const unsigned char)5, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  add_huff_table(dinfo, &dinfo->dc_huff_tbl_ptrs[(signed long int)0], bits_dc_luminance, val_dc_luminance);
  static const unsigned char val_ac_luminance[162l] = { (const unsigned char)0x01, (const unsigned char)0x02, (const unsigned char)0x03, (const unsigned char)0x00, (const unsigned char)0x04, (const unsigned char)0x11, (const unsigned char)0x05, (const unsigned char)0x12, (const unsigned char)0x21, (const unsigned char)0x31, (const unsigned char)0x41, (const unsigned char)0x06, (const unsigned char)0x13, (const unsigned char)0x51, (const unsigned char)0x61, (const unsigned char)0x07, (const unsigned char)0x22, (const unsigned char)0x71, (const unsigned char)0x14, (const unsigned char)0x32, (const unsigned char)0x81, (const unsigned char)0x91, (const unsigned char)0xa1, (const unsigned char)0x08, (const unsigned char)0x23, (const unsigned char)0x42, (const unsigned char)0xb1, (const unsigned char)0xc1, (const unsigned char)0x15, (const unsigned char)0x52, (const unsigned char)0xd1, (const unsigned char)0xf0, (const unsigned char)0x24, (const unsigned char)0x33, (const unsigned char)0x62, (const unsigned char)0x72, (const unsigned char)0x82, (const unsigned char)0x09, (const unsigned char)0x0a, (const unsigned char)0x16, (const unsigned char)0x17, (const unsigned char)0x18, (const unsigned char)0x19, (const unsigned char)0x1a, (const unsigned char)0x25, (const unsigned char)0x26, (const unsigned char)0x27, (const unsigned char)0x28, (const unsigned char)0x29, (const unsigned char)0x2a, (const unsigned char)0x34, (const unsigned char)0x35, (const unsigned char)0x36, (const unsigned char)0x37, (const unsigned char)0x38, (const unsigned char)0x39, (const unsigned char)0x3a, (const unsigned char)0x43, (const unsigned char)0x44, (const unsigned char)0x45, (const unsigned char)0x46, (const unsigned char)0x47, (const unsigned char)0x48, (const unsigned char)0x49, (const unsigned char)0x4a, (const unsigned char)0x53, (const unsigned char)0x54, (const unsigned char)0x55, (const unsigned char)0x56, (const unsigned char)0x57, (const unsigned char)0x58, (const unsigned char)0x59, (const unsigned char)0x5a, (const unsigned char)0x63, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x66, (const unsigned char)0x67, (const unsigned char)0x68, (const unsigned char)0x69, (const unsigned char)0x6a, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x75, (const unsigned char)0x76, (const unsigned char)0x77, (const unsigned char)0x78, (const unsigned char)0x79, (const unsigned char)0x7a, (const unsigned char)0x83, (const unsigned char)0x84, (const unsigned char)0x85, (const unsigned char)0x86, (const unsigned char)0x87, (const unsigned char)0x88, (const unsigned char)0x89, (const unsigned char)0x8a, (const unsigned char)0x92, (const unsigned char)0x93, (const unsigned char)0x94, (const unsigned char)0x95, (const unsigned char)0x96, (const unsigned char)0x97, (const unsigned char)0x98, (const unsigned char)0x99, (const unsigned char)0x9a, (const unsigned char)0xa2, (const unsigned char)0xa3, (const unsigned char)0xa4, (const unsigned char)0xa5, (const unsigned char)0xa6, (const unsigned char)0xa7, (const unsigned char)0xa8, (const unsigned char)0xa9, (const unsigned char)0xaa, (const unsigned char)0xb2, (const unsigned char)0xb3, (const unsigned char)0xb4, (const unsigned char)0xb5, (const unsigned char)0xb6, (const unsigned char)0xb7, (const unsigned char)0xb8, (const unsigned char)0xb9, (const unsigned char)0xba, (const unsigned char)0xc2, (const unsigned char)0xc3, (const unsigned char)0xc4, (const unsigned char)0xc5, (const unsigned char)0xc6, (const unsigned char)0xc7, (const unsigned char)0xc8, (const unsigned char)0xc9, (const unsigned char)0xca, (const unsigned char)0xd2, (const unsigned char)0xd3, (const unsigned char)0xd4, (const unsigned char)0xd5, (const unsigned char)0xd6, (const unsigned char)0xd7, (const unsigned char)0xd8, (const unsigned char)0xd9, (const unsigned char)0xda, (const unsigned char)0xe1, (const unsigned char)0xe2, (const unsigned char)0xe3, (const unsigned char)0xe4, (const unsigned char)0xe5, (const unsigned char)0xe6, (const unsigned char)0xe7, (const unsigned char)0xe8, (const unsigned char)0xe9, (const unsigned char)0xea, (const unsigned char)0xf1, (const unsigned char)0xf2, (const unsigned char)0xf3, (const unsigned char)0xf4, (const unsigned char)0xf5, (const unsigned char)0xf6, (const unsigned char)0xf7, (const unsigned char)0xf8, (const unsigned char)0xf9, (const unsigned char)0xfa };
  static const unsigned char bits_ac_luminance[17l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)2, (const unsigned char)1, (const unsigned char)3, (const unsigned char)3, (const unsigned char)2, (const unsigned char)4, (const unsigned char)3, (const unsigned char)5, (const unsigned char)5, (const unsigned char)4, (const unsigned char)4, (const unsigned char)0, (const unsigned char)0, (const unsigned char)1, (const unsigned char)0x7d };
  add_huff_table(dinfo, &dinfo->ac_huff_tbl_ptrs[(signed long int)0], bits_ac_luminance, val_ac_luminance);
  static const unsigned char val_dc_chrominance[12l] = { (const unsigned char)0, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4, (const unsigned char)5, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11 };
  static const unsigned char bits_dc_chrominance[17l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)3, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  add_huff_table(dinfo, &dinfo->dc_huff_tbl_ptrs[(signed long int)1], bits_dc_chrominance, val_dc_chrominance);
  static const unsigned char val_ac_chrominance[162l] = { (const unsigned char)0x00, (const unsigned char)0x01, (const unsigned char)0x02, (const unsigned char)0x03, (const unsigned char)0x11, (const unsigned char)0x04, (const unsigned char)0x05, (const unsigned char)0x21, (const unsigned char)0x31, (const unsigned char)0x06, (const unsigned char)0x12, (const unsigned char)0x41, (const unsigned char)0x51, (const unsigned char)0x07, (const unsigned char)0x61, (const unsigned char)0x71, (const unsigned char)0x13, (const unsigned char)0x22, (const unsigned char)0x32, (const unsigned char)0x81, (const unsigned char)0x08, (const unsigned char)0x14, (const unsigned char)0x42, (const unsigned char)0x91, (const unsigned char)0xa1, (const unsigned char)0xb1, (const unsigned char)0xc1, (const unsigned char)0x09, (const unsigned char)0x23, (const unsigned char)0x33, (const unsigned char)0x52, (const unsigned char)0xf0, (const unsigned char)0x15, (const unsigned char)0x62, (const unsigned char)0x72, (const unsigned char)0xd1, (const unsigned char)0x0a, (const unsigned char)0x16, (const unsigned char)0x24, (const unsigned char)0x34, (const unsigned char)0xe1, (const unsigned char)0x25, (const unsigned char)0xf1, (const unsigned char)0x17, (const unsigned char)0x18, (const unsigned char)0x19, (const unsigned char)0x1a, (const unsigned char)0x26, (const unsigned char)0x27, (const unsigned char)0x28, (const unsigned char)0x29, (const unsigned char)0x2a, (const unsigned char)0x35, (const unsigned char)0x36, (const unsigned char)0x37, (const unsigned char)0x38, (const unsigned char)0x39, (const unsigned char)0x3a, (const unsigned char)0x43, (const unsigned char)0x44, (const unsigned char)0x45, (const unsigned char)0x46, (const unsigned char)0x47, (const unsigned char)0x48, (const unsigned char)0x49, (const unsigned char)0x4a, (const unsigned char)0x53, (const unsigned char)0x54, (const unsigned char)0x55, (const unsigned char)0x56, (const unsigned char)0x57, (const unsigned char)0x58, (const unsigned char)0x59, (const unsigned char)0x5a, (const unsigned char)0x63, (const unsigned char)0x64, (const unsigned char)0x65, (const unsigned char)0x66, (const unsigned char)0x67, (const unsigned char)0x68, (const unsigned char)0x69, (const unsigned char)0x6a, (const unsigned char)0x73, (const unsigned char)0x74, (const unsigned char)0x75, (const unsigned char)0x76, (const unsigned char)0x77, (const unsigned char)0x78, (const unsigned char)0x79, (const unsigned char)0x7a, (const unsigned char)0x82, (const unsigned char)0x83, (const unsigned char)0x84, (const unsigned char)0x85, (const unsigned char)0x86, (const unsigned char)0x87, (const unsigned char)0x88, (const unsigned char)0x89, (const unsigned char)0x8a, (const unsigned char)0x92, (const unsigned char)0x93, (const unsigned char)0x94, (const unsigned char)0x95, (const unsigned char)0x96, (const unsigned char)0x97, (const unsigned char)0x98, (const unsigned char)0x99, (const unsigned char)0x9a, (const unsigned char)0xa2, (const unsigned char)0xa3, (const unsigned char)0xa4, (const unsigned char)0xa5, (const unsigned char)0xa6, (const unsigned char)0xa7, (const unsigned char)0xa8, (const unsigned char)0xa9, (const unsigned char)0xaa, (const unsigned char)0xb2, (const unsigned char)0xb3, (const unsigned char)0xb4, (const unsigned char)0xb5, (const unsigned char)0xb6, (const unsigned char)0xb7, (const unsigned char)0xb8, (const unsigned char)0xb9, (const unsigned char)0xba, (const unsigned char)0xc2, (const unsigned char)0xc3, (const unsigned char)0xc4, (const unsigned char)0xc5, (const unsigned char)0xc6, (const unsigned char)0xc7, (const unsigned char)0xc8, (const unsigned char)0xc9, (const unsigned char)0xca, (const unsigned char)0xd2, (const unsigned char)0xd3, (const unsigned char)0xd4, (const unsigned char)0xd5, (const unsigned char)0xd6, (const unsigned char)0xd7, (const unsigned char)0xd8, (const unsigned char)0xd9, (const unsigned char)0xda, (const unsigned char)0xe2, (const unsigned char)0xe3, (const unsigned char)0xe4, (const unsigned char)0xe5, (const unsigned char)0xe6, (const unsigned char)0xe7, (const unsigned char)0xe8, (const unsigned char)0xe9, (const unsigned char)0xea, (const unsigned char)0xf2, (const unsigned char)0xf3, (const unsigned char)0xf4, (const unsigned char)0xf5, (const unsigned char)0xf6, (const unsigned char)0xf7, (const unsigned char)0xf8, (const unsigned char)0xf9, (const unsigned char)0xfa };
  static const unsigned char bits_ac_chrominance[17l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)4, (const unsigned char)4, (const unsigned char)3, (const unsigned char)4, (const unsigned char)7, (const unsigned char)5, (const unsigned char)4, (const unsigned char)4, (const unsigned char)0, (const unsigned char)1, (const unsigned char)2, (const unsigned char)0x77 };
  add_huff_table(dinfo, &dinfo->ac_huff_tbl_ptrs[(signed long int)1], bits_ac_chrominance, val_ac_chrominance);
}

// stepper_center
// file track.c line 173
static unsigned int stepper_center(struct context *cnt, signed int x_offset, signed int y_offset)
{
  struct termios adtio;
  if(!(cnt->track.dev >= 0))
  {
    motion_log(5, (unsigned int)7, 0, "%s: Try to open serial device %s", (const void *)"stepper_center", cnt->track.port);
    cnt->track.dev=open(cnt->track.port, 02 | 0400);
    if(!(cnt->track.dev >= 0))
    {
      motion_log(3, (unsigned int)7, 1, "%s: Unable to open serial device %s", (const void *)"stepper_center", cnt->track.port);
      return (unsigned int)0;
    }

    bzero((void *)&adtio, sizeof(struct termios) /*60ul*/ );
    adtio.c_cflag = (unsigned int)(0000015 | 0000060 | 0004000 | 0000200);
    adtio.c_iflag = (unsigned int)0000004;
    adtio.c_oflag = (unsigned int)0;
    adtio.c_lflag = (unsigned int)0;
    adtio.c_cc[(signed long int)5] = (unsigned char)0;
    adtio.c_cc[(signed long int)6] = (unsigned char)0;
    tcflush(cnt->track.dev, 0);
    signed int return_value_tcsetattr$1;
    return_value_tcsetattr$1=tcsetattr(cnt->track.dev, 0, &adtio);
    if(!(return_value_tcsetattr$1 >= 0))
    {
      motion_log(3, (unsigned int)7, 1, "%s: Unable to initialize serial device %s", (const void *)"stepper_center", cnt->track.port);
      cnt->track.dev = -1;
      return (unsigned int)0;
    }

    motion_log(5, (unsigned int)7, 0, "%s: Opened serial device %s and initialize, fd %i", (const void *)"stepper_center", cnt->track.port, cnt->track.dev);
  }

  stepper_command(cnt, cnt->track.motorx, (unsigned int)7, cnt->track.speed);
  stepper_command(cnt, cnt->track.motorx, (unsigned int)1, (unsigned int)cnt->track.maxx);
  unsigned int return_value_stepper_status$2;
  do
  {
    return_value_stepper_status$2=stepper_status(cnt, cnt->track.motorx);
    if((1u & return_value_stepper_status$2) == 0u)
      break;

  }
  while((_Bool)1);
  stepper_command(cnt, cnt->track.motorx, (unsigned int)2, (unsigned int)(cnt->track.maxx / 2) + (unsigned int)x_offset * cnt->track.stepsize);
  unsigned int return_value_stepper_status$3;
  do
  {
    return_value_stepper_status$3=stepper_status(cnt, cnt->track.motorx);
    if((2u & return_value_stepper_status$3) == 0u)
      break;

  }
  while((_Bool)1);
  stepper_command(cnt, cnt->track.motory, (unsigned int)7, cnt->track.speed);
  stepper_command(cnt, cnt->track.motory, (unsigned int)1, (unsigned int)cnt->track.maxy);
  unsigned int return_value_stepper_status$4;
  do
  {
    return_value_stepper_status$4=stepper_status(cnt, cnt->track.motory);
    if((1u & return_value_stepper_status$4) == 0u)
      break;

    stepper_command(cnt, cnt->track.motory, (unsigned int)2, (unsigned int)(cnt->track.maxy / 2) + (unsigned int)y_offset * cnt->track.stepsize);
  }
  while((_Bool)1);
  unsigned int return_value_stepper_status$5;
  do
  {
    return_value_stepper_status$5=stepper_status(cnt, cnt->track.motory);
    if((2u & return_value_stepper_status$5) == 0u)
      break;

  }
  while((_Bool)1);
  return cnt->track.move_wait;
}

// stepper_command
// file track.c line 140
static unsigned int stepper_command(struct context *cnt, unsigned int motor, unsigned int command, unsigned int data)
{
  char buffer[3l];
  signed long int timeout;
  timeout=time((signed long int *)(void *)0);
  buffer[(signed long int)0] = (char)motor;
  buffer[(signed long int)1] = (char)command;
  buffer[(signed long int)2] = (char)data;
  signed long int return_value_write$1;
  return_value_write$1=write(cnt->track.dev, (const void *)buffer, (unsigned long int)3);
  signed long int return_value_read$2;
  signed long int return_value_time$3;
  if(!(return_value_write$1 == 3l))
  {
    motion_log(5, (unsigned int)7, 1, "%s: port %s dev fd %i, motor %hu command %hu data %hu", (const void *)"stepper_command", cnt->track.port, cnt->track.dev, motor, command, data);
    return (unsigned int)0;
  }

  else
  {
    do
    {
      return_value_read$2=read(cnt->track.dev, (void *)buffer, (unsigned long int)1);
      if(return_value_read$2 == 1l)
        break;

      return_value_time$3=time((signed long int *)(void *)0);
      if(return_value_time$3 >= 1l + timeout)
        break;

    }
    while((_Bool)1);
    signed long int return_value_time$4;
    return_value_time$4=time((signed long int *)(void *)0);
    if(return_value_time$4 >= 2l + timeout)
    {
      motion_log(3, (unsigned int)7, 1, "%s: Status byte timeout!", (const void *)"stepper_command");
      return (unsigned int)0;
    }

    else
      return (unsigned int)buffer[(signed long int)0];
  }
}

// stepper_move
// file track.c line 232
static unsigned int stepper_move(struct context *cnt, struct coord *cent, struct images *imgs)
{
  unsigned int command = (unsigned int)0;
  unsigned int data = (unsigned int)0;
  if(!(cnt->track.dev >= 0))
  {
    motion_log(4, (unsigned int)7, 0, "%s: No device %s started yet , trying stepper_center()", (const void *)"stepper_move", cnt->track.port);
    unsigned int return_value_stepper_center$1;
    return_value_stepper_center$1=stepper_center(cnt, 0, 0);
    if(return_value_stepper_center$1 == 0u)
    {
      motion_log(3, (unsigned int)7, 1, "%s: failed to initialize stepper device on %s , fd [%i].", (const void *)"stepper_move", cnt->track.port, cnt->track.dev);
      return (unsigned int)0;
    }

    motion_log(5, (unsigned int)7, 0, "%s: succeed , device started %s , fd [%i]", (const void *)"stepper_move", cnt->track.port, cnt->track.dev);
  }

  if(!(cent->x >= imgs->width / 2))
  {
    command = (unsigned int)1;
    data = (unsigned int)(imgs->width / 2 - cent->x);
  }

  if(!(imgs->width / 2 >= cent->x))
  {
    command = (unsigned int)2;
    data = (unsigned int)(cent->x - imgs->width / 2);
  }

  data = (data * cnt->track.stepsize) / (unsigned int)imgs->width;
  if(!(data == 0u))
    stepper_command(cnt, cnt->track.motorx, command, data);

  if(!(cent->y >= imgs->height / 2))
  {
    command = (unsigned int)1;
    data = (unsigned int)(imgs->height / 2 - cent->y);
  }

  if(!(imgs->height / 2 >= cent->y))
  {
    command = (unsigned int)2;
    data = (unsigned int)(cent->y - imgs->height / 2);
  }

  data = (data * cnt->track.stepsize) / (unsigned int)imgs->height;
  if(!(data == 0u))
    stepper_command(cnt, cnt->track.motory, command, data);

  return cnt->track.move_wait;
}

// stepper_status
// file track.c line 167
static unsigned int stepper_status(struct context *cnt, unsigned int motor)
{
  unsigned int return_value_stepper_command$1;
  return_value_stepper_command$1=stepper_command(cnt, motor, (unsigned int)0, (unsigned int)0);
  return return_value_stepper_command$1;
}

// str_time
// file logger.c line 127
static char * str_time(void)
{
  signed long int now = (signed long int)0;
  now=time(((signed long int *)NULL));
  struct tm *return_value_localtime$1;
  return_value_localtime$1=localtime(&now);
  static char buffer[16l];
  strftime(buffer, (unsigned long int)16, "%b %d %H:%M:%S", return_value_localtime$1);
  return buffer;
}

// strdupdelim
// file netcam_wget.c line 258
char * strdupdelim(const char *beg, const char *end)
{
  char *res;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc((unsigned long int)((end - beg) + (signed long int)1));
  res = (char *)return_value_mymalloc$1;
  memcpy((void *)res, (const void *)beg, (unsigned long int)(end - beg));
  res[end - beg] = (char)0;
  return res;
}

// stream_add_client
// file stream.c line 947
static void stream_add_client(struct stream *list, signed int sc)
{
  struct stream *new;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct stream) /*64ul*/ );
  new = (struct stream *)return_value_mymalloc$1;
  memset((void *)new, 0, sizeof(struct stream) /*64ul*/ );
  new->socket = sc;
  new->tmpbuffer=stream_tmpbuffer((signed int)sizeof(const char [218l]) /*218ul*/ );
  if(new->tmpbuffer == ((struct stream_buffer *)NULL))
    motion_log(3, (unsigned int)2, 1, "%s: Error creating tmpbuffer in stream_add_client", (const void *)"stream_add_client");

  else
  {
    static const char header[218l] = { 'H', 'T', 'T', 'P', '/', '1', '.', '0', ' ', '2', '0', '0', ' ', 'O', 'K', '\r', '\n', 'S', 'e', 'r', 'v', 'e', 'r', ':', ' ', 'M', 'o', 't', 'i', 'o', 'n', '/', '3', '.', '2', '.', '1', '2', '+', 'g', 'i', 't', '2', '0', '1', '4', '0', '2', '2', '8', '\r', '\n', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ':', ' ', 'c', 'l', 'o', 's', 'e', '\r', '\n', 'M', 'a', 'x', '-', 'A', 'g', 'e', ':', ' ', '0', '\r', '\n', 'E', 'x', 'p', 'i', 'r', 'e', 's', ':', ' ', '0', '\r', '\n', 'C', 'a', 'c', 'h', 'e', '-', 'C', 'o', 'n', 't', 'r', 'o', 'l', ':', ' ', 'n', 'o', '-', 'c', 'a', 'c', 'h', 'e', ',', ' ', 'p', 'r', 'i', 'v', 'a', 't', 'e', '\r', '\n', 'P', 'r', 'a', 'g', 'm', 'a', ':', ' ', 'n', 'o', '-', 'c', 'a', 'c', 'h', 'e', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'T', 'y', 'p', 'e', ':', ' ', 'm', 'u', 'l', 't', 'i', 'p', 'a', 'r', 't', '/', 'x', '-', 'm', 'i', 'x', 'e', 'd', '-', 'r', 'e', 'p', 'l', 'a', 'c', 'e', ';', ' ', 'b', 'o', 'u', 'n', 'd', 'a', 'r', 'y', '=', '-', '-', 'B', 'o', 'u', 'n', 'd', 'a', 'r', 'y', 'S', 't', 'r', 'i', 'n', 'g', '\r', '\n', '\r', '\n', 0 };
    memcpy((void *)new->tmpbuffer->ptr, (const void *)header, sizeof(const char [218l]) /*218ul*/  - (unsigned long int)1);
    new->tmpbuffer->size = (signed long int)(sizeof(const char [218l]) /*218ul*/  - (unsigned long int)1);
  }
  new->prev = list;
  new->next = list->next;
  if(!(new->next == ((struct stream *)NULL)))
    new->next->prev = new;

  list->next = new;
}

// stream_add_write
// file stream.c line 984
static void stream_add_write(struct stream *list, struct stream_buffer *tmpbuffer, unsigned int fps)
{
  struct timeval curtimeval;
  unsigned long int curtime;
  gettimeofday(&curtimeval, (struct timezone *)(void *)0);
  curtime = (unsigned long int)(curtimeval.tv_usec + 1000000L * curtimeval.tv_sec);
  while(!(list->next == ((struct stream *)NULL)))
  {
    list = list->next;
    if(list->tmpbuffer == ((struct stream_buffer *)NULL))
    {
      if(curtime + -list->last >= (unsigned long int)(1000000L / (signed long int)fps))
      {
        list->last = curtime;
        list->tmpbuffer = tmpbuffer;
        tmpbuffer->ref = tmpbuffer->ref + 1;
        list->filepos = (signed long int)0;
      }

    }

  }
  if(!(tmpbuffer->ref >= 1))
  {
    free((void *)tmpbuffer->ptr);
    free((void *)tmpbuffer);
  }

}

// stream_check_write
// file stream.c line 1019
static signed int stream_check_write(struct stream *list)
{
  while(!(list->next == ((struct stream *)NULL)))
  {
    list = list->next;
    if(list->tmpbuffer == ((struct stream_buffer *)NULL))
      return 1;

  }
  return 0;
}

// stream_flush
// file stream.c line 823
static void stream_flush(struct stream *list, signed int *stream_count, signed int lim)
{
  signed int written;
  struct stream *client;
  signed int workdone = 0;
  client = list->next;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  while(!(client == ((struct stream *)NULL)))
  {
    if(!(client->tmpbuffer == ((struct stream_buffer *)NULL)))
    {
      if(!(client->filepos >= client->tmpbuffer->size))
      {
        signed long int return_value_write$1;
        return_value_write$1=write(client->socket, (const void *)(client->tmpbuffer->ptr + client->filepos), (unsigned long int)(client->tmpbuffer->size - client->filepos));
        written = (signed int)return_value_write$1;
        if(written >= 1)
        {
          client->filepos = client->filepos + (signed long int)written;
          workdone = 1;
        }

      }

      else
        written = 0;
      _Bool tmp_if_expr$4;
      if(client->filepos >= client->tmpbuffer->size)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        if(!(written >= 0))
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 != 11 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        client->tmpbuffer->ref = client->tmpbuffer->ref - 1;
        if(!(client->tmpbuffer->ref >= 1))
        {
          free((void *)client->tmpbuffer->ptr);
          free((void *)client->tmpbuffer);
        }

        client->tmpbuffer = (struct stream_buffer *)(void *)0;
        client->nr = client->nr + 1;
      }

      _Bool tmp_if_expr$6;
      if(!(written >= 0))
      {
        return_value___errno_location$5=__errno_location();
        tmp_if_expr$6 = *return_value___errno_location$5 != 11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      _Bool tmp_if_expr$9;
      if(tmp_if_expr$6)
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        if(!(lim == 0))
          tmp_if_expr$7 = !(client->tmpbuffer != ((struct stream_buffer *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = client->nr > lim ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
      {
        void *tmp;
        close(client->socket);
        if(!(client->next == ((struct stream *)NULL)))
          client->next->prev = client->prev;

        client->prev->next = client->next;
        tmp = (void *)client;
        client = client->prev;
        free(tmp);
        *stream_count = *stream_count - 1;
      }

    }

    client = client->next;
    if(client == ((struct stream *)NULL) && !(workdone == 0))
    {
      client = list->next;
      workdone = 0;
    }

  }
}

// stream_init
// file stream.h line 41
signed int stream_init(struct context *cnt)
{
  cnt->stream.socket=http_bindsock(cnt->conf.stream_port, cnt->conf.stream_localhost, cnt->conf.ipv6_enabled);
  cnt->stream.next = (struct stream *)(void *)0;
  cnt->stream.prev = (struct stream *)(void *)0;
  return cnt->stream.socket;
}

// stream_put
// file stream.h line 42
void stream_put(struct context *cnt, unsigned char *image)
{
  struct timeval timeout;
  struct stream_buffer *tmpbuffer;
  struct anonymous$45 fdread;
  signed int sl = cnt->stream.socket;
  signed int sc;
  const char jpeghead[76l] = { '-', '-', 'B', 'o', 'u', 'n', 'd', 'a', 'r', 'y', 'S', 't', 'r', 'i', 'n', 'g', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 't', 'y', 'p', 'e', ':', ' ', 'i', 'm', 'a', 'g', 'e', '/', 'j', 'p', 'e', 'g', '\r', '\n', 'C', 'o', 'n', 't', 'e', 'n', 't', '-', 'L', 'e', 'n', 'g', 't', 'h', ':', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 0 };
  signed int headlength = (signed int)(sizeof(const char [76l]) /*76ul*/  - (unsigned long int)1);
  char len[20l];
  timeout.tv_sec = (signed long int)0;
  timeout.tv_usec = (signed long int)0;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fdread)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fdread)->fds_bits[(signed long int)(cnt->stream.socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fdread)->fds_bits[(signed long int)(cnt->stream.socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << cnt->stream.socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  if(!(cnt->stream_count >= 10))
  {
    return_value_select$1=select(sl + 1, &fdread, (struct anonymous$45 *)(void *)0, (struct anonymous$45 *)(void *)0, &timeout);
    if(return_value_select$1 >= 1)
    {
      sc=http_acceptsock(sl);
      if(cnt->conf.stream_auth_method == 0)
      {
        stream_add_client(&cnt->stream, sc);
        cnt->stream_count = cnt->stream_count + 1;
      }

      else
        do_client_auth(cnt, sc);
    }

  }

  if(!(cnt->conf.stream_auth_method == 0))
    pthread_mutex_lock(&stream_auth_mutex);

  stream_flush(&cnt->stream, &cnt->stream_count, cnt->conf.stream_limit);
  signed int return_value_stream_check_write$3;
  return_value_stream_check_write$3=stream_check_write(&cnt->stream);
  if(!(return_value_stream_check_write$3 == 0))
  {
    tmpbuffer=stream_tmpbuffer(cnt->imgs.size);
    if(!(tmpbuffer == ((struct stream_buffer *)NULL)))
    {
      signed int imgsize;
      unsigned char *wptr = tmpbuffer->ptr;
      memcpy((void *)wptr, (const void *)jpeghead, (unsigned long int)headlength);
      wptr = wptr + (signed long int)headlength;
      signed int return_value_put_picture_memory$2;
      return_value_put_picture_memory$2=put_picture_memory(cnt, wptr, cnt->imgs.size, image, cnt->conf.stream_quality);
      tmpbuffer->size = (signed long int)return_value_put_picture_memory$2;
      imgsize=sprintf(len, "%9ld\r\n\r\n", tmpbuffer->size);
      memcpy((void *)(wptr - (signed long int)imgsize), (const void *)len, (unsigned long int)imgsize);
      memcpy((void *)(wptr + tmpbuffer->size), (const void *)"\r\n", (unsigned long int)2);
      tmpbuffer->size = tmpbuffer->size + (signed long int)(headlength + 2);
      stream_add_write(&cnt->stream, tmpbuffer, (unsigned int)cnt->conf.stream_maxrate);
    }

    else
      motion_log(3, (unsigned int)2, 1, "%s: Error creating tmpbuffer", (const void *)"stream_put");
  }

  stream_flush(&cnt->stream, &cnt->stream_count, cnt->conf.stream_limit);
  if(!(cnt->conf.stream_auth_method == 0))
    pthread_mutex_unlock(&stream_auth_mutex);

  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// stream_stop
// file stream.h line 43
void stream_stop(struct context *cnt)
{
  struct stream *list;
  struct stream *next = cnt->stream.next;
  motion_log(5, (unsigned int)2, 0, "%s: Closing motion-stream listen socket & active motion-stream sockets", (const void *)"stream_stop");
  close(cnt->stream.socket);
  cnt->stream.socket = -1;
  while(!(next == ((struct stream *)NULL)))
  {
    list = next;
    next = list->next;
    if(!(list->tmpbuffer == ((struct stream_buffer *)NULL)))
    {
      free((void *)list->tmpbuffer->ptr);
      free((void *)list->tmpbuffer);
    }

    close(list->socket);
    free((void *)list);
  }
  motion_log(5, (unsigned int)2, 0, "%s: Closed motion-stream listen socket & active motion-stream sockets", (const void *)"stream_stop");
}

// stream_tmpbuffer
// file stream.c line 933
static struct stream_buffer * stream_tmpbuffer(signed int size)
{
  struct stream_buffer *tmpbuffer;
  void *return_value_mymalloc$1;
  return_value_mymalloc$1=mymalloc(sizeof(struct stream_buffer) /*24ul*/ );
  tmpbuffer = (struct stream_buffer *)return_value_mymalloc$1;
  tmpbuffer->ref = 0;
  void *return_value_mymalloc$2;
  return_value_mymalloc$2=mymalloc((unsigned long int)size);
  tmpbuffer->ptr = (unsigned char *)return_value_mymalloc$2;
  return tmpbuffer;
}

// term_destination
// file jpegutils.c line 207
static void term_destination(struct jpeg_compress_struct *cinfo)
{
  ;
}

// term_destination$link1
// file picture.c line 53
static void term_destination$link1(struct jpeg_compress_struct *cinfo$link1)
{
  struct anonymous$8 *dest = (struct anonymous$8 *)cinfo$link1->dest;
  dest->jpegsize = dest->bufsize - dest->pub.free_in_buffer;
}

// term_source
// file jpegutils.c line 114
static void term_source(struct jpeg_decompress_struct *cinfo)
{
  ;
}

// track
// file webhttpd.c line 1272
static unsigned int track(char *pointer, char *res, unsigned int length_uri, unsigned int thread, signed int client_socket, void *userdata)
{
  char question = (char)0;
  char command[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct context **cnt = (struct context **)userdata;
  warningkill=sscanf(pointer, "%255[a-z]%c", (const void *)command, &question);
  signed int return_value_strcmp$39;
  return_value_strcmp$39=strcmp(command, "set");
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$20;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$38;
  signed int return_value_strcmp$37;
  signed int return_value_strcmp$36;
  signed int return_value_strcmp$34;
  if(return_value_strcmp$39 == 0)
  {
    pointer = pointer + (signed long int)3;
    length_uri = length_uri - (unsigned int)3;
    if((signed int)question == 63 && length_uri >= 3u)
    {
      char panvalue[12l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char tiltvalue[12l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char x_value[12l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      char y_value[12l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      struct context *setcnt;
      signed int pan = 0;
      signed int tilt = 0;
      signed int X = 0;
      signed int Y = 0;
      pointer = pointer + 1l;
      length_uri = length_uri - 1u;
      warningkill=sscanf(pointer, "%255[a-z]%c", (const void *)command, &question);
      _Bool tmp_if_expr$1;
      if(!((signed int)question == 61))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)command[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 1", (const void *)"track");
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_valid_syntax, (char *)(void *)0);

        else
          response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
        return (unsigned int)1;
      }

      pointer = pointer + 1l;
      length_uri = length_uri - 1u;
      signed int return_value_strcmp$13;
      return_value_strcmp$13=strcmp(command, "pan");
      if(return_value_strcmp$13 == 0)
      {
        pointer = pointer + (signed long int)3;
        length_uri = length_uri - (unsigned int)3;
        pan = 1;
        warningkill=sscanf(pointer, "%10[-0-9]", (const void *)panvalue);
        if(!(warningkill == 0))
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(panvalue);
          pointer = pointer + (signed long int)return_value_strlen$2;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(panvalue);
          length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$3);
        }

      }

      else
      {
        return_value_strcmp$12=strcmp(command, "tilt");
        if(return_value_strcmp$12 == 0)
        {
          pointer = pointer + (signed long int)4;
          length_uri = length_uri - (unsigned int)4;
          tilt = 1;
          warningkill=sscanf(pointer, "%10[-0-9]", (const void *)tiltvalue);
          if(!(warningkill == 0))
          {
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(tiltvalue);
            pointer = pointer + (signed long int)return_value_strlen$4;
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(tiltvalue);
            length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$5);
          }

        }

        else
        {
          return_value_strcmp$11=strcmp(command, "x");
          if(return_value_strcmp$11 == 0)
          {
            pointer = pointer + 1l;
            length_uri = length_uri - 1u;
            X = 1;
            warningkill=sscanf(pointer, "%10[-0-9]", (const void *)x_value);
            if(!(warningkill == 0))
            {
              unsigned long int return_value_strlen$6;
              return_value_strlen$6=strlen(x_value);
              pointer = pointer + (signed long int)return_value_strlen$6;
              unsigned long int return_value_strlen$7;
              return_value_strlen$7=strlen(x_value);
              length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$7);
            }

          }

          else
          {
            return_value_strcmp$10=strcmp(command, "y");
            if(return_value_strcmp$10 == 0)
            {
              pointer = pointer + 1l;
              length_uri = length_uri - 1u;
              Y = 1;
              warningkill=sscanf(pointer, "%10[-0-9]", (const void *)y_value);
              if(!(warningkill == 0))
              {
                unsigned long int return_value_strlen$8;
                return_value_strlen$8=strlen(y_value);
                pointer = pointer + (signed long int)return_value_strlen$8;
                unsigned long int return_value_strlen$9;
                return_value_strlen$9=strlen(y_value);
                length_uri = (unsigned int)((unsigned long int)length_uri - return_value_strlen$9);
              }

            }

            else
            {
              motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 2", (const void *)"track");
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_valid_syntax, (char *)(void *)0);

              else
                response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
              return (unsigned int)1;
            }
          }
        }
      }
      if(warningkill == 0)
      {
        motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 3", (const void *)"track");
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, error_value, (char *)(void *)0);

        else
          response_client(client_socket, error_value_raw, (char *)(void *)0);
        return (unsigned int)1;
      }

      if(length_uri == 0u)
      {
        if(!(pan == 0))
        {
          struct coord track$$1$$1$$1$$8$$1$$cent;
          struct context *pancnt = cnt[(signed long int)thread];
          track$$1$$1$$1$$8$$1$$cent.width = pancnt->imgs.width;
          track$$1$$1$$1$$8$$1$$cent.height = pancnt->imgs.height;
          track$$1$$1$$1$$8$$1$$cent.y = 0;
          track$$1$$1$$1$$8$$1$$cent.x=atoi(panvalue);
          cnt[(signed long int)thread]->moved=track_move(pancnt, pancnt->video_dev, &track$$1$$1$$1$$8$$1$$cent, &pancnt->imgs, (unsigned int)1);
          if(!(cnt[(signed long int)thread]->moved == 0u))
          {
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack set relative pan=%s<br>\n", thread, thread, (const void *)panvalue);
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              sprintf(res, "track set relative pan=%s\nDone\n", (const void *)panvalue);
              send_template_raw(client_socket, res);
            }
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
              response_client(client_socket, track_error, res);
            }

            else
              response_client(client_socket, track_error_raw, (char *)(void *)0);
        }

        else
          if(!(tilt == 0))
          {
            struct coord track$$1$$1$$1$$8$$2$$cent;
            struct context *tiltcnt = cnt[(signed long int)thread];
            track$$1$$1$$1$$8$$2$$cent.width = tiltcnt->imgs.width;
            track$$1$$1$$1$$8$$2$$cent.height = tiltcnt->imgs.height;
            track$$1$$1$$1$$8$$2$$cent.x = 0;
            track$$1$$1$$1$$8$$2$$cent.y=atoi(tiltvalue);
            cnt[(signed long int)thread]->moved=track_move(tiltcnt, tiltcnt->video_dev, &track$$1$$1$$1$$8$$2$$cent, &tiltcnt->imgs, (unsigned int)1);
            if(!(cnt[(signed long int)thread]->moved == 0u))
            {
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack set relative tilt=%s\n", thread, thread, (const void *)tiltvalue);
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "track set relative tilt=%s\nDone\n", (const void *)tiltvalue);
                send_template_raw(client_socket, res);
              }
            }

            else
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
                response_client(client_socket, track_error, res);
              }

              else
                response_client(client_socket, track_error_raw, (char *)(void *)0);
          }

          else
            if(!(X == 0))
            {
              setcnt = cnt[(signed long int)thread];
              signed int return_value_atoi$14;
              return_value_atoi$14=atoi(x_value);
              cnt[(signed long int)thread]->moved=track_center(setcnt, setcnt->video_dev, (unsigned int)1, return_value_atoi$14, 1000);
              if(!(cnt[(signed long int)thread]->moved == 0u))
              {
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  send_template_ini_client(client_socket, ini_template);
                  sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack set absolute x=%s\n", thread, thread, (const void *)x_value);
                  send_template(client_socket, res);
                  send_template_end_client(client_socket);
                }

                else
                {
                  send_template_ini_client_raw(client_socket);
                  sprintf(res, "track set absolute x=%s\nDone\n", (const void *)x_value);
                  send_template_raw(client_socket, res);
                }
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
                  response_client(client_socket, track_error, res);
                }

                else
                  response_client(client_socket, track_error_raw, (char *)(void *)0);
            }

            else
            {
              setcnt = cnt[(signed long int)thread];
              signed int return_value_atoi$15;
              return_value_atoi$15=atoi(y_value);
              cnt[(signed long int)thread]->moved=track_center(setcnt, setcnt->video_dev, (unsigned int)1, 1000, return_value_atoi$15);
              if(!(cnt[(signed long int)thread]->moved == 0u))
              {
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  send_template_ini_client(client_socket, ini_template);
                  sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack set absolute y=%s<br>\n", thread, thread, (const void *)y_value);
                  send_template(client_socket, res);
                  send_template_end_client(client_socket);
                }

                else
                {
                  send_template_ini_client_raw(client_socket);
                  sprintf(res, "track set absolute y=%s\nDone\n", (const void *)y_value);
                  send_template_raw(client_socket, res);
                }
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                {
                  sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
                  response_client(client_socket, track_error, res);
                }

                else
                  response_client(client_socket, track_error_raw, (char *)(void *)0);
            }
        return (unsigned int)1;
      }

      warningkill=sscanf(pointer, "%c%255[a-z]", &question, (const void *)command);
      _Bool tmp_if_expr$17;
      if(!((signed int)question == 38))
        tmp_if_expr$17 = (_Bool)1;

      else
        tmp_if_expr$17 = (signed int)command[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$17)
      {
        motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 4", (const void *)"track");
        char *return_value_strstr$16;
        return_value_strstr$16=strstr(pointer, "&");
        if(!(return_value_strstr$16 == ((char *)NULL)))
        {
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, error_value, (char *)(void *)0);

          else
            response_client(client_socket, error_value_raw, (char *)(void *)0);
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_valid_syntax, (char *)(void *)0);

          else
            response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
        return (unsigned int)1;
      }

      pointer = pointer + 1l;
      length_uri = length_uri - 1u;
      signed int return_value_strcmp$21;
      return_value_strcmp$21=strcmp(command, "pan");
      if(return_value_strcmp$21 == 0)
      {
        pointer = pointer + (signed long int)3;
        length_uri = length_uri - (unsigned int)3;
        if(tilt == 0 || !(X == 0) || !(Y == 0) || !(pan == 0))
        {
          motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 5", (const void *)"track");
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_valid_syntax, (char *)(void *)0);

          else
            response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
          return (unsigned int)1;
        }

        pan = 2;
        warningkill=sscanf(pointer, "%c%10[-0-9]", &question, (const void *)panvalue);
      }

      else
      {
        return_value_strcmp$20=strcmp(command, "tilt");
        if(return_value_strcmp$20 == 0)
        {
          pointer = pointer + (signed long int)4;
          length_uri = length_uri - (unsigned int)4;
          if(pan == 0 || !(X == 0) || !(Y == 0) || !(tilt == 0))
          {
            motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 6", (const void *)"track");
            if(!((*cnt)->conf.webcontrol_html_output == 0))
              response_client(client_socket, not_valid_syntax, (char *)(void *)0);

            else
              response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
            return (unsigned int)1;
          }

          tilt = 2;
          warningkill=sscanf(pointer, "%c%10[-0-9]", &question, (const void *)tiltvalue);
        }

        else
        {
          return_value_strcmp$19=strcmp(command, "x");
          if(return_value_strcmp$19 == 0)
          {
            pointer = pointer + 1l;
            length_uri = length_uri - 1u;
            if(Y == 0 || !(X == 0) || !(pan == 0) || !(tilt == 0))
            {
              motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 7", (const void *)"track");
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_valid_syntax, (char *)(void *)0);

              else
                response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
              return (unsigned int)1;
            }

            X = 2;
            warningkill=sscanf(pointer, "%c%10[-0-9]", &question, (const void *)x_value);
          }

          else
          {
            return_value_strcmp$18=strcmp(command, "y");
            if(return_value_strcmp$18 == 0)
            {
              pointer = pointer + 1l;
              length_uri = length_uri - 1u;
              if(X == 0 || !(Y == 0) || !(pan == 0) || !(tilt == 0))
              {
                motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 8", (const void *)"track");
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                  response_client(client_socket, not_valid_syntax, (char *)(void *)0);

                else
                  response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
                return (unsigned int)1;
              }

              Y = 2;
              warningkill=sscanf(pointer, "%c%10[-0-9]", &question, (const void *)y_value);
            }

            else
            {
              motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 9", (const void *)"track");
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_valid_syntax, (char *)(void *)0);

              else
                response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
              return (unsigned int)1;
            }
          }
        }
      }
      if(!((signed int)question == 61) && !(warningkill >= 2))
      {
        motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 10", (const void *)"track");
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_valid_syntax, (char *)(void *)0);

        else
          response_client(client_socket, not_valid_syntax_raw, (char *)(void *)0);
        return (unsigned int)1;
      }

      else
        if(warningkill == 1 && (signed int)question == 61)
        {
          motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 11", (const void *)"track");
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, error_value, (char *)(void *)0);

          else
            response_client(client_socket, error_value_raw, (char *)(void *)0);
          return (unsigned int)1;
        }

      if(pan == 2)
      {
        unsigned long int return_value_strlen$22;
        return_value_strlen$22=strlen(panvalue);
        pointer = pointer + (signed long int)return_value_strlen$22 + (signed long int)1;
        unsigned long int return_value_strlen$23;
        return_value_strlen$23=strlen(panvalue);
        length_uri = (unsigned int)(((unsigned long int)length_uri - return_value_strlen$23) - (unsigned long int)1);
      }

      else
        if(tilt == 2)
        {
          unsigned long int return_value_strlen$24;
          return_value_strlen$24=strlen(tiltvalue);
          pointer = pointer + (signed long int)return_value_strlen$24 + (signed long int)1;
          unsigned long int return_value_strlen$25;
          return_value_strlen$25=strlen(tiltvalue);
          length_uri = (unsigned int)(((unsigned long int)length_uri - return_value_strlen$25) - (unsigned long int)1);
        }

        else
          if(X == 2)
          {
            unsigned long int return_value_strlen$26;
            return_value_strlen$26=strlen(x_value);
            pointer = pointer + (signed long int)return_value_strlen$26 + (signed long int)1;
            unsigned long int return_value_strlen$27;
            return_value_strlen$27=strlen(x_value);
            length_uri = (unsigned int)(((unsigned long int)length_uri - return_value_strlen$27) - (unsigned long int)1);
          }

          else
          {
            unsigned long int return_value_strlen$28;
            return_value_strlen$28=strlen(y_value);
            pointer = pointer + (signed long int)return_value_strlen$28 + (signed long int)1;
            unsigned long int return_value_strlen$29;
            return_value_strlen$29=strlen(y_value);
            length_uri = (unsigned int)(((unsigned long int)length_uri - return_value_strlen$29) - (unsigned long int)1);
          }
      if(!(length_uri == 0u))
      {
        motion_log(6, (unsigned int)2, 0, "%s: httpd debug race 12", (const void *)"track");
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, error_value, (char *)(void *)0);

        else
          response_client(client_socket, error_value_raw, (char *)(void *)0);
        return (unsigned int)1;
      }

      if(!(X == 0) && !(Y == 0))
      {
        setcnt = cnt[(signed long int)thread];
        signed int return_value_atoi$30;
        return_value_atoi$30=atoi(x_value);
        signed int return_value_atoi$31;
        return_value_atoi$31=atoi(y_value);
        cnt[(signed long int)thread]->moved=track_center(setcnt, setcnt->video_dev, (unsigned int)1, return_value_atoi$30, return_value_atoi$31);
        if(!(cnt[(signed long int)thread]->moved == 0u))
        {
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            send_template_ini_client(client_socket, ini_template);
            sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack absolute set x=%s y=%s<br>\n", thread, thread, (const void *)x_value, (const void *)y_value);
            send_template(client_socket, res);
            send_template_end_client(client_socket);
          }

          else
          {
            send_template_ini_client_raw(client_socket);
            sprintf(res, "track absolute set x=%s y=%s\nDone\n", (const void *)x_value, (const void *)y_value);
            send_template_raw(client_socket, res);
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
            response_client(client_socket, track_error, res);
          }

          else
            response_client(client_socket, track_error_raw, (char *)(void *)0);
      }

      else
      {
        struct coord cent;
        struct context *relativecnt = cnt[(signed long int)thread];
        cent.width = relativecnt->imgs.width;
        cent.height = relativecnt->imgs.height;
        cent.y = 0;
        cent.x=atoi(panvalue);
        cnt[(signed long int)thread]->moved=track_move(relativecnt, relativecnt->video_dev, &cent, &relativecnt->imgs, (unsigned int)1);
        if(!(cnt[(signed long int)thread]->moved == 0u))
        {
          relativecnt = cnt[(signed long int)thread];
          cent.width = relativecnt->imgs.width;
          cent.height = relativecnt->imgs.height;
          cent.x = 0;
          cent.y=atoi(tiltvalue);
          cnt[(signed long int)thread]->moved=track_move(relativecnt, relativecnt->video_dev, &cent, &relativecnt->imgs, (unsigned int)1);
          if(!(cnt[(signed long int)thread]->moved == 0u))
          {
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              send_template_ini_client(client_socket, ini_template);
              sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>\ntrack relative pan=%s tilt=%s\n", thread, thread, (const void *)panvalue, (const void *)tiltvalue);
              send_template(client_socket, res);
              send_template_end_client(client_socket);
            }

            else
            {
              send_template_ini_client_raw(client_socket);
              sprintf(res, "track relative pan=%s tilt=%s\nDone\n", (const void *)panvalue, (const void *)tiltvalue);
              send_template_raw(client_socket, res);
            }
            return (unsigned int)1;
          }

          else
            if(!((*cnt)->conf.webcontrol_html_output == 0))
            {
              sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
              response_client(client_socket, track_error, res);
            }

            else
              response_client(client_socket, track_error_raw, (char *)(void *)0);
        }

        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b>\n", thread, thread);
          response_client(client_socket, track_error, res);
        }

        else
          response_client(client_socket, track_error_raw, (char *)(void *)0);
      }
    }

    else
      if(length_uri == 0u)
      {
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          send_template_ini_client(client_socket, ini_template);
          sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>\n<form action='set'>\nPan<input type=text name='pan' value=''>\nTilt<input type=text name='tilt' value=''>\n<input type=submit value='set relative'>\n</form>\n<form action='set'>\nX<input type=text name='x' value=''>\nY<input type=text name='y' value=''>\n<input type=submit value='set absolute'>\n</form>\n", thread, thread);
          send_template(client_socket, res);
          send_template_end_client(client_socket);
        }

        else
        {
          send_template_ini_client_raw(client_socket);
          sprintf(res, "set needs a pan/tilt or x/y values\n");
          send_template_raw(client_socket, res);
        }
      }

      else
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

        else
          response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
  }

  else
  {
    return_value_strcmp$38=strcmp(command, "center");
    if(return_value_strcmp$38 == 0)
    {
      pointer = pointer + (signed long int)6;
      length_uri = length_uri - (unsigned int)6;
      if(length_uri == 0u)
      {
        struct context *track$$1$$2$$1$$setcnt = cnt[(signed long int)thread];
        cnt[(signed long int)thread]->moved=track_center(track$$1$$2$$1$$setcnt, track$$1$$2$$1$$setcnt->video_dev, (unsigned int)1, 0, 0);
        if(!((*cnt)->conf.webcontrol_html_output == 0))
        {
          send_template_ini_client(client_socket, ini_template);
          sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>track set center", thread, thread);
          send_template(client_socket, res);
          send_template_end_client(client_socket);
        }

        else
        {
          sprintf(res, "Thread %hu\n track set center\nDone\n", thread);
          send_template_ini_client_raw(client_socket);
          send_template_raw(client_socket, res);
        }
      }

      else
        if(!((*cnt)->conf.webcontrol_html_output == 0))
          response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

        else
          response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
    }

    else
    {
      return_value_strcmp$37=strcmp(command, "status");
      if(return_value_strcmp$37 == 0)
      {
        pointer = pointer + (signed long int)6;
        length_uri = length_uri - (unsigned int)6;
        if(length_uri == 0u)
        {
          if(!((*cnt)->conf.webcontrol_html_output == 0))
          {
            send_template_ini_client(client_socket, ini_template);
            sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b><br>track auto %s", thread, thread, cnt[(signed long int)thread]->track.active != 0u ? "enabled" : "disabled");
            send_template(client_socket, res);
            send_template_end_client(client_socket);
          }

          else
          {
            sprintf(res, "Thread %hu\n track auto %s\nDone\n", thread, cnt[(signed long int)thread]->track.active != 0u ? "enabled" : "disabled");
            send_template_ini_client_raw(client_socket);
            send_template_raw(client_socket, res);
          }
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }

      else
      {
        return_value_strcmp$36=strcmp(command, "auto");
        if(return_value_strcmp$36 == 0)
        {
          pointer = pointer + (signed long int)4;
          length_uri = length_uri - (unsigned int)4;
          if((signed int)question == 63 && length_uri >= 1u)
          {
            char query[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            pointer = pointer + 1l;
            length_uri = length_uri - 1u;
            warningkill=sscanf(pointer, "%255[a-z]%c", (const void *)query, &question);
            _Bool tmp_if_expr$35;
            if((signed int)question == 61)
            {
              return_value_strcmp$34=strcmp(query, "value");
              tmp_if_expr$35 = !(return_value_strcmp$34 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$35 = (_Bool)0;
            if(tmp_if_expr$35)
            {
              pointer = pointer + (signed long int)6;
              length_uri = length_uri - (unsigned int)6;
              warningkill=sscanf(pointer, "%255[-0-9a-z]", (const void *)command);
              unsigned long int return_value_strlen$33;
              return_value_strlen$33=strlen(command);
              if(return_value_strlen$33 >= 1ul)
              {
                struct context *autocnt;
                signed int return_value_strcmp$32;
                return_value_strcmp$32=strcmp(command, "status");
                if(return_value_strcmp$32 == 0)
                {
                  if(!((*cnt)->conf.webcontrol_html_output == 0))
                  {
                    send_template_ini_client(client_socket, ini_template);
                    sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>track auto %s", thread, thread, cnt[(signed long int)thread]->track.active != 0u ? "enabled" : "disabled");
                    send_template(client_socket, res);
                    send_template_end_client(client_socket);
                  }

                  else
                  {
                    sprintf(res, "Thread %hu\n track auto %s\nDone\n", thread, cnt[(signed long int)thread]->track.active != 0u ? "enabled" : "disabled");
                    send_template_ini_client_raw(client_socket);
                    send_template_raw(client_socket, res);
                  }
                }

                else
                {
                  signed int active;
                  active=atoi(command);
                  if(active >= 0 && !(active >= 2))
                  {
                    autocnt = cnt[(signed long int)thread];
                    autocnt->track.active = (unsigned int)active;
                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                    {
                      send_template_ini_client(client_socket, ini_template);
                      sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br><b>Thread %hu</b><br>track auto %s<br>", thread, thread, active != 0 ? "enabled" : "disabled");
                      send_template(client_socket, res);
                      send_template_end_client(client_socket);
                    }

                    else
                    {
                      send_template_ini_client_raw(client_socket);
                      sprintf(res, "track auto %s\nDone\n", active != 0 ? "enabled" : "disabled");
                      send_template_raw(client_socket, res);
                    }
                  }

                  else
                    if(!((*cnt)->conf.webcontrol_html_output == 0))
                      response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                    else
                      response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
                }
              }

              else
                if(!((*cnt)->conf.webcontrol_html_output == 0))
                  response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

                else
                  response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
            }

            else
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

              else
                response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
          }

          else
            if(length_uri == 0u)
            {
              if(!((*cnt)->conf.webcontrol_html_output == 0))
              {
                send_template_ini_client(client_socket, ini_template);
                sprintf(res, "<a href=/%hu/track>&lt;&ndash; back</a><br><br>\n<b>Thread %hu</b>\n<form action='auto'><select name='value'>\n<option value='0' %s>Disable</option><option value='1' %s>Enable</option>\n<option value='status'>status</option>\n</select><input type=submit value='set'>\n</form>\n", thread, thread, cnt[(signed long int)thread]->track.active != 0u ? "selected" : "", cnt[(signed long int)thread]->track.active != 0u ? "selected" : "");
                send_template(client_socket, res);
                send_template_end_client(client_socket);
              }

              else
              {
                send_template_ini_client_raw(client_socket);
                sprintf(res, "auto accepts only 0,1 or status as valid value\n");
                send_template_raw(client_socket, res);
              }
            }

            else
              if(!((*cnt)->conf.webcontrol_html_output == 0))
                response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

              else
                response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
        }

        else
          if(!((*cnt)->conf.webcontrol_html_output == 0))
            response_client(client_socket, not_found_response_valid_command, (char *)(void *)0);

          else
            response_client(client_socket, not_found_response_valid_command_raw, (char *)(void *)0);
      }
    }
  }
  return (unsigned int)1;
}

// track_center
// file track.h line 45
unsigned int track_center(struct context *cnt, signed int dev, unsigned int manual, signed int xoff, signed int yoff)
{
  unsigned int return_value_iomojo_center$2;
  if(manual == 0u)
  {
    if(!(cnt->track.active == 0u))
      goto __CPROVER_DUMP_L1;

    return (unsigned int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(cnt->track.type == 1u)
    {
      unsigned int ret;
      ret=stepper_center(cnt, xoff, yoff);
      if(ret == 0u)
      {
        motion_log(3, (unsigned int)7, 1, "%s: internal error", (const void *)"track_center");
        return (unsigned int)0;
      }

      else
        return ret;
    }

    else
      if(cnt->track.type == 6u)
      {
        unsigned int return_value_servo_center$1;
        return_value_servo_center$1=servo_center(cnt, xoff, yoff);
        return return_value_servo_center$1;
      }

      else
        if(cnt->track.type == 2u)
        {
          return_value_iomojo_center$2=iomojo_center(cnt, xoff, yoff);
          return return_value_iomojo_center$2;
        }

        else
          if(cnt->track.type == 4u)
            return (unsigned int)10;

    motion_log(3, (unsigned int)7, 1, "%s: internal error, %hu is not a known track-type", (const void *)"track_center", cnt->track.type);
    return (unsigned int)0;
  }
}

// track_move
// file track.h line 46
unsigned int track_move(struct context *cnt, signed int dev, struct coord *cent, struct images *imgs, unsigned int manual)
{
  unsigned int return_value_stepper_move$1;
  unsigned int return_value_servo_move$2;
  unsigned int return_value_iomojo_move$3;
  if(manual == 0u)
  {
    if(!(cnt->track.active == 0u))
      goto __CPROVER_DUMP_L1;

    return (unsigned int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(cnt->track.type == 1u)
    {
      return_value_stepper_move$1=stepper_move(cnt, cent, imgs);
      return return_value_stepper_move$1;
    }

    else
      if(cnt->track.type == 6u)
      {
        return_value_servo_move$2=servo_move(cnt, cent, imgs, manual);
        return return_value_servo_move$2;
      }

      else
        if(cnt->track.type == 2u)
        {
          return_value_iomojo_move$3=iomojo_move(cnt, dev, cent, imgs);
          return return_value_iomojo_move$3;
        }

        else
          if(cnt->track.type == 4u)
            return cnt->track.move_wait;

    motion_log(4, (unsigned int)7, 1, "%s: internal error, %hu is not a known track-type", (const void *)"track_move", cnt->track.type);
    return (unsigned int)0;
  }
}

// url_decode
// file webhttpd.c line 347
static void url_decode(char *urlencoded, unsigned long int length)
{
  char *data = urlencoded;
  char *urldecoded = urlencoded;
  for( ; length >= 1ul; length = length - 1ul)
  {
    if((signed int)*data == 37)
    {
      char c[3l];
      signed int i;
      data = data + 1l;
      length = length - 1ul;
      char *tmp_post$1 = data;
      data = data + 1l;
      c[(signed long int)0] = *tmp_post$1;
      length = length - 1ul;
      c[(signed long int)1] = *data;
      c[(signed long int)2] = (char)0;
      warningkill=sscanf(c, "%x", &i);
      if(!(i >= 128))
      {
        char *tmp_post$2 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$2 = (char)i;
      }

      else
      {
        char *tmp_post$3 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$3 = (char)37;
        char *tmp_post$4 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$4 = c[(signed long int)0];
        char *tmp_post$5 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$5 = c[(signed long int)1];
      }
    }

    else
      if((signed int)*data == 43)
      {
        char *tmp_post$6 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$6 = (char)32;
      }

      else
      {
        char *tmp_post$7 = urldecoded;
        urldecoded = urldecoded + 1l;
        *tmp_post$7 = *data;
      }
    data = data + 1l;
  }
  *urldecoded = (char)0;
}

// usage
// file conf.c line 2355
static void usage(void)
{
  printf("motion Version 3.2.12+git20140228, Copyright 2000-2005 Jeroen Vreeken/Folkert van Heusden/Kenneth Lavrsen\n");
  printf("\nusage:\tmotion [options]\n");
  printf("\n\n");
  printf("Possible options:\n\n");
  printf("-n\t\t\tRun in non-daemon mode.\n");
  printf("-s\t\t\tRun in setup mode.\n");
  printf("-c config\t\tFull path and filename of config file.\n");
  printf("-d level\t\tLog level (1-9) (EMR, ALR, CRT, ERR, WRN, NTC, ERR, DBG, ALL). default: 6 / NTC.\n");
  printf("-k type\t\t\tType of log (COR, STR, ENC, NET, DBL, EVT, TRK, VID, ALL). default: ALL.\n");
  printf("-p process_id_file\tFull path and filename of process id file (pid file).\n");
  printf("-l log file \t\tFull path and filename of log file.\n");
  printf("-m\t\t\tDisable motion detection at startup.\n");
  printf("-h\t\t\tShow this screen.\n");
  printf("\n");
  printf("Motion is configured using a config file only. If none is supplied,\n");
  printf("it will read motion.conf from current directory, ~/.motion or %s/motion.\n", (const void *)"/etc");
  printf("\n");
}

// v4l2_cleanup
// file video2.c line 1090
void v4l2_cleanup(struct video_dev *viddev)
{
  struct anonymous$29 *vid_source = (struct anonymous$29 *)viddev->v4l2_private;
  if(!(vid_source->buffers == ((struct video_image_buff *)NULL)))
  {
    unsigned int i = (unsigned int)0;
    for( ; !(i >= vid_source->req.count); i = i + 1u)
      munmap((void *)(vid_source->buffers + (signed long int)i)->ptr, (vid_source->buffers + (signed long int)i)->size);
    free((void *)vid_source->buffers);
    vid_source->buffers = (struct video_image_buff *)(void *)0;
  }

  if(!(vid_source->controls == ((struct v4l2_queryctrl *)NULL)))
  {
    free((void *)vid_source->controls);
    vid_source->controls = (struct v4l2_queryctrl *)(void *)0;
  }

  free((void *)vid_source);
  viddev->v4l2_private = (void *)0;
}

// v4l2_close
// file video2.c line 1076
void v4l2_close(struct video_dev *viddev)
{
  struct anonymous$29 *vid_source = (struct anonymous$29 *)viddev->v4l2_private;
  enum v4l2_buf_type type = (enum v4l2_buf_type)V4L2_BUF_TYPE_VIDEO_CAPTURE;
  xioctl(vid_source->fd, (signed int)((unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(19 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8), (void *)&type);
  close(vid_source->fd);
  vid_source->fd = -1;
}

// v4l2_do_set_pix_format
// file video2.c line 394
static signed int v4l2_do_set_pix_format(unsigned int pixformat, struct anonymous$29 *vid_source, signed int *width, signed int *height)
{
  memset((void *)&vid_source->dst_fmt, 0, sizeof(struct v4l2_format) /*208ul*/ );
  vid_source->dst_fmt.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
  vid_source->dst_fmt.fmt.pix.width = (unsigned int)*width;
  vid_source->dst_fmt.fmt.pix.height = (unsigned int)*height;
  vid_source->dst_fmt.fmt.pix.pixelformat = pixformat;
  vid_source->dst_fmt.fmt.pix.field = (unsigned int)0;
  signed int return_value_xioctl$3;
  return_value_xioctl$3=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(64 << 0)) | sizeof(struct v4l2_format) /*208ul*/  << 0 + 8 + 8), (void *)&vid_source->dst_fmt);
  if(!(return_value_xioctl$3 == -1))
  {
    if(vid_source->dst_fmt.fmt.pix.pixelformat == pixformat)
    {
      motion_log(5, (unsigned int)8, 0, "%s: Testing palette %c%c%c%c (%dx%d)", (const void *)"v4l2_do_set_pix_format", pixformat >> 0, pixformat >> 8, pixformat >> 16, pixformat >> 24, *width, *height);
      _Bool tmp_if_expr$1;
      if(!(vid_source->dst_fmt.fmt.pix.width == (unsigned int)*width))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = vid_source->dst_fmt.fmt.pix.height != (unsigned int)*height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        motion_log(4, (unsigned int)8, 0, "%s: Adjusting resolution from %ix%i to %ix%i.", (const void *)"v4l2_do_set_pix_format", *width, *height, vid_source->dst_fmt.fmt.pix.width, vid_source->dst_fmt.fmt.pix.height);
        *width = (signed int)vid_source->dst_fmt.fmt.pix.width;
        *height = (signed int)vid_source->dst_fmt.fmt.pix.height;
      }

      signed int return_value_xioctl$2;
      return_value_xioctl$2=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(5 << 0)) | sizeof(struct v4l2_format) /*208ul*/  << 0 + 8 + 8), (void *)&vid_source->dst_fmt);
      if(return_value_xioctl$2 == -1)
      {
        motion_log(3, (unsigned int)8, 1, "%s: Error setting pixel format.\nVIDIOC_S_FMT: ", (const void *)"v4l2_do_set_pix_format");
        return -1;
      }

      motion_log(5, (unsigned int)8, 0, "%s: Using palette %c%c%c%c (%dx%d) bytesperlines %d sizeimage %d colorspace %08x", (const void *)"v4l2_do_set_pix_format", pixformat >> 0, pixformat >> 8, pixformat >> 16, pixformat >> 24, *width, *height, vid_source->dst_fmt.fmt.pix.bytesperline, vid_source->dst_fmt.fmt.pix.sizeimage, vid_source->dst_fmt.fmt.pix.colorspace);
      return 0;
    }

  }

  return -1;
}

// v4l2_get_capability
// file video2.c line 196
static signed int v4l2_get_capability(struct anonymous$29 *vid_source)
{
  signed int return_value_xioctl$1;
  return_value_xioctl$1=xioctl(vid_source->fd, (signed int)((unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(0 << 0)) | sizeof(struct v4l2_capability) /*104ul*/  << 0 + 8 + 8), (void *)&vid_source->cap);
  if(!(return_value_xioctl$1 >= 0))
  {
    motion_log(3, (unsigned int)8, 0, "%s: Not a V4L2 device?", (const void *)"v4l2_get_capability");
    return -1;
  }

  else
  {
    motion_log(5, (unsigned int)8, 0, "%s: \n------------------------\ncap.driver: \"%s\"\ncap.card: \"%s\"\ncap.bus_info: \"%s\"\ncap.capabilities=0x%08X\n------------------------", (const void *)"v4l2_get_capability", (const void *)vid_source->cap.driver, (const void *)vid_source->cap.card, (const void *)vid_source->cap.bus_info, vid_source->cap.capabilities);
    if(!((1u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - VIDEO_CAPTURE", (const void *)"v4l2_get_capability");

    if(!((2u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - VIDEO_OUTPUT", (const void *)"v4l2_get_capability");

    if(!((4u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - VIDEO_OVERLAY", (const void *)"v4l2_get_capability");

    if(!((16u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - VBI_CAPTURE", (const void *)"v4l2_get_capability");

    if(!((32u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - VBI_OUTPUT", (const void *)"v4l2_get_capability");

    if(!((256u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - RDS_CAPTURE", (const void *)"v4l2_get_capability");

    if(!((65536u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - TUNER", (const void *)"v4l2_get_capability");

    if(!((131072u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - AUDIO", (const void *)"v4l2_get_capability");

    if(!((16777216u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - READWRITE", (const void *)"v4l2_get_capability");

    if(!((33554432u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - ASYNCIO", (const void *)"v4l2_get_capability");

    if(!((67108864u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - STREAMING", (const void *)"v4l2_get_capability");

    if(!((4096u & vid_source->cap.capabilities) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - TIMEPERFRAME", (const void *)"v4l2_get_capability");

    if((1u & vid_source->cap.capabilities) == 0u)
    {
      motion_log(3, (unsigned int)8, 0, "%s: Device does not support capturing.", (const void *)"v4l2_get_capability");
      return -1;
    }

    else
      return 0;
  }
}

// v4l2_next
// file video2.c line 943
signed int v4l2_next(struct context *cnt, struct video_dev *viddev, unsigned char *map, signed int width, signed int height)
{
  struct anonymous$16 set;
  struct anonymous$16 old;
  struct anonymous$29 *vid_source = (struct anonymous$29 *)viddev->v4l2_private;
  signed int *return_value___errno_location$2;
  if(!(viddev->v4l_fmt == 15))
    return -1;

  else
  {
    sigemptyset(&set);
    sigaddset(&set, 17);
    sigaddset(&set, 14);
    sigaddset(&set, 10);
    sigaddset(&set, 15);
    sigaddset(&set, 1);
    pthread_sigmask(0, &set, &old);
    motion_log(7, (unsigned int)8, 0, "%s: 1) vid_source->pframe %i", (const void *)"v4l2_next", vid_source->pframe);
    if(vid_source->pframe >= 0)
    {
      signed int return_value_xioctl$1;
      return_value_xioctl$1=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(15 << 0)) | sizeof(struct v4l2_buffer) /*88ul*/  << 0 + 8 + 8), (void *)&vid_source->buf);
      if(return_value_xioctl$1 == -1)
      {
        motion_log(3, (unsigned int)8, 1, "%s: VIDIOC_QBUF", (const void *)"v4l2_next");
        pthread_sigmask(1, &old, (struct anonymous$16 *)(void *)0);
        return -1;
      }

    }

    memset((void *)&vid_source->buf, 0, sizeof(struct v4l2_buffer) /*88ul*/ );
    vid_source->buf.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
    vid_source->buf.memory = (unsigned int)1;
    signed int return_value_xioctl$4;
    return_value_xioctl$4=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(17 << 0)) | sizeof(struct v4l2_buffer) /*88ul*/  << 0 + 8 + 8), (void *)&vid_source->buf);
    if(return_value_xioctl$4 == -1)
    {
      signed int ret;
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 5)
      {
        vid_source->pframe = vid_source->pframe + 1;
        if((unsigned int)vid_source->pframe >= vid_source->req.count)
          vid_source->pframe = 0;

        vid_source->buf.index = (unsigned int)vid_source->pframe;
        motion_log(3, (unsigned int)8, 1, "%s: VIDIOC_DQBUF: EIO (vid_source->pframe %d)", (const void *)"v4l2_next", vid_source->pframe);
        ret = 1;
      }

      else
      {
        return_value___errno_location$2=__errno_location();
        if(*return_value___errno_location$2 == 11)
        {
          motion_log(3, (unsigned int)8, 1, "%s: VIDIOC_DQBUF: EAGAIN (vid_source->pframe %d)", (const void *)"v4l2_next", vid_source->pframe);
          ret = 1;
        }

        else
        {
          motion_log(3, (unsigned int)8, 1, "%s: VIDIOC_DQBUF", (const void *)"v4l2_next");
          ret = -1;
        }
      }
      pthread_sigmask(1, &old, (struct anonymous$16 *)(void *)0);
      return ret;
    }

    motion_log(7, (unsigned int)8, 0, "%s: 2) vid_source->pframe %i", (const void *)"v4l2_next", vid_source->pframe);
    vid_source->pframe = (signed int)vid_source->buf.index;
    (vid_source->buffers + (signed long int)vid_source->buf.index)->used = (unsigned long int)vid_source->buf.bytesused;
    (vid_source->buffers + (signed long int)vid_source->buf.index)->content_length = (signed int)vid_source->buf.bytesused;
    motion_log(7, (unsigned int)8, 0, "%s: 3) vid_source->pframe %i vid_source->buf.index %i", (const void *)"v4l2_next", vid_source->pframe, vid_source->buf.index);
    motion_log(7, (unsigned int)8, 0, "%s: vid_source->buf.bytesused %i", (const void *)"v4l2_next", vid_source->buf.bytesused);
    pthread_sigmask(1, &old, (struct anonymous$16 *)(void *)0);
    struct video_image_buff *the_buffer = &vid_source->buffers[(signed long int)vid_source->buf.index];
    motion_log(7, (unsigned int)8, 0, "%s: the_buffer index %d Address (%x)", (const void *)"v4l2_next", vid_source->buf.index, the_buffer->ptr);
    if(!(vid_source->dst_fmt.fmt.pix.pixelformat == 859981650u))
    {
      if(vid_source->dst_fmt.fmt.pix.pixelformat == 1498831189u)
        goto __CPROVER_DUMP_L11;

      if(vid_source->dst_fmt.fmt.pix.pixelformat == 1345466932u || vid_source->dst_fmt.fmt.pix.pixelformat == 1448695129u)
        goto __CPROVER_DUMP_L12;

      if(vid_source->dst_fmt.fmt.pix.pixelformat == 842093913u)
        goto __CPROVER_DUMP_L13;

      if(vid_source->dst_fmt.fmt.pix.pixelformat == 1195724874u || vid_source->dst_fmt.fmt.pix.pixelformat == 1196444237u || vid_source->dst_fmt.fmt.pix.pixelformat == 1196444240u)
        goto __CPROVER_DUMP_L14;

      if(vid_source->dst_fmt.fmt.pix.pixelformat == 825770306u || vid_source->dst_fmt.fmt.pix.pixelformat == 844257602u || vid_source->dst_fmt.fmt.pix.pixelformat == 1195528775u || vid_source->dst_fmt.fmt.pix.pixelformat == 1196573255u)
        goto __CPROVER_DUMP_L15;

      if(vid_source->dst_fmt.fmt.pix.pixelformat == 808532307u || vid_source->dst_fmt.fmt.pix.pixelformat == 825636179u)
        goto __CPROVER_DUMP_L16;

    }

    else
    {
      conv_rgb24toyuv420p(map, the_buffer->ptr, width, height);
      return 0;

    __CPROVER_DUMP_L11:
      ;
      conv_uyvyto420p(map, the_buffer->ptr, (unsigned int)width, (unsigned int)height);
      return 0;

    __CPROVER_DUMP_L12:
      ;
      conv_yuv422to420p(map, the_buffer->ptr, width, height);
      return 0;

    __CPROVER_DUMP_L13:
      ;
      memcpy((void *)map, (const void *)the_buffer->ptr, (unsigned long int)viddev->v4l_bufsize);
      return 0;

    __CPROVER_DUMP_L14:
      ;
      signed int return_value_mjpegtoyuv420p$5;
      return_value_mjpegtoyuv420p$5=mjpegtoyuv420p(map, the_buffer->ptr, width, height, (unsigned int)(vid_source->buffers + (signed long int)vid_source->buf.index)->content_length);
      return return_value_mjpegtoyuv420p$5;

    __CPROVER_DUMP_L15:
      ;
      bayer2rgb24(cnt->imgs.common_buffer, the_buffer->ptr, (signed long int)width, (signed long int)height);
      conv_rgb24toyuv420p(map, cnt->imgs.common_buffer, width, height);
      return 0;

    __CPROVER_DUMP_L16:
      ;
      sonix_decompress(map, the_buffer->ptr, width, height);
      bayer2rgb24(cnt->imgs.common_buffer, map, (signed long int)width, (signed long int)height);
      conv_rgb24toyuv420p(map, cnt->imgs.common_buffer, width, height);
      return 0;
    }
    return 1;
  }
}

// v4l2_picture_controls
// file video2.c line 768
static void v4l2_picture_controls(struct context *cnt, struct video_dev *viddev)
{
  struct anonymous$29 *vid_source = (struct anonymous$29 *)viddev->v4l2_private;
  if(!(cnt->conf.contrast == 0))
  {
    if(!(cnt->conf.contrast == viddev->contrast))
    {
      viddev->contrast = cnt->conf.contrast;
      v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 1), viddev->contrast);
    }

  }

  if(!(cnt->conf.saturation == 0))
  {
    if(!(cnt->conf.saturation == viddev->saturation))
    {
      viddev->saturation = cnt->conf.saturation;
      v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 2), viddev->saturation);
    }

  }

  if(!(cnt->conf.hue == 0))
  {
    if(!(cnt->conf.hue == viddev->hue))
    {
      viddev->hue = cnt->conf.hue;
      v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 3), viddev->hue);
    }

  }

  if(!(cnt->conf.autobright == 0))
  {
    signed int return_value_vid_do_autobright$2;
    return_value_vid_do_autobright$2=vid_do_autobright(cnt, viddev);
    if(!(return_value_vid_do_autobright$2 == 0))
    {
      signed int return_value_v4l2_set_control$1;
      return_value_v4l2_set_control$1=v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 0), viddev->brightness);
      if(!(return_value_v4l2_set_control$1 == 0))
        v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 19), viddev->brightness);

    }

  }

  else
    if(!(cnt->conf.brightness == 0))
    {
      if(!(cnt->conf.brightness == viddev->brightness))
      {
        viddev->brightness = cnt->conf.brightness;
        signed int return_value_v4l2_set_control$3;
        return_value_v4l2_set_control$3=v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 0), viddev->brightness);
        if(!(return_value_v4l2_set_control$3 == 0))
          v4l2_set_control(vid_source, (unsigned int)((0x00980000 | 0x900) + 19), viddev->brightness);

      }

    }

}

// v4l2_scan_controls
// file video2.c line 661
static signed int v4l2_scan_controls(struct anonymous$29 *vid_source)
{
  signed int count;
  signed int i;
  struct v4l2_queryctrl queryctrl;
  memset((void *)&queryctrl, 0, sizeof(struct v4l2_queryctrl) /*68ul*/ );
  i = 0;
  count = 0;
  for( ; !(queried_ctrls[(signed long int)i] == 0u); i = i + 1)
  {
    queryctrl.id = queried_ctrls[(signed long int)i];
    signed int return_value_xioctl$1;
    return_value_xioctl$1=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(36 << 0)) | sizeof(struct v4l2_queryctrl) /*68ul*/  << 0 + 8 + 8), (void *)&queryctrl);
    if(return_value_xioctl$1 == 0)
    {
      count = count + 1;
      vid_source->ctrl_flags = vid_source->ctrl_flags | (unsigned int)(1 << i);
    }

  }
  if(!(count == 0))
  {
    struct v4l2_queryctrl *ctrl;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)count, sizeof(struct v4l2_queryctrl) /*68ul*/ );
    vid_source->controls = (struct v4l2_queryctrl *)return_value_calloc$2;
    ctrl = vid_source->controls;
    if(ctrl == ((struct v4l2_queryctrl *)NULL))
    {
      motion_log(3, (unsigned int)8, 1, "%s: Insufficient buffer memory.", (const void *)"v4l2_scan_controls");
      return -1;
    }

    i = 0;
    for( ; !(queried_ctrls[(signed long int)i] == 0u); i = i + 1)
      if(!((vid_source->ctrl_flags & (unsigned int)(1 << i)) == 0u))
      {
        struct v4l2_control control;
        queryctrl.id = queried_ctrls[(signed long int)i];
        signed int return_value_xioctl$3;
        return_value_xioctl$3=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(36 << 0)) | sizeof(struct v4l2_queryctrl) /*68ul*/  << 0 + 8 + 8), (void *)&queryctrl);
        if(return_value_xioctl$3 == 0)
        {
          memcpy((void *)ctrl, (const void *)&queryctrl, sizeof(struct v4l2_queryctrl) /*68ul*/ );
          motion_log(5, (unsigned int)8, 0, "%s: found control 0x%08x, \"%s\", range %d,%d %s", (const void *)"v4l2_scan_controls", ctrl->id, (const void *)ctrl->name, ctrl->minimum, ctrl->maximum, (ctrl->flags & (unsigned int)0x0001) != 0u ? "!DISABLED!" : "");
          memset((void *)&control, 0, sizeof(struct v4l2_control) /*8ul*/ );
          control.id = queried_ctrls[(signed long int)i];
          xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(27 << 0)) | sizeof(struct v4l2_control) /*8ul*/  << 0 + 8 + 8), (void *)&control);
          motion_log(5, (unsigned int)8, 0, "%s: \t\"%s\", default %d, current %d", (const void *)"v4l2_scan_controls", (const void *)ctrl->name, ctrl->default_value, control.value);
          ctrl = ctrl + 1l;
        }

      }

  }

  return 0;
}

// v4l2_select_input
// file video2.c line 247
static signed int v4l2_select_input(struct config *conf, struct video_dev *viddev, struct anonymous$29 *vid_source, signed int in, signed int norm, unsigned long int freq_, signed int tuner_number)
{
  struct v4l2_input input;
  struct v4l2_standard standard;
  unsigned long long int std_id;
  memset((void *)&input, 0, sizeof(struct v4l2_input) /*80ul*/ );
  if(in == -1)
    input.index = (unsigned int)0;

  else
    input.index = (unsigned int)in;
  signed int return_value_xioctl$1;
  return_value_xioctl$1=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(26 << 0)) | sizeof(struct v4l2_input) /*80ul*/  << 0 + 8 + 8), (void *)&input);
  signed int return_value_xioctl$4;
  if(return_value_xioctl$1 == -1)
  {
    motion_log(3, (unsigned int)8, 1, "%s: Unable to query input %d. VIDIOC_ENUMINPUT, if you use a WEBCAM change input value in conf by -1", (const void *)"v4l2_select_input", input.index);
    return -1;
  }

  else
  {
    motion_log(5, (unsigned int)8, 0, "%s: name = \"%s\", type 0x%08X, status %08x", (const void *)"v4l2_select_input", (const void *)input.name, input.type, input.status);
    if(!((1u & input.type) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - TUNER", (const void *)"v4l2_select_input");

    if(!((2u & input.type) == 0u))
      motion_log(5, (unsigned int)8, 0, "%s: - CAMERA", (const void *)"v4l2_select_input");

    signed int return_value_xioctl$2;
    return_value_xioctl$2=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(39 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8), (void *)&input.index);
    if(return_value_xioctl$2 == -1)
    {
      motion_log(3, (unsigned int)8, 1, "%s: Error selecting input %d VIDIOC_S_INPUT", (const void *)"v4l2_select_input", input.index);
      return -1;
    }

    else
    {
      conf->input = in;
      viddev->input = conf->input;
      signed int return_value_xioctl$3;
      return_value_xioctl$3=xioctl(vid_source->fd, (signed int)((unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(23 << 0)) | sizeof(unsigned long long int) /*8ul*/  << 0 + 8 + 8), (void *)&std_id);
      if(return_value_xioctl$3 == -1)
      {
        motion_log(4, (unsigned int)8, 0, "%s: Device doesn't support VIDIOC_G_STD", (const void *)"v4l2_select_input");
        std_id = (unsigned long long int)0;
        norm = (signed int)std_id;
      }

      if(!(std_id == 0ull))
      {
        memset((void *)&standard, 0, sizeof(struct v4l2_standard) /*72ul*/ );
        standard.index = (unsigned int)0;
        do
        {
          return_value_xioctl$4=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(25 << 0)) | sizeof(struct v4l2_standard) /*72ul*/  << 0 + 8 + 8), (void *)&standard);
          if(!(return_value_xioctl$4 == 0))
            break;

          if(!((standard.id & std_id) == 0ull))
            motion_log(5, (unsigned int)8, 0, "%s: - video standard %s", (const void *)"v4l2_select_input", (const void *)standard.name);

          standard.index = standard.index + 1u;
        }
        while((_Bool)1);
        switch(norm)
        {
          case 1:
          {
            std_id = (unsigned long long int)0x00001000 | (unsigned long long int)0x00002000 | (unsigned long long int)0x00008000;
            break;
          }
          case 2:
          {
            std_id = (unsigned long long int)0x00010000 | (unsigned long long int)0x00040000 | (unsigned long long int)0x00080000 | (unsigned long long int)0x00020000 | (unsigned long long int)0x00100000 | (unsigned long long int)0x00200000 | (unsigned long long int)0x00400000 | (unsigned long long int)0x00800000;
            break;
          }
          default:
            std_id = (unsigned long long int)0x00000001 | (unsigned long long int)0x00000002 | (unsigned long long int)0x00000004 | (unsigned long long int)0x00000020 | (unsigned long long int)0x00000040 | (unsigned long long int)0x00000080 | (unsigned long long int)0x00000008 | (unsigned long long int)0x00000010;
        }
        signed int return_value_xioctl$5;
        return_value_xioctl$5=xioctl(vid_source->fd, (signed int)((unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(24 << 0)) | sizeof(unsigned long long int) /*8ul*/  << 0 + 8 + 8), (void *)&std_id);
        if(return_value_xioctl$5 == -1)
          motion_log(3, (unsigned int)8, 1, "%s: Error selecting standard method %d VIDIOC_S_STD", (const void *)"v4l2_select_input", (signed int)std_id);

        motion_log(5, (unsigned int)8, 0, "%s: Set standard method %d", (const void *)"v4l2_select_input", (signed int)std_id);
      }

      conf->norm = norm;
      viddev->norm = conf->norm;
      if(!((1u & input.type) == 0u))
      {
        struct v4l2_tuner tuner;
        struct v4l2_frequency freq;
        memset((void *)&tuner, 0, sizeof(struct v4l2_tuner) /*84ul*/ );
        tuner.index = input.tuner;
        signed int return_value_xioctl$6;
        return_value_xioctl$6=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(29 << 0)) | sizeof(struct v4l2_tuner) /*84ul*/  << 0 + 8 + 8), (void *)&tuner);
        if(return_value_xioctl$6 == -1)
        {
          motion_log(3, (unsigned int)8, 1, "%s: tuner %d VIDIOC_G_TUNER", (const void *)"v4l2_select_input", tuner.index);
          return 0;
        }

        motion_log(5, (unsigned int)8, 0, "%s: Set tuner %d", (const void *)"v4l2_select_input", tuner.index);
        memset((void *)&freq, 0, sizeof(struct v4l2_frequency) /*44ul*/ );
        freq.tuner = input.tuner;
        freq.type = (unsigned int)2;
        freq.frequency = (unsigned int)((freq_ / (unsigned long int)1000) * (unsigned long int)16);
        signed int return_value_xioctl$7;
        return_value_xioctl$7=xioctl(vid_source->fd, (signed int)((unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(57 << 0)) | sizeof(struct v4l2_frequency) /*44ul*/  << 0 + 8 + 8), (void *)&freq);
        if(return_value_xioctl$7 == -1)
        {
          motion_log(3, (unsigned int)8, 1, "%s: freq %ul VIDIOC_S_FREQUENCY", (const void *)"v4l2_select_input", freq.frequency);
          return 0;
        }

        conf->frequency = freq_;
        viddev->freq = conf->frequency;
        motion_log(5, (unsigned int)8, 0, "%s: Set Frequency to %ul", (const void *)"v4l2_select_input", freq.frequency);
      }

      else
      {
        conf->frequency = (unsigned long int)0;
        viddev->freq = conf->frequency;
      }
      return 0;
    }
  }
}

// v4l2_set_control
// file video2.c line 718
static signed int v4l2_set_control(struct anonymous$29 *vid_source, unsigned int cid, signed int value)
{
  signed int i;
  signed int count;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(vid_source->controls == ((struct v4l2_queryctrl *)NULL))
    return -1;

  else
  {
    i = 0;
    count = 0;
    for( ; !(queried_ctrls[(signed long int)i] == 0u); i = i + 1)
      if(!((vid_source->ctrl_flags & (unsigned int)(1 << i)) == 0u))
      {
        if(cid == queried_ctrls[(signed long int)i])
        {
          struct v4l2_queryctrl *ctrl = vid_source->controls + (signed long int)count;
          struct v4l2_control control;
          signed int ret;
          memset((void *)&control, 0, sizeof(struct v4l2_control) /*8ul*/ );
          control.id = queried_ctrls[(signed long int)i];
          switch(ctrl->type)
          {
            case (unsigned int)1:
            {
              control.value = (value * (ctrl->maximum - ctrl->minimum)) / 256 + ctrl->minimum;
              value = control.value;
              ret=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(28 << 0)) | sizeof(struct v4l2_control) /*8ul*/  << 0 + 8 + 8), (void *)&control);
              break;
            }
            case (unsigned int)2:
            {
              control.value = value != 0 ? 1 : 0;
              value = control.value;
              ret=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(28 << 0)) | sizeof(struct v4l2_control) /*8ul*/  << 0 + 8 + 8), (void *)&control);
              break;
            }
            default:
            {
              motion_log(4, (unsigned int)8, 0, "%s: control type not supported yet", (const void *)"v4l2_set_control");
              return -1;
            }
          }
          char *tmp_if_expr$3;
          if(!(ret == 0))
          {
            return_value___errno_location$1=__errno_location();
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            tmp_if_expr$3 = return_value_strerror$2;
          }

          else
            tmp_if_expr$3 = "";
          motion_log(5, (unsigned int)8, 0, "%s: setting control \"%s\" to %d (ret %d %s) %s", (const void *)"v4l2_set_control", (const void *)ctrl->name, value, ret, tmp_if_expr$3, (ctrl->flags & (unsigned int)0x0001) != 0u ? "Control is DISABLED!" : "");
          return 0;
        }

        count = count + 1;
      }

    return -1;
  }
}

// v4l2_set_input
// file video2.c line 868
void v4l2_set_input(struct context *cnt, struct video_dev *viddev, unsigned char *map, signed int width, signed int height, struct config *conf)
{
  signed int input = conf->input;
  signed int norm = conf->norm;
  unsigned long int freq = conf->frequency;
  signed int tuner_number = conf->tuner_number;
  _Bool tmp_if_expr$4;
  if(!(input == viddev->input))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = width != viddev->width ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = height != viddev->height ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$5)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = freq != viddev->freq ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = tuner_number != viddev->tuner_number ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = norm != viddev->norm ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$8)
  {
    unsigned int i;
    struct timeval switchTime;
    unsigned int skip = (unsigned int)conf->roundrobin_skip;
    if(!(conf->roundrobin_skip >= 0))
      skip = (unsigned int)1;

    v4l2_select_input(conf, viddev, (struct anonymous$29 *)viddev->v4l2_private, input, norm, freq, tuner_number);
    gettimeofday(&switchTime, (struct timezone *)(void *)0);
    v4l2_picture_controls(cnt, viddev);
    viddev->width = width;
    viddev->height = height;
    struct anonymous$29 *vid_source = (struct anonymous$29 *)viddev->v4l2_private;
    unsigned int counter = (unsigned int)0;
    motion_log(5, (unsigned int)8, 0, "%s: set_input_skip_frame switch_time=%ld:%ld", (const void *)"v4l2_set_input", switchTime.tv_sec, switchTime.tv_usec);
    while(!(counter >= vid_source->req.count))
    {
      counter = counter + 1u;
      signed int return_value_v4l2_next$1;
      return_value_v4l2_next$1=v4l2_next(cnt, viddev, map, width, height);
      if(!(return_value_v4l2_next$1 == 0))
        break;

      _Bool tmp_if_expr$3;
      if(!(switchTime.tv_sec >= vid_source->buf.timestamp.tv_sec))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        if(vid_source->buf.timestamp.tv_sec == switchTime.tv_sec)
          tmp_if_expr$2 = vid_source->buf.timestamp.tv_usec > switchTime.tv_usec ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        break;

      motion_log(5, (unsigned int)8, 0, "%s: got frame before  switch timestamp=%ld:%ld", (const void *)"v4l2_set_input", vid_source->buf.timestamp.tv_sec, vid_source->buf.timestamp.tv_usec);
    }
    i = (unsigned int)1;
    for( ; !(i >= skip); i = i + 1u)
      v4l2_next(cnt, viddev, map, width, height);
  }

  else
    v4l2_picture_controls(cnt, viddev);
}

// v4l2_set_mmap
// file video2.c line 565
static signed int v4l2_set_mmap(struct anonymous$29 *vid_source)
{
  enum v4l2_buf_type type;
  unsigned int buffer_index;
  if((67108864u & vid_source->cap.capabilities) == 0u)
    return -1;

  else
  {
    memset((void *)&vid_source->req, 0, sizeof(struct v4l2_requestbuffers) /*20ul*/ );
    vid_source->req.count = (unsigned int)4;
    vid_source->req.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
    vid_source->req.memory = (unsigned int)1;
    signed int return_value_xioctl$1;
    return_value_xioctl$1=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(8 << 0)) | sizeof(struct v4l2_requestbuffers) /*20ul*/  << 0 + 8 + 8), (void *)&vid_source->req);
    if(return_value_xioctl$1 == -1)
    {
      motion_log(3, (unsigned int)8, 1, "%s: Error requesting buffers %d for memory map. VIDIOC_REQBUFS", (const void *)"v4l2_set_mmap", vid_source->req.count);
      return -1;
    }

    else
    {
      motion_log(7, (unsigned int)8, 0, "%s: mmap information: frames=%d", (const void *)"v4l2_set_mmap", vid_source->req.count);
      if(!(vid_source->req.count >= 2u))
      {
        motion_log(3, (unsigned int)8, 1, "%s: Insufficient buffer memory %d < MIN_MMAP_BUFFERS.", (const void *)"v4l2_set_mmap", vid_source->req.count);
        return -1;
      }

      else
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)vid_source->req.count, sizeof(struct video_image_buff) /*48ul*/ );
        vid_source->buffers = (struct video_image_buff *)return_value_calloc$2;
        if(vid_source->buffers == ((struct video_image_buff *)NULL))
        {
          motion_log(3, (unsigned int)8, 1, "%s: Out of memory.", (const void *)"v4l2_set_mmap");
          return -1;
        }

        else
        {
          buffer_index = (unsigned int)0;
          for( ; !(buffer_index >= vid_source->req.count); buffer_index = buffer_index + 1u)
          {
            struct v4l2_buffer buf;
            memset((void *)&buf, 0, sizeof(struct v4l2_buffer) /*88ul*/ );
            buf.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
            buf.memory = (unsigned int)1;
            buf.index = buffer_index;
            signed int return_value_xioctl$3;
            return_value_xioctl$3=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(9 << 0)) | sizeof(struct v4l2_buffer) /*88ul*/  << 0 + 8 + 8), (void *)&buf);
            if(return_value_xioctl$3 == -1)
            {
              motion_log(3, (unsigned int)8, 1, "%s: Error querying buffer %i\nVIDIOC_QUERYBUF: ", (const void *)"v4l2_set_mmap", buffer_index);
              free((void *)vid_source->buffers);
              return -1;
            }

            (vid_source->buffers + (signed long int)buffer_index)->size = (unsigned long int)buf.length;
            void *return_value_mmap$4;
            return_value_mmap$4=mmap((void *)0, (unsigned long int)buf.length, 0x1 | 0x2, 0x01, vid_source->fd, (signed long int)buf.m.offset);
            (vid_source->buffers + (signed long int)buffer_index)->ptr = (unsigned char *)return_value_mmap$4;
            if((vid_source->buffers + (signed long int)buffer_index)->ptr == (unsigned char *)-1)
            {
              motion_log(3, (unsigned int)8, 1, "%s: Error mapping buffer %i mmap", (const void *)"v4l2_set_mmap", buffer_index);
              free((void *)vid_source->buffers);
              return -1;
            }

            motion_log(7, (unsigned int)8, 0, "%s: %i length=%d Address (%x)", (const void *)"v4l2_set_mmap", buffer_index, buf.length, (vid_source->buffers + (signed long int)buffer_index)->ptr);
          }
          buffer_index = (unsigned int)0;
          for( ; !(buffer_index >= vid_source->req.count); buffer_index = buffer_index + 1u)
          {
            memset((void *)&vid_source->buf, 0, sizeof(struct v4l2_buffer) /*88ul*/ );
            vid_source->buf.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
            vid_source->buf.memory = (unsigned int)1;
            vid_source->buf.index = buffer_index;
            signed int return_value_xioctl$5;
            return_value_xioctl$5=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(15 << 0)) | sizeof(struct v4l2_buffer) /*88ul*/  << 0 + 8 + 8), (void *)&vid_source->buf);
            if(return_value_xioctl$5 == -1)
            {
              motion_log(3, (unsigned int)8, 1, "%s: VIDIOC_QBUF", (const void *)"v4l2_set_mmap");
              return -1;
            }

          }
          type = (enum v4l2_buf_type)V4L2_BUF_TYPE_VIDEO_CAPTURE;
          signed int return_value_xioctl$6;
          return_value_xioctl$6=xioctl(vid_source->fd, (signed int)((unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(18 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8), (void *)&type);
          if(return_value_xioctl$6 == -1)
          {
            motion_log(3, (unsigned int)8, 1, "%s: Error starting stream. VIDIOC_STREAMON", (const void *)"v4l2_set_mmap");
            return -1;
          }

          else
            return 0;
        }
      }
    }
  }
}

// v4l2_set_pix_format
// file video2.c line 447
static signed int v4l2_set_pix_format(struct context *cnt, struct anonymous$29 *vid_source, signed int *width, signed int *height)
{
  struct v4l2_fmtdesc fmtd;
  signed int v4l2_pal;
  signed int array_size = (signed int)(sizeof(const unsigned int [18l]) /*72ul*/  / sizeof(const unsigned int) /*4ul*/ );
  signed int index_format = -1;
  memset((void *)&fmtd, 0, sizeof(struct v4l2_fmtdesc) /*64ul*/ );
  v4l2_pal = 0;
  fmtd.index = (unsigned int)v4l2_pal;
  fmtd.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
  static const unsigned int supported_formats[18l] = { (unsigned int)83 | (unsigned int)57 << 8 | (unsigned int)49 << 16 | (unsigned int)48 << 24,
    (unsigned int)66 | (unsigned int)89 << 8 | (unsigned int)82 << 16 | (unsigned int)50 << 24,
    (unsigned int)66 | (unsigned int)65 << 8 | (unsigned int)56 << 16 | (unsigned int)49 << 24,
    (unsigned int)83 | (unsigned int)53 << 8 | (unsigned int)54 << 16 | (unsigned int)49 << 24,
    (unsigned int)71 | (unsigned int)66 << 8 | (unsigned int)82 << 16 | (unsigned int)71 << 24,
    (unsigned int)71 | (unsigned int)82 << 8 | (unsigned int)66 << 16 | (unsigned int)71 << 24,
    (unsigned int)80 | (unsigned int)50 << 8 | (unsigned int)48 << 16 | (unsigned int)55 << 24,
    (unsigned int)80 | (unsigned int)74 << 8 | (unsigned int)80 << 16 | (unsigned int)71 << 24,
    (unsigned int)77 | (unsigned int)74 << 8 | (unsigned int)80 << 16 | (unsigned int)71 << 24,
    (unsigned int)74 | (unsigned int)80 << 8 | (unsigned int)69 << 16 | (unsigned int)71 << 24,
    (unsigned int)82 | (unsigned int)71 << 8 | (unsigned int)66 << 16 | (unsigned int)51 << 24,
    (unsigned int)83 | (unsigned int)53 << 8 | (unsigned int)48 << 16 | (unsigned int)49 << 24,
    (unsigned int)83 | (unsigned int)53 << 8 | (unsigned int)48 << 16 | (unsigned int)53 << 24,
    (unsigned int)83 | (unsigned int)53 << 8 | (unsigned int)48 << 16 | (unsigned int)56 << 24,
    (unsigned int)85 | (unsigned int)89 << 8 | (unsigned int)86 << 16 | (unsigned int)89 << 24,
    (unsigned int)89 | (unsigned int)85 << 8 | (unsigned int)89 << 16 | (unsigned int)86 << 24,
    (unsigned int)52 | (unsigned int)50 << 8 | (unsigned int)50 << 16 | (unsigned int)80 << 24,
    (unsigned int)89 | (unsigned int)85 << 8 | (unsigned int)49 << 16 | (unsigned int)50 << 24 };
  if(cnt->conf.v4l2_palette >= 0)
  {
    char name[5l] = { (char)(supported_formats[(signed long int)cnt->conf.v4l2_palette] >> 0),
    (char)(supported_formats[(signed long int)cnt->conf.v4l2_palette] >> 8),
    (char)(supported_formats[(signed long int)cnt->conf.v4l2_palette] >> 16),
    (char)(supported_formats[(signed long int)cnt->conf.v4l2_palette] >> 24),
    (char)0 };
    signed int return_value_v4l2_do_set_pix_format$1;
    return_value_v4l2_do_set_pix_format$1=v4l2_do_set_pix_format(supported_formats[(signed long int)cnt->conf.v4l2_palette], vid_source, width, height);
    if(return_value_v4l2_do_set_pix_format$1 >= 0)
      return 0;

    motion_log(5, (unsigned int)8, 0, "%s: Config palette index %d (%s) doesn't work.", (const void *)"v4l2_set_pix_format", cnt->conf.v4l2_palette, (const void *)name);
  }

  motion_log(5, (unsigned int)8, 0, "%s: Supported palettes:", (const void *)"v4l2_set_pix_format");
  signed int return_value_xioctl$2;
  do
  {
    return_value_xioctl$2=xioctl(vid_source->fd, (signed int)((unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(2 << 0)) | sizeof(struct v4l2_fmtdesc) /*64ul*/  << 0 + 8 + 8), (void *)&fmtd);
    if(return_value_xioctl$2 == -1)
      break;

    signed int i;
    motion_log(5, (unsigned int)8, 0, "%s: (%i) %c%c%c%c (%s)", (const void *)"v4l2_set_pix_format", v4l2_pal, fmtd.pixelformat >> 0, fmtd.pixelformat >> 8, fmtd.pixelformat >> 16, fmtd.pixelformat >> 24, (const void *)fmtd.description);
    motion_log(5, (unsigned int)8, 0, "%s: %d - %s (compressed : %d) (%#x)", (const void *)"v4l2_set_pix_format", fmtd.index, (const void *)fmtd.description, fmtd.flags, fmtd.pixelformat);
    i = index_format + 1;
    for( ; !(i >= array_size); i = i + 1)
      if(supported_formats[(signed long int)i] == fmtd.pixelformat)
        index_format = i;

    memset((void *)&fmtd, 0, sizeof(struct v4l2_fmtdesc) /*64ul*/ );
    v4l2_pal = v4l2_pal + 1;
    fmtd.index = (unsigned int)v4l2_pal;
    fmtd.type = (unsigned int)V4L2_BUF_TYPE_VIDEO_CAPTURE;
  }
  while((_Bool)1);
  if(index_format >= 0)
  {
    char v4l2_set_pix_format$$1$$3$$name[5l] = { (char)(supported_formats[(signed long int)index_format] >> 0),
    (char)(supported_formats[(signed long int)index_format] >> 8),
    (char)(supported_formats[(signed long int)index_format] >> 16),
    (char)(supported_formats[(signed long int)index_format] >> 24),
    (char)0 };
    motion_log(5, (unsigned int)8, 0, "%s Selected palette %s", (const void *)"v4l2_set_pix_format", (const void *)v4l2_set_pix_format$$1$$3$$name);
    signed int return_value_v4l2_do_set_pix_format$3;
    return_value_v4l2_do_set_pix_format$3=v4l2_do_set_pix_format(supported_formats[(signed long int)index_format], vid_source, width, height);
    if(return_value_v4l2_do_set_pix_format$3 >= 0)
      return 0;

    motion_log(3, (unsigned int)8, 1, "VIDIOC_TRY_FMT failed for format %s", (const void *)"v4l2_set_pix_format", (const void *)v4l2_set_pix_format$$1$$3$$name);
  }

  motion_log(3, (unsigned int)8, 0, "%s: Unable to find a compatible palette format.", (const void *)"v4l2_set_pix_format");
  return -1;
}

// v4l2_start
// file video2.c line 806
unsigned char * v4l2_start(struct context *cnt, struct video_dev *viddev, signed int width, signed int height, signed int input, signed int norm, unsigned long int freq, signed int tuner_number)
{
  struct anonymous$29 *vid_source;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(sizeof(struct anonymous$29) /*664ul*/ , (unsigned long int)1);
  vid_source = (struct anonymous$29 *)return_value_calloc$1;
  struct config *conf;
  signed int return_value_v4l2_get_capability$2;
  signed int return_value_v4l2_select_input$3;
  signed int return_value_v4l2_set_pix_format$4;
  signed int return_value_v4l2_scan_controls$5;
  signed int return_value_v4l2_set_mmap$6;
  if(vid_source == ((struct anonymous$29 *)NULL))
    motion_log(3, (unsigned int)8, 1, "%s: Out of memory.", (const void *)"v4l2_start");

  else
  {
    viddev->v4l2_private = (void *)vid_source;
    vid_source->fd = viddev->fd;
    vid_source->fps = (unsigned int)cnt->conf.frame_limit;
    vid_source->pframe = -1;
    conf = &cnt->conf;
    return_value_v4l2_get_capability$2=v4l2_get_capability(vid_source);
    if(return_value_v4l2_get_capability$2 == 0)
    {
      return_value_v4l2_select_input$3=v4l2_select_input(conf, viddev, vid_source, input, norm, freq, tuner_number);
      if(return_value_v4l2_select_input$3 == 0)
      {
        return_value_v4l2_set_pix_format$4=v4l2_set_pix_format(cnt, vid_source, &width, &height);
        if(return_value_v4l2_set_pix_format$4 == 0)
        {
          return_value_v4l2_scan_controls$5=v4l2_scan_controls(vid_source);
          if(return_value_v4l2_scan_controls$5 == 0)
          {
            return_value_v4l2_set_mmap$6=v4l2_set_mmap(vid_source);
            if(return_value_v4l2_set_mmap$6 == 0)
            {
              viddev->size_map = 0;
              viddev->v4l_buffers[(signed long int)0] = (unsigned char *)(void *)0;
              viddev->v4l_maxbuffer = 1;
              viddev->v4l_curbuffer = 0;
              viddev->v4l_fmt = 15;
              viddev->v4l_bufsize = (width * height * 3) / 2;
              viddev->width = width;
              viddev->height = height;
              return (unsigned char *)(void *)1;
            }

          }

        }

      }

    }

  }

err:
  ;
  if(!(vid_source == ((struct anonymous$29 *)NULL)))
    free((void *)vid_source);

  viddev->v4l2_private = (void *)0;
  viddev->v4l2 = 0;
  return (unsigned char *)(void *)0;
}

// vid_cleanup
// file video.h line 92
void vid_cleanup(void)
{
  pthread_mutex_destroy(&vid_mutex);
}

// vid_close
// file video.h line 91
void vid_close(struct context *cnt)
{
  struct video_dev *dev = viddevs;
  struct video_dev *prev = (struct video_dev *)(void *)0;
  if(!(cnt->netcam == ((struct netcam_context *)NULL)))
  {
    motion_log(6, (unsigned int)8, 0, "%s: calling netcam_cleanup", (const void *)"vid_close");
    netcam_cleanup(cnt->netcam, 0);
    cnt->netcam = (struct netcam_context *)(void *)0;
  }

  else
  {
    pthread_mutex_lock(&vid_mutex);
    for( ; !(dev == ((struct video_dev *)NULL)); dev = dev->next)
    {
      if(dev->fd == cnt->video_dev)
        break;

      prev = dev;
    }
    pthread_mutex_unlock(&vid_mutex);
    cnt->video_dev = -1;
    if(dev == ((struct video_dev *)NULL))
      motion_log(2, (unsigned int)8, 0, "%s: Unable to find video device", (const void *)"vid_close");

    else
    {
      dev->usage_count = dev->usage_count - 1;
      if(dev->usage_count == 0)
      {
        motion_log(5, (unsigned int)8, 0, "%s: Closing video device %s", (const void *)"vid_close", dev->video_device);
        if(!(dev->v4l2 == 0))
        {
          v4l2_close(dev);
          v4l2_cleanup(dev);
        }

        else
        {
          close(dev->fd);
          munmap((void *)viddevs->v4l_buffers[(signed long int)0], (unsigned long int)dev->size_map);
        }
        dev->fd = -1;
        pthread_mutex_lock(&vid_mutex);
        if(prev == ((struct video_dev *)NULL))
          viddevs = dev->next;

        else
          prev->next = dev->next;
        pthread_mutex_unlock(&vid_mutex);
        pthread_mutexattr_destroy(&dev->attr);
        pthread_mutex_destroy(&dev->mutex);
        free((void *)dev);
      }

      else
      {
        motion_log(5, (unsigned int)8, 0, "%s: Still %d users of video device %s, so we don't close it now", (const void *)"vid_close", dev->usage_count, dev->video_device);
        if(dev->owner == cnt->threadnr)
        {
          dev->frames = 0;
          dev->owner = -1;
          pthread_mutex_unlock(&dev->mutex);
        }

      }
    }
  }
}

// vid_do_autobright
// file video.h line 99
signed int vid_do_autobright(struct context *cnt, struct video_dev *viddev)
{
  signed int brightness_window_high;
  signed int brightness_window_low;
  signed int brightness_target;
  signed int i;
  signed int j = 0;
  signed int avg = 0;
  signed int step = 0;
  unsigned char *image = cnt->imgs.image_virgin;
  signed int make_change = 0;
  if(!(cnt->conf.brightness == 0))
    brightness_target = cnt->conf.brightness;

  else
    brightness_target = 128;
  brightness_window_high = brightness_target + 10 < 255 ? brightness_target + 10 : 255;
  brightness_window_low = brightness_target - 10 > 1 ? brightness_target - 10 : 1;
  i = 0;
  for( ; !(i >= cnt->imgs.motionsize); i = i + 101)
  {
    avg = avg + (signed int)image[(signed long int)i];
    j = j + 1;
  }
  avg = avg / j;
  if(!(brightness_window_high >= avg))
  {
    signed int tmp_if_expr$1;
    if(!((avg + -brightness_target) / 5 + 1 >= viddev->brightness))
      tmp_if_expr$1 = (avg - brightness_target) / 5 + 1;

    else
      tmp_if_expr$1 = viddev->brightness - 0;
    step = tmp_if_expr$1;
    if(!(1 + step >= viddev->brightness))
    {
      viddev->brightness = viddev->brightness - step;
      make_change = 1;
    }

  }

  else
    if(!(avg >= brightness_window_low))
    {
      signed int tmp_if_expr$2;
      if(!((brightness_target + -avg) / 5 + 1 >= 255 + -viddev->brightness))
        tmp_if_expr$2 = (brightness_target - avg) / 5 + 1;

      else
        tmp_if_expr$2 = 255 - viddev->brightness;
      step = tmp_if_expr$2;
      if(!(viddev->brightness >= 255 + -step))
      {
        viddev->brightness = viddev->brightness + step;
        make_change = 1;
      }

    }

  return make_change;
}

// vid_init
// file video.h line 93
void vid_init(void)
{
  pthread_mutex_init(&vid_mutex, (const union anonymous$31 *)(void *)0);
}

// vid_next
// file video.h line 90
signed int vid_next(struct context *cnt, unsigned char *map)
{
  signed int ret = -2;
  struct config *conf = &cnt->conf;
  if(!(conf->netcam_url == ((const char *)NULL)))
  {
    if(cnt->video_dev == -1)
      return 0x02;

    signed int return_value_netcam_next$1;
    return_value_netcam_next$1=netcam_next(cnt, map);
    return return_value_netcam_next$1;
  }

  struct video_dev *dev;
  signed int width;
  signed int height;
  width = cnt->rotate_data.cap_width;
  height = cnt->rotate_data.cap_height;
  pthread_mutex_lock(&vid_mutex);
  dev = viddevs;
  for( ; !(dev == ((struct video_dev *)NULL)); dev = dev->next)
    if(dev->fd == cnt->video_dev)
      break;

  pthread_mutex_unlock(&vid_mutex);
  if(dev == ((struct video_dev *)NULL))
    return -1;

  else
  {
    if(!(dev->owner == cnt->threadnr))
    {
      pthread_mutex_lock(&dev->mutex);
      dev->owner = cnt->threadnr;
      dev->frames = conf->roundrobin_frames;
    }

    if(!(dev->v4l2 == 0))
    {
      v4l2_set_input(cnt, dev, map, width, height, conf);
      ret=v4l2_next(cnt, dev, map, width, height);
    }

    dev->frames = dev->frames - 1;
    if(!(dev->frames >= 1))
    {
      dev->owner = -1;
      dev->frames = 0;
      pthread_mutex_unlock(&dev->mutex);
    }

    if(cnt->rotate_data.degrees >= 1)
      rotate_map(cnt, map);

    return ret;
  }
}

// vid_start
// file video.h line 89
signed int vid_start(struct context *cnt)
{
  struct config *conf = &cnt->conf;
  signed int dev = -1;
  if(!(conf->netcam_url == ((const char *)NULL)))
  {
    dev=netcam_start(cnt);
    if(!(dev >= 0))
    {
      netcam_cleanup(cnt->netcam, 1);
      cnt->netcam = (struct netcam_context *)(void *)0;
    }

  }

  else
    dev=vid_v4lx_start(cnt);
  return dev;
}

// vid_v4lx_start
// file video_common.c line 649
static signed int vid_v4lx_start(struct context *cnt)
{
  struct config *conf = &cnt->conf;
  signed int fd = -1;
  struct video_dev *dev;
  signed int width;
  signed int height;
  signed int input;
  signed int norm;
  signed int tuner_number;
  unsigned long int frequency;
  if(!(conf->width % 8 == 0))
  {
    motion_log(3, (unsigned int)8, 0, "%s: config image width (%d) is not modulo 8", (const void *)"vid_v4lx_start", conf->width);
    return -3;
  }

  else
    if(!(conf->height % 8 == 0))
    {
      motion_log(3, (unsigned int)8, 0, "%s: config image height (%d) is not modulo 8", (const void *)"vid_v4lx_start", conf->height);
      return -3;
    }

    else
    {
      width = conf->width;
      height = conf->height;
      input = conf->input;
      norm = conf->norm;
      frequency = conf->frequency;
      tuner_number = conf->tuner_number;
      pthread_mutex_lock(&vid_mutex);
      cnt->imgs.width = width;
      cnt->imgs.height = height;
      dev = viddevs;
      while(!(dev == ((struct video_dev *)NULL)))
      {
        signed int return_value_strcmp$1;
        return_value_strcmp$1=strcmp(conf->video_device, dev->video_device);
        if(return_value_strcmp$1 == 0)
        {
          dev->usage_count = dev->usage_count + 1;
          cnt->imgs.type = dev->v4l_fmt;
          switch(cnt->imgs.type)
          {
            case 1:
            {
              cnt->imgs.motionsize = width * height;
              cnt->imgs.size = width * height;
              break;
            }
            case 8:

            case 4:

            case 7:
              cnt->imgs.type = 15;
            case 15:
            {
              cnt->imgs.motionsize = width * height;
              cnt->imgs.size = (width * height * 3) / 2;
            }
          }
          pthread_mutex_unlock(&vid_mutex);
          return dev->fd;
        }

        dev = dev->next;
      }
      motion_log(5, (unsigned int)8, 0, "%s: Using videodevice %s and input %d", (const void *)"vid_v4lx_start", conf->video_device, conf->input);
      void *return_value_mymalloc$2;
      return_value_mymalloc$2=mymalloc(sizeof(struct video_dev) /*176ul*/ );
      dev = (struct video_dev *)return_value_mymalloc$2;
      memset((void *)dev, 0, sizeof(struct video_dev) /*176ul*/ );
      dev->video_device = conf->video_device;
      fd=open(dev->video_device, 02);
      if(!(fd >= 0))
      {
        motion_log(1, (unsigned int)8, 1, "%s: Failed to open video device %s", (const void *)"vid_v4lx_start", conf->video_device);
        free((void *)dev);
        pthread_mutex_unlock(&vid_mutex);
        return -1;
      }

      else
      {
        pthread_mutexattr_init(&dev->attr);
        pthread_mutex_init(&dev->mutex, &dev->attr);
        dev->usage_count = 1;
        dev->fd = fd;
        dev->input = input;
        dev->norm = norm;
        dev->height = height;
        dev->width = width;
        dev->freq = frequency;
        dev->tuner_number = tuner_number;
        dev->brightness = 0;
        dev->contrast = 0;
        dev->saturation = 0;
        dev->hue = 0;
        dev->owner = -1;
        dev->v4l_fmt = 15;
        dev->fps = 0;
        dev->v4l2 = 1;
        unsigned char *return_value_v4l2_start$3;
        return_value_v4l2_start$3=v4l2_start(cnt, dev, width, height, input, norm, frequency, tuner_number);
        if(return_value_v4l2_start$3 == ((unsigned char *)NULL))
        {
          dev->width = width;
          dev->height = height;
          dev->v4l2 = 0;
        }

        if(dev->v4l2 == 0)
          motion_log(5, (unsigned int)8, 0, "%s: Using V4L1", (const void *)"vid_v4lx_start");

        else
        {
          motion_log(5, (unsigned int)8, 0, "%s: Using V4L2", (const void *)"vid_v4lx_start");
          width = dev->width;
          height = dev->height;
          cnt->imgs.width = width;
          cnt->imgs.height = height;
        }
        cnt->imgs.type = dev->v4l_fmt;
        switch(cnt->imgs.type)
        {
          case 1:
          {
            cnt->imgs.size = width * height;
            cnt->imgs.motionsize = width * height;
            break;
          }
          case 8:

          case 4:

          case 7:
            cnt->imgs.type = 15;
          case 15:
          {
            cnt->imgs.size = (width * height * 3) / 2;
            cnt->imgs.motionsize = width * height;
          }
        }
        dev->next = viddevs;
        viddevs = dev;
        pthread_mutex_unlock(&vid_mutex);
        return fd;
      }
    }
}

// write_nonblock
// file webhttpd.c line 194
static signed long int write_nonblock(signed int fd, const void *buf, unsigned long int size)
{
  signed long int nwrite = (signed long int)-1;
  struct timeval tm;
  struct anonymous$45 fds;
  tm.tv_sec = (signed long int)1;
  tm.tv_usec = (signed long int)0;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$45) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$2;
  return_value_select$2=select(fd + 1, (struct anonymous$45 *)(void *)0, &fds, (struct anonymous$45 *)(void *)0, &tm);
  if(return_value_select$2 >= 1)
  {
    if(!((fds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
    {
      nwrite=write(fd, buf, size);
      if(!(nwrite >= 0l))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(!(*return_value___errno_location$1 == 11))
          return (signed long int)-1;

      }

    }

  }

  return nwrite;
}

// xioctl
// file video2.c line 182
static signed int xioctl(signed int fd, signed int request, void *arg)
{
  signed int ret;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    ret=ioctl(fd, (unsigned long int)request, arg);
    if(ret == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = 4 == *return_value___errno_location$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  return ret;
}

