// #anon_enum_MESSAGE=0_WARNING=1_ERROR=2
// file logapp.h line 24
enum anonymous_6 { MESSAGE=0, WARNING=1, ERROR=2 };

// #anon_enum_TBOOL=0_TCLIP=1_TCOLOR=2_TINT=3_TNONE=4_TSTRING=5_TUINT=6
// file configuration.h line 182
enum anonymous_11 { TBOOL=0, TCLIP=1, TCOLOR=2, TINT=3, TNONE=4, TSTRING=5, TUINT=6 };

// tag-#anon#ST[*{S8}_S8_'argprefix'||*{S8}_S8_'strip_prefix'||*{S8}_S8_'executable'||S32'usepty'||S32'dumbterm'||S32'detectescape'||S32'ptyremovecr'||S32'appendlog'||S32'printsummary'||S32'printlogname'||S32'disable'||*{S8}_S8_'disable_keywords'||*{S8}_S8_'logname'||S32'logtime'||S32'logreltime'||S32'logenv'||S32'maxlogsize'||S32'locklogfile'||S32'warnlogfilelock'||S32'maxlogfiles'||S32'circularlog'||S32'logrename'||S32'alignlog'||S32'jointimeout'||S32'alignlinebreaks'||*{S8}_S8_'configfile'||*{S8}_S8_'configsection'||*{S8}_S8_'custconfigfile'||*{S8}_S8_'preexeccmd'||*{S8}_S8_'postexeccmd'||S32'exitonexecfail'||S32'extregexp'|]
// file configuration.h line 31
struct anonymous_3;

// tag-#anon#ST[*{S8}_S8_'exe'||*{*{S8}_S8_}_*{S8}_S8__'argv'||S32'argc'||S32'pid'||S32'active'||S32'doexit'||S32'exit_state'||U32'_pad0'||S64'starttime'||SYM#tag-timeval#'toffset'||*{SYM#tag-#anon#ST[S32'fh'||S32'cfhno'||*{S8}_S8_'name'||U64'ct'||*{S8}_S8_'dbuf'||*{S8}_S8_'buf'||SYM#tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]#'rdbuf'||S32'state'||S32'charbased'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'handler'||S32'detectescape'||S32'switchtocbmode'||S32'memcr'||S32'ptyremovecr'||S32'blen'||S32'bfill'||S32'recalclen'||S32'fgcol'||S32'bgcol'||S32'bold'||S32'clip'||S32'eclip'||*{S8}_S8_'escreset'||S32'escresetlen'||U32'_pad0'||*{S8}_S8_'esccolor'||S32'esccolorlen'||S32'linecount'||*{S8}_S8_'lineprefix'||S32'lineprefixlen'||ARR9{S32}_S32_'linebreakpos'||*{S8}_S8_'regexp'||SYM#tag-re_pattern_buffer#'preg'||S32'regbgcol'||U32'_pad1'||*{S8}_S8_'bgesccolor'||*{S8}_S8_'execregexp'||SYM#tag-re_pattern_buffer#'pexecreg'||*{S8}_S8_'execcommand'|]#}_SYM#tag-#anon#ST[S32'fh'||S32'cfhno'||*{S8}_S8_'name'||U64'ct'||*{S8}_S8_'dbuf'||*{S8}_S8_'buf'||SYM#tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]#'rdbuf'||S32'state'||S32'charbased'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'handler'||S32'detectescape'||S32'switchtocbmode'||S32'memcr'||S32'ptyremovecr'||S32'blen'||S32'bfill'||S32'recalclen'||S32'fgcol'||S32'bgcol'||S32'bold'||S32'clip'||S32'eclip'||*{S8}_S8_'escreset'||S32'escresetlen'||U32'_pad0'||*{S8}_S8_'esccolor'||S32'esccolorlen'||S32'linecount'||*{S8}_S8_'lineprefix'||S32'lineprefixlen'||ARR9{S32}_S32_'linebreakpos'||*{S8}_S8_'regexp'||SYM#tag-re_pattern_buffer#'preg'||S32'regbgcol'||U32'_pad1'||*{S8}_S8_'bgesccolor'||*{S8}_S8_'execregexp'||SYM#tag-re_pattern_buffer#'pexecreg'||*{S8}_S8_'execcommand'|]#_'pstdout'||*{SYM#tag-#anon#ST[S32'fh'||S32'cfhno'||*{S8}_S8_'name'||U64'ct'||*{S8}_S8_'dbuf'||*{S8}_S8_'buf'||SYM#tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]#'rdbuf'||S32'state'||S32'charbased'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'handler'||S32'detectescape'||S32'switchtocbmode'||S32'memcr'||S32'ptyremovecr'||S32'blen'||S32'bfill'||S32'recalclen'||S32'fgcol'||S32'bgcol'||S32'bold'||S32'clip'||S32'eclip'||*{S8}_S8_'escreset'||S32'escresetlen'||U32'_pad0'||*{S8}_S8_'esccolor'||S32'esccolorlen'||S32'linecount'||*{S8}_S8_'lineprefix'||S32'lineprefixlen'||ARR9{S32}_S32_'linebreakpos'||*{S8}_S8_'regexp'||SYM#tag-re_pattern_buffer#'preg'||S32'regbgcol'||U32'_pad1'||*{S8}_S8_'bgesccolor'||*{S8}_S8_'execregexp'||SYM#tag-re_pattern_buffer#'pexecreg'||*{S8}_S8_'execcommand'|]#}_SYM#tag-#anon#ST[S32'fh'||S32'cfhno'||*{S8}_S8_'name'||U64'ct'||*{S8}_S8_'dbuf'||*{S8}_S8_'buf'||SYM#tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]#'rdbuf'||S32'state'||S32'charbased'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'handler'||S32'detectescape'||S32'switchtocbmode'||S32'memcr'||S32'ptyremovecr'||S32'blen'||S32'bfill'||S32'recalclen'||S32'fgcol'||S32'bgcol'||S32'bold'||S32'clip'||S32'eclip'||*{S8}_S8_'escreset'||S32'escresetlen'||U32'_pad0'||*{S8}_S8_'esccolor'||S32'esccolorlen'||S32'linecount'||*{S8}_S8_'lineprefix'||S32'lineprefixlen'||ARR9{S32}_S32_'linebreakpos'||*{S8}_S8_'regexp'||SYM#tag-re_pattern_buffer#'preg'||S32'regbgcol'||U32'_pad1'||*{S8}_S8_'bgesccolor'||*{S8}_S8_'execregexp'||SYM#tag-re_pattern_buffer#'pexecreg'||*{S8}_S8_'execcommand'|]#_'pstderr'||*{SYM#tag-winsize#}_SYM#tag-winsize#_'ptysize'||*{SYM#tag-termios#}_SYM#tag-termios#_'ptytermios'||*{SYM#tag-termios#}_SYM#tag-termios#_'ptytermios_bak'||*{SYM#tag-#anon#ST[S32'fh'||U32'_pad0'||*{S8}_S8_'name'||U32'sizelimit'||U32'_pad1'||*{S8}_S8_'oldext'||S32'appendnr'||U32'_pad2'||*{S8}_S8_'head'||*{S8}_S8_'split'||*{S8}_S8_'foot'||S32'addnewline'||U32'_pad3'||*{S8}_S8_'indent'|]#}_SYM#tag-#anon#ST[S32'fh'||U32'_pad0'||*{S8}_S8_'name'||U32'sizelimit'||U32'_pad1'||*{S8}_S8_'oldext'||S32'appendnr'||U32'_pad2'||*{S8}_S8_'head'||*{S8}_S8_'split'||*{S8}_S8_'foot'||S32'addnewline'||U32'_pad3'||*{S8}_S8_'indent'|]#_'logfile'|]
// file configuration.h line 152
struct anonymous_8;

// tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]
// file configuration.h line 76
struct anonymous;

// tag-#anon#ST[*{S8}_S8_'string'||S32'value'||U32'_pad0'|]
// file configuration.h line 170
struct anonymous_1;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_9;

// tag-#anon#ST[S32'fh'||S32'cfhno'||*{S8}_S8_'name'||U64'ct'||*{S8}_S8_'dbuf'||*{S8}_S8_'buf'||SYM#tag-#anon#ST[*{S8}_S8_'start'||S32'len'||U32'_pad0'||*{S8}_S8_'end'||*{S8}_S8_'read'|]#'rdbuf'||S32'state'||S32'charbased'||*{S32(*{V}_V_)->S32}_S32(*{V}_V_)->S32_'handler'||S32'detectescape'||S32'switchtocbmode'||S32'memcr'||S32'ptyremovecr'||S32'blen'||S32'bfill'||S32'recalclen'||S32'fgcol'||S32'bgcol'||S32'bold'||S32'clip'||S32'eclip'||*{S8}_S8_'escreset'||S32'escresetlen'||U32'_pad0'||*{S8}_S8_'esccolor'||S32'esccolorlen'||S32'linecount'||*{S8}_S8_'lineprefix'||S32'lineprefixlen'||ARR9{S32}_S32_'linebreakpos'||*{S8}_S8_'regexp'||SYM#tag-re_pattern_buffer#'preg'||S32'regbgcol'||U32'_pad1'||*{S8}_S8_'bgesccolor'||*{S8}_S8_'execregexp'||SYM#tag-re_pattern_buffer#'pexecreg'||*{S8}_S8_'execcommand'|]
// file configuration.h line 83
struct anonymous_5;

// tag-#anon#ST[S32'fh'||U32'_pad0'||*{S8}_S8_'name'||U32'sizelimit'||U32'_pad1'||*{S8}_S8_'oldext'||S32'appendnr'||U32'_pad2'||*{S8}_S8_'head'||*{S8}_S8_'split'||*{S8}_S8_'foot'||S32'addnewline'||U32'_pad3'||*{S8}_S8_'indent'|]
// file configuration.h line 135
struct anonymous_7;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_4;

// tag-#anon#ST[S8'shrt'||U56'_pad0'||*{S8}_S8_'lng'||*{S8}_S8_'parm'||EN#anon_enum_TBOOL=0_TCLIP=1_TCOLOR=2_TINT=3_TNONE=4_TSTRING=5_TUINT=6#{U32}_U32_'type'||U32'_pad1'||*{V}_V_'var'||*{S8}_S8_'desc'||S32'set'||U32'_pad2'|]
// file configuration.h line 192
struct anonymous_10;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 398
extern signed int __fxstat(signed int, signed int, struct stat *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject);
// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2);
// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1023
static inline unsigned long int __strspn_c1(const char *__s, signed int __accept);
// __strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1035
static inline unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1047
static inline unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// adjust_clipping
// file configuration.h line 212
extern signed int adjust_clipping(void);
// buf_get_char
// file capture.c line 247
signed int buf_get_char(struct anonymous_5 *pipe, char *buf);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_end
// file capture.h line 24
signed int capture_end(void);
// capture_loop
// file capture.c line 612
signed int capture_loop(struct anonymous_5 *pipe_stdout, struct anonymous_5 *pipe_stderr);
// capture_start
// file capture.h line 23
signed int capture_start(void);
// capture_thread
// file capture.c line 577
void * capture_thread(void *do_pipe);
// check_for_disable_keywords
// file configuration.h line 213
extern signed int check_for_disable_keywords(void);
// cleanup_config
// file configuration.h line 210
extern void cleanup_config(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// error_outofmemory
// file main.c line 54
void error_outofmemory(void);
// execcmd
// file main.c line 119
signed int execcmd(char *cmd);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fixup_config
// file configuration.h line 209
extern signed int fixup_config(void);
// fixup_pipe
// file configuration.c line 508
static signed int fixup_pipe(struct anonymous_5 *pipe);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_child
// file main.c line 245
signed int fork_child();
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_buffer
// file capture.c line 404
void free_buffer(struct anonymous_5 *pipe);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// get_argid
// file configuration.c line 759
signed int get_argid(char *arg, signed int isshort);
// get_argvalue
// file configuration.c line 844
signed int get_argvalue(signed int priority, signed int argid, signed int *argp, signed int argc, char **argv, char *value);
// get_config
// file configuration.h line 208
extern signed int get_config(void);
// get_display_parameters
// file configuration.h line 211
extern signed int get_display_parameters(void);
// get_lock
// file logfile.c line 612
signed int get_lock(struct anonymous_7 *logfile);
// get_longpath
// file configuration.c line 479
extern char * get_longpath(const char *filename);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_cbstream
// file capture.c line 423
signed int handle_cbstream(struct anonymous_5 *pipe);
// handle_lbstream
// file capture.c line 527
signed int handle_lbstream(struct anonymous_5 *pipe);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_rdbuf_empty
// file capture.c line 242
inline signed int is_rdbuf_empty(struct anonymous_5 *pipe);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// logfile_add_footer
// file logfile.c line 238
static signed int logfile_add_footer(struct anonymous_7 *logfile);
// logfile_add_header
// file logfile.c line 52
static signed int logfile_add_header(struct anonymous_7 *logfile);
// logfile_add_splitmarker
// file logfile.c line 168
static signed int logfile_add_splitmarker(struct anonymous_7 *logfile);
// logfile_check_size
// file logfile.c line 392
static signed int logfile_check_size(struct anonymous_7 *logfile, signed int addmarker, unsigned int addsize);
// logfile_close
// file logfile.h line 30
extern signed int logfile_close(struct anonymous_7 *logfile);
// logfile_get_alternate_name
// file logfile.c line 365
static char * logfile_get_alternate_name(struct anonymous_7 *logfile);
// logfile_open
// file logfile.h line 29
extern signed int logfile_open(char *filename, struct anonymous_7 *logfile);
// logfile_rename
// file logfile.c line 332
static signed int logfile_rename(struct anonymous_7 *logfile, char *oldname);
// logfile_write
// file logfile.c line 432
extern signed int logfile_write(struct anonymous_7 *logfile, struct anonymous_5 *pipe);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// main::_tmp::return_value_signal_11_object
//
void return_value_signal_11_object(signed int);
// main::_tmp::return_value_signal_13_object
//
void return_value_signal_13_object(signed int);
// main::_tmp::return_value_signal_14_object
//
void return_value_signal_14_object(signed int);
// main::_tmp::return_value_signal_15_object
//
void return_value_signal_15_object(signed int);
// main::_tmp::return_value_signal_16_object
//
void return_value_signal_16_object(signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openpty
// file /usr/include/pty.h line 33
extern signed int openpty(signed int *, signed int *, char *, struct termios *, struct winsize *);
// parse_args
// file configuration.h line 206
extern signed int parse_args(signed int argc, char **argv);
// parse_configline
// file configuration.c line 1049
signed int parse_configline(char *line, char **appconfig_section);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// prepare_buffer
// file capture.c line 346
signed int prepare_buffer(struct anonymous_5 *pipe);
// print
// file main.c line 63
void print(enum anonymous_6 type, const char *format, ...);
// print_stream
// file capture.c line 92
signed int print_stream(struct anonymous_5 *pipe);
// print_summary
// file capture.h line 25
void print_summary(void);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_pipe
// file capture.c line 278
signed int read_pipe(struct anonymous_5 *pipe);
// recalc_cliplen
// file capture.c line 64
static signed int recalc_cliplen(struct anonymous_5 *pipe);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_4 *, signed int);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// reset_console
// file capture.h line 22
void reset_console(void);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_9 *, struct anonymous_9 *, struct anonymous_9 *, struct timeval *);
// show_configuration
// file configuration.h line 207
extern void show_configuration(void);
// sig_handler
// file main.c line 228
static void sig_handler(signed int signr);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string2numvalue
// file configuration.c line 783
signed int string2numvalue(char *string, signed int *value, const struct anonymous_1 *list, const struct anonymous_1 *prefixes);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcdrain
// file /usr/include/termios.h line 86
extern signed int tcdrain(signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// usage
// file main.c line 126
void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// version
// file main.c line 215
void version(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_3
{
  // argprefix
  char *argprefix;
  // strip_prefix
  char *strip_prefix;
  // executable
  char *executable;
  // usepty
  signed int usepty;
  // dumbterm
  signed int dumbterm;
  // detectescape
  signed int detectescape;
  // ptyremovecr
  signed int ptyremovecr;
  // appendlog
  signed int appendlog;
  // printsummary
  signed int printsummary;
  // printlogname
  signed int printlogname;
  // disable
  signed int disable;
  // disable_keywords
  char *disable_keywords;
  // logname
  char *logname;
  // logtime
  signed int logtime;
  // logreltime
  signed int logreltime;
  // logenv
  signed int logenv;
  // maxlogsize
  signed int maxlogsize;
  // locklogfile
  signed int locklogfile;
  // warnlogfilelock
  signed int warnlogfilelock;
  // maxlogfiles
  signed int maxlogfiles;
  // circularlog
  signed int circularlog;
  // logrename
  signed int logrename;
  // alignlog
  signed int alignlog;
  // jointimeout
  signed int jointimeout;
  // alignlinebreaks
  signed int alignlinebreaks;
  // configfile
  char *configfile;
  // configsection
  char *configsection;
  // custconfigfile
  char *custconfigfile;
  // preexeccmd
  char *preexeccmd;
  // postexeccmd
  char *postexeccmd;
  // exitonexecfail
  signed int exitonexecfail;
  // extregexp
  signed int extregexp;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous_8
{
  // exe
  char *exe;
  // argv
  char **argv;
  // argc
  signed int argc;
  // pid
  signed int pid;
  // active
  signed int active;
  // doexit
  signed int doexit;
  // exit_state
  signed int exit_state;
  // starttime
  signed long int starttime;
  // toffset
  struct timeval toffset;
  // pstdout
  struct anonymous_5 *pstdout;
  // pstderr
  struct anonymous_5 *pstderr;
  // ptysize
  struct winsize *ptysize;
  // ptytermios
  struct termios *ptytermios;
  // ptytermios_bak
  struct termios *ptytermios_bak;
  // logfile
  struct anonymous_7 *logfile;
};

struct anonymous
{
  // start
  char *start;
  // len
  signed int len;
  // end
  char *end;
  // read
  char *read;
};

struct anonymous_1
{
  // string
  char *string;
  // value
  signed int value;
};

struct anonymous_9
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct anonymous_5
{
  // fh
  signed int fh;
  // cfhno
  signed int cfhno;
  // name
  char *name;
  // ct
  unsigned long int ct;
  // dbuf
  char *dbuf;
  // buf
  char *buf;
  // rdbuf
  struct anonymous rdbuf;
  // state
  signed int state;
  // charbased
  signed int charbased;
  // handler
  signed int (*handler)(void *);
  // detectescape
  signed int detectescape;
  // switchtocbmode
  signed int switchtocbmode;
  // memcr
  signed int memcr;
  // ptyremovecr
  signed int ptyremovecr;
  // blen
  signed int blen;
  // bfill
  signed int bfill;
  // recalclen
  signed int recalclen;
  // fgcol
  signed int fgcol;
  // bgcol
  signed int bgcol;
  // bold
  signed int bold;
  // clip
  signed int clip;
  // eclip
  signed int eclip;
  // escreset
  char *escreset;
  // escresetlen
  signed int escresetlen;
  // esccolor
  char *esccolor;
  // esccolorlen
  signed int esccolorlen;
  // linecount
  signed int linecount;
  // lineprefix
  char *lineprefix;
  // lineprefixlen
  signed int lineprefixlen;
  // linebreakpos
  signed int linebreakpos[9l];
  // regexp
  char *regexp;
  // preg
  struct re_pattern_buffer preg;
  // regbgcol
  signed int regbgcol;
  // bgesccolor
  char *bgesccolor;
  // execregexp
  char *execregexp;
  // pexecreg
  struct re_pattern_buffer pexecreg;
  // execcommand
  char *execcommand;
};

struct anonymous_7
{
  // fh
  signed int fh;
  // name
  char *name;
  // sizelimit
  unsigned int sizelimit;
  // oldext
  char *oldext;
  // appendnr
  signed int appendnr;
  // head
  char *head;
  // split
  char *split;
  // foot
  char *foot;
  // addnewline
  signed int addnewline;
  // indent
  char *indent;
};

struct anonymous_4
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_10
{
  // shrt
  char shrt;
  // lng
  char *lng;
  // parm
  char *parm;
  // type
  enum anonymous_11 type;
  // var
  void *var;
  // desc
  char *desc;
  // set
  signed int set;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// app
// file configuration.c line 164
struct anonymous_8 app;
// logfile
// file configuration.c line 148
struct anonymous_7 logfile = { .fh=0, .name=(char *)(void *)0, .sizelimit=(unsigned int)0, .oldext=".old",
    .appendnr=0, .head=">> logapp:", .split="== logapp split:",
    .foot="<< logapp end:", .addnewline=0,
    .indent=((char *)NULL) };
// pstderr
// file configuration.c line 117
struct anonymous_5 pstderr = { .fh=0, .cfhno=2, .name="stderr", .ct=0ul, .dbuf=((char *)NULL),
    .buf=(char *)(void *)0, .rdbuf={ .start=((char *)NULL), .len=0, .end=((char *)NULL), .read=((char *)NULL) },
    .state=0,
    .charbased=0, .handler=((signed int (*)(void *))NULL), .detectescape=0,
    .switchtocbmode=0, .memcr=0, .ptyremovecr=0,
    .blen=65540, .bfill=0, .recalclen=0,
    .fgcol=1, .bgcol=-1, .bold=1, .clip=-1,
    .eclip=0, .escreset="\033[0m", .escresetlen=0,
    .esccolor=(char *)(void *)0, .esccolorlen=0,
    .linecount=0, .lineprefix="STDERR: ", .lineprefixlen=0,
    .linebreakpos={ 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .regexp=(char *)(void *)0,
    .preg={ .__buffer=((unsigned char *)NULL), .__allocated=0ul, .__used=0ul,
    .__syntax=0ul, .__fastmap=((char *)NULL), .__translate=((unsigned char *)NULL),
    .re_nsub=0ul,
    .__can_be_null=0u, .__regs_allocated=0u, .__fastmap_accurate=0u,
    .__no_sub=0u, .__not_bol=0u,
    .__not_eol=0u, .__newline_anchor=0u }, .regbgcol=4,
    .bgesccolor=(char *)(void *)0, .execregexp=(char *)(void *)0,
    .pexecreg={ .__buffer=((unsigned char *)NULL), .__allocated=0ul, .__used=0ul,
    .__syntax=0ul, .__fastmap=((char *)NULL), .__translate=((unsigned char *)NULL),
    .re_nsub=0ul,
    .__can_be_null=0u, .__regs_allocated=0u, .__fastmap_accurate=0u,
    .__no_sub=0u, .__not_bol=0u,
    .__not_eol=0u, .__newline_anchor=0u }, .execcommand=(char *)(void *)0 };
// pstdout
// file configuration.c line 86
struct anonymous_5 pstdout = { .fh=0, .cfhno=1, .name="stdout", .ct=0ul, .dbuf=((char *)NULL),
    .buf=(char *)(void *)0, .rdbuf={ .start=((char *)NULL), .len=0, .end=((char *)NULL), .read=((char *)NULL) },
    .state=0,
    .charbased=0, .handler=((signed int (*)(void *))NULL), .detectescape=0,
    .switchtocbmode=0, .memcr=0, .ptyremovecr=0,
    .blen=65540, .bfill=0, .recalclen=0,
    .fgcol=-1, .bgcol=-1, .bold=0, .clip=-2,
    .eclip=2, .escreset="\033[0m", .escresetlen=0,
    .esccolor=(char *)(void *)0, .esccolorlen=0,
    .linecount=0, .lineprefix=(char *)(void *)0, .lineprefixlen=0,
    .linebreakpos={ 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .regexp=(char *)(void *)0,
    .preg={ .__buffer=((unsigned char *)NULL), .__allocated=0ul, .__used=0ul,
    .__syntax=0ul, .__fastmap=((char *)NULL), .__translate=((unsigned char *)NULL),
    .re_nsub=0ul,
    .__can_be_null=0u, .__regs_allocated=0u, .__fastmap_accurate=0u,
    .__no_sub=0u, .__not_bol=0u,
    .__not_eol=0u, .__newline_anchor=0u }, .regbgcol=4,
    .bgesccolor=(char *)(void *)0, .execregexp=(char *)(void *)0,
    .pexecreg={ .__buffer=((unsigned char *)NULL), .__allocated=0ul, .__used=0ul,
    .__syntax=0ul, .__fastmap=((char *)NULL), .__translate=((unsigned char *)NULL),
    .re_nsub=0ul,
    .__can_be_null=0u, .__regs_allocated=0u, .__fastmap_accurate=0u,
    .__no_sub=0u, .__not_bol=0u,
    .__not_eol=0u, .__newline_anchor=0u }, .execcommand=(char *)(void *)0 };
// ptysize
// file configuration.c line 160
struct winsize ptysize;
// ptytermios
// file configuration.c line 161
struct termios ptytermios;
// ptytermios_bak
// file configuration.c line 161
struct termios ptytermios_bak;
// app
// file configuration.c line 164
struct anonymous_8 app = { .exe=(char *)(void *)0, .argv=(char **)(void *)0, .argc=0,
    .pid=0, .active=0, .doexit=0, .exit_state=0,
    .starttime=(signed long int)0, .toffset={ .tv_sec=0l, .tv_usec=0l },
    .pstdout=&pstdout,
    .pstderr=&pstderr, .ptysize=&ptysize,
    .ptytermios=&ptytermios, .ptytermios_bak=&ptytermios_bak,
    .logfile=&logfile };
// arglist
// file configuration.c line 221
struct anonymous_10 arglist[56l];
// config
// file configuration.c line 42
struct anonymous_3 config = { .argprefix="logapp_", .strip_prefix="log", .executable="logapp",
    .usepty=1, .dumbterm=0, .detectescape=0,
    .ptyremovecr=1, .appendlog=0, .printsummary=0,
    .printlogname=0, .disable=0, .disable_keywords=(char *)(void *)0,
    .logname="./logapp.log",
    .logtime=0, .logreltime=0,
    .logenv=0, .maxlogsize=0, .locklogfile=1,
    .warnlogfilelock=1, .maxlogfiles=10, .circularlog=0,
    .logrename=1, .alignlog=1, .jointimeout=0,
    .alignlinebreaks=1, .configfile=(char *)(void *)0, .configsection=(char *)(void *)0,
    .custconfigfile=(char *)(void *)0, .preexeccmd=(char *)(void *)0,
    .postexeccmd=(char *)(void *)0, .exitonexecfail=0,
    .extregexp=0 };
// show_config
// file configuration.c line 39
signed int show_config = 0;
// show_usage
// file configuration.c line 37
signed int show_usage = 0;
// show_version
// file configuration.c line 38
signed int show_version = 0;
// arglist
// file configuration.c line 221
struct anonymous_10 arglist[56l] = { { .shrt=(char)0, .lng=(char *)(void *)0, .parm=(char *)(void *)0,
    .type=(enum anonymous_11)TNONE, .var=(void *)0,
    .desc="General options:", .set=0 },
    { .shrt=(char)63, .lng="help", .parm=(char *)(void *)0, .type=(enum anonymous_11)TNONE,
    .var=(void *)&show_usage, .desc="show this help",
    .set=0 },
    { .shrt=(char)0, .lng="version", .parm=(char *)(void *)0, .type=(enum anonymous_11)TNONE,
    .var=(void *)&show_version, .desc="show version information",
    .set=0 },
    { .shrt=(char)0, .lng="configfile", .parm="FILE", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&config.custconfigfile, .desc="configuration file",
    .set=0 },
    { .shrt=(char)0, .lng="showconfig", .parm=(char *)(void *)0, .type=(enum anonymous_11)TNONE,
    .var=(void *)&show_config, .desc="print current configuration on the screen and exit",
    .set=0 },
    { .shrt=(char)0, .lng="configsection", .parm="NAME", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&config.configsection, .desc="select configuration section",
    .set=0 },
    { .shrt=(char)0, .lng="disable", .parm=(char *)(void *)0, .type=(enum anonymous_11)TNONE,
    .var=(void *)&config.disable, .desc="disable output handling",
    .set=0 },
    { .shrt=(char)0, .lng="disable_keywords", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&config.disable_keywords,
    .desc="comma separated keywords to disable output handling when found in argument list",
    .set=0 },
    { .shrt=(char)0, .lng="detectescape", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.detectescape, .desc="switch to charbased mode if escape sequence is detected",
    .set=0 },
    { .shrt=(char)0, .lng="usepty", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.usepty, .desc="use PTY for stream redirection",
    .set=0 },
    { .shrt=(char)0, .lng="ptyremovecr", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.ptyremovecr, .desc="translate CR-LF to LF when capturing PTY",
    .set=0 },
    { .shrt=(char)0, .lng="stdout_blen", .parm="SIZE", .type=(enum anonymous_11)TUINT,
    .var=(void *)&pstdout.blen, .desc="stdout buffer size",
    .set=0 },
    { .shrt=(char)0, .lng="stderr_blen", .parm="SIZE", .type=(enum anonymous_11)TUINT,
    .var=(void *)&pstderr.blen, .desc="stderr buffer size",
    .set=0 },
    { .shrt=(char)0, .lng="stdout_charbased", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&pstdout.charbased,
    .desc="handle stdout char- instead of line-based", .set=0 },
    { .shrt=(char)0, .lng="stderr_charbased", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&pstderr.charbased,
    .desc="handle stderr char- instead of line-based", .set=0 },
    { .shrt=(char)0, .lng="extended-regexp", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&config.extregexp,
    .desc="interpret regexp patterns as extended regular expressions", .set=0 },
    { .shrt=(char)0, .lng=(char *)(void *)0, .parm=(char *)(void *)0,
    .type=(enum anonymous_11)TNONE, .var=(void *)0,
    .desc="Logging options:", .set=0 },
    { .shrt=(char)108, .lng="logfile", .parm="NAME", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&config.logname, .desc="application logfile",
    .set=0 },
    { .shrt=(char)97, .lng="appendlog", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.appendlog, .desc="append to existing logfile",
    .set=0 },
    { .shrt=(char)0, .lng="maxlogsize", .parm="SIZE", .type=(enum anonymous_11)TUINT,
    .var=(void *)&config.maxlogsize, .desc="max. logfile size in KiB (0=no limit, 10-4000000) the file will be truncated if logrename isn't set",
    .set=0 },
    { .shrt=(char)0, .lng="logrename", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.logrename, .desc="rename logfile before replacing it",
    .set=0 },
    { .shrt=(char)0, .lng="circularlog", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.circularlog, .desc="write log in a circular way, keeping the max. size",
    .set=0 },
    { .shrt=(char)0, .lng="oldlogext", .parm="STRING", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&logfile.oldext, .desc="extension for old logfile",
    .set=0 },
    { .shrt=(char)0, .lng="locklogfile", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.locklogfile, .desc="lock logfile when opening it",
    .set=0 },
    { .shrt=(char)0, .lng="warnlogfilelock", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&config.warnlogfilelock,
    .desc="print a warning if current logfile is locked",
    .set=0 },
    { .shrt=(char)110, .lng="print_logname", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&config.printlogname,
    .desc="print logfile name after execution", .set=0 },
    { .shrt=(char)0, .lng="maxaltlogfiles", .parm="COUNT", .type=(enum anonymous_11)TUINT,
    .var=(void *)&config.maxlogfiles, .desc="max # of alternate logfiles on lock",
    .set=0 },
    { .shrt=(char)0, .lng="alignlog", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.alignlog, .desc="use one line for every write in charbased mode",
    .set=0 },
    { .shrt=(char)0, .lng="jointimeout", .parm="TIME", .type=(enum anonymous_11)TUINT,
    .var=(void *)&config.jointimeout, .desc="join timeout for packets with alignlog active",
    .set=0 },
    { .shrt=(char)0, .lng="alignlinebreaks", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&config.alignlinebreaks,
    .desc="align logged line breaks in charbased mode",
    .set=0 },
    { .shrt=(char)116, .lng="logtime", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.logtime, .desc="add timestamp to each logged line",
    .set=0 },
    { .shrt=(char)0, .lng="logreltime", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.logreltime, .desc="log relative time with --logtime",
    .set=0 },
    { .shrt=(char)0, .lng="logenv", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.logenv, .desc="add environment variables to logfile",
    .set=0 },
    { .shrt=(char)112, .lng="stdout_lineprefix", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstdout.lineprefix,
    .desc="logfile line prefix for stdout", .set=0 },
    { .shrt=(char)80, .lng="stderr_lineprefix", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstderr.lineprefix,
    .desc="logfile line prefix for stderr", .set=0 },
    { .shrt=(char)0, .lng=(char *)(void *)0, .parm=(char *)(void *)0,
    .type=(enum anonymous_11)TNONE, .var=(void *)0,
    .desc="Console output options:", .set=0 },
    { .shrt=(char)0, .lng="dumbterm", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.dumbterm, .desc="disable colors for use with dumb terminals",
    .set=0 },
    { .shrt=(char)115, .lng="print_summary", .parm="BOOL",
    .type=(enum anonymous_11)TBOOL, .var=(void *)&config.printsummary,
    .desc="print execution summary", .set=0 },
    { .shrt=(char)102, .lng="stdout_fgcol", .parm="COLOR", .type=(enum anonymous_11)TCOLOR,
    .var=(void *)&pstdout.fgcol, .desc="stdout console foreground color (disable=-1, 0-7)",
    .set=0 },
    { .shrt=(char)70, .lng="stderr_fgcol", .parm="COLOR", .type=(enum anonymous_11)TCOLOR,
    .var=(void *)&pstderr.fgcol, .desc="stderr console foreground color (disable=-1, 0-7)",
    .set=0 },
    { .shrt=(char)98, .lng="stdout_bold", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&pstdout.bold, .desc="bold stdout console font",
    .set=0 },
    { .shrt=(char)66, .lng="stderr_bold", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&pstderr.bold, .desc="bold stderr console font",
    .set=0 },
    { .shrt=(char)114, .lng="stdout_regexp", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstdout.regexp,
    .desc="regular expression to change stdout background color", .set=0 },
    { .shrt=(char)82, .lng="stderr_regexp", .parm="STRING", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&pstderr.regexp, .desc="regular expression to change stderr background color",
    .set=0 },
    { .shrt=(char)0, .lng="stdout_regexp_bgcol", .parm="COLOR",
    .type=(enum anonymous_11)TCOLOR, .var=(void *)&pstdout.regbgcol,
    .desc="stdout console background color on regexp match (disable=-1, 0-7)", .set=0 },
    { .shrt=(char)0, .lng="stderr_regexp_bgcol", .parm="COLOR",
    .type=(enum anonymous_11)TCOLOR, .var=(void *)&pstderr.regbgcol,
    .desc="stderr console background color on regexp match (disable=-1, 0-7)", .set=0 },
    { .shrt=(char)99, .lng="stdout_clip", .parm="LENGTH", .type=(enum anonymous_11)TCLIP,
    .var=(void *)&pstdout.clip, .desc="clip stdout console at column LENGTH (disable=-1, auto=-2)",
    .set=0 },
    { .shrt=(char)67, .lng="stderr_clip", .parm="LENGTH", .type=(enum anonymous_11)TCLIP,
    .var=(void *)&pstderr.clip, .desc="clip stderr console at column LENGTH (disable=-1, auto=-2)",
    .set=0 },
    { .shrt=(char)0, .lng=(char *)(void *)0, .parm=(char *)(void *)0,
    .type=(enum anonymous_11)TNONE, .var=(void *)0,
    .desc="Command execution options:", .set=0 },
    { .shrt=(char)0, .lng="exitonexecfail", .parm="BOOL", .type=(enum anonymous_11)TBOOL,
    .var=(void *)&config.exitonexecfail, .desc="exit if execution of command fails",
    .set=0 },
    { .shrt=(char)0, .lng="preexec", .parm="STRING", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&config.preexeccmd, .desc="command executed before application start",
    .set=0 },
    { .shrt=(char)0, .lng="postexec", .parm="STRING", .type=(enum anonymous_11)TSTRING,
    .var=(void *)&config.postexeccmd, .desc="command executed after application exit",
    .set=0 },
    { .shrt=(char)101, .lng="stdout_execregexp", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstdout.execregexp,
    .desc="regular expression to execute command", .set=0 },
    { .shrt=(char)69, .lng="stderr_execregexp", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstderr.execregexp,
    .desc="regular expression to execute command", .set=0 },
    { .shrt=(char)120, .lng="stdout_execcommand", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstdout.execcommand,
    .desc="command to be executed after stdout regexp match", .set=0 },
    { .shrt=(char)88, .lng="stderr_execregexp", .parm="STRING",
    .type=(enum anonymous_11)TSTRING, .var=(void *)&pstderr.execcommand,
    .desc="command to be executed after stderr regexp match", .set=0 } };
// arglistsize
// file configuration.c line 355
const signed int arglistsize = (signed int)(sizeof(struct anonymous_10 [56l]) /*3136ul*/  / sizeof(struct anonymous_10) /*56ul*/ );
// boolvalues
// file configuration.c line 181
const struct anonymous_1 boolvalues[5l] = { { .string="true", .value=1 }, { .string="false", .value=0 }, { .string="on", .value=1 }, { .string="off", .value=0 }, { .string=(char *)(void *)0, .value=0 } };
// clipvalues
// file configuration.c line 203
const struct anonymous_1 clipvalues[3l] = { { .string="disable", .value=-1 }, { .string="auto", .value=-2 }, { .string=(char *)(void *)0, .value=0 } };
// colorvalues
// file configuration.c line 189
const struct anonymous_1 colorvalues[11l] = { { .string="disable", .value=-1 }, { .string="default", .value=-1 }, { .string="black", .value=0 }, { .string="red", .value=1 }, { .string="green", .value=2 }, { .string="brown", .value=3 }, { .string="blue", .value=4 }, { .string="magenta", .value=5 }, { .string="cyan", .value=6 }, { .string="white", .value=7 }, { .string=(char *)(void *)0, .value=0 } };
// configsearchpath
// file configuration.c line 78
char *configsearchpath[3l] = { "~/.logapprc", "/etc/logapp.conf", "/etc/logapp/logapp.conf" };
// environ
// file logfile.c line 45
extern char **environ;
// logfile_mutex
// file logfile.c line 43
union anonymous_0 logfile_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// multprefixes
// file configuration.c line 209
const struct anonymous_1 multprefixes[8l] = { { .string="", .value=1 }, { .string="k", .value=1000 }, { .string="M", .value=1000000 }, { .string="G", .value=1000000000 }, { .string="ki", .value=1024 }, { .string="Mi", .value=1048576 }, { .string="Gi", .value=1073741824 }, { .string=(char *)(void *)0, .value=0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// string_outofmemory
// file main.c line 52
const char string_outofmemory[29l] = { 'l', 'o', 'g', 'a', 'p', 'p', ' ', 'e', 'r', 'r', 'o', 'r', ':', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\n', 0 };

// __strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 947
static inline unsigned long int __strcspn_c1(const char *__s, signed int __reject)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
    if((signed int)__s[(signed long int)__result] == __reject)
      break;

  return __result;
}

// __strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 958
static inline unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

  }
  return __result;
}

// __strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
static inline unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; !((signed int)__s[(signed long int)__result] == 0); __result = __result + 1ul)
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      break;

    if((signed int)__s[(signed long int)__result] == __reject2)
      break;

    if((signed int)__s[(signed long int)__result] == __reject3)
      break;

  }
  return __result;
}

// __strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1023
static inline unsigned long int __strspn_c1(const char *__s, signed int __accept)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (signed int)__s[(signed long int)__result] == __accept; __result = __result + 1ul)
    ;
  return __result;
}

// __strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1035
static inline unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (_Bool)1; __result = __result + 1ul)
    if(!((signed int)__s[(signed long int)__result] == __accept1))
    {
      if(!((signed int)__s[(signed long int)__result] == __accept2))
        goto __CPROVER_DUMP_L3;

    }


__CPROVER_DUMP_L3:
  ;
  return __result;
}

// __strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1047
static inline unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (_Bool)1; __result = __result + 1ul)
    if(!((signed int)__s[(signed long int)__result] == __accept1))
    {
      if(!((signed int)__s[(signed long int)__result] == __accept2))
      {
        if(!((signed int)__s[(signed long int)__result] == __accept3))
          goto __CPROVER_DUMP_L3;

      }

    }


__CPROVER_DUMP_L3:
  ;
  return __result;
}

// adjust_clipping
// file configuration.h line 212
extern signed int adjust_clipping(void)
{
  signed int return_value_get_display_parameters_1;
  return_value_get_display_parameters_1=get_display_parameters();
  if(!(return_value_get_display_parameters_1 == 0))
  {
    if(pstdout.eclip == 2)
      pstdout.eclip = 0;

    if(pstderr.eclip == 2)
      pstderr.eclip = 0;

    return -1;
  }

  else
  {
    if(pstdout.eclip == 2)
      pstdout.clip = (signed int)app.ptysize->ws_col;

    if(pstderr.eclip == 2)
      pstderr.clip = (signed int)app.ptysize->ws_col;

    if(!(app.pid == 0))
    {
      signed int return_value_ioctl_2;
      return_value_ioctl_2=ioctl(app.pstdout->fh, (unsigned long int)0x5414, (char *)app.ptysize);
      if(!(return_value_ioctl_2 >= 0))
      {
        print((enum anonymous_6)ERROR, "Unable to set window size");
        return -1;
      }

    }

    return 0;
  }
}

// buf_get_char
// file capture.c line 247
signed int buf_get_char(struct anonymous_5 *pipe, char *buf)
{
  signed int i;
  signed int return_value_is_rdbuf_empty_2;
  return_value_is_rdbuf_empty_2=is_rdbuf_empty(pipe);
  if(!(return_value_is_rdbuf_empty_2 == 0))
  {
    pipe->rdbuf.read = pipe->rdbuf.start;
    if(!(pipe->switchtocbmode == 0))
    {
      pipe->charbased = 1;
      pipe->handler = (signed int (*)(void *))handle_cbstream;
      return 0;
    }

    signed long int return_value_read_1;
    return_value_read_1=read(pipe->fh, (void *)pipe->rdbuf.start, (unsigned long int)pipe->rdbuf.len);
    i = (signed int)return_value_read_1;
    if(!(i >= 1))
    {
      pipe->rdbuf.end = pipe->rdbuf.start;
      return i;
    }

    pipe->rdbuf.end = pipe->rdbuf.start + (signed long int)i;
  }

  *buf = *pipe->rdbuf.read;
  pipe->rdbuf.read = pipe->rdbuf.read + 1l;
  return 1;
}

// capture_end
// file capture.h line 24
signed int capture_end(void)
{
  pthread_join(app.pstderr->ct, (void **)(void *)0);
  pthread_join(app.pstdout->ct, (void **)(void *)0);
  free_buffer(app.pstdout);
  free_buffer(app.pstderr);
  return 0;
}

// capture_loop
// file capture.c line 612
signed int capture_loop(struct anonymous_5 *pipe_stdout, struct anonymous_5 *pipe_stderr)
{
  struct anonymous_9 rdfs;
  signed long int flags = (signed long int)0;
  signed int do_stdout_loop = 1;
  signed int do_stderr_loop = 1;
  if(!(pipe_stdout->charbased == 0))
    pipe_stdout->handler = (signed int (*)(void *))handle_cbstream;

  else
    pipe_stdout->handler = (signed int (*)(void *))handle_lbstream;
  if(!(pipe_stderr->charbased == 0))
    pipe_stderr->handler = (signed int (*)(void *))handle_cbstream;

  else
    pipe_stderr->handler = (signed int (*)(void *))handle_lbstream;
  fcntl(pipe_stdout->fh, 3, flags);
  fcntl(pipe_stdout->fh, 4, flags | (signed long int)04000);
  fcntl(pipe_stderr->fh, 3, flags);
  fcntl(pipe_stderr->fh, 4, flags | (signed long int)04000);
  while(!(do_stderr_loop == 0) || !(do_stdout_loop == 0))
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rdfs)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rdfs)->__fds_bits[(signed long int)(pipe_stdout->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rdfs)->__fds_bits[(signed long int)(pipe_stdout->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pipe_stdout->fh % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    (&rdfs)->__fds_bits[(signed long int)(pipe_stderr->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rdfs)->__fds_bits[(signed long int)(pipe_stderr->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << pipe_stderr->fh % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    signed int return_value_select_1;
    return_value_select_1=select(1024, &rdfs, (struct anonymous_9 *)(void *)0, (struct anonymous_9 *)(void *)0, (struct timeval *)(void *)0);
    if(return_value_select_1 >= 1)
    {
      if(!((rdfs.__fds_bits[(signed long int)(pipe_stdout->fh / 8)] & (signed long int)(1UL << pipe_stdout->fh % 8)) == 0l))
      {
        signed int return_value;
        return_value=pipe_stdout->handler((void *)pipe_stdout);
        if(return_value == -1)
        {
          reset_console();
          do_stdout_loop = 0;
          do_stdout_loop = 0;
        }

      }

      if(!((rdfs.__fds_bits[(signed long int)(pipe_stderr->fh / 8)] & (signed long int)(1UL << pipe_stderr->fh % 8)) == 0l))
      {
        signed int return_value_1;
        return_value_1=pipe_stdout->handler((void *)pipe_stderr);
        if(return_value_1 == -1)
        {
          reset_console();
          do_stderr_loop = 0;
          do_stderr_loop = 0;
        }

      }

    }

    else
    {
      do_stdout_loop = 0;
      do_stderr_loop = 0;
    }
  }
  return 0;
}

// capture_start
// file capture.h line 23
signed int capture_start(void)
{
  signed int return_value_prepare_buffer_1;
  return_value_prepare_buffer_1=prepare_buffer(app.pstdout);
  if(!(return_value_prepare_buffer_1 == 0))
    exit(1);

  signed int return_value_prepare_buffer_2;
  return_value_prepare_buffer_2=prepare_buffer(app.pstderr);
  if(!(return_value_prepare_buffer_2 == 0))
    exit(1);

  pthread_create(&app.pstderr->ct, (const union pthread_attr_t *)(void *)0, capture_thread, (void *)app.pstderr);
  pthread_create(&app.pstdout->ct, (const union pthread_attr_t *)(void *)0, capture_thread, (void *)app.pstdout);
  return 0;
}

// capture_thread
// file capture.c line 577
void * capture_thread(void *do_pipe)
{
  struct anonymous_9 fd_pipe;
  struct anonymous_5 *capture_thread__1__pipe = (struct anonymous_5 *)do_pipe;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fd_pipe)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fd_pipe)->__fds_bits[(signed long int)(capture_thread__1__pipe->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fd_pipe)->__fds_bits[(signed long int)(capture_thread__1__pipe->fh / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << capture_thread__1__pipe->fh % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(capture_thread__1__pipe->charbased == 0))
    capture_thread__1__pipe->handler = (signed int (*)(void *))handle_cbstream;

  else
    capture_thread__1__pipe->handler = (signed int (*)(void *))handle_lbstream;
  while((_Bool)1)
  {
    signed int return_value_select_1;
    return_value_select_1=select(capture_thread__1__pipe->fh + 1, &fd_pipe, (struct anonymous_9 *)(void *)0, (struct anonymous_9 *)(void *)0, (struct timeval *)(void *)0);
    if(return_value_select_1 == 1)
    {
      signed int return_value;
      return_value=capture_thread__1__pipe->handler((void *)capture_thread__1__pipe);
      if(return_value == -1)
      {
        reset_console();
        exit(1);
        pthread_exit((void *)0);
        usleep((unsigned int)10000);
      }

    }

    else
      pthread_exit((void *)0);
  }
}

// check_for_disable_keywords
// file configuration.h line 213
extern signed int check_for_disable_keywords(void)
{
  signed int i;
  signed int j;
  signed int key;
  char *toksrc;
  char *tok[50l];
  if(config.disable_keywords == ((char *)NULL))
    return 0;

  else
  {
    char *return_value___strdup_1;
    return_value___strdup_1=__strdup(config.disable_keywords);
    toksrc = return_value___strdup_1;
    key = 0;
    tok[(signed long int)key]=strtok(toksrc, ", ");
    while(!(tok[(signed long int)key] == ((char *)NULL)))
    {
      if(1 + key >= 50)
        break;

      key = key + 1;
      tok[(signed long int)key]=strtok((char *)(void *)0, ", ");
    }
    i = 1;
    for( ; config.disable == 0 && !(i >= app.argc); i = i + 1)
    {
      j = 0;
      for( ; config.disable == 0 && !(j >= key); j = j + 1)
      {
        char *return_value_strstr_2;
        return_value_strstr_2=strstr(app.argv[(signed long int)i], tok[(signed long int)j]);
        if(!(return_value_strstr_2 == ((char *)NULL)))
          config.disable = 1;

      }
    }
    free((void *)toksrc);
    return 0;
  }
}

// cleanup_config
// file configuration.h line 210
extern void cleanup_config(void)
{
  if(!(app.argv == ((char **)NULL)))
  {
    free((void *)app.argv);
    app.argv = (char **)(void *)0;
  }

}

// error_outofmemory
// file main.c line 54
void error_outofmemory(void)
{
  signed int ret;
  signed long int return_value_write_1;
  return_value_write_1=write(2, (const void *)string_outofmemory, sizeof(const char [29l]) /*29ul*/ );
  ret = (signed int)return_value_write_1;
}

// execcmd
// file main.c line 119
signed int execcmd(char *cmd)
{
  signed int return_value_system_1;
  return_value_system_1=system(cmd);
  return return_value_system_1;
}

// fixup_config
// file configuration.h line 209
extern signed int fixup_config(void)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(config.logname);
  if(return_value_strlen_1 == 0ul)
    config.logname = (char *)(void *)0;

  config.maxlogfiles = config.maxlogfiles + 1;
  if(config.maxlogsize == 0)
    logfile.sizelimit = (unsigned int)0;

  else
    if(config.maxlogsize >= 4000001 || !(config.maxlogsize >= 10))
    {
      print((enum anonymous_6)ERROR, "maximum logsize out of range (0=no limit, 10-4000000 KiB)\n");
      return -1;
    }

    else
      logfile.sizelimit = (unsigned int)(config.maxlogsize * 1024);
  if(!(config.usepty == 0))
    app.pstdout->ptyremovecr = config.ptyremovecr;

  signed int return_value_fixup_pipe_2;
  return_value_fixup_pipe_2=fixup_pipe(app.pstdout);
  if(!(return_value_fixup_pipe_2 == 0))
    return -1;

  else
  {
    signed int return_value_fixup_pipe_3;
    return_value_fixup_pipe_3=fixup_pipe(app.pstderr);
    if(!(return_value_fixup_pipe_3 == 0))
      return -1;

    else
    {
      signed int maxindentlen = 15;
      if(!(app.pstderr->lineprefixlen >= app.pstdout->lineprefixlen))
        maxindentlen = maxindentlen + app.pstdout->lineprefixlen;

      else
        maxindentlen = maxindentlen + app.pstderr->lineprefixlen;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc((unsigned long int)(maxindentlen + 1));
      app.logfile->indent = (char *)return_value_malloc_4;
      if(app.logfile->indent == ((char *)NULL))
      {
        error_outofmemory();
        return -1;
      }

      else
      {
        memset((void *)app.logfile->indent, 32, (unsigned long int)maxindentlen);
        return 0;
      }
    }
  }
}

// fixup_pipe
// file configuration.c line 508
static signed int fixup_pipe(struct anonymous_5 *pipe)
{
  if(!(config.detectescape == 0))
    pipe->detectescape = 1;

  _Bool tmp_if_expr_1;
  if(!(pipe->fgcol >= -1))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = pipe->fgcol > 7 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_1)
  {
    print((enum anonymous_6)ERROR, "%s foreground color out of range\n", pipe->name);
    return -1;
  }

  else
  {
    if(!(pipe->bgcol >= -1))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = pipe->bgcol > 7 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      print((enum anonymous_6)ERROR, "%s background color out of range\n", pipe->name);
      return -1;
    }

    else
    {
      if(pipe->regbgcol == -1)
        pipe->regexp = (char *)(void *)0;

      if(!(pipe->regbgcol >= -1))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = pipe->regbgcol > 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        print((enum anonymous_6)ERROR, "%s regexp background color out of range\n", pipe->name);
        return -1;
      }

      else
        if(!(pipe->bgcol == pipe->regbgcol))
        {
          if(pipe->bgcol == -1)
            pipe->bgcol = 9;

          if(pipe->regbgcol == -1)
            pipe->regbgcol = 9;

        }

      if(!(pipe->clip == -1))
      {
        if(pipe->clip == -2)
          goto __CPROVER_DUMP_L15;

      }

      else
      {
        pipe->eclip = 0;
        pipe->clip = 80;
        goto __CPROVER_DUMP_L18;

      __CPROVER_DUMP_L15:
        ;
        pipe->eclip = 2;
        pipe->clip = 80;
        goto __CPROVER_DUMP_L18;
      }
      if(!(pipe->clip >= 0))
        pipe->eclip = 0;

      else
        pipe->eclip = 1;

    __CPROVER_DUMP_L18:
      ;
      if(!(pipe->lineprefix == ((char *)NULL)))
      {
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(pipe->lineprefix);
        pipe->lineprefixlen = (signed int)return_value_strlen_4;
        if(pipe->lineprefixlen == 0)
        {
          free((void *)pipe->lineprefix);
          pipe->lineprefix = (char *)(void *)0;
        }

      }

      signed int len;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(pipe->escreset);
      pipe->escresetlen = (signed int)return_value_strlen_5;
      len = pipe->escresetlen;
      if(pipe->fgcol >= 0)
        len = len + 5;

      if(pipe->regbgcol >= 0)
        len = len + 5;

      if(!(pipe->bold == 0))
        len = len + 4;

      void *return_value_malloc_6;
      return_value_malloc_6=malloc((unsigned long int)(len + 1));
      pipe->esccolor = (char *)return_value_malloc_6;
      pipe->esccolorlen = 0;
      if(pipe->esccolor == ((char *)NULL))
      {
        error_outofmemory();
        return -1;
      }

      else
      {
        memcpy((void *)pipe->esccolor, (const void *)pipe->escreset, (unsigned long int)pipe->escresetlen);
        pipe->esccolorlen = pipe->esccolorlen + pipe->escresetlen;
        if(pipe->fgcol >= 0)
        {
          snprintf(pipe->esccolor + (signed long int)pipe->esccolorlen, (unsigned long int)6, "\033[3%dm", pipe->fgcol);
          pipe->esccolorlen = pipe->esccolorlen + 5;
        }

        if(pipe->regbgcol >= 0)
        {
          pipe->bgesccolor = pipe->esccolor + (signed long int)pipe->esccolorlen + (signed long int)3;
          snprintf(pipe->esccolor + (signed long int)pipe->esccolorlen, (unsigned long int)6, "\033[4%dm", pipe->bgcol);
          pipe->esccolorlen = pipe->esccolorlen + 5;
        }

        else
          pipe->bgesccolor = (char *)(void *)0;
        if(!(pipe->bold == 0))
        {
          snprintf(pipe->esccolor + (signed long int)pipe->esccolorlen, (unsigned long int)5, "\033[1m");
          pipe->esccolorlen = pipe->esccolorlen + 4;
        }

        signed int regexp_cflags = ((1 << 1) << 1) << 1 | (1 << 1) << 1;
        if(!(config.extregexp == 0))
          regexp_cflags = regexp_cflags | 1;

        if(!(pipe->regexp == ((char *)NULL)))
        {
          unsigned long int return_value_strlen_8;
          return_value_strlen_8=strlen(pipe->regexp);
          if(!(return_value_strlen_8 == 0ul))
          {
            signed int return_value_regcomp_7;
            return_value_regcomp_7=regcomp(&pipe->preg, pipe->regexp, regexp_cflags);
            if(!(return_value_regcomp_7 == 0))
            {
              print((enum anonymous_6)ERROR, "unable to process regular expression for %s\n", pipe->name);
              return -1;
            }

          }

          else
            pipe->regexp = (char *)(void *)0;
        }

        if(!(pipe->execregexp == ((char *)NULL)))
        {
          unsigned long int return_value_strlen_10;
          return_value_strlen_10=strlen(pipe->execregexp);
          if(!(return_value_strlen_10 == 0ul))
          {
            signed int return_value_regcomp_9;
            return_value_regcomp_9=regcomp(&pipe->pexecreg, pipe->execregexp, regexp_cflags);
            if(!(return_value_regcomp_9 == 0))
            {
              print((enum anonymous_6)ERROR, "unable to process regular expression for %s\n", pipe->name);
              return -1;
            }

          }

          else
            pipe->execregexp = (char *)(void *)0;
          if(pipe->execcommand == ((char *)NULL))
            pipe->execregexp = (char *)(void *)0;

          else
          {
            unsigned long int return_value_strlen_11;
            return_value_strlen_11=strlen(pipe->execcommand);
            if(return_value_strlen_11 == 0ul)
              pipe->execregexp = (char *)(void *)0;

          }
        }

        return 0;
      }
    }
  }
}

// fork_child
// file main.c line 245
signed int fork_child()
{
  signed int pipe_stdout[2l];
  signed int pipe_stderr[2l];
  if(config.disable == 0)
  {
    get_display_parameters();
    if(!(app.ptytermios == ((struct termios *)NULL)))
      memcpy((void *)app.ptytermios_bak, (const void *)app.ptytermios, sizeof(struct termios) /*60ul*/ );

    if(!(config.usepty == 0))
    {
      signed int return_value_openpty_2;
      return_value_openpty_2=openpty(&pipe_stdout[(signed long int)0], &pipe_stdout[(signed long int)1], (char *)(void *)0, app.ptytermios, app.ptysize);
      if(return_value_openpty_2 == -1)
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        print((enum anonymous_6)ERROR, "opening PTY for %s failed with error %d\n", app.pstdout->name, *return_value___errno_location_1);
        app.pstdout->ptyremovecr = 0;
      }

    }

    else
    {
      signed int return_value_pipe_3;
      return_value_pipe_3=pipe(pipe_stdout);
      if(!(return_value_pipe_3 >= 0))
      {
        print((enum anonymous_6)ERROR, "creating stdout pipe handler\n");
        return -1;
      }

    }
    signed int return_value_pipe_4;
    return_value_pipe_4=pipe(pipe_stderr);
    if(!(return_value_pipe_4 >= 0))
    {
      print((enum anonymous_6)ERROR, "creating stderr pipe handler\n");
      return -1;
    }

  }

  signal(18, sig_handler);
  fflush((struct _IO_FILE *)(void *)0);
  app.pid=fork();
  if(!(app.pid >= 0))
  {
    print((enum anonymous_6)ERROR, "fork error\n");
    return -1;
  }

  else
  {
    if(app.pid >= 1)
    {
      if(config.disable == 0)
      {
        close(pipe_stdout[(signed long int)1]);
        close(pipe_stderr[(signed long int)1]);
        app.pstdout->fh = pipe_stdout[(signed long int)0];
        app.pstderr->fh = pipe_stderr[(signed long int)0];
      }

      while(app.active == 0 && app.doexit == 0)
        usleep((unsigned int)10000);
      kill(app.pid, 18);
      time(&app.starttime);
      gettimeofday(&app.toffset, (struct timezone *)(void *)0);
    }

    else
      if(app.pid == 0)
      {
        if(config.disable == 0)
        {
          close(pipe_stdout[(signed long int)0]);
          close(pipe_stderr[(signed long int)0]);
          if(!(pipe_stdout[1l] == 1))
          {
            signed int return_value_dup2_5;
            return_value_dup2_5=dup2(pipe_stdout[(signed long int)1], 1);
            if(!(return_value_dup2_5 == 1))
              print((enum anonymous_6)ERROR, "redirecting stdout failed");

            close(pipe_stdout[(signed long int)1]);
          }

          if(!(pipe_stderr[1l] == 2))
          {
            signed int return_value_dup2_6;
            return_value_dup2_6=dup2(pipe_stderr[(signed long int)1], 2);
            if(!(return_value_dup2_6 == 2))
              print((enum anonymous_6)ERROR, "redirecting stderr failed");

            close(pipe_stderr[(signed long int)1]);
          }

          if(!(app.ptytermios == ((struct termios *)NULL)))
            tcsetattr(0, 1, app.ptytermios);

        }

        signed int return_value_getppid_7;
        return_value_getppid_7=getppid();
        kill(return_value_getppid_7, 18);
        while(app.active == 0 && app.doexit == 0)
          usleep((unsigned int)10000);
        signed int return_value_execvp_8;
        return_value_execvp_8=execvp(app.exe, app.argv);
        if(!(return_value_execvp_8 >= 0))
        {
          print((enum anonymous_6)ERROR, "executing application %s failed\n", app.exe);
          exit(1);
        }

      }

      else
      {
        print((enum anonymous_6)ERROR, "forking process failed\n");
        return -1;
      }
    return 0;
  }
}

// free_buffer
// file capture.c line 404
void free_buffer(struct anonymous_5 *pipe)
{
  if(!(pipe->dbuf == ((char *)NULL)))
  {
    free((void *)pipe->dbuf);
    if(pipe->dbuf == pipe->esccolor)
      pipe->esccolor = (char *)(void *)0;

    pipe->dbuf = (char *)(void *)0;
    pipe->buf = (char *)(void *)0;
  }

  if(!(pipe->rdbuf.start == ((char *)NULL)))
  {
    free((void *)pipe->rdbuf.start);
    pipe->rdbuf.start = (char *)(void *)0;
    pipe->rdbuf.read = (char *)(void *)0;
    pipe->rdbuf.end = (char *)(void *)0;
  }

}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 466
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat_1;
  return_value___fxstat_1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat_1;
}

// get_argid
// file configuration.c line 759
signed int get_argid(char *arg, signed int isshort)
{
  signed int i;
  signed int tmp_statement_expression_1;
  if(arg == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= arglistsize); i = i + 1)
    {
      if(!(isshort == 0))
      {
        if(arglist[(signed long int)i].shrt == 0)
          goto __CPROVER_DUMP_L5;

        if(arglist[(signed long int)i].shrt == *arg)
          return i;

      }

      else
        if(!(arglist[(signed long int)i].lng == ((char *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_2;
          return_value___builtin_strcmp_2=__builtin_strcmp(arglist[(signed long int)i].lng, arg);
          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
          if(tmp_statement_expression_1 == 0)
            return i;

        }


    __CPROVER_DUMP_L5:
      ;
    }
    return -1;
  }
}

// get_argvalue
// file configuration.c line 844
signed int get_argvalue(signed int priority, signed int argid, signed int *argp, signed int argc, char **argv, char *value)
{
  signed int tmpint;
  signed int ret;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  char *return_value___strdup_3;
  signed int return_value_string2numvalue_4;
  if(arglist[(signed long int)argid].var == NULL)
    return -1;

  else
  {
    if(!(argv == ((char **)NULL)))
      tmp_if_expr_2 = value == &argv[(signed long int)*argp][(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      if((signed int)arglist[(signed long int)argid].type == TBOOL)
        value = boolvalues[(signed long int)0].string;

    }

    else
    {
      if(!(value == ((char *)NULL)))
        tmp_if_expr_1 = (signed int)arglist[(signed long int)argid].type == TNONE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        print((enum anonymous_6)ERROR, "no value expected\n");
        return -1;
      }

      else
        if(value == ((char *)NULL))
        {
          if(!((signed int)arglist[(signed long int)argid].type == TNONE))
          {
            if(!(argp == ((signed int *)NULL)))
            {
              if(!(*argp >= argc + -1))
              {
                *argp = *argp + 1;
                if(!(argv == ((char **)NULL)))
                {
                  if(!((signed int)*argv[(signed long int)*argp] == 45))
                    value = argv[(signed long int)*argp];

                }

              }

            }

            if(value == ((char *)NULL))
            {
              print((enum anonymous_6)ERROR, "parameter needs value\n");
              return -1;
            }

          }

        }

    }
    switch((signed int)arglist[(signed long int)argid].type)
    {
      case TNONE:
      {
        if(!(priority >= arglist[(signed long int)argid].set))
          break;

        *((signed int *)arglist[(signed long int)argid].var) = 1;
        break;
      }
      case TCLIP:

      case TCOLOR:

      case TINT:

      case TUINT:
      {
        switch((signed int)arglist[(signed long int)argid].type)
        {
          case TCLIP:
          {
            ret=string2numvalue(value, &tmpint, clipvalues, multprefixes);
            break;
          }
          case TCOLOR:
          {
            ret=string2numvalue(value, &tmpint, colorvalues, multprefixes);
            break;
          }
          default:
            ret=string2numvalue(value, &tmpint, (const struct anonymous_1 *)(void *)0, multprefixes);
        }
        if(!(ret == 0))
          return -1;

        if((signed int)arglist[(signed long int)argid].type == TUINT)
        {
          if(!(tmpint >= 0))
          {
            print((enum anonymous_6)ERROR, "negative value not allowed for this parameter\n");
            return -1;
          }

        }

        if(!(priority >= arglist[(signed long int)argid].set))
          break;

        *((signed int *)arglist[(signed long int)argid].var) = tmpint;
        break;
      }
      case TSTRING:
      {
        if(!(priority >= arglist[(signed long int)argid].set))
          break;

        if(!(*((char **)arglist[(signed long int)argid].var) == ((char *)NULL)))
        {
          if(arglist[(signed long int)argid].set >= 1)
            free((void *)*((char **)arglist[(signed long int)argid].var));

        }

        return_value___strdup_3=__strdup(value);
        *((char **)arglist[(signed long int)argid].var) = return_value___strdup_3;
        if(*((char **)arglist[(signed long int)argid].var) == ((char *)NULL))
        {
          error_outofmemory();
          return -1;
        }

        break;
      }
      case TBOOL:
      {
        return_value_string2numvalue_4=string2numvalue(value, &tmpint, boolvalues, (const struct anonymous_1 *)(void *)0);
        if(!(return_value_string2numvalue_4 == 0))
          return -1;

        if(tmpint >= 2 || !(tmpint >= 0))
        {
          print((enum anonymous_6)ERROR, "invalid boolean value\n");
          return -1;
        }

        if(!(priority >= arglist[(signed long int)argid].set))
          break;

        *((signed int *)arglist[(signed long int)argid].var) = tmpint;
        break;
      }
      default:
      {
        print((enum anonymous_6)ERROR, "unknown argument type\n");
        return -1;
      }
    }
    if(!(arglist[(signed long int)argid].set >= priority))
      arglist[(signed long int)argid].set = priority;

    return 0;
  }
}

// get_config
// file configuration.h line 208
extern signed int get_config(void)
{
  struct _IO_FILE *conffile = (struct _IO_FILE *)(void *)0;
  char *filename;
  char *appconfig_section = (char *)(void *)0;
  char linebuf[251l];
  if(config.custconfigfile == ((char *)NULL))
  {
    unsigned int i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 3ul); i = i + 1u)
    {
      filename=get_longpath(configsearchpath[(signed long int)i]);
      if(filename == ((char *)NULL))
        return -1;

      conffile=fopen(filename, "r");
      if(!(conffile == ((struct _IO_FILE *)NULL)))
        break;

    }
  }

  else
  {
    filename=get_longpath(config.custconfigfile);
    if(!(filename == ((char *)NULL)))
      conffile=fopen(filename, "r");

    if(conffile == ((struct _IO_FILE *)NULL))
    {
      print((enum anonymous_6)ERROR, "unable to open provided configuration file\n");
      return -1;
    }

  }
  char *return_value_fgets_1;
  unsigned long int tmp_statement_expression_2;
  if(conffile == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    if(config.configsection == ((char *)NULL))
      config.configsection = app.exe;

    config.configfile = filename;
    do
    {
      return_value_fgets_1=fgets(linebuf, 251, conffile);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      char __r0;
      char __r1;
      char __r2;
      unsigned long int return_value___builtin_strcspn_3;
      return_value___builtin_strcspn_3=__builtin_strcspn(linebuf, "#\n");
      tmp_statement_expression_2 = return_value___builtin_strcspn_3;
      linebuf[(signed long int)tmp_statement_expression_2] = (char)0;
      signed int return_value_parse_configline_4;
      return_value_parse_configline_4=parse_configline(linebuf, &appconfig_section);
      if(!(return_value_parse_configline_4 == 0))
        return -1;

    }
    while((_Bool)1);
    if(!(appconfig_section == ((char *)NULL)))
      free((void *)appconfig_section);

    fclose(conffile);
    return 0;
  }
}

// get_display_parameters
// file configuration.h line 211
extern signed int get_display_parameters(void)
{
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(1, (unsigned long int)0x5413, (char *)app.ptysize);
  if(!(return_value_ioctl_3 >= 0))
  {
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(2, (unsigned long int)0x5413, (char *)app.ptysize);
    if(!(return_value_ioctl_2 >= 0))
    {
      signed int return_value_ioctl_1;
      return_value_ioctl_1=ioctl(0, (unsigned long int)0x5413, (char *)app.ptysize);
      if(!(return_value_ioctl_1 >= 0))
      {
        app.ptysize = (struct winsize *)(void *)0;
        app.ptytermios = (struct termios *)(void *)0;
        return -1;
      }

    }

  }

  signed int return_value_tcgetattr_6;
  return_value_tcgetattr_6=tcgetattr(1, app.ptytermios);
  if(!(return_value_tcgetattr_6 >= 0))
  {
    signed int return_value_tcgetattr_5;
    return_value_tcgetattr_5=tcgetattr(2, app.ptytermios);
    if(!(return_value_tcgetattr_5 >= 0))
    {
      signed int return_value_tcgetattr_4;
      return_value_tcgetattr_4=tcgetattr(0, app.ptytermios);
      if(!(return_value_tcgetattr_4 >= 0))
      {
        print((enum anonymous_6)ERROR, "unable to get window termios\n");
        app.ptytermios = (struct termios *)(void *)0;
        return -1;
      }

    }

  }

  return 0;
}

// get_lock
// file logfile.c line 612
signed int get_lock(struct anonymous_7 *logfile)
{
  struct flock lock;
  if(config.locklogfile == 0)
    return 0;

  else
  {
    lock.l_type = (signed short int)1;
    lock.l_start = (signed long int)0;
    lock.l_whence = (signed short int)0;
    lock.l_len = (signed long int)0;
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(logfile->fh, 6, &lock);
    return return_value_fcntl_1;
  }
}

// get_longpath
// file configuration.c line 479
extern char * get_longpath(const char *filename)
{
  char *home;
  char *longpath;
  signed int return_value_strncmp_5;
  return_value_strncmp_5=strncmp(filename, "~/", (unsigned long int)2);
  if(return_value_strncmp_5 == 0)
  {
    home=getenv("HOME");
    if(home == ((char *)NULL))
      home = "./";

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(home);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(filename);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1);
    longpath = (char *)return_value_malloc_3;
    if(!(longpath == ((char *)NULL)))
    {
      strcpy(longpath, home);
      strcat(longpath, "/");
      strcat(longpath, filename + (signed long int)2);
    }

  }

  else
  {
    char *return_value___strdup_4;
    return_value___strdup_4=__strdup(filename);
    longpath = return_value___strdup_4;
  }
  if(longpath == ((char *)NULL))
  {
    error_outofmemory();
    return (char *)(void *)0;
  }

  else
    return longpath;
}

// handle_cbstream
// file capture.c line 423
signed int handle_cbstream(struct anonymous_5 *pipe)
{
  if(!(pipe->memcr == 0))
    *pipe->buf = (char)13;

  signed long int return_value_read_6;
  return_value_read_6=read(pipe->fh, (void *)(pipe->buf + (signed long int)pipe->memcr), (unsigned long int)(pipe->blen - pipe->memcr));
  pipe->bfill = (signed int)return_value_read_6;
  signed int tmp_post_1;
  if(pipe->bfill >= 1)
  {
    pipe->bfill = pipe->bfill + pipe->memcr;
    if(!(pipe->ptyremovecr == 0))
    {
      signed int i;
      signed int lbo = 0;
      char *bufa = pipe->buf;
      char *bufb = pipe->buf;
      i = 0;
      for( ; !(i >= pipe->bfill + -1); i = i + 1)
      {
        *bufb = *bufa;
        bufa = bufa + 1l;
        bufb = bufb + 1l;
        if((signed int)*bufa == 10)
        {
          if((signed int)bufa[-1l] == 13)
            bufb = bufb - 1l;

          if(!(config.alignlinebreaks == 0) && !(lbo >= 8))
          {
            tmp_post_1 = lbo;
            lbo = lbo + 1;
            pipe->linebreakpos[(signed long int)tmp_post_1] = (signed int)((bufb - pipe->buf) + (signed long int)1);
          }

        }

      }
      pipe->bfill = pipe->bfill - (signed int)(bufa - bufb);
      *bufb = *bufa;
      pipe->linebreakpos[(signed long int)lbo] = 0;
      if(pipe->linebreakpos[0l] == 0)
      {
        pipe->linebreakpos[(signed long int)0] = pipe->bfill;
        pipe->linebreakpos[(signed long int)1] = 0;
      }

      if((signed int)pipe->buf[(signed long int)(pipe->bfill + -1)] == 13)
      {
        pipe->memcr = 1;
        pipe->bfill = pipe->bfill - 1;
        if(!(pipe->bfill >= 1))
          return 0;

      }

      else
        pipe->memcr = 0;
    }

    signed long int return_value_write_2;
    return_value_write_2=write(pipe->cfhno, (const void *)pipe->buf, (unsigned long int)pipe->bfill);
    if(return_value_write_2 == -1l)
    {
      print((enum anonymous_6)ERROR, "Problem writing data to screen for %s\n", pipe->name);
      return -1;
    }

    signed int return_value_logfile_write_3;
    return_value_logfile_write_3=logfile_write(app.logfile, pipe);
    if(!(return_value_logfile_write_3 == 0))
    {
      print((enum anonymous_6)ERROR, "error writing logfile\n");
      return -1;
    }

  }

  else
  {
    if(app.active == 0)
    {
      if(!(pipe->memcr == 0))
      {
        pipe->bfill = 1;
        signed long int return_value_write_4;
        return_value_write_4=write(pipe->cfhno, (const void *)pipe->buf, (unsigned long int)pipe->bfill);
        if(return_value_write_4 == -1l)
        {
          print((enum anonymous_6)ERROR, "Problem writing data to screen for %s\n", pipe->name);
          return -1;
        }

        signed int return_value_logfile_write_5;
        return_value_logfile_write_5=logfile_write(app.logfile, pipe);
        if(!(return_value_logfile_write_5 == 0))
        {
          print((enum anonymous_6)ERROR, "error writing logfile\n");
          return -1;
        }

      }

      return 1;
    }

    return 2;
  }
  return 0;
}

// handle_lbstream
// file capture.c line 527
signed int handle_lbstream(struct anonymous_5 *pipe)
{
  pipe->state=read_pipe(pipe);
  if(pipe->state >= 1)
  {
    signed int clearbuf;
    signed int return_value_logfile_write_1;
    return_value_logfile_write_1=logfile_write(app.logfile, pipe);
    if(!(return_value_logfile_write_1 == 0))
    {
      print((enum anonymous_6)ERROR, "error writing logfile\n");
      return -1;
    }

    clearbuf=print_stream(pipe);
    if(!(clearbuf >= 0))
    {
      print((enum anonymous_6)ERROR, "error printing %s output\n", pipe->name);
      return -1;
    }

    if(!(clearbuf == 0))
      pipe->bfill = 0;

    if(!(pipe->execregexp == ((char *)NULL)))
    {
      signed int return_value_regexec_2;
      return_value_regexec_2=regexec(&pipe->pexecreg, pipe->buf, (unsigned long int)pipe->bfill, (struct anonymous_4 *)(void *)0, 0);
      if(return_value_regexec_2 == 0)
      {
        signed int ret;
        ret=execcmd(pipe->execcommand);
        if(!(ret == 0))
        {
          print((enum anonymous_6)(config.exitonexecfail != 0 ? ERROR : WARNING), "command \"%s\" returned 0x%x\n", pipe->execcommand, ret);
          if(!(config.exitonexecfail == 0))
            exit(1);

        }

      }

    }

  }

  else
  {
    signed int return_value_is_rdbuf_empty_3;
    return_value_is_rdbuf_empty_3=is_rdbuf_empty(pipe);
    if(return_value_is_rdbuf_empty_3 == 0)
      return 0;

    if(app.active == 0)
      return 1;

    return 2;
  }
  return 0;
}

// is_rdbuf_empty
// file capture.c line 242
inline signed int is_rdbuf_empty(struct anonymous_5 *pipe)
{
  return (signed int)(pipe->rdbuf.read >= pipe->rdbuf.end);
}

// logfile_add_footer
// file logfile.c line 238
static signed int logfile_add_footer(struct anonymous_7 *logfile)
{
  signed int len = 0;
  signed int tmplen = 0;
  signed long int sec;
  struct tm *loctime;
  char buf[81l];
  char tmp[51l];
  signed long int return_value_write_1;
  if(!(logfile->addnewline == 0))
  {
    return_value_write_1=write(logfile->fh, (const void *)"\n", (unsigned long int)1);
    if(!(return_value_write_1 == -1l))
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    buf[(signed long int)80] = (char)0;
    signed long int return_value_time_3;
    return_value_time_3=time(&sec);
    if(return_value_time_3 >= 0l)
    {
      loctime=localtime(&sec);
      unsigned long int return_value_strftime_2;
      return_value_strftime_2=strftime(tmp, (unsigned long int)50, "%Y-%m-%d %T %Z", loctime);
      len = (signed int)return_value_strftime_2;
    }

    if(!(len >= 1) || !(sec >= 0l))
    {
      tmp[(signed long int)0] = (char)0;
      len = 0;
    }

    snprintf(buf, (unsigned long int)80, "%s %s\n", logfile->foot, (const void *)tmp);
    if(len >= 81 || !(len >= 0))
      return -1;

    else
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(logfile->foot);
      len = len + (signed int)(return_value_strlen_4 + (unsigned long int)2);
      signed long int return_value_write_5;
      return_value_write_5=write(logfile->fh, (const void *)buf, (unsigned long int)len);
      if(return_value_write_5 == -1l)
        return -1;

      else
      {
        len=snprintf(buf, (unsigned long int)80, "%s application exit status: ", logfile->foot);
        if(len >= 81 || !(len >= 0))
          return -1;

        else
        {
          /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_2
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
          ;
          if((0x7f & app.exit_state) == 0)
            tmplen=snprintf(buf + (signed long int)len, (unsigned long int)(80 - len), "%d\n", (((union anonymous_2){ .__in=app.exit_state }).__i & 0xff00) >> 8);

          else
            if((signed int)((127 & (signed char)app.exit_state) + 1) >> 1 >= 1)
              tmplen=snprintf(buf + (signed long int)len, (unsigned long int)(80 - len), "abnormal termination (signal = %d)\n", ((union anonymous_2){ .__in=app.exit_state }).__i & 0x7f);

            else
            {
              signed int return_value_snprintf_6;
              return_value_snprintf_6=snprintf(buf + (signed long int)len, (unsigned long int)(80 - len), "unknown\n");
              tmplen = tmplen + return_value_snprintf_6;
            }
          if(tmplen >= 81 || !(tmplen >= 0))
            return -1;

          else
          {
            len = len + tmplen;
            signed long int return_value_write_7;
            return_value_write_7=write(logfile->fh, (const void *)buf, (unsigned long int)len);
            if(return_value_write_7 == -1l)
              return -1;

            else
            {
              len=snprintf(buf, (unsigned long int)80, "%s %d lines output (%d stdout, %d stderr)\n", logfile->foot, app.pstdout->linecount + app.pstderr->linecount, app.pstdout->linecount, app.pstderr->linecount);
              if(len >= 81 || !(len >= 0))
                return -1;

              else
              {
                signed long int return_value_write_8;
                return_value_write_8=write(logfile->fh, (const void *)buf, (unsigned long int)len);
                if(return_value_write_8 == -1l)
                  return -1;

                else
                {
                  if(app.starttime >= 0l && sec >= app.starttime)
                  {
                    len=snprintf(buf, (unsigned long int)80, "%s execution time was %us\n", logfile->foot, (unsigned int)(sec - app.starttime));
                    if(len >= 81 || !(len >= 0))
                      return -1;

                    signed long int return_value_write_9;
                    return_value_write_9=write(logfile->fh, (const void *)buf, (unsigned long int)len);
                    if(return_value_write_9 == -1l)
                      return -1;

                  }

                  else
                    print((enum anonymous_6)ERROR, "problem calculating execution time\n");
                  len=snprintf(buf, (unsigned long int)80, "%s %s\n", logfile->foot, app.exe);
                  if(len >= 81 || !(len >= 0))
                    return -1;

                  else
                  {
                    signed long int return_value_write_10;
                    return_value_write_10=write(logfile->fh, (const void *)buf, (unsigned long int)len);
                    if(return_value_write_10 == -1l)
                      return -1;

                    else
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// logfile_add_header
// file logfile.c line 52
static signed int logfile_add_header(struct anonymous_7 *logfile)
{
  signed int ret;
  signed int len;
  signed int headlen;
  signed int i;
  struct tm *loctime;
  char buf[81l];
  char tmp[51l];
  char pwd[501l];
  signed long int return_value_lseek_3;
  return_value_lseek_3=lseek(logfile->fh, (signed long int)0, 2);
  if(!(return_value_lseek_3 == 0l))
  {
    signed long int return_value_write_1;
    return_value_write_1=write(logfile->fh, (const void *)"\n", (unsigned long int)1);
    if(return_value_write_1 == -1l)
      return -1;

    signed int return_value_logfile_check_size_2;
    return_value_logfile_check_size_2=logfile_check_size(logfile, 0, (unsigned int)(80 * 2));
    if(!(return_value_logfile_check_size_2 == 0))
    {
      print((enum anonymous_6)ERROR, "Problem while checking/resizing logfile\n");
      return -1;
    }

  }

  buf[(signed long int)80] = (char)0;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(logfile->head);
  headlen = (signed int)return_value_strlen_4;
  len=snprintf(buf, (unsigned long int)80, "%s %s\n", logfile->head, app.exe);
  signed long int return_value_write_11;
  if(len >= 81 || !(len >= 0))
    return -1;

  else
  {
    signed long int return_value_write_5;
    return_value_write_5=write(logfile->fh, (const void *)buf, (unsigned long int)len);
    if(return_value_write_5 == -1l)
      return -1;

    else
    {
      i = 1;
      for( ; !(i >= app.argc); i = i + 1)
      {
        signed long int return_value_write_6;
        return_value_write_6=write(logfile->fh, (const void *)logfile->head, (unsigned long int)headlen);
        if(return_value_write_6 == -1l)
          return -1;

        len=snprintf(buf, (unsigned long int)80, " arg[%d] = \"", i);
        if(len >= 81 || !(len >= 0))
          return -1;

        signed long int return_value_write_7;
        return_value_write_7=write(logfile->fh, (const void *)buf, (unsigned long int)len);
        if(return_value_write_7 == -1l)
          return -1;

        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(app.argv[(signed long int)i]);
        signed long int return_value_write_9;
        return_value_write_9=write(logfile->fh, (const void *)app.argv[(signed long int)i], return_value_strlen_8);
        if(return_value_write_9 == -1l)
          return -1;

        signed long int return_value_write_10;
        return_value_write_10=write(logfile->fh, (const void *)"\"", (unsigned long int)1);
        if(!(return_value_write_10 == 1l))
          return -1;

        if(!(1 + i >= app.argc))
        {
          return_value_write_11=write(logfile->fh, (const void *)"\n", (unsigned long int)1);
          if(!(return_value_write_11 == 1l))
            return -1;

        }

      }
      if(!(app.argc >= 2))
      {
        signed long int return_value_write_12;
        return_value_write_12=write(logfile->fh, (const void *)logfile->head, (unsigned long int)headlen);
        if(return_value_write_12 == -1l)
          return -1;

        signed long int return_value_write_13;
        return_value_write_13=write(logfile->fh, (const void *)" <no command line options>", (unsigned long int)26);
        if(!(return_value_write_13 == 26l))
          return -1;

      }

      signed long int return_value_write_14;
      return_value_write_14=write(logfile->fh, (const void *)"\n", (unsigned long int)1);
      if(!(return_value_write_14 == 1l))
        return -1;

      else
      {
        len=snprintf(buf, (unsigned long int)80, "%s pwd = ", logfile->head);
        if(len >= 81 || !(len >= 0))
          return -1;

        else
        {
          signed long int return_value_write_15;
          return_value_write_15=write(logfile->fh, (const void *)buf, (unsigned long int)len);
          if(return_value_write_15 == -1l)
            return -1;

          else
          {
            char *return_value_getcwd_21;
            return_value_getcwd_21=getcwd(pwd, (unsigned long int)500);
            if(return_value_getcwd_21 == ((char *)NULL))
            {
              signed long int return_value_write_16;
              return_value_write_16=write(logfile->fh, (const void *)"<unable to get working directory>\n", (unsigned long int)34);
              if(!(return_value_write_16 == 34l))
                return -1;

            }

            else
            {
              unsigned long int return_value_strlen_17;
              return_value_strlen_17=strlen(pwd);
              pwd[(signed long int)(return_value_strlen_17 + (unsigned long int)1)] = (char)0;
              unsigned long int return_value_strlen_18;
              return_value_strlen_18=strlen(pwd);
              pwd[(signed long int)return_value_strlen_18] = (char)10;
              unsigned long int return_value_strlen_19;
              return_value_strlen_19=strlen(pwd);
              signed long int return_value_write_20;
              return_value_write_20=write(logfile->fh, (const void *)pwd, return_value_strlen_19);
              if(return_value_write_20 == -1l)
                return -1;

            }
            if(!(config.logenv == 0))
            {
              i = 0;
              for( ; !(environ[(signed long int)i] == ((char *)NULL)); i = i + 1)
              {
                signed long int return_value_write_22;
                return_value_write_22=write(logfile->fh, (const void *)logfile->head, (unsigned long int)headlen);
                if(return_value_write_22 == -1l)
                  return -1;

                len=snprintf(buf, (unsigned long int)80, " env[%d] = \"", i);
                if(len >= 81 || !(len >= 0))
                  return -1;

                signed long int return_value_write_23;
                return_value_write_23=write(logfile->fh, (const void *)buf, (unsigned long int)len);
                if(return_value_write_23 == -1l)
                  return -1;

                unsigned long int return_value_strlen_24;
                return_value_strlen_24=strlen(environ[(signed long int)i]);
                signed long int return_value_write_25;
                return_value_write_25=write(logfile->fh, (const void *)environ[(signed long int)i], return_value_strlen_24);
                if(return_value_write_25 == -1l)
                  return -1;

                signed long int return_value_write_26;
                return_value_write_26=write(logfile->fh, (const void *)"\"\n", (unsigned long int)2);
                if(!(return_value_write_26 == 2l))
                  return -1;

              }
            }

            loctime=localtime(&app.starttime);
            unsigned long int return_value_strftime_27;
            return_value_strftime_27=strftime(tmp, (unsigned long int)50, "%Y-%m-%d %T %Z", loctime);
            ret = (signed int)return_value_strftime_27;
            if(ret == 0 || !(app.starttime >= 0l))
              tmp[(signed long int)0] = (char)0;

            snprintf(buf, (unsigned long int)80, "%s %s\n", logfile->head, (const void *)tmp);
            if(len >= 81 || !(len >= 0))
              return -1;

            else
            {
              unsigned long int return_value_strlen_28;
              return_value_strlen_28=strlen(buf);
              signed long int return_value_write_29;
              return_value_write_29=write(logfile->fh, (const void *)buf, return_value_strlen_28);
              if(return_value_write_29 == -1l)
                return -1;

              else
                return 0;
            }
          }
        }
      }
    }
  }
}

// logfile_add_splitmarker
// file logfile.c line 168
static signed int logfile_add_splitmarker(struct anonymous_7 *logfile)
{
  signed int ret;
  signed int len;
  signed long int sec;
  struct tm *loctime;
  char buf[81l];
  char tmp[51l];
  buf[(signed long int)80] = (char)0;
  len=snprintf(buf, (unsigned long int)80, "%s %s\n", logfile->split, app.exe);
  if(len >= 81 || !(len >= 0))
    return -1;

  else
  {
    signed long int return_value_write_1;
    return_value_write_1=write(logfile->fh, (const void *)buf, (unsigned long int)len);
    if(return_value_write_1 == -1l)
      return -1;

    else
    {
      loctime=localtime(&app.starttime);
      unsigned long int return_value_strftime_2;
      return_value_strftime_2=strftime(tmp, (unsigned long int)50, "%Y-%m-%d %T %Z", loctime);
      ret = (signed int)return_value_strftime_2;
      if(ret == 0 || !(app.starttime >= 0l))
        tmp[(signed long int)0] = (char)0;

      len=snprintf(buf, (unsigned long int)80, "%s running since %s\n", logfile->split, (const void *)tmp);
      if(len >= 81 || !(len >= 0))
        return -1;

      else
      {
        signed long int return_value_write_3;
        return_value_write_3=write(logfile->fh, (const void *)buf, (unsigned long int)len);
        if(return_value_write_3 == -1l)
          return -1;

        else
        {
          len=snprintf(buf, (unsigned long int)80, "%s %d lines output (%d stdout, %d stderr)\n", logfile->split, app.pstdout->linecount + app.pstderr->linecount, app.pstdout->linecount, app.pstderr->linecount);
          if(len >= 81 || !(len >= 0))
            return -1;

          else
          {
            signed long int return_value_write_4;
            return_value_write_4=write(logfile->fh, (const void *)buf, (unsigned long int)len);
            if(return_value_write_4 == -1l)
              return -1;

            else
            {
              signed long int return_value_time_6;
              return_value_time_6=time(&sec);
              if(return_value_time_6 >= 0l)
              {
                loctime=localtime(&sec);
                unsigned long int return_value_strftime_5;
                return_value_strftime_5=strftime(tmp, (unsigned long int)50, "%Y-%m-%d %T %Z", loctime);
                ret = (signed int)return_value_strftime_5;
              }

              if(ret == 0 || !(sec >= 0l))
                tmp[(signed long int)0] = (char)0;

              if(app.starttime >= 0l && sec >= app.starttime)
              {
                len=snprintf(buf, (unsigned long int)80, "%s execution time is %us\n", logfile->split, (unsigned int)(sec - app.starttime));
                if(len >= 81 || !(len >= 0))
                  return -1;

                signed long int return_value_write_7;
                return_value_write_7=write(logfile->fh, (const void *)buf, (unsigned long int)len);
                if(return_value_write_7 == -1l)
                  return -1;

              }

              else
                print((enum anonymous_6)ERROR, "Problem calculating execution time\n");
              return 0;
            }
          }
        }
      }
    }
  }
}

// logfile_check_size
// file logfile.c line 392
static signed int logfile_check_size(struct anonymous_7 *logfile, signed int addmarker, unsigned int addsize)
{
  unsigned int curpos;
  signed int *return_value___errno_location_3;
  if(logfile->sizelimit == 0u)
    return 0;

  else
  {
    signed long int return_value_lseek_1;
    return_value_lseek_1=lseek(logfile->fh, (signed long int)0, 1);
    curpos = (unsigned int)(return_value_lseek_1 + (signed long int)addsize);
    if(!(logfile->sizelimit >= curpos))
    {
      signed int flags = 0100 | 01;
      if(!(addmarker == 0))
        logfile_add_splitmarker(logfile);

      if(config.circularlog == 0)
      {
        signed int return_value_logfile_rename_2;
        return_value_logfile_rename_2=logfile_rename(logfile, (char *)(void *)0);
        if(!(return_value_logfile_rename_2 == 0))
          print((enum anonymous_6)ERROR, "problem moving log - continuing anyways\n");

        flags = flags | 01000;
      }

      else
      {
        signed long int return_value_lseek_4;
        return_value_lseek_4=lseek(logfile->fh, (signed long int)0, 1);
        signed int return_value_ftruncate_5;
        return_value_ftruncate_5=ftruncate(logfile->fh, return_value_lseek_4);
        if(return_value_ftruncate_5 == -1)
        {
          return_value___errno_location_3=__errno_location();
          print((enum anonymous_6)ERROR, "Problem truncating logfile (errno=%d)", *return_value___errno_location_3);
        }

        return -1;
      }
      close(logfile->fh);
      logfile->fh=open(logfile->name, flags, 0644);
      if(!(addmarker == 0))
        logfile_add_splitmarker(logfile);

    }

    return 0;
  }
}

// logfile_close
// file logfile.h line 30
extern signed int logfile_close(struct anonymous_7 *logfile)
{
  if(logfile->name == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_logfile_add_footer_1;
    return_value_logfile_add_footer_1=logfile_add_footer(logfile);
    if(!(return_value_logfile_add_footer_1 == 0))
    {
      print((enum anonymous_6)ERROR, "problem writing log footer to file\n");
      return -1;
    }

    else
    {
      close(logfile->fh);
      return 0;
    }
  }
}

// logfile_get_alternate_name
// file logfile.c line 365
static char * logfile_get_alternate_name(struct anonymous_7 *logfile)
{
  signed int len;
  if(logfile->appendnr == 0)
  {
    char *return_value___strdup_1;
    return_value___strdup_1=__strdup(logfile->name);
    return return_value___strdup_1;
  }

  char number[12l];
  len=snprintf(number, (unsigned long int)12, ".%d", logfile->appendnr);
  if(!(len >= 0))
    return (char *)(void *)0;

  else
  {
    char *name;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(logfile->name);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(number);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)1);
    name = (char *)return_value_malloc_4;
    if(name == ((char *)NULL))
    {
      error_outofmemory();
      return (char *)(void *)0;
    }

    else
    {
      strcpy(name, logfile->name);
      strcat(name, number);
      return name;
    }
  }
}

// logfile_open
// file logfile.h line 29
extern signed int logfile_open(char *filename, struct anonymous_7 *logfile)
{
  signed int flags;
  char *altname = (char *)(void *)0;
  if(filename == ((char *)NULL))
    return 0;

  else
  {
    logfile->name=get_longpath(filename);
    if(logfile->name == ((char *)NULL))
      return -1;

    else
    {
      flags = 0100 | 01 | 02000;
      while(!(logfile->appendnr >= config.maxlogfiles))
      {
        if(!(altname == ((char *)NULL)))
          free((void *)altname);

        altname=logfile_get_alternate_name(logfile);
        if(logfile->name == ((char *)NULL))
          return -1;

        if(config.appendlog == 0)
        {
          logfile->fh=open(altname, 01, 0644);
          if(!(logfile->fh == -1))
          {
            signed int return_value_get_lock_2;
            return_value_get_lock_2=get_lock(logfile);
            if(return_value_get_lock_2 == 0)
            {
              close(logfile->fh);
              signed int return_value_logfile_rename_1;
              return_value_logfile_rename_1=logfile_rename(logfile, altname);
              if(!(return_value_logfile_rename_1 == 0))
              {
                logfile->fh = -1;
                logfile->appendnr = logfile->appendnr + 1;
                continue;
              }

            }

            else
            {
              close(logfile->fh);
              logfile->fh = -1;
              logfile->appendnr = logfile->appendnr + 1;
              continue;
            }
          }

        }

        logfile->fh=open(altname, flags, 0644);
        signed int return_value_get_lock_3;
        return_value_get_lock_3=get_lock(logfile);
        if(!(return_value_get_lock_3 == 0))
        {
          close(logfile->fh);
          logfile->fh = -1;
          logfile->appendnr = logfile->appendnr + 1;
        }

        else
          break;
      }
      free((void *)logfile->name);
      logfile->name = altname;
      if(logfile->fh == -1)
      {
        if(logfile->appendnr == config.maxlogfiles)
        {
          print((enum anonymous_6)ERROR, "no possible logfile is writeable\n");
          print((enum anonymous_6)ERROR, "-> check permissions or try increasing the maxaltlogfiles value\n");
        }

        return -1;
      }

      else
      {
        if(!(logfile->appendnr == 0))
        {
          if(!(config.warnlogfilelock == 0))
          {
            print((enum anonymous_6)WARNING, "using %s as logfile\n", logfile->name);
            print((enum anonymous_6)WARNING, "most likely another logapp session is locking the logfile\n");
          }

        }

        if(config.appendlog == 0)
        {
          signed int return_value_ftruncate_5;
          return_value_ftruncate_5=ftruncate(logfile->fh, (signed long int)0);
          if(return_value_ftruncate_5 == -1)
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            print((enum anonymous_6)ERROR, "Problem truncating logfile (errno = %d)\n", *return_value___errno_location_4);
            return -1;
          }

        }

        signed int return_value_logfile_add_header_6;
        return_value_logfile_add_header_6=logfile_add_header(logfile);
        if(!(return_value_logfile_add_header_6 == 0))
        {
          print((enum anonymous_6)ERROR, "problem writing log header to file\n");
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// logfile_rename
// file logfile.c line 332
static signed int logfile_rename(struct anonymous_7 *logfile, char *oldname)
{
  char *newname;
  signed int ret = 0;
  if(config.logrename == 0)
    return 0;

  else
  {
    if(oldname == ((char *)NULL))
      oldname = logfile->name;

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(oldname);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(return_value_strlen_1 + sizeof(char *) /*8ul*/ );
    newname = (char *)return_value_malloc_2;
    if(newname == ((char *)NULL))
    {
      error_outofmemory();
      return -1;
    }

    else
    {
      strcpy(newname, oldname);
      strcat(newname, logfile->oldext);
      signed int return_value_rename_5;
      return_value_rename_5=rename(oldname, newname);
      if(!(return_value_rename_5 == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 2))
        {
          ret = -1;
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          print((enum anonymous_6)WARNING, "logfile rename failed (error: %d)\n", *return_value___errno_location_3);
        }

      }

      free((void *)newname);
      return ret;
    }
  }
}

// logfile_write
// file logfile.c line 432
extern signed int logfile_write(struct anonymous_7 *logfile, struct anonymous_5 *pipe)
{
  unsigned int stamp_sec = (unsigned int)0;
  signed int stamp_msec = 0;
  signed int writetimestamp = config.logtime;
  signed int prefixlen = 0;
  signed int return_value_logfile_check_size_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  signed long int return_value_write_4;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_11;
  if(logfile->name == ((char *)NULL))
    return 0;

  else
  {
    pthread_mutex_lock(&logfile_mutex);
    if(!(logfile->sizelimit == 0u))
    {
      return_value_logfile_check_size_1=logfile_check_size(logfile, 1, (unsigned int)pipe->bfill);
      if(return_value_logfile_check_size_1 == 0)
        goto __CPROVER_DUMP_L3;

      print((enum anonymous_6)ERROR, "Problem while checking/resizing logfile\n");
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!(config.logtime == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if(!(config.jointimeout == 0))
          tmp_if_expr_2 = pipe->charbased != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        struct timeval tvtime;
        gettimeofday(&tvtime, (struct timezone *)(void *)0);
        stamp_sec = (unsigned int)(tvtime.tv_sec - app.toffset.tv_sec);
        stamp_msec = (signed int)((tvtime.tv_usec - app.toffset.tv_usec) / (signed long int)1000);
        if(!(stamp_msec >= 0))
        {
          stamp_sec = stamp_sec - 1u;
          stamp_msec = stamp_msec + 1000;
        }

        if(!(config.jointimeout == 0))
        {
          if(!(pipe->charbased == 0))
          {
            signed int ossec;
            signed int osmsec;
            signed int join = 0;
            static signed int oldmsec = -1;
            osmsec = stamp_msec - oldmsec;
            static unsigned int oldsec = (unsigned int)-1;
            ossec = (signed int)(stamp_sec - oldsec);
            if(!(osmsec >= 0))
            {
              ossec = ossec - 1;
              osmsec = osmsec + 1000;
            }

            if(config.jointimeout / 1000 == ossec)
            {
              if(!(osmsec >= config.jointimeout % 1000))
                join = 1;

              else
                join = 0;
            }

            else
              if(!(ossec >= config.jointimeout / 1000))
                join = 1;

              else
                join = 0;
            if(!(join == 0))
            {
              logfile->addnewline = 0;
              writetimestamp = 0;
            }

            if(!(config.logreltime == 0) && !(writetimestamp == 0))
            {
              oldmsec = 0;
              oldsec = (unsigned int)0;
            }

            else
            {
              oldmsec = stamp_msec;
              oldsec = stamp_sec;
            }
          }

        }

        if(!(config.logreltime == 0) && !(writetimestamp == 0))
          memcpy((void *)&app.toffset, (const void *)&tvtime, sizeof(struct timeval) /*16ul*/ );

      }

      if(!(pipe->charbased == 0))
      {
        if(!(logfile->addnewline == 0))
        {
          if(!(config.alignlog == 0))
          {
            return_value_write_4=write(logfile->fh, (const void *)"\n", (unsigned long int)1);
            if(return_value_write_4 == -1l)
              goto failure_exit;

          }

        }

        if(!((signed int)pipe->buf[(signed long int)(pipe->bfill + -1)] == 10))
          logfile->addnewline = 1;

        else
          logfile->addnewline = 0;
      }

      if(!(writetimestamp == 0))
      {
        char timestamp[16l];
        signed int len;
        if(!(stamp_sec >= 999999u))
        {
          len=snprintf(timestamp, (unsigned long int)12, "%06u%03u: ", stamp_sec, stamp_msec);
          if(!(len >= 0))
            goto failure_exit;

          prefixlen = 11;
        }

        else
        {
          len=snprintf(timestamp, (unsigned long int)16, "%010u%03u: ", stamp_sec, stamp_msec);
          if(!(len >= 0))
            goto failure_exit;

          prefixlen = 15;
        }
        signed long int return_value_write_5;
        return_value_write_5=write(logfile->fh, (const void *)timestamp, (unsigned long int)prefixlen);
        if(return_value_write_5 == -1l)
          goto failure_exit;

      }

      if(!(pipe->lineprefix == ((char *)NULL)))
      {
        signed long int return_value_write_6;
        return_value_write_6=write(logfile->fh, (const void *)pipe->lineprefix, (unsigned long int)pipe->lineprefixlen);
        if(return_value_write_6 == -1l)
          goto failure_exit;

        prefixlen = prefixlen + pipe->lineprefixlen;
      }

      signed int i = 0;
      signed int offset = 0;
      if(!(config.alignlinebreaks == 0))
        tmp_if_expr_13 = pipe->charbased != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_13 = (_Bool)0;
      if(tmp_if_expr_13)
      {
        while(!(pipe->linebreakpos[(signed long int)i] == 0))
        {
          if(!(i == 0))
          {
            signed long int return_value_write_7;
            return_value_write_7=write(logfile->fh, (const void *)logfile->indent, (unsigned long int)prefixlen);
            if(return_value_write_7 == -1l)
              goto failure_exit;

          }

          signed long int return_value_write_8;
          return_value_write_8=write(logfile->fh, (const void *)(pipe->buf + (signed long int)offset), (unsigned long int)(pipe->linebreakpos[(signed long int)i] - offset));
          if(return_value_write_8 == -1l)
            goto failure_exit;

          offset = pipe->linebreakpos[(signed long int)i];
          i = i + 1;
        }
        i = offset;
        for( ; !(i >= pipe->bfill); i = i + 1)
        {
          if((signed int)pipe->buf[(signed long int)i] == 10)
            tmp_if_expr_11 = (_Bool)1;

          else
            tmp_if_expr_11 = i + 1 == pipe->bfill ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_11)
          {
            if(!(offset == 0))
            {
              signed long int return_value_write_9;
              return_value_write_9=write(logfile->fh, (const void *)logfile->indent, (unsigned long int)prefixlen);
              if(return_value_write_9 == -1l)
                goto failure_exit;

            }

            signed long int return_value_write_10;
            return_value_write_10=write(logfile->fh, (const void *)(pipe->buf + (signed long int)offset), (unsigned long int)((i - offset) + 1));
            if(return_value_write_10 == -1l)
              goto failure_exit;

            offset = i + 1;
          }

        }
      }

      else
      {
        signed long int return_value_write_12;
        return_value_write_12=write(logfile->fh, (const void *)pipe->buf, (unsigned long int)pipe->bfill);
        if(return_value_write_12 == -1l)
          goto failure_exit;

      }
      pthread_mutex_unlock(&logfile_mutex);
      return 0;

    failure_exit:
      ;
      pthread_mutex_unlock(&logfile_mutex);
      return -1;
    }
  }
}

// main
// file main.c line 348
signed int main(signed int argc, char **argv)
{
  char *argv0;
  signed int main__1__ret;
  char *env;
  env=getenv("TERM");
  signed int tmp_statement_expression_1;
  if(!(env == ((char *)NULL)))
  {
    unsigned long int main__1__1__1____s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(env, "dumb");
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      config.dumbterm = 1;

  }

  else
    config.dumbterm = 1;
  argv0=strrchr(argv[(signed long int)0], 47);
  if(!(argv0 == ((char *)NULL)))
    argv0 = argv0 + 1l;

  else
    argv0 = argv[(signed long int)0];
  signed int tmp_statement_expression_6;
  unsigned long int __s1_len;
  unsigned long int main__1__3____s2_len;
  signed int return_value___builtin_strcmp_7;
  return_value___builtin_strcmp_7=__builtin_strcmp(argv0, "logapp");
  tmp_statement_expression_6 = return_value___builtin_strcmp_7;
  unsigned long int return_value_strlen_3;
  if(!(tmp_statement_expression_6 == 0))
  {
    app.exe=strstr(argv0, config.strip_prefix);
    if(app.exe == argv0)
    {
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(app.exe);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(config.strip_prefix);
      if(!(return_value_strlen_5 >= return_value_strlen_4))
      {
        return_value_strlen_3=strlen(config.strip_prefix);
        app.exe = app.exe + (signed long int)return_value_strlen_3;
      }

    }

    else
      app.exe = argv0;
  }

  main__1__ret=parse_args(argc, argv);
  if(!(main__1__ret == 0))
  {
    print((enum anonymous_6)ERROR, "error parsing logapp argument %d\n", main__1__ret);
    exit(1);
  }

  if(!(show_usage == 0))
  {
    usage();
    exit(0);
  }

  if(!(show_version == 0))
  {
    version();
    exit(0);
  }

  if(app.exe == ((char *)NULL) && show_config == 0)
  {
    print((enum anonymous_6)MESSAGE, "%s: No application parameter has been provided.\n", (const void *)"logapp");
    usage();
    exit(0);
  }

  signed int return_value_get_config_8;
  return_value_get_config_8=get_config();
  if(!(return_value_get_config_8 == 0))
  {
    print((enum anonymous_6)ERROR, "problem while loading default config from file\n");
    exit(1);
  }

  signed int return_value_fixup_config_9;
  return_value_fixup_config_9=fixup_config();
  if(!(return_value_fixup_config_9 == 0))
  {
    print((enum anonymous_6)ERROR, "problem processing configuration\n");
    exit(1);
  }

  signed int return_value_check_for_disable_keywords_10;
  return_value_check_for_disable_keywords_10=check_for_disable_keywords();
  if(!(return_value_check_for_disable_keywords_10 == 0))
  {
    print((enum anonymous_6)ERROR, "failed to check for disable keywords\n");
    exit(1);
  }

  if(!(show_config == 0))
  {
    show_configuration();
    exit(0);
  }

  _Bool tmp_if_expr_12;
  if(app.pstderr->eclip == 2)
    tmp_if_expr_12 = (_Bool)1;

  else
    tmp_if_expr_12 = app.pstdout->eclip == 2 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_12)
  {
    void (*return_value_signal_11)(signed int);
    return_value_signal_11=signal(28, sig_handler);
    if(return_value_signal_11 == (void (*)(signed int))-1)
    {
      print((enum anonymous_6)ERROR, "creating signal handler\n");
      return -1;
    }

    adjust_clipping();
  }

  void (*return_value_signal_13)(signed int);
  return_value_signal_13=signal(2, sig_handler);
  if(return_value_signal_13 == (void (*)(signed int))-1)
  {
    print((enum anonymous_6)ERROR, "creating signal handler\n");
    exit(1);
  }

  void (*return_value_signal_14)(signed int);
  return_value_signal_14=signal(3, sig_handler);
  if(return_value_signal_14 == (void (*)(signed int))-1)
  {
    print((enum anonymous_6)ERROR, "creating signal handler\n");
    exit(1);
  }

  void (*return_value_signal_15)(signed int);
  return_value_signal_15=signal(15, sig_handler);
  if(return_value_signal_15 == (void (*)(signed int))-1)
  {
    print((enum anonymous_6)ERROR, "creating signal handler\n");
    exit(1);
  }

  void (*return_value_signal_16)(signed int);
  return_value_signal_16=signal(17, sig_handler);
  if(return_value_signal_16 == (void (*)(signed int))-1)
  {
    print((enum anonymous_6)ERROR, "creating signal handler\n");
    exit(1);
  }

  signed int return_value_fork_child_17;
  return_value_fork_child_17=fork_child();
  if(!(return_value_fork_child_17 == 0))
    exit(1);

  signed int return_value_logfile_open_18;
  return_value_logfile_open_18=logfile_open(config.logname, app.logfile);
  if(!(return_value_logfile_open_18 == 0))
  {
    print((enum anonymous_6)ERROR, "unable to open logfile %s\n", config.logname);
    exit(1);
  }

  if(!(config.preexeccmd == ((char *)NULL)))
  {
    signed int main__1__20__ret;
    main__1__20__ret=execcmd(config.preexeccmd);
    if(!(main__1__20__ret == 0))
    {
      print((enum anonymous_6)(config.exitonexecfail != 0 ? ERROR : WARNING), "preexec command \"%s\" returned 0x%x\n", config.preexeccmd, main__1__20__ret);
      if(!(config.exitonexecfail == 0))
        exit(1);

    }

  }

  if(config.disable == 0)
  {
    signed int return_value_capture_start_19;
    return_value_capture_start_19=capture_start();
    if(!(return_value_capture_start_19 == 0))
    {
      print((enum anonymous_6)ERROR, "unable to capture streams\n");
      exit(1);
    }

  }

  waitpid(app.pid, &app.exit_state, 0);
  if(config.disable == 0)
    capture_end();

  signed int return_value_logfile_close_20;
  return_value_logfile_close_20=logfile_close(app.logfile);
  if(!(return_value_logfile_close_20 == 0))
    print((enum anonymous_6)ERROR, "problem closing logfile");

  if(!(config.postexeccmd == ((char *)NULL)))
  {
    signed int ret;
    ret=execcmd(config.postexeccmd);
    if(!(ret == 0))
      print((enum anonymous_6)(config.exitonexecfail != 0 ? ERROR : WARNING), "postexec command \"%s\" returned 0x%x\n", config.postexeccmd, ret);

  }

  if(config.disable == 0)
    reset_console();

  fflush((struct _IO_FILE *)(void *)0);
  if(!(config.printsummary == 0))
    print_summary();

  cleanup_config();
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_2
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & app.exit_state) == 0)
    exit((((union anonymous_2){ .__in=app.exit_state }).__i & 0xff00) >> 8);

  else
    exit(1);
}

// parse_args
// file configuration.h line 206
extern signed int parse_args(signed int argc, char **argv)
{
  signed int i;
  char *arg;
  char *value;
  signed int argid;
  signed int argcount = 1;
  if(!(argc >= 1))
  {
    print((enum anonymous_6)ERROR, "invalid argument count\n");
    return -1;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(argc + 1) * sizeof(char *) /*8ul*/ );
    app.argv = (char **)return_value_malloc_1;
    if(app.argv == ((char **)NULL))
    {
      error_outofmemory();
      return -1;
    }

    else
    {
      app.argc = 1;
      i = 1;
      for( ; !(i >= argc); i = i + 1)
      {
        value = (char *)(void *)0;
        if((signed int)*argv[(signed long int)i] == 45)
        {
          if((signed int)argv[(signed long int)i][1l] == 45)
          {
            arg = &argv[(signed long int)i][(signed long int)2];
            char *return_value_strstr_3;
            return_value_strstr_3=strstr(arg, config.argprefix);
            if(return_value_strstr_3 == arg)
            {
              unsigned long int return_value_strlen_2;
              return_value_strlen_2=strlen(config.argprefix);
              arg = arg + (signed long int)return_value_strlen_2;
            }

            else
              if(!(app.exe == ((char *)NULL)))
              {
                app.argv[(signed long int)app.argc] = argv[(signed long int)i];
                app.argc = app.argc + 1;
                goto __CPROVER_DUMP_L17;
              }

            char *return_value___builtin_strchr_4;
            return_value___builtin_strchr_4=__builtin_strchr(arg, 61);
            value = return_value___builtin_strchr_4;
            if(!(value == ((char *)NULL)))
            {
              *value = (char)0;
              if(!(value[1l] == 0))
                value = value + 1l;

            }

            else
              value = &argv[(signed long int)i][(signed long int)2];
            argid=get_argid(arg, 0);
          }

          else
          {
            if(!(app.exe == ((char *)NULL)))
            {
              app.argv[(signed long int)app.argc] = argv[(signed long int)i];
              app.argc = app.argc + 1;
              goto __CPROVER_DUMP_L17;
            }

            arg = &argv[(signed long int)i][(signed long int)1];
            if(!(argv[(signed long int)i][2l] == 0))
              return argcount;

            argid=get_argid(arg, 1);
          }
          if(!(argid >= 0))
            return argcount;

          signed int return_value_get_argvalue_5;
          return_value_get_argvalue_5=get_argvalue(2, argid, &i, argc, argv, value);
          if(!(return_value_get_argvalue_5 == 0))
            return argcount;

          argcount = argcount + 1;
        }

        else
          if(!(app.exe == ((char *)NULL)))
          {
            app.argv[(signed long int)app.argc] = argv[(signed long int)i];
            app.argc = app.argc + 1;
          }

          else
          {
            arg = &argv[(signed long int)i][(signed long int)0];
            app.exe = arg;
          }

      __CPROVER_DUMP_L17:
        ;
      }
      app.argv[(signed long int)0] = app.exe;
      app.argv[(signed long int)app.argc] = (char *)(void *)0;
      if(app.exe == ((char *)NULL))
        app.argc = 0;

      return 0;
    }
  }
}

// parse_configline
// file configuration.c line 1049
signed int parse_configline(char *line, char **appconfig_section)
{
  char *name;
  char *value;
  char *tmp;
  signed int argid;
  static signed int lineno;
  lineno = lineno + 1;
  unsigned long int tmp_statement_expression_1;
  char __a0;
  char __a1;
  char __a2;
  unsigned long int return_value___builtin_strspn_2;
  return_value___builtin_strspn_2=__builtin_strspn(line, " \t");
  tmp_statement_expression_1 = return_value___builtin_strspn_2;
  name = line + (signed long int)tmp_statement_expression_1;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(name);
  unsigned long int tmp_statement_expression_4;
  unsigned long int tmp_statement_expression_6;
  unsigned long int tmp_statement_expression_11;
  unsigned long int return_value_strlen_16;
  unsigned long int return_value_strlen_15;
  signed int tmp_statement_expression_19;
  if(return_value_strlen_3 == 0ul)
    return 0;

  else
  {
    char __r0;
    char __r1;
    char __r2;
    unsigned long int return_value___builtin_strcspn_5;
    return_value___builtin_strcspn_5=__builtin_strcspn(name, " \t=");
    tmp_statement_expression_4 = return_value___builtin_strcspn_5;
    value = name + (signed long int)tmp_statement_expression_4;
    *value = (char)0;
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(value + (signed long int)1);
    if(return_value_strlen_8 >= 1ul)
    {
      char parse_configline__1__3____a0;
      char parse_configline__1__3____a1;
      char parse_configline__1__3____a2;
      unsigned long int return_value___builtin_strspn_7;
      return_value___builtin_strspn_7=__builtin_strspn(value + (signed long int)1, " \t=");
      tmp_statement_expression_6 = return_value___builtin_strspn_7;
      value = value + (signed long int)1 + (signed long int)tmp_statement_expression_6;
    }

    if((signed int)*value == 34)
    {
      value = value + 1l;
      char *return_value___builtin_strchr_9;
      return_value___builtin_strchr_9=__builtin_strchr(value, 34);
      tmp = return_value___builtin_strchr_9;
    }

    else
      if((signed int)*value == 39)
      {
        value = value + 1l;
        char *return_value___builtin_strchr_10;
        return_value___builtin_strchr_10=__builtin_strchr(value, 39);
        tmp = return_value___builtin_strchr_10;
      }

      else
      {
        char parse_configline__1__6__1____r0;
        char parse_configline__1__6__1____r1;
        char parse_configline__1__6__1____r2;
        unsigned long int return_value___builtin_strcspn_12;
        return_value___builtin_strcspn_12=__builtin_strcspn(value, " \t");
        tmp_statement_expression_11 = return_value___builtin_strcspn_12;
        tmp = value + (signed long int)tmp_statement_expression_11;
      }
    if(tmp == ((char *)NULL))
    {
      print((enum anonymous_6)WARNING, "unterminated string in config file (line %d)\n", lineno);
      return -1;
    }

    else
    {
      *tmp = (char)0;
      unsigned long int return_value_strlen_17;
      return_value_strlen_17=strlen(value);
      if(return_value_strlen_17 == 0ul)
      {
        return_value_strlen_16=strlen(name);
        if(return_value_strlen_16 >= 2ul)
        {
          if((signed int)*name == 91)
          {
            return_value_strlen_15=strlen(name);
            if((signed int)name[-1l + (signed long int)return_value_strlen_15] == 93)
            {
              name = name + (signed long int)1;
              unsigned long int return_value_strlen_13;
              return_value_strlen_13=strlen(name);
              name[(signed long int)(return_value_strlen_13 - (unsigned long int)1)] = (char)0;
              if(!(*appconfig_section == ((char *)NULL)))
                free((void *)*appconfig_section);

              char *return_value___strdup_14;
              return_value___strdup_14=__strdup(name);
              *appconfig_section = return_value___strdup_14;
              if(appconfig_section == ((char **)NULL))
              {
                error_outofmemory();
                return -1;
              }

              return 0;
            }

          }

        }

      }

      if(!(*appconfig_section == ((char *)NULL)))
      {
        if(!(config.configsection == ((char *)NULL)))
        {
          char *parse_configline__1__9__1__tmp;
          char *return_value___builtin_strchr_18;
          return_value___builtin_strchr_18=__builtin_strchr(*appconfig_section, 47);
          if(return_value___builtin_strchr_18 == ((char *)NULL))
          {
            parse_configline__1__9__1__tmp=strrchr(config.configsection, 47);
            if(parse_configline__1__9__1__tmp == ((char *)NULL))
              parse_configline__1__9__1__tmp = config.configsection;

            else
              parse_configline__1__9__1__tmp = parse_configline__1__9__1__tmp + (signed long int)1;
          }

          else
            parse_configline__1__9__1__tmp = config.configsection;
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_20;
          return_value___builtin_strcmp_20=__builtin_strcmp(*appconfig_section, parse_configline__1__9__1__tmp);
          tmp_statement_expression_19 = return_value___builtin_strcmp_20;
          if(!(tmp_statement_expression_19 == 0))
            return 0;

          goto __CPROVER_DUMP_L16;
        }

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L16:
        ;
        argid=get_argid(name, 0);
        if(argid >= 0)
        {
          unsigned long int return_value_strlen_21;
          return_value_strlen_21=strlen(value);
          if(return_value_strlen_21 == 0ul)
          {
            if((signed int)arglist[(signed long int)argid].type == TNONE)
              value = (char *)(void *)0;

          }

          get_argvalue(1, argid, (signed int *)(void *)0, 0, (char **)(void *)0, value);
        }

        else
        {
          print((enum anonymous_6)WARNING, "unknown parameter in config file (line %d)\n", lineno);
          return -1;
        }
        return 0;
      }
    }
  }
}

// prepare_buffer
// file capture.c line 346
signed int prepare_buffer(struct anonymous_5 *pipe)
{
  if(!(pipe->blen == 0))
  {
    signed int len = pipe->blen + pipe->esccolorlen + 1;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)len);
    pipe->dbuf = (char *)return_value_malloc_1;
    if(pipe->dbuf == ((char *)NULL))
    {
      error_outofmemory();
      print((enum anonymous_6)ERROR, "trying to allocate %d byte %s buffer\n", len, pipe->name);
      return -1;
    }

    if(pipe->charbased == 0)
    {
      struct stat statbuf;
      signed int return_value_fstat_2;
      return_value_fstat_2=fstat(pipe->fh, &statbuf);
      if(!(return_value_fstat_2 == 0))
      {
        print((enum anonymous_6)ERROR, "unable to get io buffer stats for %s\n", pipe->name);
        free((void *)pipe->dbuf);
        pipe->dbuf = (char *)(void *)0;
        return -1;
      }

      pipe->rdbuf.len = (signed int)statbuf.st_blksize;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)pipe->rdbuf.len);
      pipe->rdbuf.start = (char *)return_value_malloc_3;
      if(pipe->rdbuf.start == ((char *)NULL))
      {
        error_outofmemory();
        print((enum anonymous_6)ERROR, "trying to allocate %d byte %s read buffer\n", pipe->rdbuf.len, pipe->name);
        free((void *)pipe->buf);
        pipe->buf = (char *)(void *)0;
        return -1;
      }

      pipe->rdbuf.read = pipe->rdbuf.start;
      pipe->rdbuf.end = pipe->rdbuf.start;
    }

    strcpy(pipe->dbuf, pipe->esccolor);
    free((void *)pipe->esccolor);
    if(!(pipe->bgesccolor == ((char *)NULL)))
      pipe->bgesccolor = pipe->dbuf + (pipe->bgesccolor - pipe->esccolor);

    pipe->esccolor = pipe->dbuf;
    pipe->buf = pipe->dbuf + (signed long int)pipe->esccolorlen;
  }

  return 0;
}

// print
// file main.c line 63
void print(enum anonymous_6 type, const char *format, ...)
{
  void **argptr;
  signed int format_len;
  signed int fmt_len;
  signed int exec_len;
  signed int warn_len;
  signed int err_len;
  char *fmtstring;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(format);
  format_len = (signed int)return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen("logapp");
  exec_len = (signed int)return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(" warning: ");
  warn_len = (signed int)return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(" error: ");
  err_len = (signed int)return_value_strlen_4;
  fmt_len = format_len + exec_len + (warn_len > err_len ? warn_len : err_len) + 1;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)fmt_len);
  fmtstring = (char *)return_value_malloc_5;
  if(fmtstring == ((char *)NULL))
  {
    error_outofmemory();
    exit(1);
  }

  argptr = (void **)&format;
  if(!((signed int)type == MESSAGE))
  {
    memcpy((void *)fmtstring, (const void *)"logapp", (unsigned long int)exec_len);
    fmt_len = exec_len;
  }

  else
  {
    fmt_len = 0;
    *fmtstring = (char)0;
  }
  switch((signed int)type)
  {
    case WARNING:
    {
      memcpy((void *)(fmtstring + (signed long int)exec_len), (const void *)" warning: ", (unsigned long int)warn_len);
      fmt_len = fmt_len + warn_len;
      break;
    }
    case ERROR:
    {
      memcpy((void *)(fmtstring + (signed long int)exec_len), (const void *)" error: ", (unsigned long int)err_len);
      fmt_len = fmt_len + err_len;
    }
  }
  memcpy((void *)(fmtstring + (signed long int)fmt_len), (const void *)format, (unsigned long int)format_len);
  (fmtstring + (signed long int)fmt_len)[(signed long int)format_len] = (char)0;
  signed int return_value_vfprintf_6;
  return_value_vfprintf_6=vfprintf(stderr, fmtstring, argptr);
  if(!(return_value_vfprintf_6 >= 0))
    exit(1);

  argptr = ((void **)NULL);
  free((void *)fmtstring);
}

// print_stream
// file capture.c line 92
signed int print_stream(struct anonymous_5 *pipe)
{
  char *buf;
  unsigned int ccount;
  unsigned int esclength = (unsigned int)0;
  signed int regmatch = 0;
  if(!(pipe->bfill >= 1))
    return 1;

  else
  {
    static unsigned int offset;
    if(config.dumbterm == 0)
    {
      if(!(pipe->regexp == ((char *)NULL)))
      {
        signed int return_value_regexec_1;
        return_value_regexec_1=regexec(&pipe->preg, pipe->buf, (unsigned long int)0, (struct anonymous_4 *)(void *)0, 0);
        if(return_value_regexec_1 == 0)
          regmatch = 1;

      }

      static struct anonymous_5 *pipe_old;
      if(!(regmatch == 0) || !((void *)pipe_old == (void *)pipe))
      {
        offset = (unsigned int)0;
        buf = pipe->esccolor;
        esclength = (unsigned int)(pipe->buf - pipe->esccolor);
        if(!(pipe->bgesccolor == ((char *)NULL)))
        {
          if(regmatch == 0)
          {
            *pipe->bgesccolor = (char)(pipe->bgcol + 48);
            pipe_old = pipe;
          }

          else
          {
            *pipe->bgesccolor = (char)(pipe->regbgcol + 48);
            pipe_old = (struct anonymous_5 *)(void *)0;
          }
        }

        else
          pipe_old = pipe;
      }

      else
        buf = pipe->buf;
    }

    else
      buf = pipe->buf;
    if(!(pipe->eclip == 0))
    {
      unsigned int clip;
      if(!(pipe->recalclen == 0))
      {
        signed int return_value_recalc_cliplen_2;
        return_value_recalc_cliplen_2=recalc_cliplen(pipe);
        clip = (unsigned int)return_value_recalc_cliplen_2;
      }

      else
        clip = (unsigned int)pipe->clip;
      if(offset >= clip)
        return 0;

      if(!(clip >= offset + (unsigned int)pipe->bfill))
      {
        ccount = clip - offset;
        pipe->buf[(signed long int)ccount] = (char)10;
        ccount = ccount + 1u;
        offset = (unsigned int)0;
      }

      else
      {
        ccount = (unsigned int)pipe->bfill;
        if((signed int)pipe->buf[(signed long int)(ccount + 4294967295u)] == 10)
          offset = (unsigned int)0;

        else
          offset = offset + ccount;
      }
    }

    else
      ccount = (unsigned int)pipe->bfill;
    if(config.dumbterm == 0 && !(regmatch == 0))
    {
      if((signed int)pipe->buf[(signed long int)(ccount + 4294967295u)] == 10)
      {
        signed int rlen = pipe->escresetlen + 1;
        strcpy(&pipe->buf[(signed long int)(ccount - (unsigned int)1)], pipe->escreset);
        strcpy(&pipe->buf[(signed long int)((ccount - (unsigned int)1) + (unsigned int)rlen)], "\n");
        esclength = esclength + (unsigned int)rlen;
        regmatch = 1;
      }

      else
        regmatch = 0;
    }

    signed long int return_value_write_3;
    return_value_write_3=write(pipe->cfhno, (const void *)buf, (unsigned long int)(ccount + esclength));
    if(return_value_write_3 == -1l)
      return -1;

    else
    {
      if(config.dumbterm == 0 && !(regmatch == 0))
      {
        if(!(regmatch == 0))
          pipe->buf[(signed long int)(ccount - (unsigned int)1)] = (char)10;

      }

      pipe->recalclen = 0;
      return 1;
    }
  }
}

// print_summary
// file capture.h line 25
void print_summary(void)
{
  signed long int sec;
  unsigned int executiontime = (unsigned int)0;
  time(&sec);
  if(app.starttime >= 0l && sec >= app.starttime)
    executiontime = (unsigned int)(sec - app.starttime);

  else
    print((enum anonymous_6)ERROR, "Error calculating execution time\n");
  fprintf(stderr, "\nLogapp exited after %us; ", executiontime);
  if(app.pstdout->charbased == 0)
    fprintf(stderr, "%u", app.pstdout->linecount);

  else
    fprintf(stderr, "?");
  fprintf(stderr, " stdout, ");
  if(app.pstderr->charbased == 0)
    fprintf(stderr, "%u", app.pstderr->linecount);

  else
    fprintf(stderr, "?");
  fprintf(stderr, " stderr lines;");
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_2
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & app.exit_state) == 0)
    fprintf(stderr, " exit state %u\n", (((union anonymous_2){ .__in=app.exit_state }).__i & 0xff00) >> 8);

  else
    if((signed int)((127 & (signed char)app.exit_state) + 1) >> 1 >= 1)
      fprintf(stderr, " signal %d\n", ((union anonymous_2){ .__in=app.exit_state }).__i & 0x7f);

    else
      fprintf(stderr, " unknown exit state\n");
  if(!(config.warnlogfilelock == 0) && !(logfile.appendnr == 0) || !(config.printlogname == 0))
    fprintf(stderr, "Logapp logfile is: %s\n", logfile.name);

}

// read_pipe
// file capture.c line 278
signed int read_pipe(struct anonymous_5 *pipe)
{
  signed int i = 0;
  if(pipe->state >= 1)
  {
    pipe->recalclen = 0;
    pipe->bfill = 0;
  }

  if(!(pipe->memcr == 0))
  {
    *pipe->buf = (char)13;
    pipe->bfill = pipe->bfill + 1;
    pipe->memcr = 0;
  }

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  while((_Bool)1)
  {
    i=buf_get_char(pipe, &pipe->buf[(signed long int)pipe->bfill]);
    if(!(i >= 1))
      return pipe->bfill;

    if((signed int)pipe->buf[(signed long int)pipe->bfill] == 9)
      pipe->recalclen = 1;

    if((signed int)pipe->buf[(signed long int)pipe->bfill] == 10)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = i + pipe->bfill >= pipe->blen ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((signed int)pipe->buf[(signed long int)pipe->bfill] == 27)
        tmp_if_expr_3 = pipe->detectescape != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if((signed int)pipe->buf[(signed long int)pipe->bfill] == 10 && i >= 1)
      {
        if(!(pipe->ptyremovecr == 0))
        {
          if(pipe->bfill >= 1)
          {
            if((signed int)pipe->buf[(signed long int)(pipe->bfill + -1)] == 13)
            {
              pipe->bfill = pipe->bfill - 1;
              pipe->buf[(signed long int)pipe->bfill] = (char)10;
            }

          }

        }

        pipe->bfill = pipe->bfill + 1;
        pipe->linecount = pipe->linecount + 1;
      }

      else
      {
        if((signed int)pipe->buf[(signed long int)pipe->bfill] == 27)
          tmp_if_expr_1 = pipe->detectescape != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(i >= 1 && tmp_if_expr_1)
        {
          pipe->bfill = pipe->bfill + 1;
          pipe->switchtocbmode = 1;
        }

        else
          if(pipe->bfill + i >= pipe->blen)
            pipe->bfill = pipe->bfill + 1;

      }
      if((signed int)pipe->buf[(signed long int)(pipe->bfill + -1)] == 13)
      {
        pipe->memcr = 1;
        pipe->bfill = pipe->bfill - 1;
      }

      pipe->buf[(signed long int)pipe->bfill] = (char)0;
      return pipe->bfill;
    }

    if(!(pipe->bfill >= pipe->blen))
      pipe->bfill = pipe->bfill + 1;

  }
  return 0;
}

// recalc_cliplen
// file capture.c line 64
static signed int recalc_cliplen(struct anonymous_5 *pipe)
{
  signed int i;
  signed int length = 0;
  signed int checklen;
  if(!(pipe->clip >= pipe->bfill))
    checklen = pipe->clip;

  else
    checklen = pipe->bfill;
  i = 0;
  signed int tmp_post_1;
  for( ; !(i >= pipe->bfill); i = i + 1)
  {
    if((signed int)pipe->buf[(signed long int)i] == 9)
    {
      length = length + (8 - length % 8);
      goto __CPROVER_DUMP_L6;
    }

    length = length + 1;

  __CPROVER_DUMP_L6:
    ;
    if(!(pipe->clip >= length))
    {
      tmp_post_1 = i;
      i = i - 1;
      return tmp_post_1;
    }

  }
  return pipe->clip;
}

// reset_console
// file capture.h line 22
void reset_console(void)
{
  signed int err = 0;
  if(config.dumbterm == 0)
  {
    signed long int return_value_write_1;
    return_value_write_1=write(app.pstdout->cfhno, (const void *)app.pstdout->escreset, (unsigned long int)app.pstdout->escresetlen);
    err = (signed int)return_value_write_1;
    signed long int return_value_write_2;
    return_value_write_2=write(app.pstderr->cfhno, (const void *)app.pstderr->escreset, (unsigned long int)app.pstderr->escresetlen);
    err = (signed int)return_value_write_2;
  }

  if(!(app.ptytermios_bak == ((struct termios *)NULL)))
    tcsetattr(0, 1, app.ptytermios_bak);

  tcdrain(1);
  tcdrain(2);
  if(err == -1)
    print((enum anonymous_6)WARNING, "Problem reseting console...");

}

// show_configuration
// file configuration.h line 207
extern void show_configuration(void)
{
  unsigned int i;
  print((enum anonymous_6)MESSAGE, "%s %s\n\n", (const void *)"logapp", (const void *)"0.15");
  print((enum anonymous_6)MESSAGE, "current configuration:\n");
  print((enum anonymous_6)MESSAGE, "  argument prefix         %s\n", config.argprefix);
  print((enum anonymous_6)MESSAGE, "  executable prefix       %s\n", config.strip_prefix);
  print((enum anonymous_6)MESSAGE, "  active config file      %s\n", config.configfile != ((char *)NULL) ? config.configfile : "<none>");
  print((enum anonymous_6)MESSAGE, "  custom configfile path  %s\n", config.custconfigfile != ((char *)NULL) ? config.custconfigfile : "<none>");
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 3ul); i = i + 1u)
    print((enum anonymous_6)MESSAGE, "  config search path (%d)  %s\n", i, configsearchpath[(signed long int)i]);
  print((enum anonymous_6)MESSAGE, "  activate section        %s\n", config.configsection != ((char *)NULL) ? config.configsection : "<none>");
  print((enum anonymous_6)MESSAGE, "  application logfile     %s\n", config.logname != ((char *)NULL) ? config.logname : "<none>");
  print((enum anonymous_6)MESSAGE, "  append to logfile       %i\n", config.appendlog);
  print((enum anonymous_6)MESSAGE, "  log timestamps          %i\n", config.logtime);
  print((enum anonymous_6)MESSAGE, "  log relative time       %i\n", config.logreltime);
  print((enum anonymous_6)MESSAGE, "  log environment         %i\n", config.logenv);
  print((enum anonymous_6)MESSAGE, "  align log writes left   %i\n", config.alignlog);
  print((enum anonymous_6)MESSAGE, "  join timeout            %i\n", config.jointimeout);
  print((enum anonymous_6)MESSAGE, "  align line breaks       %i\n", config.alignlinebreaks);
  print((enum anonymous_6)MESSAGE, "  lock logfiles           %i\n", config.locklogfile);
  print((enum anonymous_6)MESSAGE, "  warning on logfile lock %i\n", config.warnlogfilelock);
  print((enum anonymous_6)MESSAGE, "  max. alternate logfiles %u\n", config.maxlogfiles - 1);
  print((enum anonymous_6)MESSAGE, "  maximum logsize         %u\n", logfile.sizelimit);
  print((enum anonymous_6)MESSAGE, "  rename logfiles         %i\n", config.logrename);
  print((enum anonymous_6)MESSAGE, "  circular logfile        %i\n", config.circularlog);
  print((enum anonymous_6)MESSAGE, "  extension for old logs  %s\n", logfile.oldext);
  print((enum anonymous_6)MESSAGE, "  exit on execution fail  %i\n", config.exitonexecfail);
  print((enum anonymous_6)MESSAGE, "\n  application executable  %s\n", app.exe != ((char *)NULL) ? app.exe : "<none>");
  print((enum anonymous_6)MESSAGE, "  application argc        %d\n", app.argc);
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)app.argc); i = i + 1u)
    print((enum anonymous_6)MESSAGE, "  application argv[%d]     %s\n", i, app.argv[(signed long int)i]);
  print((enum anonymous_6)MESSAGE, "\n");
  print((enum anonymous_6)MESSAGE, "  preexec command         %s\n", config.preexeccmd != ((char *)NULL) ? config.preexeccmd : "<none>");
  print((enum anonymous_6)MESSAGE, "  postexec command        %s\n", config.postexeccmd != ((char *)NULL) ? config.postexeccmd : "<none>");
  print((enum anonymous_6)MESSAGE, "\n");
  print((enum anonymous_6)MESSAGE, "  use threads             %i\n", 1);
  print((enum anonymous_6)MESSAGE, "  use PTY                 %i\n", config.usepty);
  print((enum anonymous_6)MESSAGE, "  remove CR for PTY       %i\n", config.ptyremovecr);
  print((enum anonymous_6)MESSAGE, "\n  ext. regexp patterns    %i\n", config.extregexp);
  print((enum anonymous_6)MESSAGE, "\n  dumb terminal mode      %i\n", config.dumbterm);
  print((enum anonymous_6)MESSAGE, "  print_summary           %i\n", config.printsummary);
  print((enum anonymous_6)MESSAGE, "  print_logname           %i\n", config.printlogname);
  print((enum anonymous_6)MESSAGE, "  disable output handling %i\n", config.disable);
  print((enum anonymous_6)MESSAGE, "  disable keywords        %s\n", config.disable_keywords != ((char *)NULL) ? config.disable_keywords : "<none>");
  print((enum anonymous_6)MESSAGE, "\n  stdout buffer length    %i\n", app.pstdout->blen);
  print((enum anonymous_6)MESSAGE, "  stdout foreground color %i\n", app.pstdout->fgcol);
  signed int tmp_if_expr_1;
  if(app.pstdout->bgcol == 9)
    tmp_if_expr_1 = -1;

  else
    tmp_if_expr_1 = app.pstdout->bgcol;
  print((enum anonymous_6)MESSAGE, "  stdout background color %i\n", tmp_if_expr_1);
  signed int tmp_if_expr_2;
  if(app.pstdout->regbgcol == 9)
    tmp_if_expr_2 = -1;

  else
    tmp_if_expr_2 = app.pstdout->regbgcol;
  print((enum anonymous_6)MESSAGE, "  stdout regexp bg color  %i\n", tmp_if_expr_2);
  print((enum anonymous_6)MESSAGE, "  stdout bold font        %i\n", app.pstdout->bold);
  print((enum anonymous_6)MESSAGE, "  stdout clip at column   ");
  if(app.pstdout->eclip == 1)
    print((enum anonymous_6)MESSAGE, "%d\n", app.pstdout->clip);

  else
    print((enum anonymous_6)MESSAGE, "%s\n", app.pstdout->eclip != 0 ? "auto" : "disable");
  char *tmp_if_expr_3;
  if(!(app.pstdout->lineprefix == ((char *)NULL)))
    tmp_if_expr_3 = app.pstdout->lineprefix;

  else
    tmp_if_expr_3 = "<none>";
  print((enum anonymous_6)MESSAGE, "  stdout line prefix      %s\n", tmp_if_expr_3);
  char *tmp_if_expr_4;
  if(!(app.pstdout->regexp == ((char *)NULL)))
    tmp_if_expr_4 = app.pstdout->regexp;

  else
    tmp_if_expr_4 = "<disabled>";
  print((enum anonymous_6)MESSAGE, "  stdout regexp           %s\n", tmp_if_expr_4);
  char *tmp_if_expr_5;
  if(!(app.pstdout->execregexp == ((char *)NULL)))
    tmp_if_expr_5 = app.pstdout->execregexp;

  else
    tmp_if_expr_5 = "<disabled>";
  print((enum anonymous_6)MESSAGE, "  stdout exec regexp      %s\n", tmp_if_expr_5);
  char *tmp_if_expr_6;
  if(!(app.pstdout->execcommand == ((char *)NULL)))
    tmp_if_expr_6 = app.pstdout->execcommand;

  else
    tmp_if_expr_6 = "<none>";
  print((enum anonymous_6)MESSAGE, "  stdout regexp command   %s\n", tmp_if_expr_6);
  print((enum anonymous_6)MESSAGE, "  stdout charbased        %i\n", app.pstdout->charbased);
  print((enum anonymous_6)MESSAGE, "  stdout esc detection    %i\n", app.pstdout->detectescape);
  print((enum anonymous_6)MESSAGE, "\n  stderr buffer length    %i\n", app.pstderr->blen);
  print((enum anonymous_6)MESSAGE, "  stderr foreground color %i\n", app.pstderr->fgcol);
  signed int tmp_if_expr_7;
  if(app.pstderr->bgcol == 9)
    tmp_if_expr_7 = -1;

  else
    tmp_if_expr_7 = app.pstderr->bgcol;
  print((enum anonymous_6)MESSAGE, "  stderr background color %i\n", tmp_if_expr_7);
  signed int tmp_if_expr_8;
  if(app.pstderr->regbgcol == 9)
    tmp_if_expr_8 = -1;

  else
    tmp_if_expr_8 = app.pstderr->regbgcol;
  print((enum anonymous_6)MESSAGE, "  stderr regexp bg color  %i\n", tmp_if_expr_8);
  print((enum anonymous_6)MESSAGE, "  stderr bold font        %i\n", app.pstderr->bold);
  print((enum anonymous_6)MESSAGE, "  stderr clip at column   ");
  if(app.pstderr->eclip == 1)
    print((enum anonymous_6)MESSAGE, "%d\n", app.pstderr->clip);

  else
    print((enum anonymous_6)MESSAGE, "%s\n", app.pstderr->eclip != 0 ? "auto" : "disable");
  char *tmp_if_expr_9;
  if(!(app.pstderr->lineprefix == ((char *)NULL)))
    tmp_if_expr_9 = app.pstderr->lineprefix;

  else
    tmp_if_expr_9 = "<none>";
  print((enum anonymous_6)MESSAGE, "  stderr line prefix      %s\n", tmp_if_expr_9);
  char *tmp_if_expr_10;
  if(!(app.pstderr->regexp == ((char *)NULL)))
    tmp_if_expr_10 = app.pstderr->regexp;

  else
    tmp_if_expr_10 = "<disabled>";
  print((enum anonymous_6)MESSAGE, "  stderr regexp           %s\n", tmp_if_expr_10);
  char *tmp_if_expr_11;
  if(!(app.pstderr->execregexp == ((char *)NULL)))
    tmp_if_expr_11 = app.pstderr->execregexp;

  else
    tmp_if_expr_11 = "<disabled>";
  print((enum anonymous_6)MESSAGE, "  stderr exec regexp      %s\n", tmp_if_expr_11);
  char *tmp_if_expr_12;
  if(!(app.pstderr->execcommand == ((char *)NULL)))
    tmp_if_expr_12 = app.pstderr->execcommand;

  else
    tmp_if_expr_12 = "<none>";
  print((enum anonymous_6)MESSAGE, "  stderr regexp command   %s\n", tmp_if_expr_12);
  print((enum anonymous_6)MESSAGE, "  stderr charbased        %i\n", app.pstderr->charbased);
  print((enum anonymous_6)MESSAGE, "  stderr esc detection    %i\n", app.pstderr->detectescape);
}

// sig_handler
// file main.c line 228
static void sig_handler(signed int signr)
{
  switch(signr)
  {
    case 28:
    {
      adjust_clipping();
      break;
    }
    case 18:
    {
      app.active = 1;
      break;
    }
    case 17:

    case 15:

    case 3:

    case 2:

    default:
    {
      app.active = 0;
      app.doexit = 1;
    }
  }
}

// string2numvalue
// file configuration.c line 783
signed int string2numvalue(char *string, signed int *value, const struct anonymous_1 *list, const struct anonymous_1 *prefixes)
{
  char *p;
  signed int tmp_value;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_6;
  if(!(list == ((const struct anonymous_1 *)NULL)))
  {
    do
    {
      unsigned long int string2numvalue__1__1__1____s1_len;
      unsigned long int string2numvalue__1__1__1____s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(string, list->string);
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
        break;

      list = list + 1l;
      if(list->string == ((char *)NULL))
        break;

    }
    while((_Bool)1);
    if(list->string == ((char *)NULL))
      goto __CPROVER_DUMP_L4;

    *value = list->value;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 0;
    signed long int return_value_strtol_4;
    return_value_strtol_4=strtol(string, &p, 0);
    tmp_value = (signed int)return_value_strtol_4;
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(*return_value___errno_location_5 == 34)
    {
      print((enum anonymous_6)ERROR, "value out of range\n");
      return -1;
    }

    else
      if(p == string)
      {
        print((enum anonymous_6)ERROR, "invalid parameter value\n");
        return -1;
      }

      else
        if(!(prefixes == ((const struct anonymous_1 *)NULL)))
        {
          if(*p == 0)
            goto __CPROVER_DUMP_L12;

          print((enum anonymous_6)ERROR, "sdf %d\n", *value);
          do
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_7;
            return_value___builtin_strcmp_7=__builtin_strcmp(p, prefixes->string);
            tmp_statement_expression_6 = return_value___builtin_strcmp_7;
            if(tmp_statement_expression_6 == 0)
              break;

            prefixes = prefixes + 1l;
            if(prefixes->string == ((char *)NULL))
              break;

          }
          while((_Bool)1);
          if(!(prefixes->string == ((char *)NULL)))
          {
            signed long long int tmp = (signed long long int)tmp_value * (signed long int)prefixes->value;
            if(tmp >= 2147483648l || !(tmp >= -2147483648l))
            {
              print((enum anonymous_6)ERROR, "value including prefix out of range\n");
              return -1;
            }

            tmp_value = (signed int)tmp;
            goto __CPROVER_DUMP_L12;
          }

          print((enum anonymous_6)ERROR, "invalid prefix for numerical value\n");
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L12:
          ;
          *value = tmp_value;
          return 0;
        }
  }
}

// usage
// file main.c line 126
void usage(void)
{
  signed int i;
  unsigned int j;
  signed int offset;
  char linebuf[81l];
  print((enum anonymous_6)MESSAGE, "%s %s\n\n", (const void *)"logapp", (const void *)"0.15");
  print((enum anonymous_6)MESSAGE, "Usage: %s [OPTION]... APPLICATION...\n", (const void *)"logapp");
  signed int return_value_snprintf_1;
  signed int return_value_snprintf_2;
  signed int return_value_snprintf_3;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_5;
  if(show_usage == 0)
    print((enum anonymous_6)MESSAGE, "\nTry \"%s --help\" for more options.\n", (const void *)"logapp");

  else
  {
    i = 0;
    for( ; !(i >= arglistsize); i = i + 1)
    {
      unsigned int descoffset = (unsigned int)0;
      unsigned int desclen;
      if(arglist[(signed long int)i].shrt == 0)
      {
        if(!(arglist[(signed long int)i].lng == ((char *)NULL)))
          goto __CPROVER_DUMP_L3;

        if(arglist[(signed long int)i].desc == ((char *)NULL))
          goto __CPROVER_DUMP_L3;

        print((enum anonymous_6)MESSAGE, "\n%s\n", arglist[(signed long int)i].desc);
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        snprintf(linebuf, (unsigned long int)3, "  ");
        if(!(arglist[(signed long int)i].shrt == 0))
          snprintf(&linebuf[(signed long int)2], (unsigned long int)4, "-%c ", arglist[(signed long int)i].shrt);

        else
          snprintf(&linebuf[(signed long int)2], (unsigned long int)4, "    ");
        offset = 5;
        if(!(arglist[(signed long int)i].lng == ((char *)NULL)))
        {
          return_value_snprintf_1=snprintf(&linebuf[(signed long int)5], (unsigned long int)(80 - 5), "--%s", arglist[(signed long int)i].lng);
          offset = offset + return_value_snprintf_1;
        }

        else
        {
          return_value_snprintf_2=snprintf(&linebuf[(signed long int)5], (unsigned long int)5, "    ");
          offset = offset + return_value_snprintf_2;
        }
        if(!(arglist[(signed long int)i].parm == ((char *)NULL)))
        {
          return_value_snprintf_3=snprintf(&linebuf[(signed long int)offset], (unsigned long int)(80 - offset), "=%s ", arglist[(signed long int)i].parm);
          offset = offset + return_value_snprintf_3;
        }

        if(!(offset >= 5))
        {
          print((enum anonymous_6)ERROR, "unable to generate usage information\n");
          exit(1);
        }

        j = (unsigned int)offset;
        for( ; !(j >= 33u); j = j + 1u)
        {
          linebuf[(signed long int)j] = (char)32;
          offset = offset + 1;
        }
        linebuf[(signed long int)j] = (char)0;
        if(arglist[(signed long int)i].desc == ((char *)NULL))
          print((enum anonymous_6)MESSAGE, "%s\n", (const void *)linebuf);

        else
        {
          j = (unsigned int)0;
          do
          {
            return_value_strlen_4=strlen(arglist[(signed long int)i].desc);
            desclen = (unsigned int)return_value_strlen_4;
            if(j >= 2u + desclen)
              break;

            if((signed int)arglist[(signed long int)i].desc[(signed long int)j] == 32)
              tmp_if_expr_5 = (_Bool)1;

            else
              tmp_if_expr_5 = (signed int)arglist[(signed long int)i].desc[(signed long int)j] == 10 ? (_Bool)1 : (_Bool)0;
            if(!(desclen >= j) || tmp_if_expr_5)
            {
              if(j + (unsigned int)offset + -descoffset >= 80u)
              {
                linebuf[(signed long int)offset] = (char)10;
                linebuf[(signed long int)(offset + 1)] = (char)0;
                offset = 33 + 1;
                print((enum anonymous_6)MESSAGE, "%s", (const void *)linebuf);
                memset((void *)linebuf, 32, (unsigned long int)offset);
              }

              memcpy((void *)&linebuf[(signed long int)offset], (const void *)&arglist[(signed long int)i].desc[(signed long int)descoffset], (unsigned long int)(j - descoffset));
              offset = offset + (signed int)(j - descoffset);
              descoffset = j;
              linebuf[(signed long int)offset] = (char)0;
            }

            j = j + 1u;
          }
          while((_Bool)1);
          print((enum anonymous_6)MESSAGE, "%s\n", (const void *)linebuf);
        }
      }
    }
    print((enum anonymous_6)MESSAGE, "\nPlease send bug reports and feature requests to %s\n", (const void *)"Michael Brunner <mibru@gmx.de>");
  }
}

// version
// file main.c line 215
void version(void)
{
  print((enum anonymous_6)MESSAGE, "%s %s\n", (const void *)"logapp", (const void *)"0.15");
  print((enum anonymous_6)MESSAGE, "Build date: %s %s\n", (const void *)"Jan 25 2016", (const void *)"05:37:58");
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen("");
  if(!(return_value_strlen_1 == 0ul))
    print((enum anonymous_6)MESSAGE, "SVN revision: %s\n\n", (const void *)"");

  print((enum anonymous_6)MESSAGE, "\nCompiletime configuration:\n");
  print((enum anonymous_6)MESSAGE, "  PTY support %s\n", 1 != 0 ? "enabled" : "disabled");
  print((enum anonymous_6)MESSAGE, "  Thread usage %s\n\n", 1 != 0 ? "enabled" : "disabled");
}

