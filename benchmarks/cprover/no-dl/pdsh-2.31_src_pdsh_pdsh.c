// #anon_enum_CBUF_NO_DROP=0_CBUF_WRAP_ONCE=1_CBUF_WRAP_MANY=2
// file cbuf.h line 74
enum anonymous_9 { CBUF_NO_DROP=0, CBUF_WRAP_ONCE=1, CBUF_WRAP_MANY=2 };

// #anon_enum_CBUF_OPT_OVERWRITE=0
// file cbuf.h line 70
enum anonymous_10 { CBUF_OPT_OVERWRITE=0 };

// #anon_enum_DSH=1_PCP=2
// file ../../src/pdsh/opt.h line 47
enum anonymous_5 { DSH=1, PCP=2 };

// #anon_enum_DSH_NEW=0_DSH_RCMD=1_DSH_READING=2_DSH_DONE=3_DSH_FAILED=4_DSH_CANCELED=5
// file dsh.h line 53
enum anonymous_8 { DSH_NEW=0, DSH_RCMD=1, DSH_READING=2, DSH_DONE=3, DSH_FAILED=4, DSH_CANCELED=5 };

// #anon_enum_FAIL=0_PASS=1
// file testcase.c line 50
enum anonymous_6 { FAIL=0, PASS=1 };

// #anon_enum_false=0_true=1
// file ../../src/common/macros.h line 60
enum anonymous { false=0, true=1 };

// tag-#anon#ST[*{S8}_S8_'desc'||*{EN#anon_enum_FAIL=0_PASS=1#{U32}_U32_()->EN#anon_enum_FAIL=0_PASS=1#{U32}_U32_}_EN#anon_enum_FAIL=0_PASS=1#{U32}_U32_()->EN#anon_enum_FAIL=0_PASS=1#{U32}_U32__'fun'|]
// file testcase.c line 52
struct anonymous_7;

// tag-#anon#ST[*{S8}_S8_'filename'||*{S8}_S8_'name'||S32'ref_count'||U32'_pad0'|]
// file ltdl.h line 242
struct anonymous_25;

// tag-#anon#ST[*{S8}_S8_'progname'||EN#anon_enum_false=0_true=1#{U32}_U32_'debug'||EN#anon_enum_false=0_true=1#{U32}_U32_'info_only'||EN#anon_enum_false=0_true=1#{U32}_U32_'test_range_expansion'||EN#anon_enum_false=0_true=1#{U32}_U32_'sdr_verify'||EN#anon_enum_false=0_true=1#{U32}_U32_'sdr_global'||EN#anon_enum_false=0_true=1#{U32}_U32_'altnames'||EN#anon_enum_false=0_true=1#{U32}_U32_'sigint_terminates'||U32'_pad0'||*{SYM#tag-hostlist#}_SYM#tag-hostlist#_'wcoll'||*{S8}_S8_'luser'||U32'luid'||U32'_pad1'||*{S8}_S8_'ruser'||S32'fanout'||S32'connect_timeout'||S32'command_timeout'||U32'_pad2'||*{S8}_S8_'rcmd_name'||*{S8}_S8_'misc_modules'||EN#anon_enum_false=0_true=1#{U32}_U32_'resolve_hosts'||EN#anon_enum_false=0_true=1#{U32}_U32_'kill_on_fail'||EN#anon_enum_false=0_true=1#{U32}_U32_'separate_stderr'||EN#anon_enum_false=0_true=1#{U32}_U32_'stdin_unavailable'||*{S8}_S8_'cmd'||*{S8}_S8_'dshpath'||*{S8}_S8_'getstat'||EN#anon_enum_false=0_true=1#{U32}_U32_'ret_remote_rc'||EN#anon_enum_false=0_true=1#{U32}_U32_'labels'||EN#anon_enum_false=0_true=1#{U32}_U32_'preserve'||EN#anon_enum_false=0_true=1#{U32}_U32_'recursive'||*{SYM#tag-list#}_SYM#tag-list#_'infile_names'||*{S8}_S8_'outfile_name'||EN#anon_enum_false=0_true=1#{U32}_U32_'pcp_server'||EN#anon_enum_false=0_true=1#{U32}_U32_'target_is_directory'||EN#anon_enum_false=0_true=1#{U32}_U32_'pcp_client'||U32'_pad3'||*{S8}_S8_'pcp_client_host'||*{S8}_S8_'local_program_path'||*{S8}_S8_'remote_program_path'||EN#anon_enum_false=0_true=1#{U32}_U32_'reverse_copy'||U32'_pad4'|]
// file ../../src/pdsh/opt.h line 49
struct anonymous_1;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_22;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_20;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_11;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_14;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_0;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_16;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_19;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_18;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_13;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_17;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_21;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_12;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_23;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_15;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_buf
// file pcp_server.c line 116
struct _buf;

// tag-_range
// file hostlist.c line 1387
struct _range;

// tag-cbuf
// file cbuf.h line 68
struct cbuf;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-hostlist
// file hostlist.h line 59
struct hostlist;

// tag-hostlist_iterator
// file hostlist.h line 74
struct hostlist_iterator;

// tag-hostname_components
// file hostlist.c line 118
struct hostname_components;

// tag-hostrange_components
// file hostlist.c line 131
struct hostrange_components;

// tag-hostset
// file hostlist.h line 68
struct hostset;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-list
// file list.h line 58
struct list;

// tag-listIterator
// file list.h line 63
struct listIterator;

// tag-listNode
// file list.c line 92
struct listNode;

// tag-lt_dlhandle_struct
// file ltdl.h line 153
struct lt_dlhandle_struct;

// tag-module_components
// file mod.h line 37
struct module_components;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-node_rcmd_info
// file rcmd.c line 64
struct node_rcmd_info;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pcp_client
// file pcp_client.h line 56
struct pcp_client;

// tag-pcp_filename
// file pcp_client.h line 48
struct pcp_filename;

// tag-pcp_server
// file pcp_server.h line 36
struct pcp_server;

// tag-pdsh_module
// file mod.h line 203
struct pdsh_module;

// tag-pdsh_module_operations
// file mod.h line 179
struct pdsh_module_operations;

// tag-pdsh_module_option
// file ../../src/pdsh/opt.h line 137
struct pdsh_module_option;

// tag-pdsh_rcmd_operations
// file mod.h line 193
struct pdsh_rcmd_operations;

// tag-permission_error
// file mod.c line 86
enum permission_error { DIR_OK=0, DIR_NOT_DIRECTORY=1, DIR_BAD_OWNER=2, DIR_WORLD_WRITABLE=3 };

// tag-pid
// file xpopen.c line 61
struct pid;

// tag-pipe_info_struct
// file ../../src/common/pipecmd.h line 30
struct pipe_info_struct;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rcmd_info
// file ../../src/pdsh/rcmd.h line 38
struct rcmd_info;

// tag-rcmd_module
// file rcmd.h line 41
struct rcmd_module;

// tag-rcmd_options
// file ../../src/pdsh/rcmd.h line 32
struct rcmd_options;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-regex_info
// file opt.c line 1215
struct regex_info;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-thd
// file dsh.h line 56
struct thd;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-wcoll_ctx
// file wcoll.c line 52
struct wcoll_ctx;

// tag-xpollfd
// file ../../src/common/xpoll.h line 38
struct xpollfd;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// Free
// file ../../src/common/xmalloc.h line 34
void Free(void **item);
// Malloc
// file ../../src/common/xmalloc.h line 32
void * Malloc(unsigned long int size);
// Realloc
// file ../../src/common/xmalloc.h line 33
void Realloc(void **item, unsigned long int newsize);
// Size
// file xmalloc.c line 123
signed int Size(void *item);
// Strdup
// file ../../src/common/xmalloc.h line 36
char * Strdup(const char *str);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _alarm_handler
// file dsh.c line 184
static void _alarm_handler(signed int dummy);
// _allocbuf
// file pcp_server.c line 164
static struct _buf * _allocbuf(struct pcp_server *s, struct _buf *bp, signed int fd, signed int blksize);
// _attempt_range_join
// file hostlist.c line 2053
static signed int _attempt_range_join(struct hostlist *hl, signed int loc);
// _cancel_pending_threads
// file dsh.c line 889
static signed int _cancel_pending_threads(void);
// _check_path
// file opt.c line 226
char * _check_path(char *dir, char *cwd, char *argv0);
// _cmp
// file hostlist.c line 1943
signed int _cmp(const void *hr1, const void *hr2);
// _cmp_f
// file mod.c line 320
static signed int _cmp_f(struct module_components *x, struct module_components *y);
// _cmp_filenames
// file mod.c line 945
static signed int _cmp_filenames(struct module_components *mod, char *filename);
// _cmp_type
// file mod.c line 461
static signed int _cmp_type(struct module_components *mod, char *type);
// _die_if_signalled
// file dsh.c line 593
static signed int _die_if_signalled(struct thd *t);
// _dir_permission_error
// file mod.c line 987
static enum permission_error _dir_permission_error(struct stat *st, unsigned int alt_uid);
// _do_output
// file dsh.c line 523
static signed int _do_output(signed int fd, struct cbuf *cb, void (*outf)(const char *, ...), enum anonymous read_rc, struct thd *t);

//

// _dsh_attr_init
// file dsh.c line 806
static signed int _dsh_attr_init(union pthread_attr_t *attrp, signed int stacksize);
// _dump_debug_stats
// file dsh.c line 760
static void _dump_debug_stats(signed int rshcount);
// _error
// file pcp_server.c line 192
static void _error(struct pcp_server *s, const char *fmt, ...);
// _error_link1
// file hostlist.c line 336
static void _error_link1(char *file, signed int line, char *msg, ...);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _extract_rc
// file dsh.c line 507
static signed int _extract_rc(char *buf);
// _fd_get_lock
// file fd.c line 123
static signed int _fd_get_lock(signed int fd, signed int cmd, signed int type);
// _fd_test_lock
// file fd.c line 139
static signed int _fd_test_lock(signed int fd, signed int type);
// _find_path
// file opt.c line 249
char * _find_path(char *argv0);
// _flush_output
// file dsh.c line 579
static void _flush_output(struct cbuf *cb, void (*outf)(const char *, ...), struct thd *t);

//

// _fwd_signal
// file dsh.c line 260
static void _fwd_signal(signed int signum);
// _get_bracketed_list
// file hostlist.c line 2136
static signed int _get_bracketed_list(struct hostlist *hl, signed int *start, const unsigned long int n, char *buf);
// _get_dir_name
// file mod.c line 1004
static char * _get_dir_name(const char *path, char *buf, unsigned long int len);
// _getcmd
// file main.c line 382
static char * _getcmd(char *prompt);
// _gethost
// file dsh.c line 333
static void _gethost(char *name, char *addr);
// _handle_rcmd_stderr
// file dsh.c line 620
static signed int _handle_rcmd_stderr(struct thd *th);
// _handle_rcmd_stdout
// file dsh.c line 608
static signed int _handle_rcmd_stdout(struct thd *th);
// _handle_sigint
// file dsh.c line 915
static void _handle_sigint(signed long int *last_intrp);
// _handle_sigtstp
// file dsh.c line 940
static void _handle_sigtstp(signed long int last_intr);
// _hostlist_create
// file hostlist.c line 1380
static struct hostlist * _hostlist_create(const char *hostlist, char *sep, char *r_op);
// _hostlist_create_bracketed
// file hostlist.c line 1498
static struct hostlist * _hostlist_create_bracketed(const char *hostlist, char *sep, char *r_op);
// _hostrange_string
// file hostlist.c line 1833
static char * _hostrange_string(struct hostrange_components *hr, signed int depth);
// _increase_nofile_limit
// file dsh.c line 826
static void _increase_nofile_limit(struct anonymous_1 *opt);
// _infile_names_check
// file opt.c line 787
static signed int _infile_names_check(struct anonymous_1 *opt);
// _init_pdsh_options
// file opt.c line 174
static void _init_pdsh_options();
// _interactive_dsh
// file main.c line 319
static void _interactive_dsh(struct anonymous_1 *opt);
// _is_bracket_needed
// file hostlist.c line 2120
static signed int _is_bracket_needed(struct hostlist *hl, signed int i);
// _is_loaded
// file mod.c line 951
static signed int _is_loaded(char *filename);
// _iterator_advance
// file hostlist.c line 2273
static void _iterator_advance(struct hostlist_iterator *i);
// _iterator_advance_range
// file hostlist.c line 2289
static void _iterator_advance_range(struct hostlist_iterator *i);
// _list_slowthreads
// file dsh.c line 192
static void _list_slowthreads(void);
// _makespace
// file xstring.c line 87
static void _makespace(char **str, signed int needed);
// _mask_signals
// file dsh.c line 243
static void _mask_signals(signed int how);
// _mod_delete
// file mod.c line 686
static signed int _mod_delete(const char *type, const char *name);
// _mod_description_match
// file mod.c line 547
static signed int _mod_description_match(struct module_components *m, const char *type, const char *name);
// _mod_destroy
// file mod.c line 277
static void _mod_destroy(struct module_components *mod);
// _mod_find_misc
// file mod.c line 329
static signed int _mod_find_misc(struct module_components *mod, const char *name);
// _mod_find_opt
// file mod.c line 677
static struct pdsh_module_option * _mod_find_opt(struct module_components *mod, signed int opt);
// _mod_get_module_names
// file mod.c line 491
static struct list * _mod_get_module_names(char *type, signed int get_active);
// _mod_init_list_safe
// file mod.c line 757
static signed int _mod_init_list_safe(struct module_components *mod, void *arg);
// _mod_initialize
// file mod.c line 735
static signed int _mod_initialize(struct module_components *mod);
// _mod_initialize_by_name
// file mod.c line 339
static signed int _mod_initialize_by_name(char *name, struct list *l);
// _mod_initialize_modules_by_name
// file mod.c line 349
static signed int _mod_initialize_modules_by_name(char *names, struct list *m);
// _mod_load_dynamic
// file mod.c line 806
static signed int _mod_load_dynamic(const char *fq_path);
// _mod_load_dynamic_modules
// file mod.c line 875
static signed int _mod_load_dynamic_modules(const char *dir, struct anonymous_1 *pdsh_opts);
// _mod_next_active
// file mod.c line 181
static struct module_components * _mod_next_active(struct listIterator *i);
// _mod_opts_ok
// file mod.c line 311
static enum anonymous _mod_opts_ok(struct module_components *mod);
// _mod_postop
// file mod.c line 169
signed int _mod_postop(struct module_components *mod, struct anonymous_1 *pdsh_opts);
// _mod_print_info
// file mod.c line 426
static signed int _mod_print_info(struct module_components *mod);
// _mod_read_wcoll
// file mod.c line 160
struct hostlist * _mod_read_wcoll(struct module_components *mod, struct anonymous_1 *pdsh_opts);
// _mod_register
// file mod.c line 699
static signed int _mod_register(struct module_components *mod, const char *name);
// _module_list_string
// file opt.c line 1053
static signed int _module_list_string(char *type, char *buf, signed int len);
// _module_list_uninitialized
// file opt.c line 1068
static signed int _module_list_uninitialized(char *type, char *buf, signed int len);
// _next_tok
// file hostlist.c line 366
static char * _next_tok(char *sep, char **str);
// _next_tok_link1
// file split.c line 45
static char * _next_tok_link1(char *sep_link1, char **str_link1);
// _opt_print
// file mod.c line 446
static signed int _opt_print(struct module_components *mod, signed int *col);
// _parallel_copy
// file dsh.c line 395
static signed int _parallel_copy(struct thd *th);
// _parse_command_with_quotes
// file xpopen.c line 211
static void _parse_command_with_quotes(char **argv, signed int maxn, char *str);
// _parse_range_list
// file hostlist.c line 1443
static signed int _parse_range_list(char *str, struct _range *ranges, signed int len);
// _parse_single_range
// file hostlist.c line 1396
static signed int _parse_single_range(const char *str, struct _range *range);
// _path_permissions_ok
// file mod.c line 1040
static enum anonymous _path_permissions_ok(const char *dir, unsigned int pdsh_owner);
// _pcp_client
// file dsh.c line 380
static signed int _pcp_client(struct thd *th);
// _pcp_remote_client
// file main.c line 411
static signed int _pcp_remote_client(struct anonymous_1 *opt);
// _pcp_remote_server
// file main.c line 398
static signed int _pcp_remote_server(struct anonymous_1 *opt);
// _pcp_send_file_data
// file pcp_client.c line 205
static signed int _pcp_send_file_data(signed int outfd, char *filename, char *host);
// _pcp_sendfile
// file pcp_client.c line 365
static signed int _pcp_sendfile(struct pcp_filename *pf, struct pcp_client *pcp);
// _pcp_server
// file dsh.c line 367
static signed int _pcp_server(struct thd *th);
// _pcp_write
// file pcp_client.c line 180
static signed int _pcp_write(signed int fd, char *buf, signed int size);
// _pdsh_owner
// file mod.c line 860
static signed int _pdsh_owner(const char *pdsh_path, unsigned int *pdsh_uid);
// _perm_error_string
// file mod.c line 960
static char * _perm_error_string(enum permission_error error);
// _pipecmd
// file pipecmd.c line 255
static signed int _pipecmd(char *path, char **args, signed int *fd2p, signed int *ppid);
// _poll
// file xpoll.c line 54
static signed int _poll(struct xpollfd *xfds, unsigned int nfds, signed int timeout);
// _print_option_help
// file mod.c line 391
static void _print_option_help(struct pdsh_module_option *p, signed int col);
// _push_range_list
// file hostlist.c line 1461
static void _push_range_list(struct hostlist *hl, char *pfx, struct _range *rng, signed int n);
// _push_range_list_with_suffix
// file hostlist.c line 1472
static void _push_range_list_with_suffix(struct hostlist *hl, char *pfx, char *sfx, struct _range *rng, signed int n);
// _rcmd_module_list
// file opt.c line 1084
static char * _rcmd_module_list(char *buf, signed int maxlen);
// _rcp_thread
// file dsh.c line 450
static void * _rcp_thread(void *args);
// _response
// file pcp_server.c line 142
static signed int _response(struct pcp_server *s);
// _rexpand_dir
// file pcp_client.c line 94
static void _rexpand_dir(struct list *list, char *name);
// _rsh_thread
// file dsh.c line 636
static void * _rsh_thread(void *args);
// _shell
// file main.c line 362
static void _shell(unsigned int uid, char *cmd);
// _show_version
// file opt.c line 1142
static void _show_version(void);
// _signals_thread
// file dsh.c line 951
static void * _signals_thread(void *arg);
// _sink
// file pcp_server.c line 214
static void _sink(struct pcp_server *svr, char *targ, struct _buf *bufp);
// _strcatchar
// file xstring.c line 126
static void _strcatchar(char *str, char c);
// _test_pipecmd
// file testcase.c line 91
static enum anonymous_6 _test_pipecmd(void);
// _test_xstrerrorcat
// file testcase.c line 71
static enum anonymous_6 _test_xstrerrorcat(void);
// _testmsg
// file testcase.c line 65
static void _testmsg(signed int testnum, enum anonymous_6 result);
// _thd_command_timeout
// file dsh.c line 282
static signed int _thd_command_timeout(struct thd *t);
// _thd_connect_timeout
// file dsh.c line 273
static signed int _thd_connect_timeout(struct thd *t);
// _thd_init
// file dsh.c line 849
static signed int _thd_init(struct thd *th, struct anonymous_1 *opt, struct list *pcp_infiles, signed int i);
// _update_connect_state
// file dsh.c line 349
static enum anonymous_8 _update_connect_state(struct thd *a);
// _usage
// file opt.c line 1118
static void _usage(struct anonymous_1 *opt);
// _verifydir
// file pcp_server.c line 128
static signed int _verifydir(struct pcp_server *s, const char *cp);
// _verr
// file err.c line 101
static void _verr(struct _IO_FILE *stream, char *format, __builtin_va_list ap);
// _wdog
// file dsh.c line 297
static void * _wdog(void *args);
// _width_equiv
// file hostlist.c line 419
static signed int _width_equiv(unsigned long int n, signed int *wn, unsigned long int m, signed int *wm);
// _xsignal
// file dsh.c line 166
static void (*_xsignal(signed int signal, void (*handler)(signed int)))(signed int);

//

// _zero_padded
// file hostlist.c line 398
static signed int _zero_padded(unsigned long int num, signed int width);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// cbuf_copier
// file cbuf.c line 1337
static signed int cbuf_copier(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped);
// cbuf_copy
// file cbuf.c line 1007
signed int cbuf_copy(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped);
// cbuf_create
// file ../../src/pdsh/cbuf.h line 85
struct cbuf * cbuf_create(signed int minsize, signed int maxsize);
// cbuf_destroy
// file ../../src/pdsh/cbuf.h line 95
void cbuf_destroy(struct cbuf *cb);
// cbuf_drop
// file cbuf.c line 477
signed int cbuf_drop(struct cbuf *src, signed int len);
// cbuf_drop_line
// file cbuf.c line 639
signed int cbuf_drop_line(struct cbuf *src, signed int len, signed int lines);
// cbuf_dropper
// file cbuf.c line 1423
static signed int cbuf_dropper(struct cbuf *cb, signed int len);
// cbuf_find_replay_line
// file cbuf.c line 1108
static signed int cbuf_find_replay_line(struct cbuf *cb, signed int chars, signed int *nlines, signed int *nl);
// cbuf_find_unread_line
// file cbuf.c line 1203
static signed int cbuf_find_unread_line(struct cbuf *cb, signed int chars, signed int *nlines);
// cbuf_flush
// file cbuf.c line 306
void cbuf_flush(struct cbuf *cb);
// cbuf_free
// file cbuf.c line 338
signed int cbuf_free(struct cbuf *cb);
// cbuf_get_fd
// file cbuf.c line 1261
static signed int cbuf_get_fd(void *dstbuf, signed int *psrcfd, signed int len);
// cbuf_get_mem
// file cbuf.c line 1282
static signed int cbuf_get_mem(void *dstbuf, unsigned char **psrcbuf, signed int len);
// cbuf_grow
// file cbuf.c line 1649
static signed int cbuf_grow(struct cbuf *cb, signed int n);
// cbuf_is_empty
// file cbuf.c line 408
signed int cbuf_is_empty(struct cbuf *cb);
// cbuf_lines_reused
// file cbuf.c line 394
signed int cbuf_lines_reused(struct cbuf *cb);
// cbuf_lines_used
// file cbuf.c line 366
signed int cbuf_lines_used(struct cbuf *cb);
// cbuf_move
// file cbuf.c line 1056
signed int cbuf_move(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped);
// cbuf_opt_get
// file cbuf.c line 422
signed int cbuf_opt_get(struct cbuf *cb, enum anonymous_10 name, signed int *value);
// cbuf_opt_set
// file cbuf.c line 447
signed int cbuf_opt_set(struct cbuf *cb, enum anonymous_10 name, signed int value);
// cbuf_peek
// file cbuf.c line 507
signed int cbuf_peek(struct cbuf *src, void *dstbuf, signed int len);
// cbuf_peek_line
// file ../../src/pdsh/cbuf.h line 208
signed int cbuf_peek_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines);
// cbuf_peek_to_fd
// file cbuf.c line 893
signed int cbuf_peek_to_fd(struct cbuf *src, signed int dstfd, signed int len);
// cbuf_put_fd
// file cbuf.c line 1299
static signed int cbuf_put_fd(void *srcbuf, signed int *pdstfd, signed int len);
// cbuf_put_mem
// file cbuf.c line 1320
static signed int cbuf_put_mem(void *srcbuf, unsigned char **pdstbuf, signed int len);
// cbuf_read
// file ../../src/pdsh/cbuf.h line 171
signed int cbuf_read(struct cbuf *src, void *dstbuf, signed int len);
// cbuf_read_line
// file cbuf.c line 702
signed int cbuf_read_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines);
// cbuf_read_to_fd
// file cbuf.c line 918
signed int cbuf_read_to_fd(struct cbuf *src, signed int dstfd, signed int len);
// cbuf_reader
// file cbuf.c line 1449
static signed int cbuf_reader(struct cbuf *src, signed int len, signed int (*putf)(void *, void *, signed int), void *dst);

//

// cbuf_replay
// file cbuf.c line 556
signed int cbuf_replay(struct cbuf *src, void *dstbuf, signed int len);
// cbuf_replay_line
// file cbuf.c line 739
signed int cbuf_replay_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines);
// cbuf_replay_to_fd
// file cbuf.c line 946
signed int cbuf_replay_to_fd(struct cbuf *src, signed int dstfd, signed int len);
// cbuf_replayer
// file cbuf.c line 1505
static signed int cbuf_replayer(struct cbuf *src, signed int len, signed int (*putf)(void *, void *, signed int), void *dst);

//

// cbuf_reused
// file cbuf.c line 380
signed int cbuf_reused(struct cbuf *cb);
// cbuf_rewind
// file cbuf.c line 579
signed int cbuf_rewind(struct cbuf *src, signed int len);
// cbuf_rewind_line
// file cbuf.c line 784
signed int cbuf_rewind_line(struct cbuf *src, signed int len, signed int lines);
// cbuf_shrink
// file cbuf.c line 1724
static signed int cbuf_shrink(struct cbuf *cb);
// cbuf_size
// file cbuf.c line 324
signed int cbuf_size(struct cbuf *cb);
// cbuf_used
// file cbuf.c line 352
signed int cbuf_used(struct cbuf *cb);
// cbuf_write
// file cbuf.c line 613
signed int cbuf_write(struct cbuf *dst, void *srcbuf, signed int len, signed int *ndropped);
// cbuf_write_from_fd
// file ../../src/pdsh/cbuf.h line 290
signed int cbuf_write_from_fd(struct cbuf *dst, signed int srcfd, signed int len, signed int *ndropped);
// cbuf_write_line
// file cbuf.c line 812
signed int cbuf_write_line(struct cbuf *dst, char *srcbuf, signed int *ndropped);
// cbuf_writer
// file cbuf.c line 1562
static signed int cbuf_writer(struct cbuf *dst, signed int len, signed int (*getf)(void *, void *, signed int), void *src, signed int *ndropped);

//

// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closeall
// file pipecmd.c line 246
static void closeall(signed int fd);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// cmd_args_create
// file pipecmd.c line 135
static char ** cmd_args_create(struct pipe_info_struct *e, const char **argv);
// cmd_args_destroy
// file pipecmd.c line 157
static void cmd_args_destroy(char **args);
// copy_username
// file opt.c line 321
static void copy_username(char *dst, const char *src);
// create_privileged_child
// file privsep.c line 250
static signed int create_privileged_child(void);
// create_socketpair
// file privsep.c line 85
static signed int create_socketpair(void);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// drop_privileges
// file privsep.c line 100
static void drop_privileges(void);
// dsh
// file dsh.h line 95
signed int dsh(struct anonymous_1 *opt);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// err
// file ../../src/common/err.h line 35
void err(char *format, ...);
// err_cleanup
// file ../../src/common/err.h line 39
void err_cleanup(void);
// err_init
// file ../../src/common/err.h line 33
void err_init(char *str);
// err_no_strip_domain
// file ../../src/common/err.h line 34
void err_no_strip_domain();
// errf
// file ../../src/common/err.h line 38
void errf(struct _IO_FILE *stream, char *format, void **ap);
// errx
// file ../../src/common/err.h line 37
void errx(char *format, ...);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fchmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 296
extern signed int fchmod(signed int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fd_get_read_lock
// file fd.c line 74
signed int fd_get_read_lock(signed int fd);
// fd_get_readw_lock
// file fd.c line 81
signed int fd_get_readw_lock(signed int fd);
// fd_get_write_lock
// file fd.c line 88
signed int fd_get_write_lock(signed int fd);
// fd_get_writew_lock
// file fd.c line 95
signed int fd_get_writew_lock(signed int fd);
// fd_is_read_lock_blocked
// file fd.c line 109
signed int fd_is_read_lock_blocked(signed int fd);
// fd_is_write_lock_blocked
// file fd.c line 116
signed int fd_is_write_lock_blocked(signed int fd);
// fd_null_read_n
// file fd.c line 244
signed long int fd_null_read_n(signed int fd, void *buf, unsigned long int n);
// fd_read_line
// file ../../src/common/fd.h line 112
signed long int fd_read_line(signed int fd, void *buf, unsigned long int maxlen);
// fd_read_n
// file ../../src/common/fd.h line 100
signed long int fd_read_n(signed int fd, void *buf, unsigned long int n);
// fd_release_lock
// file fd.c line 102
signed int fd_release_lock(signed int fd);
// fd_set_close_on_exec
// file fd.c line 48
signed int fd_set_close_on_exec(signed int fd);
// fd_set_nonblocking
// file ../../src/common/fd.h line 46
signed int fd_set_nonblocking(signed int fd);
// fd_write_n
// file fd.c line 185
signed long int fd_write_n(signed int fd, void *buf, unsigned long int n);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_host
// file rcmd.c line 151
static signed int find_host(struct node_rcmd_info *x, char *hostname);
// find_rcmd_module
// file rcmd.c line 146
static signed int find_rcmd_module(struct rcmd_module *x, char *name);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_f
// file opt.c line 1210
void free_f(void *x);
// free_f_link1
// file wcoll.c line 58
static void free_f_link1(void *x_link1);
// free_f_link2
// file split.c line 77
static void free_f_link2(char *str);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// get_file_path
// file wcoll.c line 296
static char * get_file_path(const char *file, char *dir, signed int len);
// get_host_rcmd_type
// file opt.c line 1171
static signed int get_host_rcmd_type(char *hosts, char **rptr, char **hptr, char **uptr);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getegid
// file /usr/include/unistd.h line 684
extern unsigned int getegid(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(signed int, struct rlimit *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// host_prefix_end
// file hostlist.c line 457
static signed int host_prefix_end(const char *hostname);
// host_rcmd_info
// file rcmd.c line 156
static struct node_rcmd_info * host_rcmd_info(char *host);
// hostlist_assign
// file opt.c line 1288
static void hostlist_assign(struct hostlist **hlp, struct hostlist *hl2);
// hostlist_coalesce
// file hostlist.c line 1999
static void hostlist_coalesce(struct hostlist *hl);
// hostlist_collapse
// file hostlist.c line 1977
static void hostlist_collapse(struct hostlist *hl);
// hostlist_copy
// file hostlist.c line 1558
struct hostlist * hostlist_copy(struct hostlist * const hl);
// hostlist_count
// file ../../src/common/hostlist.h line 248
signed int hostlist_count(struct hostlist *hl);
// hostlist_create
// file ../../src/common/hostlist.h line 106
struct hostlist * hostlist_create(const char *str);
// hostlist_delete
// file ../../src/common/hostlist.h line 220
signed int hostlist_delete(struct hostlist *hl, const char *hosts);
// hostlist_delete_host
// file hostlist.c line 1823
signed int hostlist_delete_host(struct hostlist *hl, const char *hostname);
// hostlist_delete_nth
// file hostlist.c line 1867
signed int hostlist_delete_nth(struct hostlist *hl, signed int n);
// hostlist_delete_range
// file hostlist.c line 1222
static void hostlist_delete_range(struct hostlist *hl, signed int n);
// hostlist_deranged_string
// file ../../src/common/hostlist.h line 295
signed long int hostlist_deranged_string(struct hostlist *hl, unsigned long int n, char *buf);
// hostlist_destroy
// file ../../src/common/hostlist.h line 119
void hostlist_destroy(struct hostlist *hl);
// hostlist_expand
// file hostlist.c line 1118
static signed int hostlist_expand(struct hostlist *hl);
// hostlist_filter_regex
// file opt.c line 1259
void hostlist_filter_regex(struct hostlist *hl, struct regex_info *re);
// hostlist_find
// file hostlist.c line 1913
signed int hostlist_find(struct hostlist *hl, const char *hostname);
// hostlist_insert_range
// file hostlist.c line 1182
static signed int hostlist_insert_range(struct hostlist *hl, struct hostrange_components *hr, signed int n);
// hostlist_iterator_create
// file ../../src/common/hostlist.h line 316
struct hostlist_iterator * hostlist_iterator_create(struct hostlist *hl);
// hostlist_iterator_destroy
// file ../../src/common/hostlist.h line 329
void hostlist_iterator_destroy(struct hostlist_iterator *i);
// hostlist_iterator_new
// file hostlist.c line 2208
static struct hostlist_iterator * hostlist_iterator_new(void);
// hostlist_iterator_reset
// file hostlist.c line 2243
void hostlist_iterator_reset(struct hostlist_iterator *i);
// hostlist_new
// file hostlist.c line 1059
static struct hostlist * hostlist_new(void);
// hostlist_next
// file ../../src/common/hostlist.h line 344
char * hostlist_next(struct hostlist_iterator *i);
// hostlist_next_range
// file hostlist.c line 2339
char * hostlist_next_range(struct hostlist_iterator *i);
// hostlist_nth
// file hostlist.c line 1844
char * hostlist_nth(struct hostlist *hl, signed int n);
// hostlist_pop
// file ../../src/common/hostlist.h line 165
char * hostlist_pop(struct hostlist *hl);
// hostlist_pop_range
// file hostlist.c line 1728
char * hostlist_pop_range(struct hostlist *hl);
// hostlist_push
// file ../../src/common/hostlist.h line 133
signed int hostlist_push(struct hostlist *hl, const char *hosts);
// hostlist_push_host
// file hostlist.c line 1622
signed int hostlist_push_host(struct hostlist *hl, const char *str);
// hostlist_push_hr
// file hostlist.c line 1170
static signed int hostlist_push_hr(struct hostlist *hl, char *prefix, unsigned long int lo, unsigned long int hi, signed int width);
// hostlist_push_list
// file ../../src/common/hostlist.h line 154
signed int hostlist_push_list(struct hostlist *h1, struct hostlist *h2);
// hostlist_push_range
// file hostlist.c line 1130
static signed int hostlist_push_range(struct hostlist *hl, struct hostrange_components *hr);
// hostlist_ranged_string
// file ../../src/common/hostlist.h line 283
signed long int hostlist_ranged_string(struct hostlist *hl, unsigned long int n, char *buf);
// hostlist_register_rcmd
// file rcmd.c line 195
static signed int hostlist_register_rcmd(const char *hosts, struct rcmd_module *rmod, char *user);
// hostlist_remove
// file ../../src/common/hostlist.h line 363
signed int hostlist_remove(struct hostlist_iterator *i);
// hostlist_resize
// file hostlist.c line 1097
static signed int hostlist_resize(struct hostlist *hl, unsigned long int newsize);
// hostlist_shift
// file ../../src/common/hostlist.h line 178
char * hostlist_shift(struct hostlist *hl);
// hostlist_shift_iterators
// file hostlist.c line 1685
static void hostlist_shift_iterators(struct hostlist *hl, signed int idx, signed int depth, signed int n);
// hostlist_shift_range
// file hostlist.c line 1761
char * hostlist_shift_range(struct hostlist *hl);
// hostlist_sort
// file hostlist.c line 1951
void hostlist_sort(struct hostlist *hl);
// hostlist_uniq
// file hostlist.c line 2068
void hostlist_uniq(struct hostlist *hl);
// hostname_create
// file hostlist.c line 519
static struct hostname_components * hostname_create(const char *hostname);
// hostname_create_with_suffix
// file hostlist.c line 466
static struct hostname_components * hostname_create_with_suffix(const char *hostname, signed int idx);
// hostname_destroy
// file hostlist.c line 527
static void hostname_destroy(struct hostname_components *hn);
// hostname_suffix_is_valid
// file hostlist.c line 541
static signed int hostname_suffix_is_valid(struct hostname_components *hn);
// hostname_suffix_width
// file hostlist.c line 548
static signed int hostname_suffix_width(struct hostname_components *hn);
// hostrange_cmp
// file hostlist.c line 696
static signed int hostrange_cmp(struct hostrange_components *h1, struct hostrange_components *h2);
// hostrange_copy
// file hostlist.c line 639
static struct hostrange_components * hostrange_copy(struct hostrange_components *hr);
// hostrange_count
// file hostlist.c line 628
static unsigned long int hostrange_count(struct hostrange_components *hr);
// hostrange_create
// file hostlist.c line 599
static struct hostrange_components * hostrange_create(char *prefix, unsigned long int lo, unsigned long int hi, signed int width);
// hostrange_create_single
// file hostlist.c line 570
static struct hostrange_components * hostrange_create_single(const char *prefix);
// hostrange_delete_host
// file hostlist.c line 668
static struct hostrange_components * hostrange_delete_host(struct hostrange_components *hr, unsigned long int n);
// hostrange_destroy
// file hostlist.c line 653
static void hostrange_destroy(struct hostrange_components *hr);
// hostrange_empty
// file hostlist.c line 765
static signed int hostrange_empty(struct hostrange_components *hr);
// hostrange_hn_within
// file hostlist.c line 896
static signed int hostrange_hn_within(struct hostrange_components *hr, struct hostname_components *hn);
// hostrange_intersect
// file hostlist.c line 868
static struct hostrange_components * hostrange_intersect(struct hostrange_components *h1, struct hostrange_components *h2);
// hostrange_join
// file hostlist.c line 834
static signed int hostrange_join(struct hostrange_components *h1, struct hostrange_components *h2);
// hostrange_new
// file hostlist.c line 559
static struct hostrange_components * hostrange_new(void);
// hostrange_numstr
// file hostlist.c line 1031
static unsigned long int hostrange_numstr(struct hostrange_components *hr, unsigned long int n, char *buf);
// hostrange_pop
// file hostlist.c line 776
static char * hostrange_pop(struct hostrange_components *hr);
// hostrange_prefix_cmp
// file hostlist.c line 719
static signed int hostrange_prefix_cmp(struct hostrange_components *h1, struct hostrange_components *h2);
// hostrange_shift
// file hostlist.c line 798
static char * hostrange_shift(struct hostrange_components *hr);
// hostrange_to_string
// file hostlist.c line 992
static unsigned long int hostrange_to_string(struct hostrange_components *hr, unsigned long int n, char *buf, char *separator);
// hostrange_width_combine
// file hostlist.c line 754
static signed int hostrange_width_combine(struct hostrange_components *h0, struct hostrange_components *h1);
// hostrange_within_range
// file hostlist.c line 740
static signed int hostrange_within_range(struct hostrange_components *h1, struct hostrange_components *h2);
// hostset_copy
// file hostlist.c line 2407
struct hostset * hostset_copy(struct hostset * const set);
// hostset_count
// file hostlist.c line 2579
signed int hostset_count(struct hostset *set);
// hostset_create
// file hostlist.c line 2388
struct hostset * hostset_create(const char *hostlist);
// hostset_delete
// file hostlist.c line 2549
signed int hostset_delete(struct hostset *set, const char *hosts);
// hostset_delete_host
// file hostlist.c line 2554
signed int hostset_delete_host(struct hostset *set, const char *hostname);
// hostset_deranged_string
// file hostlist.c line 2589
signed long int hostset_deranged_string(struct hostset *set, unsigned long int n, char *buf);
// hostset_destroy
// file hostlist.c line 2423
void hostset_destroy(struct hostset *set);
// hostset_find_host
// file hostlist.c line 2506
static signed int hostset_find_host(struct hostset *set, const char *host);
// hostset_insert
// file hostlist.c line 2487
signed int hostset_insert(struct hostset *set, const char *hosts);
// hostset_insert_range
// file hostlist.c line 2435
static signed int hostset_insert_range(struct hostset *set, struct hostrange_components *hr);
// hostset_iterator_create
// file hostlist.c line 2238
struct hostlist_iterator * hostset_iterator_create(struct hostset *set);
// hostset_pop
// file hostlist.c line 2564
char * hostset_pop(struct hostset *set);
// hostset_pop_range
// file hostlist.c line 2574
char * hostset_pop_range(struct hostset *set);
// hostset_ranged_string
// file hostlist.c line 2584
signed long int hostset_ranged_string(struct hostset *set, unsigned long int n, char *buf);
// hostset_shift
// file hostlist.c line 2559
char * hostset_shift(struct hostset *set);
// hostset_shift_range
// file hostlist.c line 2569
char * hostset_shift_range(struct hostset *set);
// hostset_within
// file hostlist.c line 2525
signed int hostset_within(struct hostset *set, const char *hosts);
// include_file
// file wcoll.c line 137
static char * include_file(char *line);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// list_alloc
// file list.c line 728
static struct list * list_alloc(void);
// list_alloc_aux
// file list.c line 773
static void * list_alloc_aux(signed int size, void *pfreelist);
// list_append
// file ../../src/common/list.h line 131
void * list_append(struct list *l, void *x);
// list_count
// file ../../src/common/list.h line 121
signed int list_count(struct list *l);
// list_create
// file ../../src/common/list.h line 99
struct list * list_create(void (*f)(void *));

//

// list_delete
// file ../../src/common/list.h line 273
signed int list_delete(struct listIterator *i);
// list_delete_all
// file list.c line 350
signed int list_delete_all(struct list *l, signed int (*f)(void *, void *), void *key);

//

// list_dequeue
// file list.c line 505
void * list_dequeue(struct list *l);
// list_destroy
// file ../../src/common/list.h line 109
void list_destroy(struct list *l);
// list_enqueue
// file list.c line 490
void * list_enqueue(struct list *l, void *x);
// list_find
// file ../../src/common/list.h line 257
void * list_find(struct listIterator *i, signed int (*f)(void *, void *), void *key);

//

// list_find_first
// file ../../src/common/list.h line 143
void * list_find_first(struct list *l, signed int (*f)(void *, void *), void *key);

//

// list_for_each
// file ../../src/common/list.h line 162
signed int list_for_each(struct list *l, signed int (*f)(void *, void *), void *arg);

//

// list_free
// file list.c line 735
static void list_free(struct list *l);
// list_free_aux
// file list.c line 807
static void list_free_aux(void *x, void *pfreelist);
// list_insert
// file list.c line 595
void * list_insert(struct listIterator *i, void *x);
// list_is_empty
// file ../../src/common/list.h line 116
signed int list_is_empty(struct list *l);
// list_iterator_alloc
// file list.c line 758
static struct listIterator * list_iterator_alloc(void);
// list_iterator_create
// file ../../src/common/list.h line 223
struct listIterator * list_iterator_create(struct list *l);
// list_iterator_destroy
// file ../../src/common/list.h line 235
void list_iterator_destroy(struct listIterator *i);
// list_iterator_free
// file list.c line 765
static void list_iterator_free(struct listIterator *i);
// list_iterator_reset
// file list.c line 540
void list_iterator_reset(struct listIterator *i);
// list_join
// file ../../src/common/split.h line 33
signed int list_join(char *result, unsigned long int len, const char *sep, struct list *l);
// list_next
// file ../../src/common/list.h line 242
void * list_next(struct listIterator *i);
// list_node_alloc
// file list.c line 743
static struct listNode * list_node_alloc(void);
// list_node_create
// file list.c line 657
static void * list_node_create(struct list *l, struct listNode **pp, void *x);
// list_node_destroy
// file list.c line 692
static void * list_node_destroy(struct list *l, struct listNode **pp);
// list_node_free
// file list.c line 750
static void list_node_free(struct listNode *p);
// list_peek
// file list.c line 476
void * list_peek(struct list *l);
// list_pop
// file list.c line 462
void * list_pop(struct list *l);
// list_prepend
// file ../../src/common/list.h line 137
void * list_prepend(struct list *l, void *x);
// list_push
// file ../../src/common/list.h line 182
void * list_push(struct list *l, void *x);
// list_push_hostlist
// file opt.c line 1275
static void list_push_hostlist(struct list *l, struct hostlist *hl);
// list_remove
// file list.c line 625
void * list_remove(struct listIterator *i);
// list_sort
// file ../../src/common/list.h line 170
void list_sort(struct list *l, signed int (*f)(void *, void *));

//

// list_split
// file ../../src/common/split.h line 31
struct list * list_split(char *sep, char *str);
// list_split_append
// file split.c line 104
struct list * list_split_append(struct list *l, char *sep, char *str);
// login_name_max_len
// file opt.c line 302
static signed int login_name_max_len(void);
// lsd_fatal_error
// file err.c line 193
void lsd_fatal_error(char *file, signed int line, char *mesg);
// lsd_nomem_error
// file err.c line 198
void lsd_nomem_error(char *file, signed int line, char *mesg);
// lt_dlclose
// file ltdl.h line 176
extern signed int lt_dlclose(struct lt_dlhandle_struct *);
// lt_dlexit
// file ltdl.h line 157
extern signed int lt_dlexit(void);
// lt_dlgetinfo
// file ltdl.h line 249
extern const struct anonymous_25 * lt_dlgetinfo(struct lt_dlhandle_struct *);
// lt_dlinit
// file ltdl.h line 156
extern signed int lt_dlinit(void);
// lt_dlopen
// file ltdl.h line 171
extern struct lt_dlhandle_struct * lt_dlopen(const char *);
// lt_dlsym
// file ltdl.h line 173
extern void * lt_dlsym(struct lt_dlhandle_struct *, const char *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mod_count
// file mod.c line 467
signed int mod_count(char *type);
// mod_create
// file mod.c line 262
struct module_components * mod_create(void);
// mod_exit
// file mod.h line 53
signed int mod_exit(void);
// mod_get_module
// file mod.c line 557
struct module_components * mod_get_module(const char *type, const char *name);
// mod_get_module_names
// file mod.c line 522
struct list * mod_get_module_names(char *type);
// mod_get_name
// file mod.c line 581
char * mod_get_name(struct module_components *mod);
// mod_get_rcmd
// file mod.c line 623
signed int (*mod_get_rcmd(struct module_components *mod))(char *, char *, char *, char *, char *, signed int, signed int *, void **);
// mod_get_rcmd_destroy
// file mod.c line 635
signed int (*mod_get_rcmd_destroy(struct module_components *mod))(void *);
// mod_get_rcmd_init
// file mod.c line 599
signed int (*mod_get_rcmd_init(struct module_components *mod))(struct anonymous_1 *);
// mod_get_rcmd_signal
// file mod.c line 611
signed int (*mod_get_rcmd_signal(struct module_components *mod))(signed int, void *, signed int);
// mod_get_type
// file mod.c line 590
char * mod_get_type(struct module_components *mod);
// mod_get_uninitialized_module_names
// file mod.c line 527
struct list * mod_get_uninitialized_module_names(char *type);
// mod_init
// file mod.h line 43
signed int mod_init(void);
// mod_list_module_info
// file mod.c line 534
void mod_list_module_info(void);
// mod_load_modules
// file mod.h line 68
signed int mod_load_modules(const char *dir, struct anonymous_1 *opt);
// mod_postop
// file mod.c line 238
signed int mod_postop(struct anonymous_1 *pdsh_opts);
// mod_print_all_options
// file mod.c line 454
void mod_print_all_options(signed int col);
// mod_print_options
// file mod.c line 404
void mod_print_options(struct module_components *mod, signed int col);
// mod_process_opt
// file mod.c line 648
signed int mod_process_opt(struct anonymous_1 *opt, signed int c, char *optarg);
// mod_read_wcoll
// file mod.c line 206
signed int mod_read_wcoll(struct anonymous_1 *opt);
// node_rcmd_info_create
// file rcmd.c line 77
static struct node_rcmd_info * node_rcmd_info_create(char *hostname, char *user, struct rcmd_module *module);
// node_rcmd_info_destroy
// file rcmd.c line 91
static void node_rcmd_info_destroy(struct node_rcmd_info *n);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// opt_args
// file ../../src/pdsh/opt.h line 101
void opt_args(struct anonymous_1 *opt, signed int argc, char **argv);
// opt_args_early
// file ../../src/pdsh/opt.h line 100
void opt_args_early(struct anonymous_1 *opt, signed int argc, char **argv);
// opt_default
// file ../../src/pdsh/opt.h line 98
void opt_default(struct anonymous_1 *opt, char *argv0);
// opt_env
// file ../../src/pdsh/opt.h line 99
void opt_env(struct anonymous_1 *opt);
// opt_free
// file ../../src/pdsh/opt.h line 104
void opt_free(struct anonymous_1 *opt);
// opt_list
// file ../../src/pdsh/opt.h line 103
void opt_list(struct anonymous_1 *opt);
// opt_register
// file ../../src/pdsh/opt.h line 150
enum anonymous opt_register(struct pdsh_module_option *opt_table);
// opt_verify
// file ../../src/pdsh/opt.h line 102
enum anonymous opt_verify(struct anonymous_1 *opt);
// out
// file ../../src/common/err.h line 36
void out(char *format, ...);
// p_rresvport_af
// file privsep.c line 208
static signed int p_rresvport_af(signed int *port, signed int family);
// pcp_client
// file pcp_client.h line 65
signed int pcp_client(struct pcp_client *pcp);
// pcp_expand_dirs
// file pcp_client.h line 54
struct list * pcp_expand_dirs(struct list *infiles);
// pcp_response
// file pcp_client.c line 261
static signed int pcp_response(signed int infd, char *host);
// pcp_sendfile
// file pcp_client.c line 288
signed int pcp_sendfile(struct pcp_client *pcp, char *file, char *output_file);
// pcp_sendstr
// file pcp_client.c line 242
static signed int pcp_sendstr(signed int outfd, char *str, char *host);
// pcp_server
// file pcp_server.h line 44
signed int pcp_server(struct pcp_server *svr);
// pdsh_personality
// file ../../src/pdsh/opt.h line 109
enum anonymous_5 pdsh_personality(void);
// pdsh_remote_argc
// file opt.c line 155
signed int pdsh_remote_argc(void);
// pdsh_remote_argv
// file opt.c line 150
const char ** pdsh_remote_argv(void);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pipe_info_create
// file pipecmd.c line 62
struct pipe_info_struct * pipe_info_create(const char *path, const char *target, const char *user, signed int rank);
// pipe_info_destroy
// file pipecmd.c line 81
static void pipe_info_destroy(struct pipe_info_struct *e);
// pipecmd
// file ../../src/common/pipecmd.h line 40
struct pipe_info_struct * pipecmd(const char *path, const char **args, const char *target, const char *user, signed int rank);
// pipecmd_destroy
// file ../../src/common/pipecmd.h line 46
void pipecmd_destroy(struct pipe_info_struct *p);
// pipecmd_format_arg
// file pipecmd.c line 93
static char * pipecmd_format_arg(struct pipe_info_struct *e, const char *arg);
// pipecmd_signal
// file pipecmd.c line 205
signed int pipecmd_signal(struct pipe_info_struct *p, signed int signo);
// pipecmd_stderrfd
// file pipecmd.c line 198
signed int pipecmd_stderrfd(struct pipe_info_struct *p);
// pipecmd_stdoutfd
// file ../../src/common/pipecmd.h line 51
signed int pipecmd_stdoutfd(struct pipe_info_struct *p);
// pipecmd_target
// file pipecmd.c line 240
const char * pipecmd_target(struct pipe_info_struct *p);
// pipecmd_wait
// file ../../src/common/pipecmd.h line 64
signed int pipecmd_wait(struct pipe_info_struct *p, signed int *pstatus);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// privsep_fini
// file privsep.h line 38
signed int privsep_fini(void);
// privsep_get_family
// file privsep.c line 66
static signed int privsep_get_family(signed int *lport);
// privsep_init
// file privsep.h line 33
signed int privsep_init(void);
// privsep_rresvport
// file privsep.c line 335
signed int privsep_rresvport(signed int *lport);
// privsep_rresvport_af
// file privsep.c line 305
signed int privsep_rresvport_af(signed int *lport, signed int family);
// privsep_server
// file privsep.c line 222
static signed int privsep_server(void);
// privsep_set_family
// file privsep.c line 77
static signed int privsep_set_family(signed int *lport, signed int family);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setscope
// file /usr/include/pthread.h line 353
extern signed int pthread_attr_setscope(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_15 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_15 *, union anonymous_2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_2 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_11 *, struct anonymous_11 *);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// rcmd_connect
// file ../../src/pdsh/rcmd.h line 80
signed int rcmd_connect(struct rcmd_info *rcmd, char *ahost, char *addr, char *locuser, char *remuser, char *cmd, signed int nodeid, enum anonymous error_fd);
// rcmd_create
// file ../../src/pdsh/rcmd.h line 75
struct rcmd_info * rcmd_create(char *host);
// rcmd_destroy
// file ../../src/pdsh/rcmd.h line 87
signed int rcmd_destroy(struct rcmd_info *rcmd);
// rcmd_exit
// file rcmd.c line 401
signed int rcmd_exit(void);
// rcmd_get_default_module
// file rcmd.c line 238
char * rcmd_get_default_module(void);
// rcmd_info_create
// file rcmd.c line 284
struct rcmd_info * rcmd_info_create(struct rcmd_module *rmod);
// rcmd_info_destroy
// file rcmd.c line 301
void rcmd_info_destroy(struct rcmd_info *r);
// rcmd_init
// file ../../src/pdsh/rcmd.h line 94
signed int rcmd_init(struct anonymous_1 *opt);
// rcmd_module_create
// file rcmd.c line 102
struct rcmd_module * rcmd_module_create(struct module_components *mod);
// rcmd_module_create::_tmp::return_value_mod_get_rcmd_7_object
//
signed int return_value_mod_get_rcmd_7_object(char *, char *, char *, char *, char *, signed int, signed int *, void **);
// rcmd_module_create::_tmp::return_value_mod_get_rcmd_destroy_8_object
//
signed int return_value_mod_get_rcmd_destroy_8_object(void *);
// rcmd_module_create::_tmp::return_value_mod_get_rcmd_init_3_object
//
signed int return_value_mod_get_rcmd_init_3_object(struct anonymous_1 *);
// rcmd_module_create::_tmp::return_value_mod_get_rcmd_signal_5_object
//
signed int return_value_mod_get_rcmd_signal_5_object(signed int, void *, signed int);
// rcmd_module_destroy
// file rcmd.c line 141
static void rcmd_module_destroy(struct rcmd_module *rmod);
// rcmd_module_register
// file rcmd.c line 164
static struct rcmd_module * rcmd_module_register(char *name);
// rcmd_opt_set
// file rcmd.c line 411
signed int rcmd_opt_set(signed int id, void *value);
// rcmd_register_default_rcmd
// file rcmd.c line 253
signed int rcmd_register_default_rcmd(char *rcmd_name);
// rcmd_register_defaults
// file rcmd.c line 262
signed int rcmd_register_defaults(char *hosts, char *rcmd_name, char *user);
// rcmd_signal
// file ../../src/pdsh/rcmd.h line 92
signed int rcmd_signal(struct rcmd_info *rcmd, signed int signum);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_wcoll
// file wcoll.h line 43
struct hostlist * read_wcoll(char *file, struct _IO_FILE *f);
// read_wcoll_path
// file wcoll.c line 279
struct hostlist * read_wcoll_path(const char *path, const char *file);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv_rresvport
// file privsep.c line 165
static signed int recv_rresvport(signed int pipefd, signed int *lptr);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regex_info_create
// file opt.c line 1233
struct regex_info * regex_info_create(const char *r, signed int exclude);
// regex_info_destroy
// file opt.c line 1224
void regex_info_destroy(struct regex_info *re);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_0 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rresvport_af
// file /usr/include/netdb.h line 560
extern signed int rresvport_af(signed int *, unsigned short int);
// send_rresvport
// file privsep.c line 116
static signed int send_rresvport(signed int pipefd, signed int fd, signed int lport);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// setegid
// file /usr/include/unistd.h line 727
extern signed int setegid(unsigned int);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(signed int, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_11 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_11 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous_11 *, signed int *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcmp_f
// file wcoll.c line 63
static signed int strcmp_f(char *a, char *b);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 426
extern signed int strerror_r(signed int, char *, unsigned long int);
// string_to_int
// file opt.c line 425
static signed int string_to_int(const char *val, signed int *p2int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// testcase
// file dsh.h line 97
void testcase(signed int testnum);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// utimes
// file /usr/include/x86_64-linux-gnu/sys/time.h line 138
extern signed int utimes(const char *, struct timeval *);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wcoll_append_excluded
// file opt.c line 519
static void wcoll_append_excluded(struct anonymous_1 *opt, char *exclude_args);
// wcoll_apply_excluded
// file opt.c line 1394
static void wcoll_apply_excluded(struct anonymous_1 *opt, struct list *excludes);
// wcoll_apply_regex
// file opt.c line 1377
static void wcoll_apply_regex(struct anonymous_1 *opt, struct list *regexs);
// wcoll_arg_process
// file opt.c line 1295
static signed int wcoll_arg_process(char *arg, struct anonymous_1 *opt);
// wcoll_args_process
// file opt.c line 1368
static signed int wcoll_args_process(struct anonymous_1 *opt, char *args);
// wcoll_ctx_create
// file wcoll.c line 68
static struct wcoll_ctx * wcoll_ctx_create(const char *path);
// wcoll_ctx_destroy
// file wcoll.c line 84
static void wcoll_ctx_destroy(struct wcoll_ctx *ctx);
// wcoll_ctx_file_is_cached
// file wcoll.c line 97
static signed int wcoll_ctx_file_is_cached(struct wcoll_ctx *ctx, char *file);
// wcoll_ctx_path_lookup
// file wcoll.c line 110
static signed int wcoll_ctx_path_lookup(struct wcoll_ctx *ctx, const char *name, char *buf, signed int len);
// wcoll_ctx_read_file
// file wcoll.c line 250
static signed int wcoll_ctx_read_file(struct wcoll_ctx *ctx, const char *f);
// wcoll_ctx_read_line
// file wcoll.c line 204
static signed int wcoll_ctx_read_line(struct wcoll_ctx *ctx, char *line);
// wcoll_ctx_read_stream
// file wcoll.c line 226
static signed int wcoll_ctx_read_stream(struct wcoll_ctx *ctx, struct _IO_FILE *fp);
// wcoll_ctx_resolve_path
// file wcoll.c line 187
static char * wcoll_ctx_resolve_path(struct wcoll_ctx *ctx, const char *file, char *buf, signed int len);
// wcoll_expand
// file opt.c line 765
static void wcoll_expand(struct anonymous_1 *opt);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xbasename
// file ../../src/common/xstring.h line 39
char * xbasename(char *path);
// xpclose
// file xpopen.c line 169
signed int xpclose(struct _IO_FILE *f);
// xpoll
// file ../../src/common/xpoll.h line 66
signed int xpoll(struct xpollfd *xfds, signed int nfds, signed int timeout);
// xpopen
// file xpopen.c line 89
struct _IO_FILE * xpopen(char *cmd, char *mode);
// xstrcat
// file ../../src/common/xstring.h line 35
void xstrcat(char **str1, char *str2);
// xstrcatchar
// file ../../src/common/xstring.h line 37
void xstrcatchar(char **str, char c);
// xstrcln
// file ../../src/common/xstring.h line 32
void xstrcln(char *str, char *verboten);
// xstrcpy
// file xstring.c line 120
void xstrcpy(char **str1, char *str2);
// xstrerrorcat
// file ../../src/common/xstring.h line 38
void xstrerrorcat(char **buf);

struct anonymous_7
{
  // desc
  char *desc;
  // fun
  enum anonymous_6 (*fun)(void);
};

struct anonymous_25
{
  // filename
  char *filename;
  // name
  char *name;
  // ref_count
  signed int ref_count;
};

struct anonymous_1
{
  // progname
  char *progname;
  // debug
  enum anonymous debug;
  // info_only
  enum anonymous info_only;
  // test_range_expansion
  enum anonymous test_range_expansion;
  // sdr_verify
  enum anonymous sdr_verify;
  // sdr_global
  enum anonymous sdr_global;
  // altnames
  enum anonymous altnames;
  // sigint_terminates
  enum anonymous sigint_terminates;
  // wcoll
  struct hostlist *wcoll;
  // luser
  char *luser;
  // luid
  unsigned int luid;
  // ruser
  char *ruser;
  // fanout
  signed int fanout;
  // connect_timeout
  signed int connect_timeout;
  // command_timeout
  signed int command_timeout;
  // rcmd_name
  char *rcmd_name;
  // misc_modules
  char *misc_modules;
  // resolve_hosts
  enum anonymous resolve_hosts;
  // kill_on_fail
  enum anonymous kill_on_fail;
  // separate_stderr
  enum anonymous separate_stderr;
  // stdin_unavailable
  enum anonymous stdin_unavailable;
  // cmd
  char *cmd;
  // dshpath
  char *dshpath;
  // getstat
  char *getstat;
  // ret_remote_rc
  enum anonymous ret_remote_rc;
  // labels
  enum anonymous labels;
  // preserve
  enum anonymous preserve;
  // recursive
  enum anonymous recursive;
  // infile_names
  struct list *infile_names;
  // outfile_name
  char *outfile_name;
  // pcp_server
  enum anonymous pcp_server;
  // target_is_directory
  enum anonymous target_is_directory;
  // pcp_client
  enum anonymous pcp_client;
  // pcp_client_host
  char *pcp_client_host;
  // local_program_path
  char *local_program_path;
  // remote_program_path
  char *remote_program_path;
  // reverse_copy
  enum anonymous reverse_copy;
};

struct anonymous_22
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_20
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_11
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_14
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_16
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_19
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_18
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_17
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_21
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_23
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_16 _kill;
  // _timer
  struct anonymous_17 _timer;
  // _rt
  struct anonymous_18 _rt;
  // _sigchld
  struct anonymous_19 _sigchld;
  // _sigfault
  struct anonymous_20 _sigfault;
  // _sigpoll
  struct anonymous_21 _sigpoll;
  // _sigsys
  struct anonymous_22 _sigsys;
};

struct anonymous_13
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_23 _sifields;
};

union anonymous_12
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_13 *, void *);
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_15
{
  // __data
  struct anonymous_14 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _buf
{
  // cnt
  signed int cnt;
  // buf
  char *buf;
};

struct _range
{
  // lo
  unsigned long int lo;
  // hi
  unsigned long int hi;
  // width
  signed int width;
};

struct cbuf
{
  // mutex
  union anonymous_2 mutex;
  // alloc
  signed int alloc;
  // minsize
  signed int minsize;
  // maxsize
  signed int maxsize;
  // size
  signed int size;
  // used
  signed int used;
  // overwrite
  enum anonymous_9 overwrite;
  // got_wrap
  signed int got_wrap;
  // i_in
  signed int i_in;
  // i_out
  signed int i_out;
  // i_rep
  signed int i_rep;
  // data
  unsigned char *data;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct hostlist
{
  // mutex
  union anonymous_2 mutex;
  // size
  signed int size;
  // nranges
  signed int nranges;
  // nhosts
  signed int nhosts;
  // hr
  struct hostrange_components **hr;
  // ilist
  struct hostlist_iterator *ilist;
};

struct hostlist_iterator
{
  // hl
  struct hostlist *hl;
  // idx
  signed int idx;
  // hr
  struct hostrange_components *hr;
  // depth
  signed int depth;
  // next
  struct hostlist_iterator *next;
};

struct hostname_components
{
  // hostname
  char *hostname;
  // prefix
  char *prefix;
  // num
  unsigned long int num;
  // suffix
  char *suffix;
};

struct hostrange_components
{
  // prefix
  char *prefix;
  // lo
  unsigned long int lo;
  // hi
  unsigned long int hi;
  // width
  signed int width;
  // singlehost
  unsigned int singlehost : 1;
};

struct hostset
{
  // hl
  struct hostlist *hl;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct list
{
  // head
  struct listNode *head;
  // tail
  struct listNode **tail;
  // iNext
  struct listIterator *iNext;
  // fDel
  void (*fDel)(void *);
  // count
  signed int count;
  // mutex
  union anonymous_2 mutex;
};

struct listIterator
{
  // list
  struct list *list;
  // pos
  struct listNode *pos;
  // prev
  struct listNode **prev;
  // iNext
  struct listIterator *iNext;
};

struct listNode
{
  // data
  void *data;
  // next
  struct listNode *next;
};

struct module_components
{
  // handle
  struct lt_dlhandle_struct *handle;
  // filename
  char *filename;
  // priority
  signed int priority;
  // initialized
  signed int initialized;
  // pmod
  struct pdsh_module *pmod;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct node_rcmd_info
{
  // hostname
  char *hostname;
  // username
  char *username;
  // rmod
  struct rcmd_module *rmod;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pcp_client
{
  // infd
  signed int infd;
  // outfd
  signed int outfd;
  // preserve
  enum anonymous preserve;
  // pcp_client
  enum anonymous pcp_client;
  // host
  char *host;
  // infiles
  struct list *infiles;
};

struct pcp_filename
{
  // filename
  char *filename;
  // file_specified_by_user
  signed int file_specified_by_user;
};

struct pcp_server
{
  // infd
  signed int infd;
  // outfd
  signed int outfd;
  // preserve
  enum anonymous preserve;
  // target_is_dir
  enum anonymous target_is_dir;
  // outfile
  char *outfile;
};

struct pdsh_module
{
  // type
  char *type;
  // name
  char *name;
  // author
  char *author;
  // descr
  char *descr;
  // personality
  signed int personality;
  // mod_ops
  struct pdsh_module_operations *mod_ops;
  // rcmd_ops
  struct pdsh_rcmd_operations *rcmd_ops;
  // opt_table
  struct pdsh_module_option *opt_table;
};

struct pdsh_module_operations
{
  // init
  signed int (*init)(void);
  // exit
  signed int (*exit)(void);
  // read_wcoll
  struct hostlist * (*read_wcoll)(struct anonymous_1 *);
  // postop
  signed int (*postop)(struct anonymous_1 *);
};

struct pdsh_module_option
{
  // opt
  char opt;
  // arginfo
  char *arginfo;
  // descr
  char *descr;
  // personality
  signed int personality;
  // f
  signed int (*f)(struct anonymous_1 *, signed int, char *);
};

struct pdsh_rcmd_operations
{
  // rcmd_init
  signed int (*rcmd_init)(struct anonymous_1 *);
  // rcmd_signal
  signed int (*rcmd_signal)(signed int, void *, signed int);
  // rcmd
  signed int (*rcmd)(char *, char *, char *, char *, char *, signed int, signed int *, void **);
  // rcmd_destroy
  signed int (*rcmd_destroy)(void *);
};

struct pid
{
  // next
  struct pid *next;
  // fp
  struct _IO_FILE *fp;
  // pid
  signed int pid;
};

struct pipe_info_struct
{
  // pid
  signed int pid;
  // path
  char *path;
  // cmd
  char *cmd;
  // target
  char *target;
  // username
  char *username;
  // args
  char **args;
  // rank
  signed int rank;
  // fd
  signed int fd;
  // efd
  signed int efd;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rcmd_info
{
  // fd
  signed int fd;
  // efd
  signed int efd;
  // rmod
  struct rcmd_module *rmod;
  // opts
  struct rcmd_options *opts;
  // ruser
  char *ruser;
  // arg
  void *arg;
};

struct rcmd_options
{
  // resolve_hosts
  enum anonymous resolve_hosts;
};

struct rcmd_module
{
  // name
  char *name;
  // mod
  struct module_components *mod;
  // options
  struct rcmd_options options;
  // init
  signed int (*init)(struct anonymous_1 *);
  // signal
  signed int (*signal)(signed int, void *, signed int);
  // rcmd
  signed int (*rcmd)(char *, char *, char *, char *, char *, signed int, signed int *, void **);
  // rcmd_destroy
  signed int (*rcmd_destroy)(void *);
};

struct re_pattern_buffer
{
  // __buffer
  unsigned char *__buffer;
  // __allocated
  unsigned long int __allocated;
  // __used
  unsigned long int __used;
  // __syntax
  unsigned long int __syntax;
  // __fastmap
  char *__fastmap;
  // __translate
  unsigned char *__translate;
  // re_nsub
  unsigned long int re_nsub;
  // __can_be_null
  unsigned int __can_be_null : 1;
  // __regs_allocated
  unsigned int __regs_allocated : 2;
  // __fastmap_accurate
  unsigned int __fastmap_accurate : 1;
  // __no_sub
  unsigned int __no_sub : 1;
  // __not_bol
  unsigned int __not_bol : 1;
  // __not_eol
  unsigned int __not_eol : 1;
  // __newline_anchor
  unsigned int __newline_anchor : 1;
};

struct regex_info
{
  // exclude
  signed int exclude;
  // cflags
  signed int cflags;
  // eflags
  signed int eflags;
  // compiled
  signed int compiled;
  // pattern
  char *pattern;
  // reg
  struct re_pattern_buffer reg;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_12 __sigaction_handler;
  // sa_mask
  struct anonymous_11 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct thd
{
  // thread
  unsigned long int thread;
  // attr
  union pthread_attr_t attr;
  // state
  enum anonymous_8 state;
  // host
  char *host;
  // luser
  char *luser;
  // ruser
  char *ruser;
  // resolve_hosts
  enum anonymous resolve_hosts;
  // start
  signed long int start;
  // connect
  signed long int connect;
  // finish
  signed long int finish;
  // cmd
  char *cmd;
  // dsh_sopt
  enum anonymous dsh_sopt;
  // kill_on_fail
  enum anonymous kill_on_fail;
  // pcp_infiles
  struct list *pcp_infiles;
  // pcp_outfile
  char *pcp_outfile;
  // pcp_popt
  enum anonymous pcp_popt;
  // pcp_ropt
  enum anonymous pcp_ropt;
  // pcp_yopt
  enum anonymous pcp_yopt;
  // pcp_Popt
  enum anonymous pcp_Popt;
  // pcp_Zopt
  enum anonymous pcp_Zopt;
  // pcp_progname
  char *pcp_progname;
  // outfile_name
  char *outfile_name;
  // rc
  signed int rc;
  // nodeid
  signed int nodeid;
  // nnodes
  signed int nnodes;
  // rcmd
  struct rcmd_info *rcmd;
  // outbuf
  struct cbuf *outbuf;
  // errbuf
  struct cbuf *errbuf;
  // labels
  enum anonymous labels;
  // addr
  char addr[4l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct wcoll_ctx
{
  // hl
  struct hostlist *hl;
  // path_list
  struct list *path_list;
  // include_cache
  struct list *include_cache;
};

struct xpollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};


// client_fd
// file privsep.c line 53
static signed int client_fd = -1;
// command_timeout
// file dsh.c line 144
static signed int command_timeout;
// connect_timeout
// file dsh.c line 144
static signed int connect_timeout;
// copyright
// file pcp_server.c line 58
char copyright[97l] = { '@', '(', '#', ')', ' ', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'c', ')', ' ', '1', '9', '8', '3', ',', ' ', '1', '9', '9', '0', ' ', 'T', 'h', 'e', ' ', 'R', 'e', 'g', 'e', 'n', 't', 's', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'U', 'n', 'i', 'v', 'e', 'r', 's', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'C', 'a', 'l', 'i', 'f', 'o', 'r', 'n', 'i', 'a', '.', '\n', 'A', 'l', 'l', ' ', 'r', 'i', 'g', 'h', 't', 's', ' ', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', '.', '\n', 0 };
// cpid
// file privsep.c line 52
static signed int cpid;
// current_rcmd_module
// file rcmd.c line 74
static struct rcmd_module *current_rcmd_module = (struct rcmd_module *)(void *)0;
// debug
// file dsh.c line 120
static signed int debug = 0;
// default_rcmd_module
// file rcmd.c line 73
static struct rcmd_module *default_rcmd_module = (struct rcmd_module *)(void *)0;
// exclude_list
// file opt.c line 163
static struct list *exclude_list = (struct list *)(void *)0;
// host
// file err.c line 50
static char *host = (char *)(void *)0;
// host_info_list
// file rcmd.c line 70
static struct list *host_info_list = (struct list *)(void *)0;
// initialized
// file mod.c line 120
static enum anonymous initialized = (enum anonymous)false;
// keep_host_domain
// file err.c line 55
static enum anonymous keep_host_domain = (enum anonymous)false;
// list_free_iterators
// file list.c line 146
static struct listIterator *list_free_iterators = (struct listIterator *)(void *)0;
// list_free_lists
// file list.c line 144
static struct list *list_free_lists = (struct list *)(void *)0;
// list_free_lock
// file list.c line 149
static union anonymous_2 list_free_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// list_free_nodes
// file list.c line 145
static struct listNode *list_free_nodes = (struct listNode *)(void *)0;
// module_list
// file mod.c line 119
static struct list *module_list;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pdsh_module_dir
// file testconfig.c line 2
const char *pdsh_module_dir = "/srv/jenkins-slave/workspace/sid-goto-cc-pdsh/pdsh-2.31/src/modules";
// pdsh_options
// file opt.c line 129
static char *pdsh_options = (char *)(void *)0;
// pdsh_version
// file testconfig.c line 1
char *pdsh_version = "pdsh-2.31";
// personality
// file opt.c line 134
static enum anonymous_5 personality = (enum anonymous_5)DSH;
// pidlist
// file xpopen.c line 65
static struct pid *pidlist;
// priv_gid
// file privsep.c line 59
unsigned int priv_gid = (unsigned int)-1;
// priv_uid
// file privsep.c line 58
unsigned int priv_uid = (unsigned int)-1;
// privsep_mutex
// file privsep.c line 51
static union anonymous_2 privsep_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// prog
// file err.c line 49
static char *prog = (char *)(void *)0;
// rcmd_module_list
// file rcmd.c line 71
static struct list *rcmd_module_list = (struct list *)(void *)0;
// rcmd_rank
// file rcmd.c line 47
static char *rcmd_rank[9l] = { "mrsh", "rsh", "ssh", "krb4", "qsh", "mqsh", "exec", "xcpu", (char *)(void *)0 };
// rcsid
// file pcp_server.c line 65
char rcsid[5l] = { '_', 'I', 'd', '_', 0 };
// regex_list
// file opt.c line 164
static struct list *regex_list = (struct list *)(void *)0;
// remote_argc
// file opt.c line 148
static signed int remote_argc;
// remote_argv
// file opt.c line 147
static char **remote_argv;
// server_fd
// file privsep.c line 54
static signed int server_fd = -1;
// sigint_terminates
// file dsh.c line 149
static signed int sigint_terminates = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// t
// file dsh.c line 138
static struct thd *t;
// testcases
// file testcase.c line 60
static struct anonymous_7 testcases[2l];
// testcases
// file testcase.c line 60
static struct anonymous_7 testcases[2l] = { { .desc="xstrerrorcat", .fun=_test_xstrerrorcat },
    { .desc="pipecmd", .fun=_test_pipecmd } };
// thd_mutex
// file dsh.c line 139
static union anonymous_2 thd_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// threadcount
// file dsh.c line 130
static signed int threadcount = 0;
// threadcount_cond
// file dsh.c line 129
static union anonymous_15 threadcount_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// threadcount_mutex
// file dsh.c line 128
static union anonymous_2 threadcount_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// user_gid
// file privsep.c line 57
unsigned int user_gid = (unsigned int)-1;
// user_uid
// file privsep.c line 56
unsigned int user_uid = (unsigned int)-1;

// Free
// file ../../src/common/xmalloc.h line 34
void Free(void **item)
{
  signed int *p = (signed int *)*item - (signed long int)2;
  if(!(*item == NULL))
  {
    p[(signed long int)0] = 0;
    free((void *)p);
    *item = (void *)0;
  }

}

// Malloc
// file ../../src/common/xmalloc.h line 32
void * Malloc(unsigned long int size)
{
  void *new;
  signed int *p;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size + (unsigned long int)2 * sizeof(signed int) /*4ul*/ );
  p = (signed int *)return_value_malloc_1;
  if(p == ((signed int *)NULL))
  {
    fprintf(stderr, "Malloc(%ld) failed\n", (signed long int)size);
    exit(1);
  }

  p[(signed long int)0] = 0x42;
  p[(signed long int)1] = (signed int)size;
  new = (void *)&p[(signed long int)2];
  memset(new, 0, size);
  return new;
}

// Realloc
// file ../../src/common/xmalloc.h line 33
void Realloc(void **item, unsigned long int newsize)
{
  signed int *p = (signed int *)*item - (signed long int)2;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)p, newsize + (unsigned long int)2 * sizeof(signed int) /*4ul*/ );
  p = (signed int *)return_value_realloc_1;
  if(p == ((signed int *)NULL))
  {
    fprintf(stderr, "Realloc(%ld) failed\n", (signed long int)newsize);
    exit(1);
  }

  p[(signed long int)1] = (signed int)newsize;
  *item = (void *)&p[(signed long int)2];
}

// Size
// file xmalloc.c line 123
signed int Size(void *item)
{
  signed int *p = (signed int *)item - (signed long int)2;
  return p[(signed long int)1];
}

// Strdup
// file ../../src/common/xmalloc.h line 36
char * Strdup(const char *str)
{
  char *result;
  unsigned long int return_value_strlen_1;
  void *return_value_Malloc_2;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    return_value_strlen_1=strlen(str);
    return_value_Malloc_2=Malloc(return_value_strlen_1 + (unsigned long int)1);
    result = (char *)return_value_Malloc_2;
  }
  char *return_value_strcpy_3;
  return_value_strcpy_3=strcpy(result, str);
  return return_value_strcpy_3;
}

// _alarm_handler
// file dsh.c line 184
static void _alarm_handler(signed int dummy)
{
  ;
}

// _allocbuf
// file pcp_server.c line 164
static struct _buf * _allocbuf(struct pcp_server *s, struct _buf *bp, signed int fd, signed int blksize)
{
  struct stat stb;
  signed int size;
  signed int return_value_fstat_1;
  return_value_fstat_1=fstat(fd, &stb);
  if(!(return_value_fstat_1 >= 0))
  {
    _error(s, "fstat: %m\n");
    return (struct _buf *)(void *)0;
  }

  else
  {
    size = (signed int)(0 != 0 && (blksize - 1 & blksize) == 0 ? (stb.st_blksize + (signed long int)blksize) - (signed long int)1 & (signed long int)~(blksize - 1) : ((stb.st_blksize + (signed long int)(blksize - 1)) / (signed long int)blksize) * (signed long int)blksize);
    if(size == 0)
      size = blksize;

    if(!(bp->cnt >= size))
    {
      if(!(bp->buf == ((char *)NULL)))
        free((void *)bp->buf);

      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)size);
      bp->buf = (char *)return_value_malloc_2;
      if(bp->buf == ((char *)NULL))
      {
        _error(s, "malloc: out of memory\n");
        bp->cnt = 0;
        return (struct _buf *)(void *)0;
      }

    }

    bp->cnt = size;
    return bp;
  }
}

// _attempt_range_join
// file hostlist.c line 2053
static signed int _attempt_range_join(struct hostlist *hl, signed int loc)
{
  signed int ndup;
  ndup=hostrange_join(hl->hr[(signed long int)(loc - 1)], hl->hr[(signed long int)loc]);
  if(ndup >= 0)
  {
    hostlist_delete_range(hl, loc);
    hl->nhosts = hl->nhosts - ndup;
  }

  return ndup;
}

// _cancel_pending_threads
// file dsh.c line 889
static signed int _cancel_pending_threads(void)
{
  signed int n = 0;
  signed int i;
  _Bool tmp_if_expr_2;
  if(t == ((struct thd *)NULL))
    return 0;

  else
  {
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1=pthread_mutex_lock(&threadcount_mutex);
      if(!(*return_value___errno_location_1 == 0))
        errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 897);

    }
    while((_Bool)0);
    i = 0;
    for( ; !((t + (signed long int)i)->host == ((char *)NULL)); i = i + 1)
    {
      if((signed int)(t + (signed long int)i)->state == DSH_NEW)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)(t + (signed long int)i)->state == DSH_RCMD ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        (t + (signed long int)i)->state = (enum anonymous_8)DSH_CANCELED;
        n = n + 1;
      }

    }
    err("%p: Canceled %d pending threads.\n", n);
    do
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3=pthread_mutex_unlock(&threadcount_mutex);
      if(!(*return_value___errno_location_3 == 0))
        errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 905);

    }
    while((_Bool)0);
    return 0;
  }
}

// _check_path
// file opt.c line 226
char * _check_path(char *dir, char *cwd, char *argv0)
{
  char *abspath = (char *)(void *)0;
  if(!((signed int)*dir == 47))
  {
    abspath=Strdup(cwd);
    xstrcat(&abspath, "/");
  }

  xstrcat(&abspath, dir);
  xstrcat(&abspath, "/");
  xstrcat(&abspath, argv0);
  signed int return_value_access_1;
  return_value_access_1=access(abspath, 4);
  if(return_value_access_1 == 0)
    return abspath;

  else
  {
    Free((void **)&abspath);
    return (char *)(void *)0;
  }
}

// _cmp
// file hostlist.c line 1943
signed int _cmp(const void *hr1, const void *hr2)
{
  struct hostrange_components **h1 = (struct hostrange_components **)hr1;
  struct hostrange_components **h2 = (struct hostrange_components **)hr2;
  signed int return_value_hostrange_cmp_1;
  return_value_hostrange_cmp_1=hostrange_cmp((struct hostrange_components *)*h1, (struct hostrange_components *)*h2);
  return return_value_hostrange_cmp_1;
}

// _cmp_f
// file mod.c line 320
static signed int _cmp_f(struct module_components *x, struct module_components *y)
{
  signed int return_value_strcmp_1;
  if(x->priority == y->priority)
  {
    return_value_strcmp_1=strcmp(x->pmod->name, y->pmod->name);
    return return_value_strcmp_1;
  }

  else
    return y->priority - x->priority;
}

// _cmp_filenames
// file mod.c line 945
static signed int _cmp_filenames(struct module_components *mod, char *filename)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(mod->filename, filename);
  return (signed int)(return_value_strcmp_1 == 0);
}

// _cmp_type
// file mod.c line 461
static signed int _cmp_type(struct module_components *mod, char *type)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(mod->pmod->type, type);
  return (signed int)(return_value_strcmp_1 == 0);
}

// _die_if_signalled
// file dsh.c line 593
static signed int _die_if_signalled(struct thd *t)
{
  signed int sig = t->rc - 128;
  if(!(sig >= 1))
    return 0;

  else
  {
    err("%p: process on host %S killed by signal %d\n", t->host, sig);
    _fwd_signal(15);
    errx("%p: terminating all processes.\n");
    return 0;
  }
}

// _dir_permission_error
// file mod.c line 987
static enum permission_error _dir_permission_error(struct stat *st, unsigned int alt_uid)
{
  unsigned int return_value_getuid_1;
  if(!((61440u & st->st_mode) == 16384u))
    return (enum permission_error)DIR_NOT_DIRECTORY;

  else
    if(!(st->st_uid == 0u))
    {
      return_value_getuid_1=getuid();
      if(st->st_uid == return_value_getuid_1)
        goto __CPROVER_DUMP_L2;

      if(st->st_uid == alt_uid)
        goto __CPROVER_DUMP_L2;

      return (enum permission_error)DIR_BAD_OWNER;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!((2u & st->st_mode) == 0u))
      {
        if(!((512u & st->st_mode) == 0u))
          goto __CPROVER_DUMP_L3;

        return (enum permission_error)DIR_WORLD_WRITABLE;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return (enum permission_error)DIR_OK;
      }
    }
}

// _do_output
// file dsh.c line 523
static signed int _do_output(signed int fd, struct cbuf *cb, void (*outf)(const char *, ...), enum anonymous read_rc, struct thd *t)
{
  char c;
  signed int n;
  signed int rc;
  signed int dropped = 0;
  rc=cbuf_write_from_fd(cb, fd, -1, &dropped);
  if(!(rc >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      return 1;

    err("%p: %S: read: %m\n", t->host);
    return -1;
  }

  do
  {
    n=cbuf_peek_line(cb, &c, 1, 1);
    if(n == 0)
      break;

    char *buf;
    if(!(n >= 0))
    {
      err("%p: %S: Failed to peek line: %m\n", t->host);
      break;
    }

    void *return_value_Malloc_2;
    return_value_Malloc_2=Malloc((unsigned long int)(n + 1));
    buf = (char *)return_value_Malloc_2;
    n=cbuf_read(cb, (void *)buf, n);
    if(!(n == 0))
    {
      if(!(n >= 0))
      {
        err("%p: %S: Failed to read line from buffer: %m\n", t->host);
        break;
      }

      if(!(read_rc == /*enum*/false))
        t->rc=_extract_rc(buf);

      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(buf);
      if(return_value_strlen_3 >= 1ul)
      {
        if(!(t->labels == /*enum*/false))
          outf("%S: %s", t->host, buf);

        else
          outf("%s", buf);
        fflush((struct _IO_FILE *)(void *)0);
      }

    }

    Free((void **)&buf);
  }
  while((_Bool)1);
  return rc;
}

// _dsh_attr_init
// file dsh.c line 806
static signed int _dsh_attr_init(union pthread_attr_t *attrp, signed int stacksize)
{
  signed int rc;
  signed long int return_value_sysconf_2;
  return_value_sysconf_2=sysconf(75);
  signed long int return_value_sysconf_1;
  if(!((unsigned long int)stacksize >= (unsigned long int)return_value_sysconf_2))
  {
    return_value_sysconf_1=sysconf(75);
    stacksize = (signed int)(unsigned long int)return_value_sysconf_1;
  }

  rc=pthread_attr_init(attrp);
  char *return_value_strerror_3;
  if(!(rc == 0))
  {
    return_value_strerror_3=strerror(rc);
    errx("pthread_attr_init: %s\n", return_value_strerror_3);
  }

  rc=pthread_attr_setdetachstate(attrp, 1);
  char *return_value_strerror_4;
  if(!(rc == 0))
  {
    return_value_strerror_4=strerror(rc);
    errx("pthread_attr_setdetachstate: %s\n", return_value_strerror_4);
  }

  rc=pthread_attr_setstacksize(attrp, (unsigned long int)stacksize);
  char *return_value_strerror_5;
  if(!(rc == 0))
  {
    return_value_strerror_5=strerror(rc);
    errx("pthread_attr_setstacksize: %s\n", return_value_strerror_5);
  }

  return 0;
}

// _dump_debug_stats
// file dsh.c line 760
static void _dump_debug_stats(signed int rshcount)
{
  signed long int conTot = (signed long int)0;
  signed long int conMin = (signed long int)(60 * 60 * 24 * 7 * 52);
  signed long int conMax = (signed long int)0;
  signed long int cmdTot = (signed long int)0;
  signed long int cmdMin = (signed long int)(60 * 60 * 24 * 7 * 52);
  signed long int cmdMax = (signed long int)0;
  signed int failed = 0;
  signed int canceled = 0;
  signed int n = 0;
  signed long int tmp_if_expr_1;
  signed long int tmp_if_expr_2;
  signed long int tmp_if_expr_3;
  signed long int tmp_if_expr_4;
  for( ; !(n >= rshcount); n = n + 1)
    if((signed int)(t + (signed long int)n)->state == DSH_FAILED)
      failed = failed + 1;

    else
      if((signed int)(t + (signed long int)n)->state == DSH_CANCELED)
        canceled = canceled + 1;

      else
      {
        conTot = conTot + ((t + (signed long int)n)->connect - (t + (signed long int)n)->start);
        cmdTot = cmdTot + ((t + (signed long int)n)->finish - (t + (signed long int)n)->connect);
        if(!(conMin >= (t + (signed long int)n)->connect + -(t + (signed long int)n)->start))
          tmp_if_expr_1 = conMin;

        else
          tmp_if_expr_1 = (t + (signed long int)n)->connect - (t + (signed long int)n)->start;
        conMin = tmp_if_expr_1;
        if(!((t + (signed long int)n)->connect + -(t + (signed long int)n)->start >= conMax))
          tmp_if_expr_2 = conMax;

        else
          tmp_if_expr_2 = (t + (signed long int)n)->connect - (t + (signed long int)n)->start;
        conMax = tmp_if_expr_2;
        if(!(cmdMin >= (t + (signed long int)n)->finish + -(t + (signed long int)n)->connect))
          tmp_if_expr_3 = cmdMin;

        else
          tmp_if_expr_3 = (t + (signed long int)n)->finish - (t + (signed long int)n)->connect;
        cmdMin = tmp_if_expr_3;
        if(!((t + (signed long int)n)->finish + -(t + (signed long int)n)->connect >= cmdMax))
          tmp_if_expr_4 = cmdMax;

        else
          tmp_if_expr_4 = (t + (signed long int)n)->finish - (t + (signed long int)n)->connect;
        cmdMax = tmp_if_expr_4;
      }
  if(!(failed >= rshcount))
  {
    err("Connect time:  Avg: %d sec, Min: %d sec,  Max: %d sec\n", conTot / (signed long int)(rshcount - failed), conMin, conMax);
    err("Command time:  Avg: %d sec, Min: %d sec,  Max: %d sec\n", cmdTot / (signed long int)(rshcount - failed), cmdMin, cmdMax);
  }

  else
  {
    err("Connect time:  no sucesses\n");
    err("Command time:  no sucesses\n");
  }
  err("Failures:      %d\n", failed);
  if(!(canceled == 0))
    err("Canceled:      %d\n", canceled);

}

// _error
// file pcp_server.c line 192
static void _error(struct pcp_server *s, const char *fmt, ...)
{
  char newfmt[1000l];
  void **ap;
  signed int save_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  save_errno = *return_value___errno_location_1;
  static struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  fp=fdopen(s->outfd, "w");
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    ap = (void **)&fmt;
    snprintf(newfmt, (unsigned long int)1000, "%c%s", 0x01, fmt);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = save_errno;
    errf(fp, newfmt, ap);
    ap = ((void **)NULL);
    fflush(fp);
  }

}

// _error_link1
// file hostlist.c line 336
static void _error_link1(char *file, signed int line, char *msg, ...)
{
  void **ap_link1;
  char buf[1024l];
  signed int len = 0;
  ap_link1 = (void **)&msg;
  len=vsnprintf(buf, (unsigned long int)1024, msg, ap_link1);
  if(len >= 1025 || !(len >= 0))
    buf[(signed long int)1023] = (char)0;

  lsd_fatal_error(file, line, buf);
  ap_link1 = ((void **)NULL);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// _extract_rc
// file dsh.c line 507
static signed int _extract_rc(char *buf)
{
  signed int ret = 0;
  char *p;
  p=strstr(buf, "XXRETCODE:");
  char *tmp_post_1;
  if(!(p == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buf);
    if((signed int)buf[-1l + (signed long int)return_value_strlen_2] == 10)
    {
      if(!(p == buf))
      {
        tmp_post_1 = p;
        p = p + 1l;
        *tmp_post_1 = (char)10;
      }

    }

    *p = (char)0;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen("XXRETCODE:");
    p = p + (signed long int)return_value_strlen_3;
    ret=atoi(p);
  }

  return ret;
}

// _fd_get_lock
// file fd.c line 123
static signed int _fd_get_lock(signed int fd, signed int cmd, signed int type)
{
  struct flock lock;
  lock.l_type = (signed short int)type;
  lock.l_start = (signed long int)0;
  lock.l_whence = (signed short int)0;
  lock.l_len = (signed long int)0;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, cmd, &lock);
  return return_value_fcntl_1;
}

// _fd_test_lock
// file fd.c line 139
static signed int _fd_test_lock(signed int fd, signed int type)
{
  struct flock lock;
  lock.l_type = (signed short int)type;
  lock.l_start = (signed long int)0;
  lock.l_whence = (signed short int)0;
  lock.l_len = (signed long int)0;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, 5, &lock);
  if(!(return_value_fcntl_1 >= 0))
    return -1;

  else
    if((signed int)lock.l_type == 2)
      return 0;

    else
      return lock.l_pid;
}

// _find_path
// file opt.c line 249
char * _find_path(char *argv0)
{
  char *abspath = (char *)(void *)0;
  char cwd[4096l];
  char *return_value_getcwd_1;
  _Bool tmp_if_expr_6;
  char *return_value_strchr_5;
  if((signed int)*argv0 == 47)
    abspath=Strdup(argv0);

  else
  {
    return_value_getcwd_1=getcwd(cwd, (unsigned long int)4096);
    if(return_value_getcwd_1 == ((char *)NULL))
      errx("%p: getcwd failed: %m\n");

    if((signed int)*argv0 == 46)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strchr_5=strchr(argv0, 47);
      tmp_if_expr_6 = return_value_strchr_5 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      abspath=Strdup(cwd);
      xstrcat(&abspath, "/");
      xstrcat(&abspath, argv0);
    }

    else
    {
      char *path;
      char *dir;
      char *p;
      char *return_value_getenv_2;
      return_value_getenv_2=getenv("PATH");
      path=Strdup(return_value_getenv_2);
      if(path == ((char *)NULL))
        errx("%p: getenv PATH failed\n");

      dir = path;
      do
      {
        p=strchr(dir, 58);
        if(p == ((char *)NULL))
          break;

        *p = (char)0;
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(dir);
        if(return_value_strlen_3 >= 1ul)
        {
          abspath=_check_path(dir, cwd, argv0);
          if(!(abspath == ((char *)NULL)))
          {
            Free((void **)&path);
            goto done;
          }

        }

        p = p + 1l;
        dir = p;
      }
      while((_Bool)1);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(dir);
      if(return_value_strlen_4 >= 1ul)
        abspath=_check_path(dir, cwd, argv0);

      Free((void **)&path);
    }
  }

done:
  ;
  return abspath;
}

// _flush_output
// file dsh.c line 579
static void _flush_output(struct cbuf *cb, void (*outf)(const char *, ...), struct thd *t)
{
  char buf[8192l];
  signed int return_value_cbuf_read_1;
  return_value_cbuf_read_1=cbuf_read(cb, (void *)buf, 8192);
  if(return_value_cbuf_read_1 >= 1)
  {
    if(!(t->labels == /*enum*/false))
      outf("%S: %s\n", t->host, (const void *)buf);

    else
      outf("%s\n", (const void *)buf);
  }

  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// _fwd_signal
// file dsh.c line 260
static void _fwd_signal(signed int signum)
{
  signed int i;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_1 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 264);

  }
  while((_Bool)0);
  i = 0;
  for( ; !((t + (signed long int)i)->host == ((char *)NULL)); i = i + 1)
    if((signed int)(t + (signed long int)i)->state == DSH_READING)
      rcmd_signal((t + (signed long int)i)->rcmd, signum);

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_2 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 269);

  }
  while((_Bool)0);
}

// _get_bracketed_list
// file hostlist.c line 2136
static signed int _get_bracketed_list(struct hostlist *hl, signed int *start, const unsigned long int n, char *buf)
{
  struct hostrange_components **hr = hl->hr;
  signed int i = *start;
  signed int m;
  signed int len = 0;
  signed int bracket_needed;
  bracket_needed=_is_bracket_needed(hl, i);
  len=snprintf(buf, n, "%s", hr[(signed long int)i]->prefix);
  signed int tmp_post_1;
  signed int tmp_post_5;
  _Bool tmp_if_expr_3;
  signed int return_value_hostrange_within_range_2;
  if(!(len >= 0) || !(n >= (unsigned long int)len))
    return (signed int)n;

  else
  {
    if(len >= 0 && !(bracket_needed == 0) && !((unsigned long int)len >= n))
    {
      tmp_post_1 = len;
      len = len + 1;
      buf[(signed long int)tmp_post_1] = (char)91;
    }

    do
    {
      m = (signed int)(n - (unsigned long int)len <= n ? n - (unsigned long int)len : (unsigned long int)0);
      unsigned long int return_value_hostrange_numstr_4;
      return_value_hostrange_numstr_4=hostrange_numstr(hr[(signed long int)i], (unsigned long int)m, buf + (signed long int)len);
      len = len + (signed int)return_value_hostrange_numstr_4;
      if((unsigned long int)len >= n)
        break;

      if(!(bracket_needed == 0))
      {
        tmp_post_5 = len;
        len = len + 1;
        buf[(signed long int)tmp_post_5] = (char)44;
      }

      i = i + 1;
      if(!(i >= hl->nranges))
      {
        return_value_hostrange_within_range_2=hostrange_within_range(hr[(signed long int)i], hr[(signed long int)(i - 1)]);
        tmp_if_expr_3 = return_value_hostrange_within_range_2 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
    }
    while(tmp_if_expr_3);
    if(len >= 1 && !(bracket_needed == 0) && !((unsigned long int)len >= n))
    {
      buf[(signed long int)(len - 1)] = (char)93;
      buf[(signed long int)len] = (char)0;
    }

    else
      if((unsigned long int)len >= n)
      {
        if(n >= 1ul)
          buf[(signed long int)(n - (unsigned long int)1)] = (char)0;

      }

      else
        buf[(signed long int)(len > 0 ? len : 0)] = (char)0;
    *start = i;
    return len;
  }
}

// _get_dir_name
// file mod.c line 1004
static char * _get_dir_name(const char *path, char *buf, unsigned long int len)
{
  signed int pathlen = 256;
  char *orig_path;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc((unsigned long int)pathlen * sizeof(char) /*1ul*/ );
  orig_path = (char *)return_value_Malloc_1;
  char *return_value_getcwd_2;
  do
  {
    return_value_getcwd_2=getcwd(orig_path, (unsigned long int)pathlen);
    if(!(return_value_getcwd_2 == ((char *)NULL)))
      break;

    if(pathlen >= 2)
      break;

    pathlen = pathlen * (signed int)((unsigned long int)2 * sizeof(char) /*1ul*/ );
    Realloc((void **)&orig_path, (unsigned long int)pathlen);
  }
  while((_Bool)1);
  signed int return_value_chdir_3;
  return_value_chdir_3=chdir(path);
  if(!(return_value_chdir_3 >= 0))
    errx("Unable to chdir() to %s: %m", path);

  char *return_value_getcwd_4;
  return_value_getcwd_4=getcwd(buf, len);
  if(return_value_getcwd_4 == ((char *)NULL))
    errx("Unable to get working directory for module path: %s\n", path);

  signed int return_value_chdir_5;
  return_value_chdir_5=chdir(orig_path);
  if(!(return_value_chdir_5 >= 0))
    err("Unable to return to original working directory: %s: %m\n", orig_path);

  Free((void **)&orig_path);
  return buf;
}

// _getcmd
// file main.c line 382
static char * _getcmd(char *prompt)
{
  char *cmd = (char *)(void *)0;
  char buf[2048l];
  out("%s> ", prompt);
  char *return_value_fgets_1;
  return_value_fgets_1=fgets(buf, 2048, stdin);
  if(!(return_value_fgets_1 == ((char *)NULL)))
  {
    buf[(signed long int)(2048 - 1)] = (char)0;
    xstrcln(buf, (char *)(void *)0);
    cmd=Strdup(buf);
  }

  return cmd;
}

// _gethost
// file dsh.c line 333
static void _gethost(char *name, char *addr)
{
  struct hostent *hp;
  hp=gethostbyname(name);
  if(hp == ((struct hostent *)NULL))
    errx("%p: gethostbyname(\"%S\") failed\n", name);

  memcpy((void *)addr, (const void *)hp->h_addr_list[(signed long int)0], (unsigned long int)4);
}

// _handle_rcmd_stderr
// file dsh.c line 620
static signed int _handle_rcmd_stderr(struct thd *th)
{
  signed int rc;
  rc=_do_output(th->rcmd->efd, th->errbuf, (void (*)(const char *, ...))err, (enum anonymous)false, th);
  if(!(rc >= 1))
  {
    close(th->rcmd->efd);
    th->rcmd->efd = -1;
  }

  return rc;
}

// _handle_rcmd_stdout
// file dsh.c line 608
static signed int _handle_rcmd_stdout(struct thd *th)
{
  signed int rc;
  rc=_do_output(th->rcmd->fd, th->outbuf, (void (*)(const char *, ...))out, (enum anonymous)true, th);
  if(!(rc >= 1))
  {
    close(th->rcmd->fd);
    th->rcmd->fd = -1;
  }

  return rc;
}

// _handle_sigint
// file dsh.c line 915
static void _handle_sigint(signed long int *last_intrp)
{
  signed long int return_value_time_1;
  if(!(t == ((struct thd *)NULL)))
  {
    if(!(sigint_terminates == 0))
    {
      _fwd_signal(2);
      errx("%p: batch mode interrupt, aborting.\n");
    }

    else
    {
      return_value_time_1=time((signed long int *)(void *)0);
      if(return_value_time_1 + -(*last_intrp) >= 2l)
      {
        err("%p: interrupt (one more within %d sec to abort)\n", 1);
        err("%p:  (^Z within %d sec to cancel pending threads)\n", 1);
        *last_intrp=time((signed long int *)(void *)0);
        _list_slowthreads();
      }

      else
      {
        _fwd_signal(2);
        errx("%p: interrupt, aborting.\n");
      }
    }
  }

}

// _handle_sigtstp
// file dsh.c line 940
static void _handle_sigtstp(signed long int last_intr)
{
  if(!(t == ((struct thd *)NULL)))
  {
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    if(return_value_time_1 + -last_intr >= 2l)
      raise(19);

    else
      _cancel_pending_threads();
  }

}

// _hostlist_create
// file hostlist.c line 1380
static struct hostlist * _hostlist_create(const char *hostlist, char *sep, char *r_op)
{
  struct hostlist *return_value__hostlist_create_bracketed_1;
  return_value__hostlist_create_bracketed_1=_hostlist_create_bracketed(hostlist, sep, r_op);
  return return_value__hostlist_create_bracketed_1;
}

// _hostlist_create_bracketed
// file hostlist.c line 1498
static struct hostlist * _hostlist_create_bracketed(const char *hostlist, char *sep, char *r_op)
{
  struct hostlist *new;
  new=hostlist_new();
  struct _range ranges[10240l];
  signed int nr;
  signed int _hostlist_create_bracketed__1__err;
  char *p;
  char *tok;
  char *str;
  char *orig;
  char cur_tok[1024l];
  char *tmp_post_1;
  if(hostlist == ((const char *)NULL))
    return new;

  else
  {
    str=strdup(hostlist);
    orig = str;
    if(orig == ((char *)NULL))
    {
      hostlist_destroy(new);
      return (struct hostlist *)(void *)0;
    }

    else
    {
      do
      {
        tok=_next_tok(sep, &str);
        if(tok == ((char *)NULL))
          break;

        strncpy(cur_tok, tok, (unsigned long int)1024);
        p=strchr(tok, 91);
        if(!(p == ((char *)NULL)))
        {
          char *q;
          char *prefix = tok;
          tmp_post_1 = p;
          p = p + 1l;
          *tmp_post_1 = (char)0;
          q=strchr(p, 93);
          if(!(q == ((char *)NULL)))
          {
            *q = (char)0;
            nr=_parse_range_list(p, ranges, 10240);
            if(!(nr >= 0))
              goto error;

            q = q + 1l;
            if(!((signed int)*q == 0))
              _push_range_list_with_suffix(new, prefix, q, ranges, nr);

            else
              _push_range_list(new, prefix, ranges, nr);
          }

          else
            hostlist_push_host(new, cur_tok);
        }

        else
          hostlist_push_host(new, cur_tok);
      }
      while((_Bool)1);
      free((void *)orig);
      return new;

    error:
      ;
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      _hostlist_create_bracketed__1__err = *return_value___errno_location_2;
      hostlist_destroy(new);
      free((void *)orig);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = _hostlist_create_bracketed__1__err;
      return (struct hostlist *)(void *)0;
    }
  }
}

// _hostrange_string
// file hostlist.c line 1833
static char * _hostrange_string(struct hostrange_components *hr, signed int depth)
{
  char buf[80l];
  signed int len;
  len=snprintf(buf, (unsigned long int)(64 + 15), "%s", hr->prefix);
  if(hr->singlehost == 0u)
    snprintf(buf + (signed long int)len, (unsigned long int)((64 + 15) - len), "%0*lu", hr->width, hr->lo + (unsigned long int)depth);

  char *return_value_strdup_1;
  return_value_strdup_1=strdup(buf);
  return return_value_strdup_1;
}

// _increase_nofile_limit
// file dsh.c line 826
static void _increase_nofile_limit(struct anonymous_1 *opt)
{
  struct rlimit rlim[1l];
  signed int nfds = 2 * opt->fanout + 32;
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit(7, rlim);
  if(!(return_value_getrlimit_1 >= 0))
    err("getrlimit: %m\n");

  else
  {
    if(!(rlim[0l].rlim_cur >= rlim[0l].rlim_max))
    {
      if((unsigned long int)nfds >= rlim[0l].rlim_cur)
      {
        rlim[0l].rlim_cur = rlim[0l].rlim_max;
        signed int return_value_setrlimit_2;
        return_value_setrlimit_2=setrlimit(7, rlim);
        if(!(return_value_setrlimit_2 >= 0))
          err("Unable to increase max no. files: %m");

      }

    }

    goto __CPROVER_DUMP_L4;
  }

__CPROVER_DUMP_L4:
  ;
}

// _infile_names_check
// file opt.c line 787
static signed int _infile_names_check(struct anonymous_1 *opt)
{
  enum anonymous verified = (enum anonymous)true;
  struct listIterator *i;
  char *name;
  i=list_iterator_create(opt->infile_names);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    name = (char *)return_value_list_next_1;
    if(name == ((char *)NULL))
      break;

    struct stat sb;
    signed int return_value_stat_2;
    return_value_stat_2=stat(name, &sb);
    if(!(return_value_stat_2 >= 0))
    {
      err("%p: can't stat %s\n", name);
      verified = (enum anonymous)false;
    }

    else
    {
      if(!((61440u & sb.st_mode) == 16384u) && !((61440u & sb.st_mode) == 32768u))
      {
        err("%p: not a regular file or directory: %s\n", name);
        verified = (enum anonymous)false;
        break;
      }

      if((61440u & sb.st_mode) == 16384u)
      {
        if(opt->recursive == /*enum*/false)
        {
          err("%p: use -r to copy directories: %s\n", name);
          verified = (enum anonymous)false;
          break;
        }

      }

    }
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  return (signed int)verified;
}

// _init_pdsh_options
// file opt.c line 174
static void _init_pdsh_options()
{
  pdsh_options=Strdup("hLNKR:M:t:cqf:w:x:l:u:bI:dVT:Q");
  if((signed int)personality == DSH)
    xstrcat(&pdsh_options, "S");

  else
    xstrcat(&pdsh_options, "pryzZe:");
}

// _interactive_dsh
// file main.c line 319
static void _interactive_dsh(struct anonymous_1 *opt)
{
  signed int pid;
  signal(2, (void (*)(signed int))1);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  signed int return_value_waitpid_4;
  signed int *return_value___errno_location_5;
  do
  {
    opt->cmd=_getcmd(opt->progname);
    if(opt->cmd == ((char *)NULL))
      break;

    if((signed int)*opt->cmd == 0)
      Free((void **)&opt->cmd);

    else
      if((signed int)*opt->cmd == 33)
      {
        _shell(opt->luid, opt->cmd + (signed long int)1);
        Free((void **)&opt->cmd);
      }

      else
      {
        signed int return_value_strcmp_1;
        return_value_strcmp_1=strcmp(opt->cmd, "quit");
        if(return_value_strcmp_1 == 0)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_strcmp_2=strcmp(opt->cmd, "exit");
          tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          Free((void **)&opt->cmd);
          break;
        }

        pid=fork();
        if(!(pid == -1))
        {
          if(pid == 0)
            goto __CPROVER_DUMP_L8;

        }

        else
        {
          errx("%p: fork: %m\n");

        __CPROVER_DUMP_L8:
          ;
          dsh(opt);
          exit(0);
        }
        do
        {
          return_value_waitpid_4=waitpid(pid, (signed int *)(void *)0, 0);
          if(return_value_waitpid_4 >= 0)
            break;

          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 4))
            break;

        }
        while((_Bool)1);
        Free((void **)&opt->cmd);
      }
  }
  while((_Bool)1);
}

// _is_bracket_needed
// file hostlist.c line 2120
static signed int _is_bracket_needed(struct hostlist *hl, signed int i)
{
  struct hostrange_components *h1 = hl->hr[(signed long int)i];
  struct hostrange_components *h2;
  struct hostrange_components *tmp_if_expr_1;
  if(!(i >= hl->nranges + -1))
    tmp_if_expr_1 = hl->hr[(signed long int)(i + 1)];

  else
    tmp_if_expr_1 = (struct hostrange_components *)(void *)0;
  h2 = tmp_if_expr_1;
  unsigned long int return_value_hostrange_count_2;
  return_value_hostrange_count_2=hostrange_count(h1);
  _Bool tmp_if_expr_4;
  signed int return_value_hostrange_within_range_3;
  if(return_value_hostrange_count_2 >= 2ul)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_hostrange_within_range_3=hostrange_within_range(h1, h2);
    tmp_if_expr_4 = return_value_hostrange_within_range_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_4;
}

// _is_loaded
// file mod.c line 951
static signed int _is_loaded(char *filename)
{
  void *return_value_list_find_first_1;
  return_value_list_find_first_1=list_find_first(module_list, (signed int (*)(void *, void *))_cmp_filenames, (void *)filename);
  if(!(return_value_list_find_first_1 == NULL))
    return 1;

  else
    return 0;
}

// _iterator_advance
// file hostlist.c line 2273
static void _iterator_advance(struct hostlist_iterator *i)
{
  if(i->hl->nranges + -1 >= i->idx)
  {
    i->depth = i->depth + 1;
    if(!(i->hr->hi + -i->hr->lo >= (unsigned long int)i->depth))
    {
      i->depth = 0;
      i->idx = i->idx + 1;
      i->hr = i->hl->hr[(signed long int)i->idx];
    }

  }

}

// _iterator_advance_range
// file hostlist.c line 2289
static void _iterator_advance_range(struct hostlist_iterator *i)
{
  signed int nr;
  signed int j;
  struct hostrange_components **hr;
  nr = i->hl->nranges;
  hr = i->hl->hr;
  j = i->idx;
  i->depth = i->depth + 1;
  signed int return_value_hostrange_within_range_1;
  if(i->depth >= 1)
  {
    do
    {
      j = j + 1;
      if(j >= nr)
        break;

      return_value_hostrange_within_range_1=hostrange_within_range(i->hr, hr[(signed long int)j]);
      if(return_value_hostrange_within_range_1 == 0)
        break;

    }
    while((_Bool)1);
    i->idx = j;
    i->hr = i->hl->hr[(signed long int)i->idx];
    i->depth = 0;
  }

}

// _list_slowthreads
// file dsh.c line 192
static void _list_slowthreads(void)
{
  signed int i;
  signed long int ttl;
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_1 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 197);

  }
  while((_Bool)0);
  i = 0;
  signed long int return_value_time_2;
  signed long int return_value_time_3;
  for( ; !((t + (signed long int)i)->host == ((char *)NULL)); i = i + 1)
    switch((signed int)(t + (signed long int)i)->state)
    {
      case DSH_READING:
      {
        err("%p: %S: command in progress", (t + (signed long int)i)->host);
        return_value_time_2=time((signed long int *)(void *)0);
        ttl = ((t + (signed long int)i)->connect + (signed long int)command_timeout) - return_value_time_2;
        if(!(command_timeout == 0) && !(debug == 0))
          err(" (timeout in %d secs)\n", ttl);

        else
          err("\n");
        break;
      }
      case DSH_RCMD:
      {
        return_value_time_3=time((signed long int *)(void *)0);
        ttl = ((t + (signed long int)i)->start + (signed long int)connect_timeout) - return_value_time_3;
        err("%p: %S: connecting", (t + (signed long int)i)->host, ttl);
        if(!(connect_timeout == 0) && !(debug == 0))
          err(" (timeout in %d secs)\n", ttl);

        else
          err("\n");
        break;
      }
      case DSH_NEW:
      {
        if(!(debug == 0))
          err("%p: %S: [new]\n", (t + (signed long int)i)->host);

        break;
      }
      case DSH_FAILED:
      {
        if(!(debug == 0))
          err("%p: %S: [failed]\n", (t + (signed long int)i)->host);

        break;
      }
      case DSH_DONE:
      {
        if(!(debug == 0))
          err("%p: %S: [done]\n", (t + (signed long int)i)->host);

        break;
      }
      case DSH_CANCELED:
        if(!(debug == 0))
          err("%p: %S: [canceled]\n", (t + (signed long int)i)->host);

    }
  do
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_4 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 237);

  }
  while((_Bool)0);
}

// _makespace
// file xstring.c line 87
static void _makespace(char **str, signed int needed)
{
  signed int used;
  void *return_value_Malloc_1;
  signed int return_value_Size_3;
  if(*str == ((char *)NULL))
  {
    return_value_Malloc_1=Malloc((unsigned long int)(needed + 1));
    *str = (char *)return_value_Malloc_1;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(*str);
    used = (signed int)(return_value_strlen_2 + (unsigned long int)1);
    do
    {
      return_value_Size_3=Size((void *)*str);
      if(return_value_Size_3 >= used + needed)
        break;

      signed int newsize;
      signed int return_value_Size_4;
      return_value_Size_4=Size((void *)*str);
      newsize = return_value_Size_4 + 32;
      Realloc((void **)str, (unsigned long int)newsize);
    }
    while((_Bool)1);
  }
}

// _mask_signals
// file dsh.c line 243
static void _mask_signals(signed int how)
{
  struct anonymous_11 blockme;
  sigemptyset(&blockme);
  sigaddset(&blockme, 2);
  sigaddset(&blockme, 20);
  sigaddset(&blockme, 17);
  pthread_sigmask(how, &blockme, (struct anonymous_11 *)(void *)0);
}

// _mod_delete
// file mod.c line 686
static signed int _mod_delete(const char *type, const char *name)
{
  struct listIterator *i;
  i=list_iterator_create(module_list);
  struct module_components *m;
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    m = (struct module_components *)return_value_list_next_1;
    if(m == ((struct module_components *)NULL))
      break;

    signed int return_value__mod_description_match_2;
    return_value__mod_description_match_2=_mod_description_match(m, type, name);
    if(!(return_value__mod_description_match_2 == 0))
      list_delete(i);

  }
  while((_Bool)1);
  return 0;
}

// _mod_description_match
// file mod.c line 547
static signed int _mod_description_match(struct module_components *m, const char *type, const char *name)
{
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(m->pmod->type, type);
  signed int return_value_strcmp_1;
  if(return_value_strcmp_2 == 0)
  {
    return_value_strcmp_1=strcmp(m->pmod->name, name);
    if(!(return_value_strcmp_1 == 0))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// _mod_destroy
// file mod.c line 277
static void _mod_destroy(struct module_components *mod)
{
  if(!(mod->pmod == ((struct pdsh_module *)NULL)))
  {
    mod->pmod->type = (char *)(void *)0;
    mod->pmod->name = (char *)(void *)0;
    if(!(mod->initialized == 0))
    {
      if(!(mod->pmod->mod_ops == ((struct pdsh_module_operations *)NULL)))
      {
        if(!(mod->pmod->mod_ops->exit == ((signed int (*)(void))NULL)))
          mod->pmod->mod_ops->exit();

      }

    }

  }

  if(!(mod->filename == ((char *)NULL)))
    Free((void **)&mod->filename);

  if(!(mod->handle == ((struct lt_dlhandle_struct *)NULL)))
    lt_dlclose(mod->handle);

  Free((void **)&mod);
}

// _mod_find_misc
// file mod.c line 329
static signed int _mod_find_misc(struct module_components *mod, const char *name)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(mod->pmod->type, "misc");
  if(!(return_value_strcmp_1 == 0))
    return 0;

  else
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(mod->pmod->name, name);
    if(!(return_value_strcmp_2 == 0))
      return 0;

    else
      return 1;
  }
}

// _mod_find_opt
// file mod.c line 677
static struct pdsh_module_option * _mod_find_opt(struct module_components *mod, signed int opt)
{
  struct pdsh_module_option *p = mod->pmod->opt_table;
  p = mod->pmod->opt_table;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(p == ((struct pdsh_module_option *)NULL)))
      tmp_if_expr_1 = (signed int)p->opt != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    if((signed int)p->opt == opt)
      return p;

    p = p + 1l;
  }
  while((_Bool)1);
  return (struct pdsh_module_option *)(void *)0;
}

// _mod_get_module_names
// file mod.c line 491
static struct list * _mod_get_module_names(char *type, signed int get_active)
{
  struct list *l;
  struct module_components *mod;
  struct listIterator *module_itr;
  l=list_create((void (*)(void *))(void *)0);
  module_itr=list_iterator_create(module_list);
  void *tmp_if_expr_3;
  void *return_value_list_find_1;
  void *return_value_list_next_2;
  if(module_itr == ((struct listIterator *)NULL))
  {
    err("Unable to create module list iterator\n");
    list_destroy(l);
    return (struct list *)(void *)0;
  }

  else
  {
    do
    {
      if(!(type == ((char *)NULL)))
      {
        return_value_list_find_1=list_find(module_itr, (signed int (*)(void *, void *))_cmp_type, (void *)type);
        tmp_if_expr_3 = return_value_list_find_1;
      }

      else
      {
        return_value_list_next_2=list_next(module_itr);
        tmp_if_expr_3 = return_value_list_next_2;
      }
      mod = (struct module_components *)tmp_if_expr_3;
      if(mod == ((struct module_components *)NULL))
        break;

      if((get_active == 0) == (mod->initialized == 0))
        list_push(l, (void *)mod->pmod->name);

    }
    while((_Bool)1);
    list_iterator_destroy(module_itr);
    return l;
  }
}

// _mod_init_list_safe
// file mod.c line 757
static signed int _mod_init_list_safe(struct module_components *mod, void *arg)
{
  _mod_initialize(mod);
  return 0;
}

// _mod_initialize
// file mod.c line 735
static signed int _mod_initialize(struct module_components *mod)
{
  enum anonymous return_value__mod_opts_ok_1;
  return_value__mod_opts_ok_1=_mod_opts_ok(mod);
  signed int return_value;
  if(return_value__mod_opts_ok_1 == /*enum*/false)
    return -1;

  else
    if(!(mod->pmod->mod_ops == ((struct pdsh_module_operations *)NULL)))
    {
      if(mod->pmod->mod_ops->init == ((signed int (*)(void))NULL))
        goto __CPROVER_DUMP_L2;

      return_value=mod->pmod->mod_ops->init();
      err("%p: error: %s/%s failed to initialize.\n", mod->pmod->type, mod->pmod->name);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      mod->initialized = 1;
      return 0;
    }
}

// _mod_initialize_by_name
// file mod.c line 339
static signed int _mod_initialize_by_name(char *name, struct list *l)
{
  struct module_components *mod;
  void *return_value_list_find_first_1;
  return_value_list_find_first_1=list_find_first(l, (signed int (*)(void *, void *))_mod_find_misc, (void *)name);
  mod = (struct module_components *)return_value_list_find_first_1;
  signed int return_value__mod_initialize_2;
  if(!(mod == ((struct module_components *)NULL)))
  {
    return_value__mod_initialize_2=_mod_initialize(mod);
    if(!(return_value__mod_initialize_2 >= 0))
      err("%p: Warning: Failed to initialize requested module \"%s/%s\"\n", mod->pmod->type, mod->pmod->name);

  }

  return 0;
}

// _mod_initialize_modules_by_name
// file mod.c line 349
static signed int _mod_initialize_modules_by_name(char *names, struct list *m)
{
  struct list *l;
  if(names == ((char *)NULL))
    return 0;

  else
  {
    l=list_split(",", names);
    list_for_each(l, (signed int (*)(void *, void *))_mod_initialize_by_name, (void *)m);
    return 0;
  }
}

// _mod_load_dynamic
// file mod.c line 806
static signed int _mod_load_dynamic(const char *fq_path)
{
  struct module_components *mod = (struct module_components *)(void *)0;
  const struct anonymous_25 *info;
  signed int *priority;
  mod=mod_create();
  mod->handle=lt_dlopen(fq_path);
  signed int return_value__is_loaded_1;
  void *return_value_lt_dlsym_2;
  void *return_value_lt_dlsym_3;
  signed int return_value__mod_register_4;
  if(!(mod->handle == ((struct lt_dlhandle_struct *)NULL)))
  {
    info=lt_dlgetinfo(mod->handle);
    if(!(info == ((const struct anonymous_25 *)NULL)))
    {
      if(!(info->filename == ((char *)NULL)))
      {
        mod->filename=Strdup(info->filename);
        return_value__is_loaded_1=_is_loaded(mod->filename);
        if(!(return_value__is_loaded_1 == 0))
          goto fail;

        return_value_lt_dlsym_2=lt_dlsym(mod->handle, "pdsh_module_info");
        mod->pmod = (struct pdsh_module *)return_value_lt_dlsym_2;
        if(mod->pmod == ((struct pdsh_module *)NULL))
        {
          err("%p:[%s] can't resolve pdsh module\n", mod->filename);
          goto fail;
        }

        return_value_lt_dlsym_3=lt_dlsym(mod->handle, "pdsh_module_priority");
        priority = (signed int *)return_value_lt_dlsym_3;
        if(!(priority == ((signed int *)NULL)))
          mod->priority = *priority;

        return_value__mod_register_4=_mod_register(mod, mod->filename);
        if(!(return_value__mod_register_4 >= 0))
          goto fail;

        return 0;
      }

    }


  fail_libtool_broken:
    ;
    mod->handle = (struct lt_dlhandle_struct *)(void *)0;
  }


fail:
  ;
  _mod_destroy(mod);
  return -1;
}

// _mod_load_dynamic_modules
// file mod.c line 875
static signed int _mod_load_dynamic_modules(const char *dir, struct anonymous_1 *pdsh_opts)
{
  struct __dirstream *dirp = (struct __dirstream *)(void *)0;
  struct dirent *entry = (struct dirent *)(void *)0;
  char path[4097l];
  char *p;
  signed int count = 0;
  unsigned int pdsh_owner = (unsigned int)0;
  if(initialized == /*enum*/false)
    mod_init();

  signed int return_value__pdsh_owner_1;
  return_value__pdsh_owner_1=_pdsh_owner(pdsh_opts->local_program_path, &pdsh_owner);
  char *tmp_post_4;
  unsigned int return_value_getuid_6;
  if(!(return_value__pdsh_owner_1 >= 0))
    return -1;

  else
  {
    enum anonymous return_value__path_permissions_ok_2;
    return_value__path_permissions_ok_2=_path_permissions_ok(dir, pdsh_owner);
    if(return_value__path_permissions_ok_2 == /*enum*/false)
      return -1;

    else
    {
      dirp=opendir(dir);
      if(dirp == ((struct __dirstream *)NULL))
        return -1;

      else
      {
        strncpy(path, dir, (unsigned long int)4096);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(dir);
        p = path + (signed long int)return_value_strlen_3;
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = (char)47;
        do
        {
          entry=readdir(dirp);
          if(entry == ((struct dirent *)NULL))
            break;

          struct stat st;
          strcpy(p, entry->d_name);
          signed int return_value_stat_5;
          return_value_stat_5=stat(path, &st);
          if(return_value_stat_5 >= 0)
          {
            if((61440u & st.st_mode) == 32768u)
            {
              if(!(st.st_uid == 0u))
              {
                return_value_getuid_6=getuid();
                if(st.st_uid == return_value_getuid_6)
                  goto __CPROVER_DUMP_L8;

                if(st.st_uid == pdsh_owner)
                  goto __CPROVER_DUMP_L8;

                err("%p: skipping insecure module \"%s\" (check owner)\n", (const void *)path);
              }

              else
              {

              __CPROVER_DUMP_L8:
                ;
                if(!((2u & st.st_mode) == 0u))
                  err("%p: skipping insecure module \"%s\" (check perms)\n", (const void *)path);

                else
                {
                  signed int return_value__mod_load_dynamic_7;
                  return_value__mod_load_dynamic_7=_mod_load_dynamic(path);
                  if(return_value__mod_load_dynamic_7 >= 0)
                    count = count + 1;

                }
              }
            }

          }

        }
        while((_Bool)1);
        signed int return_value_closedir_8;
        return_value_closedir_8=closedir(dirp);
        if(!(return_value_closedir_8 >= 0))
          err("%p: error closing %s: %m", dir);

        if(count == 0)
          errx("%p: no modules found\n");

        return 0;
      }
    }
  }
}

// _mod_next_active
// file mod.c line 181
static struct module_components * _mod_next_active(struct listIterator *i)
{
  struct module_components *mod;
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    mod = (struct module_components *)return_value_list_next_1;
    if(mod == ((struct module_components *)NULL))
      break;

    if(!(mod->initialized == 0))
      return mod;

  }
  while((_Bool)1);
  return (struct module_components *)(void *)0;
}

// _mod_opts_ok
// file mod.c line 311
static enum anonymous _mod_opts_ok(struct module_components *mod)
{
  enum anonymous return_value_opt_register_1;
  return_value_opt_register_1=opt_register(mod->pmod->opt_table);
  if(return_value_opt_register_1 == /*enum*/false)
    return (enum anonymous)false;

  else
    return (enum anonymous)true;
}

// _mod_postop
// file mod.c line 169
signed int _mod_postop(struct module_components *mod, struct anonymous_1 *pdsh_opts)
{
  signed int return_value;
  if(!(mod->pmod->mod_ops == ((struct pdsh_module_operations *)NULL)))
  {
    if(mod->pmod->mod_ops->postop == ((signed int (*)(struct anonymous_1 *))NULL))
      goto __CPROVER_DUMP_L1;

    return_value=mod->pmod->mod_ops->postop(pdsh_opts);
    return return_value;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// _mod_print_info
// file mod.c line 426
static signed int _mod_print_info(struct module_components *mod)
{
  char *tmp_if_expr_1;
  char *tmp_if_expr_2;
  if(mod == ((struct module_components *)NULL))
    return 0;

  else
  {
    out("Module: %s/%s\n", mod->pmod->type, mod->pmod->name);
    if(!(mod->pmod->author == ((char *)NULL)))
      tmp_if_expr_1 = mod->pmod->author;

    else
      tmp_if_expr_1 = "???";
    out("Author: %s\n", tmp_if_expr_1);
    if(!(mod->pmod->descr == ((char *)NULL)))
      tmp_if_expr_2 = mod->pmod->descr;

    else
      tmp_if_expr_2 = "???";
    out("Descr:  %s\n", tmp_if_expr_2);
    out("Active: %s\n", mod->initialized != 0 ? "yes" : "no");
    if(!(mod->pmod->opt_table == ((struct pdsh_module_option *)NULL)))
    {
      if(!(mod->pmod->opt_table->opt == 0))
      {
        out("Options:\n");
        mod_print_options(mod, 18);
      }

    }

    out("\n");
    return 0;
  }
}

// _mod_read_wcoll
// file mod.c line 160
struct hostlist * _mod_read_wcoll(struct module_components *mod, struct anonymous_1 *pdsh_opts)
{
  struct hostlist *return_value;
  if(!(mod->pmod->mod_ops == ((struct pdsh_module_operations *)NULL)))
  {
    if(mod->pmod->mod_ops->read_wcoll == ((struct hostlist * (*)(struct anonymous_1 *))NULL))
      goto __CPROVER_DUMP_L1;

    return_value=mod->pmod->mod_ops->read_wcoll(pdsh_opts);
    return return_value;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return ((struct hostlist *)NULL);
  }
}

// _mod_register
// file mod.c line 699
static signed int _mod_register(struct module_components *mod, const char *name)
{
  struct module_components *prev;
  _Bool tmp_if_expr_1;
  if(mod->pmod->type == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(mod->pmod->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    err("%p:[%s] type or name not specified in module\n", name);
    return -1;
  }

  else
  {
    prev=mod_get_module(mod->pmod->type, mod->pmod->name);
    if(!(prev == ((struct module_components *)NULL)))
    {
      err("%p: %s: [%s/%s] already loaded from [%s]\n", mod->filename, mod->pmod->type, mod->pmod->name, prev->filename);
      if(!(prev->priority >= mod->priority))
      {
        _mod_delete(mod->pmod->type, mod->pmod->name);
        goto __CPROVER_DUMP_L5;
      }

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      enum anonymous_5 return_value_pdsh_personality_2;
      return_value_pdsh_personality_2=pdsh_personality();
      if((mod->pmod->personality & (signed int)return_value_pdsh_personality_2) == 0)
        return -1;

      else
      {
        list_prepend(module_list, (void *)mod);
        return 0;
      }
    }
  }
}

// _module_list_string
// file opt.c line 1053
static signed int _module_list_string(char *type, char *buf, signed int len)
{
  struct list *l = (struct list *)(void *)0;
  signed int n = 0;
  signed int return_value_mod_count_1;
  return_value_mod_count_1=mod_count(type);
  if(return_value_mod_count_1 == 0)
    return 0;

  else
  {
    l=mod_get_module_names(type);
    n=list_join(buf, (unsigned long int)len, ",", l);
    list_destroy(l);
    return n;
  }
}

// _module_list_uninitialized
// file opt.c line 1068
static signed int _module_list_uninitialized(char *type, char *buf, signed int len)
{
  struct list *l = (struct list *)(void *)0;
  signed int n = 0;
  signed int return_value_mod_count_1;
  return_value_mod_count_1=mod_count(type);
  if(return_value_mod_count_1 == 0)
    return 0;

  else
  {
    l=mod_get_uninitialized_module_names(type);
    n=list_join(buf, (unsigned long int)len, ",", l);
    list_destroy(l);
    return n;
  }
}

// _next_tok
// file hostlist.c line 366
static char * _next_tok(char *sep, char **str)
{
  char *tok;
  signed int level = 0;
  char *return_value_strchr_1;
  for( ; !((signed int)*(*str) == 0); *str = *str + 1l)
  {
    return_value_strchr_1=strchr(sep, (signed int)*(*str));
    if(return_value_strchr_1 == ((char *)NULL))
      break;

  }
  char *return_value_strchr_2;
  char *return_value_strchr_3;
  char *tmp_post_4;
  if((signed int)*(*str) == 0)
    return (char *)(void *)0;

  else
  {
    tok = *str;
    for( ; !((signed int)*(*str) == 0); *str = *str + 1l)
    {
      if(level == 0)
      {
        return_value_strchr_2=strchr(sep, (signed int)*(*str));
        if(!(return_value_strchr_2 == ((char *)NULL)))
          break;

      }

      if((signed int)*(*str) == 91)
        level = level + 1;

      else
        if((signed int)*(*str) == 93)
          level = level - 1;

    }
    for( ; !((signed int)*(*str) == 0); *tmp_post_4 = (char)0)
    {
      return_value_strchr_3=strchr(sep, (signed int)*(*str));
      if(return_value_strchr_3 == ((char *)NULL))
        break;

      tmp_post_4 = *str;
      *str = *str + 1l;
    }
    return tok;
  }
}

// _next_tok_link1
// file split.c line 45
static char * _next_tok_link1(char *sep_link1, char **str_link1)
{
  char *tok_link1;
  signed int level_link1 = 0;
  char *return_value_strchr_1_link1;
  for( ; !((signed int)*(*str_link1) == 0); *str_link1 = *str_link1 + 1l)
  {
    return_value_strchr_1_link1=strchr(sep_link1, (signed int)*(*str_link1));
    if(return_value_strchr_1_link1 == ((char *)NULL))
      break;

  }
  char *return_value_strchr_2_link1;
  char *return_value_strchr_3_link1;
  char *tmp_post_4_link1;
  if((signed int)*(*str_link1) == 0)
    return (char *)(void *)0;

  else
  {
    tok_link1 = *str_link1;
    for( ; !((signed int)*(*str_link1) == 0); *str_link1 = *str_link1 + 1l)
    {
      if(level_link1 == 0)
      {
        return_value_strchr_2_link1=strchr(sep_link1, (signed int)*(*str_link1));
        if(!(return_value_strchr_2_link1 == ((char *)NULL)))
          break;

      }

      if((signed int)*(*str_link1) == 91)
        level_link1 = level_link1 + 1;

      else
        if((signed int)*(*str_link1) == 93)
          level_link1 = level_link1 - 1;

    }
    for( ; !((signed int)*(*str_link1) == 0); *tmp_post_4_link1 = (char)0)
    {
      return_value_strchr_3_link1=strchr(sep_link1, (signed int)*(*str_link1));
      if(return_value_strchr_3_link1 == ((char *)NULL))
        break;

      tmp_post_4_link1 = *str_link1;
      *str_link1 = *str_link1 + 1l;
    }
    return tok_link1;
  }
}

// _opt_print
// file mod.c line 446
static signed int _opt_print(struct module_components *mod, signed int *col)
{
  if(!(mod->initialized == 0))
    mod_print_options(mod, *col);

  return 0;
}

// _parallel_copy
// file dsh.c line 395
static signed int _parallel_copy(struct thd *th)
{
  signed int rv = 0;
  if(!(th->pcp_Popt == /*enum*/false))
    rv=_pcp_server(th);

  else
    rv=_pcp_client(th);
  _Bool tmp_if_expr_2;
  if(th->pcp_Popt == /*enum*/false && !(rv >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = th->pcp_Popt != (enum anonymous)0 ? (_Bool)1 : (_Bool)0;
  signed int return_value__handle_rcmd_stderr_1;
  if(tmp_if_expr_2)
  {
    do
    {
      return_value__handle_rcmd_stderr_1=_handle_rcmd_stderr(th);
      if(!(return_value__handle_rcmd_stderr_1 >= 1))
        break;

    }
    while((_Bool)1);
    _flush_output(th->errbuf, (void (*)(const char *, ...))err, th);
  }

  close(th->rcmd->fd);
  if(!(th->dsh_sopt == /*enum*/false))
    close(th->rcmd->efd);

  return rv;
}

// _parse_command_with_quotes
// file xpopen.c line 211
static void _parse_command_with_quotes(char **argv, signed int maxn, char *str)
{
  signed int i = 0;
  char *c;
  char *lc = str;
  c = lc;
  unsigned long int return_value_strlen_2;
  signed int tmp_post_1;
  unsigned long int return_value_strlen_4;
  signed int tmp_post_3;
  while(!((signed int)*c == 0))
  {
    if(i >= maxn)
      break;

    switch((signed int)*c)
    {
      case 34:
      {
        c = c + 1l;
        lc = c;
        for( ; !((signed int)*c == 0); c = c + 1l)
          if((signed int)*c == 34)
            break;

        if((signed int)*c == 0)
          errx("%P: Unmatched `%c' in xpopen\n", *lc);

        *c = (char)0;
        return_value_strlen_2=strlen(lc);
        if(return_value_strlen_2 >= 1ul)
        {
          tmp_post_1 = i;
          i = i + 1;
          argv[(signed long int)tmp_post_1] = lc;
        }

        c = c + 1l;
        lc = c;
        break;
      }
      case 32:

      case 9:

      case 10:
      {
        *c = (char)0;
        if(!(lc == ((char *)NULL)))
        {
          return_value_strlen_4=strlen(lc);
          if(return_value_strlen_4 >= 1ul)
          {
            tmp_post_3 = i;
            i = i + 1;
            argv[(signed long int)tmp_post_3] = lc;
          }

        }

        c = c + 1l;
        lc = c;
        break;
      }
      default:
        c = c + 1l;
    }
  }
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(lc);
  signed int tmp_post_5;
  if(return_value_strlen_6 >= 1ul)
  {
    if(!(i >= maxn))
    {
      tmp_post_5 = i;
      i = i + 1;
      argv[(signed long int)tmp_post_5] = lc;
    }

  }

  argv[(signed long int)i] = (char *)(void *)0;
}

// _parse_range_list
// file hostlist.c line 1443
static signed int _parse_range_list(char *str, struct _range *ranges, signed int len)
{
  char *p;
  signed int count = 0;
  char *tmp_post_1;
  signed int tmp_post_2;
  while(!(str == ((char *)NULL)))
  {
    if(count == len)
      return -1;

    p=strchr(str, 44);
    if(!(p == ((char *)NULL)))
    {
      tmp_post_1 = p;
      p = p + 1l;
      *tmp_post_1 = (char)0;
    }

    tmp_post_2 = count;
    count = count + 1;
    signed int return_value__parse_single_range_3;
    return_value__parse_single_range_3=_parse_single_range(str, &ranges[(signed long int)tmp_post_2]);
    if(return_value__parse_single_range_3 == 0)
      return -1;

    str = p;
  }
  return count;
}

// _parse_single_range
// file hostlist.c line 1396
static signed int _parse_single_range(const char *str, struct _range *range)
{
  char *p;
  char *q;
  char *orig;
  orig=strdup(str);
  if(orig == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    return 0;
  }

  p=strchr(str, 45);
  char *tmp_post_2;
  if(!(p == ((char *)NULL)))
  {
    tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = (char)0;
    if((signed int)*p == 45)
      goto error;

  }

  range->lo=strtoul(str, &q, 10);
  _Bool tmp_if_expr_3;
  unsigned long int tmp_if_expr_5;
  unsigned long int return_value_strtoul_4;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_8;
  if(!(q == str))
  {
    if(!(p == ((char *)NULL)))
      tmp_if_expr_3 = *p != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_strtoul_4=strtoul(p, &q, 10);
      tmp_if_expr_5 = return_value_strtoul_4;
    }

    else
      tmp_if_expr_5 = range->lo;
    range->hi = tmp_if_expr_5;
    if(q == p)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)*q != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
      goto error;

    if(!(range->hi >= range->lo))
      goto error;

    if(1ul + range->hi + -range->lo >= 16385ul)
    {
      _error_link1("hostlist.c", 1421, "Too many hosts in range `%s'", orig);
      free((void *)orig);
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      *return_value___errno_location_7 = 34;
      return 0;
    }

    free((void *)orig);
    return_value_strlen_8=strlen(str);
    range->width = (signed int)return_value_strlen_8;
    return 1;
  }

  else
  {

  error:
    ;
    _error_link1("hostlist.c", 1431, "Invalid range: `%s'", orig);
    free((void *)orig);
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    *return_value___errno_location_9 = 22;
    return 0;
  }
}

// _path_permissions_ok
// file mod.c line 1040
static enum anonymous _path_permissions_ok(const char *dir, unsigned int pdsh_owner)
{
  struct stat st;
  char dirbuf[4097l];
  unsigned long int rootdev;
  unsigned long int rootino;
  enum permission_error error;
  signed int pos = 0;
  signed int return_value_stat_1;
  return_value_stat_1=stat("/", &st);
  if(!(return_value_stat_1 >= 0))
  {
    err("%p: Can't stat root directory: %m\n");
    return (enum anonymous)false;
  }

  else
  {
    rootdev = st.st_dev;
    rootino = st.st_ino;
    strncpy(dirbuf, dir, (unsigned long int)4096);
    dirbuf[(signed long int)4096] = (char)0;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(dirbuf);
    pos = (signed int)return_value_strlen_2;
    do
    {
      signed int return_value_stat_3;
      return_value_stat_3=stat(dirbuf, &st);
      if(!(return_value_stat_3 >= 0))
      {
        err("%p: Can't stat \"%s\": %m\n", dir);
        return (enum anonymous)false;
      }

      error=_dir_permission_error(&st, pdsh_owner);
      if(!((signed int)error == DIR_OK))
      {
        char buf[4096l];
        err("%p: module path \"%s\" insecure.\n", dir);
        char *return_value__get_dir_name_4;
        return_value__get_dir_name_4=_get_dir_name(dirbuf, buf, (unsigned long int)4096);
        char *return_value__perm_error_string_5;
        return_value__perm_error_string_5=_perm_error_string(error);
        err("%p: \"%s\": %s\n", return_value__get_dir_name_4, return_value__perm_error_string_5);
        return (enum anonymous)false;
      }

      if(pos >= 4094)
      {
        err("%p :-( Path too long while checking permissions\n");
        return (enum anonymous)false;
      }

      strncpy(&dirbuf[(signed long int)pos], "/..", (unsigned long int)4);
      pos = pos + 3;
    }
    while(!(st.st_dev == rootdev) || !(st.st_ino == rootino));
    return (enum anonymous)true;
  }
}

// _pcp_client
// file dsh.c line 380
static signed int _pcp_client(struct thd *th)
{
  struct pcp_client pcp[1l];
  pcp[0l].infd = th->rcmd->fd;
  pcp[0l].outfd = pcp[0l].infd;
  pcp[0l].preserve = th->pcp_popt;
  pcp[0l].pcp_client = th->pcp_Zopt;
  pcp[0l].host = th->host;
  pcp[0l].infiles = th->pcp_infiles;
  signed int return_value_pcp_client_1;
  return_value_pcp_client_1=pcp_client(pcp);
  return return_value_pcp_client_1;
}

// _pcp_remote_client
// file main.c line 411
static signed int _pcp_remote_client(struct anonymous_1 *opt)
{
  struct pcp_client pcp[1l];
  pcp[0l].infd = 0;
  pcp[0l].outfd = 1;
  pcp[0l].infiles=pcp_expand_dirs(opt->infile_names);
  pcp[0l].host = opt->pcp_client_host;
  pcp[0l].preserve = opt->preserve;
  pcp[0l].pcp_client = opt->pcp_client;
  signed int return_value_pcp_client_1;
  return_value_pcp_client_1=pcp_client(pcp);
  return return_value_pcp_client_1;
}

// _pcp_remote_server
// file main.c line 398
static signed int _pcp_remote_server(struct anonymous_1 *opt)
{
  struct pcp_server svr[1l];
  svr[0l].infd = 0;
  svr[0l].outfd = 1;
  svr[0l].preserve = opt->preserve;
  svr[0l].target_is_dir = opt->target_is_directory;
  svr[0l].outfile = opt->outfile_name;
  signed int return_value_pcp_server_1;
  return_value_pcp_server_1=pcp_server(svr);
  return return_value_pcp_server_1;
}

// _pcp_send_file_data
// file pcp_client.c line 205
static signed int _pcp_send_file_data(signed int outfd, char *filename, char *host)
{
  signed int filefd;
  signed int inbytes;
  signed int total = 0;
  char tmpbuf[8192l];
  filefd=open(filename, 00);
  if(!(filefd >= 0))
  {
    err("%S: _pcp_send_file_data: open %s: %m\n", host, filename);
    return -1;
  }

  else
  {
    do
    {
      signed long int return_value_read_1;
      return_value_read_1=read(filefd, (void *)tmpbuf, (unsigned long int)8192);
      inbytes = (signed int)return_value_read_1;
      if(!(inbytes >= 0))
      {
        err("%S: _pcp_send_file_data: read %s: %m\n", host, filename);
        return -1;
      }

      if(inbytes >= 1)
      {
        total = total + inbytes;
        signed int return_value__pcp_write_2;
        return_value__pcp_write_2=_pcp_write(outfd, tmpbuf, inbytes);
        if(!(return_value__pcp_write_2 >= 0))
        {
          err("%S: _pcp_send_file_data: write: %m\n", host);
          return -1;
        }

      }

    }
    while(inbytes >= 1);
    close(filefd);
    return 0;
  }
}

// _pcp_sendfile
// file pcp_client.c line 365
static signed int _pcp_sendfile(struct pcp_filename *pf, struct pcp_client *pcp)
{
  char *output_filename = (char *)(void *)0;
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(pf->filename, "a!b@c#d_");
  if(return_value_strcmp_3 == 0)
  {
    signed int return_value_pcp_sendstr_1;
    return_value_pcp_sendstr_1=pcp_sendstr(pcp->outfd, "E\n", pcp->host);
    if(!(return_value_pcp_sendstr_1 >= 0))
      errx("%p: failed to send exit subdir flag\n");

    signed int return_value_pcp_response_2;
    return_value_pcp_response_2=pcp_response(pcp->infd, pcp->host);
    if(!(return_value_pcp_response_2 >= 0))
      errx("%p: failed to exit subdir properly\n");

    return 0;
  }

  if(!(pcp->pcp_client == /*enum*/false))
  {
    if(!(pf->file_specified_by_user == 0))
    {
      output_filename=Strdup(pf->filename);
      xstrcat(&output_filename, ".");
      xstrcat(&output_filename, pcp->host);
    }

  }

  pcp_sendfile(pcp, pf->filename, output_filename);
  return 0;
}

// _pcp_server
// file dsh.c line 367
static signed int _pcp_server(struct thd *th)
{
  struct pcp_server svr[1l];
  svr[0l].infd = th->rcmd->fd;
  svr[0l].outfd = svr[0l].infd;
  svr[0l].preserve = th->pcp_popt;
  svr[0l].target_is_dir = th->pcp_yopt;
  svr[0l].outfile = th->outfile_name;
  signed int return_value_pcp_server_1;
  return_value_pcp_server_1=pcp_server(svr);
  return return_value_pcp_server_1;
}

// _pcp_write
// file pcp_client.c line 180
static signed int _pcp_write(signed int fd, char *buf, signed int size)
{
  char *bufp = buf;
  signed int towrite = size;
  signed int outbytes;
  while(towrite >= 1)
  {
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)bufp, (unsigned long int)towrite);
    outbytes = (signed int)return_value_write_1;
    if(!(outbytes >= 1))
      return -1;

    towrite = towrite - outbytes;
    bufp = bufp + (signed long int)outbytes;
  }
  return size;
}

// _pdsh_owner
// file mod.c line 860
static signed int _pdsh_owner(const char *pdsh_path, unsigned int *pdsh_uid)
{
  struct stat st;
  signed int return_value_stat_1;
  return_value_stat_1=stat(pdsh_path, &st);
  if(!(return_value_stat_1 >= 0))
  {
    err("%p: Unable to determine ownership of pdsh binary: %m\n");
    return -1;
  }

  else
  {
    *pdsh_uid = st.st_uid;
    return 0;
  }
}

// _perm_error_string
// file mod.c line 960
static char * _perm_error_string(enum permission_error error)
{
  switch((signed int)error)
  {
    case DIR_OK:
      return "Permissions are valid";
    case DIR_NOT_DIRECTORY:
      return "Not a directory";
    case DIR_BAD_OWNER:
      return "Owner not root, current uid, or pdsh executable owner";
    case DIR_WORLD_WRITABLE:
      return "World writable and sticky bit is not set";
    default:
      return "Unspecified error";
  }
}

// _pipecmd
// file pipecmd.c line 255
static signed int _pipecmd(char *path, char **args, signed int *fd2p, signed int *ppid)
{
  signed int sp[2l];
  signed int esp[2l];
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, sp);
  signed int return_value_socketpair_2;
  _Bool tmp_if_expr_5;
  signed int return_value_dup2_4;
  signed int tmp_if_expr_6;
  if(!(return_value_socketpair_1 >= 0))
  {
    err("%p: pipecmd: socketpair: %m\n");
    return -1;
  }

  else
    if(!(fd2p == ((signed int *)NULL)))
    {
      return_value_socketpair_2=socketpair(1, 1, 0, esp);
      if(return_value_socketpair_2 >= 0)
        goto __CPROVER_DUMP_L2;

      err("%p: pipecmd: socketpair: %m\n");
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      *ppid=fork();
      if(!(*ppid >= 0))
      {
        err("%p: pipecmd: fork: %m\n");
        return -1;
      }

      else
      {
        if(*ppid == 0)
        {
          close(sp[(signed long int)0]);
          signed int return_value_dup2_3;
          return_value_dup2_3=dup2(sp[(signed long int)1], 0);
          if(!(return_value_dup2_3 >= 0))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_dup2_4=dup2(0, 1);
            tmp_if_expr_5 = return_value_dup2_4 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
          {
            err("%p: pipecmd (in child): dup2: %m");
            _exit(255);
          }

          if(!(fd2p == ((signed int *)NULL)))
            tmp_if_expr_6 = esp[(signed long int)1];

          else
            tmp_if_expr_6 = 0;
          signed int return_value_dup2_7;
          return_value_dup2_7=dup2(tmp_if_expr_6, 2);
          if(!(return_value_dup2_7 >= 0))
          {
            err("%p: pipecmd (in child): dup2: %m");
            _exit(255);
          }

          if(!(fd2p == ((signed int *)NULL)))
            close(esp[(signed long int)0]);

          closeall(3);
          setsid();
          execvp(path, args);
          err("%p: execvp %s failed: %m\n", path);
          _exit(255);
        }

        close(sp[(signed long int)1]);
        if(!(fd2p == ((signed int *)NULL)))
        {
          close(esp[(signed long int)1]);
          *fd2p = esp[(signed long int)0];
        }

        return sp[(signed long int)0];
      }
    }
}

// _poll
// file xpoll.c line 54
static signed int _poll(struct xpollfd *xfds, unsigned int nfds, signed int timeout)
{
  signed int i;
  signed int rv;
  struct pollfd *pfds;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc((unsigned long int)nfds * sizeof(struct pollfd) /*8ul*/ );
  pfds = (struct pollfd *)return_value_Malloc_1;
  i = 0;
  for( ; !((unsigned int)i >= nfds); i = i + 1)
  {
    (pfds + (signed long int)i)->fd = (xfds + (signed long int)i)->fd;
    (pfds + (signed long int)i)->events = (signed short int)0;
    (pfds + (signed long int)i)->revents = (signed short int)0;
    if(!((0x0001 & (signed int)(xfds + (signed long int)i)->events) == 0))
      (pfds + (signed long int)i)->events = (pfds + (signed long int)i)->events | (signed short int)0x001;

    if(!((0x0002 & (signed int)(xfds + (signed long int)i)->events) == 0))
      (pfds + (signed long int)i)->events = (pfds + (signed long int)i)->events | (signed short int)0x004;

  }
  rv=poll(pfds, (unsigned long int)nfds, timeout);
  _Bool tmp_if_expr_2;
  if(!(rv >= 0))
  {
    Free((void **)&pfds);
    return -1;
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= nfds); i = i + 1)
    {
      if(!((0x001 & (signed int)(pfds + (signed long int)i)->revents) == 0))
        (xfds + (signed long int)i)->revents = (xfds + (signed long int)i)->revents | (signed short int)0x0001;

      if(!((0x004 & (signed int)(pfds + (signed long int)i)->revents) == 0))
        (xfds + (signed long int)i)->revents = (xfds + (signed long int)i)->revents | (signed short int)0x0002;

      if(!((0x008 & (signed int)(pfds + (signed long int)i)->revents) == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = ((signed int)(pfds + (signed long int)i)->revents & 0x010) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        (xfds + (signed long int)i)->revents = (xfds + (signed long int)i)->revents | (signed short int)0x0020;

      if(!((0x020 & (signed int)(pfds + (signed long int)i)->revents) == 0))
        (xfds + (signed long int)i)->revents = (xfds + (signed long int)i)->revents | (signed short int)0x0010;

    }
    Free((void **)&pfds);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 0;
    return rv;
  }
}

// _print_option_help
// file mod.c line 391
static void _print_option_help(struct pdsh_module_option *p, signed int col)
{
  char buf[81l];
  char *tmp_if_expr_1;
  if(!(p->arginfo == ((char *)NULL)))
    tmp_if_expr_1 = p->arginfo;

  else
    tmp_if_expr_1 = "";
  snprintf(buf, (unsigned long int)81, "-%c %-*s %s\n", p->opt, col - 4, tmp_if_expr_1, p->descr);
  err("%s", (const void *)buf);
}

// _push_range_list
// file hostlist.c line 1461
static void _push_range_list(struct hostlist *hl, char *pfx, struct _range *rng, signed int n)
{
  signed int i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    hostlist_push_hr(hl, pfx, rng->lo, rng->hi, rng->width);
    rng = rng + 1l;
  }
}

// _push_range_list_with_suffix
// file hostlist.c line 1472
static void _push_range_list_with_suffix(struct hostlist *hl, char *pfx, char *sfx, struct _range *rng, signed int n)
{
  signed int i;
  unsigned long int j;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    j = rng->lo;
    for( ; rng->hi >= j; j = j + 1ul)
    {
      char _push_range_list_with_suffix__1__1__1__1__1__host[4096l];
      struct hostrange_components *hr;
      snprintf(_push_range_list_with_suffix__1__1__1__1__1__host, (unsigned long int)4096, "%s%0*lu%s", pfx, rng->width, j, sfx);
      hr=hostrange_create_single(_push_range_list_with_suffix__1__1__1__1__1__host);
      hostlist_push_range(hl, hr);
      hostrange_destroy(hr);
    }
    rng = rng + 1l;
  }
}

// _rcmd_module_list
// file opt.c line 1084
static char * _rcmd_module_list(char *buf, signed int maxlen)
{
  signed int len;
  signed int len2;
  char rbuf[1024l];
  signed int n;
  n=_module_list_string("rcmd", rbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  char *tmp_if_expr_1;
  if(!(n == 0))
    tmp_if_expr_1 = rbuf;

  else
    tmp_if_expr_1 = "(none)";
  len=snprintf(buf, (unsigned long int)maxlen, "%s", tmp_if_expr_1);
  signed int return_value_mod_count_2;
  if(!(len >= maxlen) && len >= 0)
  {
    return_value_mod_count_2=mod_count("rcmd");
    if(return_value_mod_count_2 >= 2)
    {
      char *def;
      def=rcmd_get_default_module();
      len2=snprintf(buf + (signed long int)len, (unsigned long int)(maxlen - len), " (default: %s)", def != ((char *)NULL) ? def : "none");
      if(!(len2 >= 0))
        len = -1;

      else
        len = len + len2;
    }

  }


done:
  ;
  if(!(len >= 0) || !(maxlen >= len))
    snprintf((buf + (signed long int)maxlen) - (signed long int)12, (unsigned long int)12, "[truncated]");

  buf[(signed long int)(maxlen - 1)] = (char)0;
  return buf;
}

// _rcp_thread
// file dsh.c line 450
static void * _rcp_thread(void *args)
{
  struct thd *a = (struct thd *)args;
  signed int result = DSH_DONE;
  signed int rc;
  char *rcpycmd = (char *)(void *)0;
  a->start=time((signed long int *)(void *)0);
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_1 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 462);

  }
  while((_Bool)0);
  a->state = (enum anonymous_8)DSH_RCMD;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_2 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 464);

  }
  while((_Bool)0);
  if(!(a->pcp_Popt == /*enum*/false))
  {
    xstrcat(&rcpycmd, a->cmd);
    xstrcat(&rcpycmd, " ");
    xstrcat(&rcpycmd, a->host);
  }

  char *tmp_if_expr_3;
  if(!(rcpycmd == ((char *)NULL)))
    tmp_if_expr_3 = rcpycmd;

  else
    tmp_if_expr_3 = a->cmd;
  rcmd_connect(a->rcmd, a->host, a->addr, a->luser, a->ruser, tmp_if_expr_3, a->nodeid, a->dsh_sopt);
  if(!(rcpycmd == ((char *)NULL)))
    Free((void **)&rcpycmd);

  enum anonymous_8 return_value__update_connect_state_4;
  if(a->rcmd->fd == -1)
    result = DSH_FAILED;

  else
  {
    return_value__update_connect_state_4=_update_connect_state(a);
    if(!((signed int)return_value__update_connect_state_4 == DSH_CANCELED))
      _parallel_copy(a);

  }
  do
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_5 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 485);

  }
  while((_Bool)0);
  a->state = (enum anonymous_8)result;
  a->finish=time((signed long int *)(void *)0);
  do
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_6 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 488);

  }
  while((_Bool)0);
  rc=rcmd_destroy(a->rcmd);
  if(a->rc == 0)
  {
    if(rc >= 1)
      a->rc = rc;

  }

  do
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    *return_value___errno_location_7=pthread_mutex_lock(&threadcount_mutex);
    if(!(*return_value___errno_location_7 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 495);

  }
  while((_Bool)0);
  threadcount = threadcount - 1;
  pthread_cond_signal(&threadcount_cond);
  do
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    *return_value___errno_location_8=pthread_mutex_unlock(&threadcount_mutex);
    if(!(*return_value___errno_location_8 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 498);

  }
  while((_Bool)0);
  return (void *)0;
}

// _response
// file pcp_server.c line 142
static signed int _response(struct pcp_server *s)
{
  char resp;
  signed long int return_value_read_1;
  return_value_read_1=read(s->infd, (void *)&resp, sizeof(char) /*1ul*/ );
  if(!((unsigned long int)return_value_read_1 == sizeof(char) /*1ul*/ ))
  {
    _error(s, "lost connection\n");
    return -1;
  }

  else
  {
    if((signed int)resp == 0)
      return 0;

    _error(s, "invalid response received\n");
    return -1;
    return 0;
  }
}

// _rexpand_dir
// file pcp_client.c line 94
static void _rexpand_dir(struct list *list, char *name)
{
  struct __dirstream *dir;
  struct dirent *dp;
  struct stat sb;
  char file[4096l];
  struct pcp_filename *pf = (struct pcp_filename *)(void *)0;
  dir=opendir(name);
  if(dir == ((struct __dirstream *)NULL))
    errx("%p: opendir: %s: %m\n", name);

  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  do
  {
    dp=readdir(dir);
    if(dp == ((struct dirent *)NULL))
      break;

    if(!(dp->d_ino == 0ul))
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(dp->d_name, ".");
      if(return_value_strcmp_1 == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(dp->d_name, "..");
        tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_3)
      {
        snprintf(file, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", name, (const void *)dp->d_name);
        signed int return_value_stat_4;
        return_value_stat_4=stat(file, &sb);
        if(!(return_value_stat_4 >= 0))
          errx("%p: can't stat %s: %m\n", (const void *)file);

        signed int return_value_access_5;
        return_value_access_5=access(name, 4);
        if(!(return_value_access_5 >= 0))
          errx("%p: access: %s: %m\n", name);

        if(!((61440u & sb.st_mode) == 16384u) && !((61440u & sb.st_mode) == 32768u))
          errx("%p: not a regular file or directory: %s\n", (const void *)file);

        void *return_value_Malloc_6;
        return_value_Malloc_6=Malloc(sizeof(struct pcp_filename) /*16ul*/ );
        pf = (struct pcp_filename *)return_value_Malloc_6;
        pf->filename=Strdup(file);
        pf->file_specified_by_user = 0;
        list_append(list, (void *)pf);
        if((61440u & sb.st_mode) == 16384u)
          _rexpand_dir(list, file);

      }

    }

  }
  while((_Bool)1);
  closedir(dir);
  void *return_value_Malloc_7;
  return_value_Malloc_7=Malloc(sizeof(struct pcp_filename) /*16ul*/ );
  pf = (struct pcp_filename *)return_value_Malloc_7;
  pf->filename=Strdup("a!b@c#d_");
  pf->file_specified_by_user = 0;
  list_append(list, (void *)pf);
}

// _rsh_thread
// file dsh.c line 636
static void * _rsh_thread(void *args)
{
  struct thd *a = (struct thd *)args;
  signed int rv;
  signed int result = DSH_DONE;
  struct xpollfd xpfds[2l];
  signed int nfds = 1;
  a->start=time((signed long int *)(void *)0);
  _xsignal(13, ((void (*)(signed int))NULL));
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_1 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 653);

  }
  while((_Bool)0);
  a->state = (enum anonymous_8)DSH_RCMD;
  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_2 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 655);

  }
  while((_Bool)0);
  rcmd_connect(a->rcmd, a->host, a->addr, a->luser, a->ruser, a->cmd, a->nodeid, a->dsh_sopt);
  enum anonymous_8 return_value__update_connect_state_7;
  signed int return_value__thd_command_timeout_3;
  if(a->rcmd->fd == -1)
    result = DSH_FAILED;

  else
  {
    return_value__update_connect_state_7=_update_connect_state(a);
    if(!((signed int)return_value__update_connect_state_7 == DSH_CANCELED))
    {
      fd_set_nonblocking(a->rcmd->fd);
      memset((void *)xpfds, 0, sizeof(struct xpollfd [2l]) /*16ul*/ );
      xpfds[(signed long int)0].fd = a->rcmd->fd;
      if(!(a->dsh_sopt == /*enum*/false))
      {
        fd_set_nonblocking(a->rcmd->efd);
        xpfds[(signed long int)1].fd = a->rcmd->efd;
        nfds = nfds + 1;
      }

      else
        xpfds[(signed long int)1].fd = -1;
      xpfds[(signed long int)1].events = (signed short int)0x001;
      xpfds[(signed long int)0].events = xpfds[(signed long int)1].events;
      while((_Bool)1)
      {
        if(!(xpfds[0l].fd >= 0))
        {
          if(!(xpfds[1l].fd >= 0))
            goto __CPROVER_DUMP_L19;

        }

        rv=xpoll(xpfds, nfds, -1);
        if(rv == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 4))
            err("%p: %S: xpoll: %m\n", a->host);

          else
          {
            return_value__thd_command_timeout_3=_thd_command_timeout(a);
            if(!(return_value__thd_command_timeout_3 == 0))
              err("%p: %S: command timeout\n", a->host);

            else
              continue;
          }
          result = DSH_FAILED;
          rcmd_signal(a->rcmd, 15);
          break;
        }

        if(!((33 & (signed int)xpfds[0l].revents) == 0))
        {
          signed int return_value__handle_rcmd_stdout_5;
          return_value__handle_rcmd_stdout_5=_handle_rcmd_stdout(a);
          if(!(return_value__handle_rcmd_stdout_5 >= 1))
            xpfds[(signed long int)0].fd = -1;

        }

        if(!(a->dsh_sopt == /*enum*/false))
        {
          if(!((33 & (signed int)xpfds[1l].revents) == 0))
          {
            signed int return_value__handle_rcmd_stderr_6;
            return_value__handle_rcmd_stderr_6=_handle_rcmd_stderr(a);
            if(!(return_value__handle_rcmd_stderr_6 >= 1))
              xpfds[(signed long int)1].fd = -1;

          }

        }

        if(!(a->kill_on_fail == /*enum*/false))
          _die_if_signalled(a);

      }
    }

  }
  do
  {

  __CPROVER_DUMP_L19:
    ;
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    *return_value___errno_location_8=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_8 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 728);

  }
  while((_Bool)0);
  a->state = (enum anonymous_8)result;
  a->finish=time((signed long int *)(void *)0);
  do
  {
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    *return_value___errno_location_9=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_9 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 731);

  }
  while((_Bool)0);
  _flush_output(a->outbuf, (void (*)(const char *, ...))out, a);
  _flush_output(a->errbuf, (void (*)(const char *, ...))err, a);
  rv=rcmd_destroy(a->rcmd);
  if(a->rc == 0)
  {
    if(rv >= 1)
      a->rc = rv;

  }

  if(!(a->kill_on_fail == /*enum*/false))
  {
    if((signed int)a->state == DSH_FAILED)
    {
      _fwd_signal(15);
      errx("%p: terminating all processes\n");
    }

  }

  do
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    *return_value___errno_location_10=pthread_mutex_lock(&threadcount_mutex);
    if(!(*return_value___errno_location_10 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 748);

  }
  while((_Bool)0);
  threadcount = threadcount - 1;
  pthread_cond_signal(&threadcount_cond);
  do
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    *return_value___errno_location_11=pthread_mutex_unlock(&threadcount_mutex);
    if(!(*return_value___errno_location_11 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 751);

  }
  while((_Bool)0);
  return (void *)0;
}

// _shell
// file main.c line 362
static void _shell(unsigned int uid, char *cmd)
{
  signed int pid;
  pid=fork();
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    errx("%p: fork: %m\n");

  __CPROVER_DUMP_L2:
    ;
    setuid(uid);
    system(cmd);
    exit(0);
  }
  waitpid(pid, (signed int *)(void *)0, 0);
}

// _show_version
// file opt.c line 1142
static void _show_version(void)
{
  char buf[1024l];
  signed int n;
  printf("%s\n", pdsh_version);
  char *return_value__rcmd_module_list_1;
  return_value__rcmd_module_list_1=_rcmd_module_list(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  printf("rcmd modules: %s\n", return_value__rcmd_module_list_1);
  n=_module_list_string("misc", buf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  char *tmp_if_expr_2;
  if(!(n == 0))
    tmp_if_expr_2 = buf;

  else
    tmp_if_expr_2 = "(none)";
  printf("misc modules: %s", tmp_if_expr_2);
  n=_module_list_uninitialized("misc", buf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  if(!(n == 0))
  {
    printf(" (*conflicting: %s)\n", (const void *)buf);
    printf("[* To force-load a conflicting module, use the -M <name> option]\n");
  }

  else
    printf("\n");
  exit(0);
}

// _signals_thread
// file dsh.c line 951
static void * _signals_thread(void *arg)
{
  struct anonymous_11 set;
  signed long int last_intr = (signed long int)0;
  signed int signo;
  signed int e;
  sigemptyset(&set);
  sigaddset(&set, 2);
  sigaddset(&set, 20);
  while(!(t == ((struct thd *)NULL)))
  {
    e=sigwait(&set, &signo);
    if(!(e == 0))
    {
      if(e == 4)
        continue;

      char *return_value_strerror_1;
      return_value_strerror_1=strerror(e);
      err("sigwait: %s\n", return_value_strerror_1);
    }

    switch(signo)
    {
      case 2:
      {
        _handle_sigint(&last_intr);
        break;
      }
      case 20:
      {
        _handle_sigtstp(last_intr);
        break;
      }
      default:
        err("%p: Didn't expect to be here.\n");
    }
  }
  return (void *)0;
}

// _sink
// file pcp_server.c line 214
static void _sink(struct pcp_server *svr, char *targ, struct _buf *bufp)
{
  char *cp;
  struct stat stb;
  struct timeval tv[2l];
  /* #anon_enum_YES=0_NO=1_DISPLAYED=2 */
enum anonymous_4 { YES=0, NO=1, DISPLAYED=2 };

/* */
  ;
  enum anonymous_4 wrerr;
  struct _buf *bp;
  signed long int i;
  signed long int j;
  signed long int size;
  char ch;
  const char *why = "failed to set 'why' string";
  signed int amt;
  signed int count;
  signed int exists;
  signed int mask;
  signed int mode;
  signed int ofd;
  signed int setimes;
  signed int targisdir;
  signed int cursize = 0;
  char *np;
  char *buf = (char *)(void *)0;
  char *namebuf = (char *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)8192);
  buf = (char *)return_value_malloc_1;
  char *tmp_post_6;
  char *tmp_post_8;
  _Bool tmp_if_expr_9;
  const unsigned short int **return_value___ctype_b_loc_10;
  char *tmp_post_11;
  char *tmp_post_12;
  const unsigned short int **return_value___ctype_b_loc_13;
  char *tmp_post_14;
  char *tmp_post_15;
  const unsigned short int **return_value___ctype_b_loc_16;
  char *tmp_post_17;
  char *tmp_post_18;
  const unsigned short int **return_value___ctype_b_loc_19;
  char *tmp_post_20;
  char *tmp_post_21;
  _Bool tmp_if_expr_22;
  char *tmp_post_23;
  const unsigned short int **return_value___ctype_b_loc_24;
  char *tmp_post_25;
  char *tmp_post_26;
  signed int return_value_mkdir_32;
  signed long int return_value_write_34;
  signed long int return_value_write_35;
  if(buf == ((char *)NULL))
    _error(svr, "out of memory for buf: %m\n");

  else
  {
    targisdir = 0;
    setimes = targisdir;
    unsigned int return_value_umask_2;
    return_value_umask_2=umask((unsigned int)0);
    mask = (signed int)return_value_umask_2;
    if(svr->preserve == /*enum*/false)
      umask((unsigned int)mask);

    if(!(svr->target_is_dir == /*enum*/false))
    {
      signed int return_value__verifydir_3;
      return_value__verifydir_3=_verifydir(svr, svr->outfile);
      if(!(return_value__verifydir_3 >= 0))
        goto __CPROVER_DUMP_L71;

    }

    write(svr->outfd, (const void *)"", (unsigned long int)1);
    signed int return_value_stat_4;
    return_value_stat_4=stat(targ, &stb);
    if(return_value_stat_4 == 0)
    {
      if((61440u & stb.st_mode) == 16384u)
        targisdir = 1;

    }

    while((_Bool)1)
    {
      signed int rc;
      cp = buf;
      signed long int return_value_read_5;
      return_value_read_5=read(svr->infd, (void *)cp, (unsigned long int)1);
      rc = (signed int)return_value_read_5;
      if(!(rc >= 1))
        goto end_server;

      tmp_post_6 = cp;
      cp = cp + 1l;
      if((signed int)*tmp_post_6 == 10)
      {
        why = "unexpected <newline>";
        break;
      }

      do
      {
        signed long int return_value_read_7;
        return_value_read_7=read(svr->infd, (void *)&ch, sizeof(char) /*1ul*/ );
        if(!((unsigned long int)return_value_read_7 == sizeof(char) /*1ul*/ ))
        {
          why = "lost connection";
          goto screwup;
        }

        tmp_post_8 = cp;
        cp = cp + 1l;
        *tmp_post_8 = ch;
      }
      while(!((signed int)ch == 10) && !(cp >= buf + 8191l));
      *cp = (char)0;
      if((signed int)*buf == 1)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = (signed int)buf[(signed long int)0] == 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_9)
      {
        if((signed int)*buf == 2)
          goto end_server;

      }

      else
      {
        if((signed int)*buf == 69)
        {
          write(svr->outfd, (const void *)"", (unsigned long int)1);
          goto end_server;
        }

        if((signed int)ch == 10)
        {
          cp = cp - 1l;
          *cp = (char)0;
        }

        cp = buf;
        if((signed int)*cp == 84)
        {
          setimes = setimes + 1;
          cp = cp + 1l;
          tv[(signed long int)1].tv_sec = (signed long int)0;
          do
          {
            return_value___ctype_b_loc_10=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)*cp]) == 0)
              break;

            tmp_post_11 = cp;
            cp = cp + 1l;
            tv[(signed long int)1].tv_sec = tv[(signed long int)1].tv_sec * (signed long int)10 + (signed long int)((signed int)*tmp_post_11 - 48);
          }
          while((_Bool)1);
          tmp_post_12 = cp;
          cp = cp + 1l;
          if(!((signed int)*tmp_post_12 == 32))
          {
            why = "mtime.sec not delimited";
            break;
          }

          tv[(signed long int)1].tv_usec = (signed long int)0;
          do
          {
            return_value___ctype_b_loc_13=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)*cp]) == 0)
              break;

            tmp_post_14 = cp;
            cp = cp + 1l;
            tv[(signed long int)1].tv_usec = tv[(signed long int)1].tv_usec * (signed long int)10 + (signed long int)((signed int)*tmp_post_14 - 48);
          }
          while((_Bool)1);
          tmp_post_15 = cp;
          cp = cp + 1l;
          if(!((signed int)*tmp_post_15 == 32))
          {
            why = "mtime.usec not delimited";
            break;
          }

          tv[(signed long int)0].tv_sec = (signed long int)0;
          do
          {
            return_value___ctype_b_loc_16=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)*cp]) == 0)
              break;

            tmp_post_17 = cp;
            cp = cp + 1l;
            tv[(signed long int)0].tv_sec = tv[(signed long int)0].tv_sec * (signed long int)10 + (signed long int)((signed int)*tmp_post_17 - 48);
          }
          while((_Bool)1);
          tmp_post_18 = cp;
          cp = cp + 1l;
          if(!((signed int)*tmp_post_18 == 32))
          {
            why = "atime.sec not delimited";
            break;
          }

          tv[(signed long int)0].tv_usec = (signed long int)0;
          do
          {
            return_value___ctype_b_loc_19=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_19)[(signed long int)(signed int)*cp]) == 0)
              break;

            tmp_post_20 = cp;
            cp = cp + 1l;
            tv[(signed long int)0].tv_usec = tv[(signed long int)0].tv_usec * (signed long int)10 + (signed long int)((signed int)*tmp_post_20 - 48);
          }
          while((_Bool)1);
          tmp_post_21 = cp;
          cp = cp + 1l;
          if(!((signed int)*tmp_post_21 == 0))
          {
            why = "atime.usec not delimited";
            break;
          }

          write(svr->outfd, (const void *)"", (unsigned long int)1);
          continue;
        }

        if(!((signed int)*cp == 67))
        {
          if(!((signed int)*cp == 68))
          {
            why = "expected control record";
            break;
          }

        }

        mode = 0;
        cp = cp + 1l;
        for( ; !(cp >= buf + 5l); cp = cp + 1l)
        {
          if(!((signed int)*cp >= 48))
            tmp_if_expr_22 = (_Bool)1;

          else
            tmp_if_expr_22 = (signed int)*cp > 55 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_22)
          {
            why = "bad mode";
            goto screwup;
          }

          mode = mode << 3 | (signed int)*cp - 48;
        }
        tmp_post_23 = cp;
        cp = cp + 1l;
        if(!((signed int)*tmp_post_23 == 32))
        {
          why = "mode not delimited";
          break;
        }

        size = (signed long int)0;
        do
        {
          return_value___ctype_b_loc_24=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_24)[(signed long int)(signed int)*cp]) == 0)
            break;

          tmp_post_25 = cp;
          cp = cp + 1l;
          size = size * (signed long int)10 + (signed long int)((signed int)*tmp_post_25 - 48);
        }
        while((_Bool)1);
        tmp_post_26 = cp;
        cp = cp + 1l;
        if(!((signed int)*tmp_post_26 == 32))
        {
          why = "size not delimited";
          break;
        }

        if(!(targisdir == 0))
        {
          signed int need;
          unsigned long int return_value_strlen_27;
          return_value_strlen_27=strlen(targ);
          unsigned long int return_value_strlen_28;
          return_value_strlen_28=strlen(cp);
          need = (signed int)(return_value_strlen_27 + return_value_strlen_28 + (unsigned long int)250);
          if(!(cursize >= need))
          {
            if(!(namebuf == ((char *)NULL)))
              free((void *)namebuf);

            void *return_value_malloc_29;
            return_value_malloc_29=malloc((unsigned long int)need);
            namebuf = (char *)return_value_malloc_29;
            if(namebuf == ((char *)NULL))
            {
              _error(svr, "out of memory\n");
              cursize = 0;
              continue;
            }

            cursize = need;
          }

          snprintf(namebuf, (unsigned long int)cursize, "%s%s%s", targ, *targ != 0 ? "/" : "", cp);
          np = namebuf;
        }

        else
          np = targ;
        signed int return_value_stat_30;
        return_value_stat_30=stat(np, &stb);
        exists = (signed int)(return_value_stat_30 == 0);
        if((signed int)*buf == 68)
        {
          if(!(exists == 0))
          {
            if(!((61440u & stb.st_mode) == 16384u))
            {
              signed int *return_value___errno_location_31;
              return_value___errno_location_31=__errno_location();
              *return_value___errno_location_31 = 20;
              goto bad;
            }

            if(!(svr->preserve == /*enum*/false))
              chmod(np, (unsigned int)mode);

          }

          else
          {
            return_value_mkdir_32=mkdir(np, (unsigned int)mode);
            if(!(return_value_mkdir_32 >= 0))
              goto bad;

          }
          _sink(svr, np, bufp);
          if(!(setimes == 0))
          {
            setimes = 0;
            signed int return_value_utimes_33;
            return_value_utimes_33=utimes(np, tv);
            if(!(return_value_utimes_33 >= 0))
              _error(svr, "can't set times on %s: %m\n", np);

          }

          continue;
        }

        ofd=open(np, 01 | 0100, mode);
        if(!(ofd >= 0))
        {

        bad:
          ;
          _error(svr, "%s: %m\n", np);
        }

        else
        {
          if(!(exists == 0))
          {
            if(!(svr->preserve == /*enum*/false))
              fchmod(ofd, (unsigned int)mode);

          }

          write(svr->outfd, (const void *)"", (unsigned long int)1);
          bp=_allocbuf(svr, bufp, ofd, 8192);
          if(bp == ((struct _buf *)NULL))
            close(ofd);

          else
          {
            cp = bp->buf;
            count = 0;
            wrerr = (enum anonymous_4)NO;
            i = (signed long int)0;
            for( ; !(i >= size); i = i + (signed long int)8192)
            {
              amt = 8192;
              if(!(size >= i + (signed long int)amt))
                amt = (signed int)(size - i);

              count = count + amt;
              do
              {
                j=read(svr->infd, (void *)cp, (unsigned long int)amt);
                if(!(j >= 1l))
                {
                  _error(svr, "%m\n");
                  goto end_server;
                }

                amt = amt - (signed int)j;
                cp = cp + j;
              }
              while(amt >= 1);
              if(count == bp->cnt)
              {
                if((signed int)wrerr == NO)
                {
                  return_value_write_34=write(ofd, (const void *)bp->buf, (unsigned long int)count);
                  if(!(return_value_write_34 == (signed long int)count))
                    wrerr = (enum anonymous_4)YES;

                }

                count = 0;
                cp = bp->buf;
              }

            }
            if((signed int)wrerr == NO && !(count == 0))
            {
              return_value_write_35=write(ofd, (const void *)bp->buf, (unsigned long int)count);
              if(!(return_value_write_35 == (signed long int)count))
                wrerr = (enum anonymous_4)YES;

            }

            signed int return_value_ftruncate_36;
            return_value_ftruncate_36=ftruncate(ofd, size);
            if(!(return_value_ftruncate_36 == 0))
            {
              _error(svr, "can't truncate %s: %m\n", np);
              wrerr = (enum anonymous_4)DISPLAYED;
            }

            close(ofd);
            signed int return_value__response_37;
            return_value__response_37=_response(svr);
            if(!(return_value__response_37 >= 0))
              goto end_server;

            if((signed int)wrerr == NO && !(setimes == 0))
            {
              setimes = 0;
              signed int return_value_utimes_38;
              return_value_utimes_38=utimes(np, tv);
              if(!(return_value_utimes_38 >= 0))
              {
                _error(svr, "can't set times on %s: %m\n", np);
                wrerr = (enum anonymous_4)DISPLAYED;
              }

            }

            switch((signed int)wrerr)
            {
              case YES:
              {
                _error(svr, "%s: %m\n", np);
                goto __CPROVER_DUMP_L65;
              }
              case NO:
                write(svr->outfd, (const void *)"", (unsigned long int)1);
              case DISPLAYED:

              default:

                __CPROVER_DUMP_L65:
                  ;
            }
          }
        }
      }
    }

  screwup:
    ;
    _error(svr, "protocol screwup: %s\n", why);

  end_server:
    ;
    if(!(buf == ((char *)NULL)))
      free((void *)buf);

    if(!(namebuf == ((char *)NULL)))
      free((void *)namebuf);

    goto __CPROVER_DUMP_L71;
  }

__CPROVER_DUMP_L71:
  ;
}

// _strcatchar
// file xstring.c line 126
static void _strcatchar(char *str, char c)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  len = (signed int)return_value_strlen_1;
  signed int tmp_post_2 = len;
  len = len + 1;
  str[(signed long int)tmp_post_2] = c;
  str[(signed long int)len] = (char)0;
}

// _test_pipecmd
// file testcase.c line 91
static enum anonymous_6 _test_pipecmd(void)
{
  const char expected[27l] = { 'h', 'o', 's', 't', '=', 'f', 'o', 'o', '0', ' ', 'u', 's', 'e', 'r', '=', 'f', 'o', 'o', 'u', 's', 'e', 'r', ' ', 'n', '=', '0', 0 };
  const char *args[4l] = { "host=%h", "user=%u", "n=%n", (const char *)(void *)0 };
  signed int n;
  char buf[1024l];
  struct pipe_info_struct *p;
  p=pipecmd("/bin/echo", args, "foo0", "foouser", 0);
  if(p == ((struct pipe_info_struct *)NULL))
    return (enum anonymous_6)FAIL;

  else
  {
    signed int return_value_pipecmd_stdoutfd_1;
    return_value_pipecmd_stdoutfd_1=pipecmd_stdoutfd(p);
    signed long int return_value_fd_read_n_2;
    return_value_fd_read_n_2=fd_read_n(return_value_pipecmd_stdoutfd_1, (void *)buf, sizeof(char [1024l]) /*1024ul*/ );
    n = (signed int)return_value_fd_read_n_2;
    if(!(n >= 0))
      return (enum anonymous_6)FAIL;

    else
    {
      buf[(signed long int)(n - 1)] = (char)0;
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(expected, buf);
      if(!(return_value_strcmp_3 == 0))
      {
        err("testcase: pipecmd: expected \"%s\" got \"%s\"\n", (const void *)expected, (const void *)buf);
        return (enum anonymous_6)FAIL;
      }

      else
      {
        pipecmd_wait(p, (signed int *)(void *)0);
        pipecmd_destroy(p);
        return (enum anonymous_6)PASS;
      }
    }
  }
}

// _test_xstrerrorcat
// file testcase.c line 71
static enum anonymous_6 _test_xstrerrorcat(void)
{
  signed int e;
  enum anonymous_6 result = (enum anonymous_6)PASS;
  e = 1;
  for( ; !(e >= 100); e = e + 1)
  {
    char *s1 = (char *)(void *)0;
    char *s2;
    s2=strerror(e);
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = e;
    xstrerrorcat(&s1);
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(s1, s2);
    if(!(return_value_strcmp_2 == 0))
    {
      err("xsterrorcat (errno=%d) = \"%s\" (should be \"%s\")\n", e, s1, s2);
      result = (enum anonymous_6)FAIL;
    }

    Free((void **)&s1);
  }
  return result;
}

// _testmsg
// file testcase.c line 65
static void _testmsg(signed int testnum, enum anonymous_6 result)
{
  out("%P: Test %d: %s: %s\n", testnum, testcases[(signed long int)testnum].desc, (signed int)result == PASS ? "PASS" : "FAIL");
}

// _thd_command_timeout
// file dsh.c line 282
static signed int _thd_command_timeout(struct thd *t)
{
  if(command_timeout >= 1)
  {
    if(!(t->connect == -1l))
    {
      signed long int return_value_time_1;
      return_value_time_1=time((signed long int *)(void *)0);
      if(!(t->connect + (signed long int)command_timeout >= return_value_time_1))
        return 1;

    }

  }

  return 0;
}

// _thd_connect_timeout
// file dsh.c line 273
static signed int _thd_connect_timeout(struct thd *t)
{
  if(connect_timeout >= 1)
  {
    if(!(t->start == -1l))
    {
      signed long int return_value_time_1;
      return_value_time_1=time((signed long int *)(void *)0);
      if(!(t->start + (signed long int)connect_timeout >= return_value_time_1))
        return 1;

    }

  }

  return 0;
}

// _thd_init
// file dsh.c line 849
static signed int _thd_init(struct thd *th, struct anonymous_1 *opt, struct list *pcp_infiles, signed int i)
{
  th->luser = opt->luser;
  th->ruser = opt->ruser;
  th->state = (enum anonymous_8)DSH_NEW;
  th->labels = opt->labels;
  th->nodeid = i;
  th->cmd = opt->cmd;
  th->dsh_sopt = opt->separate_stderr;
  th->rc = 0;
  th->pcp_infiles = pcp_infiles;
  th->pcp_outfile = opt->outfile_name;
  th->pcp_popt = opt->preserve;
  th->pcp_ropt = opt->recursive;
  th->pcp_yopt = opt->target_is_directory;
  th->pcp_Popt = opt->reverse_copy;
  th->pcp_Zopt = opt->pcp_client;
  th->pcp_progname = opt->progname;
  th->outfile_name = opt->outfile_name;
  th->kill_on_fail = opt->kill_on_fail;
  th->outbuf=cbuf_create(64, 131072);
  th->errbuf=cbuf_create(64, 131072);
  th->rcmd=rcmd_create(th->host);
  if(th->rcmd == ((struct rcmd_info *)NULL))
  {
    th->state = (enum anonymous_8)DSH_CANCELED;
    return -1;
  }

  else
  {
    if(!(th->rcmd->opts->resolve_hosts == /*enum*/false))
      _gethost(th->host, th->addr);

    return 0;
  }
}

// _update_connect_state
// file dsh.c line 349
static enum anonymous_8 _update_connect_state(struct thd *a)
{
  do
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1=pthread_mutex_lock(&thd_mutex);
    if(!(*return_value___errno_location_1 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 351);

  }
  while((_Bool)0);
  a->connect=time((signed long int *)(void *)0);
  if(!((signed int)a->state == DSH_CANCELED))
    a->state = (enum anonymous_8)DSH_READING;

  do
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2=pthread_mutex_unlock(&thd_mutex);
    if(!(*return_value___errno_location_2 == 0))
      errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 355);

  }
  while((_Bool)0);
  if((signed int)a->state == DSH_CANCELED)
  {
    if(a->rcmd->fd >= 0)
      close(a->rcmd->fd);

    if(a->rcmd->efd >= 0)
      close(a->rcmd->efd);

  }

  return a->state;
}

// _usage
// file opt.c line 1118
static void _usage(struct anonymous_1 *opt)
{
  char buf[1024l];
  if((signed int)personality == DSH)
    err("Usage: pdsh [-options] command ...\n-S                return largest of remote command return values\n");

  else
    if(opt->reverse_copy == /*enum*/false)
      err("Usage: pdcp [-options] src [src2...] dest\n-r                recursively copy files\n-p                preserve modification time and modes\n-e PATH           specify the path to pdcp on the remote machine\n");

    else
      err("Usage: rpdcp [-options] src [src2...] dir\n-r                recursively copy files\n-p                preserve modification time and modes\n");
  err("-h                output usage menu and quit\n-V                output version information and quit\n-q                list the option settings and quit\n-b                disable ^C status feature (batch mode)\n-d                enable extra debug information from ^C status\n-l user           execute remote commands as user\n-t seconds        set connect timeout (default is 10 sec)\n-u seconds        set command timeout (no default)\n-f n              use fanout of n nodes\n-w host,host,...  set target node list on command line\n-x host,host,...  set node exclusion list on command line\n-R name           set rcmd module to name\n-M name,...       select one or more misc modules to initialize first\n-N                disable hostname: labels on output lines\n-L                list info on all loaded modules and exit\n");
  mod_print_all_options(18);
  char *return_value__rcmd_module_list_1;
  return_value__rcmd_module_list_1=_rcmd_module_list(buf, 1024);
  err("available rcmd modules: %s\n", return_value__rcmd_module_list_1);
  exit(1);
}

// _verifydir
// file pcp_server.c line 128
static signed int _verifydir(struct pcp_server *s, const char *cp)
{
  struct stat stb;
  signed int return_value_stat_2;
  return_value_stat_2=stat(cp, &stb);
  if(return_value_stat_2 >= 0)
  {
    if((61440u & stb.st_mode) == 16384u)
      return 0;

    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 20;
  }

  _error(s, "%s not a directory\n", cp);
  return -1;
}

// _verr
// file err.c line 101
static void _verr(struct _IO_FILE *stream, char *format, __builtin_va_list ap)
{
  char *buf = (char *)(void *)0;
  char *q;
  signed int percent = 0;
  char tmpstr[2048l];
  for( ; !(format == ((char *)NULL)); format = format + 1l)
  {
    if(*format == 0)
      break;

    if(percent == 1)
    {
      percent = 0;
      if((signed int)*format == 115)
      {
        char *return_value_gcc_builtin_va_arg_1;
        return_value_gcc_builtin_va_arg_1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_1));
        xstrcat(&buf, return_value_gcc_builtin_va_arg_1);
      }

      else
        if((signed int)*format == 83)
        {
          char *return_value_gcc_builtin_va_arg_2;
          return_value_gcc_builtin_va_arg_2=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_2));
          snprintf(tmpstr, sizeof(char [2048l]) /*2048ul*/ , "%s", return_value_gcc_builtin_va_arg_2);
          const unsigned short int **return_value___ctype_b_loc_3;
          return_value___ctype_b_loc_3=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)tmpstr[0l]]) == 0)
          {
            if(keep_host_domain == /*enum*/false)
            {
              q=strchr(tmpstr, 46);
              if(!(q == ((char *)NULL)))
                *q = (char)0;

            }

          }

          xstrcat(&buf, tmpstr);
        }

        else
          if((signed int)*format == 122)
          {
            signed int return_value_gcc_builtin_va_arg_4;
            return_value_gcc_builtin_va_arg_4=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_4));
            snprintf(tmpstr, sizeof(char [2048l]) /*2048ul*/ , "%.3d", return_value_gcc_builtin_va_arg_4);
            xstrcat(&buf, tmpstr);
          }

          else
            if((signed int)*format == 99)
            {
              signed int return_value_gcc_builtin_va_arg_5;
              return_value_gcc_builtin_va_arg_5=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_5));
              xstrcatchar(&buf, (char)return_value_gcc_builtin_va_arg_5);
            }

            else
              if((signed int)*format == 100)
              {
                signed int return_value_gcc_builtin_va_arg_6;
                return_value_gcc_builtin_va_arg_6=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_6));
                snprintf(tmpstr, sizeof(char [2048l]) /*2048ul*/ , "%d", return_value_gcc_builtin_va_arg_6);
                xstrcat(&buf, tmpstr);
              }

              else
                if((signed int)*format == 109)
                  xstrerrorcat(&buf);

                else
                  if((signed int)*format == 80)
                    xstrcat(&buf, prog);

                  else
                    if((signed int)*format == 72)
                      xstrcat(&buf, host);

                    else
                      if((signed int)*format == 112)
                      {
                        snprintf(tmpstr, sizeof(char [2048l]) /*2048ul*/ , "%s@%s", prog, host);
                        xstrcat(&buf, tmpstr);
                      }

                      else
                        xstrcatchar(&buf, *format);
    }

    else
      if((signed int)*format == 37)
        percent = 1;

      else
        xstrcatchar(&buf, *format);
  }
  fputs(buf, stream);
  Free((void **)&buf);
}

// _wdog
// file dsh.c line 297
static void * _wdog(void *args)
{
  signed int i;
  signed int return_value__thd_connect_timeout_1;
  signed int return_value__thd_command_timeout_2;
  while((_Bool)1)
  {
    if(t == ((struct thd *)NULL))
      return (void *)0;

    i = 0;
    while(!((t + (signed long int)i)->host == ((char *)NULL)))
      switch((signed int)(t + (signed long int)i)->state)
      {
        case DSH_RCMD:
        {
          return_value__thd_connect_timeout_1=_thd_connect_timeout(&t[(signed long int)i]);
          if(!(return_value__thd_connect_timeout_1 == 0))
            pthread_kill((t + (signed long int)i)->thread, 14);

          goto __CPROVER_DUMP_L9;
        }
        case DSH_READING:
        {
          return_value__thd_command_timeout_2=_thd_command_timeout(&t[(signed long int)i]);
          if(!(return_value__thd_command_timeout_2 == 0))
            pthread_kill((t + (signed long int)i)->thread, 14);

          goto __CPROVER_DUMP_L9;
        }
        case DSH_NEW:

        case DSH_DONE:

        case DSH_FAILED:

        case DSH_CANCELED:
          ;
        default:
        {

        __CPROVER_DUMP_L9:
          ;
          i = i + 1;
        }
      }
    sleep((unsigned int)2);
  }
  return (void *)0;
}

// _width_equiv
// file hostlist.c line 419
static signed int _width_equiv(unsigned long int n, signed int *wn, unsigned long int m, signed int *wm)
{
  signed int npad;
  signed int nmpad;
  signed int mpad;
  signed int mnpad;
  if(wn == wm)
    return 1;

  else
  {
    npad=_zero_padded(n, *wn);
    nmpad=_zero_padded(n, *wm);
    mpad=_zero_padded(m, *wm);
    mnpad=_zero_padded(m, *wn);
    if(!(mpad == mnpad) && !(npad == nmpad))
      return 0;

    else
      if(!(npad == nmpad))
      {
        if(mpad == mnpad)
        {
          *wm = *wn;
          return 1;
        }

        else
          return 0;
      }

      else
        if(npad == nmpad)
        {
          *wn = *wm;
          return 1;
        }

        else
          return 0;
  }
}

// _xsignal
// file dsh.c line 166
static void (*_xsignal(signed int signal, void (*handler)(signed int)))(signed int)
{
  struct sigaction sa;
  struct sigaction old_sa;
  sa.__sigaction_handler.sa_handler = handler;
  sigemptyset(&sa.sa_mask);
  sigaddset(&sa.sa_mask, signal);
  sa.sa_flags = 0;
  sigaction(signal, &sa, &old_sa);
  return (void (*)(signed int))old_sa.__sigaction_handler.sa_handler;
}

// _zero_padded
// file hostlist.c line 398
static signed int _zero_padded(unsigned long int num, signed int width)
{
  signed int n = 1;
  do
  {
    num = num / (unsigned long int)10L;
    if(num == 0ul)
      break;

    n = n + 1;
  }
  while((_Bool)1);
  return width > n ? width - n : 0;
}

// cbuf_copier
// file cbuf.c line 1337
static signed int cbuf_copier(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped)
{
  signed int ncopy;
  signed int nfree;
  signed int nleft;
  signed int nrepl;
  signed int n;
  signed int i_src;
  signed int i_dst;
  signed int tmp_if_expr_1;
  if(src->used >= len)
    tmp_if_expr_1 = len;

  else
    tmp_if_expr_1 = src->used;
  len = tmp_if_expr_1;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  if(len == 0)
    return 0;

  else
  {
    nfree = dst->size - dst->used;
    if(!(nfree >= len))
    {
      if(!(dst->size >= dst->maxsize))
      {
        signed int return_value_cbuf_grow_2;
        return_value_cbuf_grow_2=cbuf_grow(dst, len - nfree);
        nfree = nfree + return_value_cbuf_grow_2;
      }

    }

    if((signed int)dst->overwrite == CBUF_NO_DROP)
    {
      if(dst->size + -dst->used >= len)
        tmp_if_expr_3 = len;

      else
        tmp_if_expr_3 = dst->size - dst->used;
      len = tmp_if_expr_3;
      if(len == 0)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 28;
        return -1;
      }

    }

    else
      if((signed int)dst->overwrite == CBUF_WRAP_ONCE)
      {
        if(dst->size >= len)
          tmp_if_expr_5 = len;

        else
          tmp_if_expr_5 = dst->size;
        len = tmp_if_expr_5;
      }

    if(!(ndropped == ((signed int *)NULL)))
    {
      if(!(dst->used + len + -dst->size >= 1))
        tmp_if_expr_6 = 0;

      else
        tmp_if_expr_6 = (len - dst->size) + dst->used;
      *ndropped = tmp_if_expr_6;
    }

    ncopy = len;
    i_src = src->i_out;
    i_dst = dst->i_in;
    if(!(dst->size >= ncopy))
    {
      n = ncopy - dst->size;
      i_src = (i_src + n) % (src->size + 1);
      ncopy = ncopy - n;
    }

    nleft = ncopy;
    for( ; nleft >= 1; nleft = nleft - n)
    {
      if(1 + dst->size + -i_dst >= 1 + src->size + -i_src)
        tmp_if_expr_7 = (src->size + 1) - i_src;

      else
        tmp_if_expr_7 = (dst->size + 1) - i_dst;
      n = tmp_if_expr_7;
      n = n <= nleft ? n : nleft;
      memcpy((void *)&dst->data[(signed long int)i_dst], (const void *)&src->data[(signed long int)i_src], (unsigned long int)n);
      i_src = (i_src + n) % (src->size + 1);
      i_dst = (i_dst + n) % (dst->size + 1);
    }
    if(ncopy >= 1)
    {
      nrepl = ((dst->i_out - dst->i_rep) + dst->size + 1) % (dst->size + 1);
      if(dst->size >= dst->used + ncopy)
        tmp_if_expr_8 = dst->used + ncopy;

      else
        tmp_if_expr_8 = dst->size;
      dst->used = tmp_if_expr_8;
      dst->i_in = i_dst;
      if(!(nfree + -nrepl >= ncopy))
      {
        dst->got_wrap = 1;
        dst->i_rep = (dst->i_in + 1) % (dst->size + 1);
      }

      if(!(nfree >= ncopy))
        dst->i_out = dst->i_rep;

    }

    return len;
  }
}

// cbuf_copy
// file cbuf.c line 1007
signed int cbuf_copy(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped)
{
  signed int n = 0;
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = 0;

  if(src == dst)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(len >= -1))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    if(!(src >= dst))
    {
      do
      {
        signed int cbuf_copy__1__5__1__e;
        cbuf_copy__1__5__1__e=pthread_mutex_lock(&src->mutex);
        if(!(cbuf_copy__1__5__1__e == 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = cbuf_copy__1__5__1__e;
          lsd_fatal_error("cbuf.c", 1031, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
      do
      {
        signed int e;
        e=pthread_mutex_lock(&dst->mutex);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = e;
          lsd_fatal_error("cbuf.c", 1032, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
    }

    else
    {
      do
      {
        signed int cbuf_copy__1__6__1__e;
        cbuf_copy__1__6__1__e=pthread_mutex_lock(&dst->mutex);
        if(!(cbuf_copy__1__6__1__e == 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = cbuf_copy__1__6__1__e;
          lsd_fatal_error("cbuf.c", 1035, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
      do
      {
        signed int cbuf_copy__1__6__2__e;
        cbuf_copy__1__6__2__e=pthread_mutex_lock(&src->mutex);
        if(!(cbuf_copy__1__6__2__e == 0))
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = cbuf_copy__1__6__2__e;
          lsd_fatal_error("cbuf.c", 1036, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
    }
    if(len == -1)
      len = src->used;

    if(len >= 1)
      n=cbuf_copier(src, dst, len, ndropped);

    do
    {
      signed int cbuf_copy__1__9__e;
      cbuf_copy__1__9__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_copy__1__9__e == 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7 = cbuf_copy__1__9__e;
        lsd_fatal_error("cbuf.c", 1049, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    do
    {
      signed int cbuf_copy__1__10__e;
      cbuf_copy__1__10__e=pthread_mutex_unlock(&dst->mutex);
      if(!(cbuf_copy__1__10__e == 0))
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        *return_value___errno_location_8 = cbuf_copy__1__10__e;
        lsd_fatal_error("cbuf.c", 1050, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_create
// file ../../src/pdsh/cbuf.h line 85
struct cbuf * cbuf_create(signed int minsize, signed int maxsize)
{
  struct cbuf *cb;
  if(!(minsize >= 1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (struct cbuf *)(void *)0;
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct cbuf) /*88ul*/ );
  cb = (struct cbuf *)return_value_malloc_3;
  if(cb == ((struct cbuf *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
    return (struct cbuf *)(void *)0;
  }

  cb->alloc = minsize + 1;
  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)cb->alloc);
  cb->data = (unsigned char *)return_value_malloc_5;
  if(cb->data == ((unsigned char *)NULL))
  {
    free((void *)cb);
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = 12;
    return (struct cbuf *)(void *)0;
  }

  do
  {
    signed int e;
    e=pthread_mutex_init(&cb->mutex, (const union anonymous_3 *)(void *)0);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = e;
      lsd_fatal_error("cbuf.c", 247, "cbuf mutex init");
      abort();
    }

  }
  while((_Bool)0);
  cb->minsize = minsize;
  cb->maxsize = maxsize > minsize ? maxsize : minsize;
  cb->size = minsize;
  cb->used = 0;
  cb->overwrite = (enum anonymous_9)CBUF_WRAP_MANY;
  cb->got_wrap = 0;
  cb->i_rep = 0;
  cb->i_out = cb->i_rep;
  cb->i_in = cb->i_out;
  return cb;
}

// cbuf_destroy
// file ../../src/pdsh/cbuf.h line 95
void cbuf_destroy(struct cbuf *cb)
{
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 284, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  free((void *)cb->data);
  do
  {
    signed int cbuf_destroy__1__2__e;
    cbuf_destroy__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_destroy__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_destroy__1__2__e;
      lsd_fatal_error("cbuf.c", 298, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  do
  {
    signed int cbuf_destroy__1__3__e;
    cbuf_destroy__1__3__e=pthread_mutex_destroy(&cb->mutex);
    if(!(cbuf_destroy__1__3__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = cbuf_destroy__1__3__e;
      lsd_fatal_error("cbuf.c", 299, "cbuf mutex destroy");
      abort();
    }

  }
  while((_Bool)0);
  free((void *)cb);
}

// cbuf_drop
// file cbuf.c line 477
signed int cbuf_drop(struct cbuf *src, signed int len)
{
  if(!(len >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  signed int tmp_if_expr_3;
  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 488, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    if(len == -1)
      len = src->used;

    else
    {
      if(src->used >= len)
        tmp_if_expr_3 = len;

      else
        tmp_if_expr_3 = src->used;
      len = tmp_if_expr_3;
    }
    if(len >= 1)
      cbuf_dropper(src, len);

    do
    {
      signed int cbuf_drop__1__7__e;
      cbuf_drop__1__7__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_drop__1__7__e == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = cbuf_drop__1__7__e;
        lsd_fatal_error("cbuf.c", 501, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return len;
  }
}

// cbuf_drop_line
// file cbuf.c line 639
signed int cbuf_drop_line(struct cbuf *src, signed int len, signed int lines)
{
  signed int n;
  if(!(len >= 0) || !(lines >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(lines == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 652, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_find_unread_line(src, len, &lines);
    if(n >= 1)
      cbuf_dropper(src, n);

    do
    {
      signed int cbuf_drop_line__1__5__e;
      cbuf_drop_line__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_drop_line__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_drop_line__1__5__e;
        lsd_fatal_error("cbuf.c", 660, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_dropper
// file cbuf.c line 1423
static signed int cbuf_dropper(struct cbuf *cb, signed int len)
{
  cb->used = cb->used - len;
  cb->i_out = (cb->i_out + len) % (cb->size + 1);
  if(cb->size + -cb->used >= 1001)
  {
    if(!(cb->minsize >= cb->size))
      cbuf_shrink(cb);

  }

  return len;
}

// cbuf_find_replay_line
// file cbuf.c line 1108
static signed int cbuf_find_replay_line(struct cbuf *cb, signed int chars, signed int *nlines, signed int *nl)
{
  signed int i;
  signed int n;
  signed int m;
  signed int l;
  signed int lines;
  l = 0;
  m = l;
  n = m;
  lines = *nlines;
  *nlines = 0;
  if(!(nl == ((signed int *)NULL)))
    *nl = 0;

  if(lines == 0 || !(lines >= 0) && !(chars >= 1))
    return 0;

  else
    if(cb->i_out == cb->i_rep)
      return 0;

    else
    {
      if(lines >= 1)
        chars = -1;

      else
        chars = chars + 1;
      if(!((signed int)cb->data[(signed long int)((cb->i_out + cb->size) % (1 + cb->size))] == 10))
      {
        if(!(nl == ((signed int *)NULL)))
          *nl = 1;

        chars = chars - 1;
      }

      else
      {
        if(lines >= 1)
          lines = lines + 1;

        l = l - 1;
      }
      i = cb->i_out;
      while(!(i == cb->i_rep))
      {
        i = (i + cb->size) % (cb->size + 1);
        n = n + 1;
        if(chars >= 1)
          chars = chars - 1;

        if((signed int)cb->data[(signed long int)i] == 10)
        {
          if(lines >= 1)
            lines = lines - 1;

          m = n - 1;
          l = l + 1;
        }

        if(lines == 0 || chars == 0)
          break;

      }
      if(cb->got_wrap == 0)
      {
        if(lines >= 1 || chars >= 1)
        {
          if(lines >= 1)
            lines = lines - 1;

          m = n;
          l = l + 1;
        }

      }

      if(lines >= 1)
        return 0;

      else
      {
        *nlines = l;
        return m;
      }
    }
}

// cbuf_find_unread_line
// file cbuf.c line 1203
static signed int cbuf_find_unread_line(struct cbuf *cb, signed int chars, signed int *nlines)
{
  signed int i;
  signed int n;
  signed int m;
  signed int l;
  signed int lines;
  l = 0;
  m = l;
  n = m;
  lines = *nlines;
  *nlines = 0;
  if(lines == 0 || !(lines >= 0) && !(chars >= 1))
    return 0;

  else
    if(cb->used == 0)
      return 0;

    else
    {
      if(lines >= 1)
        chars = -1;

      i = cb->i_out;
      for( ; !(i == cb->i_in); i = (i + 1) % (cb->size + 1))
      {
        n = n + 1;
        if(chars >= 1)
          chars = chars - 1;

        if((signed int)cb->data[(signed long int)i] == 10)
        {
          if(lines >= 1)
            lines = lines - 1;

          m = n;
          l = l + 1;
        }

        if(lines == 0 || chars == 0)
          break;

      }
      if(lines >= 1)
        return 0;

      else
      {
        *nlines = l;
        return m;
      }
    }
}

// cbuf_flush
// file cbuf.c line 306
void cbuf_flush(struct cbuf *cb)
{
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 309, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  cb->used = 0;
  cb->got_wrap = 0;
  cb->i_rep = 0;
  cb->i_out = cb->i_rep;
  cb->i_in = cb->i_out;
  do
  {
    signed int cbuf_flush__1__2__e;
    cbuf_flush__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_flush__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_flush__1__2__e;
      lsd_fatal_error("cbuf.c", 318, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
}

// cbuf_free
// file cbuf.c line 338
signed int cbuf_free(struct cbuf *cb)
{
  signed int nfree;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 343, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  nfree = cb->size - cb->used;
  do
  {
    signed int cbuf_free__1__2__e;
    cbuf_free__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_free__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_free__1__2__e;
      lsd_fatal_error("cbuf.c", 346, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return nfree;
}

// cbuf_get_fd
// file cbuf.c line 1261
static signed int cbuf_get_fd(void *dstbuf, signed int *psrcfd, signed int len)
{
  signed int n;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    signed long int return_value_read_3;
    return_value_read_3=read(*psrcfd, dstbuf, (unsigned long int)len);
    n = (signed int)return_value_read_3;
    if(!(n >= 0))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return n;
}

// cbuf_get_mem
// file cbuf.c line 1282
static signed int cbuf_get_mem(void *dstbuf, unsigned char **psrcbuf, signed int len)
{
  memcpy(dstbuf, (const void *)*psrcbuf, (unsigned long int)len);
  *psrcbuf = *psrcbuf + (signed long int)len;
  return len;
}

// cbuf_grow
// file cbuf.c line 1649
static signed int cbuf_grow(struct cbuf *cb, signed int n)
{
  unsigned char *data;
  signed int size_old;
  signed int size_meta;
  signed int m;
  signed int tmp_if_expr_1;
  if(cb->size == cb->maxsize)
    return 0;

  else
  {
    size_old = cb->size;
    size_meta = cb->alloc - cb->size;
    m = cb->alloc + n;
    m = m + (1000 - m % 1000);
    if(cb->maxsize + size_meta >= m)
      tmp_if_expr_1 = m;

    else
      tmp_if_expr_1 = cb->maxsize + size_meta;
    m = tmp_if_expr_1;
    data = cb->data;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)data, (unsigned long int)m);
    data = (unsigned char *)return_value_realloc_2;
    if(data == ((unsigned char *)NULL))
      return 0;

    else
    {
      cb->data = data;
      cb->alloc = m;
      cb->size = m - size_meta;
      if(!(cb->i_in >= cb->i_rep))
      {
        n = (size_old + 1) - cb->i_rep;
        m = (cb->size + 1) - n;
        memmove((void *)(cb->data + (signed long int)m), (const void *)(cb->data + (signed long int)cb->i_rep), (unsigned long int)n);
        if(cb->i_out >= cb->i_rep)
          cb->i_out = cb->i_out + (m - cb->i_rep);

        cb->i_rep = m;
      }

      return cb->size - size_old;
    }
  }
}

// cbuf_is_empty
// file cbuf.c line 408
signed int cbuf_is_empty(struct cbuf *cb)
{
  signed int used;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 413, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  used = cb->used;
  do
  {
    signed int cbuf_is_empty__1__2__e;
    cbuf_is_empty__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_is_empty__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_is_empty__1__2__e;
      lsd_fatal_error("cbuf.c", 416, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return (signed int)(used == 0);
}

// cbuf_lines_reused
// file cbuf.c line 394
signed int cbuf_lines_reused(struct cbuf *cb)
{
  signed int lines = -1;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 399, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  cbuf_find_replay_line(cb, cb->size, &lines, (signed int *)(void *)0);
  do
  {
    signed int cbuf_lines_reused__1__2__e;
    cbuf_lines_reused__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_lines_reused__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_lines_reused__1__2__e;
      lsd_fatal_error("cbuf.c", 402, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return lines;
}

// cbuf_lines_used
// file cbuf.c line 366
signed int cbuf_lines_used(struct cbuf *cb)
{
  signed int lines = -1;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 371, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  cbuf_find_unread_line(cb, cb->size, &lines);
  do
  {
    signed int cbuf_lines_used__1__2__e;
    cbuf_lines_used__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_lines_used__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_lines_used__1__2__e;
      lsd_fatal_error("cbuf.c", 374, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return lines;
}

// cbuf_move
// file cbuf.c line 1056
signed int cbuf_move(struct cbuf *src, struct cbuf *dst, signed int len, signed int *ndropped)
{
  signed int n = 0;
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = 0;

  if(src == dst)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(!(len >= -1))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    if(!(src >= dst))
    {
      do
      {
        signed int e;
        e=pthread_mutex_lock(&src->mutex);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = e;
          lsd_fatal_error("cbuf.c", 1080, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
      do
      {
        signed int cbuf_move__1__5__2__e;
        cbuf_move__1__5__2__e=pthread_mutex_lock(&dst->mutex);
        if(!(cbuf_move__1__5__2__e == 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = cbuf_move__1__5__2__e;
          lsd_fatal_error("cbuf.c", 1081, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
    }

    else
    {
      do
      {
        signed int cbuf_move__1__6__1__e;
        cbuf_move__1__6__1__e=pthread_mutex_lock(&dst->mutex);
        if(!(cbuf_move__1__6__1__e == 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = cbuf_move__1__6__1__e;
          lsd_fatal_error("cbuf.c", 1084, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
      do
      {
        signed int cbuf_move__1__6__2__e;
        cbuf_move__1__6__2__e=pthread_mutex_lock(&src->mutex);
        if(!(cbuf_move__1__6__2__e == 0))
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = cbuf_move__1__6__2__e;
          lsd_fatal_error("cbuf.c", 1085, "cbuf mutex lock");
          abort();
        }

      }
      while((_Bool)0);
    }
    if(len == -1)
      len = src->used;

    if(len >= 1)
    {
      n=cbuf_copier(src, dst, len, ndropped);
      if(n >= 1)
        cbuf_dropper(src, n);

    }

    do
    {
      signed int cbuf_move__1__9__e;
      cbuf_move__1__9__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_move__1__9__e == 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7 = cbuf_move__1__9__e;
        lsd_fatal_error("cbuf.c", 1101, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    do
    {
      signed int cbuf_move__1__10__e;
      cbuf_move__1__10__e=pthread_mutex_unlock(&dst->mutex);
      if(!(cbuf_move__1__10__e == 0))
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        *return_value___errno_location_8 = cbuf_move__1__10__e;
        lsd_fatal_error("cbuf.c", 1102, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_opt_get
// file cbuf.c line 422
signed int cbuf_opt_get(struct cbuf *cb, enum anonymous_10 name, signed int *value)
{
  signed int rc = 0;
  if(value == ((signed int *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("cbuf.c", 432, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if((signed int)name == CBUF_OPT_OVERWRITE)
    *value = (signed int)cb->overwrite;

  else
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 22;
    rc = -1;
  }
  do
  {
    signed int cbuf_opt_get__1__5__e;
    cbuf_opt_get__1__5__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_opt_get__1__5__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = cbuf_opt_get__1__5__e;
      lsd_fatal_error("cbuf.c", 441, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return rc;
}

// cbuf_opt_set
// file cbuf.c line 447
signed int cbuf_opt_set(struct cbuf *cb, enum anonymous_10 name, signed int value)
{
  signed int rc = 0;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 453, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if((signed int)name == CBUF_OPT_OVERWRITE)
  {
    if(value == CBUF_NO_DROP || value == CBUF_WRAP_ONCE || value == CBUF_WRAP_MANY)
      cb->overwrite = (enum anonymous_9)value;

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 22;
      rc = -1;
    }
  }

  else
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 22;
    rc = -1;
  }
  do
  {
    signed int cbuf_opt_set__1__4__e;
    cbuf_opt_set__1__4__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_opt_set__1__4__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = cbuf_opt_set__1__4__e;
      lsd_fatal_error("cbuf.c", 471, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return rc;
}

// cbuf_peek
// file cbuf.c line 507
signed int cbuf_peek(struct cbuf *src, void *dstbuf, signed int len)
{
  signed int n;
  if(dstbuf == NULL || !(len >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 520, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_reader(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&dstbuf);
    do
    {
      signed int cbuf_peek__1__4__e;
      cbuf_peek__1__4__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_peek__1__4__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_peek__1__4__e;
        lsd_fatal_error("cbuf.c", 524, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_peek_line
// file ../../src/pdsh/cbuf.h line 208
signed int cbuf_peek_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines)
{
  signed int n;
  signed int m;
  signed int l;
  char *pdst;
  if(dstbuf == ((char *)NULL) || !(len >= 0) || !(lines >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(lines == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 680, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_find_unread_line(src, len - 1, &lines);
    if(n >= 1)
    {
      if(len >= 1)
      {
        m = n <= len - 1 ? n : len - 1;
        if(m >= 1)
        {
          pdst = dstbuf;
          l=cbuf_reader(src, m, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&pdst);
        }

        dstbuf[(signed long int)m] = (char)0;
      }

    }

    do
    {
      signed int cbuf_peek_line__1__5__e;
      cbuf_peek_line__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_peek_line__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_peek_line__1__5__e;
        lsd_fatal_error("cbuf.c", 696, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_peek_to_fd
// file cbuf.c line 893
signed int cbuf_peek_to_fd(struct cbuf *src, signed int dstfd, signed int len)
{
  signed int n = 0;
  if(!(dstfd >= 0) || !(len >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  do
  {
    signed int e;
    e=pthread_mutex_lock(&src->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("cbuf.c", 903, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(len == -1)
    len = src->used;

  if(len >= 1)
    n=cbuf_reader(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_fd, (void *)&dstfd);

  do
  {
    signed int cbuf_peek_to_fd__1__5__e;
    cbuf_peek_to_fd__1__5__e=pthread_mutex_unlock(&src->mutex);
    if(!(cbuf_peek_to_fd__1__5__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = cbuf_peek_to_fd__1__5__e;
      lsd_fatal_error("cbuf.c", 912, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// cbuf_put_fd
// file cbuf.c line 1299
static signed int cbuf_put_fd(void *srcbuf, signed int *pdstfd, signed int len)
{
  signed int n;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    signed long int return_value_write_3;
    return_value_write_3=write(*pdstfd, srcbuf, (unsigned long int)len);
    n = (signed int)return_value_write_3;
    if(!(n >= 0))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return n;
}

// cbuf_put_mem
// file cbuf.c line 1320
static signed int cbuf_put_mem(void *srcbuf, unsigned char **pdstbuf, signed int len)
{
  memcpy((void *)*pdstbuf, srcbuf, (unsigned long int)len);
  *pdstbuf = *pdstbuf + (signed long int)len;
  return len;
}

// cbuf_read
// file ../../src/pdsh/cbuf.h line 171
signed int cbuf_read(struct cbuf *src, void *dstbuf, signed int len)
{
  signed int n;
  if(dstbuf == NULL || !(len >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 543, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_reader(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&dstbuf);
    if(n >= 1)
      cbuf_dropper(src, n);

    do
    {
      signed int cbuf_read__1__5__e;
      cbuf_read__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_read__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_read__1__5__e;
        lsd_fatal_error("cbuf.c", 550, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_read_line
// file cbuf.c line 702
signed int cbuf_read_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines)
{
  signed int n;
  signed int m;
  signed int l;
  char *pdst;
  if(dstbuf == ((char *)NULL) || !(len >= 0) || !(lines >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(lines == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 716, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_find_unread_line(src, len - 1, &lines);
    if(n >= 1)
    {
      if(len >= 1)
      {
        m = n <= len - 1 ? n : len - 1;
        if(m >= 1)
        {
          pdst = dstbuf;
          l=cbuf_reader(src, m, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&pdst);
        }

        dstbuf[(signed long int)m] = (char)0;
      }

      cbuf_dropper(src, n);
    }

    do
    {
      signed int cbuf_read_line__1__5__e;
      cbuf_read_line__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_read_line__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_read_line__1__5__e;
        lsd_fatal_error("cbuf.c", 733, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_read_to_fd
// file cbuf.c line 918
signed int cbuf_read_to_fd(struct cbuf *src, signed int dstfd, signed int len)
{
  signed int n = 0;
  if(!(dstfd >= 0) || !(len >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  do
  {
    signed int e;
    e=pthread_mutex_lock(&src->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("cbuf.c", 928, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(len == -1)
    len = src->used;

  if(len >= 1)
  {
    n=cbuf_reader(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_fd, (void *)&dstfd);
    if(n >= 1)
      cbuf_dropper(src, n);

  }

  do
  {
    signed int cbuf_read_to_fd__1__5__e;
    cbuf_read_to_fd__1__5__e=pthread_mutex_unlock(&src->mutex);
    if(!(cbuf_read_to_fd__1__5__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = cbuf_read_to_fd__1__5__e;
      lsd_fatal_error("cbuf.c", 940, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// cbuf_reader
// file cbuf.c line 1449
static signed int cbuf_reader(struct cbuf *src, signed int len, signed int (*putf)(void *, void *, signed int), void *dst)
{
  signed int nleft;
  signed int n;
  signed int m;
  signed int i_src;
  signed int tmp_if_expr_1;
  if(src->used >= len)
    tmp_if_expr_1 = len;

  else
    tmp_if_expr_1 = src->used;
  len = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(len == 0)
    return 0;

  else
  {
    i_src = src->i_out;
    nleft = len;
    m = 0;
    if(nleft >= 1)
    {
      if(1 + src->size + -i_src >= nleft)
        tmp_if_expr_2 = nleft;

      else
        tmp_if_expr_2 = (src->size + 1) - i_src;
      n = tmp_if_expr_2;
      m=putf((void *)&src->data[(signed long int)i_src], dst, n);
      if(m >= 1)
      {
        nleft = nleft - m;
        i_src = (i_src + m) % (src->size + 1);
      }

    }

    n = len - nleft;
    if(n == 0)
      return m;

    else
      return n;
  }
}

// cbuf_replay
// file cbuf.c line 556
signed int cbuf_replay(struct cbuf *src, void *dstbuf, signed int len)
{
  signed int n;
  if(dstbuf == NULL || !(len >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 569, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_replayer(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&dstbuf);
    do
    {
      signed int cbuf_replay__1__4__e;
      cbuf_replay__1__4__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_replay__1__4__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_replay__1__4__e;
        lsd_fatal_error("cbuf.c", 573, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_replay_line
// file cbuf.c line 739
signed int cbuf_replay_line(struct cbuf *src, char *dstbuf, signed int len, signed int lines)
{
  signed int n;
  signed int m;
  signed int l;
  signed int nl;
  char *pdst;
  if(dstbuf == ((char *)NULL) || !(len >= 0) || !(lines >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  signed int tmp_post_3;
  if(lines == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 754, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_find_replay_line(src, len - 1, &lines, &nl);
    if(n >= 1)
    {
      if(len >= 1)
      {
        m = n <= (len - 1) - nl ? n : (len - 1) - nl;
        m = m >= 0 ? m : 0;
        if(m >= 1)
        {
          pdst = dstbuf;
          l=cbuf_replayer(src, m, (signed int (*)(void *, void *, signed int))cbuf_put_mem, (void *)&pdst);
        }

        if(len >= 2 && !(nl == 0))
        {
          tmp_post_3 = m;
          m = m + 1;
          dstbuf[(signed long int)tmp_post_3] = (char)10;
        }

        dstbuf[(signed long int)m] = (char)0;
        n = n + nl;
      }

    }

    do
    {
      signed int cbuf_replay_line__1__5__e;
      cbuf_replay_line__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_replay_line__1__5__e == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = cbuf_replay_line__1__5__e;
        lsd_fatal_error("cbuf.c", 778, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_replay_to_fd
// file cbuf.c line 946
signed int cbuf_replay_to_fd(struct cbuf *src, signed int dstfd, signed int len)
{
  signed int n = 0;
  if(!(dstfd >= 0) || !(len >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  do
  {
    signed int e;
    e=pthread_mutex_lock(&src->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("cbuf.c", 956, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(len == -1)
    len = src->size - src->used;

  if(len >= 1)
    n=cbuf_replayer(src, len, (signed int (*)(void *, void *, signed int))cbuf_put_fd, (void *)&dstfd);

  do
  {
    signed int cbuf_replay_to_fd__1__5__e;
    cbuf_replay_to_fd__1__5__e=pthread_mutex_unlock(&src->mutex);
    if(!(cbuf_replay_to_fd__1__5__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = cbuf_replay_to_fd__1__5__e;
      lsd_fatal_error("cbuf.c", 965, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// cbuf_replayer
// file cbuf.c line 1505
static signed int cbuf_replayer(struct cbuf *src, signed int len, signed int (*putf)(void *, void *, signed int), void *dst)
{
  signed int nleft;
  signed int n;
  signed int m;
  signed int i_src;
  n = ((src->i_out - src->i_rep) + src->size + 1) % (src->size + 1);
  len = len <= n ? len : n;
  signed int tmp_if_expr_1;
  if(len == 0)
    return 0;

  else
  {
    i_src = ((src->i_out - len) + src->size + 1) % (src->size + 1);
    nleft = len;
    m = 0;
    if(nleft >= 1)
    {
      if(1 + src->size + -i_src >= nleft)
        tmp_if_expr_1 = nleft;

      else
        tmp_if_expr_1 = (src->size + 1) - i_src;
      n = tmp_if_expr_1;
      m=putf((void *)&src->data[(signed long int)i_src], dst, n);
      if(m >= 1)
      {
        nleft = nleft - m;
        i_src = (i_src + m) % (src->size + 1);
      }

    }

    n = len - nleft;
    if(n == 0)
      return m;

    else
      return n;
  }
}

// cbuf_reused
// file cbuf.c line 380
signed int cbuf_reused(struct cbuf *cb)
{
  signed int reused;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 385, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  reused = ((cb->i_out - cb->i_rep) + cb->size + 1) % (cb->size + 1);
  do
  {
    signed int cbuf_reused__1__2__e;
    cbuf_reused__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_reused__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_reused__1__2__e;
      lsd_fatal_error("cbuf.c", 388, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return reused;
}

// cbuf_rewind
// file cbuf.c line 579
signed int cbuf_rewind(struct cbuf *src, signed int len)
{
  signed int reused;
  if(!(len >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 592, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    reused = ((src->i_out - src->i_rep) + src->size + 1) % (src->size + 1);
    if(len == -1)
      len = reused;

    else
      len = len <= reused ? len : reused;
    if(len >= 1)
    {
      src->used = src->used + len;
      src->i_out = ((src->i_out - len) + src->size + 1) % (src->size + 1);
    }

    do
    {
      signed int cbuf_rewind__1__7__e;
      cbuf_rewind__1__7__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_rewind__1__7__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_rewind__1__7__e;
        lsd_fatal_error("cbuf.c", 607, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return len;
  }
}

// cbuf_rewind_line
// file cbuf.c line 784
signed int cbuf_rewind_line(struct cbuf *src, signed int len, signed int lines)
{
  signed int n;
  if(!(len >= 0) || !(lines >= -1))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(lines == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&src->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 797, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_find_replay_line(src, len, &lines, (signed int *)(void *)0);
    if(n >= 1)
    {
      src->used = src->used + n;
      src->i_out = ((src->i_out - n) + src->size + 1) % (src->size + 1);
    }

    do
    {
      signed int cbuf_rewind_line__1__5__e;
      cbuf_rewind_line__1__5__e=pthread_mutex_unlock(&src->mutex);
      if(!(cbuf_rewind_line__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_rewind_line__1__5__e;
        lsd_fatal_error("cbuf.c", 806, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_shrink
// file cbuf.c line 1724
static signed int cbuf_shrink(struct cbuf *cb)
{
  if(cb->size == cb->minsize)
    return 0;

  else
    if(!(cb->size + -cb->used >= 1001))
      return 0;

    else
      return 0;
}

// cbuf_size
// file cbuf.c line 324
signed int cbuf_size(struct cbuf *cb)
{
  signed int size;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 329, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  size = cb->size;
  do
  {
    signed int cbuf_size__1__2__e;
    cbuf_size__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_size__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_size__1__2__e;
      lsd_fatal_error("cbuf.c", 332, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return size;
}

// cbuf_used
// file cbuf.c line 352
signed int cbuf_used(struct cbuf *cb)
{
  signed int used;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&cb->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("cbuf.c", 357, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  used = cb->used;
  do
  {
    signed int cbuf_used__1__2__e;
    cbuf_used__1__2__e=pthread_mutex_unlock(&cb->mutex);
    if(!(cbuf_used__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = cbuf_used__1__2__e;
      lsd_fatal_error("cbuf.c", 360, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return used;
}

// cbuf_write
// file cbuf.c line 613
signed int cbuf_write(struct cbuf *dst, void *srcbuf, signed int len, signed int *ndropped)
{
  signed int n;
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = 0;

  if(srcbuf == NULL || !(len >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(len == 0)
    return 0;

  else
  {
    do
    {
      signed int e;
      e=pthread_mutex_lock(&dst->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("cbuf.c", 629, "cbuf mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    n=cbuf_writer(dst, len, (signed int (*)(void *, void *, signed int))cbuf_get_mem, (void *)&srcbuf, ndropped);
    do
    {
      signed int cbuf_write__1__5__e;
      cbuf_write__1__5__e=pthread_mutex_unlock(&dst->mutex);
      if(!(cbuf_write__1__5__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = cbuf_write__1__5__e;
        lsd_fatal_error("cbuf.c", 633, "cbuf mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// cbuf_write_from_fd
// file ../../src/pdsh/cbuf.h line 290
signed int cbuf_write_from_fd(struct cbuf *dst, signed int srcfd, signed int len, signed int *ndropped)
{
  signed int n = 0;
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = 0;

  if(!(len >= -1) || !(srcfd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  do
  {
    signed int e;
    e=pthread_mutex_lock(&dst->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("cbuf.c", 984, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  signed int tmp_if_expr_3;
  if(len == -1)
  {
    len = dst->size - dst->used;
    if(len == 0)
    {
      if(!(dst->size >= 1001))
        tmp_if_expr_3 = dst->size;

      else
        tmp_if_expr_3 = 1000;
      len = tmp_if_expr_3;
    }

  }

  if(len >= 1)
    n=cbuf_writer(dst, len, (signed int (*)(void *, void *, signed int))cbuf_get_fd, (void *)&srcfd, ndropped);

  do
  {
    signed int cbuf_write_from_fd__1__6__e;
    cbuf_write_from_fd__1__6__e=pthread_mutex_unlock(&dst->mutex);
    if(!(cbuf_write_from_fd__1__6__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = cbuf_write_from_fd__1__6__e;
      lsd_fatal_error("cbuf.c", 1001, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// cbuf_write_line
// file cbuf.c line 812
signed int cbuf_write_line(struct cbuf *dst, char *srcbuf, signed int *ndropped)
{
  signed int len;
  signed int nfree;
  signed int ncopy;
  signed int n;
  signed int ndrop = 0;
  signed int d;
  char *psrc = srcbuf;
  char *newline = "\n";
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = 0;

  if(srcbuf == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(srcbuf);
  ncopy = (signed int)return_value_strlen_2;
  len = ncopy;
  _Bool tmp_if_expr_3;
  if(len == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)srcbuf[(signed long int)(len - 1)] != 10 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    len = len + 1;

  do
  {
    signed int e;
    e=pthread_mutex_lock(&dst->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = e;
      lsd_fatal_error("cbuf.c", 836, "cbuf mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  nfree = dst->size - dst->used;
  if(!(nfree >= len))
  {
    if(!(dst->size >= dst->maxsize))
    {
      signed int return_value_cbuf_grow_5;
      return_value_cbuf_grow_5=cbuf_grow(dst, len - nfree);
      nfree = nfree + return_value_cbuf_grow_5;
    }

  }

  if((signed int)dst->overwrite == CBUF_NO_DROP)
  {
    if(!(dst->size + -dst->used >= len))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = 28;
      len = -1;
    }

  }

  else
    if((signed int)dst->overwrite == CBUF_WRAP_ONCE)
    {
      if(!(dst->size >= len))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7 = 28;
        len = -1;
      }

    }

  if(len >= 1)
  {
    if(!(dst->size >= len))
    {
      ndrop = ndrop + (len - dst->size);
      ncopy = ncopy - ndrop;
      psrc = psrc + (signed long int)ndrop;
    }

    if(ncopy >= 1)
    {
      n=cbuf_writer(dst, ncopy, (signed int (*)(void *, void *, signed int))cbuf_get_mem, (void *)&psrc, &d);
      ndrop = ndrop + d;
    }

    if(!((signed int)srcbuf[(signed long int)(len + -1)] == 10))
    {
      n=cbuf_writer(dst, 1, (signed int (*)(void *, void *, signed int))cbuf_get_mem, (void *)&newline, &d);
      ndrop = ndrop + d;
    }

  }

  do
  {
    signed int cbuf_write_line__1__9__e;
    cbuf_write_line__1__9__e=pthread_mutex_unlock(&dst->mutex);
    if(!(cbuf_write_line__1__9__e == 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      *return_value___errno_location_8 = cbuf_write_line__1__9__e;
      lsd_fatal_error("cbuf.c", 884, "cbuf mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  if(!(ndropped == ((signed int *)NULL)))
    *ndropped = ndrop;

  return len;
}

// cbuf_writer
// file cbuf.c line 1562
static signed int cbuf_writer(struct cbuf *dst, signed int len, signed int (*getf)(void *, void *, signed int), void *src, signed int *ndropped)
{
  signed int nfree;
  signed int nleft;
  signed int nrepl;
  signed int n;
  signed int m;
  signed int i_dst;
  nfree = dst->size - dst->used;
  if(!(nfree >= len))
  {
    if(!(dst->size >= dst->maxsize))
    {
      signed int return_value_cbuf_grow_1;
      return_value_cbuf_grow_1=cbuf_grow(dst, len - nfree);
      nfree = nfree + return_value_cbuf_grow_1;
    }

  }

  signed int tmp_if_expr_2;
  signed int tmp_if_expr_4;
  if((signed int)dst->overwrite == CBUF_NO_DROP)
  {
    if(dst->size + -dst->used >= len)
      tmp_if_expr_2 = len;

    else
      tmp_if_expr_2 = dst->size - dst->used;
    len = tmp_if_expr_2;
    if(len == 0)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 28;
      return -1;
    }

  }

  else
    if((signed int)dst->overwrite == CBUF_WRAP_ONCE)
    {
      if(dst->size >= len)
        tmp_if_expr_4 = len;

      else
        tmp_if_expr_4 = dst->size;
      len = tmp_if_expr_4;
    }

  i_dst = dst->i_in;
  nleft = len;
  m = 0;
  signed int tmp_if_expr_5;
  if(nleft >= 1)
  {
    if(1 + dst->size + -i_dst >= nleft)
      tmp_if_expr_5 = nleft;

    else
      tmp_if_expr_5 = (dst->size + 1) - i_dst;
    n = tmp_if_expr_5;
    m=getf((void *)&dst->data[(signed long int)i_dst], src, n);
    if(m >= 1)
    {
      nleft = nleft - m;
      i_dst = (i_dst + m) % (dst->size + 1);
    }

  }

  n = len - nleft;
  signed int tmp_if_expr_6;
  if(n == 0)
    return m;

  else
  {
    if(n >= 1)
    {
      nrepl = ((dst->i_out - dst->i_rep) + dst->size + 1) % (dst->size + 1);
      if(dst->size >= dst->used + n)
        tmp_if_expr_6 = dst->used + n;

      else
        tmp_if_expr_6 = dst->size;
      dst->used = tmp_if_expr_6;
      dst->i_in = i_dst;
      if(!(nfree + -nrepl >= n))
      {
        dst->got_wrap = 1;
        dst->i_rep = (dst->i_in + 1) % (dst->size + 1);
      }

      if(!(nfree >= n))
        dst->i_out = dst->i_rep;

    }

    if(!(ndropped == ((signed int *)NULL)))
      *ndropped = 0 >= n - nfree ? 0 : n - nfree;

    return n;
  }
}

// closeall
// file pipecmd.c line 246
static void closeall(signed int fd)
{
  signed int fdlimit;
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(4);
  fdlimit = (signed int)return_value_sysconf_1;
  signed int tmp_post_2;
  while(!(fd >= fdlimit))
  {
    tmp_post_2 = fd;
    fd = fd + 1;
    close(tmp_post_2);
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// cmd_args_create
// file pipecmd.c line 135
static char ** cmd_args_create(struct pipe_info_struct *e, const char **argv)
{
  signed int i = 0;
  signed int n = 0;
  char **args = (char **)(void *)0;
  for( ; !(argv[(signed long int)n] == ((const char *)NULL)); n = n + 1)
    ;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc((unsigned long int)(n + 2) * sizeof(char *) /*8ul*/ );
  args = (char **)return_value_Malloc_1;
  args[(signed long int)0]=Strdup(e->cmd);
  i = 1;
  for( ; !(i >= 1 + n); i = i + 1)
    args[(signed long int)i]=pipecmd_format_arg(e, argv[(signed long int)(i - 1)]);
  args[(signed long int)i] = (char *)(void *)0;
  return args;
}

// cmd_args_destroy
// file pipecmd.c line 157
static void cmd_args_destroy(char **args)
{
  signed int i = 0;
  signed int tmp_post_1;
  if(!(args == ((char **)NULL)))
  {
    while(!(args[(signed long int)i] == ((char *)NULL)))
    {
      tmp_post_1 = i;
      i = i + 1;
      Free((void **)&args[(signed long int)tmp_post_1]);
    }
    Free((void **)&args);
  }

}

// copy_username
// file opt.c line 321
static void copy_username(char *dst, const char *src)
{
  signed int maxlen;
  maxlen=login_name_max_len();
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(src);
  if(!((unsigned long int)maxlen >= return_value_strlen_1))
    errx("%p: Fatal: username '%s' exceeds max username length (%d)\n", src, maxlen);

  strcpy(dst, src);
}

// create_privileged_child
// file privsep.c line 250
static signed int create_privileged_child(void)
{
  cpid=fork();
  if(!(cpid >= 0))
  {
    err("%p: fork failed in privilege separation: %m\n");
    return -1;
  }

  else
  {
    if(cpid == 0)
    {
      privsep_server();
      exit(0);
    }

    close(server_fd);
    drop_privileges();
    return 0;
  }
}

// create_socketpair
// file privsep.c line 85
static signed int create_socketpair(void)
{
  signed int pfds[2l];
  signed int return_value_socketpair_1;
  return_value_socketpair_1=socketpair(1, 1, 0, pfds);
  if(!(return_value_socketpair_1 >= 0))
  {
    err("%p: socketpair failed in privilege separation: %m\n");
    return -1;
  }

  else
  {
    client_fd = pfds[(signed long int)0];
    server_fd = pfds[(signed long int)1];
    return 0;
  }
}

// drop_privileges
// file privsep.c line 100
static void drop_privileges(void)
{
  user_uid=getuid();
  priv_uid=geteuid();
  user_gid=getgid();
  priv_gid=getegid();
  seteuid(user_uid);
  setegid(user_gid);
}

// dsh
// file dsh.h line 95
signed int dsh(struct anonymous_1 *opt)
{
  signed int i;
  signed int rc = 0;
  signed int rv;
  signed int rshcount;
  unsigned long int thread_wdog;
  unsigned long int thread_sig;
  union pthread_attr_t attr_wdog;
  union pthread_attr_t attr_sig;
  struct list *pcp_infiles = (struct list *)(void *)0;
  struct hostlist_iterator *itr;
  const char *domain = (const char *)(void *)0;
  enum anonymous domain_in_label = (enum anonymous)false;
  _mask_signals(0);
  signed int return_value_rcmd_init_1;
  return_value_rcmd_init_1=rcmd_init(opt);
  if(!(return_value_rcmd_init_1 >= 0))
  {
    err("%p: unable to initialize an rcmd module\n");
    exit(1);
  }

  _increase_nofile_limit(opt);
  _xsignal(14, _alarm_handler);
  if(!(opt->sigint_terminates == /*enum*/false))
    sigint_terminates = 1;

  rshcount=hostlist_count(opt->wcoll);
  enum anonymous_5 return_value_pdsh_personality_2;
  return_value_pdsh_personality_2=pdsh_personality();
  if((signed int)return_value_pdsh_personality_2 == DSH)
  {
    if(!(opt->dshpath == ((char *)NULL)))
    {
      char *dsh__1__2__cmd;
      dsh__1__2__cmd=Strdup(opt->dshpath);
      xstrcat(&dsh__1__2__cmd, opt->cmd);
      Free((void **)&opt->cmd);
      opt->cmd = dsh__1__2__cmd;
    }

  }

  _Bool tmp_if_expr_3;
  if(!(opt->kill_on_fail == /*enum*/false))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = opt->ret_remote_rc != (enum anonymous)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    opt->getstat = ";echo XXRETCODE:_?";

  enum anonymous_5 return_value_pdsh_personality_4;
  return_value_pdsh_personality_4=pdsh_personality();
  if((signed int)return_value_pdsh_personality_4 == DSH)
  {
    if(!(opt->getstat == ((char *)NULL)))
    {
      char *dsh__1__3__cmd;
      dsh__1__3__cmd=Strdup(opt->cmd);
      xstrcat(&dsh__1__3__cmd, opt->getstat);
      Free((void **)&opt->cmd);
      opt->cmd = dsh__1__3__cmd;
    }

  }

  enum anonymous_5 return_value_pdsh_personality_6;
  return_value_pdsh_personality_6=pdsh_personality();
  if((signed int)return_value_pdsh_personality_6 == PCP)
  {
    if(opt->reverse_copy == /*enum*/false)
    {
      char *dsh__1__4__cmd = (char *)(void *)0;
      pcp_infiles=pcp_expand_dirs(opt->infile_names);
      if(pcp_infiles == ((struct list *)NULL))
      {
        err("%p: unable to build file copy list\n");
        exit(1);
      }

      xstrcat(&dsh__1__4__cmd, opt->remote_program_path);
      if(!(opt->recursive == /*enum*/false))
        xstrcat(&dsh__1__4__cmd, " -r");

      if(!(opt->preserve == /*enum*/false))
        xstrcat(&dsh__1__4__cmd, " -p");

      signed int return_value_list_count_5;
      return_value_list_count_5=list_count(pcp_infiles);
      if(return_value_list_count_5 >= 2)
        xstrcat(&dsh__1__4__cmd, " -y");

      xstrcat(&dsh__1__4__cmd, " -z ");
      xstrcat(&dsh__1__4__cmd, opt->outfile_name);
      opt->cmd = dsh__1__4__cmd;
    }

  }

  enum anonymous_5 return_value_pdsh_personality_8;
  return_value_pdsh_personality_8=pdsh_personality();
  void *return_value_list_next_7;
  if((signed int)return_value_pdsh_personality_8 == PCP)
  {
    if(!(opt->reverse_copy == /*enum*/false))
    {
      char *cmd = (char *)(void *)0;
      char *filename;
      struct listIterator *dsh__1__5__i;
      xstrcat(&cmd, opt->remote_program_path);
      if(!(opt->recursive == /*enum*/false))
        xstrcat(&cmd, " -r");

      if(!(opt->preserve == /*enum*/false))
        xstrcat(&cmd, " -p");

      xstrcat(&cmd, " -Z ");
      dsh__1__5__i=list_iterator_create(opt->infile_names);
      do
      {
        return_value_list_next_7=list_next(dsh__1__5__i);
        filename = (char *)return_value_list_next_7;
        if(filename == ((char *)NULL))
          break;

        xstrcat(&cmd, " ");
        xstrcat(&cmd, filename);
      }
      while((_Bool)1);
      list_iterator_destroy(dsh__1__5__i);
      opt->cmd = cmd;
    }

  }

  if(!(opt->debug == /*enum*/false))
    debug = 1;

  void *return_value_Malloc_9;
  return_value_Malloc_9=Malloc(sizeof(struct thd) /*248ul*/  * (unsigned long int)(rshcount + 1));
  t = (struct thd *)return_value_Malloc_9;
  itr=hostlist_iterator_create(opt->wcoll);
  if(itr == ((struct hostlist_iterator *)NULL))
    errx("%p: hostlist_iterator_create failed\n");

  i = 0;
  signed int return_value_strcmp_10;
  do
  {
    (t + (signed long int)i)->host=hostlist_next(itr);
    if((t + (signed long int)i)->host == ((char *)NULL))
      break;

    char *d;
    _thd_init(&t[(signed long int)i], opt, pcp_infiles, i);
    if(domain_in_label == /*enum*/false)
    {
      d=strchr((t + (signed long int)i)->host, 46);
      if(!(d == ((char *)NULL)))
      {
        if(domain == ((const char *)NULL))
          domain = d;

        else
        {
          return_value_strcmp_10=strcmp(d, domain);
          if(!(return_value_strcmp_10 == 0))
            domain_in_label = (enum anonymous)true;

        }
      }

    }

    i = i + 1;
  }
  while((_Bool)1);
  hostlist_iterator_destroy(itr);
  if(!(domain_in_label == /*enum*/false))
    err_no_strip_domain();

  connect_timeout = opt->connect_timeout;
  command_timeout = opt->command_timeout;
  _dsh_attr_init(&attr_wdog, 128 * 1024);
  rv=pthread_create(&thread_wdog, &attr_wdog, _wdog, (void *)t);
  _dsh_attr_init(&attr_sig, 128 * 1024);
  rv=pthread_create(&thread_sig, &attr_sig, _signals_thread, (void *)t);
  i = 0;
  for( ; !(i >= rshcount); i = i + 1)
  {
    do
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      *return_value___errno_location_11=pthread_mutex_lock(&threadcount_mutex);
      if(!(*return_value___errno_location_11 == 0))
        errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 1140);

    }
    while((_Bool)0);
    if(opt->fanout == threadcount)
      pthread_cond_wait(&threadcount_cond, &threadcount_mutex);

    for( ; (signed int)(t + (signed long int)i)->state == DSH_CANCELED; i = i + 1)
      if(i >= rshcount)
        break;

    if(i >= rshcount)
    {
      do
      {
        signed int *return_value___errno_location_12;
        return_value___errno_location_12=__errno_location();
        *return_value___errno_location_12=pthread_mutex_unlock(&threadcount_mutex);
        if(!(*return_value___errno_location_12 == 0))
          errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 1154);

      }
      while((_Bool)0);
      break;
    }

    _dsh_attr_init(&(t + (signed long int)i)->attr, 128 * 1024);
    pthread_attr_setscope(&(t + (signed long int)i)->attr, 0);
    enum anonymous_5 return_value_pdsh_personality_13;
    return_value_pdsh_personality_13=pdsh_personality();
    rv=pthread_create(&(t + (signed long int)i)->thread, &(t + (signed long int)i)->attr, (signed int)return_value_pdsh_personality_13 == DSH ? _rsh_thread : _rcp_thread, (void *)&t[(signed long int)i]);
    if(!(rv == 0))
    {
      if(!(opt->kill_on_fail == /*enum*/false))
        _fwd_signal(15);

      char *return_value_strerror_14;
      return_value_strerror_14=strerror(rv);
      errx("%p: pthread_create %S: %S\n", (t + (signed long int)i)->host, return_value_strerror_14);
    }

    threadcount = threadcount + 1;
    do
    {
      signed int *return_value___errno_location_15;
      return_value___errno_location_15=__errno_location();
      *return_value___errno_location_15=pthread_mutex_unlock(&threadcount_mutex);
      if(!(*return_value___errno_location_15 == 0))
        errx("%s:%d: mutex_unlock: %m", (const void *)"dsh.c", 1174);

    }
    while((_Bool)0);
  }
  do
  {
    signed int *return_value___errno_location_16;
    return_value___errno_location_16=__errno_location();
    *return_value___errno_location_16=pthread_mutex_lock(&threadcount_mutex);
    if(!(*return_value___errno_location_16 == 0))
      errx("%s:%d: mutex_lock: %m", (const void *)"dsh.c", 1178);

  }
  while((_Bool)0);
  while(threadcount >= 1)
    pthread_cond_wait(&threadcount_cond, &threadcount_mutex);
  if(!(debug == 0))
    _dump_debug_stats(rshcount);

  pthread_cancel(thread_sig);
  _mask_signals(1);
  if(!(opt->ret_remote_rc == /*enum*/false))
  {
    i = 0;
    for( ; !((t + (signed long int)i)->host == ((char *)NULL)); i = i + 1)
    {
      if((signed int)(t + (signed long int)i)->state == DSH_FAILED)
        rc = 254;

      if(!(rc >= (t + (signed long int)i)->rc))
        rc = (t + (signed long int)i)->rc;

    }
  }

  i = 0;
  for( ; !((t + (signed long int)i)->host == ((char *)NULL)); i = i + 1)
  {
    free((void *)(t + (signed long int)i)->host);
    cbuf_destroy((t + (signed long int)i)->outbuf);
    cbuf_destroy((t + (signed long int)i)->errbuf);
  }
  Free((void **)&t);
  return rc;
}

// err
// file ../../src/common/err.h line 35
void err(char *format, ...)
{
  void **ap = (void **)&format;
  _verr(stderr, format, ap);
  ap = ((void **)NULL);
}

// err_cleanup
// file ../../src/common/err.h line 39
void err_cleanup(void)
{
  Free((void **)&prog);
  Free((void **)&host);
}

// err_init
// file ../../src/common/err.h line 33
void err_init(char *str)
{
  char thishost[64l];
  char *p;
  gethostname(thishost, (unsigned long int)64);
  p=strchr(thishost, 46);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  host=Strdup(thishost);
  prog=Strdup(str);
}

// err_no_strip_domain
// file ../../src/common/err.h line 34
void err_no_strip_domain()
{
  keep_host_domain = (enum anonymous)true;
}

// errf
// file ../../src/common/err.h line 38
void errf(struct _IO_FILE *stream, char *format, void **ap)
{
  if(!(stream == ((struct _IO_FILE *)NULL)))
    _verr(stream, format, ap);

}

// errx
// file ../../src/common/err.h line 37
void errx(char *format, ...)
{
  void **ap = (void **)&format;
  _verr(stderr, format, ap);
  ap = ((void **)NULL);
  exit(1);
}

// fd_get_read_lock
// file fd.c line 74
signed int fd_get_read_lock(signed int fd)
{
  signed int return_value__fd_get_lock_1;
  return_value__fd_get_lock_1=_fd_get_lock(fd, 6, 0);
  return return_value__fd_get_lock_1;
}

// fd_get_readw_lock
// file fd.c line 81
signed int fd_get_readw_lock(signed int fd)
{
  signed int return_value__fd_get_lock_1;
  return_value__fd_get_lock_1=_fd_get_lock(fd, 7, 0);
  return return_value__fd_get_lock_1;
}

// fd_get_write_lock
// file fd.c line 88
signed int fd_get_write_lock(signed int fd)
{
  signed int return_value__fd_get_lock_1;
  return_value__fd_get_lock_1=_fd_get_lock(fd, 6, 1);
  return return_value__fd_get_lock_1;
}

// fd_get_writew_lock
// file fd.c line 95
signed int fd_get_writew_lock(signed int fd)
{
  signed int return_value__fd_get_lock_1;
  return_value__fd_get_lock_1=_fd_get_lock(fd, 7, 1);
  return return_value__fd_get_lock_1;
}

// fd_is_read_lock_blocked
// file fd.c line 109
signed int fd_is_read_lock_blocked(signed int fd)
{
  signed int return_value__fd_test_lock_1;
  return_value__fd_test_lock_1=_fd_test_lock(fd, 0);
  return return_value__fd_test_lock_1;
}

// fd_is_write_lock_blocked
// file fd.c line 116
signed int fd_is_write_lock_blocked(signed int fd)
{
  signed int return_value__fd_test_lock_1;
  return_value__fd_test_lock_1=_fd_test_lock(fd, 1);
  return return_value__fd_test_lock_1;
}

// fd_null_read_n
// file fd.c line 244
signed long int fd_null_read_n(signed int fd, void *buf, unsigned long int n)
{
  unsigned char *mp;
  unsigned long int nleft;
  signed long int nread;
  unsigned char *p;
  unsigned char *q;
  p = (unsigned char *)buf;
  q = p;
  nleft = n;
  while(nleft >= 1ul)
  {
    nread=read(fd, (void *)p, nleft);
    if(!(nread >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      else
        return (signed long int)-1;
    }

    else
      if(nread == 0l)
        break;

    nleft = nleft - (unsigned long int)nread;
    p = p + nread;
    void *return_value_memchr_2;
    return_value_memchr_2=memchr((const void *)q, 0, n - nleft);
    mp = (unsigned char *)return_value_memchr_2;
    if(q + -1l + (signed long int)n + -((signed long int)nleft) >= mp)
    {
      if(!(mp == ((unsigned char *)NULL)))
        break;

    }

  }
  return (signed long int)(n - nleft);
}

// fd_read_line
// file ../../src/common/fd.h line 112
signed long int fd_read_line(signed int fd, void *buf, unsigned long int maxlen)
{
  signed long int n;
  signed long int rc;
  unsigned char c;
  unsigned char *p;
  n = (signed long int)0;
  p = (unsigned char *)buf;
  unsigned char *tmp_post_1;
  while(!(n >= (signed long int)maxlen + -1l))
  {
    rc=read(fd, (void *)&c, (unsigned long int)1);
    if(rc == 1l)
    {
      n = n + 1l;
      tmp_post_1 = p;
      p = p + 1l;
      *tmp_post_1 = c;
      if((signed int)c == 10)
        break;

    }

    else
      if(rc == 0l)
      {
        if(n == 0l)
          return (signed long int)0;

        else
          break;
      }

      else
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 4))
          return (signed long int)-1;

      }
  }
  *p = (unsigned char)0;
  return n;
}

// fd_read_n
// file ../../src/common/fd.h line 100
signed long int fd_read_n(signed int fd, void *buf, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nread;
  unsigned char *p = (unsigned char *)buf;
  nleft = n;
  while(nleft >= 1ul)
  {
    nread=read(fd, (void *)p, nleft);
    if(!(nread >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      else
        return (signed long int)-1;
    }

    else
      if(nread == 0l)
        break;

    nleft = nleft - (unsigned long int)nread;
    p = p + nread;
  }
  return (signed long int)(n - nleft);
}

// fd_release_lock
// file fd.c line 102
signed int fd_release_lock(signed int fd)
{
  signed int return_value__fd_get_lock_1;
  return_value__fd_get_lock_1=_fd_get_lock(fd, 6, 2);
  return return_value__fd_get_lock_1;
}

// fd_set_close_on_exec
// file fd.c line 48
signed int fd_set_close_on_exec(signed int fd)
{
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, 2, 1);
  if(!(return_value_fcntl_1 >= 0))
    return -1;

  else
    return 0;
}

// fd_set_nonblocking
// file ../../src/common/fd.h line 46
signed int fd_set_nonblocking(signed int fd)
{
  signed int fval;
  fval=fcntl(fd, 3, 0);
  if(!(fval >= 0))
    return -1;

  else
  {
    signed int return_value_fcntl_1;
    return_value_fcntl_1=fcntl(fd, 4, fval | 04000);
    if(!(return_value_fcntl_1 >= 0))
      return -1;

    else
      return 0;
  }
}

// fd_write_n
// file fd.c line 185
signed long int fd_write_n(signed int fd, void *buf, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nwritten;
  unsigned char *p = (unsigned char *)buf;
  nleft = n;
  while(nleft >= 1ul)
  {
    nwritten=write(fd, (const void *)p, nleft);
    if(!(nwritten >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      else
        return (signed long int)-1;
    }

    nleft = nleft - (unsigned long int)nwritten;
    p = p + nwritten;
  }
  return (signed long int)n;
}

// find_host
// file rcmd.c line 151
static signed int find_host(struct node_rcmd_info *x, char *hostname)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(x->hostname, hostname);
  return (signed int)(return_value_strcmp_1 == 0);
}

// find_rcmd_module
// file rcmd.c line 146
static signed int find_rcmd_module(struct rcmd_module *x, char *name)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(x->name, name);
  return (signed int)(return_value_strcmp_1 == 0);
}

// free_f
// file opt.c line 1210
void free_f(void *x)
{
  Free(&x);
}

// free_f_link1
// file wcoll.c line 58
static void free_f_link1(void *x_link1)
{
  Free(&x_link1);
}

// free_f_link2
// file split.c line 77
static void free_f_link2(char *str)
{
  Free((void **)&str);
}

// get_file_path
// file wcoll.c line 296
static char * get_file_path(const char *file, char *dir, signed int len)
{
  char *str;
  char *dname;
  memset((void *)dir, 0, (unsigned long int)len);
  dir[(signed long int)0] = (char)46;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(file == ((const char *)NULL))
    return dir;

  else
  {
    str=Strdup(file);
    dname=dirname(str);
    if(!(dname == ((char *)NULL)))
    {
      return_value_strlen_1=strlen(dname);
      tmp_if_expr_2 = return_value_strlen_1 < (unsigned long int)(len - 1) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      strcpy(dir, dname);

    else
      err("%p: %s: Error reading file path\n");
    Free((void **)&str);
    return dir;
  }
}

// get_host_rcmd_type
// file opt.c line 1171
static signed int get_host_rcmd_type(char *hosts, char **rptr, char **hptr, char **uptr)
{
  char *p = hosts;
  char *q;
  *hptr = hosts;
  p=strchr(hosts, 58);
  q=strchr(hosts, 64);
  if(!(p == ((char *)NULL)) && !(q == ((char *)NULL)) && !(q >= p))
    errx("Host spec \"%s\" not of form [rcmd_type:][user@]hosts\n", hosts);

  char *tmp_post_1;
  if(!(p == ((char *)NULL)))
  {
    if(!((signed int)p[1l] == 58))
    {
      *rptr = *hptr;
      tmp_post_1 = p;
      p = p + 1l;
      *tmp_post_1 = (char)0;
      *hptr = p;
    }

  }

  char *tmp_post_2;
  if(!(q == ((char *)NULL)))
  {
    *uptr = *hptr;
    tmp_post_2 = q;
    q = q + 1l;
    *tmp_post_2 = (char)0;
    *hptr = q;
  }

  return 1;
}

// host_prefix_end
// file hostlist.c line 457
static signed int host_prefix_end(const char *hostname)
{
  signed int idx;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(hostname);
  idx = (signed int)(return_value_strlen_1 - (unsigned long int)1);
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; idx >= 0; idx = idx - 1)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)hostname[(signed long int)idx]]) == 0)
      break;

  }
  return idx;
}

// host_rcmd_info
// file rcmd.c line 156
static struct node_rcmd_info * host_rcmd_info(char *host)
{
  if(host_info_list == ((struct list *)NULL))
    return (struct node_rcmd_info *)(void *)0;

  else
  {
    void *return_value_list_find_first_1;
    return_value_list_find_first_1=list_find_first(host_info_list, (signed int (*)(void *, void *))find_host, (void *)host);
    return (struct node_rcmd_info *)return_value_list_find_first_1;
  }
}

// hostlist_assign
// file opt.c line 1288
static void hostlist_assign(struct hostlist **hlp, struct hostlist *hl2)
{
  if(*hlp == ((struct hostlist *)NULL))
    *hlp=hostlist_create("");

  hostlist_push_list(*hlp, hl2);
}

// hostlist_coalesce
// file hostlist.c line 1999
static void hostlist_coalesce(struct hostlist *hl)
{
  signed int i;
  signed int j;
  struct hostrange_components *new;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_coalesce__1__1__1__e;
    hostlist_coalesce__1__1__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_coalesce__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_coalesce__1__1__1__e;
      lsd_fatal_error("hostlist.c", 2004, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  i = hl->nranges - 1;
  signed int tmp_post_3;
  signed int tmp_post_4;
  for( ; i >= 1; i = i - 1)
  {
    new=hostrange_intersect(hl->hr[(signed long int)(i - 1)], hl->hr[(signed long int)i]);
    if(!(new == ((struct hostrange_components *)NULL)))
    {
      struct hostrange_components *hprev = hl->hr[(signed long int)(i - 1)];
      struct hostrange_components *hnext = hl->hr[(signed long int)i];
      j = i;
      if(!(new->hi >= hprev->hi))
        hnext->hi = hprev->hi;

      hprev->hi = new->lo;
      hnext->lo = new->hi;
      signed int return_value_hostrange_empty_2;
      return_value_hostrange_empty_2=hostrange_empty(hprev);
      if(!(return_value_hostrange_empty_2 == 0))
        hostlist_delete_range(hl, i);

      while(new->hi >= new->lo)
      {
        struct hostrange_components *hr;
        hr=hostrange_create(new->prefix, new->lo, new->lo, new->width);
        if(!(hprev->hi >= new->lo))
        {
          tmp_post_3 = j;
          j = j + 1;
          hostlist_insert_range(hl, hr, tmp_post_3);
        }

        if(!(new->lo >= hnext->lo))
        {
          tmp_post_4 = j;
          j = j + 1;
          hostlist_insert_range(hl, hr, tmp_post_4);
        }

        hostrange_destroy(hr);
        new->lo = new->lo + 1ul;
      }
      i = hl->nranges;
      hostrange_destroy(new);
    }

  }
  do
  {

  __CPROVER_DUMP_L10:
    ;
    signed int e;
    e=pthread_mutex_unlock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = e;
      lsd_fatal_error("hostlist.c", 2043, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  hostlist_collapse(hl);
}

// hostlist_collapse
// file hostlist.c line 1977
static void hostlist_collapse(struct hostlist *hl)
{
  signed int i;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1981, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  i = hl->nranges - 1;
  signed int return_value_hostrange_width_combine_2;
  for( ; i >= 1; i = i - 1)
  {
    struct hostrange_components *hprev = hl->hr[(signed long int)(i - 1)];
    struct hostrange_components *hnext = hl->hr[(signed long int)i];
    signed int return_value_hostrange_prefix_cmp_3;
    return_value_hostrange_prefix_cmp_3=hostrange_prefix_cmp(hprev, hnext);
    if(return_value_hostrange_prefix_cmp_3 == 0)
    {
      if(hprev->hi == hnext->lo + 18446744073709551615ul)
      {
        return_value_hostrange_width_combine_2=hostrange_width_combine(hprev, hnext);
        if(!(return_value_hostrange_width_combine_2 == 0))
        {
          hprev->hi = hnext->hi;
          hostlist_delete_range(hl, i);
        }

      }

    }

  }
  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int hostlist_collapse__1__3__1__e;
    hostlist_collapse__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_collapse__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = hostlist_collapse__1__3__1__e;
      lsd_fatal_error("hostlist.c", 1993, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
}

// hostlist_copy
// file hostlist.c line 1558
struct hostlist * hostlist_copy(struct hostlist * const hl)
{
  signed int i;
  struct hostlist *new;
  if(hl == ((struct hostlist *)NULL))
    return (struct hostlist *)(void *)0;

  else
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      signed int e;
      e=pthread_mutex_lock(&hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("hostlist.c", 1566, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    new=hostlist_new();
    if(!(new == ((struct hostlist *)NULL)))
    {
      new->nranges = hl->nranges;
      new->nhosts = hl->nhosts;
      if(!(new->size >= new->nranges))
        hostlist_resize(new, (unsigned long int)new->nranges);

      i = 0;
      for( ; !(i >= hl->nranges); i = i + 1)
        new->hr[(signed long int)i]=hostrange_copy(hl->hr[(signed long int)i]);
    }

    do
    {

    done:
      ;
      signed int hostlist_copy__1__3__1__e;
      hostlist_copy__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_copy__1__3__1__e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = hostlist_copy__1__3__1__e;
        lsd_fatal_error("hostlist.c", 1579, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return new;
  }
}

// hostlist_count
// file ../../src/common/hostlist.h line 248
signed int hostlist_count(struct hostlist *hl)
{
  signed int retval;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1907, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  retval = hl->nhosts;
  do
  {

  __CPROVER_DUMP_L3:
    ;
    signed int hostlist_count__1__2__1__e;
    hostlist_count__1__2__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_count__1__2__1__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = hostlist_count__1__2__1__e;
      lsd_fatal_error("hostlist.c", 1909, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return retval;
}

// hostlist_create
// file ../../src/common/hostlist.h line 106
struct hostlist * hostlist_create(const char *str)
{
  struct hostlist *return_value__hostlist_create_1;
  return_value__hostlist_create_1=_hostlist_create(str, "\t, ", "-");
  return return_value__hostlist_create_1;
}

// hostlist_delete
// file ../../src/common/hostlist.h line 220
signed int hostlist_delete(struct hostlist *hl, const char *hosts)
{
  signed int n = 0;
  char *hostname = (char *)(void *)0;
  struct hostlist *hltmp;
  hltmp=hostlist_create(hosts);
  if(hltmp == ((struct hostlist *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return 0;
  }

  do
  {
    hostname=hostlist_pop(hltmp);
    if(hostname == ((char *)NULL))
      break;

    signed int return_value_hostlist_delete_host_2;
    return_value_hostlist_delete_host_2=hostlist_delete_host(hl, hostname);
    n = n + return_value_hostlist_delete_host_2;
    free((void *)hostname);
  }
  while((_Bool)1);
  hostlist_destroy(hltmp);
  return n;
}

// hostlist_delete_host
// file hostlist.c line 1823
signed int hostlist_delete_host(struct hostlist *hl, const char *hostname)
{
  signed int n;
  n=hostlist_find(hl, hostname);
  if(n >= 0)
    hostlist_delete_nth(hl, n);

  return n >= 0 ? 1 : 0;
}

// hostlist_delete_nth
// file hostlist.c line 1867
signed int hostlist_delete_nth(struct hostlist *hl, signed int n)
{
  signed int i;
  signed int count;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_delete_nth__1__1__1__e;
    hostlist_delete_nth__1__1__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_delete_nth__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_delete_nth__1__1__1__e;
      lsd_fatal_error("hostlist.c", 1871, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  count = 0;
  i = 0;
  signed int return_value_hostrange_empty_3;
  for( ; !(i >= hl->nranges); i = i + 1)
  {
    signed int num_in_range;
    unsigned long int return_value_hostrange_count_2;
    return_value_hostrange_count_2=hostrange_count(hl->hr[(signed long int)i]);
    num_in_range = (signed int)return_value_hostrange_count_2;
    struct hostrange_components *hr = hl->hr[(signed long int)i];
    if(-1 + num_in_range + count >= n)
    {
      unsigned long int num = (hr->lo + (unsigned long int)n) - (unsigned long int)count;
      struct hostrange_components *new;
      if(!(hr->singlehost == 0u))
        hostlist_delete_range(hl, i);

      else
      {
        new=hostrange_delete_host(hr, num);
        if(!(new == ((struct hostrange_components *)NULL)))
        {
          hostlist_insert_range(hl, new, i + 1);
          hostrange_destroy(new);
        }

        else
        {
          return_value_hostrange_empty_3=hostrange_empty(hr);
          if(!(return_value_hostrange_empty_3 == 0))
            hostlist_delete_range(hl, i);

        }
      }
      break;
    }

    else
      count = count + num_in_range;
  }

done:
  ;
  hl->nhosts = hl->nhosts - 1;
  do
  {

  __CPROVER_DUMP_L10:
    ;
    signed int e;
    e=pthread_mutex_unlock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = e;
      lsd_fatal_error("hostlist.c", 1900, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return 1;
}

// hostlist_delete_range
// file hostlist.c line 1222
static void hostlist_delete_range(struct hostlist *hl, signed int n)
{
  signed int i;
  struct hostrange_components *old = hl->hr[(signed long int)n];
  i = n;
  for( ; !(i >= hl->nranges + -1); i = i + 1)
    hl->hr[(signed long int)i] = hl->hr[(signed long int)(i + 1)];
  hl->nranges = hl->nranges - 1;
  hl->hr[(signed long int)hl->nranges] = (struct hostrange_components *)(void *)0;
  hostlist_shift_iterators(hl, n, 0, 1);
  hostrange_destroy(old);
}

// hostlist_deranged_string
// file ../../src/common/hostlist.h line 295
signed long int hostlist_deranged_string(struct hostlist *hl, unsigned long int n, char *buf)
{
  signed int i;
  signed int len = 0;
  signed int truncated = 0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 2098, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  i = 0;
  signed int tmp_post_3;
  for( ; !(i >= hl->nranges); i = i + 1)
  {
    unsigned long int m = n - (unsigned long int)len <= n ? n - (unsigned long int)len : (unsigned long int)0;
    signed int ret;
    unsigned long int return_value_hostrange_to_string_2;
    return_value_hostrange_to_string_2=hostrange_to_string(hl->hr[(signed long int)i], m, buf + (signed long int)len, ",");
    ret = (signed int)return_value_hostrange_to_string_2;
    if(!(ret >= 0) || !(m >= (unsigned long int)ret))
    {
      len = (signed int)n;
      truncated = 1;
      break;
    }

    len = len + ret;
    tmp_post_3 = len;
    len = len + 1;
    buf[(signed long int)tmp_post_3] = (char)44;
  }
  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int hostlist_deranged_string__1__3__1__e;
    hostlist_deranged_string__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_deranged_string__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = hostlist_deranged_string__1__3__1__e;
      lsd_fatal_error("hostlist.c", 2110, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  signed int tmp_if_expr_5;
  if(len >= 1)
  {
    len = len - 1;
    tmp_if_expr_5 = len;
  }

  else
    tmp_if_expr_5 = 0;
  buf[(signed long int)tmp_if_expr_5] = (char)0;
  if((unsigned long int)len == n)
    truncated = 1;

  return (signed long int)(truncated != 0 ? -1 : len);
}

// hostlist_destroy
// file ../../src/common/hostlist.h line 119
void hostlist_destroy(struct hostlist *hl)
{
  signed int i;
  if(!(hl == ((struct hostlist *)NULL)))
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      signed int e;
      e=pthread_mutex_lock(&hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("hostlist.c", 1589, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    while(!(hl->ilist == ((struct hostlist_iterator *)NULL)))
    {
      do
      {
        signed int hostlist_destroy__1__2__1__e;
        hostlist_destroy__1__2__1__e=pthread_mutex_unlock(&hl->mutex);
        if(!(hostlist_destroy__1__2__1__e == 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = hostlist_destroy__1__2__1__e;
          lsd_fatal_error("hostlist.c", 1591, "hostlist mutex unlock:");
          abort();
        }

      }
      while((_Bool)0);
      hostlist_iterator_destroy(hl->ilist);
      do
      {
        signed int hostlist_destroy__1__2__2__e;
        hostlist_destroy__1__2__2__e=pthread_mutex_lock(&hl->mutex);
        if(!(hostlist_destroy__1__2__2__e == 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = hostlist_destroy__1__2__2__e;
          lsd_fatal_error("hostlist.c", 1593, "hostlist mutex lock:");
          abort();
        }

      }
      while((_Bool)0);
    }
    i = 0;
    for( ; !(i >= hl->nranges); i = i + 1)
      hostrange_destroy(hl->hr[(signed long int)i]);
    free((void *)hl->hr);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      signed int hostlist_destroy__1__4__1__e;
      hostlist_destroy__1__4__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_destroy__1__4__1__e == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = hostlist_destroy__1__4__1__e;
        lsd_fatal_error("hostlist.c", 1599, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    do
    {
      signed int hostlist_destroy__1__5__e;
      hostlist_destroy__1__5__e=pthread_mutex_destroy(&hl->mutex);
      if(!(hostlist_destroy__1__5__e == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = hostlist_destroy__1__5__e;
        lsd_fatal_error("hostlist.c", 1600, "hostlist mutex destroy:");
        abort();
      }

    }
    while((_Bool)0);
    free((void *)hl);
  }

}

// hostlist_expand
// file hostlist.c line 1118
static signed int hostlist_expand(struct hostlist *hl)
{
  signed int return_value_hostlist_resize_1;
  return_value_hostlist_resize_1=hostlist_resize(hl, (unsigned long int)(hl->size + 16));
  if(return_value_hostlist_resize_1 == 0)
    return 0;

  else
    return 1;
}

// hostlist_filter_regex
// file opt.c line 1259
void hostlist_filter_regex(struct hostlist *hl, struct regex_info *re)
{
  char *hostlist_filter_regex__1__host;
  struct hostlist_iterator *i;
  i=hostlist_iterator_create(hl);
  _Bool tmp_if_expr_1;
  do
  {
    hostlist_filter_regex__1__host=hostlist_next(i);
    if(hostlist_filter_regex__1__host == ((char *)NULL))
      break;

    signed int rc;
    rc=regexec(&re->reg, hostlist_filter_regex__1__host, (unsigned long int)0, (struct anonymous_0 *)(void *)0, re->eflags);
    if(rc == 0 && !(re->exclude == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (!(re->exclude != 0) ? (rc == 1 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      hostlist_remove(i);

    free((void *)hostlist_filter_regex__1__host);
  }
  while((_Bool)1);
  hostlist_iterator_destroy(i);
}

// hostlist_find
// file hostlist.c line 1913
signed int hostlist_find(struct hostlist *hl, const char *hostname)
{
  signed int i;
  signed int count;
  signed int ret = -1;
  struct hostname_components *hn;
  unsigned long int return_value_hostrange_count_2;
  if(hostname == ((const char *)NULL))
    return -1;

  else
  {
    hn=hostname_create(hostname);
    do
    {

    __CPROVER_DUMP_L2:
      ;
      signed int hostlist_find__1__1__1__e;
      hostlist_find__1__1__1__e=pthread_mutex_lock(&hl->mutex);
      if(!(hostlist_find__1__1__1__e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = hostlist_find__1__1__1__e;
        lsd_fatal_error("hostlist.c", 1923, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    i = 0;
    count = 0;
    for( ; !(i >= hl->nranges); i = i + 1)
    {
      signed int offset;
      offset=hostrange_hn_within(hl->hr[(signed long int)i], hn);
      if(offset >= 0)
      {
        ret = count + offset;
        break;
      }

      else
      {
        return_value_hostrange_count_2=hostrange_count(hl->hr[(signed long int)i]);
        count = count + (signed int)return_value_hostrange_count_2;
      }
    }
    do
    {

    __CPROVER_DUMP_L7:
      ;
      signed int e;
      e=pthread_mutex_unlock(&hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = e;
        lsd_fatal_error("hostlist.c", 1935, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    hostname_destroy(hn);
    return ret;
  }
}

// hostlist_insert_range
// file hostlist.c line 1182
static signed int hostlist_insert_range(struct hostlist *hl, struct hostrange_components *hr, signed int n)
{
  signed int i;
  struct hostrange_components *tmp;
  struct hostlist_iterator *hli;
  signed int return_value_hostlist_expand_1;
  if(!(hl->nranges >= n))
    return 0;

  else
    if(hl->size == hl->nranges)
    {
      return_value_hostlist_expand_1=hostlist_expand(hl);
      if(!(return_value_hostlist_expand_1 == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      tmp = hl->hr[(signed long int)n];
      hl->hr[(signed long int)n]=hostrange_copy(hr);
      i = n + 1;
      for( ; !(i >= 1 + hl->nranges); i = i + 1)
      {
        struct hostrange_components *last = hl->hr[(signed long int)i];
        hl->hr[(signed long int)i] = tmp;
        tmp = last;
      }
      hl->nranges = hl->nranges + 1;
      hli = hl->ilist;
      for( ; !(hli == ((struct hostlist_iterator *)NULL)); hli = hli->next)
        if(hli->idx >= n)
        {
          hli->idx = hli->idx + 1;
          hli->hr = hli->hl->hr[(signed long int)hli->idx];
        }

      return 1;
    }
}

// hostlist_iterator_create
// file ../../src/common/hostlist.h line 316
struct hostlist_iterator * hostlist_iterator_create(struct hostlist *hl)
{
  struct hostlist_iterator *i;
  i=hostlist_iterator_new();
  if(i == ((struct hostlist_iterator *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    return (struct hostlist_iterator *)(void *)0;
  }

  do
  {

  __CPROVER_DUMP_L2:
    ;
    signed int hostlist_iterator_create__1__2__1__e;
    hostlist_iterator_create__1__2__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_iterator_create__1__2__1__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = hostlist_iterator_create__1__2__1__e;
      lsd_fatal_error("hostlist.c", 2229, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  i->hl = hl;
  i->hr = hl->hr[(signed long int)0];
  i->next = hl->ilist;
  hl->ilist = i;
  do
  {

  __CPROVER_DUMP_L4:
    ;
    signed int e;
    e=pthread_mutex_unlock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = e;
      lsd_fatal_error("hostlist.c", 2234, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return i;
}

// hostlist_iterator_destroy
// file ../../src/common/hostlist.h line 329
void hostlist_iterator_destroy(struct hostlist_iterator *i)
{
  struct hostlist_iterator **pi;
  if(!(i == ((struct hostlist_iterator *)NULL)))
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      signed int hostlist_iterator_destroy__1__1__1__e;
      hostlist_iterator_destroy__1__1__1__e=pthread_mutex_lock(&i->hl->mutex);
      if(!(hostlist_iterator_destroy__1__1__1__e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = hostlist_iterator_destroy__1__1__1__e;
        lsd_fatal_error("hostlist.c", 2260, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    pi = &i->hl->ilist;
    for( ; !(*pi == ((struct hostlist_iterator *)NULL)); pi = &(*pi)->next)
      if(*pi == i)
      {
        *pi = (*pi)->next;
        break;
      }

    do
    {

    __CPROVER_DUMP_L5:
      ;
      signed int e;
      e=pthread_mutex_unlock(&i->hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("hostlist.c", 2268, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    free((void *)i);
  }

}

// hostlist_iterator_new
// file hostlist.c line 2208
static struct hostlist_iterator * hostlist_iterator_new(void)
{
  struct hostlist_iterator *i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hostlist_iterator) /*40ul*/ );
  i = (struct hostlist_iterator *)return_value_malloc_1;
  if(i == ((struct hostlist_iterator *)NULL))
    return (struct hostlist_iterator *)(void *)0;

  else
  {
    i->hl = (struct hostlist *)(void *)0;
    i->hr = (struct hostrange_components *)(void *)0;
    i->idx = 0;
    i->depth = -1;
    i->next = i;
    return i;
  }
}

// hostlist_iterator_reset
// file hostlist.c line 2243
void hostlist_iterator_reset(struct hostlist_iterator *i)
{
  i->idx = 0;
  i->hr = i->hl->hr[(signed long int)0];
  i->depth = -1;
}

// hostlist_new
// file hostlist.c line 1059
static struct hostlist * hostlist_new(void)
{
  signed int i;
  struct hostlist *new;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hostlist) /*72ul*/ );
  new = (struct hostlist *)return_value_malloc_1;
  void *return_value_malloc_3;
  if(!(new == ((struct hostlist *)NULL)))
  {
    do
    {
      signed int e;
      e=pthread_mutex_init(&new->mutex, (const union anonymous_3 *)(void *)0);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("hostlist.c", 1067, "hostlist mutex init:");
        abort();
      }

    }
    while((_Bool)0);
    return_value_malloc_3=malloc((unsigned long int)16 * sizeof(struct hostrange_components *) /*8ul*/ );
    new->hr = (struct hostrange_components **)return_value_malloc_3;
    if(!(new->hr == ((struct hostrange_components **)NULL)))
    {
      i = 0;
      for( ; !(i >= 16); i = i + 1)
        new->hr[(signed long int)i] = (struct hostrange_components *)(void *)0;
      new->size = 16;
      new->nranges = 0;
      new->nhosts = 0;
      new->ilist = (struct hostlist_iterator *)(void *)0;
      return new;
    }


  fail2:
    ;
    free((void *)new);
  }


fail1:
  ;
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  *return_value___errno_location_4 = 12;
  return (struct hostlist *)(void *)0;
}

// hostlist_next
// file ../../src/common/hostlist.h line 344
char * hostlist_next(struct hostlist_iterator *i)
{
  char *buf = (char *)(void *)0;
  char suffix[16l];
  signed int len = 0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_next__1__1__1__e;
    hostlist_next__1__1__1__e=pthread_mutex_lock(&i->hl->mutex);
    if(!(hostlist_next__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_next__1__1__1__e;
      lsd_fatal_error("hostlist.c", 2314, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  _iterator_advance(i);
  if(!(i->hl->nranges + -1 >= i->idx))
  {
    do
    {

    __CPROVER_DUMP_L3:
      ;
      signed int e;
      e=pthread_mutex_unlock(&i->hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("hostlist.c", 2318, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return (char *)(void *)0;
  }

  else
  {
    suffix[(signed long int)0] = (char)0;
    if(i->hr->singlehost == 0u)
      snprintf(suffix, (unsigned long int)15, "%0*lu", i->hr->width, i->hr->lo + (unsigned long int)i->depth);

    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(i->hr->prefix);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(suffix);
    len = (signed int)(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)1);
    void *return_value_malloc_6;
    return_value_malloc_6=malloc((unsigned long int)len);
    buf = (char *)return_value_malloc_6;
    if(buf == ((char *)NULL))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 12;
      return (char *)(void *)0;
    }

    buf[(signed long int)0] = (char)0;
    strcat(buf, i->hr->prefix);
    strcat(buf, suffix);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      signed int hostlist_next__1__4__1__e;
      hostlist_next__1__4__1__e=pthread_mutex_unlock(&i->hl->mutex);
      if(!(hostlist_next__1__4__1__e == 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7 = hostlist_next__1__4__1__e;
        lsd_fatal_error("hostlist.c", 2335, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return buf;
  }
}

// hostlist_next_range
// file hostlist.c line 2339
char * hostlist_next_range(struct hostlist_iterator *i)
{
  char buf[1025l];
  signed int j;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_next_range__1__1__1__e;
    hostlist_next_range__1__1__1__e=pthread_mutex_lock(&i->hl->mutex);
    if(!(hostlist_next_range__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_next_range__1__1__1__e;
      lsd_fatal_error("hostlist.c", 2346, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  _iterator_advance_range(i);
  if(!(i->hl->nranges + -1 >= i->idx))
  {
    do
    {

    __CPROVER_DUMP_L3:
      ;
      signed int e;
      e=pthread_mutex_unlock(&i->hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("hostlist.c", 2351, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return (char *)(void *)0;
  }

  else
  {
    j = i->idx;
    _get_bracketed_list(i->hl, &j, (const unsigned long int)1024, buf);
    do
    {

    __CPROVER_DUMP_L6:
      ;
      signed int hostlist_next_range__1__3__1__e;
      hostlist_next_range__1__3__1__e=pthread_mutex_unlock(&i->hl->mutex);
      if(!(hostlist_next_range__1__3__1__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = hostlist_next_range__1__3__1__e;
        lsd_fatal_error("hostlist.c", 2358, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    char *return_value_strdup_4;
    return_value_strdup_4=strdup(buf);
    return return_value_strdup_4;
  }
}

// hostlist_nth
// file hostlist.c line 1844
char * hostlist_nth(struct hostlist *hl, signed int n)
{
  char *hostlist_nth__1__host = (char *)(void *)0;
  signed int i;
  signed int count;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1849, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  count = 0;
  i = 0;
  for( ; !(i >= hl->nranges); i = i + 1)
  {
    signed int num_in_range;
    unsigned long int return_value_hostrange_count_2;
    return_value_hostrange_count_2=hostrange_count(hl->hr[(signed long int)i]);
    num_in_range = (signed int)return_value_hostrange_count_2;
    if(-1 + num_in_range + count >= n)
    {
      hostlist_nth__1__host=_hostrange_string(hl->hr[(signed long int)i], n - count);
      break;
    }

    else
      count = count + num_in_range;
  }
  do
  {

  __CPROVER_DUMP_L6:
    ;
    signed int hostlist_nth__1__3__1__e;
    hostlist_nth__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_nth__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = hostlist_nth__1__3__1__e;
      lsd_fatal_error("hostlist.c", 1861, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return hostlist_nth__1__host;
}

// hostlist_pop
// file ../../src/common/hostlist.h line 165
char * hostlist_pop(struct hostlist *hl)
{
  char *hostlist_pop__1__host = (char *)(void *)0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_pop__1__1__1__e;
    hostlist_pop__1__1__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_pop__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_pop__1__1__1__e;
      lsd_fatal_error("hostlist.c", 1668, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  if(hl->nhosts >= 1)
  {
    struct hostrange_components *hr = hl->hr[(signed long int)(hl->nranges - 1)];
    hostlist_pop__1__host=hostrange_pop(hr);
    hl->nhosts = hl->nhosts - 1;
    signed int return_value_hostrange_empty_2;
    return_value_hostrange_empty_2=hostrange_empty(hr);
    if(!(return_value_hostrange_empty_2 == 0))
    {
      hl->nranges = hl->nranges - 1;
      hostrange_destroy(hl->hr[(signed long int)hl->nranges]);
      hl->hr[(signed long int)hl->nranges] = (struct hostrange_components *)(void *)0;
    }

  }

  do
  {

  __CPROVER_DUMP_L4:
    ;
    signed int e;
    e=pthread_mutex_unlock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = e;
      lsd_fatal_error("hostlist.c", 1678, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return hostlist_pop__1__host;
}

// hostlist_pop_range
// file hostlist.c line 1728
char * hostlist_pop_range(struct hostlist *hl)
{
  signed int i;
  char buf[1025l];
  struct hostlist *hltmp;
  struct hostrange_components *tail;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1735, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_3;
  if(!(hl->nranges >= 1))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    hltmp=hostlist_new();
    tmp_if_expr_3 = !(hltmp != ((struct hostlist *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_hostrange_within_range_4;
  if(tmp_if_expr_3)
  {
    do
    {

    __CPROVER_DUMP_L5:
      ;
      signed int hostlist_pop_range__1__2__1__1__e;
      hostlist_pop_range__1__2__1__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_pop_range__1__2__1__1__e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = hostlist_pop_range__1__2__1__1__e;
        lsd_fatal_error("hostlist.c", 1737, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return (char *)(void *)0;
  }

  else
  {
    i = hl->nranges - 2;
    tail = hl->hr[(signed long int)(hl->nranges - 1)];
    for( ; i >= 0; i = i - 1)
    {
      return_value_hostrange_within_range_4=hostrange_within_range(tail, hl->hr[(signed long int)i]);
      if(return_value_hostrange_within_range_4 == 0)
        break;

    }
    i = i + 1;
    for( ; !(i >= hl->nranges); i = i + 1)
    {
      hostlist_push_range(hltmp, hl->hr[(signed long int)i]);
      hostrange_destroy(hl->hr[(signed long int)i]);
      hl->hr[(signed long int)i] = (struct hostrange_components *)(void *)0;
    }
    hl->nhosts = hl->nhosts - hltmp->nhosts;
    hl->nranges = hl->nranges - hltmp->nranges;
    do
    {

    __CPROVER_DUMP_L12:
      ;
      signed int hostlist_pop_range__1__4__1__e;
      hostlist_pop_range__1__4__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_pop_range__1__4__1__e == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = hostlist_pop_range__1__4__1__e;
        lsd_fatal_error("hostlist.c", 1754, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    hostlist_ranged_string(hltmp, (unsigned long int)1024, buf);
    hostlist_destroy(hltmp);
    char *return_value_strdup_6;
    return_value_strdup_6=strdup(buf);
    return return_value_strdup_6;
  }
}

// hostlist_push
// file ../../src/common/hostlist.h line 133
signed int hostlist_push(struct hostlist *hl, const char *hosts)
{
  struct hostlist *new;
  signed int retval;
  if(hosts == ((const char *)NULL))
    return 0;

  else
  {
    new=hostlist_create(hosts);
    if(new == ((struct hostlist *)NULL))
      return 0;

    else
    {
      do
      {
        signed int e;
        e=pthread_mutex_lock(&new->mutex);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = e;
          lsd_fatal_error("hostlist.c", 1614, "hostlist mutex lock:");
          abort();
        }

      }
      while((_Bool)0);
      retval = new->nhosts;
      do
      {
        signed int hostlist_push__1__2__e;
        hostlist_push__1__2__e=pthread_mutex_unlock(&new->mutex);
        if(!(hostlist_push__1__2__e == 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = hostlist_push__1__2__e;
          lsd_fatal_error("hostlist.c", 1616, "hostlist mutex unlock:");
          abort();
        }

      }
      while((_Bool)0);
      hostlist_push_list(hl, new);
      hostlist_destroy(new);
      return retval;
    }
  }
}

// hostlist_push_host
// file hostlist.c line 1622
signed int hostlist_push_host(struct hostlist *hl, const char *str)
{
  struct hostrange_components *hr;
  struct hostname_components *hn;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    hn=hostname_create(str);
    signed int return_value_hostname_suffix_is_valid_2;
    return_value_hostname_suffix_is_valid_2=hostname_suffix_is_valid(hn);
    if(!(return_value_hostname_suffix_is_valid_2 == 0))
    {
      signed int return_value_hostname_suffix_width_1;
      return_value_hostname_suffix_width_1=hostname_suffix_width(hn);
      hr=hostrange_create(hn->prefix, hn->num, hn->num, return_value_hostname_suffix_width_1);
    }

    else
      hr=hostrange_create_single(str);
    hostlist_push_range(hl, hr);
    hostrange_destroy(hr);
    hostname_destroy(hn);
    return 1;
  }
}

// hostlist_push_hr
// file hostlist.c line 1170
static signed int hostlist_push_hr(struct hostlist *hl, char *prefix, unsigned long int lo, unsigned long int hi, signed int width)
{
  struct hostrange_components *hr;
  hr=hostrange_create(prefix, lo, hi, width);
  signed int retval;
  retval=hostlist_push_range(hl, hr);
  hostrange_destroy(hr);
  return retval;
}

// hostlist_push_list
// file ../../src/common/hostlist.h line 154
signed int hostlist_push_list(struct hostlist *h1, struct hostlist *h2)
{
  signed int i;
  signed int n = 0;
  signed int return_value_hostlist_push_range_2;
  if(h2 == ((struct hostlist *)NULL))
    return 0;

  else
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      signed int e;
      e=pthread_mutex_lock(&h2->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("hostlist.c", 1653, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= h2->nranges); i = i + 1)
    {
      return_value_hostlist_push_range_2=hostlist_push_range(h1, h2->hr[(signed long int)i]);
      n = n + return_value_hostlist_push_range_2;
    }
    do
    {

    __CPROVER_DUMP_L5:
      ;
      signed int hostlist_push_list__1__3__1__e;
      hostlist_push_list__1__3__1__e=pthread_mutex_unlock(&h2->mutex);
      if(!(hostlist_push_list__1__3__1__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = hostlist_push_list__1__3__1__e;
        lsd_fatal_error("hostlist.c", 1658, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    return n;
  }
}

// hostlist_push_range
// file hostlist.c line 1130
static signed int hostlist_push_range(struct hostlist *hl, struct hostrange_components *hr)
{
  struct hostrange_components *tail;
  signed int retval;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_push_range__1__1__1__e;
    hostlist_push_range__1__1__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_push_range__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_push_range__1__1__1__e;
      lsd_fatal_error("hostlist.c", 1136, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  struct hostrange_components *tmp_if_expr_2;
  if(hl->nranges >= 1)
    tmp_if_expr_2 = hl->hr[(signed long int)(hl->nranges - 1)];

  else
    tmp_if_expr_2 = hl->hr[(signed long int)0];
  tail = tmp_if_expr_2;
  signed int return_value_hostlist_expand_3;
  if(hl->size == hl->nranges)
  {
    return_value_hostlist_expand_3=hostlist_expand(hl);
    if(return_value_hostlist_expand_3 == 0)
      goto error;

  }

  _Bool tmp_if_expr_6;
  signed int return_value_hostrange_prefix_cmp_5;
  if(hl->nranges >= 1)
  {
    return_value_hostrange_prefix_cmp_5=hostrange_prefix_cmp(tail, hr);
    tmp_if_expr_6 = return_value_hostrange_prefix_cmp_5 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = tail->hi == hr->lo - (unsigned long int)1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_9;
  signed int return_value_hostrange_width_combine_8;
  if(tmp_if_expr_7)
  {
    return_value_hostrange_width_combine_8=hostrange_width_combine(tail, hr);
    tmp_if_expr_9 = return_value_hostrange_width_combine_8 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  signed int tmp_post_4;
  if(tmp_if_expr_9)
    tail->hi = hr->hi;

  else
  {
    tmp_post_4 = hl->nranges;
    hl->nranges = hl->nranges + 1;
    hl->hr[(signed long int)tmp_post_4]=hostrange_copy(hr);
    if(hl->hr[(signed long int)tmp_post_4] == ((struct hostrange_components *)NULL))
      goto error;

  }
  unsigned long int return_value_hostrange_count_10;
  return_value_hostrange_count_10=hostrange_count(hr);
  hl->nhosts = hl->nhosts + (signed int)return_value_hostrange_count_10;
  retval = hl->nhosts;
  do
  {

  __CPROVER_DUMP_L14:
    ;
    signed int hostlist_push_range__1__4__1__e;
    hostlist_push_range__1__4__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_push_range__1__4__1__e == 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      *return_value___errno_location_11 = hostlist_push_range__1__4__1__e;
      lsd_fatal_error("hostlist.c", 1155, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return retval;
  do
  {

  error:
    ;
    signed int e;
    e=pthread_mutex_unlock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_12;
      return_value___errno_location_12=__errno_location();
      *return_value___errno_location_12 = e;
      lsd_fatal_error("hostlist.c", 1160, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return -1;
}

// hostlist_ranged_string
// file ../../src/common/hostlist.h line 283
signed long int hostlist_ranged_string(struct hostlist *hl, unsigned long int n, char *buf)
{
  signed int i = 0;
  signed int len = 0;
  signed int truncated = 0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 2187, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  signed int tmp_post_3;
  while(!(i >= hl->nranges))
  {
    if((unsigned long int)len >= n)
      break;

    signed int return_value__get_bracketed_list_2;
    return_value__get_bracketed_list_2=_get_bracketed_list(hl, &i, n - (unsigned long int)len, buf + (signed long int)len);
    len = len + return_value__get_bracketed_list_2;
    if(len >= 1 && !((unsigned long int)len >= n))
    {
      if(!(i >= hl->nranges))
      {
        tmp_post_3 = len;
        len = len + 1;
        buf[(signed long int)tmp_post_3] = (char)44;
      }

    }

  }
  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int hostlist_ranged_string__1__3__1__e;
    hostlist_ranged_string__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_ranged_string__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = hostlist_ranged_string__1__3__1__e;
      lsd_fatal_error("hostlist.c", 2193, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  if((unsigned long int)len >= n)
  {
    truncated = 1;
    if(n >= 1ul)
      buf[(signed long int)(n - (unsigned long int)1)] = (char)0;

  }

  else
    buf[(signed long int)(len > 0 ? len : 0)] = (char)0;
  return (signed long int)(truncated != 0 ? -1 : len);
}

// hostlist_register_rcmd
// file rcmd.c line 195
static signed int hostlist_register_rcmd(const char *hosts, struct rcmd_module *rmod, char *user)
{
  struct hostlist *hl;
  hl=hostlist_create(hosts);
  char *hostlist_register_rcmd__1__host;
  if(hl == ((struct hostlist *)NULL))
    return -1;

  else
  {
    if(host_info_list == ((struct list *)NULL))
      host_info_list=list_create((void (*)(void *))node_rcmd_info_destroy);

    do
    {
      hostlist_register_rcmd__1__host=hostlist_pop(hl);
      if(hostlist_register_rcmd__1__host == ((char *)NULL))
        break;

      struct node_rcmd_info *n = (struct node_rcmd_info *)(void *)0;
      void *return_value_list_find_first_1;
      return_value_list_find_first_1=list_find_first(host_info_list, (signed int (*)(void *, void *))find_host, (void *)hostlist_register_rcmd__1__host);
      if(return_value_list_find_first_1 == NULL)
      {
        n=node_rcmd_info_create(hostlist_register_rcmd__1__host, user, rmod);
        if(n == ((struct node_rcmd_info *)NULL))
          errx("Failed to create rcmd info for host \"%s\"\n", hostlist_register_rcmd__1__host);

        list_append(host_info_list, (void *)n);
        free((void *)hostlist_register_rcmd__1__host);
      }

    }
    while((_Bool)1);
    hostlist_destroy(hl);
    return 0;
  }
}

// hostlist_remove
// file ../../src/common/hostlist.h line 363
signed int hostlist_remove(struct hostlist_iterator *i)
{
  struct hostrange_components *new;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&i->hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 2368, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  new=hostrange_delete_host(i->hr, i->hr->lo + (unsigned long int)i->depth);
  signed int return_value_hostrange_empty_2;
  if(!(new == ((struct hostrange_components *)NULL)))
  {
    hostlist_insert_range(i->hl, new, i->idx + 1);
    hostrange_destroy(new);
    i->idx = i->idx + 1;
    i->hr = i->hl->hr[(signed long int)i->idx];
    i->depth = -1;
  }

  else
  {
    return_value_hostrange_empty_2=hostrange_empty(i->hr);
    if(!(return_value_hostrange_empty_2 == 0))
      hostlist_delete_range(i->hl, i->idx);

    else
      i->depth = i->depth - 1;
  }
  i->hl->nhosts = i->hl->nhosts - 1;
  do
  {

  __CPROVER_DUMP_L6:
    ;
    signed int hostlist_remove__1__4__1__e;
    hostlist_remove__1__4__1__e=pthread_mutex_unlock(&i->hl->mutex);
    if(!(hostlist_remove__1__4__1__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = hostlist_remove__1__4__1__e;
      lsd_fatal_error("hostlist.c", 2381, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return 1;
}

// hostlist_resize
// file hostlist.c line 1097
static signed int hostlist_resize(struct hostlist *hl, unsigned long int newsize)
{
  signed int i;
  unsigned long int oldsize = (unsigned long int)hl->size;
  hl->size = (signed int)newsize;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)hl->hr, (unsigned long int)hl->size * sizeof(struct hostrange_components *) /*8ul*/ );
  hl->hr = (struct hostrange_components **)return_value_realloc_1;
  if(hl->hr == ((struct hostrange_components **)NULL))
    return 0;

  else
  {
    i = (signed int)oldsize;
    for( ; !((unsigned long int)i >= newsize); i = i + 1)
      hl->hr[(signed long int)i] = (struct hostrange_components *)(void *)0;
    return 1;
  }
}

// hostlist_shift
// file ../../src/common/hostlist.h line 178
char * hostlist_shift(struct hostlist *hl)
{
  char *hostlist_shift__1__host = (char *)(void *)0;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1707, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  if(hl->nhosts >= 1)
  {
    struct hostrange_components *hr = hl->hr[(signed long int)0];
    hostlist_shift__1__host=hostrange_shift(hr);
    hl->nhosts = hl->nhosts - 1;
    signed int return_value_hostrange_empty_2;
    return_value_hostrange_empty_2=hostrange_empty(hr);
    if(!(return_value_hostrange_empty_2 == 0))
      hostlist_delete_range(hl, 0);

    else
      hostlist_shift_iterators(hl, 0, 0, 0);
  }

  do
  {

  __CPROVER_DUMP_L5:
    ;
    signed int hostlist_shift__1__3__1__e;
    hostlist_shift__1__3__1__e=pthread_mutex_unlock(&hl->mutex);
    if(!(hostlist_shift__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = hostlist_shift__1__3__1__e;
      lsd_fatal_error("hostlist.c", 1722, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  return hostlist_shift__1__host;
}

// hostlist_shift_iterators
// file hostlist.c line 1685
static void hostlist_shift_iterators(struct hostlist *hl, signed int idx, signed int depth, signed int n)
{
  struct hostlist_iterator *i = hl->ilist;
  signed int tmp_if_expr_1;
  for( ; !(i == ((struct hostlist_iterator *)NULL)); i = i->next)
    if(n == 0)
    {
      if(i->idx == idx)
      {
        if(i->depth >= depth)
        {
          if(i->depth >= 0)
            tmp_if_expr_1 = i->depth - 1;

          else
            tmp_if_expr_1 = -1;
          i->depth = tmp_if_expr_1;
        }

      }

    }

    else
      if(i->idx >= idx)
      {
        i->idx = i->idx - n;
        if(i->idx >= 0)
          i->hr = i->hl->hr[(signed long int)i->idx];

        else
          hostlist_iterator_reset(i);
      }

}

// hostlist_shift_range
// file hostlist.c line 1761
char * hostlist_shift_range(struct hostlist *hl)
{
  signed int i;
  char buf[1024l];
  struct hostlist *hltmp;
  hltmp=hostlist_new();
  _Bool tmp_if_expr_4;
  signed int return_value_hostrange_within_range_3;
  if(hltmp == ((struct hostlist *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      signed int e;
      e=pthread_mutex_lock(&hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("hostlist.c", 1769, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    if(hl->nranges == 0)
    {
      hostlist_destroy(hltmp);
      do
      {

      __CPROVER_DUMP_L3:
        ;
        signed int hostlist_shift_range__1__2__1__1__e;
        hostlist_shift_range__1__2__1__1__e=pthread_mutex_unlock(&hl->mutex);
        if(!(hostlist_shift_range__1__2__1__1__e == 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = hostlist_shift_range__1__2__1__1__e;
          lsd_fatal_error("hostlist.c", 1773, "hostlist mutex unlock:");
          abort();
        }

      }
      while((_Bool)0);
      return (char *)(void *)0;
    }

    else
    {
      i = 0;
      do
      {
        hostlist_push_range(hltmp, hl->hr[(signed long int)i]);
        hostrange_destroy(hl->hr[(signed long int)i]);
        i = i + 1;
        if(!(i >= hl->nranges))
        {
          return_value_hostrange_within_range_3=hostrange_within_range(hltmp->hr[(signed long int)0], hl->hr[(signed long int)i]);
          tmp_if_expr_4 = return_value_hostrange_within_range_3 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
      }
      while(tmp_if_expr_4);
      hostlist_shift_iterators(hl, i, 0, hltmp->nranges);
      for( ; !(i >= hl->nranges); i = i + 1)
      {
        hl->hr[(signed long int)(i - hltmp->nranges)] = hl->hr[(signed long int)i];
        hl->hr[(signed long int)i] = (struct hostrange_components *)(void *)0;
      }
      hl->nhosts = hl->nhosts - hltmp->nhosts;
      hl->nranges = hl->nranges - hltmp->nranges;
      do
      {

      __CPROVER_DUMP_L11:
        ;
        signed int hostlist_shift_range__1__5__1__e;
        hostlist_shift_range__1__5__1__e=pthread_mutex_unlock(&hl->mutex);
        if(!(hostlist_shift_range__1__5__1__e == 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          *return_value___errno_location_5 = hostlist_shift_range__1__5__1__e;
          lsd_fatal_error("hostlist.c", 1794, "hostlist mutex unlock:");
          abort();
        }

      }
      while((_Bool)0);
      hostlist_ranged_string(hltmp, (unsigned long int)1024, buf);
      hostlist_destroy(hltmp);
      char *return_value_strdup_6;
      return_value_strdup_6=strdup(buf);
      return return_value_strdup_6;
    }
  }
}

// hostlist_sort
// file hostlist.c line 1951
void hostlist_sort(struct hostlist *hl)
{
  struct hostlist_iterator *i;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 1954, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  if(!(hl->nranges >= 2))
    do
    {

    __CPROVER_DUMP_L3:
      ;
      signed int hostlist_sort__1__2__1__1__e;
      hostlist_sort__1__2__1__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_sort__1__2__1__1__e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = hostlist_sort__1__2__1__1__e;
        lsd_fatal_error("hostlist.c", 1957, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);

  else
  {
    qsort((void *)hl->hr, (unsigned long int)hl->nranges, sizeof(struct hostrange_components *) /*8ul*/ , _cmp);
    i = hl->ilist;
    for( ; !(i == ((struct hostlist_iterator *)NULL)); i = i->next)
      hostlist_iterator_reset(i);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      signed int hostlist_sort__1__4__1__e;
      hostlist_sort__1__4__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_sort__1__4__1__e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = hostlist_sort__1__4__1__e;
        lsd_fatal_error("hostlist.c", 1967, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    hostlist_coalesce(hl);
  }
}

// hostlist_uniq
// file hostlist.c line 2068
void hostlist_uniq(struct hostlist *hl)
{
  signed int i = 1;
  struct hostlist_iterator *hli;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int hostlist_uniq__1__1__1__e;
    hostlist_uniq__1__1__1__e=pthread_mutex_lock(&hl->mutex);
    if(!(hostlist_uniq__1__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = hostlist_uniq__1__1__1__e;
      lsd_fatal_error("hostlist.c", 2072, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  if(!(hl->nranges >= 2))
    do
    {

    __CPROVER_DUMP_L3:
      ;
      signed int e;
      e=pthread_mutex_unlock(&hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = e;
        lsd_fatal_error("hostlist.c", 2074, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);

  else
  {
    qsort((void *)hl->hr, (unsigned long int)hl->nranges, sizeof(struct hostrange_components *) /*8ul*/ , _cmp);
    while(!(i >= hl->nranges))
    {
      signed int return_value__attempt_range_join_3;
      return_value__attempt_range_join_3=_attempt_range_join(hl, i);
      if(!(return_value__attempt_range_join_3 >= 0))
        i = i + 1;

    }
    hli = hl->ilist;
    for( ; !(hli == ((struct hostlist_iterator *)NULL)); hli = hli->next)
      hostlist_iterator_reset(hli);
    do
    {

    __CPROVER_DUMP_L10:
      ;
      signed int hostlist_uniq__1__5__1__e;
      hostlist_uniq__1__5__1__e=pthread_mutex_unlock(&hl->mutex);
      if(!(hostlist_uniq__1__5__1__e == 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = hostlist_uniq__1__5__1__e;
        lsd_fatal_error("hostlist.c", 2088, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
  }
}

// hostname_create
// file hostlist.c line 519
static struct hostname_components * hostname_create(const char *hostname)
{
  signed int idx;
  idx=host_prefix_end(hostname);
  struct hostname_components *return_value_hostname_create_with_suffix_1;
  return_value_hostname_create_with_suffix_1=hostname_create_with_suffix(hostname, idx);
  return return_value_hostname_create_with_suffix_1;
}

// hostname_create_with_suffix
// file hostlist.c line 466
static struct hostname_components * hostname_create_with_suffix(const char *hostname, signed int idx)
{
  struct hostname_components *hn = (struct hostname_components *)(void *)0;
  char *p = ((char *)NULL);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct hostname_components) /*32ul*/ );
  hn = (struct hostname_components *)return_value_malloc_2;
  if(hn == ((struct hostname_components *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    return (struct hostname_components *)(void *)0;
  }

  hn->hostname=strdup(hostname);
  if(hn->hostname == ((char *)NULL))
  {
    free((void *)hn);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 12;
    return (struct hostname_components *)(void *)0;
  }

  hn->num = (unsigned long int)0;
  hn->prefix = (char *)(void *)0;
  hn->suffix = (char *)(void *)0;
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(hostname);
  _Bool tmp_if_expr_9;
  if((unsigned long int)idx == return_value_strlen_5 + 18446744073709551615ul)
  {
    hn->prefix=strdup(hostname);
    if(hn->prefix == ((char *)NULL))
    {
      hostname_destroy(hn);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 12;
      return (struct hostname_components *)(void *)0;
    }

    return hn;
  }

  else
  {
    hn->suffix = hn->hostname + (signed long int)idx + (signed long int)1;
    hn->num=strtoul(hn->suffix, &p, 10);
    if((signed int)*p == 0)
      tmp_if_expr_9 = hn->num <= (unsigned long int)(1 << 25) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
    {
      void *return_value_malloc_7;
      return_value_malloc_7=malloc((unsigned long int)(idx + 2) * sizeof(char) /*1ul*/ );
      hn->prefix = (char *)return_value_malloc_7;
      if(hn->prefix == ((char *)NULL))
      {
        hostname_destroy(hn);
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 12;
        return (struct hostname_components *)(void *)0;
      }

      memcpy((void *)hn->prefix, (const void *)hostname, (unsigned long int)(idx + 1));
      hn->prefix[(signed long int)(idx + 1)] = (char)0;
    }

    else
    {
      hn->prefix=strdup(hostname);
      if(hn->prefix == ((char *)NULL))
      {
        hostname_destroy(hn);
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        *return_value___errno_location_8 = 12;
        return (struct hostname_components *)(void *)0;
      }

      hn->suffix = (char *)(void *)0;
    }
    return hn;
  }
}

// hostname_destroy
// file hostlist.c line 527
static void hostname_destroy(struct hostname_components *hn)
{
  if(!(hn == ((struct hostname_components *)NULL)))
  {
    hn->suffix = (char *)(void *)0;
    if(!(hn->hostname == ((char *)NULL)))
      free((void *)hn->hostname);

    if(!(hn->prefix == ((char *)NULL)))
      free((void *)hn->prefix);

    free((void *)hn);
  }

}

// hostname_suffix_is_valid
// file hostlist.c line 541
static signed int hostname_suffix_is_valid(struct hostname_components *hn)
{
  return (signed int)(hn->suffix != (char *)(void *)0);
}

// hostname_suffix_width
// file hostlist.c line 548
static signed int hostname_suffix_width(struct hostname_components *hn)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(hn->suffix);
  return (signed int)return_value_strlen_1;
}

// hostrange_cmp
// file hostlist.c line 696
static signed int hostrange_cmp(struct hostrange_components *h1, struct hostrange_components *h2)
{
  signed int retval;
  retval=hostrange_prefix_cmp(h1, h2);
  signed int return_value_hostrange_width_combine_1;
  unsigned long int tmp_if_expr_2;
  if(retval == 0)
  {
    return_value_hostrange_width_combine_1=hostrange_width_combine(h1, h2);
    if(!(return_value_hostrange_width_combine_1 == 0))
      tmp_if_expr_2 = h1->lo - h2->lo;

    else
      tmp_if_expr_2 = (unsigned long int)(h1->width - h2->width);
    retval = (signed int)tmp_if_expr_2;
  }

  return retval;
}

// hostrange_copy
// file hostlist.c line 639
static struct hostrange_components * hostrange_copy(struct hostrange_components *hr)
{
  struct hostrange_components *return_value_hostrange_create_single_1;
  struct hostrange_components *return_value_hostrange_create_2;
  if(!(hr->singlehost == 0u))
  {
    return_value_hostrange_create_single_1=hostrange_create_single(hr->prefix);
    return return_value_hostrange_create_single_1;
  }

  else
  {
    return_value_hostrange_create_2=hostrange_create(hr->prefix, hr->lo, hr->hi, hr->width);
    return return_value_hostrange_create_2;
  }
}

// hostrange_count
// file hostlist.c line 628
static unsigned long int hostrange_count(struct hostrange_components *hr)
{
  if(!(hr->singlehost == 0u))
    return (unsigned long int)1;

  else
    return (hr->hi - hr->lo) + (unsigned long int)1;
}

// hostrange_create
// file hostlist.c line 599
static struct hostrange_components * hostrange_create(char *prefix, unsigned long int lo, unsigned long int hi, signed int width)
{
  struct hostrange_components *new;
  new=hostrange_new();
  if(!(new == ((struct hostrange_components *)NULL)))
  {
    new->prefix=strdup(prefix);
    if(!(new->prefix == ((char *)NULL)))
    {
      new->lo = lo;
      new->hi = hi;
      new->width = width;
      new->singlehost = (unsigned int)0;
      return new;
    }


  error2:
    ;
    free((void *)new);
  }


error1:
  ;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 12;
  return (struct hostrange_components *)(void *)0;
}

// hostrange_create_single
// file hostlist.c line 570
static struct hostrange_components * hostrange_create_single(const char *prefix)
{
  struct hostrange_components *new;
  new=hostrange_new();
  if(!(new == ((struct hostrange_components *)NULL)))
  {
    new->prefix=strdup(prefix);
    if(!(new->prefix == ((char *)NULL)))
    {
      new->singlehost = (unsigned int)1;
      new->lo = (unsigned long int)0L;
      new->hi = (unsigned long int)0L;
      new->width = 0;
      return new;
    }


  error2:
    ;
    free((void *)new);
  }


error1:
  ;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 12;
  return (struct hostrange_components *)(void *)0;
}

// hostrange_delete_host
// file hostlist.c line 668
static struct hostrange_components * hostrange_delete_host(struct hostrange_components *hr, unsigned long int n)
{
  struct hostrange_components *new = (struct hostrange_components *)(void *)0;
  if(n == hr->lo)
    hr->lo = hr->lo + 1ul;

  else
    if(n == hr->hi)
      hr->hi = hr->hi - 1ul;

    else
    {
      new=hostrange_copy(hr);
      if(new == ((struct hostrange_components *)NULL))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 12;
        return (struct hostrange_components *)(void *)0;
      }

      hr->hi = n - (unsigned long int)1;
      new->lo = n + (unsigned long int)1;
    }
  return new;
}

// hostrange_destroy
// file hostlist.c line 653
static void hostrange_destroy(struct hostrange_components *hr)
{
  if(!(hr == ((struct hostrange_components *)NULL)))
  {
    if(!(hr->prefix == ((char *)NULL)))
      free((void *)hr->prefix);

    free((void *)hr);
  }

}

// hostrange_empty
// file hostlist.c line 765
static signed int hostrange_empty(struct hostrange_components *hr)
{
  _Bool tmp_if_expr_1;
  if(!(hr->hi >= hr->lo))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = hr->hi == (unsigned long int)-1 ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// hostrange_hn_within
// file hostlist.c line 896
static signed int hostrange_hn_within(struct hostrange_components *hr, struct hostname_components *hn)
{
  signed int len_hr;
  signed int len_hn;
  signed int hostrange_hn_within__1__width;
  if(!(hr->singlehost == 0u))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(hn->hostname, hr->prefix);
    if(return_value_strcmp_1 == 0)
      return 0;

    else
      return -1;
  }

  signed int return_value_hostname_suffix_is_valid_2;
  return_value_hostname_suffix_is_valid_2=hostname_suffix_is_valid(hn);
  const unsigned short int **return_value___ctype_b_loc_6;
  signed int return_value_strcmp_8;
  if(return_value_hostname_suffix_is_valid_2 == 0)
    return -1;

  else
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(hn->prefix);
    len_hn = (signed int)return_value_strlen_3;
    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp(hr->prefix, hn->prefix, (unsigned long int)len_hn);
    if(!(return_value_strncmp_4 == 0))
      return -1;

    else
    {
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(hr->prefix);
      len_hr = (signed int)return_value_strlen_5;
      hostrange_hn_within__1__width=hostname_suffix_width(hn);
      if(hostrange_hn_within__1__width >= 2 && !(len_hn >= len_hr))
      {
        return_value___ctype_b_loc_6=__ctype_b_loc();
        if(!((2048 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)hr->prefix[(signed long int)(len_hr + -1)]]) == 0))
        {
          if(hr->prefix[(signed long int)len_hn] == *hn->suffix)
          {
            signed int rc;
            struct hostname_components *h;
            h=hostname_create_with_suffix(hn->hostname, len_hn);
            rc=hostrange_hn_within(hr, h);
            hostname_destroy(h);
            return rc;
          }

        }

      }

      if(len_hr == len_hn)
      {
        return_value_strcmp_8=strcmp(hn->prefix, hr->prefix);
        if(return_value_strcmp_8 == 0)
        {
          if(hr->hi >= hn->num)
          {
            if(hn->num >= hr->lo)
            {
              signed int width;
              width=hostname_suffix_width(hn);
              signed int return_value__width_equiv_7;
              return_value__width_equiv_7=_width_equiv(hr->lo, &hr->width, hn->num, &width);
              if(return_value__width_equiv_7 == 0)
                return -1;

              return (signed int)(hn->num - hr->lo);
            }

          }

        }

      }

      return -1;
    }
  }
}

// hostrange_intersect
// file hostlist.c line 868
static struct hostrange_components * hostrange_intersect(struct hostrange_components *h1, struct hostrange_components *h2)
{
  struct hostrange_components *new = (struct hostrange_components *)(void *)0;
  _Bool tmp_if_expr_1;
  if(!(h1->singlehost == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = h2->singlehost != 0u ? (_Bool)1 : (_Bool)0;
  signed int return_value_hostrange_width_combine_3;
  unsigned long int tmp_if_expr_2;
  if(tmp_if_expr_1)
    return (struct hostrange_components *)(void *)0;

  else
  {
    signed int return_value_hostrange_prefix_cmp_4;
    return_value_hostrange_prefix_cmp_4=hostrange_prefix_cmp(h1, h2);
    if(return_value_hostrange_prefix_cmp_4 == 0)
    {
      if(!(h2->lo >= h1->hi))
      {
        return_value_hostrange_width_combine_3=hostrange_width_combine(h1, h2);
        if(!(return_value_hostrange_width_combine_3 == 0))
        {
          new=hostrange_copy(h1);
          if(new == ((struct hostrange_components *)NULL))
            return (struct hostrange_components *)(void *)0;

          new->lo = h2->lo;
          if(!(h2->hi >= h1->hi))
            tmp_if_expr_2 = h2->hi;

          else
            tmp_if_expr_2 = h1->hi;
          new->hi = tmp_if_expr_2;
        }

      }

    }

    return new;
  }
}

// hostrange_join
// file hostlist.c line 834
static signed int hostrange_join(struct hostrange_components *h1, struct hostrange_components *h2)
{
  signed int duplicated = -1;
  signed int return_value_hostrange_prefix_cmp_4;
  return_value_hostrange_prefix_cmp_4=hostrange_prefix_cmp(h1, h2);
  signed int return_value_hostrange_width_combine_3;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_hostrange_count_1;
  if(return_value_hostrange_prefix_cmp_4 == 0)
  {
    return_value_hostrange_width_combine_3=hostrange_width_combine(h1, h2);
    if(!(return_value_hostrange_width_combine_3 == 0))
    {
      if(!(h1->singlehost == 0u))
        tmp_if_expr_2 = h2->singlehost != 0u ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        duplicated = 1;

      else
        if(h1->hi == h2->lo + 18446744073709551615ul)
        {
          h1->hi = h2->hi;
          duplicated = 0;
        }

        else
          if(h1->hi >= h2->lo)
          {
            if(!(h1->hi >= h2->hi))
            {
              duplicated = (signed int)((h1->hi - h2->lo) + (unsigned long int)1);
              h1->hi = h2->hi;
            }

            else
            {
              return_value_hostrange_count_1=hostrange_count(h2);
              duplicated = (signed int)return_value_hostrange_count_1;
            }
          }

    }

  }

  return duplicated;
}

// hostrange_new
// file hostlist.c line 559
static struct hostrange_components * hostrange_new(void)
{
  struct hostrange_components *new;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hostrange_components) /*32ul*/ );
  new = (struct hostrange_components *)return_value_malloc_1;
  if(new == ((struct hostrange_components *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
    return (struct hostrange_components *)(void *)0;
  }

  return new;
}

// hostrange_numstr
// file hostlist.c line 1031
static unsigned long int hostrange_numstr(struct hostrange_components *hr, unsigned long int n, char *buf)
{
  signed int len = 0;
  if(n == 0ul || !(hr->singlehost == 0u))
    return (unsigned long int)0;

  else
  {
    len=snprintf(buf, n, "%0*lu", hr->width, hr->lo);
    if(len >= 0 && !((unsigned long int)len >= n))
    {
      if(!(hr->lo >= hr->hi))
      {
        signed int len2;
        len2=snprintf(buf + (signed long int)len, n - (unsigned long int)len, "-%0*lu", hr->width, hr->hi);
        if(!(len2 >= 0))
          len = -1;

        else
          len = len + len2;
      }

    }

    return (unsigned long int)len;
  }
}

// hostrange_pop
// file hostlist.c line 776
static char * hostrange_pop(struct hostrange_components *hr)
{
  unsigned long int size = (unsigned long int)0;
  char *hostrange_pop__1__host = (char *)(void *)0;
  unsigned long int return_value_hostrange_count_5;
  unsigned long int tmp_post_4;
  if(!(hr->singlehost == 0u))
  {
    hr->lo = hr->lo + 1ul;
    hostrange_pop__1__host=strdup(hr->prefix);
  }

  else
  {
    return_value_hostrange_count_5=hostrange_count(hr);
    if(return_value_hostrange_count_5 >= 1ul)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(hr->prefix);
      size = return_value_strlen_1 + (unsigned long int)hr->width + (unsigned long int)16;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(size * sizeof(char) /*1ul*/ );
      hostrange_pop__1__host = (char *)return_value_malloc_3;
      if(hostrange_pop__1__host == ((char *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 12;
        return (char *)(void *)0;
      }

      tmp_post_4 = hr->hi;
      hr->hi = hr->hi - 1ul;
      snprintf(hostrange_pop__1__host, size, "%s%0*lu", hr->prefix, hr->width, tmp_post_4);
    }

  }
  return hostrange_pop__1__host;
}

// hostrange_prefix_cmp
// file hostlist.c line 719
static signed int hostrange_prefix_cmp(struct hostrange_components *h1, struct hostrange_components *h2)
{
  signed int retval;
  signed int tmp_if_expr_1;
  if(h1 == ((struct hostrange_components *)NULL))
    return 1;

  else
    if(h2 == ((struct hostrange_components *)NULL))
      return -1;

    else
    {
      retval=strcmp(h1->prefix, h2->prefix);
      if(retval == 0)
        tmp_if_expr_1 = (signed int)h2->singlehost - (signed int)h1->singlehost;

      else
        tmp_if_expr_1 = retval;
      return tmp_if_expr_1;
    }
}

// hostrange_shift
// file hostlist.c line 798
static char * hostrange_shift(struct hostrange_components *hr)
{
  unsigned long int size = (unsigned long int)0;
  char *hostrange_shift__1__host = (char *)(void *)0;
  unsigned long int return_value_hostrange_count_6;
  unsigned long int tmp_post_5;
  if(!(hr->singlehost == 0u))
  {
    hr->lo = hr->lo + 1ul;
    hostrange_shift__1__host=strdup(hr->prefix);
    if(hostrange_shift__1__host == ((char *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 12;
      return (char *)(void *)0;
    }

  }

  else
  {
    return_value_hostrange_count_6=hostrange_count(hr);
    if(return_value_hostrange_count_6 >= 1ul)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(hr->prefix);
      size = return_value_strlen_2 + (unsigned long int)hr->width + (unsigned long int)16;
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(size * sizeof(char) /*1ul*/ );
      hostrange_shift__1__host = (char *)return_value_malloc_4;
      if(hostrange_shift__1__host == ((char *)NULL))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 12;
        return (char *)(void *)0;
      }

      tmp_post_5 = hr->lo;
      hr->lo = hr->lo + 1ul;
      snprintf(hostrange_shift__1__host, size, "%s%0*lu", hr->prefix, hr->width, tmp_post_5);
    }

  }
  return hostrange_shift__1__host;
}

// hostrange_to_string
// file hostlist.c line 992
static unsigned long int hostrange_to_string(struct hostrange_components *hr, unsigned long int n, char *buf, char *separator)
{
  unsigned long int i;
  signed int truncated = 0;
  signed int len = 0;
  char sep;
  signed int tmp_if_expr_1;
  if(separator == ((char *)NULL))
    tmp_if_expr_1 = 44;

  else
    tmp_if_expr_1 = (signed int)separator[(signed long int)0];
  sep = (char)tmp_if_expr_1;
  signed int return_value_snprintf_2;
  signed int tmp_post_3;
  if(n == 0ul)
    return (unsigned long int)0;

  else
    if(!(hr->singlehost == 0u))
    {
      return_value_snprintf_2=snprintf(buf, n, "%s", hr->prefix);
      return (unsigned long int)return_value_snprintf_2;
    }

    else
    {
      i = hr->lo;
      for( ; hr->hi >= i; i = i + 1ul)
      {
        unsigned long int m = n - (unsigned long int)len <= n ? n - (unsigned long int)len : (unsigned long int)0;
        signed int ret;
        ret=snprintf(buf + (signed long int)len, m, "%s%0*lu", hr->prefix, hr->width, i);
        if((unsigned long int)ret >= m || !(ret >= 0))
        {
          len = (signed int)n;
          truncated = 1;
          break;
        }

        len = len + ret;
        tmp_post_3 = len;
        len = len + 1;
        buf[(signed long int)tmp_post_3] = sep;
      }
      if(!(truncated == 0))
      {
        buf[(signed long int)(n - (unsigned long int)1)] = (char)0;
        return (unsigned long int)-1;
      }

      else
      {
        len = len - 1;
        buf[(signed long int)len] = (char)0;
        return (unsigned long int)len;
      }
    }
}

// hostrange_width_combine
// file hostlist.c line 754
static signed int hostrange_width_combine(struct hostrange_components *h0, struct hostrange_components *h1)
{
  signed int return_value__width_equiv_1;
  return_value__width_equiv_1=_width_equiv(h0->lo, &h0->width, h1->lo, &h1->width);
  return return_value__width_equiv_1;
}

// hostrange_within_range
// file hostlist.c line 740
static signed int hostrange_within_range(struct hostrange_components *h1, struct hostrange_components *h2)
{
  signed int return_value_hostrange_prefix_cmp_2;
  return_value_hostrange_prefix_cmp_2=hostrange_prefix_cmp(h1, h2);
  _Bool tmp_if_expr_1;
  if(return_value_hostrange_prefix_cmp_2 == 0)
  {
    if(!(h1->singlehost == 0u))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = h2->singlehost != 0u ? (_Bool)1 : (_Bool)0;
    return tmp_if_expr_1 ? 0 : 1;
  }

  else
    return 0;
}

// hostset_copy
// file hostlist.c line 2407
struct hostset * hostset_copy(struct hostset * const set)
{
  struct hostset *new;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hostset) /*8ul*/ );
  new = (struct hostset *)return_value_malloc_1;
  if(!(new == ((struct hostset *)NULL)))
  {
    new->hl=hostlist_copy(set->hl);
    if(!(new->hl == ((struct hostlist *)NULL)))
      return new;


  error2:
    ;
    free((void *)new);
  }


error1:
  ;
  return (struct hostset *)(void *)0;
}

// hostset_count
// file hostlist.c line 2579
signed int hostset_count(struct hostset *set)
{
  signed int return_value_hostlist_count_1;
  return_value_hostlist_count_1=hostlist_count(set->hl);
  return return_value_hostlist_count_1;
}

// hostset_create
// file hostlist.c line 2388
struct hostset * hostset_create(const char *hostlist)
{
  struct hostset *new;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct hostset) /*8ul*/ );
  new = (struct hostset *)return_value_malloc_1;
  if(!(new == ((struct hostset *)NULL)))
  {
    new->hl=hostlist_create(hostlist);
    if(!(new->hl == ((struct hostlist *)NULL)))
    {
      hostlist_uniq(new->hl);
      return new;
    }


  error2:
    ;
    free((void *)new);
  }


error1:
  ;
  return (struct hostset *)(void *)0;
}

// hostset_delete
// file hostlist.c line 2549
signed int hostset_delete(struct hostset *set, const char *hosts)
{
  signed int return_value_hostlist_delete_1;
  return_value_hostlist_delete_1=hostlist_delete(set->hl, hosts);
  return return_value_hostlist_delete_1;
}

// hostset_delete_host
// file hostlist.c line 2554
signed int hostset_delete_host(struct hostset *set, const char *hostname)
{
  signed int return_value_hostlist_delete_host_1;
  return_value_hostlist_delete_host_1=hostlist_delete_host(set->hl, hostname);
  return return_value_hostlist_delete_host_1;
}

// hostset_deranged_string
// file hostlist.c line 2589
signed long int hostset_deranged_string(struct hostset *set, unsigned long int n, char *buf)
{
  signed long int return_value_hostlist_deranged_string_1;
  return_value_hostlist_deranged_string_1=hostlist_deranged_string(set->hl, n, buf);
  return return_value_hostlist_deranged_string_1;
}

// hostset_destroy
// file hostlist.c line 2423
void hostset_destroy(struct hostset *set)
{
  if(!(set == ((struct hostset *)NULL)))
  {
    hostlist_destroy(set->hl);
    free((void *)set);
  }

}

// hostset_find_host
// file hostlist.c line 2506
static signed int hostset_find_host(struct hostset *set, const char *host)
{
  signed int i;
  signed int retval = 0;
  struct hostname_components *hn;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    signed int e;
    e=pthread_mutex_lock(&set->hl->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("hostlist.c", 2511, "hostlist mutex lock:");
      abort();
    }

  }
  while((_Bool)0);
  hn=hostname_create(host);
  i = 0;
  for( ; !(i >= set->hl->nranges); i = i + 1)
  {
    signed int return_value_hostrange_hn_within_2;
    return_value_hostrange_hn_within_2=hostrange_hn_within(set->hl->hr[(signed long int)i], hn);
    if(return_value_hostrange_hn_within_2 >= 0)
    {
      retval = 1;
      break;
    }

  }
  do
  {

  done:
    ;
    signed int hostset_find_host__1__3__1__e;
    hostset_find_host__1__3__1__e=pthread_mutex_unlock(&set->hl->mutex);
    if(!(hostset_find_host__1__3__1__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = hostset_find_host__1__3__1__e;
      lsd_fatal_error("hostlist.c", 2520, "hostlist mutex unlock:");
      abort();
    }

  }
  while((_Bool)0);
  hostname_destroy(hn);
  return retval;
}

// hostset_insert
// file hostlist.c line 2487
signed int hostset_insert(struct hostset *set, const char *hosts)
{
  signed int i;
  signed int n = 0;
  struct hostlist *hl;
  hl=hostlist_create(hosts);
  signed int return_value_hostset_insert_range_2;
  if(hl == ((struct hostlist *)NULL))
    return 0;

  else
  {
    hostlist_uniq(hl);
    do
    {

    __CPROVER_DUMP_L2:
      ;
      signed int hostset_insert__1__1__1__e;
      hostset_insert__1__1__1__e=pthread_mutex_lock(&set->hl->mutex);
      if(!(hostset_insert__1__1__1__e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = hostset_insert__1__1__1__e;
        lsd_fatal_error("hostlist.c", 2495, "hostlist mutex lock:");
        abort();
      }

    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= hl->nranges); i = i + 1)
    {
      return_value_hostset_insert_range_2=hostset_insert_range(set, hl->hr[(signed long int)i]);
      n = n + return_value_hostset_insert_range_2;
    }
    do
    {

    __CPROVER_DUMP_L6:
      ;
      signed int e;
      e=pthread_mutex_unlock(&set->hl->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = e;
        lsd_fatal_error("hostlist.c", 2498, "hostlist mutex unlock:");
        abort();
      }

    }
    while((_Bool)0);
    hostlist_destroy(hl);
    return n;
  }
}

// hostset_insert_range
// file hostlist.c line 2435
static signed int hostset_insert_range(struct hostset *set, struct hostrange_components *hr)
{
  signed int i = 0;
  signed int inserted = 0;
  signed int nhosts = 0;
  signed int ndups = 0;
  struct hostlist *hl = set->hl;
  signed int return_value_hostlist_expand_1;
  signed int tmp_post_4;
  if(hl->size == hl->nranges)
  {
    return_value_hostlist_expand_1=hostlist_expand(hl);
    if(!(return_value_hostlist_expand_1 == 0))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    unsigned long int return_value_hostrange_count_2;
    return_value_hostrange_count_2=hostrange_count(hr);
    nhosts = (signed int)return_value_hostrange_count_2;
    i = 0;
    for( ; !(i >= hl->nranges); i = i + 1)
    {
      signed int return_value_hostrange_cmp_3;
      return_value_hostrange_cmp_3=hostrange_cmp(hr, hl->hr[(signed long int)i]);
      if(!(return_value_hostrange_cmp_3 >= 1))
      {
        ndups=hostrange_join(hr, hl->hr[(signed long int)i]);
        if(ndups >= 0)
          hostlist_delete_range(hl, i);

        else
          if(!(ndups >= 0))
            ndups = 0;

        hostlist_insert_range(hl, hr, i);
        if(i >= 1)
        {
          signed int m;
          m=_attempt_range_join(hl, i);
          if(m >= 1)
            ndups = ndups + m;

        }

        hl->nhosts = hl->nhosts + (nhosts - ndups);
        inserted = 1;
        break;
      }

    }
    if(inserted == 0)
    {
      tmp_post_4 = hl->nranges;
      hl->nranges = hl->nranges + 1;
      hl->hr[(signed long int)tmp_post_4]=hostrange_copy(hr);
      hl->nhosts = hl->nhosts + nhosts;
      if(hl->nranges >= 2)
      {
        ndups=_attempt_range_join(hl, hl->nranges - 1);
        if(!(ndups >= 1))
          ndups = 0;

      }

    }

    return nhosts - ndups;
  }
}

// hostset_iterator_create
// file hostlist.c line 2238
struct hostlist_iterator * hostset_iterator_create(struct hostset *set)
{
  struct hostlist_iterator *return_value_hostlist_iterator_create_1;
  return_value_hostlist_iterator_create_1=hostlist_iterator_create(set->hl);
  return return_value_hostlist_iterator_create_1;
}

// hostset_pop
// file hostlist.c line 2564
char * hostset_pop(struct hostset *set)
{
  char *return_value_hostlist_pop_1;
  return_value_hostlist_pop_1=hostlist_pop(set->hl);
  return return_value_hostlist_pop_1;
}

// hostset_pop_range
// file hostlist.c line 2574
char * hostset_pop_range(struct hostset *set)
{
  char *return_value_hostlist_pop_range_1;
  return_value_hostlist_pop_range_1=hostlist_pop_range(set->hl);
  return return_value_hostlist_pop_range_1;
}

// hostset_ranged_string
// file hostlist.c line 2584
signed long int hostset_ranged_string(struct hostset *set, unsigned long int n, char *buf)
{
  signed long int return_value_hostlist_ranged_string_1;
  return_value_hostlist_ranged_string_1=hostlist_ranged_string(set->hl, n, buf);
  return return_value_hostlist_ranged_string_1;
}

// hostset_shift
// file hostlist.c line 2559
char * hostset_shift(struct hostset *set)
{
  char *return_value_hostlist_shift_1;
  return_value_hostlist_shift_1=hostlist_shift(set->hl);
  return return_value_hostlist_shift_1;
}

// hostset_shift_range
// file hostlist.c line 2569
char * hostset_shift_range(struct hostset *set)
{
  char *return_value_hostlist_shift_range_1;
  return_value_hostlist_shift_range_1=hostlist_shift_range(set->hl);
  return return_value_hostlist_shift_range_1;
}

// hostset_within
// file hostlist.c line 2525
signed int hostset_within(struct hostset *set, const char *hosts)
{
  signed int nhosts;
  signed int nfound;
  struct hostlist *hl;
  char *hostname;
  hl=hostlist_create(hosts);
  if(hl == ((struct hostlist *)NULL))
    return 0;

  else
  {
    nhosts=hostlist_count(hl);
    nfound = 0;
    do
    {
      hostname=hostlist_pop(hl);
      if(hostname == ((char *)NULL))
        break;

      signed int return_value_hostset_find_host_1;
      return_value_hostset_find_host_1=hostset_find_host(set, hostname);
      nfound = nfound + return_value_hostset_find_host_1;
      free((void *)hostname);
    }
    while((_Bool)1);
    hostlist_destroy(hl);
    return (signed int)(nhosts == nfound);
  }
}

// include_file
// file wcoll.c line 137
static char * include_file(char *line)
{
  const char *sep = "\n\r\t ";
  char *p = line;
  char *orig;
  char *included = (char *)(void *)0;
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(p, "#include", (unsigned long int)8);
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_4;
  char *return_value_strtok_3;
  if(!(return_value_strncmp_1 == 0))
    return (char *)(void *)0;

  else
  {
    p = p + (signed long int)8;
    do
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((1 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
        break;

      p = p + 1l;
    }
    while((_Bool)1);
    orig=Strdup(line);
    p=strtok(p, sep);
    if(p == ((char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strtok_3=strtok((char *)(void *)0, "\n\r\t ");
      tmp_if_expr_4 = return_value_strtok_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      err("%p: warning: Ignoring invalid line: %s", orig);

    else
      included = p;
    Free((void **)&orig);
    return included;
  }
}

// list_alloc
// file list.c line 728
static struct list * list_alloc(void)
{
  void *return_value_list_alloc_aux_1;
  return_value_list_alloc_aux_1=list_alloc_aux((signed int)sizeof(struct list) /*80ul*/ , (void *)&list_free_lists);
  return (struct list *)return_value_list_alloc_aux_1;
}

// list_alloc_aux
// file list.c line 773
static void * list_alloc_aux(signed int size, void *pfreelist)
{
  void **px;
  void **pfree = (void **)pfreelist;
  void **plast;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&list_free_lock);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 787, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(*pfree == NULL)
  {
    *pfree=malloc((unsigned long int)(32 * size));
    if(!(*pfree == NULL))
    {
      px = (void **)*pfree;
      plast = (void **)((char *)*pfree + (signed long int)((32 - 1) * size));
      for( ; !(px >= plast); px = (void **)*px)
        *px = (void *)((char *)px + (signed long int)size);
      *plast = (void *)0;
    }

  }

  px = (void **)*pfree;
  signed int *return_value___errno_location_2;
  if(!(px == ((void **)NULL)))
    *pfree = *px;

  else
  {
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
  }
  do
  {
    signed int list_alloc_aux__1__3__e;
    list_alloc_aux__1__3__e=pthread_mutex_unlock(&list_free_lock);
    if(!(list_alloc_aux__1__3__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = list_alloc_aux__1__3__e;
      lsd_fatal_error("list.c", 801, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return (void *)px;
}

// list_append
// file ../../src/common/list.h line 131
void * list_append(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 304, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_create(l, l->tail, x);
  do
  {
    signed int list_append__1__2__e;
    list_append__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_append__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_append__1__2__e;
      lsd_fatal_error("list.c", 307, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_count
// file ../../src/common/list.h line 121
signed int list_count(struct list *l)
{
  signed int n;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 289, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  n = l->count;
  do
  {
    signed int list_count__1__2__e;
    list_count__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_count__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_count__1__2__e;
      lsd_fatal_error("list.c", 292, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// list_create
// file ../../src/common/list.h line 99
struct list * list_create(void (*f)(void *))
{
  struct list *l;
  l=list_alloc();
  if(l == ((struct list *)NULL))
    return (struct list *)(void *)0;

  else
  {
    l->head = (struct listNode *)(void *)0;
    l->tail = &l->head;
    l->iNext = (struct listIterator *)(void *)0;
    l->fDel = f;
    l->count = 0;
    do
    {
      signed int e;
      e=pthread_mutex_init(&l->mutex, (const union anonymous_3 *)(void *)0);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("list.c", 230, "list mutex init");
        abort();
      }

    }
    while((_Bool)0);
    return l;
  }
}

// list_delete
// file ../../src/common/list.h line 273
signed int list_delete(struct listIterator *i)
{
  void *v;
  v=list_remove(i);
  if(!(v == NULL))
  {
    if(!(i->list->fDel == ((void (*)(void *))NULL)))
      i->list->fDel(v);

    return 1;
  }

  else
    return 0;
}

// list_delete_all
// file list.c line 350
signed int list_delete_all(struct list *l, signed int (*f)(void *, void *), void *key)
{
  struct listNode **pp;
  void *v;
  signed int n = 0;
  do
  {
    signed int list_delete_all__1__1__e;
    list_delete_all__1__1__e=pthread_mutex_lock(&l->mutex);
    if(!(list_delete_all__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = list_delete_all__1__1__e;
      lsd_fatal_error("list.c", 359, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  pp = &l->head;
  if(!(*pp == ((struct listNode *)NULL)))
  {
    signed int return_value;
    return_value=f((*pp)->data, key);
    if(!(return_value == 0))
    {
      v=list_node_destroy(l, pp);
      if(!(v == NULL))
      {
        if(!(l->fDel == ((void (*)(void *))NULL)))
          l->fDel(v);

        n = n + 1;
      }

    }

    else
      pp = &(*pp)->next;
  }

  do
  {
    signed int e;
    e=pthread_mutex_unlock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("list.c", 374, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// list_dequeue
// file list.c line 505
void * list_dequeue(struct list *l)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 510, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_destroy(l, &l->head);
  do
  {
    signed int list_dequeue__1__2__e;
    list_dequeue__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_dequeue__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_dequeue__1__2__e;
      lsd_fatal_error("list.c", 513, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_destroy
// file ../../src/common/list.h line 109
void list_destroy(struct list *l)
{
  struct listIterator *i;
  struct listIterator *iTmp;
  struct listNode *p;
  struct listNode *pTmp;
  do
  {
    signed int list_destroy__1__1__e;
    list_destroy__1__1__e=pthread_mutex_lock(&l->mutex);
    if(!(list_destroy__1__1__e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = list_destroy__1__1__e;
      lsd_fatal_error("list.c", 243, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  i = l->iNext;
  for( ; !(i == ((struct listIterator *)NULL)); i = iTmp)
  {
    iTmp = i->iNext;
    list_iterator_free(i);
  }
  p = l->head;
  for( ; !(p == ((struct listNode *)NULL)); p = pTmp)
  {
    pTmp = p->next;
    if(!(p->data == NULL))
    {
      if(!(l->fDel == ((void (*)(void *))NULL)))
        l->fDel(p->data);

    }

    list_node_free(p);
  }
  do
  {
    signed int e;
    e=pthread_mutex_unlock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = e;
      lsd_fatal_error("list.c", 262, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  do
  {
    signed int list_destroy__1__5__e;
    list_destroy__1__5__e=pthread_mutex_destroy(&l->mutex);
    if(!(list_destroy__1__5__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = list_destroy__1__5__e;
      lsd_fatal_error("list.c", 263, "list mutex destroy");
      abort();
    }

  }
  while((_Bool)0);
  list_free(l);
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// list_enqueue
// file list.c line 490
void * list_enqueue(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 496, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_create(l, l->tail, x);
  do
  {
    signed int list_enqueue__1__2__e;
    list_enqueue__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_enqueue__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_enqueue__1__2__e;
      lsd_fatal_error("list.c", 499, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_find
// file ../../src/common/list.h line 257
void * list_find(struct listIterator *i, signed int (*f)(void *, void *), void *key)
{
  void *v;
  v=list_next(i);
  signed int return_value;
  if(!(v == NULL))
    return_value=f(v, key);

  return v;
}

// list_find_first
// file ../../src/common/list.h line 143
void * list_find_first(struct list *l, signed int (*f)(void *, void *), void *key)
{
  struct listNode *p;
  void *v = (void *)0;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 336, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  p = l->head;
  if(!(p == ((struct listNode *)NULL)))
  {
    signed int return_value;
    return_value=f(p->data, key);
    if(!(return_value == 0))
      v = p->data;

    else
      p = p->next;
  }

  do
  {
    signed int list_find_first__1__3__e;
    list_find_first__1__3__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_find_first__1__3__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_find_first__1__3__e;
      lsd_fatal_error("list.c", 344, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_for_each
// file ../../src/common/list.h line 162
signed int list_for_each(struct list *l, signed int (*f)(void *, void *), void *arg)
{
  struct listNode *p;
  signed int n = 0;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 387, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  p = l->head;
  if(!(p == ((struct listNode *)NULL)))
  {
    n = n + 1;
    signed int return_value;
    return_value=f(p->data, arg);
    if(!(return_value >= 0))
      n = -n;

    else
      p = p->next;
  }

  do
  {
    signed int list_for_each__1__3__e;
    list_for_each__1__3__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_for_each__1__3__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_for_each__1__3__e;
      lsd_fatal_error("list.c", 396, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return n;
}

// list_free
// file list.c line 735
static void list_free(struct list *l)
{
  list_free_aux((void *)l, (void *)&list_free_lists);
}

// list_free_aux
// file list.c line 807
static void list_free_aux(void *x, void *pfreelist)
{
  void **px = (void **)x;
  void **pfree = (void **)pfreelist;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&list_free_lock);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 816, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  *px = *pfree;
  *pfree = (void *)px;
  do
  {
    signed int list_free_aux__1__2__e;
    list_free_aux__1__2__e=pthread_mutex_unlock(&list_free_lock);
    if(!(list_free_aux__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_free_aux__1__2__e;
      lsd_fatal_error("list.c", 819, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// list_insert
// file list.c line 595
void * list_insert(struct listIterator *i, void *x)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&i->list->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 602, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_create(i->list, i->prev, x);
  do
  {
    signed int list_insert__1__2__e;
    list_insert__1__2__e=pthread_mutex_unlock(&i->list->mutex);
    if(!(list_insert__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_insert__1__2__e;
      lsd_fatal_error("list.c", 605, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_is_empty
// file ../../src/common/list.h line 116
signed int list_is_empty(struct list *l)
{
  signed int n;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 275, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  n = l->count;
  do
  {
    signed int list_is_empty__1__2__e;
    list_is_empty__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_is_empty__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_is_empty__1__2__e;
      lsd_fatal_error("list.c", 278, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return (signed int)(n == 0);
}

// list_iterator_alloc
// file list.c line 758
static struct listIterator * list_iterator_alloc(void)
{
  void *return_value_list_alloc_aux_1;
  return_value_list_alloc_aux_1=list_alloc_aux((signed int)sizeof(struct listIterator) /*32ul*/ , (void *)&list_free_iterators);
  return (struct listIterator *)return_value_list_alloc_aux_1;
}

// list_iterator_create
// file ../../src/common/list.h line 223
struct listIterator * list_iterator_create(struct list *l)
{
  struct listIterator *i;
  i=list_iterator_alloc();
  if(i == ((struct listIterator *)NULL))
    return (struct listIterator *)(void *)0;

  else
  {
    i->list = l;
    do
    {
      signed int e;
      e=pthread_mutex_lock(&l->mutex);
      if(!(e == 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = e;
        lsd_fatal_error("list.c", 527, "list mutex lock");
        abort();
      }

    }
    while((_Bool)0);
    i->pos = l->head;
    i->prev = &l->head;
    i->iNext = l->iNext;
    l->iNext = i;
    do
    {
      signed int list_iterator_create__1__2__e;
      list_iterator_create__1__2__e=pthread_mutex_unlock(&l->mutex);
      if(!(list_iterator_create__1__2__e == 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = list_iterator_create__1__2__e;
        lsd_fatal_error("list.c", 534, "list mutex unlock");
        abort();
      }

    }
    while((_Bool)0);
    return i;
  }
}

// list_iterator_destroy
// file ../../src/common/list.h line 235
void list_iterator_destroy(struct listIterator *i)
{
  struct listIterator **pi;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&i->list->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 560, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  pi = &i->list->iNext;
  for( ; !(*pi == ((struct listIterator *)NULL)); pi = &(*pi)->iNext)
    if(*pi == i)
    {
      *pi = (*pi)->iNext;
      break;
    }

  do
  {
    signed int list_iterator_destroy__1__3__e;
    list_iterator_destroy__1__3__e=pthread_mutex_unlock(&i->list->mutex);
    if(!(list_iterator_destroy__1__3__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_iterator_destroy__1__3__e;
      lsd_fatal_error("list.c", 569, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  list_iterator_free(i);
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// list_iterator_free
// file list.c line 765
static void list_iterator_free(struct listIterator *i)
{
  list_free_aux((void *)i, (void *)&list_free_iterators);
}

// list_iterator_reset
// file list.c line 540
void list_iterator_reset(struct listIterator *i)
{
  do
  {
    signed int e;
    e=pthread_mutex_lock(&i->list->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 544, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  i->pos = i->list->head;
  i->prev = &i->list->head;
  do
  {
    signed int list_iterator_reset__1__2__e;
    list_iterator_reset__1__2__e=pthread_mutex_unlock(&i->list->mutex);
    if(!(list_iterator_reset__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_iterator_reset__1__2__e;
      lsd_fatal_error("list.c", 548, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
}

// list_join
// file ../../src/common/split.h line 33
signed int list_join(char *result, unsigned long int len, const char *sep, struct list *l)
{
  char *str = (char *)(void *)0;
  signed int n = 0;
  signed int truncated = 0;
  struct listIterator *i;
  memset((void *)result, 0, len);
  signed int return_value_list_count_1;
  return_value_list_count_1=list_count(l);
  void *return_value_list_next_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(return_value_list_count_1 == 0)
    return 0;

  else
  {
    i=list_iterator_create(l);
    do
    {
      return_value_list_next_2=list_next(i);
      str = (char *)return_value_list_next_2;
      if(str == ((char *)NULL))
        break;

      signed int count;
      if(truncated == 0)
      {
        count=snprintf(result + (signed long int)n, len - (unsigned long int)n, "%s%s", str, sep);
        if((unsigned long int)count >= len + -((unsigned long int)n) || !(count >= 0))
          truncated = 1;

        else
          n = n + count;
      }

      else
      {
        return_value_strlen_3=strlen(str);
        return_value_strlen_4=strlen(sep);
        n = n + (signed int)(return_value_strlen_3 + return_value_strlen_4);
      }
    }
    while((_Bool)1);
    list_iterator_destroy(i);
    if(!(truncated == 0))
      result[(signed long int)(len - (unsigned long int)1)] = (char)0;

    else
    {
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(result);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(sep);
      result[(signed long int)(return_value_strlen_5 - return_value_strlen_6)] = (char)0;
    }
    return n;
  }
}

// list_next
// file ../../src/common/list.h line 242
void * list_next(struct listIterator *i)
{
  struct listNode *p;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&i->list->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 583, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  p = i->pos;
  if(!(p == ((struct listNode *)NULL)))
    i->pos = p->next;

  if(!(*i->prev == p))
    i->prev = &(*i->prev)->next;

  do
  {
    signed int list_next__1__2__e;
    list_next__1__2__e=pthread_mutex_unlock(&i->list->mutex);
    if(!(list_next__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_next__1__2__e;
      lsd_fatal_error("list.c", 589, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  void *tmp_if_expr_3;
  if(!(p == ((struct listNode *)NULL)))
    tmp_if_expr_3 = p->data;

  else
    tmp_if_expr_3 = (void *)0;
  return tmp_if_expr_3;
}

// list_node_alloc
// file list.c line 743
static struct listNode * list_node_alloc(void)
{
  void *return_value_list_alloc_aux_1;
  return_value_list_alloc_aux_1=list_alloc_aux((signed int)sizeof(struct listNode) /*16ul*/ , (void *)&list_free_nodes);
  return (struct listNode *)return_value_list_alloc_aux_1;
}

// list_node_create
// file list.c line 657
static void * list_node_create(struct list *l, struct listNode **pp, void *x)
{
  struct listNode *p;
  struct listIterator *i;
  p=list_node_alloc();
  if(p == ((struct listNode *)NULL))
    return (void *)0;

  else
  {
    p->data = x;
    p->next = *pp;
    if(p->next == ((struct listNode *)NULL))
      l->tail = &p->next;

    *pp = p;
    l->count = l->count + 1;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
      if(i->prev == pp)
        i->prev = &p->next;

      else
        if(i->pos == p->next)
          i->pos = p;

    return x;
  }
}

// list_node_destroy
// file list.c line 692
static void * list_node_destroy(struct list *l, struct listNode **pp)
{
  void *v;
  struct listNode *p;
  struct listIterator *i;
  p = *pp;
  if(p == ((struct listNode *)NULL))
    return (void *)0;

  else
  {
    v = p->data;
    *pp = p->next;
    if(*pp == ((struct listNode *)NULL))
      l->tail = pp;

    l->count = l->count - 1;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
      if(i->pos == p)
      {
        i->pos = p->next;
        i->prev = pp;
      }

      else
        if(i->prev == &p->next)
          i->prev = pp;

    list_node_free(p);
    return v;
  }
}

// list_node_free
// file list.c line 750
static void list_node_free(struct listNode *p)
{
  list_free_aux((void *)p, (void *)&list_free_nodes);
}

// list_peek
// file list.c line 476
void * list_peek(struct list *l)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 481, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  void *tmp_if_expr_2;
  if(!(l->head == ((struct listNode *)NULL)))
    tmp_if_expr_2 = l->head->data;

  else
    tmp_if_expr_2 = (void *)0;
  v = tmp_if_expr_2;
  do
  {
    signed int list_peek__1__2__e;
    list_peek__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_peek__1__2__e == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = list_peek__1__2__e;
      lsd_fatal_error("list.c", 484, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_pop
// file list.c line 462
void * list_pop(struct list *l)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 467, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_destroy(l, &l->head);
  do
  {
    signed int list_pop__1__2__e;
    list_pop__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_pop__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_pop__1__2__e;
      lsd_fatal_error("list.c", 470, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_prepend
// file ../../src/common/list.h line 137
void * list_prepend(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 319, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_create(l, &l->head, x);
  do
  {
    signed int list_prepend__1__2__e;
    list_prepend__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_prepend__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_prepend__1__2__e;
      lsd_fatal_error("list.c", 322, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_push
// file ../../src/common/list.h line 182
void * list_push(struct list *l, void *x)
{
  void *v;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 453, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  v=list_node_create(l, &l->head, x);
  do
  {
    signed int list_push__1__2__e;
    list_push__1__2__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_push__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_push__1__2__e;
      lsd_fatal_error("list.c", 456, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_push_hostlist
// file opt.c line 1275
static void list_push_hostlist(struct list *l, struct hostlist *hl)
{
  unsigned long int n = (unsigned long int)4096;
  char *s;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(n);
  s = (char *)return_value_Malloc_1;
  signed long int return_value_hostlist_ranged_string_2;
  do
  {
    return_value_hostlist_ranged_string_2=hostlist_ranged_string(hl, n - (unsigned long int)1, s);
    if(return_value_hostlist_ranged_string_2 >= 0l)
      break;

    n = n * (unsigned long int)(2 < 0x7fffff);
    if(n == 0ul)
      break;

    Realloc((void **)&s, n);
  }
  while((_Bool)1);
  list_push(l, (void *)s);
}

// list_remove
// file list.c line 625
void * list_remove(struct listIterator *i)
{
  void *v = (void *)0;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&i->list->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 631, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(!(*i->prev == i->pos))
    v=list_node_destroy(i->list, i->prev);

  do
  {
    signed int list_remove__1__2__e;
    list_remove__1__2__e=pthread_mutex_unlock(&i->list->mutex);
    if(!(list_remove__1__2__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_remove__1__2__e;
      lsd_fatal_error("list.c", 635, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  return v;
}

// list_sort
// file ../../src/common/list.h line 170
void list_sort(struct list *l, signed int (*f)(void *, void *))
{
  struct listNode **pp;
  struct listNode **ppPrev;
  struct listNode **ppPos;
  struct listNode *pTmp;
  struct listIterator *i;
  do
  {
    signed int e;
    e=pthread_mutex_lock(&l->mutex);
    if(!(e == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = e;
      lsd_fatal_error("list.c", 411, "list mutex lock");
      abort();
    }

  }
  while((_Bool)0);
  if(l->count >= 2)
  {
    ppPrev = &l->head;
    pp = &(*ppPrev)->next;
    if(!(*pp == ((struct listNode *)NULL)))
    {
      signed int return_value_1;
      return_value_1=f((*pp)->data, (*ppPrev)->data);
      if(!(return_value_1 >= 0))
      {
        ppPos = &l->head;
        signed int return_value;
        return_value=f((*pp)->data, (*ppPos)->data);
        if(return_value >= 0)
          ppPos = &(*ppPos)->next;

        pTmp = (*pp)->next;
        (*pp)->next = *ppPos;
        *ppPos = *pp;
        *pp = pTmp;
        if(ppPrev == ppPos)
          ppPrev = &(*ppPrev)->next;

      }

      else
      {
        ppPrev = pp;
        pp = &(*pp)->next;
      }
    }

    l->tail = pp;
    i = l->iNext;
    for( ; !(i == ((struct listIterator *)NULL)); i = i->iNext)
    {
      i->pos = i->list->head;
      i->prev = &i->list->head;
    }
  }

  do
  {
    signed int list_sort__1__3__e;
    list_sort__1__3__e=pthread_mutex_unlock(&l->mutex);
    if(!(list_sort__1__3__e == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = list_sort__1__3__e;
      lsd_fatal_error("list.c", 441, "list mutex unlock");
      abort();
    }

  }
  while((_Bool)0);
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// list_split
// file ../../src/common/split.h line 31
struct list * list_split(char *sep, char *str)
{
  struct list *new;
  new=list_create((void (*)(void *))free_f_link2);
  char *tok;
  if(sep == ((char *)NULL))
    sep = " \t";

  char *return_value_Strdup_1;
  do
  {
    tok=_next_tok_link1(sep, &str);
    if(tok == ((char *)NULL))
      break;

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(tok);
    if(return_value_strlen_2 >= 1ul)
    {
      return_value_Strdup_1=Strdup(tok);
      list_append(new, (void *)return_value_Strdup_1);
    }

  }
  while((_Bool)1);
  return new;
}

// list_split_append
// file split.c line 104
struct list * list_split_append(struct list *l, char *sep, char *str)
{
  char *tok;
  struct list *return_value_list_split_1;
  char *return_value_Strdup_2;
  if(l == ((struct list *)NULL))
  {
    return_value_list_split_1=list_split(sep, str);
    return return_value_list_split_1;
  }

  else
  {
    if(sep == ((char *)NULL))
      sep = " \t";

    do
    {
      tok=_next_tok_link1(sep, &str);
      if(tok == ((char *)NULL))
        break;

      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(tok);
      if(return_value_strlen_3 >= 1ul)
      {
        return_value_Strdup_2=Strdup(tok);
        list_append(l, (void *)return_value_Strdup_2);
      }

    }
    while((_Bool)1);
    return l;
  }
}

// login_name_max_len
// file opt.c line 302
static signed int login_name_max_len(void)
{
  static signed int maxnamelen = -1;
  if(!(maxnamelen >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    signed long int return_value_sysconf_2;
    return_value_sysconf_2=sysconf(71);
    maxnamelen = (signed int)return_value_sysconf_2;
    if(!(maxnamelen >= 1))
    {
      err("%p: sysconf(LOGIN_NAME_MAX): %m\n");
      maxnamelen = 16;
    }

  }

  return maxnamelen;
}

// lsd_fatal_error
// file err.c line 193
void lsd_fatal_error(char *file, signed int line, char *mesg)
{
  errx("%p: %s:%d: %s\n", file, line, mesg);
}

// lsd_nomem_error
// file err.c line 198
void lsd_nomem_error(char *file, signed int line, char *mesg)
{
  errx("%p: %s:%d: %s: Out of memory\n", file, line, mesg);
}

// main
// file main.c line 67
signed int main(signed int argc, char **argv)
{
  struct anonymous_1 opt;
  signed int retval = 0;
  const char *m;
  char *return_value_xbasename_1;
  return_value_xbasename_1=xbasename(argv[(signed long int)0]);
  err_init(return_value_xbasename_1);
  privsep_init();
  opt_default(&opt, argv[(signed long int)0]);
  opt_env(&opt);
  opt_args_early(&opt, argc, argv);
  mod_init();
  m=getenv("PDSH_MODULE_DIR");
  _Bool tmp_if_expr_3;
  unsigned int return_value_getuid_2;
  if(m == ((const char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_getuid_2=getuid();
    tmp_if_expr_3 = return_value_getuid_2 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  unsigned int return_value_getuid_4;
  unsigned int return_value_geteuid_5;
  if(tmp_if_expr_3)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_getuid_4=getuid();
    return_value_geteuid_5=geteuid();
    tmp_if_expr_6 = return_value_getuid_4 != return_value_geteuid_5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
    m = pdsh_module_dir;

  signed int return_value_mod_load_modules_7;
  return_value_mod_load_modules_7=mod_load_modules(m, &opt);
  if(!(return_value_mod_load_modules_7 >= 0))
    errx("%p: Couldn't load any pdsh modules\n");

  opt_args(&opt, argc, argv);
  enum anonymous return_value_opt_verify_13;
  return_value_opt_verify_13=opt_verify(&opt);
  enum anonymous_5 return_value_pdsh_personality_12;
  signed int return_value__pcp_remote_server_8;
  enum anonymous_5 return_value_pdsh_personality_11;
  signed int return_value__pcp_remote_client_9;
  enum anonymous_5 return_value_pdsh_personality_10;
  if(!(return_value_opt_verify_13 == /*enum*/false))
  {
    if(!(opt.info_only == /*enum*/false))
      opt_list(&opt);

    else
    {
      return_value_pdsh_personality_12=pdsh_personality();
      if((signed int)return_value_pdsh_personality_12 == PCP && !(opt.pcp_server == /*enum*/false))
      {
        return_value__pcp_remote_server_8=_pcp_remote_server(&opt);
        retval = (signed int)(return_value__pcp_remote_server_8 < 0);
      }

      else
      {
        return_value_pdsh_personality_11=pdsh_personality();
        if((signed int)return_value_pdsh_personality_11 == PCP && !(opt.pcp_client == /*enum*/false))
        {
          return_value__pcp_remote_client_9=_pcp_remote_client(&opt);
          retval = (signed int)(return_value__pcp_remote_client_9 < 0);
        }

        else
        {
          return_value_pdsh_personality_10=pdsh_personality();
          if((signed int)return_value_pdsh_personality_10 == PCP || !(opt.cmd == ((char *)NULL)))
            retval=dsh(&opt);

          else
            _interactive_dsh(&opt);
        }
      }
    }
  }

  else
    retval = 1;
  mod_exit();
  privsep_fini();
  opt_free(&opt);
  err_cleanup();
  return retval;
}

// mod_count
// file mod.c line 467
signed int mod_count(char *type)
{
  signed int i = 0;
  struct listIterator *module_itr;
  signed int return_value_list_count_1;
  void *return_value_list_find_2;
  if(type == ((char *)NULL))
  {
    return_value_list_count_1=list_count(module_list);
    return return_value_list_count_1;
  }

  else
  {
    module_itr=list_iterator_create(module_list);
    if(module_itr == ((struct listIterator *)NULL))
    {
      err("Unable to create module list iterator\n");
      return -1;
    }

    else
    {
      do
      {
        return_value_list_find_2=list_find(module_itr, (signed int (*)(void *, void *))_cmp_type, (void *)type);
        if(return_value_list_find_2 == NULL)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      list_iterator_destroy(module_itr);
      return i;
    }
  }
}

// mod_create
// file mod.c line 262
struct module_components * mod_create(void)
{
  struct module_components *mod;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct module_components) /*32ul*/ );
  mod = (struct module_components *)return_value_Malloc_1;
  mod->handle = (struct lt_dlhandle_struct *)(void *)0;
  mod->filename = (char *)(void *)0;
  mod->priority = 100;
  mod->initialized = 0;
  return mod;
}

// mod_exit
// file mod.h line 53
signed int mod_exit(void)
{
  if(initialized == /*enum*/false)
    return 0;

  else
  {
    list_destroy(module_list);
    signed int return_value_lt_dlexit_1;
    return_value_lt_dlexit_1=lt_dlexit();
    return return_value_lt_dlexit_1;
  }
}

// mod_get_module
// file mod.c line 557
struct module_components * mod_get_module(const char *type, const char *name)
{
  struct module_components *mod;
  struct listIterator *module_itr;
  module_itr=list_iterator_create(module_list);
  void *return_value_list_next_1;
  if(module_itr == ((struct listIterator *)NULL))
  {
    err("Unable to create module list iterator\n");
    return (struct module_components *)(void *)0;
  }

  else
  {
    do
    {
      return_value_list_next_1=list_next(module_itr);
      mod = (struct module_components *)return_value_list_next_1;
      if(mod == ((struct module_components *)NULL))
        break;

      signed int return_value__mod_description_match_2;
      return_value__mod_description_match_2=_mod_description_match(mod, type, name);
      if(!(return_value__mod_description_match_2 == 0))
        break;

    }
    while((_Bool)1);
    list_iterator_destroy(module_itr);
    return mod;
  }
}

// mod_get_module_names
// file mod.c line 522
struct list * mod_get_module_names(char *type)
{
  struct list *return_value__mod_get_module_names_1;
  return_value__mod_get_module_names_1=_mod_get_module_names(type, 1);
  return return_value__mod_get_module_names_1;
}

// mod_get_name
// file mod.c line 581
char * mod_get_name(struct module_components *mod)
{
  return mod->pmod->name;
}

// mod_get_rcmd
// file mod.c line 623
signed int (*mod_get_rcmd(struct module_components *mod))(char *, char *, char *, char *, char *, signed int, signed int *, void **)
{
  _Bool tmp_if_expr_1;
  if(!(mod->pmod->rcmd_ops == ((struct pdsh_rcmd_operations *)NULL)))
    tmp_if_expr_1 = mod->pmod->rcmd_ops->rcmd != ((signed int (*)(char *, char *, char *, char *, char *, signed int, signed int *, void **))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return mod->pmod->rcmd_ops->rcmd;

  else
    return (signed int (*)(char *, char *, char *, char *, char *, signed int, signed int *, void **))(void *)0;
}

// mod_get_rcmd_destroy
// file mod.c line 635
signed int (*mod_get_rcmd_destroy(struct module_components *mod))(void *)
{
  _Bool tmp_if_expr_1;
  if(!(mod->pmod->rcmd_ops == ((struct pdsh_rcmd_operations *)NULL)))
    tmp_if_expr_1 = mod->pmod->rcmd_ops->rcmd_destroy != ((signed int (*)(void *))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return mod->pmod->rcmd_ops->rcmd_destroy;

  else
    return (signed int (*)(void *))(void *)0;
}

// mod_get_rcmd_init
// file mod.c line 599
signed int (*mod_get_rcmd_init(struct module_components *mod))(struct anonymous_1 *)
{
  _Bool tmp_if_expr_1;
  if(!(mod->pmod->rcmd_ops == ((struct pdsh_rcmd_operations *)NULL)))
    tmp_if_expr_1 = mod->pmod->rcmd_ops->rcmd_init != ((signed int (*)(struct anonymous_1 *))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return mod->pmod->rcmd_ops->rcmd_init;

  else
    return (signed int (*)(struct anonymous_1 *))(void *)0;
}

// mod_get_rcmd_signal
// file mod.c line 611
signed int (*mod_get_rcmd_signal(struct module_components *mod))(signed int, void *, signed int)
{
  _Bool tmp_if_expr_1;
  if(!(mod->pmod->rcmd_ops == ((struct pdsh_rcmd_operations *)NULL)))
    tmp_if_expr_1 = mod->pmod->rcmd_ops->rcmd_signal != ((signed int (*)(signed int, void *, signed int))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return mod->pmod->rcmd_ops->rcmd_signal;

  else
    return (signed int (*)(signed int, void *, signed int))(void *)0;
}

// mod_get_type
// file mod.c line 590
char * mod_get_type(struct module_components *mod)
{
  return mod->pmod->type;
}

// mod_get_uninitialized_module_names
// file mod.c line 527
struct list * mod_get_uninitialized_module_names(char *type)
{
  struct list *return_value__mod_get_module_names_1;
  return_value__mod_get_module_names_1=_mod_get_module_names(type, 0);
  return return_value__mod_get_module_names_1;
}

// mod_init
// file mod.h line 43
signed int mod_init(void)
{
  if(initialized == /*enum*/false)
  {
    module_list=list_create((void (*)(void *))_mod_destroy);
    if(module_list == ((struct list *)NULL))
    {
      err("Unable to create module list\n");
      return -1;
    }

    initialized = (enum anonymous)true;
    signed int return_value_lt_dlinit_1;
    return_value_lt_dlinit_1=lt_dlinit();
    return return_value_lt_dlinit_1;
  }

  else
    return 0;
}

// mod_list_module_info
// file mod.c line 534
void mod_list_module_info(void)
{
  signed int nmodules;
  nmodules=list_count(module_list);
  out("%d module%s loaded:\n\n", nmodules, nmodules > 1 ? "s" : "");
  if(!(nmodules == 0))
    list_for_each(module_list, (signed int (*)(void *, void *))_mod_print_info, (void *)0);

}

// mod_load_modules
// file mod.h line 68
signed int mod_load_modules(const char *dir, struct anonymous_1 *opt)
{
  signed int rc = 0;
  rc=_mod_load_dynamic_modules(dir, opt);
  list_sort(module_list, (signed int (*)(void *, void *))_cmp_f);
  _mod_initialize_modules_by_name(opt->misc_modules, module_list);
  list_for_each(module_list, (signed int (*)(void *, void *))_mod_init_list_safe, (void *)0);
  return rc;
}

// mod_postop
// file mod.c line 238
signed int mod_postop(struct anonymous_1 *pdsh_opts)
{
  struct module_components *mod;
  signed int errors = 0;
  struct listIterator *module_itr;
  if(initialized == /*enum*/false)
    mod_init();

  module_itr=list_iterator_create(module_list);
  signed int return_value__mod_postop_1;
  if(module_itr == ((struct listIterator *)NULL))
  {
    err("Unable to create module list iterator\n");
    return 1;
  }

  else
  {
    do
    {
      mod=_mod_next_active(module_itr);
      if(mod == ((struct module_components *)NULL))
        break;

      return_value__mod_postop_1=_mod_postop(mod, pdsh_opts);
      errors = errors + return_value__mod_postop_1;
    }
    while((_Bool)1);
    list_iterator_destroy(module_itr);
    return errors;
  }
}

// mod_print_all_options
// file mod.c line 454
void mod_print_all_options(signed int col)
{
  list_for_each(module_list, (signed int (*)(void *, void *))_opt_print, (void *)&col);
}

// mod_print_options
// file mod.c line 404
void mod_print_options(struct module_components *mod, signed int col)
{
  struct pdsh_module_option *p = mod->pmod->opt_table;
  _Bool tmp_if_expr_1;
  if(p == ((struct pdsh_module_option *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(p->opt != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    p = mod->pmod->opt_table;
    do
    {
      if(!(p == ((struct pdsh_module_option *)NULL)))
        tmp_if_expr_2 = (signed int)p->opt != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      _print_option_help(p, col);
      p = p + 1l;
    }
    while((_Bool)1);
  }

}

// mod_process_opt
// file mod.c line 648
signed int mod_process_opt(struct anonymous_1 *opt, signed int c, char *optarg)
{
  struct module_components *mod;
  struct pdsh_module_option *p = (struct pdsh_module_option *)(void *)0;
  struct listIterator *module_itr;
  module_itr=list_iterator_create(module_list);
  if(module_itr == ((struct listIterator *)NULL))
  {
    err("Unable to create module list iterator\n");
    return -1;
  }

  else
  {
    do
    {
      mod=_mod_next_active(module_itr);
      if(mod == ((struct module_components *)NULL))
        break;

      p=_mod_find_opt(mod, c);
      if(!(p == ((struct pdsh_module_option *)NULL)))
      {
        list_iterator_destroy(module_itr);
        signed int return_value;
        return_value=p->f(opt, c, optarg);
        return return_value;
      }

    }
    while((_Bool)1);
    list_iterator_destroy(module_itr);
    return -1;
  }
}

// mod_read_wcoll
// file mod.c line 206
signed int mod_read_wcoll(struct anonymous_1 *opt)
{
  struct module_components *mod;
  struct listIterator *module_itr;
  if(initialized == /*enum*/false)
    mod_init();

  module_itr=list_iterator_create(module_list);
  if(module_itr == ((struct listIterator *)NULL))
  {
    err("Unable to create module list iterator\n");
    return -1;
  }

  else
  {
    do
    {
      mod=_mod_next_active(module_itr);
      if(mod == ((struct module_components *)NULL))
        break;

      struct hostlist *hl = (struct hostlist *)(void *)0;
      hl=_mod_read_wcoll(mod, opt);
      if(!(hl == ((struct hostlist *)NULL)))
      {
        if(!(opt->wcoll == ((struct hostlist *)NULL)))
        {
          hostlist_push_list(opt->wcoll, hl);
          hostlist_destroy(hl);
        }

        else
          opt->wcoll = hl;
      }

    }
    while((_Bool)1);
    list_iterator_destroy(module_itr);
    return 0;
  }
}

// node_rcmd_info_create
// file rcmd.c line 77
static struct node_rcmd_info * node_rcmd_info_create(char *hostname, char *user, struct rcmd_module *module)
{
  struct node_rcmd_info *n;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct node_rcmd_info) /*24ul*/ );
  n = (struct node_rcmd_info *)return_value_Malloc_1;
  if(n == ((struct node_rcmd_info *)NULL))
    return (struct node_rcmd_info *)(void *)0;

  else
  {
    n->hostname=Strdup(hostname);
    n->username=Strdup(user);
    n->rmod = module;
    return n;
  }
}

// node_rcmd_info_destroy
// file rcmd.c line 91
static void node_rcmd_info_destroy(struct node_rcmd_info *n)
{
  if(!(n == ((struct node_rcmd_info *)NULL)))
  {
    Free((void **)&n->hostname);
    if(!(n->username == ((char *)NULL)))
      Free((void **)&n->username);

    Free((void **)&n);
  }

}

// opt_args
// file ../../src/pdsh/opt.h line 101
void opt_args(struct anonymous_1 *opt, signed int argc, char **argv)
{
  signed int c;
  optind = 1;
  opterr = 1;
  signed int return_value_string_to_int_1;
  signed int return_value_strcmp_2;
  enum anonymous_5 return_value_pdsh_personality_3;
  enum anonymous_5 return_value_pdsh_personality_4;
  enum anonymous_5 return_value_pdsh_personality_5;
  signed int return_value_atoi_6;
  enum anonymous_5 return_value_pdsh_personality_7;
  enum anonymous_5 return_value_pdsh_personality_8;
  enum anonymous_5 return_value_pdsh_personality_9;
  do
  {
    c=getopt(argc, argv, pdsh_options);
    if(c == -1)
      break;

    switch(c)
    {
      case 77:
        break;
      case 78:
      {
        opt->labels = (enum anonymous)false;
        break;
      }
      case 76:
      {
        mod_list_module_info();
        exit(0);
        break;
      }
      case 82:
      {
        opt->rcmd_name=Strdup(optarg);
        break;
      }
      case 83:
      {
        opt->ret_remote_rc = (enum anonymous)true;
        break;
      }
      case 100:
      {
        opt->debug = (enum anonymous)true;
        break;
      }
      case 102:
      {
        return_value_string_to_int_1=string_to_int(optarg, &opt->fanout);
        if(!(return_value_string_to_int_1 >= 0))
          errx("%p: Invalid fanout `%s' passed to -f.\n", optarg);

        break;
      }
      case 119:
      {
        return_value_strcmp_2=strcmp(optarg, "-");
        if(return_value_strcmp_2 == 0)
          wcoll_args_process(opt, "^-");

        else
          wcoll_args_process(opt, optarg);
        break;
      }
      case 120:
      {
        wcoll_append_excluded(opt, optarg);
        break;
      }
      case 113:
      {
        opt->info_only = (enum anonymous)true;
        break;
      }
      case 116:
      {
        opt->connect_timeout=atoi(optarg);
        break;
      }
      case 117:
      {
        opt->command_timeout=atoi(optarg);
        break;
      }
      case 98:
      {
        opt->sigint_terminates = (enum anonymous)true;
        break;
      }
      case 108:
      {
        copy_username(opt->ruser, optarg);
        break;
      }
      case 114:
      {
        return_value_pdsh_personality_3=pdsh_personality();
        if((signed int)return_value_pdsh_personality_3 == PCP)
          opt->recursive = (enum anonymous)true;

        else
          goto test_module_option;
        break;
      }
      case 112:
      {
        return_value_pdsh_personality_4=pdsh_personality();
        if((signed int)return_value_pdsh_personality_4 == PCP)
          opt->preserve = (enum anonymous)true;

        else
          goto test_module_option;
        break;
      }
      case 101:
      {
        return_value_pdsh_personality_5=pdsh_personality();
        if((signed int)return_value_pdsh_personality_5 == PCP)
        {
          Free((void **)&opt->remote_program_path);
          opt->remote_program_path=Strdup(optarg);
        }

        else
          goto test_module_option;
        break;
      }
      case 86:
      {
        _show_version();
        break;
      }
      case 84:
      {
        return_value_atoi_6=atoi(optarg);
        testcase(return_value_atoi_6);
        break;
      }
      case 81:
      {
        opt->info_only = (enum anonymous)true;
        opt->test_range_expansion = (enum anonymous)true;
        break;
      }
      case 104:
      {
        _usage(opt);
        break;
      }
      case 75:
      {
        err_no_strip_domain();
        break;
      }
      case 121:
      {
        return_value_pdsh_personality_7=pdsh_personality();
        if((signed int)return_value_pdsh_personality_7 == PCP)
          opt->target_is_directory = (enum anonymous)true;

        else
          goto test_module_option;
        break;
      }
      case 122:
      {
        return_value_pdsh_personality_8=pdsh_personality();
        if((signed int)return_value_pdsh_personality_8 == PCP)
          opt->pcp_server = (enum anonymous)true;

        else
          goto test_module_option;
        break;
      }
      case 90:
      {
        return_value_pdsh_personality_9=pdsh_personality();
        if((signed int)return_value_pdsh_personality_9 == PCP)
          opt->pcp_client = (enum anonymous)true;

        else
          goto test_module_option;
        break;
      }
      default:
      {

      test_module_option:
        ;
        signed int return_value_mod_process_opt_10;
        return_value_mod_process_opt_10=mod_process_opt(opt, c, optarg);
        if(!(return_value_mod_process_opt_10 >= 0))
          _usage(opt);

      }
    }
  }
  while((_Bool)1);
  char *return_value_rcmd_get_default_module_11;
  if(opt->rcmd_name == ((char *)NULL))
  {
    return_value_rcmd_get_default_module_11=rcmd_get_default_module();
    opt->rcmd_name=Strdup(return_value_rcmd_get_default_module_11);
  }

  signed int return_value_rcmd_register_default_rcmd_12;
  if(!(opt->rcmd_name == ((char *)NULL)))
  {
    return_value_rcmd_register_default_rcmd_12=rcmd_register_default_rcmd(opt->rcmd_name);
    if(!(return_value_rcmd_register_default_rcmd_12 >= 0))
      exit(1);

  }

  remote_argc = argc - optind;
  remote_argv = argv + (signed long int)optind;
  if((signed int)personality == DSH)
    for( ; !(optind >= argc); optind = optind + 1)
    {
      if(!(opt->cmd == ((char *)NULL)))
        xstrcat(&opt->cmd, " ");

      xstrcat(&opt->cmd, argv[(signed long int)optind]);
    }

  else
  {
    if(opt->infile_names == ((struct list *)NULL))
      opt->infile_names=list_create((void (*)(void *))(void *)0);

    for( ; !(optind >= argc + -1); optind = optind + 1)
      list_append(opt->infile_names, (void *)argv[(signed long int)optind]);
    if(!(optind >= argc))
    {
      if(!(opt->pcp_client == /*enum*/false))
        xstrcat(&opt->pcp_client_host, argv[(signed long int)optind]);

      else
        xstrcat(&opt->outfile_name, argv[(signed long int)optind]);
    }

  }
  if(opt->pcp_server == /*enum*/false)
  {
    signed int return_value_mod_read_wcoll_13;
    return_value_mod_read_wcoll_13=mod_read_wcoll(opt);
    if(!(return_value_mod_read_wcoll_13 >= 0))
      exit(1);

    if(opt->wcoll == ((struct hostlist *)NULL))
    {
      char *val;
      val=getenv("WCOLL");
      if(!(val == ((char *)NULL)))
        opt->wcoll=read_wcoll(val, (struct _IO_FILE *)(void *)0);

    }

    if(!(opt->wcoll == ((struct hostlist *)NULL)))
    {
      if(!(exclude_list == ((struct list *)NULL)))
      {
        wcoll_apply_excluded(opt, exclude_list);
        list_destroy(exclude_list);
      }

      if(!(regex_list == ((struct list *)NULL)))
      {
        wcoll_apply_regex(opt, regex_list);
        list_destroy(regex_list);
      }

      wcoll_expand(opt);
    }

  }

}

// opt_args_early
// file ../../src/pdsh/opt.h line 100
void opt_args_early(struct anonymous_1 *opt, signed int argc, char **argv)
{
  signed int c;
  opterr = 0;
  putenv("POSIXLY_CORRECT=1");
  do
  {
    c=getopt(argc, argv, pdsh_options);
    if(c == -1)
      break;

    if(c == 77)
    {
      if(!(opt->misc_modules == ((char *)NULL)))
        Free((void **)&opt->misc_modules);

      opt->misc_modules=Strdup(optarg);
    }

  }
  while((_Bool)1);
}

// opt_default
// file ../../src/pdsh/opt.h line 98
void opt_default(struct anonymous_1 *opt, char *argv0)
{
  struct passwd *pw;
  opt->progname=xbasename(argv0);
  signed int return_value_login_name_max_len_1;
  return_value_login_name_max_len_1=login_name_max_len();
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc((unsigned long int)(return_value_login_name_max_len_1 + 1));
  opt->luser = (char *)return_value_Malloc_2;
  signed int return_value_login_name_max_len_3;
  return_value_login_name_max_len_3=login_name_max_len();
  void *return_value_Malloc_4;
  return_value_Malloc_4=Malloc((unsigned long int)(return_value_login_name_max_len_3 + 1));
  opt->ruser = (char *)return_value_Malloc_4;
  opt->reverse_copy = (enum anonymous)false;
  signed int return_value_strcmp_11;
  return_value_strcmp_11=strcmp(opt->progname, "pdsh");
  _Bool tmp_if_expr_13;
  signed int return_value_strcmp_12;
  if(return_value_strcmp_11 == 0)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_strcmp_12=strcmp(opt->progname, "dsh");
    tmp_if_expr_13 = !(return_value_strcmp_12 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_6;
  _Bool tmp_if_expr_8;
  signed int return_value_strcmp_7;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_5;
  if(tmp_if_expr_13)
    personality = (enum anonymous_5)DSH;

  else
  {
    return_value_strcmp_6=strcmp(opt->progname, "pdcp");
    if(return_value_strcmp_6 == 0)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_strcmp_7=strcmp(opt->progname, "dcp");
      tmp_if_expr_8 = !(return_value_strcmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(opt->progname, "pcp");
      tmp_if_expr_10 = !(return_value_strcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
      personality = (enum anonymous_5)PCP;

    else
    {
      return_value_strcmp_5=strcmp(opt->progname, "rpdcp");
      if(return_value_strcmp_5 == 0)
      {
        personality = (enum anonymous_5)PCP;
        opt->reverse_copy = (enum anonymous)true;
      }

      else
        errx("%p: program must be named pdsh/dsh/pdcp/dcp/pcp/rpdcp\n");
    }
  }
  if(pdsh_options == ((char *)NULL))
    _init_pdsh_options();

  unsigned int return_value_getuid_14;
  return_value_getuid_14=getuid();
  pw=getpwuid(return_value_getuid_14);
  if(!(pw == ((struct passwd *)NULL)))
  {
    copy_username(opt->luser, pw->pw_name);
    copy_username(opt->ruser, pw->pw_name);
    opt->luid = pw->pw_uid;
  }

  else
    errx("%p: who are you?\n");
  opt->info_only = (enum anonymous)false;
  opt->test_range_expansion = (enum anonymous)false;
  opt->wcoll = (struct hostlist *)(void *)0;
  opt->connect_timeout = 10;
  opt->command_timeout = 0;
  opt->fanout = 32;
  opt->sigint_terminates = (enum anonymous)false;
  opt->infile_names = (struct list *)(void *)0;
  opt->altnames = (enum anonymous)false;
  opt->debug = (enum anonymous)false;
  opt->labels = (enum anonymous)true;
  opt->rcmd_name = (char *)(void *)0;
  opt->misc_modules = (char *)(void *)0;
  opt->resolve_hosts = (enum anonymous)true;
  opt->kill_on_fail = (enum anonymous)false;
  opt->dshpath = (char *)(void *)0;
  opt->getstat = (char *)(void *)0;
  opt->ret_remote_rc = (enum anonymous)false;
  opt->cmd = (char *)(void *)0;
  opt->stdin_unavailable = (enum anonymous)false;
  opt->separate_stderr = (enum anonymous)true;
  opt->local_program_path=_find_path(argv0);
  opt->remote_program_path=Strdup(opt->local_program_path);
  opt->outfile_name = (char *)(void *)0;
  opt->recursive = (enum anonymous)false;
  opt->preserve = (enum anonymous)false;
  opt->pcp_server = (enum anonymous)false;
  opt->target_is_directory = (enum anonymous)false;
  opt->pcp_client = (enum anonymous)false;
  opt->pcp_client_host = (char *)(void *)0;
  goto __CPROVER_DUMP_L14;

__CPROVER_DUMP_L14:
  ;
}

// opt_env
// file ../../src/pdsh/opt.h line 99
void opt_env(struct anonymous_1 *opt)
{
  char *rhs;
  rhs=getenv("FANOUT");
  signed int return_value_string_to_int_1;
  if(!(rhs == ((char *)NULL)))
  {
    return_value_string_to_int_1=string_to_int(rhs, &opt->fanout);
    if(!(return_value_string_to_int_1 >= 0))
      errx("%p: Invalid environment variable FANOUT=%s\n", rhs);

  }

  rhs=getenv("PDSH_RCMD_TYPE");
  if(!(rhs == ((char *)NULL)))
    opt->rcmd_name=Strdup(rhs);

  rhs=getenv("PDSH_MISC_MODULES");
  if(!(rhs == ((char *)NULL)))
    opt->misc_modules=Strdup(rhs);

  rhs=getenv("DSHPATH");
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(!(rhs == ((char *)NULL)))
  {
    struct passwd *pw;
    pw=getpwnam(opt->luser);
    char *shell = "sh";
    if(!(pw == ((struct passwd *)NULL)))
    {
      if(!(*pw->pw_shell == 0))
        shell=xbasename(pw->pw_shell);

    }

    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(shell, "csh");
    if(return_value_strcmp_2 == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strcmp_3=strcmp(shell, "tcsh");
      tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      opt->dshpath=Strdup("setenv PATH ");
      xstrcat(&opt->dshpath, rhs);
      xstrcat(&opt->dshpath, ";");
    }

    else
    {
      opt->dshpath=Strdup("PATH=");
      xstrcat(&opt->dshpath, rhs);
      xstrcat(&opt->dshpath, ";");
    }
  }

  enum anonymous_5 return_value_pdsh_personality_5;
  return_value_pdsh_personality_5=pdsh_personality();
  if((signed int)return_value_pdsh_personality_5 == PCP)
  {
    rhs=getenv("PDSH_REMOTE_PDCP_PATH");
    if(!(rhs == ((char *)NULL)))
    {
      Free((void **)&opt->remote_program_path);
      opt->remote_program_path=Strdup(rhs);
    }

  }

}

// opt_free
// file ../../src/pdsh/opt.h line 104
void opt_free(struct anonymous_1 *opt)
{
  if(!(opt->wcoll == ((struct hostlist *)NULL)))
    hostlist_destroy(opt->wcoll);

  if(!(opt->cmd == ((char *)NULL)))
    Free((void **)&opt->cmd);

  if(!(opt->rcmd_name == ((char *)NULL)))
    Free((void **)&opt->rcmd_name);

  if(!(opt->misc_modules == ((char *)NULL)))
    Free((void **)&opt->misc_modules);

  if(!(pdsh_options == ((char *)NULL)))
    Free((void **)&pdsh_options);

  if(!(opt->dshpath == ((char *)NULL)))
    Free((void **)&opt->dshpath);

  if(!(opt->local_program_path == ((char *)NULL)))
    Free((void **)&opt->local_program_path);

  if(!(opt->remote_program_path == ((char *)NULL)))
    Free((void **)&opt->remote_program_path);

  if(!(opt->infile_names == ((struct list *)NULL)))
    list_destroy(opt->infile_names);

  if(!(opt->luser == ((char *)NULL)))
    Free((void **)&opt->luser);

  if(!(opt->ruser == ((char *)NULL)))
    Free((void **)&opt->ruser);

  rcmd_exit();
}

// opt_list
// file ../../src/pdsh/opt.h line 103
void opt_list(struct anonymous_1 *opt)
{
  char wcoll_str[1024l];
  signed int n;
  char *tmp_if_expr_1;
  char *tmp_if_expr_2;
  char *tmp_if_expr_3;
  char *tmp_if_expr_5;
  if((signed int)personality == DSH)
  {
    out("-- DSH-specific options --\n");
    out("Separate stderr/stdout\t%s\n", opt->separate_stderr != (enum anonymous)0 ? "Yes" : "No");
    if(!(opt->dshpath == ((char *)NULL)))
      tmp_if_expr_1 = opt->dshpath;

    else
      tmp_if_expr_1 = "none";
    out("Path prepended to cmd\t%s\n", tmp_if_expr_1);
    if(!(opt->getstat == ((char *)NULL)))
      tmp_if_expr_2 = opt->getstat;

    else
      tmp_if_expr_2 = "none";
    out("Appended to cmd         %s\n", tmp_if_expr_2);
    if(!(opt->cmd == ((char *)NULL)))
      tmp_if_expr_3 = opt->cmd;

    else
      tmp_if_expr_3 = "none";
    out("Command:\t\t%s\n", tmp_if_expr_3);
  }

  else
  {
    char infiles[4096l];
    out("-- PCP-specific options --\n");
    signed int return_value_list_join_4;
    return_value_list_join_4=list_join(infiles, sizeof(char [4096l]) /*4096ul*/ , ", ", opt->infile_names);
    if(!(return_value_list_join_4 == 0))
      out("Infile(s)\t\t%s\n", (const void *)infiles);

    if(!(opt->outfile_name == ((char *)NULL)))
      tmp_if_expr_5 = opt->outfile_name;

    else
      tmp_if_expr_5 = "none";
    out("Outfile\t\t\t%s\n", tmp_if_expr_5);
    out("Recursive\t\t%s\n", opt->recursive != (enum anonymous)0 ? "Yes" : "No");
    out("Preserve mod time/mode\t%s\n", opt->preserve != (enum anonymous)0 ? "Yes" : "No");
    if(!(opt->pcp_server == /*enum*/false))
    {
      out("pcp server         \t%s\n", opt->pcp_server != (enum anonymous)0 ? "Yes" : "No");
      out("target is directory\t%s\n", opt->target_is_directory != (enum anonymous)0 ? "Yes" : "No");
    }

  }
  char *tmp_if_expr_6;
  char *tmp_if_expr_7;
  char *tmp_if_expr_8;
  if(opt->pcp_server == /*enum*/false)
  {
    if(!(opt->local_program_path == ((char *)NULL)))
      tmp_if_expr_6 = opt->local_program_path;

    else
      tmp_if_expr_6 = "none";
    out("Full program pathname\t%s\n", tmp_if_expr_6);
    if(!(opt->remote_program_path == ((char *)NULL)))
      tmp_if_expr_7 = opt->remote_program_path;

    else
      tmp_if_expr_7 = "none";
    out("Remote program path\t%s\n", tmp_if_expr_7);
    out("\n-- Generic options --\n");
    out("Local username\t\t%s\n", opt->luser);
    out("Local uid     \t\t%d\n", opt->luid);
    out("Remote username\t\t%s\n", opt->ruser);
    if(!(opt->rcmd_name == ((char *)NULL)))
      tmp_if_expr_8 = opt->rcmd_name;

    else
      tmp_if_expr_8 = "none";
    out("Rcmd type\t\t%s\n", tmp_if_expr_8);
    out("one ^C will kill pdsh   %s\n", opt->sigint_terminates != (enum anonymous)0 ? "Yes" : "No");
    out("Connect timeout (secs)\t%d\n", opt->connect_timeout);
    out("Command timeout (secs)\t%d\n", opt->command_timeout);
    out("Fanout\t\t\t%d\n", opt->fanout);
    out("Display hostname labels\t%s\n", opt->labels != (enum anonymous)0 ? "Yes" : "No");
    out("Debugging       \t%s\n", opt->debug != (enum anonymous)0 ? "Yes" : "No");
    out("\n-- Target nodes --\n");
    if(!(opt->test_range_expansion == /*enum*/false))
    {
      signed long int return_value_hostlist_deranged_string_9;
      return_value_hostlist_deranged_string_9=hostlist_deranged_string(opt->wcoll, sizeof(char [1024l]) /*1024ul*/ , wcoll_str);
      n = (signed int)return_value_hostlist_deranged_string_9;
    }

    else
    {
      signed long int return_value_hostlist_ranged_string_10;
      return_value_hostlist_ranged_string_10=hostlist_ranged_string(opt->wcoll, sizeof(char [1024l]) /*1024ul*/ , wcoll_str);
      n = (signed int)return_value_hostlist_ranged_string_10;
    }
    if(!(n >= 0))
      out("%s[truncated]\n", (const void *)wcoll_str);

    else
      out("%s\n", (const void *)wcoll_str);
  }

}

// opt_register
// file ../../src/pdsh/opt.h line 150
enum anonymous opt_register(struct pdsh_module_option *opt_table)
{
  struct pdsh_module_option *p;
  _Bool tmp_if_expr_1;
  char *return_value_strchr_2;
  _Bool tmp_if_expr_3;
  if(opt_table == ((struct pdsh_module_option *)NULL))
    return (enum anonymous)true;

  else
  {
    if(pdsh_options == ((char *)NULL))
      _init_pdsh_options();

    p = opt_table;
    do
    {
      if(!(p == ((struct pdsh_module_option *)NULL)))
        tmp_if_expr_1 = (signed int)p->opt != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      if(!((p->personality & (signed int)personality) == 0))
      {
        return_value_strchr_2=strchr(pdsh_options, (signed int)p->opt);
        if(!(return_value_strchr_2 == ((char *)NULL)))
          return (enum anonymous)false;

      }

      p = p + 1l;
    }
    while((_Bool)1);
    p = opt_table;
    do
    {
      if(!(p == ((struct pdsh_module_option *)NULL)))
        tmp_if_expr_3 = (signed int)p->opt != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      if(!((p->personality & (signed int)personality) == 0))
      {
        xstrcatchar(&pdsh_options, p->opt);
        if(!(p->arginfo == ((char *)NULL)))
          xstrcatchar(&pdsh_options, (char)58);

      }

      p = p + 1l;
    }
    while((_Bool)1);
    return (enum anonymous)true;
  }
}

// opt_verify
// file ../../src/pdsh/opt.h line 102
enum anonymous opt_verify(struct anonymous_1 *opt)
{
  enum anonymous verified = (enum anonymous)true;
  signed int return_value_mod_postop_1;
  return_value_mod_postop_1=mod_postop(opt);
  if(return_value_mod_postop_1 >= 1)
    verified = (enum anonymous)false;

  if((signed int)personality == DSH)
  {
    if(!(opt->stdin_unavailable == /*enum*/false))
    {
      if(opt->cmd == ((char *)NULL))
      {
        _usage(opt);
        verified = (enum anonymous)false;
      }

    }

  }

  _Bool tmp_if_expr_3;
  signed int return_value_hostlist_count_2;
  if(opt->pcp_server == /*enum*/false)
  {
    if(opt->pcp_client == /*enum*/false)
    {
      if(opt->wcoll == ((struct hostlist *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_hostlist_count_2=hostlist_count(opt->wcoll);
        tmp_if_expr_3 = return_value_hostlist_count_2 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        err("%p: no remote hosts specified\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->connect_timeout >= 0))
      {
        err("%p: connect timeout must be >= 0\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->command_timeout >= 0))
      {
        err("%p: command timeout must be >= 0\n");
        verified = (enum anonymous)false;
      }

    }

  }

  _Bool tmp_if_expr_5;
  signed int return_value_list_is_empty_4;
  if((signed int)personality == PCP)
  {
    if(opt->pcp_server == /*enum*/false)
    {
      if(opt->pcp_client == /*enum*/false)
      {
        if(opt->outfile_name == ((char *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_list_is_empty_4=list_is_empty(opt->infile_names);
          tmp_if_expr_5 = return_value_list_is_empty_4 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          err("%p: pcp requires source and dest filenames\n");
          verified = (enum anonymous)false;
        }

        if(!(opt->target_is_directory == /*enum*/false))
        {
          err("%p: target is directory can only be specified with pcp server\n");
          verified = (enum anonymous)false;
        }

        if(opt->reverse_copy == /*enum*/false)
        {
          signed int return_value__infile_names_check_6;
          return_value__infile_names_check_6=_infile_names_check(opt);
          if(return_value__infile_names_check_6 == 0)
            verified = (enum anonymous)false;

        }

        if(!(opt->reverse_copy == /*enum*/false))
        {
          if(!(opt->outfile_name == ((char *)NULL)))
          {
            struct stat statbuf;
            signed int return_value_stat_7;
            return_value_stat_7=stat(opt->outfile_name, &statbuf);
            if(!(return_value_stat_7 >= 0))
            {
              err("%p: can't stat %s\n", opt->outfile_name);
              verified = (enum anonymous)false;
            }

            if(!((61440u & statbuf.st_mode) == 16384u))
            {
              err("%p: reverse copy dest must be a directory\n");
              verified = (enum anonymous)false;
            }

          }

        }

      }

    }

  }

  if((signed int)personality == PCP)
  {
    if(!(opt->pcp_server == /*enum*/false))
    {
      if(!(opt->pcp_client == /*enum*/false))
      {
        err("%p: pcp server and pcp client cannot both be set\n");
        verified = (enum anonymous)false;
      }

    }

  }

  signed int return_value_list_is_empty_8;
  if((signed int)personality == PCP)
  {
    if(!(opt->pcp_server == /*enum*/false))
    {
      if(!(opt->infile_names == ((struct list *)NULL)))
      {
        return_value_list_is_empty_8=list_is_empty(opt->infile_names);
        if(return_value_list_is_empty_8 == 0)
        {
          err("%p: do not list source files with pcp server\n");
          verified = (enum anonymous)false;
        }

      }

      if(opt->outfile_name == ((char *)NULL))
      {
        err("%p: output file must be specified with pcp server\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->pcp_client_host == ((char *)NULL)))
      {
        err("%p: pcp client host should not be specified with pcp server\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->reverse_copy == /*enum*/false))
      {
        err("%p: reverse copy cannot be specified with pcp server\n");
        verified = (enum anonymous)false;
      }

    }

  }

  _Bool tmp_if_expr_10;
  signed int return_value_list_is_empty_9;
  signed int return_value__infile_names_check_11;
  if((signed int)personality == PCP)
  {
    if(!(opt->pcp_client == /*enum*/false))
    {
      opt->reverse_copy = (enum anonymous)false;
      if(opt->infile_names == ((struct list *)NULL))
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_list_is_empty_9=list_is_empty(opt->infile_names);
        tmp_if_expr_10 = return_value_list_is_empty_9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
      {
        err("%p: list source files required for pcp client\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->outfile_name == ((char *)NULL)))
      {
        err("%p: output file should not be specified with pcp client\n");
        verified = (enum anonymous)false;
      }

      if(opt->pcp_client_host == ((char *)NULL))
      {
        err("%p: pcp client host must be specified with pcp client\n");
        verified = (enum anonymous)false;
      }

      if(!(opt->infile_names == ((struct list *)NULL)))
      {
        return_value__infile_names_check_11=_infile_names_check(opt);
        if(return_value__infile_names_check_11 == 0)
          verified = (enum anonymous)false;

      }

    }

  }

  return verified;
}

// out
// file ../../src/common/err.h line 36
void out(char *format, ...)
{
  void **ap = (void **)&format;
  _verr(stdout, format, ap);
  ap = ((void **)NULL);
}

// p_rresvport_af
// file privsep.c line 208
static signed int p_rresvport_af(signed int *port, signed int family)
{
  signed int return_value_rresvport_af_1;
  return_value_rresvport_af_1=rresvport_af(port, (unsigned short int)family);
  return return_value_rresvport_af_1;
}

// pcp_client
// file pcp_client.h line 65
signed int pcp_client(struct pcp_client *pcp)
{
  signed int return_value_pcp_response_2;
  return_value_pcp_response_2=pcp_response(pcp->infd, pcp->host);
  void *return_value_list_next_1;
  if(return_value_pcp_response_2 >= 0)
  {
    struct pcp_filename *pf;
    struct listIterator *i;
    i=list_iterator_create(pcp->infiles);
    do
    {
      return_value_list_next_1=list_next(i);
      pf = (struct pcp_filename *)return_value_list_next_1;
      if(pf == ((struct pcp_filename *)NULL))
        break;

      _pcp_sendfile(pf, pcp);
    }
    while((_Bool)1);
    list_iterator_destroy(i);
    return 0;
  }

  return -1;
}

// pcp_expand_dirs
// file pcp_client.h line 54
struct list * pcp_expand_dirs(struct list *infiles)
{
  struct list *new;
  new=list_create((void (*)(void *))(void *)0);
  struct stat sb;
  char *name;
  struct listIterator *i;
  i=list_iterator_create(infiles);
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    name = (char *)return_value_list_next_1;
    if(name == ((char *)NULL))
      break;

    struct pcp_filename *pf = (struct pcp_filename *)(void *)0;
    signed int return_value_access_2;
    return_value_access_2=access(name, 4);
    if(!(return_value_access_2 >= 0))
      errx("%p: access: %s: %m\n", name);

    signed int return_value_stat_3;
    return_value_stat_3=stat(name, &sb);
    if(!(return_value_stat_3 >= 0))
      errx("%p: stat: %s: %m\n", name);

    void *return_value_Malloc_4;
    return_value_Malloc_4=Malloc(sizeof(struct pcp_filename) /*16ul*/ );
    pf = (struct pcp_filename *)return_value_Malloc_4;
    pf->filename = name;
    pf->file_specified_by_user = 1;
    list_append(new, (void *)pf);
    if((61440u & sb.st_mode) == 16384u)
      _rexpand_dir(new, name);

  }
  while((_Bool)1);
  return new;
}

// pcp_response
// file pcp_client.c line 261
static signed int pcp_response(signed int infd, char *host)
{
  char resp;
  signed int i = 0;
  signed int result = -1;
  signed int n;
  char errstr[8192l];
  signed long int return_value_read_1;
  return_value_read_1=read(infd, (void *)&resp, sizeof(char) /*1ul*/ );
  n = (signed int)return_value_read_1;
  signed int tmp_post_2;
  if(!((unsigned long int)n == sizeof(char) /*1ul*/ ))
    return -1;

  else
  {
    if(!((signed int)resp == 0))
    {
      if((signed int)resp == 1)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      result = 0;
      goto __CPROVER_DUMP_L5;
    }
    tmp_post_2 = i;
    i = i + 1;
    errstr[(signed long int)tmp_post_2] = resp;
    result = 0;

  __CPROVER_DUMP_L4:
    ;
    fd_read_line(infd, (void *)&errstr[(signed long int)i], (unsigned long int)(8192 - i));
    err("%p: %S: %s: %s", host, result != 0 ? "fatal" : "error", (const void *)errstr);

  __CPROVER_DUMP_L5:
    ;
    return result;
  }
}

// pcp_sendfile
// file pcp_client.c line 288
signed int pcp_sendfile(struct pcp_client *pcp, char *file, char *output_file)
{
  signed int result = 0;
  char tmpstr[8192l];
  char *template;
  struct stat sb;
  if(output_file == ((char *)NULL))
    output_file = file;

  signed int return_value_stat_1;
  return_value_stat_1=stat(file, &sb);
  signed int return_value_pcp_response_8;
  if(!(return_value_stat_1 >= 0))
    err("%S: %s: %m\n", pcp->host, file);

  else
  {
    if(!(pcp->preserve == /*enum*/false))
    {
      snprintf(tmpstr, sizeof(char [8192l]) /*8192ul*/ , "T%ld %ld %ld %ld\n", (signed long int)sb.st_mtim.tv_sec, 0L, sb.st_atim.tv_sec, 0L);
      signed int return_value_pcp_sendstr_2;
      return_value_pcp_sendstr_2=pcp_sendstr(pcp->outfd, tmpstr, pcp->host);
      if(!(return_value_pcp_sendstr_2 >= 0))
        goto fail;

      signed int return_value_pcp_response_3;
      return_value_pcp_response_3=pcp_response(pcp->infd, pcp->host);
      if(!(return_value_pcp_response_3 >= 0))
        goto fail;

    }

    if((61440u & sb.st_mode) == 16384u)
    {
      char *return_value_xbasename_4;
      return_value_xbasename_4=xbasename(output_file);
      snprintf(tmpstr, sizeof(char [8192l]) /*8192ul*/ , "D%04o %d %s\n", sb.st_mode & (unsigned int)(04000 | 02000 | 01000 | 0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3), 0, return_value_xbasename_4);
      signed int return_value_pcp_sendstr_5;
      return_value_pcp_sendstr_5=pcp_sendstr(pcp->outfd, tmpstr, pcp->host);
      if(!(return_value_pcp_sendstr_5 >= 0))
        goto fail;

    }

    else
    {
      template = sizeof(signed long int) /*8ul*/  > sizeof(signed long int) /*8ul*/  ? "C%04o %lld %s\n" : "C%04o %ld %s\n";
      char *return_value_xbasename_6;
      return_value_xbasename_6=xbasename(output_file);
      snprintf(tmpstr, sizeof(char [8192l]) /*8192ul*/ , template, sb.st_mode & (unsigned int)(04000 | 02000 | 01000 | 0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3), sb.st_size, return_value_xbasename_6);
      signed int return_value_pcp_sendstr_7;
      return_value_pcp_sendstr_7=pcp_sendstr(pcp->outfd, tmpstr, pcp->host);
      if(!(return_value_pcp_sendstr_7 >= 0))
        goto fail;

    }
    return_value_pcp_response_8=pcp_response(pcp->infd, pcp->host);
    if(return_value_pcp_response_8 >= 0)
    {
      if((61440u & sb.st_mode) == 32768u)
      {
        signed int return_value__pcp_send_file_data_9;
        return_value__pcp_send_file_data_9=_pcp_send_file_data(pcp->outfd, file, pcp->host);
        if(!(return_value__pcp_send_file_data_9 >= 0))
          goto fail;

        signed int return_value__pcp_write_10;
        return_value__pcp_write_10=_pcp_write(pcp->outfd, "", 1);
        if(!(return_value__pcp_write_10 >= 0))
          goto fail;

        signed int return_value_pcp_response_11;
        return_value_pcp_response_11=pcp_response(pcp->infd, pcp->host);
        if(!(return_value_pcp_response_11 >= 0))
          goto fail;

      }

      result = 1;
    }

  }

fail:
  ;
  return result;
}

// pcp_sendstr
// file pcp_client.c line 242
static signed int pcp_sendstr(signed int outfd, char *str, char *host)
{
  signed int n;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  n=_pcp_write(outfd, str, (signed int)return_value_strlen_1);
  if(!(n >= 0))
    return -1;

  else
    return 0;
}

// pcp_server
// file pcp_server.h line 44
signed int pcp_server(struct pcp_server *svr)
{
  struct _buf buffer;
  memset((void *)&buffer, 0, sizeof(struct _buf) /*16ul*/ );
  _sink(svr, svr->outfile, &buffer);
  if(!(buffer.buf == ((char *)NULL)))
    free((void *)buffer.buf);

  return 0;
}

// pdsh_personality
// file ../../src/pdsh/opt.h line 109
enum anonymous_5 pdsh_personality(void)
{
  return personality;
}

// pdsh_remote_argc
// file opt.c line 155
signed int pdsh_remote_argc(void)
{
  return remote_argc;
}

// pdsh_remote_argv
// file opt.c line 150
const char ** pdsh_remote_argv(void)
{
  return (const char **)remote_argv;
}

// pipe_info_create
// file pipecmd.c line 62
struct pipe_info_struct * pipe_info_create(const char *path, const char *target, const char *user, signed int rank)
{
  struct pipe_info_struct *e;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct pipe_info_struct) /*64ul*/ );
  e = (struct pipe_info_struct *)return_value_Malloc_1;
  e->path=Strdup(path);
  char *return_value_xbasename_2;
  return_value_xbasename_2=xbasename(e->path);
  e->cmd=Strdup(return_value_xbasename_2);
  e->target=Strdup(target);
  e->username=Strdup(user);
  e->rank = rank;
  e->pid = (signed int)0;
  e->args = (char **)(void *)0;
  e->fd = -1;
  e->efd = -1;
  return e;
}

// pipe_info_destroy
// file pipecmd.c line 81
static void pipe_info_destroy(struct pipe_info_struct *e)
{
  if(!(e == ((struct pipe_info_struct *)NULL)))
  {
    Free((void **)&e->path);
    Free((void **)&e->cmd);
    Free((void **)&e->target);
    Free((void **)&e->username);
    Free((void **)&e);
  }

}

// pipecmd
// file ../../src/common/pipecmd.h line 40
struct pipe_info_struct * pipecmd(const char *path, const char **args, const char *target, const char *user, signed int rank)
{
  struct pipe_info_struct *p;
  p=pipe_info_create(path, target, user, rank);
  p->args=cmd_args_create(p, args);
  p->fd=_pipecmd(p->path, p->args, &p->efd, &p->pid);
  if(p->fd == 0)
  {
    err("%p: exec cmd %s failed for host %S\n", path, target);
    pipecmd_destroy(p);
    return (struct pipe_info_struct *)(void *)0;
  }

  else
    return p;
}

// pipecmd_destroy
// file ../../src/common/pipecmd.h line 46
void pipecmd_destroy(struct pipe_info_struct *p)
{
  cmd_args_destroy(p->args);
  pipe_info_destroy(p);
}

// pipecmd_format_arg
// file pipecmd.c line 93
static char * pipecmd_format_arg(struct pipe_info_struct *e, const char *arg)
{
  char buf[64l];
  const char *q;
  const char *p;
  char *str = (char *)(void *)0;
  p = arg;
  q = p;
  for( ; !((signed int)*p == 0); p = p + 1l)
    if((signed int)*p == 37)
    {
      p = p + 1l;
      switch((signed int)*p)
      {
        case 104:
        {
          xstrcat(&str, e->target);
          break;
        }
        case 117:
        {
          xstrcat(&str, e->username);
          break;
        }
        case 110:
        {
          snprintf(buf, sizeof(char [64l]) /*64ul*/  - (unsigned long int)1, "%d", e->rank);
          xstrcat(&str, buf);
          break;
        }
        case 37:
        {
          xstrcatchar(&str, (char)37);
          break;
        }
        default:
        {
          xstrcatchar(&str, (char)37);
          xstrcatchar(&str, *p);
        }
      }
    }

    else
      xstrcatchar(&str, *p);
  return str;
}

// pipecmd_signal
// file pipecmd.c line 205
signed int pipecmd_signal(struct pipe_info_struct *p, signed int signo)
{
  char *cmd;
  if(p == ((struct pipe_info_struct *)NULL))
    return -1;

  else
  {
    cmd=xbasename(p->path);
    err("sending signal %d to %s [%s] pid %d\n", signo, p->target, cmd, p->pid);
    signed int return_value_kill_1;
    return_value_kill_1=kill(p->pid, signo);
    return return_value_kill_1;
  }
}

// pipecmd_stderrfd
// file pipecmd.c line 198
signed int pipecmd_stderrfd(struct pipe_info_struct *p)
{
  if(p == ((struct pipe_info_struct *)NULL))
    return -1;

  else
    return p->efd;
}

// pipecmd_stdoutfd
// file ../../src/common/pipecmd.h line 51
signed int pipecmd_stdoutfd(struct pipe_info_struct *p)
{
  if(p == ((struct pipe_info_struct *)NULL))
    return -1;

  else
    return p->fd;
}

// pipecmd_target
// file pipecmd.c line 240
const char * pipecmd_target(struct pipe_info_struct *p)
{
  return p->target;
}

// pipecmd_wait
// file ../../src/common/pipecmd.h line 64
signed int pipecmd_wait(struct pipe_info_struct *p, signed int *pstatus)
{
  signed int status = 0;
  char *return_value_xbasename_1;
  char *return_value_xbasename_3;
  if(p == ((struct pipe_info_struct *)NULL))
    return -1;

  else
  {
    signed int return_value_waitpid_2;
    return_value_waitpid_2=waitpid(p->pid, &status, 0);
    if(!(return_value_waitpid_2 >= 0))
    {
      return_value_xbasename_1=xbasename(p->path);
      err("%p: %S: %s pid %ld: waitpid: %m\n", p->target, return_value_xbasename_1, p->pid);
    }

    if(!(status == 0))
    {
      return_value_xbasename_3=xbasename(p->path);
      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_24
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      err("%p: %S: %s exited with exit code %d\n", p->target, return_value_xbasename_3, (((union anonymous_24){ .__in=status }).__i & 0xff00) >> 8);
    }

    if(!(pstatus == ((signed int *)NULL)))
      *pstatus = status;

    return 0;
  }
}

// privsep_fini
// file privsep.h line 38
signed int privsep_fini(void)
{
  signed int status;
  if(!(client_fd >= 0) || !(cpid >= 0))
    return 0;

  else
  {
    close(client_fd);
    signed int return_value_waitpid_1;
    return_value_waitpid_1=waitpid(cpid, &status, 0);
    if(!(return_value_waitpid_1 >= 0))
    {
      err("%p: failed to reap priveleged child: %m\n");
      return -1;
    }

    else
    {
      if(!(status == 0))
        err("%p: privileged chiled exited with status %d\n", status);

      return 0;
    }
  }
}

// privsep_get_family
// file privsep.c line 66
static signed int privsep_get_family(signed int *lport)
{
  signed int family = *lport >> 16 & 0xffff;
  *lport = *lport & 0xffff;
  return family != 0 ? family : 2;
}

// privsep_init
// file privsep.h line 33
signed int privsep_init(void)
{
  unsigned int return_value_geteuid_1;
  return_value_geteuid_1=geteuid();
  unsigned int return_value_getuid_2;
  return_value_getuid_2=getuid();
  if(return_value_geteuid_1 == return_value_getuid_2)
    return 0;

  else
  {
    signed int return_value_create_socketpair_3;
    return_value_create_socketpair_3=create_socketpair();
    if(!(return_value_create_socketpair_3 >= 0))
      return -1;

    else
    {
      signed int return_value_create_privileged_child_4;
      return_value_create_privileged_child_4=create_privileged_child();
      return return_value_create_privileged_child_4;
    }
  }
}

// privsep_rresvport
// file privsep.c line 335
signed int privsep_rresvport(signed int *lport)
{
  signed int return_value_privsep_rresvport_af_1;
  return_value_privsep_rresvport_af_1=privsep_rresvport_af(lport, 2);
  return return_value_privsep_rresvport_af_1;
}

// privsep_rresvport_af
// file privsep.c line 305
signed int privsep_rresvport_af(signed int *lport, signed int family)
{
  signed int s = -1;
  signed int return_value_p_rresvport_af_1;
  if(!(client_fd >= 0))
  {
    return_value_p_rresvport_af_1=p_rresvport_af(lport, family);
    return return_value_p_rresvport_af_1;
  }

  else
  {
    signed int return_value_privsep_set_family_3;
    return_value_privsep_set_family_3=privsep_set_family(lport, family);
    if(!(return_value_privsep_set_family_3 >= 0))
    {
      err("%p: privsep_rresvport_af: Invalid family %d\n", family);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 22;
      return -1;
    }

    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4=pthread_mutex_lock(&privsep_mutex);
    if(!(*return_value___errno_location_4 == 0))
      errx("%p: %s:%d: mutex_lock: %m\n", (const void *)"privsep.c", 319);

    signed long int return_value_write_5;
    return_value_write_5=write(client_fd, (const void *)lport, sizeof(signed int) /*4ul*/ );
    if(!(return_value_write_5 >= 0l))
      err("%p: privsep: client write: %m\n");

    else
      s=recv_rresvport(client_fd, lport);

  out:
    ;
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6=pthread_mutex_unlock(&privsep_mutex);
    if(!(*return_value___errno_location_6 == 0))
      errx("%p: %s:%d: mutex_unlock: %m\n", (const void *)"privsep.c", 330);

    return s;
  }
}

// privsep_server
// file privsep.c line 222
static signed int privsep_server(void)
{
  signed int rc;
  signed int lport;
  close(client_fd);
  signed long int return_value_read_1;
  do
  {
    return_value_read_1=read(server_fd, (void *)&lport, sizeof(signed int) /*4ul*/ );
    rc = (signed int)return_value_read_1;
    if(!(rc >= 1))
      break;

    signed int family;
    family=privsep_get_family(&lport);
    signed int s;
    s=p_rresvport_af(&lport, family);
    send_rresvport(server_fd, s, lport);
    close(s);
  }
  while((_Bool)1);
  if(!(rc >= 0))
    err("%p: privsep: server read failed: %m\n");

  close(server_fd);
  return 0;
}

// privsep_set_family
// file privsep.c line 77
static signed int privsep_set_family(signed int *lport, signed int family)
{
  if(family >= 65536)
    return -1;

  else
  {
    *lport = *lport | family << 16;
    return 0;
  }
}

// rcmd_connect
// file ../../src/pdsh/rcmd.h line 80
signed int rcmd_connect(struct rcmd_info *rcmd, char *ahost, char *addr, char *locuser, char *remuser, char *cmd, signed int nodeid, enum anonymous error_fd)
{
  if(!(rcmd->ruser == ((char *)NULL)))
    remuser = rcmd->ruser;

  signed int *tmp_if_expr_1;
  if(!(error_fd == /*enum*/false))
    tmp_if_expr_1 = &rcmd->efd;

  else
    tmp_if_expr_1 = (signed int *)(void *)0;
  rcmd->fd=rcmd->rmod->rcmd(ahost, addr, locuser, remuser, cmd, nodeid, tmp_if_expr_1, &rcmd->arg);
  return rcmd->fd;
}

// rcmd_create
// file ../../src/pdsh/rcmd.h line 75
struct rcmd_info * rcmd_create(char *host)
{
  struct rcmd_info *rcmd = (struct rcmd_info *)(void *)0;
  struct rcmd_module *rmod = (struct rcmd_module *)(void *)0;
  struct node_rcmd_info *n = (struct node_rcmd_info *)(void *)0;
  n=host_rcmd_info(host);
  if(!(n == ((struct node_rcmd_info *)NULL)))
    rmod = n->rmod;

  if(rmod == ((struct rcmd_module *)NULL))
  {
    rmod = default_rcmd_module;
    if(!(rmod == ((struct rcmd_module *)NULL)))
      goto __CPROVER_DUMP_L2;

    err("%p: No rcmd module for \"%s\"\n", host);
    return (struct rcmd_info *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    rcmd=rcmd_info_create(rmod);
    if(rcmd == ((struct rcmd_info *)NULL))
    {
      err("%p: Unable to allocate rcmd info for \"%s\"\n", host);
      return (struct rcmd_info *)(void *)0;
    }

    else
    {
      if(!(n == ((struct node_rcmd_info *)NULL)))
      {
        if(!(n->username == ((char *)NULL)))
          rcmd->ruser = n->username;

      }

      return rcmd;
    }
  }
}

// rcmd_destroy
// file ../../src/pdsh/rcmd.h line 87
signed int rcmd_destroy(struct rcmd_info *rcmd)
{
  signed int rc = 0;
  if(rcmd == ((struct rcmd_info *)NULL))
    return 0;

  else
  {
    if(!(rcmd->rmod->rcmd_destroy == ((signed int (*)(void *))NULL)))
      rc=rcmd->rmod->rcmd_destroy(rcmd->arg);

    rcmd_info_destroy(rcmd);
    return rc;
  }
}

// rcmd_exit
// file rcmd.c line 401
signed int rcmd_exit(void)
{
  if(!(host_info_list == ((struct list *)NULL)))
    list_destroy(host_info_list);

  if(!(rcmd_module_list == ((struct list *)NULL)))
    list_destroy(rcmd_module_list);

  return 0;
}

// rcmd_get_default_module
// file rcmd.c line 238
char * rcmd_get_default_module(void)
{
  struct module_components *mod = (struct module_components *)(void *)0;
  signed int i = 0;
  const char *name = (const char *)(void *)0;
  signed int tmp_post_1;
  char *tmp_if_expr_3;
  char *return_value_mod_get_name_2;
  if(!(default_rcmd_module == ((struct rcmd_module *)NULL)))
    return default_rcmd_module->name;

  else
  {
    do
    {
      tmp_post_1 = i;
      i = i + 1;
      name = rcmd_rank[(signed long int)tmp_post_1];
      if(name == ((const char *)NULL))
        break;

      if(!(mod == ((struct module_components *)NULL)))
        break;

      mod=mod_get_module("rcmd", name);
    }
    while((_Bool)1);
    if(!(mod == ((struct module_components *)NULL)))
    {
      return_value_mod_get_name_2=mod_get_name(mod);
      tmp_if_expr_3 = return_value_mod_get_name_2;
    }

    else
      tmp_if_expr_3 = (char *)(void *)0;
    return tmp_if_expr_3;
  }
}

// rcmd_info_create
// file rcmd.c line 284
struct rcmd_info * rcmd_info_create(struct rcmd_module *rmod)
{
  struct rcmd_info *r;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct rcmd_info) /*40ul*/ );
  r = (struct rcmd_info *)return_value_Malloc_1;
  if(r == ((struct rcmd_info *)NULL))
    return (struct rcmd_info *)(void *)0;

  else
  {
    r->fd = -1;
    r->efd = -1;
    r->rmod = rmod;
    r->opts = &rmod->options;
    r->arg = (void *)0;
    r->ruser = (char *)(void *)0;
    return r;
  }
}

// rcmd_info_destroy
// file rcmd.c line 301
void rcmd_info_destroy(struct rcmd_info *r)
{
  Free((void **)&r);
}

// rcmd_init
// file ../../src/pdsh/rcmd.h line 94
signed int rcmd_init(struct anonymous_1 *opt)
{
  struct rcmd_module *r = (struct rcmd_module *)(void *)0;
  struct listIterator *i;
  if(rcmd_module_list == ((struct list *)NULL))
  {
    if(default_rcmd_module == ((struct rcmd_module *)NULL))
      return -1;

    current_rcmd_module = default_rcmd_module;
    default_rcmd_module->init(opt);
    current_rcmd_module = (struct rcmd_module *)(void *)0;
    return 0;
  }

  else
  {
    i=list_iterator_create(rcmd_module_list);
    void *return_value_list_next_1;
    return_value_list_next_1=list_next(i);
    r = (struct rcmd_module *)return_value_list_next_1;
    if(!(r == ((struct rcmd_module *)NULL)))
    {
      current_rcmd_module = r;
      r->init(opt);
      current_rcmd_module = (struct rcmd_module *)(void *)0;
    }

    list_iterator_destroy(i);
    return 0;
  }
}

// rcmd_module_create
// file rcmd.c line 102
struct rcmd_module * rcmd_module_create(struct module_components *mod)
{
  struct rcmd_module *rmod;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct rcmd_module) /*56ul*/ );
  rmod = (struct rcmd_module *)return_value_Malloc_1;
  rmod->mod = mod;
  rmod->name=mod_get_name(mod);
  signed int (*return_value_mod_get_rcmd_init_3)(struct anonymous_1 *);
  return_value_mod_get_rcmd_init_3=mod_get_rcmd_init(mod);
  rmod->init = (signed int (*)(struct anonymous_1 *))return_value_mod_get_rcmd_init_3;
  if(rmod->init == ((signed int (*)(struct anonymous_1 *))NULL))
  {
    char *return_value_mod_get_name_2;
    return_value_mod_get_name_2=mod_get_name(mod);
    err("Unable to resolve \"rcmd_init\" in module \"%s\"\n", return_value_mod_get_name_2);
    goto fail;
  }

  signed int (*return_value_mod_get_rcmd_signal_5)(signed int, void *, signed int);
  return_value_mod_get_rcmd_signal_5=mod_get_rcmd_signal(mod);
  rmod->signal = (signed int (*)(signed int, void *, signed int))return_value_mod_get_rcmd_signal_5;
  if(rmod->signal == ((signed int (*)(signed int, void *, signed int))NULL))
  {
    char *return_value_mod_get_name_4;
    return_value_mod_get_name_4=mod_get_name(mod);
    err("Unable to resolve \"rcmd_signal\" in module \"%s\"\n", return_value_mod_get_name_4);
    goto fail;
  }

  signed int (*return_value_mod_get_rcmd_7)(char *, char *, char *, char *, char *, signed int, signed int *, void **);
  return_value_mod_get_rcmd_7=mod_get_rcmd(mod);
  rmod->rcmd = (signed int (*)(char *, char *, char *, char *, char *, signed int, signed int *, void **))return_value_mod_get_rcmd_7;
  if(rmod->rcmd == ((signed int (*)(char *, char *, char *, char *, char *, signed int, signed int *, void **))NULL))
  {
    char *return_value_mod_get_name_6;
    return_value_mod_get_name_6=mod_get_name(mod);
    err("Unable to resolve \"rcmd\" in module \"%s\"\n", return_value_mod_get_name_6);
    goto fail;
  }

  signed int (*return_value_mod_get_rcmd_destroy_8)(void *);
  return_value_mod_get_rcmd_destroy_8=mod_get_rcmd_destroy(mod);
  rmod->rcmd_destroy = (signed int (*)(void *))return_value_mod_get_rcmd_destroy_8;
  rmod->options.resolve_hosts = (enum anonymous)1;
  return rmod;

fail:
  ;
  Free((void **)&rmod);
  return (struct rcmd_module *)(void *)0;
}

// rcmd_module_destroy
// file rcmd.c line 141
static void rcmd_module_destroy(struct rcmd_module *rmod)
{
  Free((void **)&rmod);
}

// rcmd_module_register
// file rcmd.c line 164
static struct rcmd_module * rcmd_module_register(char *name)
{
  struct module_components *mod = (struct module_components *)(void *)0;
  struct rcmd_module *rmod = (struct rcmd_module *)(void *)0;
  void *return_value_list_find_first_1;
  if(rcmd_module_list == ((struct list *)NULL))
    rcmd_module_list=list_create((void (*)(void *))rcmd_module_destroy);

  else
  {
    return_value_list_find_first_1=list_find_first(rcmd_module_list, (signed int (*)(void *, void *))find_rcmd_module, (void *)name);
    rmod = (struct rcmd_module *)return_value_list_find_first_1;
  }
  if(!(rmod == ((struct rcmd_module *)NULL)))
    return rmod;

  else
  {
    mod=mod_get_module("rcmd", name);
    if(mod == ((struct module_components *)NULL))
    {
      err("No such rcmd module \"%s\"\n", name);
      return (struct rcmd_module *)(void *)0;
    }

    else
    {
      rmod=rcmd_module_create(mod);
      if(rmod == ((struct rcmd_module *)NULL))
        return (struct rcmd_module *)(void *)0;

      else
      {
        void *return_value_list_append_2;
        return_value_list_append_2=list_append(rcmd_module_list, (void *)rmod);
        if(return_value_list_append_2 == NULL)
        {
          err("Failed to append rcmd module \"%s\"\n", name);
          rcmd_module_destroy(rmod);
          return (struct rcmd_module *)(void *)0;
        }

        else
          return rmod;
      }
    }
  }
}

// rcmd_opt_set
// file rcmd.c line 411
signed int rcmd_opt_set(signed int id, void *value)
{
  if(current_rcmd_module == ((struct rcmd_module *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 3;
    return -1;
  }

  if(id == 0x1)
  {
    current_rcmd_module->options.resolve_hosts = (enum anonymous)(signed long int)value;
    goto __CPROVER_DUMP_L4;
  }

  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  *return_value___errno_location_2 = 22;
  return -1;

__CPROVER_DUMP_L4:
  ;
  return 0;
}

// rcmd_register_default_rcmd
// file rcmd.c line 253
signed int rcmd_register_default_rcmd(char *rcmd_name)
{
  struct rcmd_module *rmod = (struct rcmd_module *)(void *)0;
  rmod=rcmd_module_register(rcmd_name);
  if(rmod == ((struct rcmd_module *)NULL))
    return -1;

  else
  {
    default_rcmd_module = rmod;
    return 0;
  }
}

// rcmd_register_defaults
// file rcmd.c line 262
signed int rcmd_register_defaults(char *hosts, char *rcmd_name, char *user)
{
  struct rcmd_module *rmod = (struct rcmd_module *)(void *)0;
  if(!(rcmd_name == ((char *)NULL)))
  {
    rmod=rcmd_module_register(rcmd_name);
    if(!(rmod == ((struct rcmd_module *)NULL)))
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(hosts == ((char *)NULL))
    {
      default_rcmd_module = rmod;
      return 0;
    }

    else
    {
      signed int return_value_hostlist_register_rcmd_1;
      return_value_hostlist_register_rcmd_1=hostlist_register_rcmd(hosts, rmod, user);
      if(!(return_value_hostlist_register_rcmd_1 >= 0))
        return -1;

      else
        return 0;
    }
  }
}

// rcmd_signal
// file ../../src/pdsh/rcmd.h line 92
signed int rcmd_signal(struct rcmd_info *rcmd, signed int signum)
{
  signed int return_value;
  return_value=rcmd->rmod->signal(rcmd->efd, rcmd->arg, signum);
  return return_value;
}

// read_wcoll
// file wcoll.h line 43
struct hostlist * read_wcoll(char *file, struct _IO_FILE *f)
{
  char path[4096l];
  struct hostlist *new;
  struct wcoll_ctx *ctx;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(file, "-");
  if(return_value_strcmp_1 == 0)
  {
    f = stdin;
    file = (char *)(void *)0;
  }

  _Bool tmp_if_expr_3;
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int return_value_access_2;
    return_value_access_2=access(file, 4);
    if(return_value_access_2 == -1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      fp=fopen(file, "r");
      tmp_if_expr_3 = !(fp != ((struct _IO_FILE *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      errx("%p: %s: %m\n", file);

  }

  else
    fp = f;
  get_file_path(file, path, (signed int)sizeof(char [4096l]) /*4096ul*/ );
  ctx=wcoll_ctx_create(path);
  wcoll_ctx_read_stream(ctx, fp);
  new = ctx->hl;
  wcoll_ctx_destroy(ctx);
  return new;
}

// read_wcoll_path
// file wcoll.c line 279
struct hostlist * read_wcoll_path(const char *path, const char *file)
{
  struct wcoll_ctx *ctx;
  struct hostlist *hl;
  ctx=wcoll_ctx_create(path);
  wcoll_ctx_read_file(ctx, file);
  hl = ctx->hl;
  wcoll_ctx_destroy(ctx);
  return hl;
}

// recv_rresvport
// file privsep.c line 165
static signed int recv_rresvport(signed int pipefd, signed int *lptr)
{
  signed int fd = -1;
  struct iovec iov[1l];
  struct msghdr msg;
  struct cmsghdr *cmsg;
  char *buf[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
  cmsg = (struct cmsghdr *)&buf;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  iov[0l].iov_base = (void *)lptr;
  iov[0l].iov_len = sizeof(signed int) /*4ul*/ ;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  cmsg->cmsg_level = 1;
  cmsg->cmsg_type = 1;
  cmsg->cmsg_len = sizeof(struct cmsghdr) /*16ul*/  + sizeof(signed int) /*4ul*/ ;
  msg.msg_control = (void *)(char *)cmsg;
  msg.msg_controllen = sizeof(struct cmsghdr) /*16ul*/  + sizeof(signed int) /*4ul*/ ;
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(pipefd, &msg, 0);
  if(!(return_value_recvmsg_1 >= 0l))
    err("%p: privsep: recvmsg: %m\n");

  if(!(*lptr >= 0))
    return -1;

  else
  {
    fd = *((signed int *)cmsg->__cmsg_data);
    return fd;
  }
}

// regex_info_create
// file opt.c line 1233
struct regex_info * regex_info_create(const char *r, signed int exclude)
{
  signed int rc;
  struct regex_info *re;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct regex_info) /*88ul*/ );
  re = (struct regex_info *)return_value_Malloc_1;
  re->pattern=Strdup(r);
  re->exclude = exclude;
  re->cflags = 1 | ((1 << 1) << 1) << 1;
  re->eflags = 0;
  re->compiled = 0;
  rc=regcomp(&re->reg, re->pattern, re->cflags);
  if(!(rc == 0))
  {
    char msg[4096l];
    regerror(rc, &re->reg, msg, sizeof(char [4096l]) /*4096ul*/ );
    err("%p: Error %s pattern \"%s\": %s\n", re->exclude != 0 ? "excluding" : "matching", re->pattern, (const void *)msg);
    regex_info_destroy(re);
    return (struct regex_info *)(void *)0;
  }

  re->compiled = 1;
  return re;
}

// regex_info_destroy
// file opt.c line 1224
void regex_info_destroy(struct regex_info *re)
{
  if(!(re->compiled == 0))
    regfree(&re->reg);

  if(!(re->pattern == ((char *)NULL)))
    Free((void **)&re->pattern);

  Free((void **)&re);
}

// send_rresvport
// file privsep.c line 116
static signed int send_rresvport(signed int pipefd, signed int fd, signed int lport)
{
  struct iovec iov[1l];
  struct msghdr msg;
  struct cmsghdr *cmsg;
  char *buf[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
  cmsg = (struct cmsghdr *)&buf;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  iov[0l].iov_base = (void *)&lport;
  iov[0l].iov_len = sizeof(signed int) /*4ul*/ ;
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  if(!(fd >= 0))
  {
    msg.msg_control = (void *)0;
    msg.msg_controllen = (unsigned long int)0;
    lport = -1;
  }

  else
  {
    cmsg->cmsg_level = 1;
    cmsg->cmsg_type = 1;
    cmsg->cmsg_len = sizeof(struct cmsghdr) /*16ul*/  + sizeof(signed int) /*4ul*/ ;
    msg.msg_control = (void *)(char *)cmsg;
    msg.msg_controllen = sizeof(struct cmsghdr) /*16ul*/  + sizeof(signed int) /*4ul*/ ;
    *((signed int *)cmsg->__cmsg_data) = fd;
  }
  signed long int return_value_sendmsg_1;
  return_value_sendmsg_1=sendmsg(pipefd, &msg, 0);
  if(!((unsigned long int)return_value_sendmsg_1 == sizeof(signed int) /*4ul*/ ))
  {
    err("%p: privsep: sendmsg: %m\n");
    return -1;
  }

  else
    return 0;
}

// strcmp_f
// file wcoll.c line 63
static signed int strcmp_f(char *a, char *b)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(a, b);
  return (signed int)(return_value_strcmp_1 == 0);
}

// string_to_int
// file opt.c line 425
static signed int string_to_int(const char *val, signed int *p2int)
{
  char *p;
  signed long int n;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  unsigned long int return_value_strtoul_2;
  return_value_strtoul_2=strtoul(val, &p, 10);
  n = (signed long int)return_value_strtoul_2;
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  _Bool tmp_if_expr_4;
  if(!(*return_value___errno_location_3 == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)*p != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
    return -1;

  else
  {
    *p2int = (signed int)n;
    return 0;
  }
}

// testcase
// file dsh.h line 97
void testcase(signed int testnum)
{
  enum anonymous_6 result;
  if((unsigned long int)testnum >= 2ul || !(testnum >= 0))
    errx("%P: Test %d unknown\n", testnum);

  result=testcases[(signed long int)testnum].fun();
  _testmsg(testnum, result);
  exit(0);
}

// wcoll_append_excluded
// file opt.c line 519
static void wcoll_append_excluded(struct anonymous_1 *opt, char *exclude_args)
{
  struct list *l;
  l=list_split(",", exclude_args);
  struct listIterator *i;
  i=list_iterator_create(l);
  char *s;
  void *return_value_list_next_1;
  do
  {
    return_value_list_next_1=list_next(i);
    s = (char *)return_value_list_next_1;
    if(s == ((char *)NULL))
      break;

    char *p = (char *)(void *)0;
    xstrcatchar(&p, (char)45);
    xstrcat(&p, s);
    wcoll_args_process(opt, p);
    Free((void **)&p);
  }
  while((_Bool)1);
  list_iterator_destroy(i);
  list_destroy(l);
}

// wcoll_apply_excluded
// file opt.c line 1394
static void wcoll_apply_excluded(struct anonymous_1 *opt, struct list *excludes)
{
  struct listIterator *i;
  char *arg;
  void *return_value_list_next_1;
  if(!(opt->wcoll == ((struct hostlist *)NULL)) && !(excludes == ((struct list *)NULL)))
  {
    i=list_iterator_create(excludes);
    do
    {
      return_value_list_next_1=list_next(i);
      arg = (char *)return_value_list_next_1;
      if(arg == ((char *)NULL))
        break;

      hostlist_delete(opt->wcoll, arg);
    }
    while((_Bool)1);
    list_iterator_destroy(i);
  }

}

// wcoll_apply_regex
// file opt.c line 1377
static void wcoll_apply_regex(struct anonymous_1 *opt, struct list *regexs)
{
  struct regex_info *re;
  struct listIterator *i;
  void *return_value_list_next_1;
  if(!(opt->wcoll == ((struct hostlist *)NULL)) && !(regexs == ((struct list *)NULL)))
  {
    i=list_iterator_create(regexs);
    do
    {
      return_value_list_next_1=list_next(i);
      re = (struct regex_info *)return_value_list_next_1;
      if(re == ((struct regex_info *)NULL))
        break;

      hostlist_filter_regex(opt->wcoll, re);
    }
    while((_Bool)1);
    list_iterator_destroy(i);
  }

}

// wcoll_arg_process
// file opt.c line 1295
static signed int wcoll_arg_process(char *arg, struct anonymous_1 *opt)
{
  struct regex_info *re;
  signed int excluded = 0;
  char *p = arg;
  if(exclude_list == ((struct list *)NULL))
    exclude_list=list_create(free_f);

  if(regex_list == ((struct list *)NULL))
    regex_list=list_create((void (*)(void *))regex_info_destroy);

  if((signed int)*p == 45)
  {
    excluded = 1;
    p = p + 1l;
  }

  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  if((signed int)*p == 94)
  {
    struct hostlist *hl;
    hl=read_wcoll(p + (signed long int)1, (struct _IO_FILE *)(void *)0);
    if(hl == ((struct hostlist *)NULL))
      errx("%p: Error reading wcoll: %s: %m\n", p + (signed long int)1);

    if(!(excluded == 0))
      list_push_hostlist(exclude_list, hl);

    else
      hostlist_assign(&opt->wcoll, hl);
    hostlist_destroy(hl);
  }

  else
    if((signed int)*p == 47)
    {
      signed int len;
      p = p + 1l;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(p);
      len = (signed int)return_value_strlen_2;
      if((signed int)p[(signed long int)(len + -1)] == 47)
        p[(signed long int)(len - 1)] = (char)0;

      re=regex_info_create(p, excluded);
      if(re == ((struct regex_info *)NULL))
        errx("%p: Fatal error\n");

      list_push(regex_list, (void *)re);
    }

    else
      if(!(excluded == 0))
      {
        char *return_value_Strdup_3;
        return_value_Strdup_3=Strdup(p);
        list_push(exclude_list, (void *)return_value_Strdup_3);
      }

      else
      {
        char *rcmd_type = (char *)(void *)0;
        char *hosts;
        char *user = (char *)(void *)0;
        if(opt->wcoll == ((struct hostlist *)NULL))
          opt->wcoll=hostlist_create("");

        get_host_rcmd_type(p, &rcmd_type, &hosts, &user);
        hostlist_push(opt->wcoll, hosts);
        if(!(rcmd_type == ((char *)NULL)) || !(user == ((char *)NULL)))
        {
          signed int return_value_rcmd_register_defaults_4;
          return_value_rcmd_register_defaults_4=rcmd_register_defaults(hosts, rcmd_type, user);
          if(!(return_value_rcmd_register_defaults_4 >= 0))
            errx("%p: Failed to register rcmd \"%s\" for \"%s\"\n", rcmd_type, hosts);

        }

      }
  return 0;
}

// wcoll_args_process
// file opt.c line 1368
static signed int wcoll_args_process(struct anonymous_1 *opt, char *args)
{
  signed int rc;
  struct list *l;
  l=list_split(",", args);
  rc=list_for_each(l, (signed int (*)(void *, void *))wcoll_arg_process, (void *)opt);
  list_destroy(l);
  return rc;
}

// wcoll_ctx_create
// file wcoll.c line 68
static struct wcoll_ctx * wcoll_ctx_create(const char *path)
{
  char *copy;
  copy=Strdup(path);
  struct wcoll_ctx *ctx;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct wcoll_ctx) /*24ul*/ );
  ctx = (struct wcoll_ctx *)return_value_Malloc_1;
  if(copy == ((char *)NULL) || ctx == ((struct wcoll_ctx *)NULL))
    errx("%p: wcoll_ctx_create: Out of memory\n");

  ctx->hl=hostlist_create("");
  ctx->path_list=list_split(":", copy);
  ctx->include_cache=list_create((void (*)(void *))free_f_link1);
  Free((void **)&copy);
  return ctx;
}

// wcoll_ctx_destroy
// file wcoll.c line 84
static void wcoll_ctx_destroy(struct wcoll_ctx *ctx)
{
  list_destroy(ctx->path_list);
  list_destroy(ctx->include_cache);
  ctx->hl = (struct hostlist *)(void *)0;
  Free((void **)&ctx);
}

// wcoll_ctx_file_is_cached
// file wcoll.c line 97
static signed int wcoll_ctx_file_is_cached(struct wcoll_ctx *ctx, char *file)
{
  void *return_value_list_find_first_1;
  return_value_list_find_first_1=list_find_first(ctx->include_cache, (signed int (*)(void *, void *))strcmp_f, (void *)file);
  if(!(return_value_list_find_first_1 == NULL))
    return 1;

  else
  {
    char *return_value_Strdup_2;
    return_value_Strdup_2=Strdup(file);
    list_push(ctx->include_cache, (void *)return_value_Strdup_2);
    return 0;
  }
}

// wcoll_ctx_path_lookup
// file wcoll.c line 110
static signed int wcoll_ctx_path_lookup(struct wcoll_ctx *ctx, const char *name, char *buf, signed int len)
{
  signed int rc = -1;
  struct listIterator *i;
  const char *s;
  void *return_value_list_next_1;
  if(name == ((const char *)NULL))
    return -1;

  else
  {
    i=list_iterator_create(ctx->path_list);
    do
    {
      return_value_list_next_1=list_next(i);
      s = (const char *)return_value_list_next_1;
      if(s == ((const char *)NULL))
        break;

      signed int n;
      n=snprintf(buf, (unsigned long int)len, "%s/%s", s, name);
      if(n >= len || !(n >= 0))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 28;
        break;
      }

      signed int return_value_access_3;
      return_value_access_3=access(buf, 4);
      if(return_value_access_3 >= 0)
      {
        rc = 0;
        break;
      }

    }
    while((_Bool)1);
    list_iterator_destroy(i);
    return rc;
  }
}

// wcoll_ctx_read_file
// file wcoll.c line 250
static signed int wcoll_ctx_read_file(struct wcoll_ctx *ctx, const char *f)
{
  char fq_path[4096l];
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  char *return_value_wcoll_ctx_resolve_path_1;
  return_value_wcoll_ctx_resolve_path_1=wcoll_ctx_resolve_path(ctx, f, fq_path, (signed int)sizeof(char [4096l]) /*4096ul*/ );
  if(return_value_wcoll_ctx_resolve_path_1 == ((char *)NULL))
    errx("%p: %s: %m\n", f);

  signed int return_value_wcoll_ctx_file_is_cached_2;
  return_value_wcoll_ctx_file_is_cached_2=wcoll_ctx_file_is_cached(ctx, fq_path);
  _Bool tmp_if_expr_4;
  if(!(return_value_wcoll_ctx_file_is_cached_2 == 0))
  {
    err("%p: warning: file '%s' included multiple times\n", f);
    return -1;
  }

  else
  {
    signed int return_value_access_3;
    return_value_access_3=access(fq_path, 4);
    if(return_value_access_3 == -1)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      fp=fopen(fq_path, "r");
      tmp_if_expr_4 = !(fp != ((struct _IO_FILE *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      errx("%p: %s: %m\n", f);

    wcoll_ctx_read_stream(ctx, fp);
    fclose(fp);
    return 0;
  }
}

// wcoll_ctx_read_line
// file wcoll.c line 204
static signed int wcoll_ctx_read_line(struct wcoll_ctx *ctx, char *line)
{
  char *p;
  char *included;
  p=strchr(line, 35);
  if(!(p == ((char *)NULL)))
  {
    if(p == line)
    {
      included=include_file(p);
      if(!(included == ((char *)NULL)))
        wcoll_ctx_read_file(ctx, included);

    }

    *p = (char)0;
  }

  xstrcln(line, (char *)(void *)0);
  signed int return_value_hostlist_push_1;
  if(!((signed int)*line == 0))
  {
    return_value_hostlist_push_1=hostlist_push(ctx->hl, line);
    if(return_value_hostlist_push_1 == 0)
      err("%p: warning: target '%s' not parsed\n", line);

  }

  return 0;
}

// wcoll_ctx_read_stream
// file wcoll.c line 226
static signed int wcoll_ctx_read_stream(struct wcoll_ctx *ctx, struct _IO_FILE *fp)
{
  char buf[2048l];
  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(buf, 2048, fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    wcoll_ctx_read_line(ctx, buf);
  }
  while((_Bool)1);
  return 0;
}

// wcoll_ctx_resolve_path
// file wcoll.c line 187
static char * wcoll_ctx_resolve_path(struct wcoll_ctx *ctx, const char *file, char *buf, signed int len)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if((signed int)*file == 47)
    strncpy(buf, file, (unsigned long int)len);

  else
  {
    if((signed int)*file == 46)
    {
      if((signed int)file[1l] == 47)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if((signed int)file[1l] == 46)
          tmp_if_expr_2 = (signed int)file[(signed long int)2] == 47 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      strncpy(buf, file, (unsigned long int)len);

    else
    {
      signed int return_value_wcoll_ctx_path_lookup_1;
      return_value_wcoll_ctx_path_lookup_1=wcoll_ctx_path_lookup(ctx, file, buf, len);
      if(!(return_value_wcoll_ctx_path_lookup_1 >= 0))
        return (char *)(void *)0;

    }
  }
  return buf;
}

// wcoll_expand
// file opt.c line 765
static void wcoll_expand(struct anonymous_1 *opt)
{
  struct hostlist *hl = opt->wcoll;
  const char *hosts;
  opt->wcoll=hostlist_create("");
  do
  {
    hosts=hostlist_shift(hl);
    if(hosts == ((const char *)NULL))
      break;

    hostlist_push(opt->wcoll, hosts);
    free((void *)hosts);
  }
  while((_Bool)1);
  hostlist_destroy(hl);
}

// xbasename
// file ../../src/common/xstring.h line 39
char * xbasename(char *path)
{
  char *p;
  p=strrchr(path, 47);
  return p != ((char *)NULL) ? p + (signed long int)1 : path;
}

// xpclose
// file xpopen.c line 169
signed int xpclose(struct _IO_FILE *f)
{
  signed int status;
  signed int pid;
  struct pid *cur;
  struct pid *last;
  fclose(f);
  last = (struct pid *)(void *)0;
  cur = pidlist;
  for( ; !(cur == ((struct pid *)NULL)); cur = cur->next)
  {
    if(f == cur->fp)
      break;

    last = cur;
  }
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  signed int tmp_if_expr_3;
  if(cur == ((struct pid *)NULL))
    return -1;

  else
  {
    do
    {
      pid=waitpid(cur->pid, &status, 0);
      if(pid == -1)
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(last == ((struct pid *)NULL))
      pidlist = cur->next;

    else
      last->next = cur->next;
    Free((void **)&cur);
    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_24
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if((0x7f & status) == 0)
      tmp_if_expr_3 = (((union anonymous_24){ .__in=status }).__i & 0xff00) >> 8;

    else
      tmp_if_expr_3 = -1;
    return tmp_if_expr_3;
  }
}

// xpoll
// file ../../src/common/xpoll.h line 66
signed int xpoll(struct xpollfd *xfds, signed int nfds, signed int timeout)
{
  signed int i;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  if(xfds == ((struct xpollfd *)NULL) || !(nfds >= 1))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  i = 0;
  for( ; !(i >= nfds); i = i + 1)
    (xfds + (signed long int)i)->revents = (signed short int)0;
  signed int return_value__poll_3;
  return_value__poll_3=_poll(xfds, (unsigned int)nfds, timeout);
  return return_value__poll_3;
}

// xpopen
// file xpopen.c line 89
struct _IO_FILE * xpopen(char *cmd, char *mode)
{
  struct pid *cur;
  signed int fds[2l];
  signed int xpopen__1__read;
  signed int fd;
  signed int pid;
  signed long int pid_array_size0;
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(0);
  pid_array_size0 = return_value_sysconf_1 + (signed long int)1;
  char *av[pid_array_size0];
  signed int maxfd;
  signed long int return_value_sysconf_2;
  return_value_sysconf_2=sysconf(4);
  maxfd = (signed int)return_value_sysconf_2;
  signed long int return_value_sysconf_3;
  return_value_sysconf_3=sysconf(0);
  _parse_command_with_quotes(av, (signed int)return_value_sysconf_3, cmd);
  _Bool tmp_if_expr_5;
  if(!((signed int)*mode == 114))
    tmp_if_expr_5 = (signed int)*mode != 119 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)mode[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_6)
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = 22;
    return (struct _IO_FILE *)(void *)0;
  }

  void *return_value_Malloc_7;
  return_value_Malloc_7=Malloc(sizeof(struct pid) /*24ul*/ );
  cur = (struct pid *)return_value_Malloc_7;
  xpopen__1__read = (signed int)((signed int)*mode == 114);
  signed int return_value_pipe_8;
  return_value_pipe_8=pipe(fds);
  if(!(return_value_pipe_8 >= 0))
  {
    close(fds[(signed long int)0]);
    close(fds[(signed long int)1]);
    Free((void **)&cur);
    errx("%p: unable to dup stdout\n");
  }

  pid=fork();
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_11;
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L8;

  }

  else
  {
    close(fds[(signed long int)0]);
    close(fds[(signed long int)1]);
    Free((void **)&cur);
    return (struct _IO_FILE *)(void *)0;

  __CPROVER_DUMP_L8:
    ;
    close(fds[(signed long int)(xpopen__1__read != 0 ? 0 : 1)]);
    dup2(fds[(signed long int)(xpopen__1__read != 0 ? 1 : 0)], xpopen__1__read != 0 ? 1 : 0);
    fd = 2 + 1;
    for( ; !(fd >= maxfd); fd = fd + 1)
      close(fd);
    unsigned int return_value_getgid_9;
    return_value_getgid_9=getgid();
    setgid(return_value_getgid_9);
    unsigned int return_value_getuid_10;
    return_value_getuid_10=getuid();
    setuid(return_value_getuid_10);
    do
    {
      signed int return_value_access_13;
      return_value_access_13=access(av[(signed long int)0], 0);
      if(!(return_value_access_13 == 0))
      {
        return_value___errno_location_12=__errno_location();
        if(!(*return_value___errno_location_12 == 4))
        {
          fprintf(stderr, "%s: not found\n", av[(signed long int)0]);
          fflush(stderr);
        }

      }

      return_value___errno_location_11=__errno_location();
    }
    while(*return_value___errno_location_11 == 4);
    execv(av[(signed long int)0], av);
    signed int *return_value___errno_location_14;
    return_value___errno_location_14=__errno_location();
    exit(*return_value___errno_location_14);
  }
  close(fds[(signed long int)(xpopen__1__read != 0 ? 1 : 0)]);
  cur->fp=fdopen(fds[(signed long int)(xpopen__1__read != 0 ? 0 : 1)], mode);
  cur->pid = pid;
  cur->next = pidlist;
  pidlist = cur;
  return cur->fp;
}

// xstrcat
// file ../../src/common/xstring.h line 35
void xstrcat(char **str1, char *str2)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str2);
  _makespace(str1, (signed int)return_value_strlen_1);
  strcat(*str1, str2);
}

// xstrcatchar
// file ../../src/common/xstring.h line 37
void xstrcatchar(char **str, char c)
{
  _makespace(str, 1);
  _strcatchar(*str, c);
}

// xstrcln
// file ../../src/common/xstring.h line 32
void xstrcln(char *str, char *verboten)
{
  char *p;
  char *base = str;
  if(verboten == ((char *)NULL))
    verboten = "\n\t ";

  char *return_value_strchr_1;
  for( ; !(str == ((char *)NULL)); str = str + 1l)
  {
    if((signed int)*str == 0)
      break;

    return_value_strchr_1=strchr(verboten, (signed int)*str);
    if(return_value_strchr_1 == ((char *)NULL))
      break;

  }
  unsigned long int return_value_strlen_5;
  char *return_value_strchr_3;
  char *tmp_post_4;
  if(!(str == ((char *)NULL)))
  {
    return_value_strlen_5=strlen(str);
    if(return_value_strlen_5 >= 1ul)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(str);
      p = (str + (signed long int)return_value_strlen_2) - (signed long int)1;
      for( ; !(str >= p); *tmp_post_4 = (char)0)
      {
        if((signed int)*p == 0)
          break;

        return_value_strchr_3=strchr(verboten, (signed int)*p);
        if(return_value_strchr_3 == ((char *)NULL))
          break;

        tmp_post_4 = p;
        p = p - 1l;
      }
    }

  }

  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen(str);
  memmove((void *)base, (const void *)str, return_value_strlen_6);
  char *tmp_post_7;
  unsigned long int return_value_strlen_8;
  do
  {
    tmp_post_7 = str;
    str = str - 1l;
    if(base >= tmp_post_7)
      break;

    return_value_strlen_8=strlen(base);
    base[(signed long int)(return_value_strlen_8 - (unsigned long int)1)] = (char)0;
  }
  while((_Bool)1);
}

// xstrcpy
// file xstring.c line 120
void xstrcpy(char **str1, char *str2)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str2);
  _makespace(str1, (signed int)return_value_strlen_1);
  strcpy(*str1, str2);
}

// xstrerrorcat
// file ../../src/common/xstring.h line 38
void xstrerrorcat(char **buf)
{
  char xstrerrorcat__1__err[64l];
  signed int e;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  e = *return_value___errno_location_1;
  signed int return_value_strerror_r_3;
  return_value_strerror_r_3=strerror_r(e, xstrerrorcat__1__err, (unsigned long int)64);
  if(!(return_value_strerror_r_3 >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 22)
      snprintf(xstrerrorcat__1__err, (unsigned long int)64, "Unknown error %d", e);

    xstrerrorcat__1__err[(signed long int)63] = (char)0;
  }

  xstrcat(buf, xstrerrorcat__1__err);
}

