// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_13 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_18 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum_VBI_BLACK=0_VBI_RED=1_VBI_GREEN=2_VBI_YELLOW=3_VBI_BLUE=4_VBI_MAGENTA=5_VBI_CYAN=6_VBI_WHITE=7
// file /usr/include/libzvbi.h line 761
enum anonymous_0 { VBI_BLACK=0, VBI_RED=1, VBI_GREEN=2, VBI_YELLOW=3, VBI_BLUE=4, VBI_MAGENTA=5, VBI_CYAN=6, VBI_WHITE=7 };

// #anon_enum_VBI_TRANSPARENT_SPACE=0_VBI_TRANSPARENT_FULL=1_VBI_SEMI_TRANSPARENT=2_VBI_OPAQUE=3
// file /usr/include/libzvbi.h line 775
enum anonymous_1 { VBI_TRANSPARENT_SPACE=0, VBI_TRANSPARENT_FULL=1, VBI_SEMI_TRANSPARENT=2, VBI_OPAQUE=3 };

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_7;

// tag-#anon#ST[ARR17{U8}_U8_'bits'|ARR256{U8}_U8_'huffval'|U24'_pad0'|S32'sent_table']
// file /usr/include/jpeglib.h line 101
struct anonymous_16;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']
// file /usr/include/jpeglib.h line 84
struct anonymous_15;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_12;

// tag-#anon#ST[S32'component_id'|S32'component_index'|S32'h_samp_factor'|S32'v_samp_factor'|S32'quant_tbl_no'|S32'dc_tbl_no'|S32'ac_tbl_no'|U32'width_in_blocks'|U32'height_in_blocks'|S32'DCT_scaled_size'|U32'downsampled_width'|U32'downsampled_height'|S32'component_needed'|S32'MCU_width'|S32'MCU_height'|S32'MCU_blocks'|S32'MCU_sample_width'|S32'last_col_width'|S32'last_row_height'|U32'_pad0'|*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'|S32'sent_table']#_'quant_table'|*{V}_V_'dct_table']
// file /usr/include/jpeglib.h line 117
struct anonymous_14;

// tag-#anon#ST[S32'comps_in_scan'|ARR4{S32}_S32_'component_index'|S32'Ss'|S32'Se'|S32'Ah'|S32'Al']
// file /usr/include/jpeglib.h line 190
struct anonymous_17;

// tag-#anon#ST[S32'pgno'|S32'subno']
// file /usr/include/libzvbi.h line 832
struct anonymous_3;

// tag-#anon#ST[S32'y0'|S32'y1'|S32'roll']
// file /usr/include/libzvbi.h line 819
struct anonymous_2;

// tag-#anon#ST[S64'ts']
// file ./libng/grab-ng.h line 183
struct anonymous_10;

// tag-#anon#ST[S64'ts'|S32'seq'|S32'twice']
// file ./libng/grab-ng.h line 142
struct anonymous_11;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_4;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_8;

// tag-#anon#UN[ARR8{S32}_S32_'i'|ARR80{S8}_S8_'s']
// file /usr/include/jpeglib.h line 736
union anonymous_19;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_5;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_9;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-CFG_ENTRIES
// file common/parseconfig.c line 11
struct CFG_ENTRIES;

// tag-CFG_SECTIONS
// file common/parseconfig.c line 18
struct CFG_SECTIONS;

// tag-CHANLIST
// file common/frequencies.h line 82
struct CHANLIST;

// tag-CHANLISTS
// file common/frequencies.h line 87
struct CHANLISTS;

// tag-CHANNEL
// file common/channel.h line 11
struct CHANNEL;

// tag-CHUNKHDR
// file libng/writefile.c line 201
struct CHUNKHDR;

// tag-COMMANDS
// file common/commands.c line 109
struct COMMANDS;

// tag-FIFO
// file common/capture.h line 6
struct FIFO;

// tag-LAUNCH
// file common/channel.h line 82
struct LAUNCH;

// tag-OVERLAY_CLIP
// file ./libng/grab-ng.h line 122
struct OVERLAY_CLIP;

// tag-STRTAB
// file ./libng/grab-ng.h line 117
struct STRTAB;

// tag-WAVEHDR
// file libng/writefile.c line 207
struct WAVEHDR;

// tag-WEBCAM
// file common/webcam.c line 22
struct WEBCAM;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bus_type
// file common/get_media_devices.h line 63
enum bus_type { MEDIA_BUS_UNKNOWN=0, MEDIA_BUS_VIRTUAL=1, MEDIA_BUS_PCI=2, MEDIA_BUS_USB=3 };

// tag-device_type
// file ./common/get_media_devices.h line 32
enum device_type { UNKNOWN=65535, NONE=65534, MEDIA_V4L_VIDEO=0, MEDIA_V4L_VBI=1, MEDIA_V4L_RADIO=2, MEDIA_V4L_SUBDEV=3, MEDIA_DVB_VIDEO=100, MEDIA_DVB_AUDIO=101, MEDIA_DVB_SEC=102, MEDIA_DVB_FRONTEND=103, MEDIA_DVB_DEMUX=104, MEDIA_DVB_DVR=105, MEDIA_DVB_CA=106, MEDIA_DVB_NET=107, MEDIA_DVB_OSD=108, MEDIA_SND_CARD=200, MEDIA_SND_CAP=201, MEDIA_SND_OUT=202, MEDIA_SND_CONTROL=203, MEDIA_SND_HW=204, MEDIA_SND_TIMER=205, MEDIA_SND_SEQ=206 };

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-event_entry
// file common/event.h line 3
struct event_entry;

// tag-files_handle
// file libng/writefile.c line 280
struct files_handle;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-list_head
// file ./libng/list.h line 15
struct list_head;

// tag-media_device_entry
// file common/get_media_devices.c line 43
struct media_device_entry;

// tag-media_devices
// file common/get_media_devices.c line 60
struct media_devices;

// tag-movie_handle
// file common/capture.h line 27
struct movie_handle;

// tag-ng_attribute
// file ./libng/grab-ng.h line 243
struct ng_attribute;

// tag-ng_audio_buf
// file ./libng/grab-ng.h line 177
struct ng_audio_buf;

// tag-ng_audio_conv
// file libng/grab-ng.h line 387
struct ng_audio_conv;

// tag-ng_audio_fmt
// file ./libng/grab-ng.h line 172
struct ng_audio_fmt;

// tag-ng_convert_handle
// file ./libng/grab-ng.h line 364
struct ng_convert_handle;

// tag-ng_convthread_handle
// file common/capture.c line 122
struct ng_convthread_handle;

// tag-ng_device_config
// file ./libng/devices.h line 2
struct ng_device_config;

// tag-ng_devinfo
// file libng/grab-ng.h line 275
struct ng_devinfo;

// tag-ng_dsp_driver
// file ./libng/grab-ng.h line 321
struct ng_dsp_driver;

// tag-ng_filter
// file ./libng/grab-ng.h line 402
struct ng_filter;

// tag-ng_format_list
// file ./libng/grab-ng.h line 194
struct ng_format_list;

// tag-ng_mix_driver
// file libng/grab-ng.h line 335
struct ng_mix_driver;

// tag-ng_reader
// file libng/grab-ng.h line 220
struct ng_reader;

// tag-ng_vid_driver
// file ./libng/grab-ng.h line 284
struct ng_vid_driver;

// tag-ng_video_buf
// file ./libng/grab-ng.h line 136
struct ng_video_buf;

// tag-ng_video_conv
// file ./libng/grab-ng.h line 350
struct ng_video_conv;

// tag-ng_video_fmt
// file ./libng/grab-ng.h line 129
struct ng_video_fmt;

// tag-ng_writer
// file ./libng/grab-ng.h line 203
struct ng_writer;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-raw_handle
// file libng/writefile.c line 392
struct raw_handle;

// tag-raw_priv
// file libng/writefile.c line 388
struct raw_priv;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vbi_char
// file /usr/include/libzvbi.h line 788
struct vbi_char;

// tag-vbi_decoder
// file /usr/include/libzvbi.h line 39
struct vbi_decoder;

// tag-vbi_font_descr
// file /usr/include/libzvbi.h line 805
struct vbi_font_descr;

// tag-vbi_page
// file /usr/include/libzvbi.h line 807
struct vbi_page;

// tag-vbi_rect
// file common/vbi-data.h line 21
struct vbi_rect;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new);
// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name);
// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md);
// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md);
// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md);
// alphasort
// file /usr/include/dirent.h line 329
extern signed int alphasort(struct dirent **, struct dirent **);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv);
// attr_init
// file common/commands.c line 473
void attr_init(void);
// attr_notify_object
//
void attr_notify_object(struct ng_attribute *, signed int);
// audio_init
// file ./common/commands.h line 69
void audio_init(void);
// audio_off
// file ./common/commands.h line 71
void audio_off(void);
// audio_on
// file ./common/commands.h line 70
void audio_on(void);
// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_get_hook_object
//
void capture_get_hook_object(void);
// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv);
// capture_rel_hook_object
//
void capture_rel_hook_object(void);
// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine);
// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name);
// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent);
// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent);
// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent);
// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent);
// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void);
// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void);
// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name);
// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void);
// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename);
// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value);
// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv);
// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value);
// channel_switch_hook_object
//
void channel_switch_hook_object(void);
// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count);
// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// ctrlc
// file console/streamer.c line 319
static void ctrlc(signed int signal);
// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv);
// del_channel
// file common/channel.c line 287
void del_channel(signed int i);
// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void);
// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque);
// display_message_object
//
void display_message_object(char *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_command
// file common/commands.c line 240
signed int do_command(signed int argc, char **argv);
// do_rec_status
// file console/streamer.c line 312
static void do_rec_status(char *message);
// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...);
// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray);
// event_dispatch
// file common/event.c line 112
signed int event_dispatch(char *event);
// event_readconfig
// file common/event.h line 20
void event_readconfig(void);
// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action);
// event_register_list
// file common/event.c line 71
signed int event_register_list(struct event_entry *entry);
// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv);
// exit_hook_object
//
void exit_hook_object(void);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo);
// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers);
// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data);
// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf);
// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle);
// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf);
// find_formats
// file console/streamer.c line 189
static void find_formats(void);
// flushit
// file common/capture.c line 106
static void * flushit(void *arg);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque);
// freq_init
// file common/frequencies.c line 22
void freq_init(void);
// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n);
// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name);
// freqtab_notify_object
//
void freqtab_notify_object(void);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv);
// fullscreen_hook_object
//
void fullscreen_hook_object(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type);
// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device);
// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *));
// get_class::fill_object
//
signed int fill_object(struct media_device_entry *);
// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i);
// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type);
// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 30
extern unsigned int gnu_dev_minor(unsigned long long int);
// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c);
// init_overlay
// file common/commands.c line 202
void init_overlay(void);
// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv);
// keypad_timeout
// file common/commands.c line 1527
void keypad_timeout(void);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// list_add_tail
// file libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_formats
// file console/streamer.c line 67
static void list_formats(struct _IO_FILE *out);
// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 266
extern signed int lstat(const char *, struct stat *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// movie_grab_put_video
// file ./common/capture.h line 36
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret);
// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv);
// movie_hook_object
//
void movie_hook_object(signed int, char **);
// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h);
// movie_writer_init
// file ./common/capture.h line 28
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads);
// movie_writer_start
// file ./common/capture.h line 33
signed int movie_writer_start(struct movie_handle *h);
// movie_writer_stop
// file ./common/capture.h line 34
signed int movie_writer_stop(struct movie_handle *h);
// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv);
// mute_notify_object
//
void mute_notify_object(signed int);
// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count);
// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id);
// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name);
// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value);
// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value);
// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value);
// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr);
// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str);
// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent);
// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count);
// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type);
// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void);
// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void);
// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i);
// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out);
// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i);
// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle);
// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv);
// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count);
// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o);
// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src);
// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h);
// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf);
// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h);
// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in);
// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg);
// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void);
// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver);
// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle);
// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter);
// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in);
// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename);
// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf);
// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void);
// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt);
// ng_grabber_grab_image
// file common/capture.c line 226
struct ng_video_buf * ng_grabber_grab_image(signed int single);
// ng_grabber_setformat
// file common/capture.c line 163
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void);
// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf);
// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap);
// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size);
// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size);
// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver);
// ng_mix_init
// file libng/grab-ng.c line 738
struct ng_attribute * ng_mix_init(char *device, char *channel);
// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in);

//

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv);
// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname);
// ng_plugins::1::initcall_object
//
void initcall_object(void);
// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff);
// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up);
// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader);
// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf);
// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv);
// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver);
// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle);
// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber);
// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf);
// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf);
// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void);
// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer);
// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right);
// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry);
// parse_config
// file common/channel.c line 501
void parse_config(signed int parse_channels);
// parse_time
// file console/streamer.c line 291
static signed int parse_time(char *time);
// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_6 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_6 *, const union anonymous_8 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_6 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_6 *, union anonymous_5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_5 *, const union anonymous_8 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_5 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_5 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf);
// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle);
// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config
// file common/channel.c line 387
void read_config(char *conffile, signed int *argc, char **argv);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rec_status_object
//
void rec_status_object(char *);
// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg);
// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p);
// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p);
// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// save_config
// file common/channel.c line 559
void save_config(void);
// scandir
// file /usr/include/dirent.h line 262
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_7 *, struct anonymous_7 *, struct anonymous_7 *, struct timeval *);
// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val);
// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch);
// set_capture_hook_object
//
void set_capture_hook_object(signed int, signed int, signed int);
// set_defaults
// file common/commands.c line 525
void set_defaults(void);
// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j);
// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val);
// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val);
// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val);
// set_mute
// file common/commands.c line 351
static void set_mute(signed int val);
// set_title
// file common/commands.c line 381
static void set_title(void);
// set_volume
// file common/commands.c line 342
static void set_volume(signed int val);
// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv);
// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv);
// setfreqtab_notify_object
//
void setfreqtab_notify_object(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv);
// setstation_notify_object
//
void setstation_notify_object(void);
// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv);
// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext);
// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b);
// split_cmdline
// file common/commands.c line 272
char ** split_cmdline(char *line, signed int *count);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// sync
// file /usr/include/unistd.h line 972
extern void sync(void);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv);
// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new);
// update_title_object
//
void update_title_object(char *);
// usage
// file console/streamer.c line 101
static void usage(struct _IO_FILE *out);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv);
// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv);
// volume_notify_object
//
void volume_notify_object(void);
// vtx_subtitle_object
//
void vtx_subtitle_object(struct vbi_page *, struct vbi_rect *);
// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size);
// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void);
// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv);
// webcam_init
// file common/webcam.c line 108
void webcam_init(void);
// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf);
// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray);
// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf);
// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf);
// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg);
// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg);
// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in);

struct anonymous_7
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_16
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_15
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_12
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_14
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_15 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_17
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_3
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
};

struct anonymous_2
{
  // y0
  signed int y0;
  // y1
  signed int y1;
  // roll
  signed int roll;
};

struct anonymous_10
{
  // ts
  signed long int ts;
};

struct anonymous_11
{
  // ts
  signed long int ts;
  // seq
  signed int seq;
  // twice
  signed int twice;
};

union anonymous_4
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_8
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_19
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous_6
{
  // __data
  struct anonymous_12 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_9
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct CFG_ENTRIES
{
  // ent_count
  signed int ent_count;
  // ent_names
  char **ent_names;
  // ent_values
  char **ent_values;
  // ent_seen
  signed int **ent_seen;
};

struct CFG_SECTIONS
{
  // sec_count
  signed int sec_count;
  // sec_names
  char **sec_names;
  // sec_entries
  struct CFG_ENTRIES **sec_entries;
};

struct CHANLIST
{
  // name
  char *name;
  // freq
  unsigned int freq;
};

struct CHANLISTS
{
  // name
  char *name;
  // filename
  char *filename;
  // list
  struct CHANLIST *list;
  // count
  signed int count;
};

struct CHANNEL
{
  // name
  char *name;
  // key
  char *key;
  // group
  char *group;
  // midi
  signed int midi;
  // cname
  char *cname;
  // channel
  signed int channel;
  // fine
  signed int fine;
  // freq
  signed int freq;
  // audio
  signed int audio;
  // capture
  signed int capture;
  // input
  signed int input;
  // norm
  signed int norm;
  // color
  signed int color;
  // bright
  signed int bright;
  // hue
  signed int hue;
  // contrast
  signed int contrast;
  // pixmap
  unsigned long int pixmap;
  // button
  struct _WidgetRec *button;
};

struct CHUNKHDR
{
  // ckid
  unsigned int ckid;
  // dwSize
  unsigned int dwSize;
};

struct COMMANDS
{
  // name
  char *name;
  // min_args
  signed int min_args;
  // handler
  signed int (*handler)(char *, signed int, char **);
};

struct FIFO
{
  // name
  char *name;
  // data
  unsigned char *data[64l];
  // slots
  signed int slots;
  // read
  signed int read;
  // write
  signed int write;
  // eof
  signed int eof;
  // max
  signed int max;
  // writers
  signed int writers;
  // lock
  union anonymous_5 lock;
  // hasdata
  union anonymous_6 hasdata;
};

struct LAUNCH
{
  // name
  char *name;
  // key
  char *key;
  // cmdline
  char *cmdline;
};

struct OVERLAY_CLIP
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct STRTAB
{
  // nr
  signed long int nr;
  // str
  const char *str;
};

struct WAVEHDR
{
  // chkRiff
  struct CHUNKHDR chkRiff;
  // fccWave
  unsigned int fccWave;
  // chkFmt
  struct CHUNKHDR chkFmt;
  // wFormatTag
  unsigned short int wFormatTag;
  // nChannels
  unsigned short int nChannels;
  // nSamplesPerSec
  unsigned int nSamplesPerSec;
  // nAvgBytesPerSec
  unsigned int nAvgBytesPerSec;
  // nBlockAlign
  unsigned short int nBlockAlign;
  // wBitsPerSample
  unsigned short int wBitsPerSample;
  // chkData
  struct CHUNKHDR chkData;
};

struct WEBCAM
{
  // lock
  union anonymous_5 lock;
  // wait
  union anonymous_6 wait;
  // filename
  char *filename;
  // buf
  struct ng_video_buf *buf;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct event_entry
{
  // event
  char event[128l];
  // action
  char action[128l];
  // argbuf
  char argbuf[128l];
  // argc
  signed int argc;
  // argv
  char *argv[16l];
  // next
  struct event_entry *next;
};

struct ng_video_fmt
{
  // fmtid
  unsigned int fmtid;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // bytesperline
  unsigned int bytesperline;
};

struct ng_audio_fmt
{
  // fmtid
  unsigned int fmtid;
  // rate
  unsigned int rate;
};

struct files_handle
{
  // file
  char file[4096l];
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
  // gotcha
  signed int gotcha;
};

struct in6_addr
{
  // __in6_u
  union anonymous_4 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_13 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_13 jpeg_color_space;
  // comp_info
  struct anonymous_14 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_15 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_16 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_16 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_17 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_18 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_14 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_17 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_19 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct media_device_entry
{
  // device
  char *device;
  // node
  char *node;
  // type
  enum device_type type;
  // bus
  enum bus_type bus;
  // major
  unsigned int major;
  // minor
  unsigned int minor;
};

struct media_devices
{
  // md_entry
  struct media_device_entry *md_entry;
  // md_size
  unsigned int md_size;
};

struct ng_convthread_handle
{
  // c
  struct ng_convert_handle *c;
  // in
  struct FIFO *in;
  // out
  struct FIFO *out;
};

struct movie_handle
{
  // lock
  union anonymous_5 lock;
  // writer
  struct ng_writer *writer;
  // handle
  void *handle;
  // tflush
  unsigned long int tflush;
  // start
  unsigned long int start;
  // rts
  unsigned long int rts;
  // stopby
  unsigned long int stopby;
  // slots
  signed int slots;
  // vfmt
  struct ng_video_fmt vfmt;
  // fps
  signed int fps;
  // frames
  signed int frames;
  // seq
  signed int seq;
  // vfifo
  struct FIFO vfifo;
  // tvideo
  unsigned long int tvideo;
  // vts
  unsigned long int vts;
  // cfifo
  struct FIFO cfifo;
  // cthreads
  signed int cthreads;
  // hconv
  struct ng_convthread_handle *hconv[4l];
  // tconv
  unsigned long int tconv[4l];
  // dsp
  struct ng_dsp_driver *dsp;
  // hdsp
  void *hdsp;
  // afmt
  struct ng_audio_fmt afmt;
  // bytes_per_sec
  unsigned long int bytes_per_sec;
  // bytes
  unsigned long int bytes;
  // afifo
  struct FIFO afifo;
  // taudio
  unsigned long int taudio;
  // raudio
  unsigned long int raudio;
  // ats
  unsigned long int ats;
  // rdrift
  unsigned long int rdrift;
  // vdrift
  unsigned long int vdrift;
};

struct ng_attribute
{
  // id
  signed int id;
  // name
  const char *name;
  // type
  signed int type;
  // defval
  signed int defval;
  // choices
  struct STRTAB *choices;
  // min
  signed int min;
  // max
  signed int max;
  // points
  signed int points;
  // priv
  const void *priv;
  // handle
  void *handle;
  // read
  signed int (*read)(struct ng_attribute *);
  // write
  void (*write)(struct ng_attribute *, signed int);
};

struct ng_audio_buf
{
  // fmt
  struct ng_audio_fmt fmt;
  // size
  signed int size;
  // written
  signed int written;
  // data
  char *data;
  // info
  struct anonymous_10 info;
};

struct ng_audio_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(void *);
  // frame
  struct ng_audio_buf * (*frame)(void *, struct ng_audio_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_convert_handle
{
  // ifmt
  struct ng_video_fmt ifmt;
  // ofmt
  struct ng_video_fmt ofmt;
  // isize
  signed int isize;
  // osize
  signed int osize;
  // conv
  struct ng_video_conv *conv;
  // chandle
  void *chandle;
};

struct ng_device_config
{
  // video
  char *video;
  // driver
  char *driver;
  // radio
  char *radio;
  // vbi
  char *vbi;
  // dsp
  char *dsp;
  // mixer
  char *mixer;
  // video_scan
  char *video_scan[32l];
  // mixer_scan
  char *mixer_scan[32l];
};

struct ng_devinfo
{
  // device
  char device[32l];
  // name
  char name[64l];
  // flags
  signed int flags;
};

struct ng_dsp_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, struct ng_audio_fmt *, signed int);
  // close
  void (*close)(void *);
  // fd
  signed int (*fd)(void *);
  // startrec
  signed int (*startrec)(void *);
  // read
  struct ng_audio_buf * (*read)(void *, signed long int);
  // write
  struct ng_audio_buf * (*write)(void *, struct ng_audio_buf *);
  // latency
  signed long int (*latency)(void *);
  // list
  struct list_head list;
};

struct ng_filter
{
  // name
  char *name;
  // fmts
  signed int fmts;
  // attrs
  struct ng_attribute *attrs;
  // init
  void * (*init)(struct ng_video_fmt *);
  // frame
  struct ng_video_buf * (*frame)(void *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // list
  struct list_head list;
};

struct ng_format_list
{
  // name
  char *name;
  // desc
  char *desc;
  // ext
  char *ext;
  // fmtid
  unsigned int fmtid;
  // priv
  void *priv;
};

struct ng_mix_driver
{
  // name
  const char *name;
  // probe
  struct ng_devinfo * (*probe)(void);
  // channels
  struct ng_devinfo * (*channels)(char *);
  // open
  void * (*open)(char *);
  // volctl
  struct ng_attribute * (*volctl)(void *, char *);
  // close
  void (*close)(void *);
  // list
  struct list_head list;
};

struct ng_reader
{
  // name
  const char *name;
  // desc
  const char *desc;
  // magic
  char *magic[4l];
  // moff
  signed int moff[4l];
  // mlen
  signed int mlen[4l];
  // rd_open
  void * (*rd_open)(char *);
  // rd_vfmt
  struct ng_video_fmt * (*rd_vfmt)(void *, signed int *, signed int);
  // rd_afmt
  struct ng_audio_fmt * (*rd_afmt)(void *);
  // rd_vdata
  struct ng_video_buf * (*rd_vdata)(void *, unsigned int);
  // rd_adata
  struct ng_audio_buf * (*rd_adata)(void *);
  // frame_time
  signed long int (*frame_time)(void *);
  // rd_close
  signed int (*rd_close)(void *);
  // list
  struct list_head list;
};

struct ng_vid_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, signed int);
  // close
  signed int (*close)(void *);
  // get_devname
  char * (*get_devname)(void *);
  // capabilities
  signed int (*capabilities)(void *);
  // list_attrs
  struct ng_attribute * (*list_attrs)(void *);
  // get_min_size
  void (*get_min_size)(void *, signed int *, signed int *);
  // setupfb
  signed int (*setupfb)(void *, struct ng_video_fmt *, void *);
  // overlay
  signed int (*overlay)(void *, struct ng_video_fmt *, signed int, signed int, struct OVERLAY_CLIP *, signed int, signed int);
  // setformat
  signed int (*setformat)(void *, struct ng_video_fmt *);
  // startvideo
  signed int (*startvideo)(void *, signed int, unsigned int);
  // stopvideo
  void (*stopvideo)(void *);
  // nextframe
  struct ng_video_buf * (*nextframe)(void *);
  // getimage
  struct ng_video_buf * (*getimage)(void *);
  // getfreq
  unsigned long int (*getfreq)(void *);
  // setfreq
  void (*setfreq)(void *, unsigned long int);
  // is_tuned
  signed int (*is_tuned)(void *);
  // list
  struct list_head list;
};

struct ng_video_buf
{
  // fmt
  struct ng_video_fmt fmt;
  // size
  unsigned long int size;
  // data
  unsigned char *data;
  // info
  struct anonymous_11 info;
  // lock
  union anonymous_5 lock;
  // cond
  union anonymous_6 cond;
  // refcount
  signed int refcount;
  // release
  void (*release)(struct ng_video_buf *);
  // priv
  void *priv;
};

struct ng_video_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(struct ng_video_fmt *, void *);
  // frame
  void (*frame)(void *, struct ng_video_buf *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_writer
{
  // name
  const char *name;
  // desc
  const char *desc;
  // video
  struct ng_format_list *video;
  // audio
  struct ng_format_list *audio;
  // combined
  const signed int combined;
  // wr_open
  void * (*wr_open)(char *, char *, struct ng_video_fmt *, const void *, signed int, struct ng_audio_fmt *, const void *);
  // wr_video
  signed int (*wr_video)(void *, struct ng_video_buf *);
  // wr_audio
  signed int (*wr_audio)(void *, struct ng_audio_buf *);
  // wr_close
  signed int (*wr_close)(void *);
  // list
  struct list_head list;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct raw_handle
{
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // vpriv
  struct raw_priv *vpriv;
  // fd
  signed int fd;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
};

struct raw_priv
{
  // yuv4mpeg
  signed int yuv4mpeg;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vbi_char
{
  // underline
  unsigned int underline : 1;
  // bold
  unsigned int bold : 1;
  // italic
  unsigned int italic : 1;
  // flash
  unsigned int flash : 1;
  // conceal
  unsigned int conceal : 1;
  // proportional
  unsigned int proportional : 1;
  // link
  unsigned int link : 1;
  // reserved
  unsigned int reserved : 1;
  // size
  unsigned int size : 8;
  // opacity
  unsigned int opacity : 8;
  // foreground
  unsigned int foreground : 8;
  // background
  unsigned int background : 8;
  // drcs_clut_offs
  unsigned int drcs_clut_offs : 8;
  // unicode
  unsigned int unicode : 16;
};

struct vbi_page
{
  // vbi
  struct vbi_decoder *vbi;
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // rows
  signed int rows;
  // columns
  signed int columns;
  // text
  struct vbi_char text[1056l];
  // dirty
  struct anonymous_2 dirty;
  // screen_color
  enum anonymous_0 screen_color;
  // screen_opacity
  enum anonymous_1 screen_opacity;
  // color_map
  unsigned int color_map[40l];
  // drcs_clut
  unsigned char *drcs_clut;
  // drcs
  unsigned char *drcs[32l];
  // nav_link
  struct anonymous_3 nav_link[6l];
  // nav_index
  char nav_index[64l];
  // font
  struct vbi_font_descr *font[2l];
  // double_height_lower
  unsigned int double_height_lower;
  // page_opacity
  enum anonymous_1 page_opacity[2l];
  // boxed_opacity
  enum anonymous_1 boxed_opacity[2l];
};

struct vbi_rect
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};


// absframes
// file console/streamer.c line 57
static signed int absframes = 1;
// afmt_name
// file console/streamer.c line 43
static char *afmt_name;
// alloc_count
// file common/channel.c line 66
signed int alloc_count = 0;
// attr_notify
// file common/commands.c line 46
void (*attr_notify)(struct ng_attribute *, signed int);
// attrs
// file common/commands.c line 79
struct ng_attribute *attrs = (struct ng_attribute *)(void *)0;
// audio
// file console/streamer.c line 52
static struct ng_audio_fmt audio = { .fmtid=0u, .rate=(unsigned int)44100 };
// audio_priv
// file console/streamer.c line 47
static const void *audio_priv;
// audioname
// file console/streamer.c line 41
static char *audioname = (char *)(void *)0;
// booltab
// file common/channel.c line 728
struct STRTAB booltab[7l] = { { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)1, .str="yes" }, { .nr=(signed long int)1, .str="true" },
    { .nr=(signed long int)1, .str="on" }, { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// bufcount
// file console/streamer.c line 36
static signed int bufcount = 16;
// c
// file common/parseconfig.c line 26
static struct CFG_SECTIONS *c;
// captab
// file common/channel.c line 170
struct STRTAB captab[11l] = { { .nr=(signed long int)9, .str="on" }, { .nr=(signed long int)9, .str="yes" }, { .nr=(signed long int)9, .str="true" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)1, .str="over" },
    { .nr=(signed long int)1, .str="overlay" },
    { .nr=(signed long int)2, .str="grab" },
    { .nr=(signed long int)2, .str="grabdisplay" },
    { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// capture_get_hook
// file common/commands.c line 62
void (*capture_get_hook)(void);
// capture_rel_hook
// file common/commands.c line 63
void (*capture_rel_hook)(void);
// chanlist_names
// file common/frequencies.c line 17
struct STRTAB *chanlist_names;
// chanlists
// file common/frequencies.c line 16
struct CHANLISTS *chanlists;
// channel_switch_hook
// file common/commands.c line 54
void (*channel_switch_hook)(void);
// channels
// file common/channel.c line 64
struct CHANNEL **channels = (struct CHANNEL **)(void *)0;
// chantab
// file common/frequencies.c line 15
signed int chantab = -1;
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l];
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l] = { { .name="setstation", .min_args=0, .handler=setstation_handler },
    { .name="setchannel", .min_args=0, .handler=setchannel_handler },
    { .name="setfreq", .min_args=1, .handler=setchannel_handler },
    { .name="setfreqtab", .min_args=1, .handler=setfreqtab_handler },
    { .name="capture", .min_args=1, .handler=capture_handler },
    { .name="setnorm", .min_args=1, .handler=attr_handler },
    { .name="setinput", .min_args=1, .handler=attr_handler },
    { .name="setattr", .min_args=1, .handler=attr_handler },
    { .name="color", .min_args=0, .handler=attr_handler },
    { .name="hue", .min_args=0, .handler=attr_handler },
    { .name="bright", .min_args=0, .handler=attr_handler },
    { .name="contrast", .min_args=0, .handler=attr_handler },
    { .name="show", .min_args=0, .handler=show_handler },
    { .name="list", .min_args=0, .handler=list_handler },
    { .name="volume", .min_args=0, .handler=volume_handler },
    { .name="attr", .min_args=0, .handler=dattr_handler },
    { .name="snap", .min_args=0, .handler=snap_handler },
    { .name="webcam", .min_args=1, .handler=webcam_handler },
    { .name="movie", .min_args=1, .handler=movie_handler },
    { .name="fullscreen", .min_args=0, .handler=fullscreen_handler },
    { .name="msg", .min_args=1, .handler=msg_handler },
    { .name="message", .min_args=0, .handler=msg_handler },
    { .name="exit", .min_args=0, .handler=exit_handler },
    { .name="quit", .min_args=0, .handler=exit_handler },
    { .name="bye", .min_args=0, .handler=exit_handler },
    { .name="keypad", .min_args=1, .handler=keypad_handler },
    { .name="showtime", .min_args=0, .handler=showtime_handler },
    { .name="vdr", .min_args=1, .handler=vdr_handler },
    { .name=(char *)(void *)0, .min_args=0, .handler=(signed int (*)(char *, signed int, char **))(void *)0 } };
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l];
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l] = { { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_be_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_native_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)5, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)3, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)4, .fmtid_out=(unsigned int)6, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)6, .fmtid_out=(unsigned int)4, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)9, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_bgr24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)8, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_bgr32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)10, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_rgb32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l];
// conv_list_link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list_link1[6l] = { { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv422p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv420p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// count
// file common/channel.c line 65
signed int count = 0;
// cur_attrs
// file common/commands.c line 72
signed int cur_attrs[256l];
// cur_capture
// file common/channel.c line 72
signed int cur_capture = 0;
// cur_channel
// file common/channel.c line 68
signed int cur_channel = -1;
// cur_dattr
// file common/commands.c line 154
static signed int cur_dattr = 0;
// cur_filter
// file common/channel.c line 70
struct ng_filter *cur_filter;
// cur_fine
// file common/channel.c line 68
signed int cur_fine = 0;
// cur_freq
// file common/channel.c line 69
signed int cur_freq;
// cur_movie
// file common/commands.c line 72
signed int cur_movie;
// cur_sender
// file common/channel.c line 68
signed int cur_sender = -1;
// cur_tv_height
// file common/commands.c line 71
unsigned int cur_tv_height;
// cur_tv_width
// file common/commands.c line 71
unsigned int cur_tv_width;
// dattr
// file common/commands.c line 155
static signed int dattr[5l] = { 3, 7, 9, 6, 8 };
// debug
// file console/streamer.c line 62
signed int debug = 0;
// defaults
// file common/channel.c line 52
struct CHANNEL defaults = { .name="defaults", .key=((char *)NULL), .group="main",
    .midi=0, .cname=((char *)NULL), .channel=-1,
    .fine=0, .freq=0, .audio=-1, .capture=9,
    .input=0, .norm=0, .color=-1, .bright=-1,
    .hue=-1, .contrast=-1, .pixmap=0ul, .button=((struct _WidgetRec *)NULL) };
// display_message
// file common/commands.c line 36
void (*display_message)(char *);
// do_overlay
// file common/commands.c line 67
signed int do_overlay;
// drv
// file common/commands.c line 75
struct ng_vid_driver *drv;
// event_builtin_list
// file common/event.c line 17
static struct event_entry *event_builtin_list;
// event_conf_list
// file common/event.c line 16
static struct event_entry *event_conf_list;
// exit_hook
// file common/commands.c line 61
void (*exit_hook)(void);
// f_drv
// file common/commands.c line 77
signed int f_drv;
// files_vformats
// file libng/writefile.c line 546
static struct ng_format_list files_vformats[4l] = { { .name="ppm", .desc=((char *)NULL), .ext="ppm", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="pgm", .desc=((char *)NULL), .ext="pgm", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="jpeg", .desc=((char *)NULL), .ext="jpeg", .fmtid=(unsigned int)17,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer;
// wav_aformats
// file libng/writefile.c line 606
static struct ng_format_list wav_aformats[4l] = { { .name="mono8", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)1,
    .priv=NULL },
    { .name="mono16", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)3,
    .priv=NULL },
    { .name="stereo", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)4,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer = { .name="files", .desc="multiple image files", .video=files_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=files_open, .wr_video=files_video, .wr_audio=files_audio,
    .wr_close=files_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// fps
// file console/streamer.c line 58
static signed int fps = 10000;
// freqtab_notify
// file common/commands.c line 49
void (*freqtab_notify)(void);
// fs_height
// file common/channel.c line 80
signed int fs_height;
// fs_width
// file common/channel.c line 80
signed int fs_width;
// fs_xoff
// file common/channel.c line 80
signed int fs_xoff;
// fs_yoff
// file common/channel.c line 80
signed int fs_yoff;
// fullscreen_hook
// file common/commands.c line 60
void (*fullscreen_hook)(void);
// h_drv
// file common/commands.c line 76
void *h_drv;
// have_config
// file common/channel.c line 73
signed int have_config;
// have_dga
// file console/streamer.c line 62
signed int have_dga = 0;
// have_shmem
// file common/commands.c line 69
signed int have_shmem;
// input
// file console/streamer.c line 39
static char *input = (char *)(void *)0;
// keypad_ntsc
// file common/channel.c line 74
signed int keypad_ntsc = 0;
// keypad_partial
// file common/channel.c line 75
signed int keypad_partial = 1;
// keypad_state
// file common/commands.c line 164
static signed int keypad_state = -1;
// last_sender
// file common/channel.c line 68
signed int last_sender = -1;
// launch
// file common/channel.c line 97
struct LAUNCH *launch = (struct LAUNCH *)(void *)0;
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l];
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l];
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// midi
// file common/channel.c line 95
char *midi = (char *)(void *)0;
// mixer
// file common/channel.c line 93
static char *mixer = (char *)(void *)0;
// mixerctl
// file common/channel.c line 94
char mixerctl[16l];
// mixerdev
// file common/channel.c line 94
char mixerdev[32l];
// mov_audio
// file common/channel.c line 86
char *mov_audio = (char *)(void *)0;
// mov_driver
// file common/channel.c line 83
char *mov_driver = (char *)(void *)0;
// mov_fps
// file common/channel.c line 85
char *mov_fps = (char *)(void *)0;
// mov_rate
// file common/channel.c line 87
char *mov_rate = (char *)(void *)0;
// mov_video
// file common/channel.c line 84
char *mov_video = (char *)(void *)0;
// movie_hook
// file common/commands.c line 64
void (*movie_hook)(signed int, char **);
// movie_state
// file console/streamer.c line 55
static void *movie_state;
// moviename
// file console/streamer.c line 40
static char *moviename = (char *)(void *)0;
// mute_notify
// file common/commands.c line 47
void (*mute_notify)(signed int);
// nconv
// file libng/color_packed.c line 255
static const signed int nconv = (const signed int)(sizeof(struct ng_video_conv [12l]) /*672ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv_link1
// file libng/color_yuv2rgb.c line 421
static const signed int nconv_link1 = (const signed int)(sizeof(struct ng_video_conv [6l]) /*336ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv2
// file libng/color_lut.c line 237
static const unsigned int nconv2 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv4
// file libng/color_lut.c line 238
static const unsigned int nconv4 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv;
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv = { .next=&ng_aconv, .prev=&ng_aconv };
// ng_afmt_to_bits
// file libng/grab-ng.c line 91
const unsigned int ng_afmt_to_bits[8l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)0 };
// ng_afmt_to_channels
// file libng/grab-ng.c line 88
const unsigned int ng_afmt_to_channels[8l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)0 };
// ng_afmt_to_desc
// file libng/grab-ng.c line 94
const char *ng_afmt_to_desc[8l] = { "none", "8bit mono", "8bit stereo", "16bit mono (LE)", "16bit stereo (LE)", "16bit mono (BE)", "16bit stereo (BE)", "mp3 compressed audio" };
// ng_attr_to_desc
// file libng/grab-ng.c line 107
const char *ng_attr_to_desc[10l] = { "none", "norm", "input", "volume", "mute", "audio mode", "color", "bright", "hue", "contrast" };
// ng_chromakey
// file libng/grab-ng.c line 33
signed int ng_chromakey = 0x00ff00ff;
// ng_clip
// file libng/color_yuv2rgb.c line 52
static unsigned int ng_clip[896l];
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv;
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv = { .next=&ng_conv, .prev=&ng_conv };
// ng_debug
// file libng/grab-ng.c line 32
signed int ng_debug = 0;
// ng_dev
// file libng/devices.c line 37
struct ng_device_config ng_dev = { .video="/dev/video0", .driver="libv4l", .radio="/dev/radio0",
    .vbi="/dev/vbi0", .dsp="/dev/dsp",
    .mixer="/dev/mixer", .video_scan={ "/dev/video0", "/dev/video1", "/dev/video2", "/dev/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/mixer", "/dev/mixer1", "/dev/mixer2", "/dev/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dev_devfs
// file libng/devices.c line 60
struct ng_device_config ng_dev_devfs = { .video="/dev/v4l/video0", .driver="libv4l", .radio="/dev/v4l/radio0",
    .vbi="/dev/v4l/vbi0", .dsp="/dev/sound/dsp",
    .mixer="/dev/sound/mixer", .video_scan={ "/dev/v4l/video0", "/dev/v4l/video1", "/dev/v4l/video2", "/dev/v4l/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/sound/mixer", "/dev/sound/mixer1", "/dev/sound/mixer2", "/dev/sound/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers;
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers = { .next=&ng_dsp_drivers, .prev=&ng_dsp_drivers };
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters;
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters = { .next=&ng_filters, .prev=&ng_filters };
// ng_jpeg_quality
// file libng/grab-ng.c line 34
signed int ng_jpeg_quality = 75;
// ng_lut_blue
// file libng/grab-ng.h line 486
unsigned long int ng_lut_blue[256l];
// ng_lut_green
// file libng/grab-ng.h line 485
unsigned long int ng_lut_green[256l];
// ng_lut_red
// file libng/grab-ng.h line 484
unsigned long int ng_lut_red[256l];
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers;
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers = { .next=&ng_mix_drivers, .prev=&ng_mix_drivers };
// ng_ratio_x
// file libng/grab-ng.c line 35
signed int ng_ratio_x = 4;
// ng_ratio_y
// file libng/grab-ng.c line 36
signed int ng_ratio_y = 3;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers = { .next=&ng_readers, .prev=&ng_readers };
// ng_v4l_conf
// file libng/grab-ng.c line 38
char ng_v4l_conf[256l] = { 'v', '4', 'l', '-', 'c', 'o', 'n', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// ng_vfmt_to_depth
// file libng/grab-ng.c line 42
const unsigned int ng_vfmt_to_depth[19l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)24, (const unsigned int)32, (const unsigned int)16, (const unsigned int)32, (const unsigned int)16, (const unsigned int)16, (const unsigned int)12, (const unsigned int)0, (const unsigned int)0, (const unsigned int)16 };
// ng_vfmt_to_desc
// file libng/grab-ng.c line 64
const char *ng_vfmt_to_desc[19l] = { "none", "8 bit PseudoColor (dithering)", "8 bit StaticGray", "15 bit TrueColor (LE)", "16 bit TrueColor (LE)", "15 bit TrueColor (BE)", "16 bit TrueColor (BE)", "24 bit TrueColor (LE: bgr)", "32 bit TrueColor (LE: bgr-)", "24 bit TrueColor (BE: rgb)", "32 bit TrueColor (BE: -rgb)", "16 bit TrueColor (lut)", "32 bit TrueColor (lut)", "16 bit YUV 4:2:2 (packed, YUYV)", "16 bit YUV 4:2:2 (planar)", "12 bit YUV 4:2:0 (planar)", "MJPEG (AVI)", "JPEG (JFIF)", "16 bit YUV 4:2:2 (packed, UYVY)" };
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers;
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers = { .next=&ng_vid_drivers, .prev=&ng_vid_drivers };
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers;
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers = { .next=&ng_writers, .prev=&ng_writers };
// ng_yuv_blue
// file libng/color_yuv2rgb.c line 49
static unsigned int ng_yuv_blue[256l];
// ng_yuv_g1
// file libng/color_yuv2rgb.c line 50
static unsigned int ng_yuv_g1[256l];
// ng_yuv_g2
// file libng/color_yuv2rgb.c line 51
static unsigned int ng_yuv_g2[256l];
// ng_yuv_gray
// file libng/color_yuv2rgb.c line 47
static unsigned int ng_yuv_gray[256l];
// ng_yuv_red
// file libng/color_yuv2rgb.c line 48
static unsigned int ng_yuv_red[256l];
// nlaunch
// file common/channel.c line 98
signed int nlaunch = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// osd_x
// file common/channel.c line 78
signed int osd_x = 30;
// osd_y
// file common/channel.c line 79
signed int osd_y = 20;
// parallel
// file console/streamer.c line 37
static signed int parallel = 1;
// pix_cols
// file common/channel.c line 81
signed int pix_cols = 1;
// pix_height
// file common/channel.c line 81
signed int pix_height = 96;
// pix_width
// file common/channel.c line 81
signed int pix_width = 128;
// quiet
// file console/streamer.c line 58
static signed int quiet = 0;
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l];
// yuv4mpeg
// file libng/writefile.c line 564
static struct raw_priv yuv4mpeg = { .yuv4mpeg=1 };
// yuv4mpeg2
// file libng/writefile.c line 568
static struct raw_priv yuv4mpeg2 = { .yuv4mpeg=2 };
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l] = { { .name="rgb", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="gray", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="422", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)13,
    .priv=NULL },
    { .name="422p", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)14,
    .priv=NULL },
    { .name="4mpeg", .desc="yuv4mpeg (mpeg2enc >= 1.6)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg2 },
    { .name="4mpeg-o", .desc="yuv4mpeg (old mpeg2enc)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer;
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer = { .name="raw", .desc="single file, raw video data", .video=raw_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=raw_open, .wr_video=raw_video, .wr_audio=raw_audio,
    .wr_close=raw_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// rec_status
// file common/commands.c line 37
void (*rec_status)(char *);
// set_capture_hook
// file common/commands.c line 57
void (*set_capture_hook)(signed int, signed int, signed int);
// setfreqtab_notify
// file common/commands.c line 50
void (*setfreqtab_notify)(void);
// setstation_notify
// file common/commands.c line 51
void (*setstation_notify)(void);
// signaled
// file console/streamer.c line 60
static signed int signaled = 0;
// snapbase
// file common/commands.c line 68
char *snapbase = "snap";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tvnorm
// file console/streamer.c line 38
static char *tvnorm = (char *)(void *)0;
// tweb
// file common/webcam.c line 105
static unsigned long int tweb;
// update_title
// file common/commands.c line 35
void (*update_title)(char *);
// use_osd
// file common/channel.c line 77
signed int use_osd = 1;
// use_wm_fullscreen
// file common/channel.c line 76
signed int use_wm_fullscreen = 1;
// vdr_sock
// file common/commands.c line 1290
static signed int vdr_sock = -1;
// vfmt_name
// file console/streamer.c line 42
static char *vfmt_name;
// video
// file console/streamer.c line 48
static struct ng_video_fmt video = { .fmtid=0u, .width=(unsigned int)320, .height=(unsigned int)240, .bytesperline=0u };
// video_priv
// file console/streamer.c line 46
static const void *video_priv;
// volume_notify
// file common/commands.c line 48
void (*volume_notify)(void);
// vtx_subtitle
// file common/commands.c line 42
void (*vtx_subtitle)(struct vbi_page *, struct vbi_rect *);
// wait_seconds
// file console/streamer.c line 60
static signed int wait_seconds = 0;
// web
// file common/webcam.c line 104
static struct WEBCAM *web;
// webcam
// file common/webcam.c line 20
char *webcam;
// writer
// file console/streamer.c line 45
static struct ng_writer *writer;

// __list_add
// file libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// add_attrs
// file ./common/commands.h line 74
void add_attrs(struct ng_attribute *new)
{
  struct ng_attribute *all;
  signed int nold;
  signed int nnew;
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    nold = 0;
    for( ; !((attrs + (signed long int)nold)->name == ((const char *)NULL)); nold = nold + 1)
      ;
  }

  else
    nold = 0;
  nnew = 0;
  for( ; !((new + (signed long int)nnew)->name == ((const char *)NULL)); nnew = nnew + 1)
    ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  all = (struct ng_attribute *)return_value_malloc_1;
  memset((void *)all, 0, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  memcpy((void *)all, (const void *)new, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nnew);
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    memcpy((void *)(all + (signed long int)nnew), (const void *)attrs, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nold);
    free((void *)attrs);
  }

  attrs = all;
}

// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name)
{
  struct CHANNEL *channel;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(alloc_count == count)
  {
    alloc_count = alloc_count + 16;
    if(alloc_count == 16)
    {
      return_value_malloc_1=malloc(sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)channels, sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_realloc_2;
    }
  }

  signed int tmp_post_3 = count;
  count = count + 1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct CHANNEL) /*104ul*/ );
  channels[(signed long int)tmp_post_3] = (struct CHANNEL *)return_value_malloc_4;
  channel = channels[(signed long int)tmp_post_3];
  memcpy((void *)channel, (const void *)&defaults, sizeof(struct CHANNEL) /*104ul*/ );
  channel->name=strdup(name);
  return channel;
}

// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md)
{
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(md->node, "video");
  if(!(return_value_strstr_1 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_VIDEO;

  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "audio");
  if(!(return_value_strstr_2 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_AUDIO;

  char *return_value_strstr_3;
  return_value_strstr_3=strstr(md->node, "sec");
  if(!(return_value_strstr_3 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_SEC;

  char *return_value_strstr_9;
  return_value_strstr_9=strstr(md->node, "frontend");
  char *return_value_strstr_8;
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  char *return_value_strstr_4;
  if(!(return_value_strstr_9 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_FRONTEND;

  else
  {
    return_value_strstr_8=strstr(md->node, "demux");
    if(!(return_value_strstr_8 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_DVB_DEMUX;

    else
    {
      return_value_strstr_7=strstr(md->node, "dvr");
      if(!(return_value_strstr_7 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_DVB_DVR;

      else
      {
        return_value_strstr_6=strstr(md->node, "net");
        if(!(return_value_strstr_6 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_DVB_NET;

        else
        {
          return_value_strstr_5=strstr(md->node, "ca");
          if(!(return_value_strstr_5 == ((char *)NULL)))
            md->type = (enum device_type)MEDIA_DVB_CA;

          else
          {
            return_value_strstr_4=strstr(md->node, "osd");
            if(!(return_value_strstr_4 == ((char *)NULL)))
              md->type = (enum device_type)MEDIA_DVB_OSD;

          }
        }
      }
    }
  }
  return 0;
}

// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md)
{
  unsigned int add_snd_class__1__c = (unsigned int)65535;
  unsigned int d = (unsigned int)65535;
  char node[64l];
  char *return_value_strstr_2;
  return_value_strstr_2=strstr(md->node, "timer");
  char *return_value_strstr_1;
  if(!(return_value_strstr_2 == ((char *)NULL)))
  {
    md->type = (enum device_type)MEDIA_SND_TIMER;
    return 0;
  }

  else
  {
    return_value_strstr_1=strstr(md->node, "seq");
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      md->type = (enum device_type)MEDIA_SND_SEQ;
      return 0;
    }

  }
  char *return_value_strstr_8;
  return_value_strstr_8=strstr(md->node, "card");
  char *return_value_strstr_7;
  char *return_value_strstr_6;
  char *return_value_strstr_5;
  unsigned long int return_value_strlen_3;
  if(!(return_value_strstr_8 == ((char *)NULL)))
  {
    sscanf(md->node, "card%u", &add_snd_class__1__c);
    md->type = (enum device_type)MEDIA_SND_CARD;
  }

  else
  {
    return_value_strstr_7=strstr(md->node, "hw");
    if(!(return_value_strstr_7 == ((char *)NULL)))
    {
      sscanf(md->node, "hwC%uD%u", &add_snd_class__1__c, &d);
      md->type = (enum device_type)MEDIA_SND_HW;
    }

    else
    {
      return_value_strstr_6=strstr(md->node, "control");
      if(!(return_value_strstr_6 == ((char *)NULL)))
      {
        sscanf(md->node, "controlC%u", &add_snd_class__1__c);
        md->type = (enum device_type)MEDIA_SND_CONTROL;
      }

      else
      {
        return_value_strstr_5=strstr(md->node, "pcm");
        if(!(return_value_strstr_5 == ((char *)NULL)))
        {
          sscanf(md->node, "pcmC%uD%u", &add_snd_class__1__c, &d);
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(md->node);
          if((signed int)md->node[-1l + (signed long int)return_value_strlen_4] == 112)
            md->type = (enum device_type)MEDIA_SND_OUT;

          else
          {
            return_value_strlen_3=strlen(md->node);
            if((signed int)md->node[-1l + (signed long int)return_value_strlen_3] == 99)
              md->type = (enum device_type)MEDIA_SND_CAP;

          }
        }

      }
    }
  }
  if(add_snd_class__1__c == 65535u)
    return 0;

  else
  {
    if(d == 65535u)
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u", add_snd_class__1__c);

    else
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u,%u", add_snd_class__1__c, d);
    free((void *)md->node);
    md->node=strdup(node);
    return 0;
  }
}

// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md)
{
  char *return_value_strstr_4;
  return_value_strstr_4=strstr(md->node, "video");
  char *return_value_strstr_3;
  char *return_value_strstr_2;
  char *return_value_strstr_1;
  if(!(return_value_strstr_4 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_V4L_VIDEO;

  else
  {
    return_value_strstr_3=strstr(md->node, "vbi");
    if(!(return_value_strstr_3 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_V4L_VBI;

    else
    {
      return_value_strstr_2=strstr(md->node, "radio");
      if(!(return_value_strstr_2 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_V4L_RADIO;

      else
      {
        return_value_strstr_1=strstr(md->node, "v4l-subdev");
        if(!(return_value_strstr_1 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_V4L_SUBDEV;

      }
    }
  }
  return 0;
}

// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int arg = 0;
  signed int return_value_strcasecmp_4;
  return_value_strcasecmp_4=strcasecmp(name, "setnorm");
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_4 == 0)
    attr=ng_attr_byname(attrs, "norm");

  else
  {
    return_value_strcasecmp_3=strcasecmp(name, "setinput");
    if(return_value_strcasecmp_3 == 0)
      attr=ng_attr_byname(attrs, "input");

    else
    {
      return_value_strcasecmp_2=strcasecmp(name, "setattr");
      if(return_value_strcasecmp_2 == 0 && argc >= 1)
      {
        signed int tmp_post_1 = arg;
        arg = arg + 1;
        attr=ng_attr_byname(attrs, argv[(signed long int)tmp_post_1]);
      }

      else
        attr=ng_attr_byname(attrs, name);
    }
  }
  if(attr == ((struct ng_attribute *)NULL))
  {
    char *tmp_if_expr_5;
    if(arg >= 1)
      tmp_if_expr_5 = argv[(signed long int)0];

    else
      tmp_if_expr_5 = name;
    fprintf(stderr, "cmd: %s: attribute not found\nvalid choices are:", tmp_if_expr_5);
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
      fprintf(stderr, "%s \"%s\"", attr != attrs ? "," : "", attr->name);
    fprintf(stderr, "\n");
    return -1;
  }

  else
  {
    if(cur_movie == 0 && !(capture_get_hook == ((void (*)(void))NULL)))
      capture_get_hook();

    switch(attr->type)
    {
      case 2:
      {
        if(!(arg >= argc))
        {
          signed int return_value_strcasecmp_6;
          return_value_strcasecmp_6=strcasecmp("next", argv[(signed long int)arg]);
          if(return_value_strcasecmp_6 == 0)
          {
            val = cur_attrs[(signed long int)attr->id];
            val = val + 1;
            if((attr->choices + (signed long int)val)->str == ((const char *)NULL))
              val = 0;

          }

          else
            val=ng_attr_getint(attr, argv[(signed long int)arg]);
          if(val == -1)
          {
            fprintf(stderr, "invalid value for %s: %s\n", attr->name, argv[(signed long int)arg]);
            ng_attr_listchoices(attr);
          }

          else
          {
            set_attr(attr, val);
            set_msg_str(attr->name, (attr->choices + (signed long int)val)->str);
          }
        }

        break;
      }
      case 1:
      {
        if(!(arg >= argc))
        {
          cur_attrs[(signed long int)attr->id]=attr->read(attr);
          val=update_int(attr, cur_attrs[(signed long int)attr->id], argv[(signed long int)arg]);
          set_attr(attr, val);
        }

        set_msg_int(attr, cur_attrs[(signed long int)attr->id]);
        break;
      }
      case 3:
      {
        if(!(arg >= argc))
        {
          val=str_to_int(argv[(signed long int)arg], booltab);
          if(val == -1)
          {
            signed int return_value_strcasecmp_7;
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)arg], "toggle");
            if(return_value_strcasecmp_7 == 0)
              val = (signed int)!(cur_attrs[(signed long int)attr->id] != 0);

          }

          set_attr(attr, val);
        }

        set_msg_bool(attr->name, cur_attrs[(signed long int)attr->id]);
      }
    }
    if(cur_movie == 0 && !(capture_rel_hook == ((void (*)(void))NULL)))
      capture_rel_hook();

    return 0;
  }
}

// attr_init
// file common/commands.c line 473
void attr_init(void)
{
  struct ng_attribute *attr;
  signed int val;
  attr = attrs;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(attr == ((struct ng_attribute *)NULL)))
      tmp_if_expr_1 = attr->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    _Bool tmp_if_expr_2;
    if(attr->id == 3)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = attr->id == 4 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      val=attr->read(attr);
      if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
        attr_notify(attr, val);

      cur_attrs[(signed long int)attr->id] = val;
    }

    attr = attr + 1l;
  }
  while((_Bool)1);
  struct ng_attribute *return_value_ng_attr_byid_3;
  if(defaults.color == -1)
  {
    return_value_ng_attr_byid_3=ng_attr_byid(attrs, 6);
    if(!(return_value_ng_attr_byid_3 == ((struct ng_attribute *)NULL)))
      defaults.color = cur_attrs[(signed long int)6];

  }

  struct ng_attribute *return_value_ng_attr_byid_4;
  if(defaults.bright == -1)
  {
    return_value_ng_attr_byid_4=ng_attr_byid(attrs, 7);
    if(!(return_value_ng_attr_byid_4 == ((struct ng_attribute *)NULL)))
      defaults.bright = cur_attrs[(signed long int)7];

  }

  struct ng_attribute *return_value_ng_attr_byid_5;
  if(defaults.hue == -1)
  {
    return_value_ng_attr_byid_5=ng_attr_byid(attrs, 8);
    if(!(return_value_ng_attr_byid_5 == ((struct ng_attribute *)NULL)))
      defaults.hue = cur_attrs[(signed long int)8];

  }

  struct ng_attribute *return_value_ng_attr_byid_6;
  if(defaults.contrast == -1)
  {
    return_value_ng_attr_byid_6=ng_attr_byid(attrs, 9);
    if(!(return_value_ng_attr_byid_6 == ((struct ng_attribute *)NULL)))
      defaults.contrast = cur_attrs[(signed long int)9];

  }

}

// audio_init
// file ./common/commands.h line 69
void audio_init(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)3]=attr->read(attr);

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)4]=attr->read(attr);

  if(!(volume_notify == ((void (*)(void))NULL)))
    volume_notify();

}

// audio_off
// file ./common/commands.h line 71
void audio_off(void)
{
  set_mute(1);
}

// audio_on
// file ./common/commands.h line 70
void audio_on(void)
{
  set_mute(0);
}

// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
    unsigned char * restrict tmp_post_8 = d;
    d = d + 1l;
    *tmp_post_8 = (unsigned char)0;
  }
  while((_Bool)1);
}

// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)0;
    unsigned char * restrict tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)2];
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)1];
    unsigned char * restrict tmp_post_5 = d;
    d = d + 1l;
    *tmp_post_5 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  do
  {
    p = p - 1;
    if(p == 0)
      break;

    unsigned char * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = s[(signed long int)1];
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)0];
    s = s + (signed long int)2;
  }
  while((_Bool)1);
}

// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void)
{
  signed int i = 0;
  signed int return_value_get_freq_1;
  for( ; !(i >= count); i = i + 1)
    if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
    {
      channels[(signed long int)i]->channel=lookup_channel(channels[(signed long int)i]->cname);
      if(channels[(signed long int)i]->channel == -1)
        channels[(signed long int)i]->freq = -1;

      else
      {
        return_value_get_freq_1=get_freq(channels[(signed long int)i]->channel);
        channels[(signed long int)i]->freq = return_value_get_freq_1 + channels[(signed long int)i]->fine;
      }
    }

}

// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int temp = 0;
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "toggle");
  if(return_value_strcasecmp_1 == 0)
    i = cur_capture == 0 ? 9 : 0;

  else
    i=str_to_int(argv[(signed long int)0], captab);
  signed int return_value_strcasecmp_2;
  if(argc == 2)
  {
    return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "temp");
    if(return_value_strcasecmp_2 == 0)
      temp = 1;

  }

  if(!(i == -1))
    set_capture(i, temp);

  return 0;
}

// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine)
{
  signed int i;
  i=lookup_channel(name);
  if(i == -1)
    return -1;

  else
  {
    signed int return_value_get_freq_1;
    return_value_get_freq_1=get_freq(i);
    return return_value_get_freq_1 + fine;
  }
}

// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name)
{
  struct CFG_ENTRIES *e;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      return c->sec_entries[(signed long int)i];

  }
  if(c->sec_count % 16 == 16)
  {
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)c->sec_names, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(char *) /*8ul*/ );
    c->sec_names = (char **)return_value_realloc_2;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c->sec_entries, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
    c->sec_entries = (struct CFG_ENTRIES **)return_value_realloc_3;
  }

  e=cfg_init_entries();
  c->sec_names[(signed long int)c->sec_count]=strdup(name);
  c->sec_entries[(signed long int)c->sec_count] = e;
  c->sec_count = c->sec_count + 1;
  c->sec_names[(signed long int)c->sec_count] = (char *)(void *)0;
  c->sec_entries[(signed long int)c->sec_count] = (struct CFG_ENTRIES *)(void *)0;
  return e;
}

// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return (float)-1;

  else
  {
    double return_value_atof_1;
    return_value_atof_1=atof(val);
    return (float)return_value_atof_1;
  }
}

// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return -1;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(val);
    return return_value_atoi_1;
  }
}

// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char *v = (char *)(void *)0;
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], sec);
    if(return_value_strcasecmp_1 == 0)
      e = c->sec_entries[(signed long int)i];

  }
  signed int return_value_strcasecmp_2;
  if(e == ((struct CFG_ENTRIES *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= e->ent_count); i = i + 1)
    {
      return_value_strcasecmp_2=strcasecmp(e->ent_names[(signed long int)i], ent);
      if(return_value_strcasecmp_2 == 0)
      {
        v = e->ent_values[(signed long int)i];
        e->ent_seen[(signed long int)i] = e->ent_seen[(signed long int)i] + 1l;
      }

    }
    return v;
  }
}

// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void)
{
  struct CFG_ENTRIES *e;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_ENTRIES) /*32ul*/ );
  e = (struct CFG_ENTRIES *)return_value_malloc_1;
  memset((void *)e, 0, sizeof(struct CFG_ENTRIES) /*32ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_names = (char **)return_value_malloc_2;
  e->ent_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_values = (char **)return_value_malloc_3;
  e->ent_values[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)16 * sizeof(signed int *) /*8ul*/ );
  e->ent_seen = (signed int **)return_value_malloc_4;
  e->ent_seen[(signed long int)0] = ((signed int *)NULL);
  return e;
}

// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void)
{
  struct CFG_SECTIONS *cfg_init_sections__1__c;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct CFG_SECTIONS) /*24ul*/ );
  cfg_init_sections__1__c = (struct CFG_SECTIONS *)return_value_malloc_1;
  memset((void *)cfg_init_sections__1__c, 0, sizeof(struct CFG_SECTIONS) /*24ul*/ );
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  cfg_init_sections__1__c->sec_names = (char **)return_value_malloc_2;
  cfg_init_sections__1__c->sec_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)16 * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
  cfg_init_sections__1__c->sec_entries = (struct CFG_ENTRIES **)return_value_malloc_3;
  cfg_init_sections__1__c->sec_entries[(signed long int)0] = (struct CFG_ENTRIES *)(void *)0;
  return cfg_init_sections__1__c;
}

// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(c == ((struct CFG_SECTIONS *)NULL))
    return (char **)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= c->sec_count); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(c->sec_names[(signed long int)i], name);
      if(return_value_strcasecmp_1 == 0)
        return c->sec_entries[(signed long int)i]->ent_names;

    }
    return (char **)(void *)0;
  }
}

// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void)
{
  return c->sec_names;
}

// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char line[256l];
  char tag[64l];
  char value[192l];
  struct _IO_FILE *fp;
  signed int nr;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  fp=fopen(filename, "r");
  char *return_value_fgets_1;
  signed int return_value_sscanf_6;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    nr = 0;
    do
    {
      return_value_fgets_1=fgets(line, 255, fp);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      nr = nr + 1;
      _Bool tmp_if_expr_2;
      if((signed int)line[0l] == 10)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
      {
        signed int return_value_sscanf_7;
        return_value_sscanf_7=sscanf(line, "[%99[^]]]", (const void *)value);
        if(return_value_sscanf_7 == 1)
          e=cfg_find_section(c, value);

        else
        {
          return_value_sscanf_6=sscanf(line, " %63[^= ] = %191[^\n]", (const void *)tag, (const void *)value);
          if(return_value_sscanf_6 == 2)
          {
            if(e == ((struct CFG_ENTRIES *)NULL))
              fprintf(stderr, "%s:%d: error: no section\n", filename, nr);

            else
            {
              char *cfg_parse_file__1__1__2__2__c;
              unsigned long int return_value_strlen_4;
              return_value_strlen_4=strlen(value);
              cfg_parse_file__1__1__2__2__c = (value + (signed long int)return_value_strlen_4) - (signed long int)1;
              while(!(value >= cfg_parse_file__1__1__2__2__c))
              {
                if(!((signed int)*cfg_parse_file__1__1__2__2__c == 32))
                {
                  if(!((signed int)*cfg_parse_file__1__1__2__2__c == 9))
                    break;

                }

                char *tmp_post_5 = cfg_parse_file__1__1__2__2__c;
                cfg_parse_file__1__1__2__2__c = cfg_parse_file__1__1__2__2__c - 1l;
                *tmp_post_5 = (char)0;
              }
              cfg_set_entry(e, tag, value);
            }
          }

          else
            fprintf(stderr, "%s:%d: syntax error\n", filename, nr);
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  e=cfg_find_section(c, section);
  cfg_set_entry(e, tag, value);
}

// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv)
{
  char section[64l];
  char tag[64l];
  signed int i;
  signed int j;
  i = 1;
  while(!(1 + i >= *argc))
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(argv[(signed long int)i], "-%63[^:]:%63s", (const void *)section, (const void *)tag);
    if(return_value_sscanf_1 == 2)
    {
      cfg_parse_option(section, tag, argv[(signed long int)(i + 1)]);
      j = i;
      for( ; !(j >= *argc + -1); j = j + 1)
        argv[(signed long int)j] = argv[(signed long int)(j + 2)];
      *argc = *argc - 2;
    }

    else
      i = i + 1;
  }
}

// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value)
{
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(i >= e->ent_count); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(e->ent_names[(signed long int)i], name);
    if(return_value_strcasecmp_1 == 0)
      break;

  }
  if(i == e->ent_count)
  {
    if(e->ent_count % 16 == 16)
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)e->ent_names, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_names = (char **)return_value_realloc_2;
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)e->ent_values, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_values = (char **)return_value_realloc_3;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)e->ent_seen, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(signed int *) /*8ul*/ );
      e->ent_seen = (signed int **)return_value_realloc_4;
    }

    e->ent_count = e->ent_count + 1;
    e->ent_names[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_values[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_seen[(signed long int)e->ent_count] = ((signed int *)NULL);
  }

  e->ent_names[(signed long int)i]=strdup(name);
  e->ent_values[(signed long int)i]=strdup(value);
}

// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count)
{
  *count = *count - 1;
  memmove((void *)(oc + (signed long int)n), (const void *)(oc + (signed long int)n + (signed long int)1), sizeof(struct OVERLAY_CLIP) /*16ul*/  * (unsigned long int)(*count - n));
}

// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count)
{
  signed int i;
  fprintf(stderr, "clip: %s - %d clips\n", state, count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
    fprintf(stderr, "clip:   %d: %dx%d+%d+%d\n", i, (oc + (signed long int)i)->x2 - (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y2 - (oc + (signed long int)i)->y1, (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y1);
}

// ctrlc
// file console/streamer.c line 319
static void ctrlc(signed int signal)
{
  unsigned long int return_value_strlen_1;
  if(quiet == 0)
  {
    static char text[24l] = { '^', 'C', ' ', '-', ' ', 'o', 'n', 'e', ' ', 'm', 'o', 'm', 'e', 'n', 't', ' ', 'p', 'l', 'e', 'a', 's', 'e', '\n', 0 };
    return_value_strlen_1=strlen(text);
    write(2, (const void *)text, return_value_strlen_1);
  }

  signaled = 1;
}

// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr = (struct ng_attribute *)(void *)0;
  unsigned int i;
  signed int return_value_strcasecmp_1;
  if(argc >= 1)
  {
    return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "next");
    if(return_value_strcasecmp_1 == 0)
    {
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= 2ul); i = i + 1u)
      {
        cur_dattr = cur_dattr + 1;
        cur_dattr = cur_dattr % (signed int)(sizeof(signed int [5l]) /*20ul*/  / sizeof(char *) /*8ul*/ );
        attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);
        if(!(attr == ((struct ng_attribute *)NULL)))
          break;

      }
      if(attr == ((struct ng_attribute *)NULL))
        return 0;

      argc = 0;
    }

  }

  if(attr == ((struct ng_attribute *)NULL))
    attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);

  if(attr == ((struct ng_attribute *)NULL))
    return 0;

  else
  {
    signed int return_value_attr_handler_2;
    return_value_attr_handler_2=attr_handler((char *)attr->name, argc, argv);
    return return_value_attr_handler_2;
  }
}

// del_channel
// file common/channel.c line 287
void del_channel(signed int i)
{
  free((void *)channels[(signed long int)i]->name);
  if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    free((void *)channels[(signed long int)i]->key);

  free((void *)channels[(signed long int)i]);
  count = count - 1;
  if(!(i >= count))
    memmove((void *)(channels + (signed long int)i), (const void *)(channels + (signed long int)i + (signed long int)1), (unsigned long int)(count - i) * sizeof(struct CHANNEL *) /*8ul*/ );

}

// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void)
{
  struct media_devices *md = (struct media_devices *)(void *)0;
  struct media_device_entry *md_entry = (struct media_device_entry *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct media_devices) /*16ul*/ );
  md = (struct media_devices *)return_value_calloc_1;
  signed int return_value_get_class_3;
  signed int return_value_get_class_4;
  if(md == ((struct media_devices *)NULL))
    return (void *)0;

  else
  {
    md->md_size = (unsigned int)0;
    signed int return_value_get_class_2;
    return_value_get_class_2=get_class("video4linux", &md_entry, &md->md_size, add_v4l_class);
    if(return_value_get_class_2 == 0)
    {
      return_value_get_class_3=get_class("sound", &md_entry, &md->md_size, add_snd_class);
      if(!(return_value_get_class_3 == 0))
        goto error;

      return_value_get_class_4=get_class("dvb", &md_entry, &md->md_size, add_dvb_class);
      if(!(return_value_get_class_4 == 0))
        goto error;

      if(md_entry == ((struct media_device_entry *)NULL))
        goto error;

      qsort((void *)md_entry, (unsigned long int)md->md_size, sizeof(struct media_device_entry) /*32ul*/ , sort_media_device_entry);
      md->md_entry = md_entry;
      return (void *)md;
    }

    else
    {

    error:
      ;
      free_media_devices((void *)md);
      return (void *)0;
    }
  }
}

// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  char *prev = "";
  i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(prev, md_ptr->device);
    if(!(return_value_strcmp_1 == 0))
    {
      printf("\nDevice %s:\n\t", md_ptr->device);
      prev = md_ptr->device;
    }

    const char *return_value_media_device_type_2;
    return_value_media_device_type_2=media_device_type(md_ptr->type);
    printf("%s(%s, dev %i:%i) ", md_ptr->node, return_value_media_device_type_2, md_ptr->major, md_ptr->minor);
    md_ptr = md_ptr + 1l;
  }
  printf("\n");
}

// do_command
// file common/commands.c line 240
signed int do_command(signed int argc, char **argv)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(argc == 0)
  {
    fprintf(stderr, "do_command: no argument\n");
    return -1;
  }

  else
  {
    if(!(debug == 0))
    {
      fprintf(stderr, "cmd:");
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        fprintf(stderr, " \"%s\"", argv[(signed long int)i]);
      fprintf(stderr, "\n");
    }

    i = 0;
    for( ; !(commands[(signed long int)i].name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp(commands[(signed long int)i].name, argv[(signed long int)0]);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(commands[(signed long int)i].name == ((char *)NULL))
    {
      fprintf(stderr, "no handler for %s\n", argv[(signed long int)0]);
      return -1;
    }

    else
      if(!(argc + -1 >= commands[(signed long int)i].min_args))
      {
        fprintf(stderr, "no enough args for %s\n", argv[(signed long int)0]);
        return -1;
      }

      else
      {
        signed int return_value;
        return_value=commands[(signed long int)i].handler(argv[(signed long int)0], argc - 1, argv + (signed long int)1);
        return return_value;
      }
  }
}

// do_rec_status
// file console/streamer.c line 312
static void do_rec_status(char *message)
{
  if(quiet == 0)
    fprintf(stderr, "%s  \r", message);

}

// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...)
{
  __builtin_va_list ap;
  signed int i;
  char *argv[32l];
  va_start(ap, argc);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    argv[(signed long int)i]=va_arg(ap, __typeof__(argv[(signed long int)i]));
  argv[(signed long int)i] = (char *)(void *)0;
  va_end(ap);
  signed int return_value_do_command_1;
  return_value_do_command_1=do_command(argc, argv);
  return return_value_do_command_1;
}

// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  unsigned int i;
  unsigned char *line;
  signed int line_length;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  jpeg_stdio_dest(&cinfo, fp);
  cinfo.image_width = buf->fmt.width;
  cinfo.image_height = buf->fmt.height;
  cinfo.input_components = gray != 0 ? 1 : 3;
  cinfo.in_color_space = (enum anonymous_13)(gray != 0 ? JCS_GRAYSCALE : JCS_RGB);
  jpeg_set_defaults(&cinfo);
  jpeg_set_quality(&cinfo, quality, 1);
  jpeg_start_compress(&cinfo, 1);
  unsigned int tmp_if_expr_1;
  if(!(gray == 0))
    tmp_if_expr_1 = buf->fmt.width;

  else
    tmp_if_expr_1 = buf->fmt.width * (unsigned int)3;
  line_length = (signed int)tmp_if_expr_1;
  i = (unsigned int)0;
  line = buf->data;
  for( ; !(i >= buf->fmt.height); line = line + (signed long int)line_length)
  {
    jpeg_write_scanlines(&cinfo, &line, (unsigned int)1);
    i = i + 1u;
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
  fclose(fp);
  return 0;
}

// event_dispatch
// file common/event.c line 112
signed int event_dispatch(char *event)
{
  struct event_entry *entry = (struct event_entry *)(void *)0;
  char *name;
  char *arg;
  char *h;
  char *argv[16l];
  signed int argc;
  h=strchr(event, 40);
  if(!(h == ((char *)NULL)))
  {
    name = event;
    arg = h + (signed long int)1;
    *h = (char)0;
    h=strchr(arg, 41);
    if(!(h == ((char *)NULL)))
      *h = (char)0;

    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s arg=%s\n", name, arg);

  }

  else
  {
    name = event;
    arg = (char *)(void *)0;
    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s\n", name);

  }
  signed int return_value_strcasecmp_1;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_1=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
  }

  signed int return_value_strcasecmp_2;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_builtin_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp_2=strcasecmp(name, entry->event);
      if(return_value_strcasecmp_2 == 0)
        break;

    }
  }

  if(entry == ((struct event_entry *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "ev: 404: %s\n", name);

    return 0;
  }

  else
  {
    memcpy((void *)argv, (const void *)entry->argv, sizeof(char *[16l]) /*128ul*/ );
    argc = entry->argc;
    if(!(arg == ((char *)NULL)))
    {
      signed int tmp_post_3 = argc;
      argc = argc + 1;
      argv[(signed long int)tmp_post_3] = arg;
    }

    do_command(argc, argv);
    return 0;
  }
}

// event_readconfig
// file common/event.h line 20
void event_readconfig(void)
{
  char **list;
  char *val;
  list=cfg_list_entries("eventmap");
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("eventmap", *list);
      if(!(val == ((char *)NULL)))
        event_register(*list, val);

    }

}

// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action)
{
  struct event_entry *entry;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct event_entry) /*528ul*/ );
  entry = (struct event_entry *)return_value_malloc_1;
  memset((void *)entry, 0, sizeof(struct event_entry) /*528ul*/ );
  strncpy(entry->event, event, (unsigned long int)127);
  strncpy(entry->action, action, (unsigned long int)127);
  entry->next = event_conf_list;
  event_conf_list = entry;
  parse_action(entry);
  if(!(debug == 0))
    fprintf(stderr, "ev: reg conf \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

  return 0;
}

// event_register_list
// file common/event.c line 71
signed int event_register_list(struct event_entry *entry)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!(entry == ((struct event_entry *)NULL)))
      tmp_if_expr_1 = 0 != (signed int)entry->event[(signed long int)0] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    entry->next = event_builtin_list;
    event_builtin_list = entry;
    parse_action(entry);
    if(!(debug == 0))
      fprintf(stderr, "ev: reg built-in \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

    entry = entry + 1l;
  }
  while((_Bool)1);
  return 0;
}

// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp)
{
  struct event_entry *entry;
  if(!(event_conf_list == ((struct event_entry *)NULL)))
  {
    fprintf(fp, "[eventmap]\n");
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
      fprintf(fp, "%s = %s\n", (const void *)entry->event, (const void *)entry->action);
    fprintf(fp, "\n");
  }

}

// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv)
{
  if(!(exit_hook == ((void (*)(void))NULL)))
    exit_hook();

  return 0;
}

// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  struct stat f_status;
  unsigned int dev_major;
  unsigned int dev_minor;
  signed int i;
  signed int found = 0;
  char *prev;
  signed int return_value_fstat_1;
  return_value_fstat_1=fstat(fd_seek_device, &f_status);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(return_value_fstat_1 == 0))
  {
    perror("Can't get file status");
    return (const char *)(void *)0;
  }

  else
    if(!((61440u & f_status.st_mode) == 8192u))
    {
      fprintf(stderr, "File descriptor is not a char device\n");
      return (const char *)(void *)0;
    }

    else
    {
      dev_major=gnu_dev_major(f_status.st_rdev);
      dev_minor=gnu_dev_minor(f_status.st_rdev);
      i = 0;
      for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
      {
        if(!(last_seek == ((const char *)NULL)))
        {
          if(!(md_ptr->type == seek_type))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->major == dev_major))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->minor == dev_minor))
            goto __CPROVER_DUMP_L4;

          found = 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(found == 0) || last_seek == ((const char *)NULL))
          {
            if(md_ptr->type == seek_type)
            {
              if(md_ptr->major == dev_major)
              {
                if(md_ptr->minor == dev_minor)
                  break;

              }

            }

          }

        }
        i = i + 1;
      }
      if((unsigned int)i == md->md_size)
        return (const char *)(void *)0;

      else
      {
        i = i + 1;
        prev = md_ptr->device;
        md_ptr = md_ptr + 1l;
        do
        {
          if(!((unsigned int)i >= md->md_size))
          {
            return_value_strcmp_2=strcmp(prev, md_ptr->device);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          if(!(last_seek == ((const char *)NULL)))
          {
            if(!(md_ptr->type == seek_type))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->major == dev_major))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->minor == dev_minor))
              goto __CPROVER_DUMP_L11;

            found = 1;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!(found == 0) || last_seek == ((const char *)NULL))
            {
              if(md_ptr->type == desired_type)
                return md_ptr->node;

            }

          }
          i = i + 1;
          md_ptr = md_ptr + 1l;
        }
        while((_Bool)1);
        return (const char *)(void *)0;
      }
    }
}

// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo)
{
  void *data;
  pthread_mutex_lock(&fifo->lock);
  while(fifo->write == fifo->read)
  {
    if(fifo->writers == fifo->eof)
      break;

    pthread_cond_wait(&fifo->hasdata, &fifo->lock);
  }
  signed int return_value_getpid_1;
  if(fifo->write == fifo->read)
  {
    pthread_cond_signal(&fifo->hasdata);
    pthread_mutex_unlock(&fifo->lock);
    return (void *)0;
  }

  else
  {
    if(debug >= 2)
    {
      return_value_getpid_1=getpid();
      fprintf(stderr, "get %s %d=%p [pid=%d]\n", fifo->name, fifo->read, fifo->data[(signed long int)fifo->read], return_value_getpid_1);
    }

    data = (void *)fifo->data[(signed long int)fifo->read];
    fifo->read = fifo->read + 1;
    if(fifo->read >= fifo->slots)
      fifo->read = 0;

    pthread_mutex_unlock(&fifo->lock);
    return data;
  }
}

// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers)
{
  pthread_mutex_init(&fifo->lock, (const union anonymous_8 *)(void *)0);
  pthread_cond_init(&fifo->hasdata, (const union anonymous_8 *)(void *)0);
  fifo->name = name;
  fifo->slots = slots;
  fifo->writers = writers;
  fifo->read = 0;
  fifo->write = 0;
  fifo->eof = 0;
  fifo->max = 0;
}

// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data)
{
  signed int full;
  pthread_mutex_lock(&fifo->lock);
  signed int return_value_getpid_1;
  if(data == NULL)
  {
    fifo->eof = fifo->eof + 1;
    if(!(debug == 0))
      fprintf(stderr, "fifo %s: EOF %d/%d\n", fifo->name, fifo->eof, fifo->writers);

    if(fifo->writers == fifo->eof)
      pthread_cond_broadcast(&fifo->hasdata);

    pthread_mutex_unlock(&fifo->lock);
    return 0;
  }

  else
    if((1 + fifo->write) % fifo->slots == fifo->read)
    {
      pthread_mutex_unlock(&fifo->lock);
      fprintf(stderr, "fifo %s is full\n", fifo->name);
      return -1;
    }

    else
    {
      if(debug >= 2)
      {
        return_value_getpid_1=getpid();
        fprintf(stderr, "put %s %d=%p [pid=%d]\n", fifo->name, fifo->write, data, return_value_getpid_1);
      }

      fifo->data[(signed long int)fifo->write] = (unsigned char *)data;
      fifo->write = fifo->write + 1;
      full = ((fifo->write + fifo->slots) - fifo->read) % fifo->slots;
      if(!(fifo->max >= full))
        fifo->max = full;

      if(fifo->write >= fifo->slots)
        fifo->write = 0;

      pthread_cond_signal(&fifo->hasdata);
      pthread_mutex_unlock(&fifo->lock);
      return 0;
    }
}

// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle)
{
  struct files_handle *h = (struct files_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  free((void *)h);
  return 0;
}

// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct files_handle *h;
  if(!(video->fmtid == 0u))
  {
    if(!(filesname == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct files_handle) /*4176ul*/ );
    h = (struct files_handle *)return_value_malloc_1;
    if(h == ((struct files_handle *)NULL))
      return (void *)0;

    else
    {
      memset((void *)h, 0, sizeof(struct files_handle) /*4176ul*/ );
      h->video = *video;
      h->audio = *audio;
      if(!(filesname == ((char *)NULL)))
        strcpy(h->file, filesname);

      if(!(h->audio.fmtid == 0u))
      {
        h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
        if(h->wav_fd == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
          free((void *)h);
          return (void *)0;
        }

        wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
      }

      return (void *)h;
    }
  }
}

// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed int rc = -1;
  struct _IO_FILE *fp;
  if(!(h->gotcha == 0))
  {
    fprintf(stderr, "Oops: can't count up file names any more\n");
    return -1;
  }

  else
  {
    switch(h->video.fmtid)
    {
      case (unsigned int)9:
      {
        rc=write_ppm(h->file, buf);
        break;
      }
      case (unsigned int)2:
      {
        rc=write_pgm(h->file, buf);
        break;
      }
      case (unsigned int)17:
      {
        fp=fopen(h->file, "w");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "grab: can't open %s: %s\n", (const void *)h->file, return_value_strerror_2);
          rc = -1;
        }

        else
        {
          fwrite((const void *)buf->data, buf->size, (unsigned long int)1, fp);
          fclose(fp);
          rc = 0;
        }
      }
    }
    signed int return_value_patch_up_3;
    return_value_patch_up_3=patch_up(h->file);
    if(!(return_value_patch_up_3 == 1))
      h->gotcha = 1;

    return rc;
  }
}

// find_formats
// file console/streamer.c line 189
static void find_formats(void)
{
  struct list_head *item;
  struct ng_writer *wr = (struct ng_writer *)(void *)0;
  char *mext = (char *)(void *)0;
  char *aext = (char *)(void *)0;
  signed int v = -1;
  signed int a = -1;
  if(!(moviename == ((char *)NULL)))
  {
    mext=strrchr(moviename, 46);
    if(!(mext == ((char *)NULL)))
      mext = mext + 1l;

  }

  if(!(audioname == ((char *)NULL)))
  {
    aext=strrchr(audioname, 46);
    if(!(aext == ((char *)NULL)))
      aext = aext + 1l;

  }

  item = (&ng_writers)->next;
  signed int return_value_strcasecmp_1;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_5;
  for( ; !(item == &ng_writers); item = item->next)
  {
    wr = (struct ng_writer *)((char *)item - (signed long int)(unsigned long int)&((struct ng_writer *)0)->list);
    if(!(debug == 0))
      fprintf(stderr, "checking writer %s [%s] ...\n", wr->name, wr->desc);

    if(!(mext == ((char *)NULL)) || !(vfmt_name == ((char *)NULL)))
    {
      if(wr->video == ((struct ng_format_list *)NULL))
      {
        if(!(debug == 0))
          fprintf(stderr, "  no video, skipping\n");

        goto __CPROVER_DUMP_L36;
      }

      v = 0;
      for( ; !((wr->video + (signed long int)v)->name == ((char *)NULL)); v = v + 1)
      {
        if(!(debug == 0))
          fprintf(stderr, "  video name=%s ext=%s: ", (wr->video + (signed long int)v)->name, (wr->video + (signed long int)v)->ext);

        if(!(mext == ((char *)NULL)))
        {
          return_value_strcasecmp_1=strcasecmp((wr->video + (signed long int)v)->ext, mext);
          if(!(return_value_strcasecmp_1 == 0))
          {
            if(!(debug == 0))
              fprintf(stderr, "ext mismatch [need %s]\n", mext);

            goto __CPROVER_DUMP_L16;
          }

        }

        if(!(vfmt_name == ((char *)NULL)))
        {
          return_value_strcasecmp_2=strcasecmp((wr->video + (signed long int)v)->name, vfmt_name);
          if(!(return_value_strcasecmp_2 == 0))
          {
            if(!(debug == 0))
              fprintf(stderr, "name mismatch [need %s]\n", vfmt_name);

            goto __CPROVER_DUMP_L16;
          }

        }

        if(!(debug == 0))
          fprintf(stderr, "OK\n");

        break;

      __CPROVER_DUMP_L16:
        ;
      }
      if((wr->video + (signed long int)v)->name == ((char *)NULL))
        goto __CPROVER_DUMP_L36;

    }

    if(wr->combined == 0 && !(aext == ((char *)NULL)) || !(afmt_name == ((char *)NULL)))
    {
      if(wr->audio == ((struct ng_format_list *)NULL))
      {
        if(!(debug == 0))
          fprintf(stderr, "  no audio, skipping\n");

        goto __CPROVER_DUMP_L36;
      }

      a = 0;
      for( ; !((wr->audio + (signed long int)a)->name == ((char *)NULL)); a = a + 1)
      {
        if(!(debug == 0))
          fprintf(stderr, "  audio name=%s ext=%s: ", (wr->audio + (signed long int)a)->name, (wr->audio + (signed long int)a)->ext);

        if(wr->combined == 0)
        {
          if(!(aext == ((char *)NULL)))
          {
            return_value_strcasecmp_3=strcasecmp((wr->audio + (signed long int)a)->ext, aext);
            if(!(return_value_strcasecmp_3 == 0))
            {
              if(!(debug == 0))
                fprintf(stderr, "ext mismatch [need %s]\n", aext);

              goto __CPROVER_DUMP_L33;
            }

          }

        }

        if(!(wr->combined == 0))
        {
          if(!(mext == ((char *)NULL)))
          {
            return_value_strcasecmp_4=strcasecmp((wr->audio + (signed long int)a)->ext, mext);
            if(!(return_value_strcasecmp_4 == 0))
            {
              if(!(debug == 0))
                fprintf(stderr, "ext mismatch [need %s]\n", mext);

              goto __CPROVER_DUMP_L33;
            }

          }

        }

        if(!(afmt_name == ((char *)NULL)))
        {
          return_value_strcasecmp_5=strcasecmp((wr->audio + (signed long int)a)->name, afmt_name);
          if(!(return_value_strcasecmp_5 == 0))
          {
            if(!(debug == 0))
              fprintf(stderr, "name mismatch [need %s]\n", afmt_name);

            goto __CPROVER_DUMP_L33;
          }

        }

        if(!(debug == 0))
          fprintf(stderr, "OK\n");

        break;

      __CPROVER_DUMP_L33:
        ;
      }
      if((wr->audio + (signed long int)a)->name == ((char *)NULL))
        goto __CPROVER_DUMP_L36;

    }

    break;

  __CPROVER_DUMP_L36:
    ;
  }
  if(!(item == &ng_writers))
  {
    writer = wr;
    if(!(v == -1))
    {
      video.fmtid = (wr->video + (signed long int)v)->fmtid;
      video_priv = (wr->video + (signed long int)v)->priv;
    }

    if(!(a == -1))
    {
      audio.fmtid = (wr->audio + (signed long int)a)->fmtid;
      audio_priv = (wr->audio + (signed long int)a)->priv;
    }

  }

  else
    if(!(debug == 0))
      fprintf(stderr, "no match found\n");

}

// flushit
// file common/capture.c line 106
static void * flushit(void *arg)
{
  signed int old;
  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  do
  {
    sleep((unsigned int)1);
    sync();
  }
  while((_Bool)1);
  return (void *)0;
}

// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    free((void *)md_ptr->node);
    free((void *)md_ptr->device);
    md_ptr = md_ptr + 1l;
  }
  free((void *)md->md_entry);
  free((void *)md);
}

// freq_init
// file common/frequencies.c line 22
void freq_init(void)
{
  char line[256l];
  char value[256l];
  struct _IO_FILE *fp;
  signed int nr;
  signed int i;
  signed int j;
  fp=fopen("/usr/share/xawtv/Index.map", "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror("open /usr/share/xawtv/Index.map");
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading /usr/share/xawtv/Index.map\n");

  nr = 0;
  i = 0;
  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(line, 255, fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    nr = nr + 1;
    _Bool tmp_if_expr_2;
    if((signed int)line[0l] == 10)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_3)
    {
      signed int return_value_sscanf_5;
      return_value_sscanf_5=sscanf(line, "[%255[^]]]", (const void *)value);
      if(return_value_sscanf_5 == 1)
      {
        void *return_value_realloc_4;
        return_value_realloc_4=realloc((void *)chanlists, (unsigned long int)(i + 2) * sizeof(struct CHANLISTS) /*32ul*/ );
        chanlists = (struct CHANLISTS *)return_value_realloc_4;
        memset((void *)(chanlists + (signed long int)i), 0, (unsigned long int)2 * sizeof(struct CHANLISTS) /*32ul*/ );
        (chanlists + (signed long int)i)->name=strdup(value);
        i = i + 1;
        continue;
      }

      if(chanlists == ((struct CHANLISTS *)NULL))
        fprintf(stderr, "%s:%d: error: no section\n", (const void *)"/usr/share/xawtv/Index.map", nr);

      else
      {
        signed int return_value_sscanf_6;
        return_value_sscanf_6=sscanf(line, " file = %255[^\n]", (const void *)value);
        if(return_value_sscanf_6 == 1)
          (chanlists + (signed long int)(i - 1))->filename=strdup(value);

        else
          fprintf(stderr, "%s:%d: syntax error\n", (const void *)"/usr/share/xawtv/Index.map", nr);
      }
    }

  }
  while((_Bool)1);
  fclose(fp);
  void *return_value_malloc_7;
  return_value_malloc_7=malloc((unsigned long int)(i + 1) * sizeof(struct STRTAB) /*16ul*/ );
  chanlist_names = (struct STRTAB *)return_value_malloc_7;
  j = 0;
  for( ; !(j >= i); j = j + 1)
  {
    (chanlist_names + (signed long int)j)->nr = (signed long int)j;
    (chanlist_names + (signed long int)j)->str = (chanlists + (signed long int)j)->name;
  }
  (chanlist_names + (signed long int)j)->nr = (signed long int)-1;
  (chanlist_names + (signed long int)j)->str = (const char *)(void *)0;
}

// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n)
{
  if(!(debug == 0))
    fprintf(stderr, "freq: newtab %d\n", n);

  if((chanlists + (signed long int)n)->list == ((struct CHANLIST *)NULL))
    (chanlists + (signed long int)n)->count=freq_readlist(&(chanlists + (signed long int)n)->list, 0, (chanlists + (signed long int)n)->filename);

  chantab = n;
}

// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name)
{
  char line[256l];
  char value[256l];
  char filename[256l];
  struct _IO_FILE *fp;
  signed int nr;
  sprintf(filename, "%s/%s", (const void *)"/usr/share/xawtv", name);
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", (const void *)filename, return_value_strerror_2);
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading %s\n", (const void *)filename);

  nr = 0;
  char *return_value_fgets_3;
  do
  {
    return_value_fgets_3=fgets(line, 255, fp);
    if(return_value_fgets_3 == ((char *)NULL))
      break;

    nr = nr + 1;
    signed int return_value_sscanf_4;
    return_value_sscanf_4=sscanf(line, "# include \"%[^\"]\"", (const void *)value);
    if(return_value_sscanf_4 == 1)
      n=freq_readlist(list, n, value);

    else
    {
      _Bool tmp_if_expr_5;
      if((signed int)line[0l] == 10)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_6)
      {
        signed int return_value_sscanf_8;
        return_value_sscanf_8=sscanf(line, "[%255[^]]]", (const void *)value);
        if(return_value_sscanf_8 == 1)
        {
          if(n % 16 == 0)
          {
            void *return_value_realloc_7;
            return_value_realloc_7=realloc((void *)*list, (unsigned long int)(n + 16) * sizeof(struct CHANLIST) /*16ul*/ );
            *list = (struct CHANLIST *)return_value_realloc_7;
            memset((void *)(*list + (signed long int)n), 0, (unsigned long int)16 * sizeof(struct CHANLIST) /*16ul*/ );
          }

          (*list + (signed long int)n)->name=strdup(value);
          n = n + 1;
        }

        else
          if(n == 0)
            fprintf(stderr, "%s:%d: error: no section\n", (const void *)filename, nr);

          else
          {
            signed int return_value_sscanf_10;
            return_value_sscanf_10=sscanf(line, " freq = %255[^\n]", (const void *)value);
            if(return_value_sscanf_10 == 1)
            {
              signed int return_value_atoi_9;
              return_value_atoi_9=atoi(value);
              (*list + (signed long int)(n - 1))->freq = (unsigned int)return_value_atoi_9;
              continue;
            }

            fprintf(stderr, "%s:%d: syntax error\n", (const void *)filename, nr);
          }
      }

    }
  }
  while((_Bool)1);
  fclose(fp);
  return n;
}

// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv)
{
  if(!(fullscreen_hook == ((void (*)(void))NULL)))
    fullscreen_hook();

  return 0;
}

// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int found = 0;
  char *prev;
  char *p;
  _Bool tmp_if_expr_7;
  if(!((signed int)seek_type == NONE))
    tmp_if_expr_7 = seek_device[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_6;
  if(tmp_if_expr_7)
  {
    p=strrchr(seek_device, 47);
    if(!(p == ((char *)NULL)))
      seek_device = p + (signed long int)1;

    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_1 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_2=strcmp(seek_device, md_ptr->node);
          if(return_value_strcmp_2 == 0)
            break;

        }

      }


    __CPROVER_DUMP_L10:
      ;
      i = i + 1;
    }
    if((unsigned int)i == md->md_size)
      return (const char *)(void *)0;

    i = i + 1;
    prev = md_ptr->device;
    md_ptr = md_ptr + 1l;
    do
    {
      if(!((unsigned int)i >= md->md_size))
      {
        return_value_strcmp_3=strcmp(prev, md_ptr->device);
        tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp_5=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp_5 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L20;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L20:
      ;
      i = i + 1;
      md_ptr = md_ptr + 1l;
    }
    while((_Bool)1);
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        return_value_strcmp_6=strcmp(md_ptr->node, last_seek);
        if(return_value_strcmp_6 == 0)
        {
          found = 1;
          goto __CPROVER_DUMP_L28;
        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L28:
      ;
      i = i + 1;
    }
  }
  return (const char *)(void *)0;
}

// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device)
{
  char file[4096l];
  char s[1024l];
  struct _IO_FILE *f;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(device, "/sys/devices/virtual");
  if(return_value_strcmp_1 == 0)
    return (enum bus_type)MEDIA_BUS_VIRTUAL;

  else
  {
    snprintf(file, (unsigned long int)4096, "%s/modalias", device);
    f=fopen(file, "r");
    if(f == ((struct _IO_FILE *)NULL))
      return (enum bus_type)MEDIA_BUS_UNKNOWN;

    else
    {
      char *return_value_fgets_2;
      return_value_fgets_2=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , f);
      if(return_value_fgets_2 == ((char *)NULL))
        return (enum bus_type)MEDIA_BUS_UNKNOWN;

      else
      {
        fclose(f);
        signed int return_value_strncmp_3;
        return_value_strncmp_3=strncmp(s, "pci", (unsigned long int)3);
        if(return_value_strncmp_3 == 0)
          return (enum bus_type)MEDIA_BUS_PCI;

        else
        {
          signed int return_value_strncmp_4;
          return_value_strncmp_4=strncmp(s, "usb", (unsigned long int)3);
          if(return_value_strncmp_4 == 0)
            return (enum bus_type)MEDIA_BUS_USB;

          else
            return (enum bus_type)MEDIA_BUS_UNKNOWN;
        }
      }
    }
  }
}

// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *))
{
  struct __dirstream *dir;
  struct dirent *entry;
  char dname[4096l];
  char fname[4096l];
  char get_class__1__link[4096l];
  char virt_dev[60l];
  signed int err = -2;
  struct media_device_entry *md_ptr = (struct media_device_entry *)(void *)0;
  char *p;
  char *device;
  enum bus_type bus;
  snprintf(dname, (unsigned long int)4096, "/sys/class/%s", class);
  dir=opendir(dname);
  char *return_value_strchr_1;
  if(dir == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    entry=readdir(dir);
    while(!(entry == ((struct dirent *)NULL)))
    {
      if(!((signed int)entry->d_name[0l] == 46))
      {
        snprintf(fname, (unsigned long int)4096, "%s/%s", (const void *)dname, (const void *)entry->d_name);
        char *return_value_realpath_4;
        return_value_realpath_4=realpath(fname, get_class__1__link);
        if(!(return_value_realpath_4 == ((char *)NULL)))
        {
          device = get_class__1__link;
          p=strstr(device, class);
          if(p == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

          *(p - (signed long int)1) = (char)0;
          bus=get_bus(device);
          device = device + (signed long int)13;
          switch((signed int)bus)
          {
            case MEDIA_BUS_PCI:
            {
              p=strrchr(device, 46);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_USB:
            {
              p=strrchr(device, 47);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              return_value_strchr_1=strchr(p, 58);
              if(return_value_strchr_1 == ((char *)NULL))
                break;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_VIRTUAL:
            {
              static signed int virtual = 0;
              signed int tmp_post_2 = virtual;
              virtual = virtual + 1;
              sprintf(virt_dev, "virtual%d", tmp_post_2);
              device = virt_dev;
              break;
            }
            case MEDIA_BUS_UNKNOWN:
              ;
          }
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)*md, (unsigned long int)(*md_size + (unsigned int)1) * sizeof(struct media_device_entry) /*32ul*/ );
          *md = (struct media_device_entry *)return_value_realloc_3;
          if(*md == ((struct media_device_entry *)NULL))
            goto error;

          md_ptr = *md + (signed long int)*md_size;
          *md_size = *md_size + 1u;
          memset((void *)md_ptr, 0, sizeof(struct media_device_entry) /*32ul*/ );
          md_ptr->type = (enum device_type)UNKNOWN;
          md_ptr->device=strdup(device);
          md_ptr->node=strdup(entry->d_name);
          get_uevent_info(md_ptr, dname);
          fill(md_ptr);
        }

      }


    __CPROVER_DUMP_L9:
      ;
      entry=readdir(dir);
    }
    err = 0;

  error:
    ;
    closedir(dir);
    return err;
  }
}

// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(i >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(chantab == -1))
      tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = i >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return -1;

  else
  {
    struct CHANLIST *tmp_if_expr_3;
    if(!(chantab == -1))
      tmp_if_expr_3 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr_3 = (struct CHANLIST *)(void *)0;
    return (signed int)(((tmp_if_expr_3 + (signed long int)i)->freq * (unsigned int)16) / (unsigned int)1000);
  }
}

// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int skip = 0;
  signed int found = 0;
  char *prev = "";
  char *result = (char *)(void *)0;
  i = 0;
  signed int return_value_strcmp_1;
  for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
  {
    if(!(last_seek == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(md_ptr->node, last_seek);
      if(return_value_strcmp_1 == 0)
      {
        found = 1;
        goto __CPROVER_DUMP_L9;
      }

    }

    if(!(found == 0) || last_seek == ((const char *)NULL))
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(prev, md_ptr->device);
      if(!(return_value_strcmp_2 == 0))
      {
        if(skip == 0 && !(result == ((char *)NULL)))
          break;

        prev = md_ptr->device;
        skip = 0;
        result = (char *)(void *)0;
      }

      if(md_ptr->type == not_desired_type)
        skip = 1;

      else
        if(result == ((char *)NULL) && skip == 0)
        {
          if(md_ptr->type == desired_type)
            result = md_ptr->node;

        }

    }


  __CPROVER_DUMP_L9:
    ;
    i = i + 1;
  }
  if(!(skip == 0))
    result = (char *)(void *)0;

  return result;
}

// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname)
{
  struct _IO_FILE *fd;
  char file[4096l];
  char *name;
  char *p;
  char s[1024l];
  snprintf(file, (unsigned long int)4096, "%s/%s/uevent", dname, md_ptr->node);
  fd=fopen(file, "r");
  char *return_value_fgets_1;
  signed long int return_value_atol_2;
  signed int return_value_strcmp_4;
  signed long int return_value_atol_3;
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets_1=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , fd);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      p=strtok(s, "=");
      if(!(p == ((char *)NULL)))
      {
        name = p;
        p=strtok((char *)(void *)0, "\n");
        if(!(p == ((char *)NULL)))
        {
          signed int return_value_strcmp_5;
          return_value_strcmp_5=strcmp(name, "MAJOR");
          if(return_value_strcmp_5 == 0)
          {
            return_value_atol_2=atol(p);
            md_ptr->major = (unsigned int)return_value_atol_2;
          }

          else
          {
            return_value_strcmp_4=strcmp(name, "MINOR");
            if(return_value_strcmp_4 == 0)
            {
              return_value_atol_3=atol(p);
              md_ptr->minor = (unsigned int)return_value_atol_3;
            }

          }
        }

      }

    }
    while((_Bool)1);
    fclose(fd);
  }

}

// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c)
{
  struct ng_attribute *attr;
  char *val;
  signed int n;
  signed int i;
  val=cfg_get_str(name, "capture");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, captab);
    if(!(i == -1))
      c->capture = i;

    else
      fprintf(stderr, "config: invalid value for capture: %s\n", val);
  }

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "input");
    _Bool tmp_if_expr_1;
    if(!(val == ((char *)NULL)))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      val=cfg_get_str(name, "source");
      tmp_if_expr_1 = (char *)(void *)0 != val ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->input = i;

      else
      {
        fprintf(stderr, "config: invalid value for input: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "norm");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->norm = i;

      else
      {
        fprintf(stderr, "config: invalid value for norm: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "audio");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->audio = i;

      else
      {
        fprintf(stderr, "config: invalid value for audio: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  val=cfg_get_str(name, "channel");
  if(!(val == ((char *)NULL)))
    c->cname=strdup(val);

  val=cfg_get_str(name, "freq");
  double return_value_atof_2;
  if(!(val == ((char *)NULL)))
  {
    return_value_atof_2=atof(val);
    c->freq = (signed int)(return_value_atof_2 * (double)16);
  }

  n=cfg_get_signed_int(name, "fine");
  if(!(n == 0))
    c->fine = n;

  val=cfg_get_str(name, "key");
  if(!(val == ((char *)NULL)))
    c->key=strdup(val);

  val=cfg_get_str(name, "group");
  if(!(val == ((char *)NULL)))
    c->group=strdup(val);

  val=cfg_get_str(name, "midi");
  if(!(val == ((char *)NULL)))
    c->midi=atoi(val);

  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "color");
    if(!(val == ((char *)NULL)))
      c->color=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "bright");
    if(!(val == ((char *)NULL)))
      c->bright=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "hue");
    if(!(val == ((char *)NULL)))
      c->hue=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "contrast");
    if(!(val == ((char *)NULL)))
      c->contrast=ng_attr_parse_int(attr, val);

  }

}

// init_overlay
// file common/commands.c line 202
void init_overlay(void)
{
  const char *tmp_if_expr_1;
  if(!(chantab == -1))
    tmp_if_expr_1 = (chanlist_names + (signed long int)chantab)->str;

  else
    tmp_if_expr_1 = "europe-west";
  do_va_cmd(2, (const void *)"setfreqtab", tmp_if_expr_1);
  cur_capture = -1;
  switch(defaults.capture)
  {
    case 9:

    case 1:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"overlay");
      break;
    }
    case 2:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"grabdisplay");
      break;
    }
    default:
      do_va_cmd(2, (const void *)"capture", (const void *)"off");
  }
}

// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab)
{
  signed int i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    if((tab + (signed long int)i)->nr == (signed long int)n)
      return (tab + (signed long int)i)->str;

  return (const char *)(void *)0;
}

// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv)
{
  signed int n;
  signed int return_value_atoi_1;
  return_value_atoi_1=atoi(argv[(signed long int)0]);
  n = return_value_atoi_1 % 10;
  char msg[8l];
  char ch[8l];
  if(!(debug == 0))
    fprintf(stderr, "keypad: key %d\n", n);

  if(keypad_state == -1)
  {
    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_partial == 0) || keypad_partial == 0 && (keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)))
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

    if((keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)) && n >= 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "keypad: hang: %d\n", n);

      keypad_state = n;
      if(!(display_message == ((void (*)(char *))NULL)))
      {
        sprintf(msg, "%d_", n);
        display_message(msg);
      }

    }

  }

  else
  {
    if((keypad_ntsc == 0 ? count : 99) >= 10 * keypad_state + n)
      n = n + keypad_state * 10;

    keypad_state = -1;
    if(!(debug == 0))
      fprintf(stderr, "keypad: ok: %d\n", n);

    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1)
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

  }
  return 0;
}

// keypad_timeout
// file common/commands.c line 1527
void keypad_timeout(void)
{
  if(!(debug == 0))
    fprintf(stderr, "keypad: timeout\n");

  if(keypad_state == 1 + cur_sender)
    set_title();

  keypad_state = -1;
}

// list_add_tail
// file libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_formats
// file console/streamer.c line 67
static void list_formats(struct _IO_FILE *out)
{
  struct list_head *item;
  struct ng_writer *wr;
  signed int j;
  fprintf(out, "\nmovie writers:\n");
  item = (&ng_writers)->next;
  for( ; !(item == &ng_writers); item = item->next)
  {
    wr = (struct ng_writer *)((char *)item - (signed long int)(unsigned long int)&((struct ng_writer *)0)->list);
    const char *tmp_if_expr_1;
    if(!(wr->desc == ((const char *)NULL)))
      tmp_if_expr_1 = wr->desc;

    else
      tmp_if_expr_1 = "-";
    fprintf(out, "  %s - %s\n", wr->name, tmp_if_expr_1);
    if(!(wr->video == ((struct ng_format_list *)NULL)))
    {
      fprintf(out, "    video formats:\n");
      j = 0;
      for( ; !((wr->video + (signed long int)j)->name == ((char *)NULL)); j = j + 1)
      {
        char *tmp_if_expr_2;
        if(!((wr->video + (signed long int)j)->desc == ((char *)NULL)))
          tmp_if_expr_2 = (wr->video + (signed long int)j)->desc;

        else
          tmp_if_expr_2 = ng_vfmt_to_desc[(signed long int)(wr->video + (signed long int)j)->fmtid];
        fprintf(out, "      %-7s %-28s [%s]\n", (wr->video + (signed long int)j)->name, tmp_if_expr_2, (wr->video + (signed long int)j)->ext);
      }
    }

    if(!(wr->audio == ((struct ng_format_list *)NULL)))
    {
      fprintf(out, "    audio formats:\n");
      j = 0;
      for( ; !((wr->audio + (signed long int)j)->name == ((char *)NULL)); j = j + 1)
      {
        char *tmp_if_expr_3;
        if(!((wr->audio + (signed long int)j)->desc == ((char *)NULL)))
          tmp_if_expr_3 = (wr->audio + (signed long int)j)->desc;

        else
          tmp_if_expr_3 = ng_afmt_to_desc[(signed long int)(wr->audio + (signed long int)j)->fmtid];
        char *tmp_if_expr_4;
        if(!((wr->audio + (signed long int)j)->ext == ((char *)NULL)))
          tmp_if_expr_4 = (wr->audio + (signed long int)j)->ext;

        else
          tmp_if_expr_4 = "-";
        fprintf(out, "      %-7s %-28s [%s]\n", (wr->audio + (signed long int)j)->name, tmp_if_expr_3, tmp_if_expr_4);
      }
    }

    fprintf(out, "\n");
  }
}

// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int i;
  printf("%-10.10s | type   | %-7.7s | %-7.7s | %s\n", (const void *)"attribute", (const void *)"current", (const void *)"default", (const void *)"comment");
  printf("-----------+--------+---------+---------+-------------------------------------\n");
  attr = attrs;
  const char *return_value_ng_attr_getstr_1;
  const char *return_value_ng_attr_getstr_2;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
  {
    val = cur_attrs[(signed long int)attr->id];
    switch(attr->type)
    {
      case 2:
      {
        return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
        return_value_ng_attr_getstr_2=ng_attr_getstr(attr, attr->defval);
        printf("%-10.10s | choice | %-7.7s | %-7.7s |", attr->name, return_value_ng_attr_getstr_1, return_value_ng_attr_getstr_2);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          printf(" %s", (attr->choices + (signed long int)i)->str);
        printf("\n");
        break;
      }
      case 1:
      {
        printf("%-10.10s | int    | %7d | %7d | range is %d => %d\n", attr->name, val, attr->defval, attr->min, attr->max);
        break;
      }
      case 3:
        printf("%-10.10s | bool   | %-7.7s | %-7.7s |\n", attr->name, val != 0 ? "on" : "off", attr->defval != 0 ? "on" : "off");
    }
  }
  return 0;
}

// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel)
{
  signed int i;
  signed int tmp_if_expr_1;
  signed int return_value_strcasecmp_3;
  if(channel == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(chantab == -1))
        tmp_if_expr_1 = (chanlists + (signed long int)chantab)->count;

      else
        tmp_if_expr_1 = 0;
      if(i >= tmp_if_expr_1)
        break;

      struct CHANLIST *tmp_if_expr_2;
      if(!(chantab == -1))
        tmp_if_expr_2 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr_2 = (struct CHANLIST *)(void *)0;
      return_value_strcasecmp_3=strcasecmp((tmp_if_expr_2 + (signed long int)i)->name, channel);
      if(return_value_strcasecmp_3 == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    signed int tmp_if_expr_4;
    if(!(chantab == -1))
      tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr_4 = 0;
    if(i == tmp_if_expr_4)
      return -1;

    else
      return i;
  }
}

// main
// file console/streamer.c line 328
signed int main(signed int argc, char **argv)
{
  signed int main__1__c;
  signed int queued = 0;
  signed int noaudio = 0;
  char *raw_length = (char *)(void *)0;
  ng_init();
  double return_value_atof_1;
  signed int return_value_sscanf_2;
  signed int return_value_atoi_3;
  do
  {
    main__1__c=getopt(argc, argv, "haqdp:w:o:c:f:r:s:t:n:i:b:j:D:O:C:F:R:");
    if(main__1__c == -1)
      break;

    switch(main__1__c)
    {
      case 113:
      {
        quiet = 1;
        break;
      }
      case 97:
      {
        noaudio = 1;
        break;
      }
      case 100:
      {
        debug = debug + 1;
        ng_debug = ng_debug + 1;
        break;
      }
      case 119:
      {
        wait_seconds=atoi(optarg);
        break;
      }
      case 112:
      {
        parallel=atoi(optarg);
        break;
      }
      case 111:
      {
        moviename = optarg;
        break;
      }
      case 102:
      {
        vfmt_name = optarg;
        break;
      }
      case 99:
      {
        ng_dev.video = optarg;
        break;
      }
      case 68:
      {
        ng_dev.driver = optarg;
        break;
      }
      case 114:
      {
        return_value_atof_1=atof(optarg);
        fps = (signed int)(return_value_atof_1 * (double)1000 + 0.5);
        break;
      }
      case 115:
      {
        return_value_sscanf_2=sscanf(optarg, "%dx%d", &video.width, &video.height);
        if(!(return_value_sscanf_2 == 2))
        {
          video.height = (unsigned int)0;
          video.width = video.height;
        }

        break;
      }
      case 116:
      {
        raw_length = optarg;
        break;
      }
      case 98:
      {
        bufcount=atoi(optarg);
        break;
      }
      case 106:
      {
        ng_jpeg_quality=atoi(optarg);
        break;
      }
      case 110:
      {
        tvnorm = optarg;
        break;
      }
      case 105:
      {
        input = optarg;
        break;
      }
      case 79:
      {
        audioname = optarg;
        break;
      }
      case 70:
      {
        afmt_name = optarg;
        break;
      }
      case 67:
      {
        ng_dev.dsp = optarg;
        break;
      }
      case 82:
      {
        return_value_atoi_3=atoi(optarg);
        audio.rate = (unsigned int)return_value_atoi_3;
        break;
      }
      case 104:
      {
        usage(stdout);
        exit(0);
      }
      default:
      {
        usage(stderr);
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(!(raw_length == ((char *)NULL)))
    absframes=parse_time(raw_length);

  find_formats();
  if(audio.fmtid == 0u && video.fmtid == 0u)
  {
    fprintf(stderr, "neither audio nor video format specified/found\n");
    exit(1);
  }

  if(writer == ((struct ng_writer *)NULL))
  {
    fprintf(stderr, "no output driver found\n");
    exit(1);
  }

  if(!(audio.fmtid == 0u))
  {
    if(writer->combined == 0)
    {
      if(audioname == ((char *)NULL))
      {
        fprintf(stderr, "no audio file name specified\n");
        exit(1);
      }

    }

  }

  rec_status = do_rec_status;
  if(quiet == 0 && !(writer == ((struct ng_writer *)NULL)))
    fprintf(stderr, "%s / video: %s / audio: %s\n", writer->name, ng_vfmt_to_desc[(signed long int)video.fmtid], ng_afmt_to_desc[(signed long int)audio.fmtid]);

  if(!(video.fmtid == 0u))
  {
    drv=ng_vid_open(&ng_dev.video, ng_dev.driver, (struct ng_video_fmt *)(void *)0, NULL, &h_drv);
    if(drv == ((struct ng_vid_driver *)NULL))
    {
      fprintf(stderr, "no grabber device available\n");
      exit(1);
    }

    f_drv=drv->capabilities(h_drv);
    struct ng_attribute *return_value;
    return_value=drv->list_attrs(h_drv);
    add_attrs(return_value);
    if((2 & f_drv) == 0)
    {
      fprintf(stderr, "%s: capture not supported\n", drv->name);
      exit(1);
    }

    if(noaudio == 0)
      audio_on();

    audio_init();
    if(!(input == ((char *)NULL)))
      do_va_cmd(2, (const void *)"setinput", input);

    if(!(tvnorm == ((char *)NULL)))
      do_va_cmd(2, (const void *)"setnorm", tvnorm);

  }

  ng_ratio_x = (signed int)video.width;
  ng_ratio_y = (signed int)video.height;
  struct movie_handle *return_value_movie_writer_init_4;
  return_value_movie_writer_init_4=movie_writer_init(moviename, audioname, writer, &video, video_priv, fps, &audio, audio_priv, ng_dev.dsp, bufcount, parallel);
  movie_state = (void *)return_value_movie_writer_init_4;
  if(movie_state == NULL)
  {
    fprintf(stderr, "movie writer initialisation failed\n");
    if(!(video.fmtid == 0u))
    {
      audio_off();
      drv->close(h_drv);
    }

    exit(1);
  }

  signal(2, ctrlc);
  if(!(wait_seconds == 0))
    sleep((unsigned int)wait_seconds);

  movie_writer_start((struct movie_handle *)movie_state);
  while(signaled == 0 && !(queued >= absframes))
    if(!(video.fmtid == 0u))
      queued=movie_grab_put_video((struct movie_handle *)movie_state, (struct ng_video_buf **)(void *)0);

    else
    {
      sleep((unsigned int)1);
      queued = queued + fps / 1000;
    }
  movie_writer_stop((struct movie_handle *)movie_state);
  if(!(video.fmtid == 0u))
  {
    if(noaudio == 0)
      audio_off();

    drv->close(h_drv);
  }

  return 0;
}

// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type)
{
  switch((signed int)type)
  {
    case MEDIA_V4L_VIDEO:
      return "video";
    case MEDIA_V4L_VBI:
      return "vbi";
    case MEDIA_V4L_RADIO:
      return "radio";
    case MEDIA_V4L_SUBDEV:
      return "v4l subdevice";
    case MEDIA_DVB_VIDEO:
      return "dvb video";
    case MEDIA_DVB_AUDIO:
      return "dvb audio";
    case MEDIA_DVB_SEC:
      return "dvb sec";
    case MEDIA_DVB_FRONTEND:
      return "dvb frontend";
    case MEDIA_DVB_DEMUX:
      return "dvb demux";
    case MEDIA_DVB_DVR:
      return "dvb dvr";
    case MEDIA_DVB_NET:
      return "dvb net";
    case MEDIA_DVB_CA:
      return "dvb conditional access";
    case MEDIA_DVB_OSD:
      return "dvb OSD";
    case MEDIA_SND_CARD:
      return "sound card";
    case MEDIA_SND_CAP:
      return "pcm capture";
    case MEDIA_SND_OUT:
      return "pcm output";
    case MEDIA_SND_CONTROL:
      return "mixer";
    case MEDIA_SND_HW:
      return "sound hardware";
    case MEDIA_SND_TIMER:
      return "sound timer";
    case MEDIA_SND_SEQ:
      return "sound sequencer";
    default:
      return "unknown";
  }
}

// movie_grab_put_video
// file ./common/capture.h line 36
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret)
{
  struct ng_video_buf *buf;
  signed int expected;
  signed int rc;
  if(debug >= 2)
    fprintf(stderr, "grab_put_video\n");

  buf=ng_grabber_grab_image(0);
  if(buf == ((struct ng_video_buf *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "grab_put_video: grab image failed\n");

    return -1;
  }

  else
  {
    expected = (signed int)((((unsigned long int)buf->info.ts - h->vdrift) * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL);
    if(!(expected >= h->frames + -1))
    {
      if(debug >= 2)
        fprintf(stderr, "rate: ignoring frame [%d %d]\n", expected, h->frames);

      ng_release_video_buf(buf);
      return 0;
    }

    else
    {
      if(!(1 + h->frames >= expected))
      {
        fprintf(stderr, "rate: queueing frame twice (%d)\n", expected - h->frames);
        buf->info.twice = buf->info.twice + 1;
        h->frames = h->frames + 1;
      }

      h->frames = h->frames + 1;
      h->vts = (unsigned long int)buf->info.ts;
      buf->info.seq = h->seq;
      if(!(ret == ((struct ng_video_buf **)NULL)))
      {
        buf->refcount = buf->refcount + 1;
        *ret = buf;
      }

      if(!(h->cthreads == 0))
        rc=fifo_put(&h->cfifo, (void *)buf);

      else
        rc=fifo_put(&h->vfifo, (void *)buf);
      if(!(rc == 0))
      {
        ng_release_video_buf(buf);
        return h->frames;
      }

      else
      {
        h->seq = h->seq + 1;
        movie_print_timestamps(h);
        return h->frames;
      }
    }
  }
}

// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv)
{
  if(movie_hook == ((void (*)(signed int, char **))NULL))
    return 0;

  else
  {
    movie_hook(argc, argv);
    return 0;
  }
}

// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h)
{
  char line[128l];
  if(!(rec_status == ((void (*)(char *))NULL)))
  {
    signed int return_value_abs_1;
    return_value_abs_1=abs((signed int)h->rdrift);
    signed int return_value_abs_2;
    return_value_abs_2=abs((signed int)h->rdrift);
    signed int return_value_abs_3;
    return_value_abs_3=abs((signed int)h->vdrift);
    signed int return_value_abs_4;
    return_value_abs_4=abs((signed int)h->vdrift);
    sprintf(line, "rec %d:%02d.%02d  -  a/r: %c%d.%02ds [%d], a/v: %c%d.%02ds [%d]", (signed int)((h->rts / (unsigned long int)1000000000) / (unsigned long int)60), (signed int)((h->rts / (unsigned long int)1000000000) % (unsigned long int)60), (signed int)((h->rts % (unsigned long int)1000000000) / (unsigned long int)10000000), h->rdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_1 / 1000000000), (signed int)((return_value_abs_2 % 1000000000) / 10000000), (signed int)((h->rdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL), h->vdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs_3 / 1000000000), (signed int)((return_value_abs_4 % 1000000000) / 10000000), (signed int)((h->vdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL));
    rec_status(line);
  }

}

// movie_writer_init
// file ./common/capture.h line 28
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads)
{
  struct movie_handle *h;
  struct ng_video_conv *conv;
  void *dummy;
  signed int i;
  if(!(debug == 0))
    fprintf(stderr, "movie_init_writer start\n");

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct movie_handle) /*2184ul*/ );
  h = (struct movie_handle *)return_value_malloc_1;
  if(h == ((struct movie_handle *)NULL))
    return (struct movie_handle *)(void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct movie_handle) /*2184ul*/ );
    pthread_mutex_init(&h->lock, (const union anonymous_8 *)(void *)0);
    h->writer = writer;
    h->slots = slots;
    if(!(audio->fmtid == 0u))
    {
      h->dsp=ng_dsp_open(dsp, audio, 1, &h->hdsp);
      if(h->dsp == ((struct ng_dsp_driver *)NULL))
      {
        free((void *)h);
        return (struct movie_handle *)(void *)0;
      }

      fifo_init(&h->afifo, "audio", slots, 1);
      pthread_create(&h->taudio, (const union pthread_attr_t *)(void *)0, writer_audio_thread, (void *)h);
      h->bytes_per_sec = (unsigned long int)((ng_afmt_to_bits[(signed long int)audio->fmtid] * ng_afmt_to_channels[(signed long int)audio->fmtid] * audio->rate) / (unsigned int)8);
      h->afmt = *audio;
    }

    if(!(video->fmtid == 0u))
    {
      signed int return_value_ng_grabber_setformat_3;
      return_value_ng_grabber_setformat_3=ng_grabber_setformat(video, 1);
      if(return_value_ng_grabber_setformat_3 == 0)
      {
        fifo_init(&h->vfifo, "video", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
      }

      else
      {
        struct ng_video_fmt gfmt = *video;
        conv=ng_grabber_findconv(&gfmt, 1);
        if(conv == ((struct ng_video_conv *)NULL))
        {
          if(!(h->afmt.fmtid == 0u))
            h->dsp->close(h->hdsp);

          free((void *)h);
          return (struct movie_handle *)(void *)0;
        }

        h->cthreads = threads;
        if(!(h->cthreads >= 1))
          h->cthreads = 1;

        if(h->cthreads >= 5)
          h->cthreads = 4;

        fifo_init(&h->vfifo, "video", slots, h->cthreads);
        fifo_init(&h->cfifo, "conv", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
        i = 0;
        for( ; !(i >= h->cthreads); i = i + 1)
        {
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i] = (struct ng_convthread_handle *)return_value_malloc_2;
          memset((void *)h->hconv[(signed long int)i], 0, sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i]->c=ng_convert_alloc(conv, &gfmt, video);
          h->hconv[(signed long int)i]->in = &h->cfifo;
          h->hconv[(signed long int)i]->out = &h->vfifo;
          pthread_create(&h->tconv[(signed long int)i], (const union pthread_attr_t *)(void *)0, ng_convert_thread, (void *)h->hconv[(signed long int)i]);
        }
      }
      h->vfmt = *video;
      h->fps = fps;
    }

    h->handle=writer->wr_open(moviename, audioname, video, priv_video, fps, audio, priv_audio);
    if(!(debug == 0))
      fprintf(stderr, "movie_init_writer end (h=%p)\n", h->handle);

    if(!(h->handle == NULL))
      return h;

    else
    {
      if(!(h->afmt.fmtid == 0u))
      {
        pthread_cancel(h->taudio);
        pthread_join(h->taudio, &dummy);
        h->dsp->close(h->hdsp);
      }

      if(!(h->vfmt.fmtid == 0u))
      {
        pthread_cancel(h->tvideo);
        pthread_join(h->tvideo, &dummy);
      }

      i = 0;
      if(!(i >= h->cthreads))
      {
        pthread_cancel(h->tconv[(signed long int)i]);
        pthread_join(h->tconv[(signed long int)i], &dummy);
        i = i + 1;
      }

      free((void *)h);
      return (struct movie_handle *)(void *)0;
    }
  }
}

// movie_writer_start
// file ./common/capture.h line 33
signed int movie_writer_start(struct movie_handle *h)
{
  signed int rc = 0;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_start\n");

  signed long int return_value_ng_get_timestamp_1;
  return_value_ng_get_timestamp_1=ng_get_timestamp();
  h->start = (unsigned long int)return_value_ng_get_timestamp_1;
  signed int return_value;
  if(!(h->afmt.fmtid == 0u))
  {
    return_value=h->dsp->startrec(h->hdsp);
    if(!(return_value == 0))
      rc = -1;

  }

  signed int return_value_1;
  if(!(h->vfmt.fmtid == 0u))
  {
    return_value_1=drv->startvideo(h_drv, h->fps, (unsigned int)h->slots);
    if(!(return_value_1 == 0))
      rc = -1;

  }

  if(!(h->afmt.fmtid == 0u))
    pthread_create(&h->raudio, (const union pthread_attr_t *)(void *)0, record_audio_thread, (void *)h);

  pthread_create(&h->tflush, (const union pthread_attr_t *)(void *)0, flushit, (void *)0);
  return rc;
}

// movie_writer_stop
// file ./common/capture.h line 34
signed int movie_writer_stop(struct movie_handle *h)
{
  char line[128l];
  unsigned long int stopby;
  signed int frames;
  signed int i;
  void *dummy;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_stop\n");

  _Bool tmp_if_expr_1;
  if(!(h->vfmt.fmtid == 0u))
    tmp_if_expr_1 = h->afmt.fmtid != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    frames = 0;
    for( ; !(frames >= 16); frames = frames + 1)
    {
      stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
      if(!(h->ats >= stopby))
        break;

    }
    frames = frames + 1;
    h->stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
    for( ; !(frames == 0); frames = frames - 1)
      movie_grab_put_video(h, (struct ng_video_buf **)(void *)0);
  }

  else
    if(!(h->afmt.fmtid == 0u))
      h->stopby = h->ats;

  if(!(h->cthreads == 0))
    fifo_put(&h->cfifo, (void *)0);

  else
    fifo_put(&h->vfifo, (void *)0);
  if(!(h->afmt.fmtid == 0u))
  {
    pthread_join(h->raudio, &dummy);
    pthread_join(h->taudio, &dummy);
  }

  if(!(h->vfmt.fmtid == 0u))
    pthread_join(h->tvideo, &dummy);

  i = 0;
  for( ; !(i >= h->cthreads); i = i + 1)
    pthread_join(h->tconv[(signed long int)i], &dummy);
  pthread_cancel(h->tflush);
  pthread_join(h->tflush, &dummy);
  h->writer->wr_close(h->handle);
  if(!(h->afmt.fmtid == 0u))
    h->dsp->close(h->hdsp);

  if(!(h->vfmt.fmtid == 0u))
    drv->stopvideo(h_drv);

  sprintf(line, "fifo max fill: audio %d/%d, video %d/%d, convert %d/%d", h->afifo.max, h->afifo.slots, h->vfifo.max, h->vfifo.slots, h->cfifo.max, h->cfifo.slots);
  rec_status(line);
  free((void *)h);
  return 0;
}

// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv)
{
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(argv[(signed long int)0]);

  return 0;
}

// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "audio converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail(&(list + (signed long int)n)->list, &ng_aconv);
    return 0;
  }
}

// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    for( ; (_Bool)1; attrs = attrs + 1l)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      if(attrs->id == id)
        return attrs;

    }
}

// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    while((_Bool)1)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(attrs->name, name);
      if(return_value_strcasecmp_1 == 0)
        return attrs;

      attrs = attrs + 1l;
    }
}

// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value)
{
  signed int i;
  signed int val;
  if(attr == ((struct ng_attribute *)NULL))
    return -1;

  else
    if(!(attr->type == 2))
      return -1;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp((attr->choices + (signed long int)i)->str, value);
        if(return_value_strcasecmp_1 == 0)
          return (signed int)(attr->choices + (signed long int)i)->nr;

      }
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*value]) == 0))
      {
        val=atoi(value);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          if((signed long int)val == (attr->choices + (signed long int)i)->nr)
            return (signed int)(attr->choices + (signed long int)i)->nr;

      }

      return -1;
    }
}

// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value)
{
  signed int i;
  if(attr == ((struct ng_attribute *)NULL))
    return (const char *)(void *)0;

  else
    if(!(attr->type == 2))
      return (const char *)(void *)0;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
        if((attr->choices + (signed long int)i)->nr == (signed long int)value)
          return (attr->choices + (signed long int)i)->str;

      return (const char *)(void *)0;
    }
}

// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value)
{
  signed int range;
  signed int percent;
  range = attr->max - attr->min;
  percent = ((value - attr->min) * 100) / range;
  if(!(percent >= 0))
    percent = 0;

  if(percent >= 101)
    percent = 100;

  return percent;
}

// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr)
{
  signed int i;
  fprintf(stderr, "valid choices for \"%s\": ", attr->name);
  i = 0;
  for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s\"%s\"", i != 0 ? ", " : "", (attr->choices + (signed long int)i)->str);
  fprintf(stderr, "\n");
}

// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str)
{
  signed int value;
  signed int n;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(str, "%d%n", &value, &n);
  if(return_value_sscanf_1 == 0)
    return attr->defval;

  else
  {
    if((signed int)str[(signed long int)n] == 37)
      value=ng_attr_percent2int(attr, value);

    if(!(value >= attr->min))
      value = attr->min;

    if(!(attr->max >= value))
      value = attr->max;

    return value;
  }
}

// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent)
{
  signed int range;
  signed int value;
  range = attr->max - attr->min;
  value = (percent * range) / 100 + attr->min;
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count)
{
  signed int i;
  signed int j;
  if(ng_debug >= 2)
  {
    fprintf(stderr, "clip: win=%dx%d xa=%d ya=%d\n", width, height, xadjust, yadjust);
    clip_dump("init", oc, *count);
  }

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    (oc + (signed long int)i)->x1 = (oc + (signed long int)i)->x1 + xadjust;
    (oc + (signed long int)i)->x2 = (oc + (signed long int)i)->x2 + xadjust;
    (oc + (signed long int)i)->y1 = (oc + (signed long int)i)->y1 + yadjust;
    (oc + (signed long int)i)->y2 = (oc + (signed long int)i)->y2 + yadjust;
  }
  if(ng_debug >= 2)
    clip_dump("fixup adjust", oc, *count);

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    if(!((oc + (signed long int)i)->x1 >= 0))
      (oc + (signed long int)i)->x1 = 0;

    if(!((oc + (signed long int)i)->x2 >= 0))
      (oc + (signed long int)i)->x2 = 0;

    if(!(width >= (oc + (signed long int)i)->x1))
      (oc + (signed long int)i)->x1 = width;

    if(!(width >= (oc + (signed long int)i)->x2))
      (oc + (signed long int)i)->x2 = width;

    if(!((oc + (signed long int)i)->y1 >= 0))
      (oc + (signed long int)i)->y1 = 0;

    if(!((oc + (signed long int)i)->y2 >= 0))
      (oc + (signed long int)i)->y2 = 0;

    if(!(height >= (oc + (signed long int)i)->y1))
      (oc + (signed long int)i)->y1 = height;

    if(!(height >= (oc + (signed long int)i)->y2))
      (oc + (signed long int)i)->y2 = height;

  }
  if(ng_debug >= 2)
    clip_dump("fixup range", oc, *count);

  i = 0;
  while(!(i >= *count))
  {
    _Bool tmp_if_expr_1;
    if((oc + (signed long int)i)->x1 == (oc + (signed long int)i)->x2)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (oc + (signed long int)i)->y1 == (oc + (signed long int)i)->y2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      clip_drop(oc, i, count);

    else
      i = i + 1;
  }
  if(ng_debug >= 2)
    clip_dump("zerosize done", oc, *count);

  do
  {

  restart_merge:
    ;
    j = *count - 1;

  __CPROVER_DUMP_L23:
    ;
    if(!(j >= 0))
      goto __CPROVER_DUMP_L34;

    i = 0;

  __CPROVER_DUMP_L24:
    ;
    if(i >= *count)
      goto __CPROVER_DUMP_L33;

    if(i == j)
      break;

    if((oc + (signed long int)i)->x1 == (oc + (signed long int)j)->x1)
    {
      if((oc + (signed long int)i)->x2 == (oc + (signed long int)j)->x2)
      {
        if((oc + (signed long int)j)->y1 >= (oc + (signed long int)i)->y1)
        {
          if((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y1)
          {
            if(ng_debug >= 2)
              fprintf(stderr, "clip: merge y %d,%d\n", i, j);

            if(!((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y2))
              (oc + (signed long int)i)->y2 = (oc + (signed long int)j)->y2;

            clip_drop(oc, j, count);
            if(ng_debug >= 2)
              clip_dump("merge y done", oc, *count);

            goto restart_merge;
          }

        }

      }

    }

    if(!((oc + (signed long int)i)->y1 == (oc + (signed long int)j)->y1))
      break;

    if(!((oc + (signed long int)i)->y2 == (oc + (signed long int)j)->y2))
      break;

    if(!((oc + (signed long int)j)->x1 >= (oc + (signed long int)i)->x1))
      break;

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x1))
      break;

    if(ng_debug >= 2)
      fprintf(stderr, "clip: merge x %d,%d\n", i, j);

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x2))
      (oc + (signed long int)i)->x2 = (oc + (signed long int)j)->x2;

    clip_drop(oc, j, count);
    if(ng_debug >= 2)
      clip_dump("merge x done", oc, *count);

  }
  while((_Bool)1);
  i = i + 1;
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L33:
  ;
  j = j - 1;
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L34:
  ;
  if(!(ng_debug == 0))
    clip_dump("final", oc, *count);

}

// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type)
{
  if(!(magic == 0x20030129))
  {
    fprintf(stderr, "ERROR: plugin magic mismatch [xawtv=%d,%s=%d]\n", 0x20030129, plugname, magic);
    return -1;
  }

  else
    return 0;
}

// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void)
{
  ng_conv_register(0x20030129, "built-in", conv_list, nconv);
}

// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    ng_yuv_gray[(signed long int)i] = (unsigned int)(i * 256 >> 8);
    ng_yuv_red[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_blue[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_g1[(signed long int)i] = (unsigned int)(-(-128 * 512) / 2 + i * (-512 / 2) >> 8);
    ng_yuv_g2[(signed long int)i] = (unsigned int)(-(-128 * 512) / 6 + i * (-512 / 6) >> 8);
  }
  i = 0;
  for( ; !(i >= 320); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)0;
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)(i - 320);
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)255;
  ng_conv_register(0x20030129, "built-in", conv_list_link1, nconv_link1);
}

// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_in == in)
      {
        *i = *i + 1;
        return ret;
      }

    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out)
{
  struct list_head *item;
  struct ng_video_conv *ret = (struct ng_video_conv *)(void *)0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
  {
    ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
    if(ret->fmtid_in == in)
    {
      if(ret->fmtid_out == out)
        return ret;

    }

  }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_out == out)
      {
        *i = *i + 1;
        return ret;
      }

      *i = *i + 1;
      j = j + 1;
    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle)
{
  ;
}

// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv)
{
  return (void *)0;
}

// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video converters");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail(&(list + (signed long int)n)->list, &ng_conv);
    return 0;
  }
}

// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o)
{
  struct ng_convert_handle *h;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_convert_handle) /*56ul*/ );
  h = (struct ng_convert_handle *)return_value_malloc_1;
  if(h == ((struct ng_convert_handle *)NULL))
    return ((struct ng_convert_handle *)NULL);

  else
  {
    memset((void *)h, 0, sizeof(struct ng_convert_handle) /*56ul*/ );
    o->width = i->width;
    o->height = i->height;
    if(o->bytesperline == 0u)
      o->bytesperline = (o->width * ng_vfmt_to_depth[(signed long int)o->fmtid]) / (unsigned int)8;

    h->ifmt = *i;
    h->ofmt = *o;
    if(!(conv == ((struct ng_video_conv *)NULL)))
      h->conv = conv;

    return h;
  }
}

// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src)
{
  unsigned int i;
  unsigned int sw;
  unsigned int dw;
  unsigned char *sp;
  unsigned char *dp;
  dw = (dest->fmt.width * ng_vfmt_to_depth[(signed long int)dest->fmt.fmtid]) / (unsigned int)8;
  sw = (src->fmt.width * ng_vfmt_to_depth[(signed long int)src->fmt.fmtid]) / (unsigned int)8;
  _Bool tmp_if_expr_1;
  if(src->fmt.bytesperline == sw)
    tmp_if_expr_1 = dest->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    memcpy((void *)dest->data, (const void *)src->data, (unsigned long int)(src->fmt.bytesperline * src->fmt.height));

  else
  {
    dp = dest->data;
    sp = src->data;
    i = (unsigned int)0;
    for( ; !(i >= src->fmt.height); i = i + 1u)
    {
      memcpy((void *)dp, (const void *)sp, (unsigned long int)dw);
      dp = dp + (signed long int)dest->fmt.bytesperline;
      sp = sp + (signed long int)src->fmt.bytesperline;
    }
  }
}

// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h)
{
  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->conv->fini(h->chandle);

  free((void *)h);
}

// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf)
{
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    if(dest == ((struct ng_video_buf *)NULL))
    {
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        dest=ng_malloc_video_buf(&h->ofmt, h->osize);

    }

    if(!(dest == ((struct ng_video_buf *)NULL)))
    {
      dest->fmt = h->ofmt;
      dest->size = (unsigned long int)h->osize;
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        h->conv->frame(h->chandle, dest, buf);

      else
        ng_convert_copyframe(dest, buf);
      dest->info = buf->info;
      ng_release_video_buf(buf);
      buf = dest;
    }

    return buf;
  }
}

// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h)
{
  if(h->ifmt.bytesperline == 0u)
    h->ifmt.bytesperline = (h->ifmt.width * ng_vfmt_to_depth[(signed long int)h->ifmt.fmtid]) / (unsigned int)8;

  if(h->ofmt.bytesperline == 0u)
    h->ofmt.bytesperline = (h->ofmt.width * ng_vfmt_to_depth[(signed long int)h->ofmt.fmtid]) / (unsigned int)8;

  h->isize = (signed int)(h->ifmt.height * h->ifmt.bytesperline);
  if(h->isize == 0)
    h->isize = (signed int)(h->ifmt.width * h->ifmt.height * (unsigned int)3);

  h->osize = (signed int)(h->ofmt.height * h->ofmt.bytesperline);
  if(h->osize == 0)
    h->osize = (signed int)(h->ofmt.width * h->ofmt.height * (unsigned int)3);

  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->chandle=h->conv->init(&h->ofmt, h->conv->priv);

  if(!(ng_debug == 0))
  {
    fprintf(stderr, "convert-in : %dx%d %s (size=%d)\n", h->ifmt.width, h->ifmt.height, ng_vfmt_to_desc[(signed long int)h->ifmt.fmtid], h->isize);
    fprintf(stderr, "convert-out: %dx%d %s (size=%d)\n", h->ofmt.width, h->ofmt.height, ng_vfmt_to_desc[(signed long int)h->ofmt.fmtid], h->osize);
  }

}

// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in)
{
  struct ng_video_buf *out;
  ng_convert_init(h);
  out=ng_convert_frame(h, (struct ng_video_buf *)(void *)0, in);
  ng_convert_fini(h);
  return out;
}

// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg)
{
  struct ng_convthread_handle *h = (struct ng_convthread_handle *)arg;
  struct ng_video_buf *in;
  struct ng_video_buf *out;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "convert_thread start [pid=%d]\n", return_value_getpid_1);
  }

  ng_convert_init(h->c);
  signed int return_value_webcam_put_3;
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(h->in);
    in = (struct ng_video_buf *)return_value_fifo_get_2;
    if(in == ((struct ng_video_buf *)NULL))
      break;

    out=ng_convert_frame(h->c, (struct ng_video_buf *)(void *)0, in);
    if(!(webcam == ((char *)NULL)))
    {
      return_value_webcam_put_3=webcam_put(webcam, out);
      if(return_value_webcam_put_3 == 0)
      {
        free((void *)webcam);
        webcam = (char *)(void *)0;
      }

    }

    fifo_put(h->out, (void *)out);
  }
  while((_Bool)1);
  fifo_put(h->out, (void *)0);
  ng_convert_fini(h->c);
  signed int return_value_getpid_4;
  if(!(debug == 0))
  {
    return_value_getpid_4=getpid();
    fprintf(stderr, "convert_thread done [pid=%d]\n", return_value_getpid_4);
  }

  return (void *)0;
}

// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void)
{
  struct stat st;
  signed int return_value_lstat_1;
  return_value_lstat_1=lstat("/dev/.devfsd", &st);
  if(!(return_value_lstat_1 == -1))
  {
    if((61440u & st.st_mode) == 8192u)
      ng_dev = ng_dev_devfs;

  }

}

// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "dsp drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_dsp_drivers);
    return 0;
  }
}

// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle)
{
  struct list_head *item;
  struct ng_dsp_driver *ng_dsp_open__1__drv;
  item = (&ng_dsp_drivers)->next;
  for( ; !(item == &ng_dsp_drivers); item = item->next)
  {
    ng_dsp_open__1__drv = (struct ng_dsp_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_dsp_driver *)0)->list);
    if(!(ng_dsp_open__1__drv->name == ((const char *)NULL)))
    {
      if(!(record == 0))
      {
        if(ng_dsp_open__1__drv->read == ((struct ng_audio_buf * (*)(void *, signed long int))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(record == 0)
      {
        if(ng_dsp_open__1__drv->write == ((struct ng_audio_buf * (*)(void *, struct ng_audio_buf *))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: trying: %s... \n", ng_dsp_open__1__drv->name);

      *handle=ng_dsp_open__1__drv->open(device, fmt, record);
      if(!(*handle == NULL))
        break;

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: failed: %s\n", ng_dsp_open__1__drv->name);

    }


  __CPROVER_DUMP_L5:
    ;
  }
  if(item == &ng_dsp_drivers)
    return (struct ng_dsp_driver *)(void *)0;

  else
  {
    if(!(ng_debug == 0))
      fprintf(stderr, "dsp-open: ok: %s\n", ng_dsp_open__1__drv->name);

    return ng_dsp_open__1__drv;
  }
}

// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "filter");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&filter->list, &ng_filters);
    return 0;
  }
}

// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in)
{
  struct ng_video_buf *out = in;
  void *handle;
  if(!(filter == ((struct ng_filter *)NULL)))
  {
    if(!((filter->fmts & 1 << in->fmt.fmtid) == 0))
    {
      handle=filter->init(&in->fmt);
      out=filter->frame(handle, in);
      filter->fini(handle);
    }

  }

  return out;
}

// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename)
{
  struct list_head *item;
  struct ng_reader *reader;
  char blk[512l];
  struct _IO_FILE *fp;
  signed int m;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "open %s: %s\n", filename, return_value_strerror_2);
    return (struct ng_reader *)(void *)0;
  }

  memset((void *)blk, 0, sizeof(char [512l]) /*512ul*/ );
  fread((void *)blk, (unsigned long int)1, sizeof(char [512l]) /*512ul*/ , fp);
  fclose(fp);
  item = (&ng_readers)->next;
  _Bool tmp_if_expr_3;
  for( ; !(item == &ng_readers); item = item->next)
  {
    reader = (struct ng_reader *)((char *)item - (signed long int)(unsigned long int)&((struct ng_reader *)0)->list);
    m = 0;
    do
    {
      if(!(m >= 4))
        tmp_if_expr_3 = reader->mlen[(signed long int)m] > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      signed int return_value_memcmp_4;
      return_value_memcmp_4=memcmp((const void *)(blk + (signed long int)reader->moff[(signed long int)m]), (const void *)reader->magic[(signed long int)m], (unsigned long int)reader->mlen[(signed long int)m]);
      if(return_value_memcmp_4 == 0)
        return reader;

      m = m + 1;
    }
    while((_Bool)1);
  }
  if(!(ng_debug == 0))
    fprintf(stderr, "%s: no reader found\n", filename);

  return (struct ng_reader *)(void *)0;
}

// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf)
{
  free((void *)buf->data);
  free((void *)buf);
}

// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  signed long int return_value_ng_tofday_to_timestamp_1;
  return_value_ng_tofday_to_timestamp_1=ng_tofday_to_timestamp(&tv);
  return return_value_ng_tofday_to_timestamp_1;
}

// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  signed int i = 0;
  do
  {
    conv=ng_conv_find_to(fmt->fmtid, &i);
    if(conv == ((struct ng_video_conv *)NULL))
      break;

    gfmt = *fmt;
    gfmt.fmtid = conv->fmtid_in;
    signed int return_value_ng_grabber_setformat_1;
    return_value_ng_grabber_setformat_1=ng_grabber_setformat(&gfmt, fix_ratio);
    if(return_value_ng_grabber_setformat_1 == 0)
      goto found;

  }
  while((_Bool)1);
  fprintf(stderr, "no way to get: %dx%d %s\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);
  return (struct ng_video_conv *)(void *)0;

found:
  ;
  *fmt = gfmt;
  return conv;
}

// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  struct ng_convert_handle *ch;
  struct ng_video_buf *buf;
  signed int return_value_ng_grabber_setformat_2;
  return_value_ng_grabber_setformat_2=ng_grabber_setformat(fmt, 1);
  struct ng_video_buf *return_value_ng_grabber_grab_image_1;
  if(return_value_ng_grabber_setformat_2 == 0)
  {
    return_value_ng_grabber_grab_image_1=ng_grabber_grab_image(1);
    return return_value_ng_grabber_grab_image_1;
  }

  gfmt = *fmt;
  conv=ng_grabber_findconv(&gfmt, 1);
  if(conv == ((struct ng_video_conv *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ch=ng_convert_alloc(conv, &gfmt, fmt);
    buf=ng_grabber_grab_image(1);
    if(buf == ((struct ng_video_buf *)NULL))
      return (struct ng_video_buf *)(void *)0;

    else
    {
      buf=ng_convert_single(ch, buf);
      return buf;
    }
  }
}

// ng_grabber_grab_image
// file common/capture.c line 226
struct ng_video_buf * ng_grabber_grab_image(signed int single)
{
  struct ng_video_buf *tmp_if_expr_1;
  struct ng_video_buf *return_value;
  struct ng_video_buf *return_value_1;
  if(!(single == 0))
  {
    return_value=drv->getimage(h_drv);
    tmp_if_expr_1 = return_value;
  }

  else
  {
    return_value_1=drv->nextframe(h_drv);
    tmp_if_expr_1 = return_value_1;
  }
  return tmp_if_expr_1;
}

// ng_grabber_setformat
// file common/capture.c line 163
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  signed int rc;
  if((2 & f_drv) == 0)
    return -1;

  else
  {
    gfmt = *fmt;
    rc=drv->setformat(h_drv, &gfmt);
    if(!(debug == 0))
      fprintf(stderr, "setformat: %s (%dx%d): %s\n", ng_vfmt_to_desc[(signed long int)gfmt.fmtid], gfmt.width, gfmt.height, 0 == rc ? "ok" : "failed");

    if(!(rc == 0))
      return -1;

    else
    {
      if(!(fix_ratio == 0))
      {
        ng_ratio_fixup((signed int *)&gfmt.width, (signed int *)&gfmt.height, (signed int *)(void *)0, (signed int *)(void *)0);
        gfmt.bytesperline = (unsigned int)0;
        signed int return_value;
        return_value=drv->setformat(h_drv, &gfmt);
        if(!(return_value == 0))
        {
          fprintf(stderr, "Oops: ratio size renegotiation failed\n");
          exit(1);
        }

      }

      *fmt = gfmt;
      return 0;
    }
  }
}

// ng_init
// file ./libng/grab-ng.h line 466
void ng_init(void)
{
  signed int ng_init__1__count = 0;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_init called twice\n");
    exit(1);
  }

  ng_device_init();
  ng_color_packed_init();
  ng_color_yuv2rgb_init();
  ng_writefile_init();
  signed int return_value_ng_plugins_2;
  return_value_ng_plugins_2=ng_plugins("/usr/lib/x86_64-linux-gnu/xawtv");
  ng_init__1__count = ng_init__1__count + return_value_ng_plugins_2;
  if(ng_init__1__count == 0)
  {
    signed int return_value_ng_plugins_3;
    return_value_ng_plugins_3=ng_plugins("../libng/plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_3;
    signed int return_value_ng_plugins_4;
    return_value_ng_plugins_4=ng_plugins("../libng/contrib-plugins");
    ng_init__1__count = ng_init__1__count + return_value_ng_plugins_4;
  }

  if(ng_init__1__count == 0)
    fprintf(stderr, "WARNING: no plugins found [%s]\n", (const void *)"/usr/lib/x86_64-linux-gnu/xawtv");

}

// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf)
{
  memset((void *)buf, 0, sizeof(struct ng_video_buf) /*160ul*/ );
  pthread_mutex_init(&buf->lock, (const union anonymous_8 *)(void *)0);
  pthread_cond_init(&buf->cond, (const union anonymous_8 *)(void *)0);
}

// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap)
{
  signed int rgb_red_bits = 0;
  signed int rgb_red_shift = 0;
  signed int rgb_green_bits = 0;
  signed int rgb_green_shift = 0;
  signed int rgb_blue_bits = 0;
  signed int rgb_blue_shift = 0;
  unsigned int i;
  unsigned int mask;
  static signed int once = 0;
  signed int tmp_post_1 = once;
  once = once + 1;
  if(!(tmp_post_1 == 0))
  {
    fprintf(stderr, "panic: ng_lut_init called twice\n");
    exit(1);
  }

  i = (unsigned int)0;
  for( ; !(i >= 32u); i = i + 1u)
  {
    mask = (unsigned int)(1 << i);
    if(!((red_mask & (unsigned long int)mask) == 0ul))
      rgb_red_bits = rgb_red_bits + 1;

    else
      if(rgb_red_bits == 0)
        rgb_red_shift = rgb_red_shift + 1;

    if(!((green_mask & (unsigned long int)mask) == 0ul))
      rgb_green_bits = rgb_green_bits + 1;

    else
      if(rgb_green_bits == 0)
        rgb_green_shift = rgb_green_shift + 1;

    if(!((blue_mask & (unsigned long int)mask) == 0ul))
      rgb_blue_bits = rgb_blue_bits + 1;

    else
      if(rgb_blue_bits == 0)
        rgb_blue_shift = rgb_blue_shift + 1;

  }
  if(rgb_red_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)(i << (rgb_red_bits + rgb_red_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_red_bits) << rgb_red_shift);
  }
  if(rgb_green_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)(i << (rgb_green_bits + rgb_green_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_green_bits) << rgb_green_shift);
  }
  if(rgb_blue_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)(i << (rgb_blue_bits + rgb_blue_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_blue_bits) << rgb_blue_shift);
  }
  switch(ng_vfmt_to_depth[(signed long int)fmtid])
  {
    case (const unsigned int)16:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0xff00;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv2); i = i + 1u)
        lut2_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut2_list, (signed int)nconv2);
      break;
    }
    case (const unsigned int)32:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_red[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_green[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_blue[(signed long int)i] << 24 & (unsigned long int)0xff000000;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv4); i = i + 1u)
        lut4_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut4_list, (signed int)nconv4);
    }
  }
}

// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size)
{
  struct ng_audio_buf *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_audio_buf) /*32ul*/  + (unsigned long int)size);
  buf = (struct ng_audio_buf *)return_value_malloc_1;
  memset((void *)buf, 0, sizeof(struct ng_audio_buf) /*32ul*/ );
  buf->fmt = *fmt;
  buf->size = size;
  buf->data = (char *)buf + (signed long int)sizeof(struct ng_audio_buf) /*32ul*/ ;
  return buf;
}

// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size)
{
  struct ng_video_buf *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ng_video_buf) /*160ul*/ );
  buf = (struct ng_video_buf *)return_value_malloc_1;
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ng_init_video_buf(buf);
    buf->fmt = *fmt;
    buf->size = (unsigned long int)size;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)size);
    buf->data = (unsigned char *)return_value_malloc_2;
    if(buf->data == ((unsigned char *)NULL))
    {
      free((void *)buf);
      return (struct ng_video_buf *)(void *)0;
    }

    else
    {
      buf->refcount = 1;
      buf->release = ng_free_video_buf;
      return buf;
    }
  }
}

// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "mixer drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_mix_drivers);
    return 0;
  }
}

// ng_mix_init
// file libng/grab-ng.c line 738
struct ng_attribute * ng_mix_init(char *device, char *channel)
{
  struct list_head *item;
  struct ng_mix_driver *ng_mix_init__1__drv = (struct ng_mix_driver *)(void *)0;
  struct ng_attribute *ng_mix_init__1__attrs = (struct ng_attribute *)(void *)0;
  void *handle;
  item = (&ng_mix_drivers)->next;
  if(!(item == &ng_mix_drivers))
  {
    ng_mix_init__1__drv = (struct ng_mix_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: trying: %s... \n", ng_mix_init__1__drv->name);

    handle=ng_mix_init__1__drv->open(device);
    if(!(handle == NULL))
    {
      ng_mix_init__1__attrs=ng_mix_init__1__drv->volctl(handle, channel);
      ng_mix_init__1__drv->close(handle);
    }

    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: failed: %s\n", ng_mix_init__1__drv->name);

    item = item->next;
  }

  if(!(ng_mix_init__1__attrs == ((struct ng_attribute *)NULL)) && !(ng_debug == 0))
    fprintf(stderr, "mix-init: ok: %s\n", ng_mix_init__1__drv->name);

  return ng_mix_init__1__attrs;
}

// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in)
{
  signed int (*func)(unsigned char *, unsigned char *, signed int) = (signed int (*)(unsigned char *, unsigned char *, signed int))handle;
  unsigned char *sp;
  unsigned char *dp;
  unsigned int i;
  unsigned int sw;
  unsigned int dw = out->fmt.width * ng_vfmt_to_depth[(signed long int)out->fmt.fmtid] >> 3;
  sw = in->fmt.width * ng_vfmt_to_depth[(signed long int)in->fmt.fmtid] >> 3;
  _Bool tmp_if_expr_1;
  if(in->fmt.bytesperline == sw)
    tmp_if_expr_1 = out->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    func(out->data, in->data, (signed int)(in->fmt.width * in->fmt.height));

  else
  {
    dp = out->data;
    sp = in->data;
    i = (unsigned int)0;
    if(!(i >= in->fmt.height))
    {
      func(dp, sp, (signed int)in->fmt.width);
      dp = dp + (signed long int)out->fmt.bytesperline;
      sp = sp + (signed long int)in->fmt.bytesperline;
      i = i + 1u;
    }

  }
}

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv)
{
  return priv;
}

// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname)
{
  struct dirent **list;
  char filename[1024l];
  void *plugin;
  void (*initcall)(void);
  signed int i;
  signed int n = 0;
  signed int l = 0;
  n=scandir(dirname, &list, (signed int (*)(struct dirent *))(void *)0, alphasort);
  if(!(n >= 1))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      signed int return_value_fnmatch_1;
      return_value_fnmatch_1=fnmatch("*.so", list[(signed long int)i]->d_name, 0);
      if(return_value_fnmatch_1 == 0)
      {
        sprintf(filename, "%s/%s", dirname, (const void *)list[(signed long int)i]->d_name);
        plugin=dlopen(filename, 0x00002);
        if(plugin == NULL)
        {
          char *return_value_dlerror_2;
          return_value_dlerror_2=dlerror();
          fprintf(stderr, "dlopen: %s\n", return_value_dlerror_2);
          goto __CPROVER_DUMP_L6;
        }

        void *return_value_dlsym_5;
        return_value_dlsym_5=dlsym(plugin, "ng_plugin_init");
        initcall = (void (*)(void))return_value_dlsym_5;
        if(initcall == ((void (*)(void))NULL))
        {
          void *return_value_dlsym_4;
          return_value_dlsym_4=dlsym(plugin, "_ng_plugin_init");
          initcall = (void (*)(void))return_value_dlsym_4;
          if(initcall == ((void (*)(void))NULL))
          {
            char *return_value_dlerror_3;
            return_value_dlerror_3=dlerror();
            fprintf(stderr, "dlsym[%s]: %s\n", (const void *)filename, return_value_dlerror_3);
            goto __CPROVER_DUMP_L6;
          }

        }

        initcall();
        l = l - 1;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    i = 0;
    for( ; !(i >= n); i = i + 1)
      free((void *)list[(signed long int)i]);
    free((void *)list);
    return l;
  }
}

// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ng_ratio_x == 0) && !(ng_ratio_y == 0))
  {
    if(!(w * ng_ratio_y >= h * ng_ratio_x))
    {
      *height = (*width * ng_ratio_y) / ng_ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(!(h * ng_ratio_x >= w * ng_ratio_y))
      {
        *width = (*height * ng_ratio_x) / ng_ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ratio_x == 0) && !(ratio_y == 0))
  {
    if(up == 0 && !(w * ratio_y >= h * ratio_x) || !(up == 0) && !(h * ratio_x >= w * ratio_y))
    {
      *height = (*width * ratio_y) / ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(up == 0 && !(h * ratio_x >= w * ratio_y) || !(up == 0) && !(w * ratio_y >= h * ratio_x))
      {
        *width = (*height * ratio_x) / ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "reader");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&reader->list, &ng_readers);
    return 0;
  }
}

// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf)
{
  signed int release;
  pthread_mutex_lock(&buf->lock);
  buf->refcount = buf->refcount - 1;
  release = (signed int)(buf->refcount == 0);
  pthread_mutex_unlock(&buf->lock);
  if(!(release == 0))
  {
    if(!(buf->release == ((void (*)(struct ng_video_buf *))NULL)))
      buf->release(buf);

  }

}

// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv)
{
  signed long long int ts = tv->tv_sec;
  ts = ts * (signed long long int)1000000;
  ts = ts + tv->tv_usec;
  ts = ts * (signed long long int)1000;
  return ts;
}

// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "video drv");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&driver->list, &ng_vid_drivers);
    return 0;
  }
}

// ng_vid_open
// file ./libng/grab-ng.h line 449
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle)
{
  struct list_head *item;
  struct ng_vid_driver *ng_vid_open__1__drv;
  signed int return_value_strcmp_5;
  signed int return_value;
  if(driver == ((char *)NULL))
  {
    fprintf(stderr, "Video4linux driver is not specified\n");
    return (struct ng_vid_driver *)(void *)0;
  }

  else
  {
    item = (&ng_vid_drivers)->next;
    for( ; !(item == &ng_vid_drivers); item = item->next)
    {
      ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(driver, ng_vid_open__1__drv->name);
      if(return_value_strcasecmp_1 == 0)
        break;

    }
    if(item == &ng_vid_drivers)
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(driver, "help");
      if(!(return_value_strcasecmp_2 == 0))
        fprintf(stderr, "Cannot find %s video driver\n", driver);

      fprintf(stderr, "Available drivers:");
      item = (&ng_vid_drivers)->next;
      for( ; !(item == &ng_vid_drivers); item = item->next)
      {
        ng_vid_open__1__drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
        fprintf(stderr, " %s", ng_vid_open__1__drv->name);
      }
      fprintf(stderr, "\n");
      return (struct ng_vid_driver *)(void *)0;
    }

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(*device, "auto");
    _Bool tmp_if_expr_6;
    if(return_value_strcmp_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strcmp_5=strcmp(*device, "auto_tv");
      tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      char devpath[4096l];
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(*device, "auto_tv");
      *handle=ng_vid_open_auto(ng_vid_open__1__drv, devpath, !(return_value_strcmp_3 != 0) ? 0 : 1);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: could not find a suitable videodev\n");
        return (struct ng_vid_driver *)(void *)0;
      }

      *device=strdup(devpath);
    }

    else
    {
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: trying: %s... \n", ng_vid_open__1__drv->name);

      *handle=ng_vid_open__1__drv->open(*device, 0);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
        return (struct ng_vid_driver *)(void *)0;
      }

      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: ok: %s\n", ng_vid_open__1__drv->name);

    }
    if(!(screen == ((struct ng_video_fmt *)NULL)))
    {
      return_value=ng_vid_open__1__drv->capabilities(*handle);
      if(!((1 & return_value) == 0))
      {
        signed int l;
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(ng_v4l_conf);
        l = (signed int)return_value_strlen_7;
        snprintf(ng_v4l_conf + (signed long int)l, sizeof(char [256l]) /*256ul*/  - (unsigned long int)l, " -c %s", *device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: closing dev to run v4lconf\n");

        ng_vid_open__1__drv->close(*handle);
        signed int return_value_system_8;
        return_value_system_8=system(ng_v4l_conf);
        if(return_value_system_8 == -1)
          fprintf(stderr, "could'nt start v4l-conf\n");

        fprintf(stderr, "v4l-conf had some trouble, trying to continue anyway\n");
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-opening dev after v4lconf\n");

        *handle=ng_vid_open__1__drv->open(*device, 0);
        if(*handle == NULL)
        {
          fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open__1__drv->name);
          return (struct ng_vid_driver *)(void *)0;
        }

        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-open ok\n");

        ng_vid_open__1__drv->setupfb(*handle, screen, base);
      }

    }

    return ng_vid_open__1__drv;
  }
}

// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber)
{
  void *md;
  void *handle = (void *)0;
  const char *device = (const char *)(void *)0;
  const char *scan_type = "an analog TV";
  *devpath = (char)0;
  md=discover_media_devices();
  if(!(md == NULL))
  {
    device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
    if(!(device == ((const char *)NULL)))
    {
      snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

      handle=drv->open(devpath, 2 | 4);
      if(!(handle == NULL))
        fprintf(stderr, "vid-open-auto: using analog TV device %s\n", devpath);

    }

    if(handle == NULL)
    {
      if(allow_grabber == 0)
        goto error;

      scan_type = "a capture";
      device = (const char *)(void *)0;
      device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
      if(!(device == ((const char *)NULL)))
      {
        snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

        handle=drv->open(devpath, 2);
        if(!(handle == NULL))
          fprintf(stderr, "vid-open-auto: using grabber/webcam device %s\n", devpath);

      }

    }

    free_media_devices(md);
  }


error:
  ;
  if(handle == NULL)
  {
    fprintf(stderr, "vid-open-auto: failed to open %s device", scan_type);
    if(!(*devpath == 0))
      fprintf(stderr, " at %s\n", devpath);

    else
      fprintf(stderr, "\n");
    return (void *)0;
  }

  else
  {
    if(!(handle == NULL) && !(ng_debug == 0))
      fprintf(stderr, "vid-open-auto: success, using: %s\n", devpath);

    return handle;
  }
}

// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf)
{
  pthread_mutex_lock(&buf->lock);
  while(!(buf->refcount == 0))
    pthread_cond_wait(&buf->cond, &buf->lock);
  pthread_mutex_unlock(&buf->lock);
}

// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf)
{
  pthread_cond_signal(&buf->cond);
}

// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void)
{
  ng_writer_register(0x20030129, "built-in", &files_writer);
  ng_writer_register(0x20030129, "built-in", &raw_writer);
}

// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer)
{
  signed int return_value_ng_check_magic_1;
  return_value_ng_check_magic_1=ng_check_magic(magic, plugname, "writer");
  if(!(return_value_ng_check_magic_1 == 0))
    return -1;

  else
  {
    list_add_tail(&writer->list, &ng_writers);
    return 0;
  }
}

// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned short int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned int * restrict tmp_post_1 = d;
    d = d + 1l;
    *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right)
{
  signed int lmax;
  signed int rmax;
  signed int i;
  signed int level;
  signed char *s = (signed char *)buf->data;
  unsigned char *u = (unsigned char *)buf->data;
  lmax = 0;
  rmax = 0;
  switch(buf->fmt.fmtid)
  {
    case (unsigned int)1:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_1 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_1] - 128);
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)2:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post_2 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_2] - 128);
        if(!(lmax >= level))
          lmax = level;

        signed int tmp_post_3 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post_3] - 128);
        if(!(rmax >= level))
          rmax = level;

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)5:

    case (unsigned int)3:
    {
      i = (unsigned int)5 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)4:

    case (unsigned int)6:
    {
      i = (unsigned int)6 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
          lmax = level;

        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(rmax >= level))
          rmax = level;

      }
    }
    default:
    {

    __CPROVER_DUMP_L18:
      ;
      *left = lmax;
      *right = rmax;
    }
  }
}

// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry)
{
  char *token;
  char *h;
  strcpy(entry->argbuf, entry->action);
  h = entry->argbuf;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if(!((signed int)*h == 32))
    {
      if((signed int)*h == 9)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h = h + 1l;
      goto __CPROVER_DUMP_L1;
    }
    if((signed int)*h == 0)
      break;

    if((signed int)*h == 34)
    {
      h = h + 1l;
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
        if((signed int)*h == 34)
          break;

    }

    else
    {
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
      {
        if((signed int)*h == 32)
          break;

        if((signed int)*h == 9)
          break;

      }
    }
    if(!((signed int)*h == 0))
    {
      *h = (char)0;
      h = h + 1l;
    }

    signed int tmp_post_1 = entry->argc;
    entry->argc = entry->argc + 1;
    entry->argv[(signed long int)tmp_post_1] = token;
  }
}

// parse_config
// file common/channel.c line 501
void parse_config(signed int parse_channels)
{
  char key[16l];
  char cmdline[128l];
  char **list;
  char *val;
  list=cfg_list_entries("launch");
  signed int return_value_sscanf_2;
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("launch", *list);
      _Bool tmp_if_expr_3;
      if(!(val == ((char *)NULL)))
      {
        return_value_sscanf_2=sscanf(val, "%15[^,], %127[^\n]", (const void *)key, (const void *)cmdline);
        tmp_if_expr_3 = 2 == return_value_sscanf_2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)launch, sizeof(struct LAUNCH) /*24ul*/  * (unsigned long int)(nlaunch + 1));
        launch = (struct LAUNCH *)return_value_realloc_1;
        (launch + (signed long int)nlaunch)->name=strdup(*list);
        (launch + (signed long int)nlaunch)->key=strdup(key);
        (launch + (signed long int)nlaunch)->cmdline=strdup(cmdline);
        nlaunch = nlaunch + 1;
      }

      else
        fprintf(stderr, "invalid value in section [launch]: %s\n", val);
    }

  event_readconfig();
  if(!(parse_channels == 0))
  {
    init_channel("defaults", &defaults);
    list=cfg_list_sections();
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(*list, "defaults");
      if(!(return_value_strcmp_4 == 0))
      {
        signed int return_value_strcmp_5;
        return_value_strcmp_5=strcmp(*list, "global");
        if(!(return_value_strcmp_5 == 0))
        {
          signed int return_value_strcmp_6;
          return_value_strcmp_6=strcmp(*list, "launch");
          if(!(return_value_strcmp_6 == 0))
          {
            signed int return_value_strcmp_7;
            return_value_strcmp_7=strcmp(*list, "eventmap");
            if(!(return_value_strcmp_7 == 0))
            {
              struct CHANNEL *return_value_add_channel_8;
              return_value_add_channel_8=add_channel(*list);
              init_channel(*list, return_value_add_channel_8);
            }

          }

        }

      }

    }
    defaults.channel=lookup_channel(defaults.cname);
    signed int return_value_get_freq_9;
    return_value_get_freq_9=get_freq(defaults.channel);
    defaults.freq = return_value_get_freq_9 + defaults.fine;
    calc_frequencies();
  }

}

// parse_time
// file console/streamer.c line 291
static signed int parse_time(char *time)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  signed int total = 0;
  signed int return_value_sscanf_2;
  return_value_sscanf_2=sscanf(time, "%d:%d:%d", &hours, &minutes, &seconds);
  signed int return_value_sscanf_1;
  if(return_value_sscanf_2 == 3)
    total = hours * 60 * 60 + minutes * 60 + seconds;

  else
  {
    return_value_sscanf_1=sscanf(time, "%d:%d", &minutes, &seconds);
    if(return_value_sscanf_1 == 2)
      total = minutes * 60 + seconds;

  }
  if(!(total == 0))
    return (total * fps) / 1000;

  else
  {
    signed int return_value_atoi_3;
    return_value_atoi_3=atoi(time);
    return return_value_atoi_3;
  }
}

// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name)
{
  char *ptr;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  ptr = name + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; ptr >= name; ptr = ptr - 1l)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*ptr]) == 0))
      break;

  }
  if(!(ptr >= name))
    return 0;

  else
  {
    while((signed int)*ptr == 57)
    {
      if(!(ptr >= name))
        break;

      char *tmp_post_3 = ptr;
      ptr = ptr - 1l;
      *tmp_post_3 = (char)48;
    }
    if(!(ptr >= name))
      return 0;

    else
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*ptr]) == 0))
      {
        *ptr = *ptr + 1;
        return 1;
      }

      else
        return 0;
    }
  }
}

// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab)
{
  signed int i;
  fprintf(stderr, "unknown %s: '%s' (available: ", name, value);
  i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s'%s'", 0 == i ? "" : ", ", (tab + (signed long int)i)->str);
  fprintf(stderr, ")\n");
}

// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  return_value_write_1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write_1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  if(!(h->video.fmtid == 0u))
  {
    if(!(h->fd == 1))
      close(h->fd);

  }

  free((void *)h);
  return 0;
}

// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct raw_handle *h;
  signed int frame_rate_code = 0;
  signed int frame_rate_mul = fps;
  signed int frame_rate_div = 1000;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct raw_handle) /*88ul*/ );
  h = (struct raw_handle *)return_value_malloc_1;
  if(h == ((struct raw_handle *)NULL))
    return (void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct raw_handle) /*88ul*/ );
    h->video = *video;
    h->audio = *audio;
    h->vpriv = (struct raw_priv *)priv_video;
    if(!(h->audio.fmtid == 0u))
    {
      h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
      if(h->wav_fd == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror_3);
        free((void *)h);
        return (void *)0;
      }

      wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
    }

    if(!(h->video.fmtid == 0u))
    {
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
          switch(fps)
          {
            case 23976:
            {
              frame_rate_code = 1;
              frame_rate_mul = 24000;
              frame_rate_div = 1001;
              break;
            }
            case 29970:
            {
              frame_rate_code = 4;
              frame_rate_mul = 30000;
              frame_rate_div = 1001;
              break;
            }
            case 59940:
            {
              frame_rate_code = 7;
              frame_rate_mul = 60000;
              frame_rate_div = 1001;
              break;
            }
            case 24000:
            {
              frame_rate_code = 2;
              break;
            }
            case 25000:
            {
              frame_rate_code = 3;
              break;
            }
            case 30000:
            {
              frame_rate_code = 5;
              break;
            }
            case 50000:
            {
              frame_rate_code = 6;
              break;
            }
            case 60000:
            {
              frame_rate_code = 8;
              break;
            }
            default:
            {
              fprintf(stderr, "illegal frame rate\n");
              free((void *)h);
              return (void *)0;
            }
          }

      }

      if(!(videoname == ((char *)NULL)))
      {
        h->fd=open(videoname, 0100 | 02 | 01000, 0666);
        if(h->fd == -1)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          fprintf(stderr, "open %s: %s\n", videoname, return_value_strerror_5);
          if(!(h->wav_fd == 0))
            close(h->wav_fd);

          free((void *)h);
          return (void *)0;
        }

      }

      else
        h->fd = 1;
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
        {
          char header[64l];
          switch(h->vpriv->yuv4mpeg)
          {
            case 1:
            {
              sprintf(header, "YUV4MPEG %d %d %d\n", h->video.width, h->video.height, frame_rate_code);
              break;
            }
            case 2:
              sprintf(header, "YUV4MPEG2 W%d H%d F%d:%d\n", h->video.width, h->video.height, frame_rate_mul, frame_rate_div);
          }
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(header);
          write(h->fd, (const void *)header, return_value_strlen_6);
        }

      }

    }

    return (void *)h;
  }
}

// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write_1;
  signed long int return_value_write_2;
  if(!(h->vpriv == ((struct raw_priv *)NULL)))
  {
    if(!(h->vpriv->yuv4mpeg == 0))
      switch(h->vpriv->yuv4mpeg)
      {
        case 1:
        {
          return_value_write_1=write(h->fd, (const void *)"FRAME\n", (unsigned long int)6);
          if(!(return_value_write_1 == 6l))
            return -1;

          break;
        }
        case 2:
        {
          return_value_write_2=write(h->fd, (const void *)"FRAME \n", (unsigned long int)7);
          if(!(return_value_write_2 == 7l))
            return -1;

        }
      }

  }

  signed long int return_value_write_3;
  return_value_write_3=write(h->fd, (const void *)buf->data, buf->size);
  if(!(buf->size == (unsigned long int)return_value_write_3))
    return -1;

  else
    return 0;
}

// read_config
// file common/channel.c line 387
void read_config(char *conffile, signed int *argc, char **argv)
{
  struct list_head *item;
  char filename[100l];
  char *val;
  signed int i;
  if(!(conffile == ((char *)NULL)))
  {
    signed int return_value_cfg_parse_file_1;
    return_value_cfg_parse_file_1=cfg_parse_file(conffile);
    if(return_value_cfg_parse_file_1 == 0)
      have_config = 1;

  }

  else
  {
    char *return_value_getenv_2;
    return_value_getenv_2=getenv("HOME");
    sprintf(filename, "%.*s/%s", (signed int)sizeof(char [100l]) /*100ul*/  - 8, return_value_getenv_2, (const void *)".xawtv");
    signed int return_value_cfg_parse_file_3;
    return_value_cfg_parse_file_3=cfg_parse_file("/etc/X11/xawtvrc");
    if(return_value_cfg_parse_file_3 == 0)
      have_config = 1;

    signed int return_value_cfg_parse_file_4;
    return_value_cfg_parse_file_4=cfg_parse_file(filename);
    if(return_value_cfg_parse_file_4 == 0)
      have_config = 1;

  }
  if(!(argc == ((signed int *)NULL)))
    cfg_parse_options(argc, argv);

  val=cfg_get_str("global", "mixer");
  if(!(val == ((char *)NULL)))
  {
    mixer=strdup(val);
    signed int return_value_sscanf_5;
    return_value_sscanf_5=sscanf(mixer, "%31[^:]:%15s", (const void *)mixerdev, (const void *)mixerctl);
    if(!(return_value_sscanf_5 == 2))
    {
      strcpy(mixerdev, ng_dev.mixer);
      strncpy(mixerctl, val, (unsigned long int)15);
      mixerctl[(signed long int)15] = (char)0;
    }

  }

  val=cfg_get_str("global", "midi");
  if(!(val == ((char *)NULL)))
    midi=strdup(val);

  val=cfg_get_str("global", "freqtab");
  signed int return_value_strcasecmp_6;
  if(!(val == ((char *)NULL)))
  {
    i = 0;
    for( ; !((chanlists + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp_6=strcasecmp(val, (chanlists + (signed long int)i)->name);
      if(return_value_strcasecmp_6 == 0)
        break;

    }
    if(!((chanlists + (signed long int)i)->name == ((char *)NULL)))
      freq_newtab(i);

    else
      fprintf(stderr, "invalid value for freqtab: %s\n", val);
  }

  val=cfg_get_str("global", "fullscreen");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_7;
    return_value_sscanf_7=sscanf(val, "%d x %d", &fs_width, &fs_height);
    if(!(return_value_sscanf_7 == 2))
    {
      fprintf(stderr, "invalid value for fullscreen: %s\n", val);
      fs_height = 0;
      fs_width = fs_height;
    }

  }

  val=cfg_get_str("global", "pixsize");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_8;
    return_value_sscanf_8=sscanf(val, "%d x %d", &pix_width, &pix_height);
    if(!(return_value_sscanf_8 == 2))
    {
      fprintf(stderr, "invalid value for pixsize: %s\n", val);
      pix_width = 128;
      pix_height = 96;
    }

  }

  i=cfg_get_int("global", "pixcols");
  if(!(i == -1))
    pix_cols = i;

  val=cfg_get_str("global", "wm-off-by");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_9;
    return_value_sscanf_9=sscanf(val, "%d %d", &fs_xoff, &fs_yoff);
    if(!(return_value_sscanf_9 == 2))
    {
      fprintf(stderr, "invalid value for wm-off-by: %s\n", val);
      fs_yoff = 0;
      fs_xoff = fs_yoff;
    }

  }

  val=cfg_get_str("global", "ratio");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf_10;
    return_value_sscanf_10=sscanf(val, "%d:%d", &ng_ratio_x, &ng_ratio_y);
    if(!(return_value_sscanf_10 == 2))
    {
      fprintf(stderr, "invalid value for ratio: %s\n", val);
      ng_ratio_y = 0;
      ng_ratio_x = ng_ratio_y;
    }

  }

  i=cfg_get_int("global", "jpeg-quality");
  if(!(i == -1))
    ng_jpeg_quality = i;

  val=cfg_get_str("global", "keypad-ntsc");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_ntsc = i;

  }

  val=cfg_get_str("global", "keypad-partial");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_partial = i;

  }

  val=cfg_get_str("global", "osd");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_osd = i;

  }

  val=cfg_get_str("global", "osd-position");
  signed int return_value_sscanf_11;
  if(!(val == ((char *)NULL)))
  {
    return_value_sscanf_11=sscanf(val, "%d , %d", &osd_x, &osd_y);
    if(!(return_value_sscanf_11 == 2))
      fprintf(stderr, "invalid values for osd-position: %s\n", val);

  }

  val=cfg_get_str("global", "use-wm-fullscreen");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_wm_fullscreen = i;

  }

  val=cfg_get_str("global", "mov-driver");
  if(!(val == ((char *)NULL)))
    mov_driver = val;

  val=cfg_get_str("global", "mov-video");
  if(!(val == ((char *)NULL)))
    mov_video = val;

  val=cfg_get_str("global", "mov-fps");
  if(!(val == ((char *)NULL)))
    mov_fps = val;

  val=cfg_get_str("global", "mov-audio");
  if(!(val == ((char *)NULL)))
    mov_audio = val;

  val=cfg_get_str("global", "mov-rate");
  if(!(val == ((char *)NULL)))
    mov_rate = val;

  val=cfg_get_str("global", "filter");
  if(!(val == ((char *)NULL)))
  {
    item = (&ng_filters)->next;
    for( ; !(item == &ng_filters); item = item->next)
    {
      struct ng_filter *f = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
      signed int return_value_strcasecmp_12;
      return_value_strcasecmp_12=strcasecmp(f->name, val);
      if(return_value_strcasecmp_12 == 0)
        cur_filter = f;

    }
  }

}

// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "record_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  buf=h->dsp->read(h->hdsp, (signed long int)h->stopby);
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    if(!(buf->size == 0))
    {
      h->ats = (unsigned long int)buf->info.ts;
      signed long int return_value_ng_get_timestamp_2;
      return_value_ng_get_timestamp_2=ng_get_timestamp();
      h->rts = (unsigned long int)return_value_ng_get_timestamp_2 - h->start;
      h->rdrift = h->rts - h->ats;
      h->vdrift = h->vts - h->ats;
      signed int return_value_fifo_put_3;
      return_value_fifo_put_3=fifo_put(&h->afifo, (void *)buf);
      if(!(return_value_fifo_put_3 == 0))
        free((void *)buf);

    }

  }

  fifo_put(&h->afifo, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "record_audio_thread done\n");

  return (void *)0;
}

// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p)
{
  unsigned char *s = src;
  unsigned char *d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    unsigned char *tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = s[(signed long int)2];
    unsigned char *tmp_post_3 = d;
    d = d + 1l;
    *tmp_post_3 = s[(signed long int)1];
    unsigned char *tmp_post_4 = d;
    d = d + 1l;
    *tmp_post_4 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c) >> 2;
    g = ((signed int)src[(signed long int)0] & 0x03) << 3 | ((signed int)src[(signed long int)1] & 0xe0) >> 5;
    b = (signed int)src[(signed long int)1] & 0x1f;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + (signed long int)2;
  }
  while((_Bool)1);
}

// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned short int * restrict src = (unsigned short int *)s;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c00) >> 10;
    g = ((signed int)src[(signed long int)0] & 0x03e0) >> 5;
    b = (signed int)src[(signed long int)0] & 0x001f;
    unsigned char * restrict tmp_post_2 = dest;
    dest = dest + 1l;
    *tmp_post_2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + 1l;
  }
  while((_Bool)1);
}

// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = s;
    s = s + 1l;
    d[(signed long int)2] = *tmp_post_2;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    d[(signed long int)1] = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = s;
    s = s + 1l;
    d[(signed long int)0] = *tmp_post_4;
    d = d + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned short int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(!(tmp_post_1 >= 1))
      break;

    unsigned int * restrict tmp_post_2 = d;
    d = d + 1l;
    *tmp_post_2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = p;
    p = p - 1;
    if(tmp_post_1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post_2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_2 = *tmp_post_3;
    unsigned char * restrict tmp_post_4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_4 = *tmp_post_5;
    unsigned char * restrict tmp_post_6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_6 = *tmp_post_7;
  }
  while((_Bool)1);
}

// save_config
// file common/channel.c line 559
void save_config(void)
{
  struct ng_attribute *attr;
  char filename1[100l];
  char filename2[100l];
  struct _IO_FILE *fp;
  signed int i;
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("HOME");
  sprintf(filename1, "%s/%s", return_value_getenv_1, (const void *)".xawtv");
  char *return_value_getenv_2;
  return_value_getenv_2=getenv("HOME");
  sprintf(filename2, "%s/%s", return_value_getenv_2, (const void *)".xawtv~");
  unlink(filename2);
  signed int return_value_link_3;
  return_value_link_3=link(filename1, filename2);
  if(return_value_link_3 == 0)
    unlink(filename1);

  fp=fopen(filename1, "w");
  signed int return_value_ng_attr_int2percent_13;
  signed int return_value_ng_attr_int2percent_14;
  signed int return_value_ng_attr_int2percent_15;
  signed int return_value_ng_attr_int2percent_16;
  struct ng_attribute *return_value_ng_attr_byid_18;
  const char *return_value_ng_attr_getstr_19;
  struct ng_attribute *return_value_ng_attr_byid_20;
  const char *return_value_ng_attr_getstr_21;
  const char *return_value_int_to_str_23;
  signed int return_value_ng_attr_int2percent_24;
  signed int return_value_ng_attr_int2percent_25;
  signed int return_value_ng_attr_int2percent_26;
  signed int return_value_ng_attr_int2percent_27;
  if(fp == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "can't open config file %s\n", (const void *)filename1);

  else
  {
    fprintf(fp, "[global]\n");
    if(!(fs_height == 0) && !(fs_width == 0))
      fprintf(fp, "fullscreen = %d x %d\n", fs_width, fs_height);

    if(!(fs_xoff == 0) || !(fs_yoff == 0))
      fprintf(fp, "wm-off-by = %+d%+d\n", fs_xoff, fs_yoff);

    if(!(ng_ratio_x == 0) || !(ng_ratio_y == 0))
      fprintf(fp, "ratio = %d:%d\n", ng_ratio_x, ng_ratio_y);

    fprintf(fp, "freqtab = %s\n", (chanlists + (signed long int)chantab)->name);
    fprintf(fp, "pixsize = %d x %d\n", pix_width, pix_height);
    fprintf(fp, "pixcols = %d\n", pix_cols);
    fprintf(fp, "jpeg-quality = %d\n", ng_jpeg_quality);
    const char *return_value_int_to_str_4;
    return_value_int_to_str_4=int_to_str(keypad_ntsc, booltab);
    fprintf(fp, "keypad-ntsc = %s\n", return_value_int_to_str_4);
    const char *return_value_int_to_str_5;
    return_value_int_to_str_5=int_to_str(keypad_partial, booltab);
    fprintf(fp, "keypad-partial = %s\n", return_value_int_to_str_5);
    const char *return_value_int_to_str_6;
    return_value_int_to_str_6=int_to_str(use_osd, booltab);
    fprintf(fp, "osd = %s\n", return_value_int_to_str_6);
    fprintf(fp, "osd-position = %d , %d\n", osd_x, osd_y);
    const char *return_value_int_to_str_7;
    return_value_int_to_str_7=int_to_str(use_wm_fullscreen, booltab);
    fprintf(fp, "use-wm-fullscreen = %s\n", return_value_int_to_str_7);
    if(!(mixer == ((char *)NULL)))
      fprintf(fp, "mixer = %s\n", mixer);

    if(!(midi == ((char *)NULL)))
      fprintf(fp, "midi = %s\n", midi);

    if(!(mov_driver == ((char *)NULL)))
      fprintf(fp, "mov-driver = %s\n", mov_driver);

    if(!(mov_video == ((char *)NULL)))
      fprintf(fp, "mov-video = %s\n", mov_video);

    if(!(mov_fps == ((char *)NULL)))
      fprintf(fp, "mov-fps = %s\n", mov_fps);

    if(!(mov_audio == ((char *)NULL)))
      fprintf(fp, "mov-audio = %s\n", mov_audio);

    if(!(mov_rate == ((char *)NULL)))
      fprintf(fp, "mov-rate = %s\n", mov_rate);

    fprintf(fp, "\n");
    if(nlaunch >= 1)
    {
      fprintf(fp, "[launch]\n");
      i = 0;
      for( ; !(i >= nlaunch); i = i + 1)
        fprintf(fp, "%s = %s, %s\n", (launch + (signed long int)i)->name, (launch + (signed long int)i)->key, (launch + (signed long int)i)->cmdline);
      fprintf(fp, "\n");
    }

    event_writeconfig(fp);
    fprintf(fp, "# [Station name]\n");
    fprintf(fp, "# capture = overlay | grabdisplay | on | off\n");
    fprintf(fp, "# input = Television | Composite1 | S-Video | ...\n");
    fprintf(fp, "# norm = PAL | NTSC | SECAM | ... \n");
    fprintf(fp, "# channel = #\n");
    fprintf(fp, "# fine = # (-128..+127)\n");
    fprintf(fp, "# key = keysym | modifier+keysym\n");
    fprintf(fp, "# color = #\n");
    fprintf(fp, "# bright = #\n");
    fprintf(fp, "# hue = #\n");
    fprintf(fp, "# contrast = #\n");
    fprintf(fp, "\n");
    fprintf(fp, "[defaults]\n");
    fprintf(fp, "group = %s\n", defaults.group);
    struct ng_attribute *return_value_ng_attr_byid_8;
    return_value_ng_attr_byid_8=ng_attr_byid(attrs, 1);
    const char *return_value_ng_attr_getstr_9;
    return_value_ng_attr_getstr_9=ng_attr_getstr(return_value_ng_attr_byid_8, cur_attrs[(signed long int)1]);
    fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_9);
    struct ng_attribute *return_value_ng_attr_byid_10;
    return_value_ng_attr_byid_10=ng_attr_byid(attrs, 2);
    const char *return_value_ng_attr_getstr_11;
    return_value_ng_attr_getstr_11=ng_attr_getstr(return_value_ng_attr_byid_10, cur_attrs[(signed long int)2]);
    fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_11);
    const char *return_value_int_to_str_12;
    return_value_int_to_str_12=int_to_str(cur_capture, captab);
    fprintf(fp, "capture = %s\n", return_value_int_to_str_12);
    attr=ng_attr_byid(attrs, 6);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[6l]))
      {
        return_value_ng_attr_int2percent_13=ng_attr_int2percent(attr, cur_attrs[(signed long int)6]);
        fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_13);
      }

    }

    attr=ng_attr_byid(attrs, 7);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[7l]))
      {
        return_value_ng_attr_int2percent_14=ng_attr_int2percent(attr, cur_attrs[(signed long int)7]);
        fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_14);
      }

    }

    attr=ng_attr_byid(attrs, 8);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[8l]))
      {
        return_value_ng_attr_int2percent_15=ng_attr_int2percent(attr, cur_attrs[(signed long int)8]);
        fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_15);
      }

    }

    attr=ng_attr_byid(attrs, 9);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[9l]))
      {
        return_value_ng_attr_int2percent_16=ng_attr_int2percent(attr, cur_attrs[(signed long int)9]);
        fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_16);
      }

    }

    fprintf(fp, "\n");
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      fprintf(fp, "[%s]\n", channels[(signed long int)i]->name);
      if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
      {
        struct CHANLIST *tmp_if_expr_17;
        if(!(chantab == -1))
          tmp_if_expr_17 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_17 = (struct CHANLIST *)(void *)0;
        fprintf(fp, "channel = %s\n", (tmp_if_expr_17 + (signed long int)channels[(signed long int)i]->channel)->name);
        if(!(channels[(signed long int)i]->fine == 0))
          fprintf(fp, "fine = %+d\n", channels[(signed long int)i]->fine);

      }

      else
        fprintf(fp, "freq = %.2f\n", (float)channels[(signed long int)i]->freq / (float)16);
      if(!(channels[(signed long int)i]->norm == cur_attrs[1l]))
      {
        return_value_ng_attr_byid_18=ng_attr_byid(attrs, 1);
        return_value_ng_attr_getstr_19=ng_attr_getstr(return_value_ng_attr_byid_18, channels[(signed long int)i]->norm);
        fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr_19);
      }

      if(!(channels[(signed long int)i]->input == cur_attrs[2l]))
      {
        return_value_ng_attr_byid_20=ng_attr_byid(attrs, 2);
        return_value_ng_attr_getstr_21=ng_attr_getstr(return_value_ng_attr_byid_20, channels[(signed long int)i]->input);
        fprintf(fp, "input = %s\n", return_value_ng_attr_getstr_21);
      }

      if(!(channels[(signed long int)i]->key == ((char *)NULL)))
        fprintf(fp, "key = %s\n", channels[(signed long int)i]->key);

      signed int return_value_strcmp_22;
      return_value_strcmp_22=strcmp(channels[(signed long int)i]->group, defaults.group);
      if(!(return_value_strcmp_22 == 0))
        fprintf(fp, "group = %s\n", channels[(signed long int)i]->group);

      if(!(channels[(signed long int)i]->midi == 0))
        fprintf(fp, "midi = %d\n", channels[(signed long int)i]->midi);

      if(!(channels[(signed long int)i]->capture == cur_capture))
      {
        return_value_int_to_str_23=int_to_str(channels[(signed long int)i]->capture, captab);
        fprintf(fp, "capture = %s\n", return_value_int_to_str_23);
      }

      attr=ng_attr_byid(attrs, 6);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[6l] == channels[(signed long int)i]->color))
        {
          return_value_ng_attr_int2percent_24=ng_attr_int2percent(attr, channels[(signed long int)i]->color);
          fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent_24);
        }

      }

      attr=ng_attr_byid(attrs, 7);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[7l] == channels[(signed long int)i]->bright))
        {
          return_value_ng_attr_int2percent_25=ng_attr_int2percent(attr, channels[(signed long int)i]->bright);
          fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent_25);
        }

      }

      attr=ng_attr_byid(attrs, 8);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[8l] == channels[(signed long int)i]->hue))
        {
          return_value_ng_attr_int2percent_26=ng_attr_int2percent(attr, channels[(signed long int)i]->hue);
          fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent_26);
        }

      }

      attr=ng_attr_byid(attrs, 9);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[9l] == channels[(signed long int)i]->contrast))
        {
          return_value_ng_attr_int2percent_27=ng_attr_int2percent(attr, channels[(signed long int)i]->contrast);
          fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent_27);
        }

      }

      fprintf(fp, "\n");
    }
    fclose(fp);
  }
}

// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val)
{
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    attr->write(attr, val);
    cur_attrs[(signed long int)attr->id] = val;
    if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
      attr_notify(attr, val);

  }

}

// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch)
{
  if(!(set_capture_hook == ((void (*)(signed int, signed int, signed int))NULL)))
  {
    static signed int last_on = 1;
    if(capture == 9)
      capture = last_on;

    if(capture == 1)
    {
      if((1 & f_drv) == 0)
        capture = 2;

      if(do_overlay == 0)
        capture = 2;

    }

    if(!(cur_capture == capture))
    {
      set_capture_hook(cur_capture, capture, tmp_switch);
      cur_capture = capture;
    }

    if(!(cur_capture == 0))
      last_on = cur_capture;

  }

}

// set_defaults
// file common/commands.c line 525
void set_defaults(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.color);

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.bright);

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.hue);

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.contrast);

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.input);

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.norm);

  set_capture(defaults.capture, 0);
  cur_channel = defaults.channel;
  cur_fine = defaults.fine;
  cur_freq = defaults.freq;
  if(!((4 & f_drv) == 0))
    drv->setfreq(h_drv, (unsigned long int)defaults.freq);

}

// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j)
{
  if(!((4 & f_drv) == 0))
  {
    freq_newtab(j);
    cur_channel = -1;
    calc_frequencies();
    if(!(freqtab_notify == ((void (*)(void))NULL)))
      freqtab_notify();

  }

}

// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val != 0 ? "on" : "off");
    display_message(title);
  }

}

// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    signed int return_value_ng_attr_int2percent_1;
    return_value_ng_attr_int2percent_1=ng_attr_int2percent(attr, val);
    static char title[256l];
    sprintf(title, "%s: %d%%", attr->name, return_value_ng_attr_int2percent_1);
    display_message(title);
  }

}

// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val);
    display_message(title);
  }

}

// set_mute
// file common/commands.c line 351
static void set_mute(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)4] = val;
  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

  if(!(mute_notify == ((void (*)(signed int))NULL)))
    mute_notify(val);

}

// set_title
// file common/commands.c line 381
static void set_title(void)
{
  const char *norm;
  keypad_state = -1;
  unsigned long int return_value_strlen_2;
  if(!(update_title == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    if(!(cur_sender == -1))
      sprintf(title, "%s", channels[(signed long int)cur_sender]->name);

    else
      if(!(cur_channel == -1))
      {
        struct CHANLIST *tmp_if_expr_1;
        if(!(chantab == -1))
          tmp_if_expr_1 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr_1 = (struct CHANLIST *)(void *)0;
        sprintf(title, "channel %s", (tmp_if_expr_1 + (signed long int)cur_channel)->name);
        if(!(cur_fine == 0))
        {
          return_value_strlen_2=strlen(title);
          sprintf(title + (signed long int)return_value_strlen_2, " (%d)", cur_fine);
        }

        struct ng_attribute *return_value_ng_attr_byid_3;
        return_value_ng_attr_byid_3=ng_attr_byid(attrs, 1);
        norm=ng_attr_getstr(return_value_ng_attr_byid_3, cur_attrs[(signed long int)1]);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(title);
        sprintf(title + (signed long int)return_value_strlen_4, " (%s/%s)", norm != ((const char *)NULL) ? norm : "???", (chanlists + (signed long int)chantab)->name);
      }

      else
        sprintf(title, "%.3f MHz", (double)cur_freq / 16.0);
    update_title(title);
  }

}

// set_volume
// file common/commands.c line 342
static void set_volume(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)3] = val;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

}

// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int setchannel_handler__1__c;
  signed int orig_mute;
  signed int return_value_strcasecmp_7;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_5;
  signed int return_value_get_freq_11;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        signed int return_value_strcasecmp_12;
        return_value_strcasecmp_12=strcasecmp("setfreq", name);
        if(return_value_strcasecmp_12 == 0)
        {
          double return_value_atof_1;
          return_value_atof_1=atof(argv[(signed long int)0]);
          cur_freq = (signed int)(unsigned long int)(return_value_atof_1 * (double)16);
          cur_sender = -1;
          cur_channel = -1;
          cur_fine = 0;
        }

        else
        {
          signed int return_value_strcasecmp_8;
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          if(return_value_strcasecmp_8 == 0)
          {
            signed int tmp_if_expr_2;
            if(!(chantab == -1))
              tmp_if_expr_2 = (chanlists + (signed long int)chantab)->count;

            else
              tmp_if_expr_2 = 0;
            cur_channel = (cur_channel + 1) % tmp_if_expr_2;
            cur_fine = defaults.fine;
          }

          else
          {
            return_value_strcasecmp_7=strcasecmp(argv[(signed long int)0], "prev");
            if(return_value_strcasecmp_7 == 0)
            {
              signed int tmp_if_expr_3;
              if(!(chantab == -1))
                tmp_if_expr_3 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_3 = 0;
              signed int tmp_if_expr_4;
              if(!(chantab == -1))
                tmp_if_expr_4 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr_4 = 0;
              cur_channel = ((cur_channel + tmp_if_expr_3) - 1) % tmp_if_expr_4;
              cur_fine = defaults.fine;
            }

            else
            {
              return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "fine_up");
              if(return_value_strcasecmp_6 == 0)
                cur_fine = cur_fine + 1;

              else
              {
                return_value_strcasecmp_5=strcasecmp(argv[(signed long int)0], "fine_down");
                if(return_value_strcasecmp_5 == 0)
                  cur_fine = cur_fine - 1;

                else
                {
                  setchannel_handler__1__c=lookup_channel(argv[(signed long int)0]);
                  if(!(setchannel_handler__1__c == -1))
                  {
                    cur_channel = setchannel_handler__1__c;
                    cur_fine = defaults.fine;
                  }

                }
              }
            }
          }
          signed int return_value_strncmp_10;
          return_value_strncmp_10=strncmp(argv[(signed long int)0], "fine", (unsigned long int)4);
          if(!(return_value_strncmp_10 == 0))
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(cur_channel == channels[(signed long int)i]->channel)
              {
                char *setchannel_handler__1__4__6__1__1__1__argv[2l];
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)0] = channels[(signed long int)i]->name;
                setchannel_handler__1__4__6__1__1__1__argv[(signed long int)1] = (char *)(void *)0;
                signed int return_value_setstation_handler_9;
                return_value_setstation_handler_9=setstation_handler("", argc, setchannel_handler__1__4__6__1__1__1__argv);
                return return_value_setstation_handler_9;
              }

          }

          cur_sender = -1;
          if(!(cur_channel == -1))
          {
            return_value_get_freq_11=get_freq(cur_channel);
            cur_freq = return_value_get_freq_11 + cur_fine;
          }

          else
          {
            cur_freq = cur_freq + cur_fine;
            cur_fine = 0;
          }
        }
        if(!(channel_switch_hook == ((void (*)(void))NULL)))
          channel_switch_hook();

        set_capture(0, 1);
        orig_mute = cur_attrs[(signed long int)4];
        if(orig_mute == 0)
          set_mute(1);

        if(!((4 & f_drv) == 0))
          drv->setfreq(h_drv, (unsigned long int)cur_freq);

        set_capture(defaults.capture, 0);
        set_title();
        if(!(setstation_notify == ((void (*)(void))NULL)))
          setstation_notify();

        if(orig_mute == 0)
        {
          usleep((unsigned int)20000);
          set_mute(0);
        }

        return 0;
      }
}

// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  if((4 & f_drv) == 0)
    return 0;

  else
  {
    i=str_to_int(argv[(signed long int)0], chanlist_names);
    if(!(i == -1))
      set_freqtab(i);

    else
      print_choices("freqtab", argv[(signed long int)0], chanlist_names);
    return 0;
  }
}

// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int i;
  signed int orig_mute;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_1;
  char *return_value_strcasestr_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        _Bool tmp_if_expr_9;
        if(!(count == 0))
        {
          return_value_strcasecmp_8=strcasecmp(argv[(signed long int)0], "next");
          tmp_if_expr_9 = 0 == return_value_strcasecmp_8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
          i = (cur_sender + 1) % count;

        else
        {
          _Bool tmp_if_expr_7;
          if(!(count == 0))
          {
            return_value_strcasecmp_6=strcasecmp(argv[(signed long int)0], "prev");
            tmp_if_expr_7 = 0 == return_value_strcasecmp_6 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
            i = ((cur_sender + count) - 1) % count;

          else
          {
            _Bool tmp_if_expr_5;
            if(!(count == 0))
            {
              return_value_strcasecmp_4=strcasecmp(argv[(signed long int)0], "back");
              tmp_if_expr_5 = 0 == return_value_strcasecmp_4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
            {
              if(last_sender == -1)
                return -1;

              i = last_sender;
            }

            else
            {
              i = 0;
              for( ; !(i >= count); i = i + 1)
              {
                return_value_strcasecmp_1=strcasecmp(channels[(signed long int)i]->name, argv[(signed long int)0]);
                if(return_value_strcasecmp_1 == 0)
                  break;

              }
              if(i == count)
              {
                i = 0;
                for( ; !(i >= count); i = i + 1)
                {
                  return_value_strcasestr_2=strcasestr(channels[(signed long int)i]->name, argv[(signed long int)0]);
                  if(!(return_value_strcasestr_2 == ((char *)NULL)))
                    break;

                }
              }

              if(i == count)
              {
                return_value___ctype_b_loc_3=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*(*argv)]) == 0))
                  i=atoi(argv[(signed long int)0]);

              }

              if(i == count)
              {
                fprintf(stderr, "station \"%s\" not found\n", argv[(signed long int)0]);
                return -1;
              }

            }
          }
        }
        if(i >= count || !(i >= 0))
          return -1;

        else
        {
          if(!(channel_switch_hook == ((void (*)(void))NULL)))
            channel_switch_hook();

          set_capture(0, 1);
          orig_mute = cur_attrs[(signed long int)4];
          if(orig_mute == 0)
            set_mute(1);

          last_sender = cur_sender;
          cur_sender = i;
          attr=ng_attr_byid(attrs, 6);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->color);

          attr=ng_attr_byid(attrs, 7);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->bright);

          attr=ng_attr_byid(attrs, 8);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->hue);

          attr=ng_attr_byid(attrs, 9);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->contrast);

          if(!(cur_attrs[2l] == channels[(signed long int)i]->input))
          {
            attr=ng_attr_byid(attrs, 2);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->input);

          }

          if(!(cur_attrs[1l] == channels[(signed long int)i]->norm))
          {
            attr=ng_attr_byid(attrs, 1);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->norm);

          }

          cur_channel = channels[(signed long int)i]->channel;
          cur_fine = channels[(signed long int)i]->fine;
          cur_freq = channels[(signed long int)i]->freq;
          if(!((4 & f_drv) == 0))
            drv->setfreq(h_drv, (unsigned long int)channels[(signed long int)i]->freq);

          set_capture(channels[(signed long int)i]->capture, 0);
          set_title();
          if(!(setstation_notify == ((void (*)(void))NULL)))
            setstation_notify();

          if(orig_mute == 0)
          {
            usleep((unsigned int)20000);
            set_mute(0);
          }

          return 0;
        }
      }
}

// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  char *n[2l] = { (char *)(void *)0, (char *)(void *)0 };
  signed int val;
  const char *return_value_ng_attr_getstr_1;
  if(argc == 0)
  {
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    {
      n[(signed long int)0] = (char *)attr->name;
      show_handler("show", 1, n);
    }
    return 0;
  }

  else
  {
    attr=ng_attr_byname(attrs, argv[(signed long int)0]);
    if(attr == ((struct ng_attribute *)NULL))
    {
      fprintf(stderr, "fixme: 404 %s\n", argv[(signed long int)0]);
      return 0;
    }

    else
    {
      val = cur_attrs[(signed long int)attr->id];
      switch(attr->type)
      {
        case 2:
        {
          return_value_ng_attr_getstr_1=ng_attr_getstr(attr, val);
          printf("%s: %s\n", attr->name, return_value_ng_attr_getstr_1);
          break;
        }
        case 1:
        {
          printf("%s: %d\n", attr->name, val);
          break;
        }
        case 3:
          printf("%s: %s\n", attr->name, val != 0 ? "on" : "off");
      }
      return 0;
    }
  }
}

// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv)
{
  char timestr[6l];
  struct tm *times;
  signed long int timet;
  timet=time((signed long int *)(void *)0);
  times=localtime(&timet);
  strftime(timestr, (unsigned long int)6, "%k:%M", times);
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(timestr);

  return 0;
}

// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext)
{
  signed long int now;
  struct tm *tm;
  char timestamp[32l];
  time(&now);
  tm=localtime(&now);
  static signed int snap_filename__1__count = 0;
  static signed long int last = (signed long int)0;
  if(!(last == now))
    snap_filename__1__count = 0;

  last = now;
  snap_filename__1__count = snap_filename__1__count + 1;
  static char *filename = (char *)(void *)0;
  if(!(filename == ((char *)NULL)))
    free((void *)filename);

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(base);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(channel);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(ext);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)32);
  filename = (char *)return_value_malloc_4;
  strftime(timestamp, (unsigned long int)31, "%Y%m%d-%H%M%S", tm);
  sprintf(filename, "%s-%s-%s-%d.%s", base, channel, (const void *)timestamp, snap_filename__1__count, ext);
  return filename;
}

// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv)
{
  char message[512l];
  char *tmpfilename = (char *)(void *)0;
  char *filename = (char *)(void *)0;
  char *name;
  signed int jpeg = 0;
  signed int ret = 0;
  struct ng_video_fmt fmt;
  struct ng_video_buf *buf = (struct ng_video_buf *)(void *)0;
  signed int return_value_strcasecmp_4;
  signed int return_value_sscanf_3;
  unsigned long int return_value_strlen_7;
  void *return_value_malloc_8;
  signed int return_value_link_17;
  if((2 & f_drv) == 0)
  {
    fprintf(stderr, "grabbing: not supported [try -noxv switch?]\n");
    return -1;
  }

  else
    if(!(cur_movie == 0))
    {
      if(!(display_message == ((void (*)(char *))NULL)))
        display_message("grabber busy");

      return -1;
    }

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      if(argc >= 1)
      {
        signed int return_value_strcasecmp_1;
        return_value_strcasecmp_1=strcasecmp(argv[(signed long int)0], "jpeg");
        if(return_value_strcasecmp_1 == 0)
          jpeg = 1;

        signed int return_value_strcasecmp_2;
        return_value_strcasecmp_2=strcasecmp(argv[(signed long int)0], "ppm");
        if(return_value_strcasecmp_2 == 0)
          jpeg = 0;

      }

      memset((void *)&fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      fmt.fmtid = (unsigned int)9;
      fmt.width = (unsigned int)2048;
      fmt.height = (unsigned int)1572;
      if(argc >= 2)
      {
        signed int return_value_strcasecmp_5;
        return_value_strcasecmp_5=strcasecmp(argv[(signed long int)1], "full");
        if(!(return_value_strcasecmp_5 == 0))
        {
          return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "win");
          if(return_value_strcasecmp_4 == 0)
          {
            fmt.width = cur_tv_width;
            fmt.height = cur_tv_height;
          }

          else
          {
            return_value_sscanf_3=sscanf(argv[(signed long int)1], "%dx%d", &fmt.width, &fmt.height);
            if(!(return_value_sscanf_3 == 2))
              return -1;

          }
        }

      }

      if(argc >= 3)
        filename = argv[(signed long int)2];

      buf=ng_grabber_get_image(&fmt);
      if(buf == ((struct ng_video_buf *)NULL))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabbing failed");

        ret = -1;
      }

      else
      {
        buf=ng_filter_single(cur_filter, buf);
        if(filename == ((char *)NULL))
        {
          if(!(cur_sender == -1))
            name = channels[(signed long int)cur_sender]->name;

          else
            if(!(cur_channel == -1))
            {
              struct CHANLIST *tmp_if_expr_6;
              if(!(chantab == -1))
                tmp_if_expr_6 = (chanlists + (signed long int)chantab)->list;

              else
                tmp_if_expr_6 = (struct CHANLIST *)(void *)0;
              name = (tmp_if_expr_6 + (signed long int)cur_channel)->name;
            }

            else
              name = "unknown";
          filename=snap_filename(snapbase, name, jpeg != 0 ? "jpeg" : "ppm");
        }

        return_value_strlen_7=strlen(filename);
        return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)8);
        tmpfilename = (char *)return_value_malloc_8;
        sprintf(tmpfilename, "%s.___", filename);
        if(!(jpeg == 0))
        {
          signed int return_value_write_jpeg_11;
          return_value_write_jpeg_11=write_jpeg(tmpfilename, buf, ng_jpeg_quality, 0);
          if(return_value_write_jpeg_11 == -1)
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            char *return_value_strerror_10;
            return_value_strerror_10=strerror(*return_value___errno_location_9);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror_10);
          }

          else
            sprintf(message, "saved jpeg: %s", filename);
        }

        else
        {
          signed int return_value_write_ppm_14;
          return_value_write_ppm_14=write_ppm(tmpfilename, buf);
          if(return_value_write_ppm_14 == -1)
          {
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            char *return_value_strerror_13;
            return_value_strerror_13=strerror(*return_value___errno_location_12);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror_13);
          }

          else
            sprintf(message, "saved ppm: %s", filename);
        }
        unlink(filename);
        return_value_link_17=link(tmpfilename, filename);
        if(return_value_link_17 == -1)
        {
          signed int *return_value___errno_location_15;
          return_value___errno_location_15=__errno_location();
          char *return_value_strerror_16;
          return_value_strerror_16=strerror(*return_value___errno_location_15);
          fprintf(stderr, "link(%s,%s): %s\n", tmpfilename, filename, return_value_strerror_16);
          goto done;
        }

        unlink(tmpfilename);
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message(message);

      }

    done:
      ;
      if(!(tmpfilename == ((char *)NULL)))
        free((void *)tmpfilename);

      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return ret;
    }
}

// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b)
{
  struct media_device_entry *md_a = (struct media_device_entry *)a;
  struct media_device_entry *md_b = (struct media_device_entry *)b;
  signed int cmp;
  cmp=strcmp(md_a->device, md_b->device);
  if(!(cmp == 0))
    return cmp;

  else
  {
    cmp = (signed int)md_a->type - (signed int)md_b->type;
    if(!(cmp == 0))
      return cmp;

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(md_a->node, md_b->node);
      return return_value_strcmp_1;
    }
  }
}

// split_cmdline
// file common/commands.c line 272
char ** split_cmdline(char *line, signed int *count)
{
  signed int argc;
  signed int i;
  static char cmdline[1024l];
  strcpy(cmdline, line);
  argc = 0;
  i = 0;
  static char *argv[32l];
  while(!(argc >= 31))
  {
    signed int tmp_post_1 = argc;
    argc = argc + 1;
    argv[(signed long int)tmp_post_1] = cmdline + (signed long int)i;
    for( ; !((signed int)cmdline[(signed long int)i] == 32); i = i + 1)
    {
      if((signed int)cmdline[(signed long int)i] == 9)
        break;

      if((signed int)cmdline[(signed long int)i] == 0)
        break;

    }
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

    signed int tmp_post_2 = i;
    i = i + 1;
    cmdline[(signed long int)tmp_post_2] = (char)0;
    for( ; (_Bool)1; i = i + 1)
      if(!((signed int)cmdline[(signed long int)i] == 32))
      {
        if(!((signed int)cmdline[(signed long int)i] == 9))
          goto __CPROVER_DUMP_L6;

      }


  __CPROVER_DUMP_L6:
    ;
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

  }
  argv[(signed long int)argc] = (char *)(void *)0;
  *count = argc;
  return argv;
}

// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab)
{
  signed int i;
  signed int return_value_atoi_1;
  if((signed int)*str >= 48)
  {
    if(!((signed int)*str >= 58))
    {
      return_value_atoi_1=atoi(str);
      return return_value_atoi_1;
    }

  }

  i = 0;
  signed int return_value_strcasecmp_2;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp_2=strcasecmp(str, (tab + (signed long int)i)->str);
    if(return_value_strcasecmp_2 == 0)
      return (signed int)(tab + (signed long int)i)->nr;

  }
  return -1;
}

// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family)
{
  switch(family)
  {
    case 10:
      return "ipv6";
    case 2:
      return "ipv4";
    case 1:
      return "unix";
    default:
      return "????";
  }
}

// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv)
{
  struct addrinfo *res;
  struct addrinfo *e;
  char uhost[47l];
  char userv[33l];
  signed int sock;
  signed int rc;
  signed int opt = 1;
  ai->ai_flags = 0x0002;
  if(!(debug == 0))
    fprintf(stderr, "tcp: lookup %s:%s ... ", host, serv);

  rc=getaddrinfo(host, serv, ai, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rc);
    fprintf(stderr, "tcp: getaddrinfo (%s:%s): %s\n", host, serv, return_value_gai_strerror_1);
    return -1;
  }

  if(!(debug == 0))
    fprintf(stderr, "ok\n");

  e = res;
  char *return_value_strfamily_3;
  for( ; !(e == ((struct addrinfo *)NULL)); e = e->ai_next)
  {
    signed int return_value_getnameinfo_2;
    return_value_getnameinfo_2=getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen, uhost, (unsigned int)46, userv, (unsigned int)32, 1 | 2);
    if(!(return_value_getnameinfo_2 == 0))
      fprintf(stderr, "tcp: getnameinfo (peer): oops\n");

    else
    {
      if(!(debug == 0))
      {
        return_value_strfamily_3=strfamily(e->ai_family);
        fprintf(stderr, "tcp: trying %s (%s:%s) ... ", return_value_strfamily_3, (const void *)uhost, (const void *)userv);
      }

      sock=socket(e->ai_family, e->ai_socktype, e->ai_protocol);
      if(sock == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        fprintf(stderr, "tcp: socket: %s\n", return_value_strerror_5);
        goto __CPROVER_DUMP_L10;
      }

      setsockopt(sock, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_connect_8;
      return_value_connect_8=connect(sock, e->ai_addr, e->ai_addrlen);
      if(return_value_connect_8 == -1)
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        fprintf(stderr, "tcp: connect: %s\n", return_value_strerror_7);
        close(sock);
        goto __CPROVER_DUMP_L10;
      }

      if(!(debug == 0))
        fprintf(stderr, "ok\n");

      fcntl(sock, 4, 04000);
      fcntl(sock, 2, 1);
      return sock;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  return -1;
}

// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen)
{
  struct timeval tv;
  struct anonymous_7 set;
  signed int rc;
  signed int *return_value___errno_location_1;
  do
  {

  again:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_7) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    rc=select(sock + 1, &set, (struct anonymous_7 *)(void *)0, (struct anonymous_7 *)(void *)0, &tv);
    if(!(rc == -1))
      goto __CPROVER_DUMP_L2;

    return_value___errno_location_1=__errno_location();
  }
  while(*return_value___errno_location_1 == 4);

__CPROVER_DUMP_L2:
  ;
  if(rc == -1)
  {
    if(!(debug == 0))
      perror("tcp: select");

    return -1;
  }

  else
    if(rc == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "tcp: select timeout\n");

      return -1;
    }

    else
    {
      signed long int return_value_read_2;
      return_value_read_2=read(sock, (void *)dest, (unsigned long int)((signed int)dlen - 1));
      rc = (signed int)return_value_read_2;
      if(rc == -1)
      {
        if(!(debug == 0))
          perror("tcp: read");

        return -1;
      }

      else
      {
        dest[(signed long int)rc] = (char)0;
        return rc;
      }
    }
}

// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new)
{
  signed int value = old;
  signed int step = ((attr->max - attr->min) * 3) / 100;
  if(step == 0)
    step = 1;

  signed int return_value_strcasecmp_9;
  return_value_strcasecmp_9=strcasecmp(new, "inc");
  signed int return_value_strcasecmp_8;
  signed int return_value_strncasecmp_7;
  signed int return_value_ng_attr_parse_int_1;
  signed int return_value_strncasecmp_6;
  signed int return_value_ng_attr_parse_int_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(return_value_strcasecmp_9 == 0)
    value = value + step;

  else
  {
    return_value_strcasecmp_8=strcasecmp(new, "dec");
    if(return_value_strcasecmp_8 == 0)
      value = value - step;

    else
    {
      return_value_strncasecmp_7=strncasecmp(new, "+=", (unsigned long int)2);
      if(return_value_strncasecmp_7 == 0)
      {
        return_value_ng_attr_parse_int_1=ng_attr_parse_int(attr, new + (signed long int)2);
        value = value + return_value_ng_attr_parse_int_1;
      }

      else
      {
        return_value_strncasecmp_6=strncasecmp(new, "-=", (unsigned long int)2);
        if(return_value_strncasecmp_6 == 0)
        {
          return_value_ng_attr_parse_int_2=ng_attr_parse_int(attr, new + (signed long int)2);
          value = value - return_value_ng_attr_parse_int_2;
        }

        else
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          _Bool tmp_if_expr_4;
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*new]) == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = 43 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = 45 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            value=ng_attr_parse_int(attr, new);

          else
            fprintf(stderr, "update_int: can't parse %s\n", new);
        }
      }
    }
  }
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// usage
// file console/streamer.c line 101
static void usage(struct _IO_FILE *out)
{
  fprintf(out, "streamer grabs image(s), records movies and sound\n\nusage: streamer [ options ]\n\ngeneral options:\n  -h          print this help text\n  -q          quiet operation\n  -d          enable debug output\n  -p n        use n compression threads    [%d]\n  -w seconds  wait before grabbing         [%d]\n\nvideo options:\n  -o file     video/movie file name\n  -f format   specify video format\n  -c device   specify video4linux device   [%s]\n  -D driver   specify video4linux driver   [%s]\n  -r fps      frame rate                   [%d.%03d]\n  -s size     specify size                 [%dx%d]\n\n  -t times    number of frames or hh:mm:ss [%d]\n  -b buffers  specify # of buffers         [%d]\n  -j quality  quality for mjpeg or jpeg    [%d]\n  -n tvnorm   set pal/ntsc/secam\n  -i input    set video source\n  -a          don't unmute/mute v4l device.\n\naudio options:\n  -O file     wav file name\n  -F format   specify audio format\n  -C device   specify dsp device           [%s]\n  -R rate     sample rate                  [%d]\n\n", parallel, wait_seconds, ng_dev.video, ng_dev.driver, fps / 1000, fps % 1000, video.width, video.height, absframes, bufcount, ng_jpeg_quality, ng_dev.dsp, audio.rate);
  list_formats(out);
  fprintf(out, "If you want to capture to multiple image files you should include some\ndigits into the movie filename (foo0000.jpeg for example), streamer will\nuse the digit block to enumerate the image files.\n\nFor file formats which can hold *both* audio and video (like AVI and\nQuickTime) the -O option has no effect.\n\nstreamer will use the file extension of the output file name to figure\nwhich format to use.  You need the -f/-F options only if the extension\nallows more than one format.\n\nExamples:\n  capture a single frame:\n    streamer -o foobar.ppm\n\n  capture ten frames, two per second:\n    streamer -t 10 -r 2 -o foobar00.jpeg\n\n  record 30 seconds stereo sound:\n    streamer -t 0:30 -O soundtrack.wav -F stereo\n\n  record a quicktime movie with sound:\n    streamer -t 0:30 -o movie.mov -f jpeg -F mono16\n\n  build mpeg movies using mjpegtools + compressed avi file:\n    streamer -t 0:30 -s 352x240 -r 24 -o movie.avi -f mjpeg -F stereo\n    lav2wav +p movie.avi | mp2enc -o audio.mp2\n    lav2yuv +p movie.avi | mpeg2enc -o video.m1v\n    mplex audio.mp2 video.m1v -o movie.mpg\n\n  build mpeg movies using mjpegtools + raw, uncompressed video:\n    streamer -t 0:30 -s 352x240 -r 24 -o video.yuv -O audio.wav -F stereo\n    mp2enc -o audio.mp2 < audio.wav\n    mpeg2enc -o video.m1v < video.yuv\n    mplex audio.mp2 video.m1v -o movie.mpg\n\n-- \n(c) 1998-2001 Gerd Knorr <kraxel@bytesex.org>\n");
}

// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv)
{
  char line[80l];
  struct addrinfo ask;
  signed int i;
  signed int rc;
  unsigned int l;
  unsigned int len;

reconnect:
  ;
  signed long int return_value_write_4;
  signed int *return_value___errno_location_3;
  for( ; (_Bool)1; vdr_sock = -1)
  {
    if(vdr_sock == -1)
    {
      memset((void *)&ask, 0, sizeof(struct addrinfo) /*48ul*/ );
      ask.ai_family = 0;
      ask.ai_socktype = 1;
      vdr_sock=tcp_connect(&ask, "localhost", "2001");
      if(vdr_sock == -1)
        return -1;

      if(!(debug == 0))
        fprintf(stderr, "vdr: connected\n");

      signed int return_value_tcp_readbuf_1;
      return_value_tcp_readbuf_1=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
      if(return_value_tcp_readbuf_1 == -1)
        goto oops;

      if(!(debug == 0))
        fprintf(stderr, "vdr: << %s", (const void *)line);

    }

    line[(signed long int)0] = (char)0;
    i = 0;
    len = (unsigned int)0;
    for( ; !(i >= argc); i = i + 1)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(argv[(signed long int)i]);
      l = (unsigned int)return_value_strlen_2;
      if((unsigned long int)(4u + l + len) >= 81ul)
        break;

      if(!(len == 0u))
      {
        strcpy(line + (signed long int)len, " ");
        len = len + 1u;
      }

      strcpy(line + (signed long int)len, argv[(signed long int)i]);
      len = len + l;
    }
    strcpy(line + (signed long int)len, "\r\n");
    len = len + (unsigned int)2;
    return_value_write_4=write(vdr_sock, (const void *)line, (unsigned long int)len);
    rc = (signed int)return_value_write_4;
    if(len == (unsigned int)rc)
      goto __CPROVER_DUMP_L14;

    if(!(rc == -1))
      goto __CPROVER_DUMP_L12;

    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 32))
      break;

    if(!(debug == 0))
      fprintf(stderr, "tcp: write: broken pipe, trying reconnect\n");

    close(vdr_sock);
  }

__CPROVER_DUMP_L12:
  ;
  if(!(debug == 0))
    perror("tcp: write");

  goto oops;

__CPROVER_DUMP_L14:
  ;
  if(!(debug == 0))
    fprintf(stderr, "vdr: >> %s", (const void *)line);

  signed int return_value_tcp_readbuf_5;
  return_value_tcp_readbuf_5=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
  if(!(return_value_tcp_readbuf_5 == -1))
  {
    if(!(debug == 0))
      fprintf(stderr, "vdr: << %s", (const void *)line);

    return 0;
  }

  else
  {

  oops:
    ;
    close(vdr_sock);
    vdr_sock = -1;
    return -1;
  }
}

// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *vol;
  vol=ng_attr_byid(attrs, 3);
  signed int return_value_strcasecmp_3;
  if(!(argc == 0))
  {
    return_value_strcasecmp_3=strcasecmp(argv[(signed long int)0], "mute");
    if(return_value_strcasecmp_3 == 0)
    {
      if(argc >= 2)
      {
        signed int return_value_str_to_int_1;
        return_value_str_to_int_1=str_to_int(argv[(signed long int)1], booltab);
        switch(return_value_str_to_int_1)
        {
          case 0:
          {
            set_mute(0);
            break;
          }
          case 1:
          {
            set_mute(1);
            break;
          }
          default:
            set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
        }
      }

      else
        set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
    }

    else
      if(!(vol == ((struct ng_attribute *)NULL)))
      {
        signed int return_value;
        return_value=vol->read(vol);
        signed int return_value_update_int_2;
        return_value_update_int_2=update_int(vol, return_value, argv[(signed long int)0]);
        set_volume(return_value_update_int_2);
      }

    if(!(volume_notify == ((void (*)(void))NULL)))
      volume_notify();

  }


display:
  ;
  if(!(cur_attrs[4l] == 0))
    set_msg_str("volume", "muted");

  else
    if(!(vol == ((struct ng_attribute *)NULL)))
      set_msg_int(vol, cur_attrs[(signed long int)3]);

    else
      set_msg_str("volume", "unmuted");
  return 0;
}

// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  signed int nBitsPerSample = (signed int)ng_afmt_to_bits[(signed long int)audio->fmtid];
  signed int wav_init_header__1__channels = (signed int)ng_afmt_to_channels[(signed long int)audio->fmtid];
  signed int rate = (signed int)audio->rate;
  unsigned long int nBlockAlign = (unsigned long int)(wav_init_header__1__channels * ((nBitsPerSample + 7) / 8));
  unsigned long int nAvgBytesPerSec = nBlockAlign * (unsigned long int)rate;
  unsigned long int temp = ((unsigned long int)0 + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.ckid = (unsigned int)(unsigned char)82 | (unsigned int)(unsigned char)73 << 8 | (unsigned int)(unsigned char)70 << 16 | (unsigned int)(unsigned char)70 << 24;
  fileheader->fccWave = (unsigned int)(unsigned char)87 | (unsigned int)(unsigned char)65 << 8 | (unsigned int)(unsigned char)86 << 16 | (unsigned int)(unsigned char)69 << 24;
  fileheader->chkFmt.ckid = (unsigned int)(unsigned char)102 | (unsigned int)(unsigned char)109 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)32 << 24;
  fileheader->chkFmt.dwSize = (unsigned int)16;
  fileheader->wFormatTag = (unsigned short int)1;
  fileheader->nChannels = (unsigned short int)wav_init_header__1__channels;
  fileheader->nSamplesPerSec = (unsigned int)rate;
  fileheader->nAvgBytesPerSec = (unsigned int)nAvgBytesPerSec;
  fileheader->nBlockAlign = (unsigned short int)nBlockAlign;
  fileheader->wBitsPerSample = (unsigned short int)nBitsPerSample;
  fileheader->chkData.ckid = (unsigned int)(unsigned char)100 | (unsigned int)(unsigned char)97 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)97 << 24;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)0;
}

// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  wav_init_header(fileheader, audio);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size)
{
  unsigned long int temp = ((unsigned long int)wav_size + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)wav_size;
  lseek(fd, (signed long int)0, 0);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void)
{
  if(!(web == ((struct WEBCAM *)NULL)))
  {
    pthread_cancel(tweb);
    free((void *)web);
    web = (struct WEBCAM *)(void *)0;
  }

}

// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv)
{
  struct ng_video_fmt fmt;
  struct ng_video_buf *buf;
  if(!(webcam == ((char *)NULL)))
    free((void *)webcam);

  webcam=strdup(argv[(signed long int)0]);
  if(!(cur_movie == 0))
    return 0;

  else
    if(cur_capture == 2)
      return 0;

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      memset((void *)&fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      fmt.fmtid = (unsigned int)9;
      fmt.width = cur_tv_width;
      fmt.height = cur_tv_height;
      buf=ng_grabber_get_image(&fmt);
      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return 0;
    }
}

// webcam_init
// file common/webcam.c line 108
void webcam_init(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct WEBCAM) /*104ul*/ );
  web = (struct WEBCAM *)return_value_malloc_1;
  memset((void *)web, 0, sizeof(struct WEBCAM) /*104ul*/ );
  pthread_mutex_init(&web->lock, (const union anonymous_8 *)(void *)0);
  pthread_create(&tweb, (const union pthread_attr_t *)(void *)0, webcam_writer, (void *)web);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf)
{
  signed int ret = 0;
  if(web == ((struct WEBCAM *)NULL))
    webcam_init();

  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&web->lock);
  if(return_value_pthread_mutex_trylock_1 == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "webcam_put: locked\n");

    return -1;
  }

  else
  {
    if(!(web->buf == ((struct ng_video_buf *)NULL)))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: still has data\n");

      ret = -1;
    }

    else
    {
      web->filename=strdup(filename);
      web->buf = buf;
      buf->refcount = buf->refcount + 1;
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: ok\n");

      pthread_cond_signal(&web->wait);
    }

  done:
    ;
    pthread_mutex_unlock(&web->lock);
    return ret;
  }
}

// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg)
{
  struct WEBCAM *webcam_writer__1__web = (struct WEBCAM *)arg;
  signed int rename;
  signed int fd;
  signed int old;
  char tmpfilename[512l];
  struct ng_video_fmt *fmt;
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer start\n");

  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  pthread_mutex_lock(&webcam_writer__1__web->lock);

__CPROVER_DUMP_L2:
  ;
  for( ; (_Bool)1; webcam_writer__1__web->buf = (struct ng_video_buf *)(void *)0)
  {
    if(webcam_writer__1__web->buf == ((struct ng_video_buf *)NULL))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_writer: waiting for data\n");

      pthread_cond_wait(&webcam_writer__1__web->wait, &webcam_writer__1__web->lock);
      goto __CPROVER_DUMP_L2;
    }

    fmt = &webcam_writer__1__web->buf->fmt;
    if(!(debug == 0))
      fprintf(stderr, "webcam_writer: %d %dx%d \n", fmt->fmtid, fmt->width, fmt->height);

    rename = 1;
    sprintf(tmpfilename, "%s.___", webcam_writer__1__web->filename);
    switch(fmt->fmtid)
    {
      case (unsigned int)16:

      case (unsigned int)17:
      {
        fd=open(tmpfilename, 0100 | 01, 0666);
        if(fd == -1)
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          fprintf(stderr, "open(%s): %s\n", (const void *)tmpfilename, return_value_strerror_2);
          goto done;
        }

        write(fd, (const void *)webcam_writer__1__web->buf->data, webcam_writer__1__web->buf->size);
        close(fd);
        break;
      }
      case (unsigned int)9:
      {
        write_jpeg(tmpfilename, webcam_writer__1__web->buf, ng_jpeg_quality, 0);
        break;
      }
      default:
      {
        fprintf(stderr, "webcam_writer: can't deal with format=%d\n", fmt->fmtid);
        rename = 0;
      }
    }
    if(!(rename == 0))
    {
      unlink(webcam_writer__1__web->filename);
      signed int return_value_link_5;
      return_value_link_5=link(tmpfilename, webcam_writer__1__web->filename);
      if(return_value_link_5 == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        fprintf(stderr, "link(%s,%s): %s\n", (const void *)tmpfilename, webcam_writer__1__web->filename, return_value_strerror_4);
        break;
      }

      unlink(tmpfilename);
    }

    free((void *)webcam_writer__1__web->filename);
    ng_release_video_buf(webcam_writer__1__web->buf);
  }

done:
  ;
  pthread_mutex_unlock(&webcam_writer__1__web->lock);
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer done\n");

  return (void *)0;
}

// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  signed int return_value_do_write_jpeg_3;
  return_value_do_write_jpeg_3=do_write_jpeg(fp, buf, quality, gray);
  return return_value_do_write_jpeg_3;
}

// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P5\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)buf->fmt.width, fp);
  fclose(fp);
  return 0;
}

// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror_2);
    return -1;
  }

  fprintf(fp, "P6\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)((unsigned int)3 * buf->fmt.width), fp);
  fclose(fp);
  return 0;
}

// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_audio_thread start [pid=%d]\n", return_value_getpid_1);
  }

  void *return_value_fifo_get_2;
  return_value_fifo_get_2=fifo_get(&h->afifo);
  buf = (struct ng_audio_buf *)return_value_fifo_get_2;
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    pthread_mutex_lock(&h->lock);
    h->writer->wr_audio(h->handle, buf);
    pthread_mutex_unlock(&h->lock);
    free((void *)buf);
  }

  if(!(debug == 0))
    fprintf(stderr, "writer_audio_thread done\n");

  return (void *)0;
}

// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_video_buf *buf;
  struct ng_video_buf *reorder[32l];
  signed int seq;
  signed int slot;
  signed int return_value_getpid_1;
  if(!(debug == 0))
  {
    return_value_getpid_1=getpid();
    fprintf(stderr, "writer_video_thread start [pid=%d]\n", return_value_getpid_1);
  }

  seq = 0;
  memset((void *)&reorder, 0, sizeof(struct ng_video_buf *[32l]) /*256ul*/ );
  do
  {
    void *return_value_fifo_get_2;
    return_value_fifo_get_2=fifo_get(&h->vfifo);
    buf = (struct ng_video_buf *)return_value_fifo_get_2;
    if(buf == ((struct ng_video_buf *)NULL))
      break;

    slot = buf->info.seq % 32;
    if(debug >= 2)
      fprintf(stderr, "video write: get seq=%d [%d]\n", buf->info.seq, slot);

    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      fprintf(stderr, "panic: reorder buffer full\n");
      exit(1);
    }

    reorder[(signed long int)slot] = buf;
    slot = seq % 32;
    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      buf = reorder[(signed long int)slot];
      reorder[(signed long int)slot] = (struct ng_video_buf *)(void *)0;
      if(debug >= 2)
        fprintf(stderr, "video write: put seq=%d [%d/%d]\n", buf->info.seq, slot, seq);

      seq = seq + 1;
      pthread_mutex_lock(&h->lock);
      h->writer->wr_video(h->handle, buf);
      if(!(buf->info.twice == 0))
        h->writer->wr_video(h->handle, buf);

      pthread_mutex_unlock(&h->lock);
      ng_release_video_buf(buf);
    }

  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "writer_video_thread done\n");

  return (void *)0;
}

// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  for( ; !(p == 0); s = s + (signed long int)2)
  {
    d[(signed long int)0] = (unsigned char)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    p = p - 1;
    d = d + 1l;
  }
}

// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    d[(signed long int)0] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)1] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)2] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    d[(signed long int)3] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)4] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)5] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    d = d + (signed long int)6;
    s = s + (signed long int)4;
  }
}

// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_2 = d;
      d = d + 1l;
      *tmp_post_2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_3 = d;
      d = d + 1l;
      *tmp_post_3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post_4 = d;
      d = d + 1l;
      *tmp_post_4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post_5 = d;
      d = d + 1l;
      *tmp_post_5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post_6 = d;
      d = d + 1l;
      *tmp_post_6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  dp = out->data;
  y = in->data;
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + 1u)
    {
      *d = (unsigned char)ng_yuv_gray[(signed long int)*y];
      d = d + 1l;
      y = y + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

