// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_0;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_1;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_sockaddr_any
// file ../common/sock_any.h line 48
union _sockaddr_any;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-clctx
// file clamsmtpd.c line 81
struct clctx;

// tag-clstate
// file clamsmtpd.c line 67
struct clstate;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_any
// file ../common/sock_any.h line 46
struct sockaddr_any;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-spctx
// file ../common/smtppass.h line 44
struct spctx;

// tag-spio
// file ../common/smtppass.h line 65
struct spio;

// tag-spstate
// file ../common/sppriv.h line 44
struct spstate;

// tag-spthread
// file ../common/smtppass.c line 74
struct spthread;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// asctime_r
// file /usr/include/time.h line 272
extern char * asctime_r(struct tm *, char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cb_check_data
// file clamsmtpd.c line 349
extern signed int cb_check_data(struct spctx *sp);
// cb_del_context
// file clamsmtpd.c line 521
extern void cb_del_context(struct spctx *sp);
// cb_new_context
// file clamsmtpd.c line 507
extern struct spctx * cb_new_context();
// cb_parse_option
// file clamsmtpd.c line 426
extern signed int cb_parse_option(const char *name, const char *value);
// check_first_word
// file ../common/stringx.h line 42
signed int check_first_word(const char *line, const char *word, signed int len, char *delims);
// clam_scan_file
// file clamsmtpd.c line 599
static signed int clam_scan_file(struct clctx *ctx, const char **virus);
// cleanup_context
// file ../common/smtppass.c line 624
static void cleanup_context(struct spctx *ctx);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_raw
// file ../common/spio.c line 70
static void close_raw(signed int *fd);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// connect_clam
// file clamsmtpd.c line 542
static signed int connect_clam(struct clctx *ctx);
// connection_loop
// file ../common/smtppass.c line 455
static void connection_loop(signed int sock);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// disconnect_clam
// file clamsmtpd.c line 583
static signed int disconnect_clam(struct clctx *ctx);
// do_server_noop
// file ../common/smtppass.c line 1759
static void do_server_noop(struct spctx *ctx);
// done_thread
// file ../common/smtppass.c line 668
static void done_thread(struct spctx *ctx);
// drop_privileges
// file ../common/smtppass.c line 383
static void drop_privileges();
// err
// file /usr/include/err.h line 46
extern void err(signed int, const char *, ...);
// errx
// file /usr/include/err.h line 50
extern void errx(signed int, const char *, ...);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fchmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 296
extern signed int fchmod(signed int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_successful_rsp
// file ../common/smtppass.c line 1235
static const char * get_successful_rsp(const char *line, signed int *cont);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_thread
// file ../common/smtppass.c line 590
static struct spctx * init_thread(signed int fd);
// is_blank_line
// file ../common/stringx.h line 45
signed int is_blank_line(const char *line);
// is_first_word
// file ../common/stringx.h line 43
signed int is_first_word(const char *line, const char *word, signed int len);
// is_last_word
// file ../common/stringx.h line 44
signed int is_last_word(const char *line, const char *word, signed int len);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_io_data
// file ../common/spio.c line 78
static void log_io_data(struct spctx *ctx, struct spio *io, const char *data, signed int read);
// make_connections
// file ../common/smtppass.c line 731
static signed int make_connections(struct spctx *ctx, signed int client);
// make_date
// file ../common/smtppass.c line 1413
static void make_date(struct spctx *ctx, char *date);
// make_header
// file ../common/smtppass.c line 1478
static signed int make_header(struct spctx *ctx, const char *format_str, char *header);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// mktemp
// file /usr/include/stdlib.h line 606
extern char * mktemp(char *);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// on_quit
// file ../common/smtppass.c line 378
static void on_quit(signed int signal);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_address
// file ../common/smtppass.c line 1175
static char * parse_address(char *line);
// parse_config_file
// file ../common/smtppass.c line 2023
static signed int parse_config_file(const char *configfile);
// parse_xforward
// file ../common/smtppass.c line 1201
static char * parse_xforward(char *line, const char *part);
// pid_file
// file ../common/smtppass.c line 422
static void pid_file(signed int write);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_4 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_4 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous_4 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_raw
// file ../common/spio.c line 307
signed int read_raw(struct spctx *ctx, struct spio *io, signed int opts);
// read_server_response
// file ../common/smtppass.c line 1736
static signed int read_server_response(struct spctx *ctx);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reallocf
// file ../common/compat.h line 60
void * reallocf(void *ptr, unsigned long int size);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_0 *, struct anonymous_0 *, struct anonymous_0 *, struct timeval *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setreuid
// file /usr/include/unistd.h line 705
extern signed int setreuid(unsigned int, unsigned int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// siginterrupt
// file /usr/include/signal.h line 323
extern signed int siginterrupt(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// smtp_passthru
// file ../common/smtppass.c line 826
static signed int smtp_passthru(struct spctx *ctx);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_any_cmp
// file ../common/sock_any.h line 88
signed int sock_any_cmp(struct sockaddr_any *a1, struct sockaddr_any *a2, signed int opts);
// sock_any_ntop
// file ../common/sock_any.h line 83
signed int sock_any_ntop(struct sockaddr_any *any, char *addr, unsigned long int addrlen, signed int opts);
// sock_any_pton
// file ../common/sock_any.h line 67
signed int sock_any_pton(const char *addr, struct sockaddr_any *any, signed int opts);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sp_add_log
// file ../common/smtppass.h line 189
void sp_add_log(struct spctx *ctx, char *prefix, char *line);
// sp_cache_data
// file ../common/smtppass.h line 212
signed int sp_cache_data(struct spctx *ctx);
// sp_done
// file ../common/smtppass.h line 169
void sp_done();
// sp_done_data
// file ../common/smtppass.h line 218
signed int sp_done_data(struct spctx *ctx, const char *headertmpl);
// sp_fail_data
// file ../common/smtppass.h line 224
signed int sp_fail_data(struct spctx *ctx, const char *smtp_status);
// sp_init
// file ../common/smtppass.h line 145
void sp_init(const char *name);
// sp_is_quit
// file ../common/smtppass.h line 163
signed int sp_is_quit();
// sp_lock
// file ../common/smtppass.c line 1879
void sp_lock();
// sp_message
// file ../common/smtppass.h line 238
void sp_message(struct spctx *ctx, signed int level, const char *msg, ...);
// sp_messagex
// file ../common/smtppass.h line 239
void sp_messagex(struct spctx *ctx, signed int level, const char *msg, ...);
// sp_parse_option
// file ../common/smtppass.h line 177
signed int sp_parse_option(const char *name, const char *value);
// sp_quit
// file ../common/smtppass.c line 355
void sp_quit();
// sp_read_data
// file ../common/smtppass.c line 1288
signed int sp_read_data(struct spctx *ctx, const char **data);
// sp_run
// file ../common/smtppass.h line 151
signed int sp_run(const char *configfile, const char *pidfile, signed int dbg_level);
// sp_setup_forked
// file ../common/smtppass.h line 231
void sp_setup_forked(struct spctx *ctx, signed int file);
// sp_unlock
// file ../common/smtppass.c line 1915
void sp_unlock();
// sp_write_data
// file ../common/smtppass.c line 1327
signed int sp_write_data(struct spctx *ctx, const char *buf, signed int len);
// spio_attach
// file ../common/spio.c line 113
void spio_attach(struct spctx *ctx, struct spio *io, signed int fd, struct sockaddr_any *peer);
// spio_connect
// file ../common/smtppass.h line 89
signed int spio_connect(struct spctx *ctx, struct spio *io, struct sockaddr_any *sany, const char *addrname);
// spio_disconnect
// file ../common/smtppass.h line 90
void spio_disconnect(struct spctx *ctx, struct spio *io);
// spio_init
// file ../common/smtppass.h line 83
void spio_init(struct spio *io, const char *name);
// spio_read_junk
// file ../common/smtppass.h line 107
void spio_read_junk(struct spctx *ctx, struct spio *io);
// spio_read_line
// file ../common/smtppass.h line 98
signed int spio_read_line(struct spctx *ctx, struct spio *io, signed int opts);
// spio_select
// file ../common/spio.c line 205
unsigned int spio_select(struct spctx *ctx, ...);
// spio_write_data
// file ../common/smtppass.h line 102
signed int spio_write_data(struct spctx *ctx, struct spio *io, const char *data);
// spio_write_data_raw
// file ../common/spio.c line 552
signed int spio_write_data_raw(struct spctx *ctx, struct spio *io, const unsigned char *buf, signed int len);
// spio_write_dataf
// file ../common/spio.c line 535
signed int spio_write_dataf(struct spctx *ctx, struct spio *io, const char *fmt, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcat
// file ../common/compat.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../common/compat.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlwr
// file ../common/compat.c line 89
char * strlwr(char *s);
// strncasecmp
// file /usr/include/strings.h line 120
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtob
// file ../common/stringx.h line 51
signed int strtob(const char *str);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strupr
// file ../common/compat.c line 102
char * strupr(char *s);
// thread_main
// file ../common/smtppass.c line 680
static void * thread_main(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// trim_end
// file ../common/stringx.h line 48
char * trim_end(char *data);
// trim_space
// file ../common/stringx.h line 49
char * trim_space(char *data);
// trim_start
// file ../common/stringx.h line 47
char * trim_start(const char *data);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file clamsmtpd.c line 338
static void usage();
// virus_action
// file clamsmtpd.c line 701
static signed int virus_action(struct clctx *ctx, const char *virus);
// vmessage
// file ../common/smtppass.c line 1811
static void vmessage(struct spctx *ctx, signed int level, signed int err, const char *msg, void **ap);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// vwarnx
// file /usr/include/err.h line 42
extern void vwarnx(const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// warnx
// file /usr/include/err.h line 40
extern void warnx(const char *, ...);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_0
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

union anonymous
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_1
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

union _sockaddr_any
{
  // a
  struct sockaddr a;
  // un
  struct sockaddr_un un;
  // in
  struct sockaddr_in in;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct spio
{
  // fd
  signed int fd;
  // name
  const char *name;
  // last_action
  signed long int last_action;
  // peername
  char peername[4096l];
  // localname
  char localname[4096l];
  // line
  char line[4224l];
  // _nx
  char *_nx;
  // _ln
  unsigned long int _ln;
};

struct spctx
{
  // id
  unsigned int id;
  // client
  struct spio client;
  // server
  struct spio server;
  // cachefile
  struct _IO_FILE *cachefile;
  // cachename
  char cachename[4096l];
  // logline
  char logline[768l];
  // sender
  char *sender;
  // recipients
  char *recipients;
  // xforwardaddr
  char *xforwardaddr;
  // xforwardhelo
  char *xforwardhelo;
  // _crlf
  signed int _crlf;
};

struct clctx
{
  // sp
  struct spctx sp;
  // clam
  struct spio clam;
};

struct sockaddr_any
{
  // s
  union _sockaddr_any s;
  // namelen
  unsigned long int namelen;
};

struct clstate
{
  // clamaddr
  struct sockaddr_any clamaddr;
  // clamname
  const char *clamname;
  // directory
  const char *directory;
  // virusaction
  const char *virusaction;
  // action
  signed int action;
  // quarantine
  signed int quarantine;
  // debug_files
  signed int debug_files;
  // header
  const char *header;
};

struct in6_addr
{
  // __in6_u
  union anonymous __in6_u;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct spstate
{
  // debug_level
  signed int debug_level;
  // max_threads
  signed int max_threads;
  // timeout
  struct timeval timeout;
  // keepalives
  signed int keepalives;
  // transparent
  signed int transparent;
  // xclient
  signed int xclient;
  // directory
  const char *directory;
  // user
  const char *user;
  // pidfile
  const char *pidfile;
  // header
  const char *header;
  // outaddr
  struct sockaddr_any outaddr;
  // outname
  const char *outname;
  // listenaddr
  struct sockaddr_any listenaddr;
  // listenname
  const char *listenname;
  // name
  const char *name;
  // quit
  signed int quit;
  // daemonized
  signed int daemonized;
  // _p
  char *_p;
};

struct spthread
{
  // tid
  unsigned long int tid;
  // fd
  signed int fd;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// __argv
// file clamsmtpd.c line 169
char **__argv;
// g_clstate
// file clamsmtpd.c line 148
struct clstate g_clstate;
// g_mtxattr
// file ../common/smtppass.c line 188
union anonymous_4 g_mtxattr;
// g_mutex
// file ../common/smtppass.c line 187
union anonymous_3 g_mutex;
// g_state
// file ../common/smtppass.c line 185
struct spstate g_state;
// g_unique_id
// file ../common/smtppass.c line 186
unsigned int g_unique_id = (unsigned int)0x00100000;
// kMsgDelimiter
// file ../common/smtppass.c line 1808
const char kMsgDelimiter[3l] = { ':', ' ', 0 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// cb_check_data
// file clamsmtpd.c line 349
extern signed int cb_check_data(struct spctx *sp)
{
  signed int r = 0;
  const char *virus;
  struct clctx *ctx = (struct clctx *)sp;
  r=sp_cache_data(sp);
  if(r >= 1)
  {
    if(ctx->clam.fd == -1)
      r=connect_clam(ctx);

    if(!(r == -1))
      r=clam_scan_file(ctx, &virus);

  }

  signed int return_value_sp_fail_data_1;
  signed int return_value_sp_done_data_2;
  signed int return_value_sp_fail_data_3;
  signed int return_value_sp_fail_data_4;
  signed int return_value_sp_done_data_5;
  if(!(r == -1))
  {
    if(r == 0)
      goto __CPROVER_DUMP_L5;

    if(r == 1)
      goto __CPROVER_DUMP_L7;

  }

  else
  {
    return_value_sp_fail_data_1=sp_fail_data(sp, (const char *)(void *)0);
    if(return_value_sp_fail_data_1 == -1)
      return -1;

    goto __CPROVER_DUMP_L17;

  __CPROVER_DUMP_L5:
    ;
    return_value_sp_done_data_2=sp_done_data(sp, g_clstate.header);
    if(return_value_sp_done_data_2 == -1)
      return -1;

    goto __CPROVER_DUMP_L17;

  __CPROVER_DUMP_L7:
    ;
    virus_action(ctx, virus);
    switch(g_clstate.action)
    {
      case 0:
      {
        return_value_sp_fail_data_3=sp_fail_data(sp, "250 Virus Detected; Discarded Email\r\n");
        if(return_value_sp_fail_data_3 == -1)
          return -1;

        break;
      }
      case 1:
      {
        return_value_sp_fail_data_4=sp_fail_data(sp, "550 Virus Detected; Content Rejected\r\n");
        if(return_value_sp_fail_data_4 == -1)
          return -1;

        break;
      }
      case 2:
      {
        return_value_sp_done_data_5=sp_done_data(sp, "X-Virus-Infected: Virus Detected!");
        if(return_value_sp_done_data_5 == -1)
          return -1;

        break;
      }
      default:
        ;
    }
    goto __CPROVER_DUMP_L17;
  }
  goto __CPROVER_DUMP_L17;

__CPROVER_DUMP_L17:
  ;
  return 0;
}

// cb_del_context
// file clamsmtpd.c line 521
extern void cb_del_context(struct spctx *sp)
{
  struct clctx *ctx = (struct clctx *)sp;
  signed int x;
  disconnect_clam(ctx);
  free((void *)ctx);
  signed int return_value_waitpid_1;
  if(!(g_clstate.virusaction == ((const char *)NULL)))
    do
    {
      return_value_waitpid_1=waitpid(-1, &x, 1);
      if(!(return_value_waitpid_1 >= 1))
        break;

    }
    while((_Bool)1);

}

// cb_new_context
// file clamsmtpd.c line 507
extern struct spctx * cb_new_context()
{
  struct clctx *ctx;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct clctx) /*42288ul*/ );
  ctx = (struct clctx *)return_value_calloc_1;
  if(ctx == ((struct clctx *)NULL))
  {
    sp_messagex((struct spctx *)(void *)0, 2, "out of memory");
    return (struct spctx *)(void *)0;
  }

  else
  {
    spio_init(&ctx->clam, "CLAMAV");
    return &ctx->sp;
  }
}

// cb_parse_option
// file clamsmtpd.c line 426
extern signed int cb_parse_option(const char *name, const char *value)
{
  signed int return_value_strcasecmp_15;
  return_value_strcasecmp_15=strcasecmp("ClamAddress", name);
  signed int return_value_strcasecmp_14;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_5;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_7;
  if(return_value_strcasecmp_15 == 0)
  {
    signed int return_value_sock_any_pton_1;
    return_value_sock_any_pton_1=sock_any_pton(value, &g_clstate.clamaddr, 0x00100000);
    if(return_value_sock_any_pton_1 == -1)
      errx(2, "invalid ClamAddress socket name: %s", value);

    g_clstate.clamname = value;
    return 1;
  }

  else
  {
    return_value_strcasecmp_14=strcasecmp("ScanHeader", name);
    if(return_value_strcasecmp_14 == 0)
    {
      warnx("please use \"Header\" option instead of \"ScanHeader\"");
      g_clstate.header=trim_start(value);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(g_clstate.header);
      if(return_value_strlen_2 == 0ul)
        g_clstate.header = (const char *)(void *)0;

    }

    else
    {
      return_value_strcasecmp_13=strcasecmp("Header", name);
      if(return_value_strcasecmp_13 == 0)
      {
        g_clstate.header=trim_start(value);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(g_clstate.header);
        if(return_value_strlen_3 == 0ul)
          g_clstate.header = (const char *)(void *)0;

        return 1;
      }

      else
      {
        return_value_strcasecmp_12=strcasecmp("TempDirectory", name);
        if(return_value_strcasecmp_12 == 0)
        {
          g_clstate.directory = value;
          return 1;
        }

        else
        {
          return_value_strcasecmp_11=strcasecmp("Bounce", name);
          if(return_value_strcasecmp_11 == 0)
          {
            signed int bounce;
            bounce=strtob(value);
            if(bounce == -1)
              errx(2, "invalid value for Bounce");

            if(!(bounce == 0))
              g_clstate.action = 1;

            warnx("please use \"Action\" option instead of \"Bounce\"");
            return 1;
          }

          else
          {
            return_value_strcasecmp_10=strcasecmp("Action", name);
            if(return_value_strcasecmp_10 == 0)
            {
              signed int return_value_strcasecmp_6;
              return_value_strcasecmp_6=strcasecmp("bounce", value);
              if(return_value_strcasecmp_6 == 0)
                g_clstate.action = 1;

              else
              {
                return_value_strcasecmp_5=strcasecmp("drop", value);
                if(return_value_strcasecmp_5 == 0)
                  g_clstate.action = 0;

                else
                {
                  return_value_strcasecmp_4=strcasecmp("pass", value);
                  if(return_value_strcasecmp_4 == 0)
                    g_clstate.action = 2;

                  else
                    errx(2, "invalid value for Action");
                }
              }
              return 1;
            }

            else
            {
              return_value_strcasecmp_9=strcasecmp("Quarantine", name);
              if(return_value_strcasecmp_9 == 0)
              {
                g_clstate.quarantine=strtob(value);
                if(g_clstate.quarantine == -1)
                  errx(2, "invalid value for Quarantine");

                return 1;
              }

              else
              {
                return_value_strcasecmp_8=strcasecmp("DebugFiles", name);
                if(return_value_strcasecmp_8 == 0)
                {
                  g_clstate.debug_files=strtob(value);
                  if(g_clstate.debug_files == -1)
                    errx(2, "invalid value for DebugFiles");

                  return 1;
                }

                else
                {
                  return_value_strcasecmp_7=strcasecmp("VirusAction", name);
                  if(return_value_strcasecmp_7 == 0)
                  {
                    g_clstate.virusaction = value;
                    return 1;
                  }

                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// check_first_word
// file ../common/stringx.h line 42
signed int check_first_word(const char *line, const char *word, signed int len, char *delims)
{
  const char *t;
  signed int found = 0;
  t = line;
  char *return_value_strchr_1;
  for( ; !(*t == 0); t = t + 1l)
  {
    return_value_strchr_1=strchr(delims, (signed int)*t);
    if(return_value_strchr_1 == ((char *)NULL))
      break;

  }
  signed int return_value_strncasecmp_2;
  return_value_strncasecmp_2=strncasecmp(t, word, (unsigned long int)len);
  char *return_value_strchr_3;
  if(!(return_value_strncasecmp_2 == 0))
    return 0;

  else
  {
    t = t + (signed long int)len;
    for( ; !(*t == 0); t = t + 1l)
    {
      return_value_strchr_3=strchr(delims, (signed int)*t);
      if(return_value_strchr_3 == ((char *)NULL))
        break;

      found = 1;
    }
    return (signed int)((!(*t != 0) ? (_Bool)1 : (found != 0 ? (_Bool)1 : (_Bool)0)) ? t - line : (signed long int)0);
  }
}

// clam_scan_file
// file clamsmtpd.c line 599
static signed int clam_scan_file(struct clctx *ctx, const char **virus)
{
  signed int len;
  signed int x;
  signed int ret = 0;
  char *line;
  struct spctx *sp = &ctx->sp;
  if(ctx->clam.fd == -1)
  {
    signed int return_value_connect_clam_1;
    return_value_connect_clam_1=connect_clam(ctx);
    if(return_value_connect_clam_1 == -1)
    {
      ret = -1;
      goto cleanup;
    }

  }

  *virus = (const char *)(void *)0;
  line = ctx->clam.line;
  strcpy(line, "SCAN ");
  strcat(line, sp->cachename);
  strcat(line, "\n");
  signed int return_value_spio_write_data_2;
  return_value_spio_write_data_2=spio_write_data(sp, &ctx->clam, line);
  signed int return_value_is_last_word_3;
  signed int return_value_is_last_word_5;
  signed int return_value_is_last_word_6;
  if(return_value_spio_write_data_2 == -1)
    ret = -1;

  else
  {
    len=spio_read_line(sp, &ctx->clam, 0x00000002 | 0x00000001);
    if(len == 0)
    {
      sp_messagex(sp, 3, "clamd disconnected unexpectedly");
      ret = -1;
    }

    else
    {
      return_value_is_last_word_3=is_last_word(line, "OK", (signed int)((sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
      if(!(return_value_is_last_word_3 == 0))
      {
        sp_add_log(sp, "status=", "CLEAN");
        sp_messagex(sp, 7, "no virus");
        ret = 0;
      }

      else
      {
        return_value_is_last_word_5=is_last_word(line, "FOUND", (signed int)((sizeof(char [6l]) /*6ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_last_word_5 == 0))
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(sp->cachename);
          x = (signed int)return_value_strlen_4;
          if(!(5ul + (unsigned long int)x >= (unsigned long int)len))
          {
            line[(signed long int)((unsigned long int)len - (sizeof(char [6l]) /*6ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ )] = (char)0;
            line = line + (signed long int)(x + 1);
            line=trim_space(line);
            sp_messagex(sp, 7, "found virus: %s", line);
            sp_add_log(sp, "status=VIRUS:", line);
            *virus = line;
          }

          else
          {
            sp_messagex(sp, 4, "couldn't parse virus name from clamd response: %s", line);
            sp_add_log(sp, "status=", "VIRUS");
            *virus = "Unparsable.Virus.Name";
          }
          ret = 1;
          goto cleanup;
        }

        return_value_is_last_word_6=is_last_word(line, "ERROR", (signed int)((sizeof(char [6l]) /*6ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_last_word_6 == 0))
        {
          sp_messagex(sp, 3, "clamav error: %s", line);
          sp_add_log(sp, "status=", "CLAMAV-ERROR");
          ret = -1;
        }

        else
        {
          sp_add_log(sp, "status=", "CLAMAV-ERROR");
          sp_messagex(sp, 3, "unexepected response from clamd: %s", line);
          ret = -1;
        }
      }
    }
  }

cleanup:
  ;
  disconnect_clam(ctx);
  return ret;
}

// cleanup_context
// file ../common/smtppass.c line 624
static void cleanup_context(struct spctx *ctx)
{
  if(!(ctx->cachefile == ((struct _IO_FILE *)NULL)))
  {
    fclose(ctx->cachefile);
    ctx->cachefile = (struct _IO_FILE *)(void *)0;
  }

  if(!(ctx->cachename[0l] == 0))
  {
    unlink(ctx->cachename);
    ctx->cachename[(signed long int)0] = (char)0;
  }

  if(!(ctx->recipients == ((char *)NULL)))
  {
    free((void *)ctx->recipients);
    ctx->recipients = (char *)(void *)0;
  }

  if(!(ctx->sender == ((char *)NULL)))
  {
    free((void *)ctx->sender);
    ctx->sender = (char *)(void *)0;
  }

  if(!(ctx->xforwardaddr == ((char *)NULL)))
  {
    free((void *)ctx->xforwardaddr);
    ctx->xforwardaddr = (char *)(void *)0;
  }

  if(!(ctx->xforwardhelo == ((char *)NULL)))
  {
    free((void *)ctx->xforwardhelo);
    ctx->xforwardhelo = (char *)(void *)0;
  }

  ctx->logline[(signed long int)0] = (char)0;
}

// close_raw
// file ../common/spio.c line 70
static void close_raw(signed int *fd)
{
  shutdown(*fd, 2);
  close(*fd);
  *fd = -1;
}

// connect_clam
// file clamsmtpd.c line 542
static signed int connect_clam(struct clctx *ctx)
{
  signed int ret = 0;
  struct spctx *sp = &ctx->sp;
  signed int return_value_spio_connect_1;
  return_value_spio_connect_1=spio_connect(sp, &ctx->clam, &g_clstate.clamaddr, g_clstate.clamname);
  if(return_value_spio_connect_1 == -1)
    ret = -1;

  else
    spio_read_junk(sp, &ctx->clam);

cleanup:
  ;
  if(!(ret >= 0))
  {
    if(!(ctx->clam.fd == -1))
      spio_disconnect(sp, &ctx->clam);

  }

  return ret;
}

// connection_loop
// file ../common/smtppass.c line 455
static void connection_loop(signed int sock)
{
  struct spthread *threads = (struct spthread *)(void *)0;
  signed int fd;
  signed int i;
  signed int x;
  signed int r;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)g_state.max_threads, sizeof(struct spthread) /*16ul*/ );
  threads = (struct spthread *)return_value_calloc_1;
  signed int return_value_sp_is_quit_2;
  _Bool tmp_if_expr_7;
  signed int return_value_setsockopt_6;
  if(threads == ((struct spthread *)NULL))
    sp_messagex((struct spctx *)(void *)0, 2, "out of memory");

  else
  {
    do
    {
      return_value_sp_is_quit_2=sp_is_quit();
      if(!(return_value_sp_is_quit_2 == 0))
        break;

      fd=accept(sock, (void *)0, (unsigned int *)(void *)0);
      if(fd == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        switch(*return_value___errno_location_3)
        {
          case 4:

          case 11:
            break;
          case 103:
          {
            sp_message((struct spctx *)(void *)0, 3, "couldn't accept a connection");
            break;
          }
          default:
            sp_message((struct spctx *)(void *)0, 3, "couldn't accept a connection");
        }
        signed int return_value_sp_is_quit_4;
        return_value_sp_is_quit_4=sp_is_quit();
        if(!(return_value_sp_is_quit_4 == 0))
          break;

        continue;
      }

      signed int return_value_setsockopt_5;
      return_value_setsockopt_5=setsockopt(fd, 1, 20, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      if(!(return_value_setsockopt_5 >= 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_setsockopt_6=setsockopt(fd, 1, 21, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
        tmp_if_expr_7 = return_value_setsockopt_6 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        sp_message((struct spctx *)(void *)0, 7, "couldn't set timeouts on incoming connection");

      signed int return_value_fcntl_8;
      return_value_fcntl_8=fcntl(fd, 1, 0);
      fcntl(fd, 2, return_value_fcntl_8 | 1);
      i = 0;
      for( ; !(i >= g_state.max_threads); i = i + 1)
      {
        if(!((threads + (signed long int)i)->tid == 0ul))
        {
          sp_lock();
          x = (threads + (signed long int)i)->fd;
          sp_unlock();
          if(x == -1)
          {
            sp_messagex((struct spctx *)(void *)0, 7, "cleaning up completed thread");
            pthread_join((threads + (signed long int)i)->tid, (void **)(void *)0);
            (threads + (signed long int)i)->tid = (unsigned long int)0;
          }

        }

        if(!(fd == -1))
        {
          if((threads + (signed long int)i)->tid == 0ul)
          {
            (threads + (signed long int)i)->fd = fd;
            r=pthread_create(&(threads + (signed long int)i)->tid, (const union pthread_attr_t *)(void *)0, thread_main, (void *)(threads + (signed long int)i));
            if(!(r == 0))
            {
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              *return_value___errno_location_9 = r;
              sp_message((struct spctx *)(void *)0, 3, "couldn't create thread");
              write(fd, (const void *)"421 Local Error, cannot start thread\r\n", (sizeof(char [39l]) /*39ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ );
              shutdown(fd, 2);
              close(fd);
              fd = -1;
              break;
            }

            sp_messagex((struct spctx *)(void *)0, 7, "created thread for connection");
            fd = -1;
            break;
          }

        }

      }
      if(!(fd == -1))
      {
        sp_messagex((struct spctx *)(void *)0, 3, "too many connections open (max %d). sent busy response", g_state.max_threads);
        write(fd, (const void *)"421 Server busy, too many connections\r\n", (sizeof(char [40l]) /*40ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ );
        shutdown(fd, 2);
        close(fd);
        fd = -1;
      }

    }
    while((_Bool)1);
    sp_messagex((struct spctx *)(void *)0, 7, "waiting for threads to quit");
    i = 0;
    for( ; !(i >= g_state.max_threads); i = i + 1)
      if(!((threads + (signed long int)i)->tid == 0ul))
      {
        if(!((threads + (signed long int)i)->fd == -1))
        {
          sp_lock();
          fd = (threads + (signed long int)i)->fd;
          (threads + (signed long int)i)->fd = -1;
          sp_unlock();
          shutdown(fd, 2);
          close(fd);
        }

        sp_messagex((struct spctx *)(void *)0, 7, "cleaning up completed thread");
        pthread_join((threads + (signed long int)i)->tid, (void **)(void *)0);
        (threads + (signed long int)i)->tid = (unsigned long int)0;
      }

    free((void *)threads);
  }
}

// disconnect_clam
// file clamsmtpd.c line 583
static signed int disconnect_clam(struct clctx *ctx)
{
  struct spctx *sp = &ctx->sp;
  if(ctx->clam.fd == -1)
    return 0;

  else
  {
    spio_disconnect(sp, &ctx->clam);
    return 0;
  }
}

// do_server_noop
// file ../common/smtppass.c line 1759
static void do_server_noop(struct spctx *ctx)
{
  if(!(ctx->server.fd == -1))
  {
    signed int return_value_spio_write_data_1;
    return_value_spio_write_data_1=spio_write_data(ctx, &ctx->server, "NOOP\r\n");
    if(!(return_value_spio_write_data_1 == -1))
      spio_read_line(ctx, &ctx->server, 0x00000002);

  }

}

// done_thread
// file ../common/smtppass.c line 668
static void done_thread(struct spctx *ctx)
{
  spio_disconnect(ctx, &ctx->client);
  spio_disconnect(ctx, &ctx->server);
  cleanup_context(ctx);
  cb_del_context(ctx);
}

// drop_privileges
// file ../common/smtppass.c line 383
static void drop_privileges()
{
  char *t;
  struct passwd *pw;
  unsigned int uid;
  _Bool tmp_if_expr_5;
  signed int return_value_setuid_4;
  if(!(g_state.user == ((const char *)NULL)))
  {
    unsigned int return_value_geteuid_1;
    return_value_geteuid_1=geteuid();
    if(!(return_value_geteuid_1 == 0u))
    {
      sp_messagex((struct spctx *)(void *)0, 4, "must be started as root to switch to user: %s", g_state.user);
      goto __CPROVER_DUMP_L11;
    }

    signed long int return_value_strtol_2;
    return_value_strtol_2=strtol(g_state.user, &t, 10);
    uid = (unsigned int)return_value_strtol_2;
    if(*t == 0)
      pw=getpwuid(uid);

    else
      pw=getpwnam(g_state.user);
    if(pw == ((struct passwd *)NULL))
      errx(1, "couldn't look up user: %s", g_state.user);

    signed int return_value_setgid_3;
    return_value_setgid_3=setgid(pw->pw_gid);
    if(return_value_setgid_3 == -1)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_setuid_4=setuid(pw->pw_uid);
      tmp_if_expr_5 = return_value_setuid_4 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      err(1, "unable to switch to user: %s (uid %d, gid %d)", g_state.user, pw->pw_uid, pw->pw_gid);

    signed int return_value_setreuid_6;
    return_value_setreuid_6=setreuid((unsigned int)-1, (unsigned int)0);
    if(return_value_setreuid_6 == 0)
      err(1, "unable to completely drop privileges");

    sp_messagex((struct spctx *)(void *)0, 7, "switched to user %s (uid %d, gid %d)", g_state.user, pw->pw_uid, pw->pw_gid);
  }

  unsigned int return_value_geteuid_7;
  return_value_geteuid_7=geteuid();
  if(return_value_geteuid_7 == 0u)
    sp_messagex((struct spctx *)(void *)0, 4, "running as root is NOT recommended");


__CPROVER_DUMP_L11:
  ;
}

// get_successful_rsp
// file ../common/smtppass.c line 1235
static const char * get_successful_rsp(const char *line, signed int *cont)
{
  line=trim_start(line);
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_1;
  if((signed int)*line == 50)
  {
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)line[1l]]) == 0)
      goto __CPROVER_DUMP_L4;

    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)line[2l]]) == 0)
      goto __CPROVER_DUMP_L4;

    if((signed int)line[3l] == 32)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)line[(signed long int)3] == 45 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
      goto __CPROVER_DUMP_L4;

    if(!(cont == ((signed int *)NULL)))
      *cont = (signed int)((signed int)line[(signed long int)3] == 45);

    return line + (signed long int)4;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    return (const char *)(void *)0;
  }
}

// init_thread
// file ../common/smtppass.c line 590
static struct spctx * init_thread(signed int fd)
{
  struct spctx *ctx;
  ctx=cb_new_context();
  unsigned int tmp_post_1;
  if(!(ctx == ((struct spctx *)NULL)))
  {
    memset((void *)ctx, 0, sizeof(struct spctx) /*29832ul*/ );
    spio_init(&ctx->server, "SERVER");
    spio_init(&ctx->client, "CLIENT");
    sp_lock();
    tmp_post_1 = g_unique_id;
    g_unique_id = g_unique_id + 1u;
    ctx->id = tmp_post_1;
    if(g_unique_id == 0u)
      g_unique_id = g_unique_id + 1u;

    sp_unlock();
    unsigned long int return_value_pthread_self_2;
    return_value_pthread_self_2=pthread_self();
    sp_messagex(ctx, 7, "processing %d on thread %x", fd, (signed int)return_value_pthread_self_2);
    signed int return_value_make_connections_3;
    return_value_make_connections_3=make_connections(ctx, fd);
    if(return_value_make_connections_3 == -1)
    {
      cb_del_context(ctx);
      ctx = (struct spctx *)(void *)0;
    }

  }

  return ctx;
}

// is_blank_line
// file ../common/stringx.h line 45
signed int is_blank_line(const char *line)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  if(*line == 0)
    return 1;

  else
  {
    for( ; !(*line == 0); line = line + 1l)
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*line]) == 0)
        break;

    }
    return (signed int)((signed int)*line == 0);
  }
}

// is_first_word
// file ../common/stringx.h line 43
signed int is_first_word(const char *line, const char *word, signed int len)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*line == 0); line = line + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*line]) == 0)
      break;

  }
  signed int return_value_strncasecmp_2;
  return_value_strncasecmp_2=strncasecmp(line, word, (unsigned long int)len);
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(!(return_value_strncasecmp_2 == 0))
    return 0;

  else
  {
    line = line + (signed long int)len;
    if(*line == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      tmp_if_expr_4 = ((signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*line] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }
    return (signed int)tmp_if_expr_4;
  }
}

// is_last_word
// file ../common/stringx.h line 44
signed int is_last_word(const char *line, const char *word, signed int len)
{
  const char *t;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(line);
  t = line + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; !(line >= t); t = t - 1l)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)t[-1l]]) == 0)
      break;

  }
  if(!(t + -((signed long int)len) >= line))
    return 0;

  else
  {
    signed int return_value_strncasecmp_3;
    return_value_strncasecmp_3=strncasecmp(t - (signed long int)len, word, (unsigned long int)len);
    return (signed int)(return_value_strncasecmp_3 == 0);
  }
}

// log_io_data
// file ../common/spio.c line 78
static void log_io_data(struct spctx *ctx, struct spio *io, const char *data, signed int read)
{
  char buf[80l];
  signed int pos;
  signed int len;
  const char *tmp_if_expr_3;
  do
  {
    unsigned long int return_value_strspn_1;
    return_value_strspn_1=strspn(data, "\r\n");
    data = data + (signed long int)return_value_strspn_1;
    if(*data == 0)
      break;

    unsigned long int return_value_strcspn_2;
    return_value_strcspn_2=strcspn(data, "\r\n");
    pos = (signed int)return_value_strcspn_2;
    len = pos < 79 ? pos : 79;
    memcpy((void *)buf, (const void *)data, (unsigned long int)len);
    buf[(signed long int)len] = (char)0;
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr_3 = io->name;

    else
      tmp_if_expr_3 = "???   ";
    sp_messagex(ctx, 7, "%s%s%s", tmp_if_expr_3, read != 0 ? " < " : " > ", (const void *)buf);
    data = data + (signed long int)pos;
  }
  while((_Bool)1);
}

// main
// file clamsmtpd.c line 172
signed int main(signed int argc, char **argv)
{
  const char *configfile = "/etc/clamsmtpd.conf";
  const char *pidfile = (const char *)(void *)0;
  signed int dbg_level = -1;
  signed int warnargs = 0;
  signed int ch = 0;
  signed int r;
  char *t;
  __argv = argv;
  memset((void *)&g_clstate, 0, sizeof(struct clstate) /*336ul*/ );
  g_clstate.directory = "/tmp/";
  r=cb_parse_option("ClamAddress", "/var/run/clamav/clamd");
  sp_init("clamsmtpd");
  sp_parse_option("Header", "X-Virus-Scanned: ClamAV using ClamSMTP");
  signed long int return_value_strtol_1;
  do
  {
    ch=getopt(argc, argv, "bc:d:D:f:h:l:m:p:qt:v");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 98:
      {
        r=cb_parse_option("Bounce", "on");
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 99:
      {
        r=cb_parse_option("ClamAddress", "on");
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 100:
      {
        return_value_strtol_1=strtol(optarg, &t, 10);
        dbg_level = (signed int)return_value_strtol_1;
        if(!(*t == 0))
          errx(1, "invalid debug log level");

        dbg_level = dbg_level + 3;
        break;
      }
      case 68:
      {
        r=sp_parse_option("TempDirectory", optarg);
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 102:
      {
        configfile = optarg;
        break;
      }
      case 104:
      {
        r=cb_parse_option("Header", optarg);
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 108:
      {
        r=sp_parse_option("Listen", optarg);
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 109:
      {
        r=sp_parse_option("MaxConnections", optarg);
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 112:
      {
        pidfile = optarg;
        break;
      }
      case 116:
      {
        r=sp_parse_option("TimeOut", optarg);
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 113:
      {
        r=cb_parse_option("Quarantine", "on");
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 118:
      {
        printf("clamsmtpd (version %s)\n", (const void *)"1.10");
        printf("          (config: %s)\n", (const void *)"/etc/clamsmtpd.conf");
        exit(0);
        break;
      }
      case 88:
      {
        r=cb_parse_option("DebugFiles", "on");
        if(!(r >= 0))
          usage();

        warnargs = 1;
        break;
      }
      case 63:

      default:
        usage();
    }
  }
  while((_Bool)1);
  argc = argc - optind;
  argv = argv + (signed long int)optind;
  if(argc >= 2)
    usage();

  if(argc == 1)
  {
    r=sp_parse_option("OutAddress", argv[(signed long int)0]);
    if(!(r >= 0))
      usage();

    warnargs = 1;
  }

  if(!(warnargs == 0))
    warnx("please use configuration file instead of command-line flags: %s", configfile);

  r=sp_run(configfile, pidfile, dbg_level);
  sp_done();
  return r;
}

// make_connections
// file ../common/smtppass.c line 731
static signed int make_connections(struct spctx *ctx, signed int client)
{
  struct sockaddr_any peeraddr;
  struct sockaddr_any addr;
  struct sockaddr_any *outaddr;
  char buf[4096l];
  const char *outname;
  spio_attach(ctx, &ctx->client, client, &peeraddr);
  sp_messagex(ctx, 6, "accepted connection from: %s", (const void *)ctx->client.peername);
  outaddr = &g_state.outaddr;
  outname = g_state.outname;
  _Bool tmp_if_expr_4;
  if(!(g_state.transparent == 0))
  {
    memset((void *)&addr, 0, sizeof(struct sockaddr_any) /*224ul*/ );
    addr.namelen = sizeof(struct sockaddr_any) /*224ul*/ ;
    signed int return_value_getsockname_1;
    return_value_getsockname_1=getsockname(ctx->client.fd, &addr.s.a, (unsigned int *)&addr.namelen);
    if(return_value_getsockname_1 == -1)
    {
      sp_message(ctx, 3, "couldn't get source address for transparent proxying");
      return -1;
    }

    signed int return_value_sock_any_cmp_2;
    return_value_sock_any_cmp_2=sock_any_cmp(&addr, &peeraddr, 0x01000000);
    if(return_value_sock_any_cmp_2 == 0)
    {
      sp_messagex(ctx, 3, "loop detected in transparent proxying");
      return -1;
    }

    outaddr = &addr;
  }

  else
  {
    if((signed int)outaddr->s.a.sa_family == 2)
      tmp_if_expr_4 = outaddr->s.in.sin_addr.s_addr == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      memcpy((void *)&addr, (const void *)&g_state.outaddr, sizeof(struct sockaddr_any) /*224ul*/ );
      memcpy((void *)&addr.s.in.sin_addr, (const void *)&peeraddr.s.in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
      outaddr = &addr;
    }

    else
    {
      signed int return_value_sock_any_pton_3;
      return_value_sock_any_pton_3=sock_any_pton(g_state.outname, &addr, (signed int)(25 & 0xFFFF));
      if(!(return_value_sock_any_pton_3 == -1))
        memcpy((void *)&g_state.outaddr, (const void *)&addr, sizeof(struct sockaddr_any) /*224ul*/ );

      else
        sp_messagex(ctx, 4, "couldn't resolve OutAddress: %s", g_state.outname);
    }
  }
  if(!(outaddr == &g_state.outaddr))
  {
    signed int return_value_sock_any_ntop_5;
    return_value_sock_any_ntop_5=sock_any_ntop(outaddr, buf, (unsigned long int)4096, 0);
    if(!(return_value_sock_any_ntop_5 == -1))
      outname = buf;

    else
      outname = "unknown";
  }

  signed int return_value_spio_connect_6;
  return_value_spio_connect_6=spio_connect(ctx, &ctx->server, outaddr, outname);
  if(return_value_spio_connect_6 == -1)
    return -1;

  else
    return 0;
}

// make_date
// file ../common/smtppass.c line 1413
static void make_date(struct spctx *ctx, char *date)
{
  unsigned long int date_len;
  struct tm t2;
  signed long int t;
  signed long int return_value_time_1;
  return_value_time_1=time(&t);
  _Bool tmp_if_expr_3;
  struct tm *return_value_localtime_r_2;
  if(return_value_time_1 == -1l)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_localtime_r_2=localtime_r(&t, &t2);
    tmp_if_expr_3 = !(return_value_localtime_r_2 != ((struct tm *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  char *return_value_asctime_r_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_asctime_r_4=asctime_r(&t2, date);
    tmp_if_expr_5 = !(return_value_asctime_r_4 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    sp_message(ctx, 4, "unable to get date for header");
    date[(signed long int)0] = (char)0;
  }

  else
  {
    trim_end(date);
    date_len=strlen(date);
    signed long int timezone = t2.tm_gmtoff;
    const char *tzname[2l] = { t2.tm_zone, t2.tm_zone };
    snprintf(date + (signed long int)date_len, (unsigned long int)64 - date_len, " %+03d%02d (%s)", (signed int)(timezone / (signed long int)3600), (signed int)(timezone % (signed long int)3600), tzname[(signed long int)(t2.tm_isdst != 0 ? 1 : 0)]);
    date[(signed long int)(64 - 1)] = (char)0;
  }
}

// make_header
// file ../common/smtppass.c line 1478
static signed int make_header(struct spctx *ctx, const char *format_str, char *header)
{
  char date[64l];
  signed int remaining;
  signed int l;
  const char *f;
  char *p;
  date[(signed long int)0] = (char)0;
  remaining = 1024 - 1;
  p = header;
  f = format_str;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  char *tmp_post_4;
  for( ; remaining >= 1 && !(*f == 0); f = f + 1l)
  {
    if((signed int)*f == 92)
      tmp_if_expr_6 = (signed int)f[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      f = f + 1l;
      switch((signed int)*f)
      {
        case 114:
        {
          *p = (char)13;
          break;
        }
        case 110:
        {
          *p = (char)10;
          break;
        }
        case 116:
        {
          *p = (char)9;
          break;
        }
        default:
          *p = *f;
      }
      p = p + 1l;
      remaining = remaining - 1;
    }

    else
    {
      if((signed int)*f == 37)
        tmp_if_expr_5 = (signed int)f[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        f = f + 1l;
        switch((signed int)*f)
        {
          case 105:
          {
            return_value_strlen_1=strlen(ctx->client.peername);
            l = (signed int)return_value_strlen_1;
            strncpy(p, ctx->client.peername, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 108:
          {
            return_value_strlen_2=strlen(ctx->client.localname);
            l = (signed int)return_value_strlen_2;
            strncpy(p, ctx->client.localname, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 100:
          {
            if((signed int)date[0l] == 0)
              make_date(ctx, date);

            return_value_strlen_3=strlen(date);
            l = (signed int)return_value_strlen_3;
            strncpy(p, date, (unsigned long int)remaining);
            remaining = remaining - l;
            p = p + (signed long int)l;
            break;
          }
          case 37:
          {
            *p = (char)37;
            p = p + 1l;
            break;
          }
          default:
            sp_messagex(ctx, 4, "invalid header symbol: %%%c", *f);
        }
      }

      else
      {
        tmp_post_4 = p;
        p = p + 1l;
        *tmp_post_4 = *f;
        remaining = remaining - 1;
      }
    }
  }
  if(!(p + 1l >= header + 1024l))
    p[(signed long int)1] = (char)0;

  header[(signed long int)(1024 - 1)] = (char)0;
  l = (signed int)(p - header);
  return l >= 1024 ? 1024 - 1 : l;
}

// on_quit
// file ../common/smtppass.c line 378
static void on_quit(signed int signal)
{
  g_state.quit = 1;
}

// parse_address
// file ../common/smtppass.c line 1175
static char * parse_address(char *line)
{
  char *t;
  line=trim_start(line);
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(line, "<>", (unsigned long int)2);
  if(return_value_strncmp_1 == 0)
    return "<>";

  else
    if((signed int)*line == 60)
    {
      t=strchr(line, 62);
      if(t == ((char *)NULL))
        goto __CPROVER_DUMP_L2;

      *t = (char)0;
      line = line + 1l;
      return line;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      char *return_value_trim_end_2;
      return_value_trim_end_2=trim_end(line);
      return return_value_trim_end_2;
    }
}

// parse_config_file
// file ../common/smtppass.c line 2023
static signed int parse_config_file(const char *configfile)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed long int len;
  char *p;
  char *t;
  char *n;
  f=fopen(configfile, "r");
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 2)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 20 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return -1;

    else
      err(1, "couldn't open config file: %s", configfile);
  }

  signed int return_value_fseek_4;
  return_value_fseek_4=fseek(f, (signed long int)0, 2);
  _Bool tmp_if_expr_5;
  if(return_value_fseek_4 == -1)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    len=ftell(f);
    tmp_if_expr_5 = len == (signed long int)-1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_fseek_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_fseek_6=fseek(f, (signed long int)0, 0);
    tmp_if_expr_7 = return_value_fseek_6 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
    err(1, "couldn't seek config file: %s", configfile);

  void *return_value_malloc_8;
  return_value_malloc_8=malloc((unsigned long int)(len + (signed long int)2));
  g_state._p = (char *)return_value_malloc_8;
  if(g_state._p == ((char *)NULL))
    errx(1, "out of memory");

  unsigned long int return_value_fread_9;
  return_value_fread_9=fread((void *)g_state._p, (unsigned long int)1, (unsigned long int)len, f);
  if(!(return_value_fread_9 == (unsigned long int)len))
    err(1, "couldn't read config file: %s", configfile);

  fclose(f);
  sp_messagex((struct spctx *)(void *)0, 7, "read config file: %s", configfile);
  p = g_state._p;
  p[len] = (char)10;
  p[len + (signed long int)1] = (char)0;
  n = g_state._p;
  _Bool tmp_if_expr_10;
  do
  {
    t=strchr(n, 10);
    if(t == ((char *)NULL))
      break;

    *t = (char)0;
    p = n;
    n = t + (signed long int)1;
    p=trim_start(p);
    if((signed int)*p == 0)
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = (signed int)*p == 35 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_10)
    {
      t=strchr(p, 58);
      if(t == ((char *)NULL))
        errx(2, "invalid config line: %s", p);

      *t = (char)0;
      t = t + 1l;
      t=trim_space(t);
      p=trim_space(p);
      signed int return_value_sp_parse_option_11;
      return_value_sp_parse_option_11=sp_parse_option(p, t);
      if(return_value_sp_parse_option_11 == 0)
        errx(2, "invalid config line: %s", p);

      sp_messagex((struct spctx *)(void *)0, 7, "parsed option: %s: %s", p, t);
    }

  }
  while((_Bool)1);
  return 0;
}

// parse_xforward
// file ../common/smtppass.c line 1201
static char * parse_xforward(char *line, const char *part)
{
  char *t;
  char *e;
  t=strcasestr(line, part);
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(part);
    t=trim_start(t + (signed long int)return_value_strlen_1);
    if(!((signed int)*t == 61))
      return (char *)(void *)0;

    else
    {
      t=trim_start(t + (signed long int)1);
      if(*t == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*t == 91)
        {
          t = t + 1l;
          e=strchr(t, 93);
        }

        else
        {
          unsigned long int return_value_strcspn_2;
          return_value_strcspn_2=strcspn(t, " \t");
          e = t + (signed long int)return_value_strcspn_2;
        }
        if(e == ((char *)NULL))
          return (char *)(void *)0;

        else
        {
          *e = (char)0;
          return t;
        }
      }
    }
  }
}

// pid_file
// file ../common/smtppass.c line 422
static void pid_file(signed int write)
{
  if(!(g_state.pidfile == ((const char *)NULL)))
  {
    if(!(write == 0))
    {
      struct _IO_FILE *f;
      f=fopen(g_state.pidfile, "w");
      if(f == ((struct _IO_FILE *)NULL))
        sp_message((struct spctx *)(void *)0, 3, "couldn't open pid file: %s", g_state.pidfile);

      else
      {
        signed int return_value_getpid_1;
        return_value_getpid_1=getpid();
        fprintf(f, "%d\n", (signed int)return_value_getpid_1);
        signed int return_value_ferror_2;
        return_value_ferror_2=ferror(f);
        if(!(return_value_ferror_2 == 0))
          sp_message((struct spctx *)(void *)0, 3, "couldn't write to pid file: %s", g_state.pidfile);

        signed int return_value_fclose_3;
        return_value_fclose_3=fclose(f);
        if(return_value_fclose_3 == -1)
          sp_message((struct spctx *)(void *)0, 3, "couldn't write to pid file: %s", g_state.pidfile);

      }
      sp_messagex((struct spctx *)(void *)0, 7, "wrote pid file: %s", g_state.pidfile);
    }

    else
    {
      unlink(g_state.pidfile);
      sp_messagex((struct spctx *)(void *)0, 7, "removed pid file: %s", g_state.pidfile);
    }
  }

}

// read_raw
// file ../common/spio.c line 307
signed int read_raw(struct spctx *ctx, struct spio *io, signed int opts)
{
  signed int len;
  signed int x;
  signed int count;
  char *at;
  char *p;
  count = 0;
  io->line[(signed long int)0] = (char)0;
  _Bool tmp_if_expr_2;
  if(!(io->_nx == ((char *)NULL)))
    tmp_if_expr_2 = io->_ln > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    void *return_value_memchr_1;
    return_value_memchr_1=memchr((const void *)io->_nx, 10, io->_ln);
    p = (char *)return_value_memchr_1;
    if(!(p == ((char *)NULL)))
    {
      x = (signed int)((p - io->_nx) + (signed long int)1);
      memmove((void *)io->line, (const void *)io->_nx, (unsigned long int)x);
      io->line[(signed long int)x] = (char)0;
      io->_ln = io->_ln - (unsigned long int)x;
      io->_nx = io->_nx + (signed long int)x;
      count = count + x;
      return count;
    }

    memmove((void *)io->line, (const void *)io->_nx, io->_ln);
    count = count + (signed int)io->_ln;
    len = (signed int)(((unsigned long int)(4096 + 128) - io->_ln) - (unsigned long int)1);
    at = io->line + (signed long int)io->_ln;
  }

  else
  {
    len = (4096 + 128) - 1;
    at = io->line;
  }
  const char *tmp_if_expr_6;
  signed int *return_value___errno_location_9;
  const char *tmp_if_expr_7;
  const char *tmp_if_expr_8;
  do
  {
    signed long int return_value_read_3;
    return_value_read_3=read(io->fd, (void *)at, sizeof(char) /*1ul*/  * (unsigned long int)len);
    x = (signed int)return_value_read_3;
    if(x == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 4)
      {
        signed int return_value_sp_is_quit_4;
        return_value_sp_is_quit_4=sp_is_quit();
        if(!(return_value_sp_is_quit_4 == 0))
          return -1;

        continue;
      }

      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      if(*return_value___errno_location_10 == 104)
      {
        if(!(io->name == ((const char *)NULL)))
          tmp_if_expr_6 = io->name;

        else
          tmp_if_expr_6 = "???   ";
        sp_messagex(ctx, 7, "%s: connection disconnected by peer", tmp_if_expr_6);
      }

      else
      {
        return_value___errno_location_9=__errno_location();
        if(*return_value___errno_location_9 == 11)
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr_7 = io->name;

          else
            tmp_if_expr_7 = "???   ";
          sp_messagex(ctx, 4, "%s: network read operation timed out", tmp_if_expr_7);
        }

        else
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr_8 = io->name;

          else
            tmp_if_expr_8 = "???   ";
          sp_message(ctx, 3, "%s: couldn't read data from socket", tmp_if_expr_8);
        }
      }
      close_raw(&io->fd);
      return -1;
    }

    else
      if(x == 0)
      {
        io->_nx = (char *)(void *)0;
        io->_ln = (unsigned long int)0;
        return count;
      }

    io->last_action=time((signed long int *)(void *)0);
    void *return_value_memchr_11;
    return_value_memchr_11=memchr((const void *)at, 10, (unsigned long int)x);
    p = (char *)return_value_memchr_11;
    if(!(p == ((char *)NULL)))
    {
      p = p + 1l;
      count = count + (signed int)(p - at);
      len = (signed int)((signed long int)x - (p - at));
      memmove((void *)(p + (signed long int)1), (const void *)p, (unsigned long int)len);
      *p = (char)0;
      io->_nx = p + (signed long int)1;
      io->_ln = (unsigned long int)len;
      return count;
    }

    at = at + (signed long int)x;
    len = len - x;
    count = count + x;
    if(!(len >= 1))
    {
      if(!((0x00000002 & opts) == 0))
      {
        at = (io->line + (signed long int)(4096 + 128)) - (signed long int)128;
        len = 128;
        continue;
      }

      io->_nx = (char *)(void *)0;
      io->_ln = (unsigned long int)0;
      io->line[(signed long int)(4096 + 128)] = (char)0;
      return count;
    }

  }
  while((_Bool)1);
}

// read_server_response
// file ../common/smtppass.c line 1736
static signed int read_server_response(struct spctx *ctx)
{
  signed int r;
  r=spio_read_line(ctx, &ctx->server, 0x00000002);
  if(r == -1)
    return -1;

  else
    if(r == 0)
    {
      sp_messagex(ctx, 3, "server disconnected unexpectedly");
      spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");
      return 0;
    }

    else
    {
      if(r >= 128)
        sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");

      return 0;
    }
}

// reallocf
// file ../common/compat.h line 60
void * reallocf(void *ptr, unsigned long int size)
{
  void *ret;
  ret=realloc(ptr, size);
  if(ret == NULL && !(size == 0ul))
    free(ptr);

  return ret;
}

// smtp_passthru
// file ../common/smtppass.c line 826
static signed int smtp_passthru(struct spctx *ctx)
{
  char *t;
  const char *p;
  signed int r;
  signed int cont;
  signed int ret = 0;
  unsigned int mask;
  signed int neterror = 0;
  signed int first_rsp = 1;
  signed int filter_host = 0;
  signed int xclient_sup = 0;
  signed int xclient_sent = 0;
  signed int return_value_sp_is_quit_1;
  signed int return_value_is_first_word_15;
  signed int return_value_is_first_word_14;
  signed int return_value_is_first_word_11;
  _Bool tmp_if_expr_13;
  signed int return_value_is_first_word_12;
  signed int return_value_is_first_word_10;
  _Bool tmp_if_expr_26;
  signed int return_value_is_first_word_25;
  _Bool tmp_if_expr_28;
  signed int return_value_is_first_word_27;
  _Bool tmp_if_expr_30;
  signed int return_value_is_first_word_29;
  _Bool tmp_if_expr_32;
  signed int return_value_is_first_word_31;
  _Bool tmp_if_expr_34;
  signed int return_value_is_first_word_33;
  _Bool tmp_if_expr_36;
  signed int return_value_is_first_word_35;
  unsigned long int tmp_if_expr_41;
  unsigned long int return_value_strlen_40;
  signed int return_value_is_first_word_49;
  signed int return_value_is_first_word_48;
  do
  {
    return_value_sp_is_quit_1=sp_is_quit();
    if(!(return_value_sp_is_quit_1 == 0))
      break;

    mask=spio_select(ctx, &ctx->client, &ctx->server, (void *)0);
    if(mask == 4294967295u)
    {
      neterror = 1;
      ret = -1;
      break;
    }

    if(!((1u & mask) == 0u))
    {
      r=spio_read_line(ctx, &ctx->client, 0x00000002);
      if(r == -1)
      {
        ret = -1;
        break;
      }

      if(r == 0)
      {
        ret = 0;
        break;
      }

      if(r >= 128)
      {
        signed int return_value_spio_write_data_2;
        return_value_spio_write_data_2=spio_write_data(ctx, &ctx->client, "500 Line too long\r\n");
        if(return_value_spio_write_data_2 == -1)
        {
          ret = -1;
          break;
        }

        continue;
      }

      filter_host = 0;
      if(xclient_sent == 0 && !(g_state.xclient == 0) && !(xclient_sup == 0))
      {
        sp_messagex(ctx, 7, "sending XCLIENT");
        signed int return_value_spio_write_dataf_3;
        return_value_spio_write_dataf_3=spio_write_dataf(ctx, &ctx->server, "XCLIENT ADDR=%s\r\n", (const void *)ctx->client.peername);
        if(return_value_spio_write_dataf_3 == -1)
        {
          ret = -1;
          break;
        }

        signed int return_value_read_server_response_4;
        return_value_read_server_response_4=read_server_response(ctx);
        if(return_value_read_server_response_4 == -1)
        {
          ret = -1;
          break;
        }

        const char *return_value_get_successful_rsp_5;
        return_value_get_successful_rsp_5=get_successful_rsp(ctx->server.line, (signed int *)(void *)0);
        if(return_value_get_successful_rsp_5 == ((const char *)NULL))
          sp_messagex(ctx, 4, "server didn't accept XCLIENT");

        xclient_sent = 1;
      }

      signed int return_value_is_first_word_16;
      return_value_is_first_word_16=is_first_word(ctx->client.line, "DATA", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
      if(!(return_value_is_first_word_16 == 0))
      {
        signed int return_value_spio_write_data_6;
        return_value_spio_write_data_6=spio_write_data(ctx, &ctx->client, "354 Start mail input; end with <CRLF>.<CRLF>\r\n");
        if(return_value_spio_write_data_6 == -1)
        {
          ret = -1;
          break;
        }

        signed int return_value_cb_check_data_7;
        return_value_cb_check_data_7=cb_check_data(ctx);
        if(return_value_cb_check_data_7 == -1)
        {
          ret = -1;
          break;
        }

        sp_messagex(ctx, 6, "%s", (const void *)ctx->logline);
        cleanup_context(ctx);
        continue;
      }

      else
      {
        return_value_is_first_word_15=is_first_word(ctx->client.line, "EHLO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word_15 == 0))
          filter_host = 1;

        else
        {
          return_value_is_first_word_14=is_first_word(ctx->client.line, "HELO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word_14 == 0))
          {
            sp_messagex(ctx, 7, "XCLIENT support assumed");
            xclient_sup = 1;
            filter_host = 1;
          }

          else
          {
            return_value_is_first_word_11=is_first_word(ctx->client.line, "STARTTLS", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word_11 == 0))
              tmp_if_expr_13 = (_Bool)1;

            else
            {
              return_value_is_first_word_12=is_first_word(ctx->client.line, "BDAT", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              tmp_if_expr_13 = return_value_is_first_word_12 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_13)
            {
              sp_messagex(ctx, 7, "ESMTP feature not supported");
              signed int return_value_spio_write_data_8;
              return_value_spio_write_data_8=spio_write_data(ctx, &ctx->client, "502 Command not implemented\r\n");
              if(return_value_spio_write_data_8 == -1)
              {
                ret = -1;
                break;
              }

              continue;
            }

            else
            {
              return_value_is_first_word_10=is_first_word(ctx->client.line, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              if(!(return_value_is_first_word_10 == 0))
              {
                sp_messagex(ctx, 4, "client attempted use of privileged XCLIENT feature");
                signed int return_value_spio_write_data_9;
                return_value_spio_write_data_9=spio_write_data(ctx, &ctx->client, "554 Insufficient authorization\r\n");
                if(return_value_spio_write_data_9 == -1)
                {
                  ret = -1;
                  break;
                }

                continue;
              }

            }
          }
        }
      }
      signed int return_value_spio_write_data_17;
      return_value_spio_write_data_17=spio_write_data(ctx, &ctx->server, ctx->client.line);
      if(return_value_spio_write_data_17 == -1)
      {
        ret = -1;
        break;
      }

      continue;
    }

    if(!((2u & mask) == 0u))
    {
      r=spio_read_line(ctx, &ctx->server, 0x00000002);
      if(r == -1)
      {
        ret = -1;
        break;
      }

      if(r == 0)
      {
        ret = 0;
        break;
      }

      if(r >= 128)
        sp_messagex(ctx, 4, "SMTP response line too long. discarded extra");

      if(!(first_rsp == 0))
      {
        first_rsp = 0;
        signed int return_value_is_first_word_19;
        return_value_is_first_word_19=is_first_word(ctx->server.line, "220", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word_19 == 0))
        {
          sp_messagex(ctx, 7, "intercepting initial response");
          signed int return_value_spio_write_data_18;
          return_value_spio_write_data_18=spio_write_data(ctx, &ctx->client, "220 smtp.passthru\r\n");
          if(return_value_spio_write_data_18 == -1)
          {
            ret = -1;
            break;
          }

          continue;
        }

      }

      p=get_successful_rsp(ctx->server.line, &cont);
      if(!(p == ((const char *)NULL)))
      {
        if(!(filter_host == 0))
        {
          filter_host = 0;
          sp_messagex(ctx, 7, "intercepting host response");
          signed int return_value_spio_write_data_20;
          return_value_spio_write_data_20=spio_write_data(ctx, &ctx->client, cont != 0 ? "250-smtp.passthru\r\n" : "250 smtp.passthru\r\n");
          if(return_value_spio_write_data_20 == -1)
          {
            ret = -1;
            break;
          }

          cleanup_context(ctx);
          continue;
        }

        signed int return_value_is_first_word_37;
        return_value_is_first_word_37=is_first_word(ctx->client.line, "EHLO", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
        if(!(return_value_is_first_word_37 == 0))
        {
          signed int return_value_is_first_word_21;
          return_value_is_first_word_21=is_first_word(p, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word_21 == 0))
          {
            sp_messagex(ctx, 7, "XCLIENT supported");
            xclient_sup = 1;
          }

          signed int return_value_is_first_word_24;
          return_value_is_first_word_24=is_first_word(p, "PIPELINING", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(!(return_value_is_first_word_24 == 0))
            tmp_if_expr_26 = (_Bool)1;

          else
          {
            return_value_is_first_word_25=is_first_word(p, "STARTTLS", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_26 = return_value_is_first_word_25 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_26)
            tmp_if_expr_28 = (_Bool)1;

          else
          {
            return_value_is_first_word_27=is_first_word(p, "CHUNKING", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_28 = return_value_is_first_word_27 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_28)
            tmp_if_expr_30 = (_Bool)1;

          else
          {
            return_value_is_first_word_29=is_first_word(p, "BINARYMIME", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_30 = return_value_is_first_word_29 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_30)
            tmp_if_expr_32 = (_Bool)1;

          else
          {
            return_value_is_first_word_31=is_first_word(p, "CHECKPOINT", (signed int)((sizeof(char [11l]) /*11ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_32 = return_value_is_first_word_31 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_32)
            tmp_if_expr_34 = (_Bool)1;

          else
          {
            return_value_is_first_word_33=is_first_word(p, "XCLIENT", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_34 = return_value_is_first_word_33 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_34)
            tmp_if_expr_36 = (_Bool)1;

          else
          {
            return_value_is_first_word_35=is_first_word(p, "XEXCH50", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            tmp_if_expr_36 = return_value_is_first_word_35 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_36)
          {
            char *return_value_trim_space_22;
            return_value_trim_space_22=trim_space((char *)p);
            sp_messagex(ctx, 7, "filtered ESMTP feature: %s", return_value_trim_space_22);
            if(cont == 0)
            {
              signed int return_value_spio_write_data_23;
              return_value_spio_write_data_23=spio_write_data(ctx, &ctx->client, "250 XFILTERED\r\n");
              if(return_value_spio_write_data_23 == -1)
              {
                ret = -1;
                break;
              }

            }

            continue;
          }

        }

        r=check_first_word(ctx->client.line, "MAIL FROM", (signed int)((sizeof(char [10l]) /*10ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
        if(r >= 1)
        {
          t=parse_address(ctx->client.line + (signed long int)r);
          sp_add_log(ctx, "from=", t);
          unsigned long int return_value_strlen_38;
          return_value_strlen_38=strlen(t);
          void *return_value_reallocf_39;
          return_value_reallocf_39=reallocf((void *)ctx->sender, return_value_strlen_38 + (unsigned long int)1);
          ctx->sender = (char *)return_value_reallocf_39;
          if(!(ctx->sender == ((char *)NULL)))
            strcpy(ctx->sender, t);

        }

        else
        {
          r=check_first_word(ctx->client.line, "RCPT TO", (signed int)((sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n\t :");
          if(r >= 1)
          {
            t=parse_address(ctx->client.line + (signed long int)r);
            sp_add_log(ctx, "to=", t);
            if(!(ctx->recipients == ((char *)NULL)))
            {
              return_value_strlen_40=strlen(ctx->recipients);
              tmp_if_expr_41 = return_value_strlen_40;
            }

            else
              tmp_if_expr_41 = (unsigned long int)0;
            r = (signed int)tmp_if_expr_41;
            unsigned long int return_value_strlen_42;
            return_value_strlen_42=strlen(t);
            void *return_value_reallocf_43;
            return_value_reallocf_43=reallocf((void *)ctx->recipients, (unsigned long int)r + return_value_strlen_42 + (unsigned long int)2);
            ctx->recipients = (char *)return_value_reallocf_43;
            if(!(ctx->recipients == ((char *)NULL)))
            {
              if(!(r == 0))
                strcat(ctx->recipients, "\n");

              else
                ctx->recipients[(signed long int)0] = (char)0;
              strcat(ctx->recipients, t);
            }

          }

          else
          {
            return_value_is_first_word_49=is_first_word(ctx->client.line, "XFORWARD", (signed int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word_49 == 0))
            {
              t=parse_xforward(ctx->client.line + (signed long int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "ADDR");
              if(!(t == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_44;
                return_value_strlen_44=strlen(t);
                void *return_value_reallocf_45;
                return_value_reallocf_45=reallocf((void *)ctx->xforwardaddr, return_value_strlen_44 + (unsigned long int)1);
                ctx->xforwardaddr = (char *)return_value_reallocf_45;
                if(!(ctx->xforwardaddr == ((char *)NULL)))
                  strcpy(ctx->xforwardaddr, t);

              }

              t=parse_xforward(ctx->client.line + (signed long int)((sizeof(char [9l]) /*9ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "HELO");
              if(!(t == ((char *)NULL)))
              {
                unsigned long int return_value_strlen_46;
                return_value_strlen_46=strlen(t);
                void *return_value_reallocf_47;
                return_value_reallocf_47=reallocf((void *)ctx->xforwardhelo, return_value_strlen_46 + (unsigned long int)1);
                ctx->xforwardhelo = (char *)return_value_reallocf_47;
                if(!(ctx->xforwardhelo == ((char *)NULL)))
                  strcpy(ctx->xforwardhelo, t);

              }

            }

            else
            {
              return_value_is_first_word_48=is_first_word(ctx->client.line, "RSET", (signed int)((sizeof(char [5l]) /*5ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
              if(!(return_value_is_first_word_48 == 0))
                cleanup_context(ctx);

            }
          }
        }
      }

      signed int return_value_spio_write_data_50;
      return_value_spio_write_data_50=spio_write_data(ctx, &ctx->client, ctx->server.line);
      if(return_value_spio_write_data_50 == -1)
      {
        ret = -1;
        break;
      }

    }

  }
  while((_Bool)1);

cleanup:
  ;
  if(neterror == 0 && ret == -1)
  {
    if(!(ctx->client.fd == -1))
      spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");

  }

  return ret;
}

// sock_any_cmp
// file ../common/sock_any.h line 88
signed int sock_any_cmp(struct sockaddr_any *a1, struct sockaddr_any *a2, signed int opts)
{
  signed int return_value_strcmp_1;
  signed int return_value_memcmp_2;
  signed int *return_value___errno_location_3;
  if(!(a1->s.a.sa_family == a2->s.a.sa_family))
    return -1;

  else
    switch((signed int)a1->s.a.sa_family)
    {
      case 1:
      {
        return_value_strcmp_1=strcmp(a1->s.un.sun_path, a2->s.un.sun_path);
        return return_value_strcmp_1;
      }
      case 2:
      {
        return_value_memcmp_2=memcmp((const void *)&a1->s.in.sin_addr, (const void *)&a2->s.in.sin_addr, sizeof(struct in_addr) /*4ul*/ );
        if(!(return_value_memcmp_2 == 0))
          return -1;

        if(opts == 0)
        {
          if(!(a1->s.in.sin_port == a2->s.in.sin_port))
            return -1;

        }

        return 0;
      }
      default:
      {
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 97;
        return -1;
      }
    }
}

// sock_any_ntop
// file ../common/sock_any.h line 83
signed int sock_any_ntop(struct sockaddr_any *any, char *addr, unsigned long int addrlen, signed int opts)
{
  signed int len = 0;
  signed int port = 0;
  unsigned long int return_value_strlen_1;
  const char *return_value_inet_ntop_3;
  unsigned short int return_value_ntohs_4;
  signed int *return_value___errno_location_5;
  switch((signed int)any->s.a.sa_family)
  {
    case 1:
    {
      return_value_strlen_1=strlen(any->s.un.sun_path);
      len = (signed int)return_value_strlen_1;
      if(!(addrlen >= (unsigned long int)(1 + len)))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 28;
        return -1;
      }

      strcpy(addr, any->s.un.sun_path);
      break;
    }
    case 2:
    {
      return_value_inet_ntop_3=inet_ntop((signed int)any->s.a.sa_family, (const void *)&any->s.in.sin_addr, addr, (unsigned int)addrlen);
      if(return_value_inet_ntop_3 == ((const char *)NULL))
        return -1;

      return_value_ntohs_4=ntohs(any->s.in.sin_port);
      port = (signed int)return_value_ntohs_4;
      break;
    }
    default:
    {
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 97;
      return -1;
    }
  }
  if((0x01000000 & opts) == 0 && !(port == 0))
  {
    strncat(addr, ":", addrlen);
    addr[(signed long int)(addrlen - (unsigned long int)1)] = (char)0;
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(addr);
    len = (signed int)return_value_strlen_6;
    addr = addr + (signed long int)len;
    addrlen = addrlen - (unsigned long int)len;
    snprintf(addr, addrlen, "%d", port);
  }

  return 0;
}

// sock_any_pton
// file ../common/sock_any.h line 67
signed int sock_any_pton(const char *addr, struct sockaddr_any *any, signed int opts)
{
  unsigned long int l;
  char buf[256l];
  char *t;
  char *t2;
  signed int defport = opts & 0xFFFF;
  memset((void *)any, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  signed int sock_any_pton__1__1__port = 0;
  l=strspn(addr, "0123456789");
  _Bool tmp_if_expr_1;
  if(l >= 6ul || !(l >= 1ul))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)addr[(signed long int)l] != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    signed long int return_value_strtol_2;
    return_value_strtol_2=strtol(addr, &t2, 10);
    sock_any_pton__1__1__port = (signed int)return_value_strtol_2;
    if(!(sock_any_pton__1__1__port >= 65536) && *t2 == 0 && sock_any_pton__1__1__port >= 1)
    {
      any->s.in.sin_port=htons((unsigned short int)sock_any_pton__1__1__port);
      any->s.in.sin_family = (unsigned short int)2;
      if(!((0x00100000 & opts) == 0))
        any->s.in.sin_addr.s_addr=htonl((unsigned int)0x7f000001);

      any->namelen = sizeof(struct sockaddr_in) /*16ul*/ ;
      return 2;
    }

  }

  signed int port = 0;
  t = (char *)(void *)0;
  l=strlen(addr);
  if(!(l >= 22ul) && l >= 3ul)
  {
    strcpy(buf, addr);
    l=strspn(buf, "0123456789.");
    if(l >= 3ul)
    {
      if(!((signed int)buf[(signed long int)l] == 0))
      {
        if((signed int)buf[(signed long int)l] == 58)
          goto __CPROVER_DUMP_L10;

      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        if(!((signed int)buf[(signed long int)l] == 0))
        {
          t = buf + (signed long int)l + (signed long int)1;
          buf[(signed long int)l] = (char)0;
        }

        if(!(t == ((char *)NULL)))
        {
          signed long int return_value_strtol_3;
          return_value_strtol_3=strtol(t, &t2, 10);
          port = (signed int)return_value_strtol_3;
          if(port >= 65536 || !(*t2 == 0) || !(port >= 1))
            goto __CPROVER_DUMP_L15;

        }

        any->s.in.sin_family = (unsigned short int)2;
        any->s.in.sin_port=htons((unsigned short int)(port <= 0 ? defport : port));
        signed int return_value_inet_pton_4;
        return_value_inet_pton_4=inet_pton(2, buf, (void *)&any->s.in.sin_addr);
        if(return_value_inet_pton_4 >= 1)
        {
          any->namelen = sizeof(struct sockaddr_in) /*16ul*/ ;
          return 2;
        }

      }
    }

  }


__CPROVER_DUMP_L15:
  ;
  char *return_value_strchr_5;
  return_value_strchr_5=strchr(addr, 58);
  _Bool tmp_if_expr_7;
  char *return_value_strchr_6;
  if(!(return_value_strchr_5 == ((char *)NULL)))
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strchr_6=strchr(addr, 47);
    tmp_if_expr_7 = !(return_value_strchr_6 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_7)
  {
    l=strlen(addr);
    if(!(l >= sizeof(char [108l]) /*108ul*/ ))
    {
      any->s.un.sun_family = (unsigned short int)1;
      strcpy(any->s.un.sun_path, addr);
      any->namelen = sizeof(struct sockaddr_un) /*110ul*/  - (sizeof(char [108l]) /*108ul*/  - l);
      return 1;
    }

  }

  struct addrinfo *res;
  signed int sock_any_pton__1__4__port = 0;
  t = (char *)(void *)0;
  l=strlen(addr);
  _Bool tmp_if_expr_9;
  const unsigned short int **return_value___ctype_b_loc_8;
  if(l >= 255ul)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value___ctype_b_loc_8=__ctype_b_loc();
    tmp_if_expr_9 = !(((signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)addr[(signed long int)0]] & (signed int)(unsigned short int)1024) != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_9)
  {
    unsigned long int return_value_strcspn_10;
    return_value_strcspn_10=strcspn(addr, " /\\");
    if(return_value_strcspn_10 == l)
    {
      strcpy(buf, addr);
      t=strchr(buf, 58);
      if(!(t == ((char *)NULL)))
      {
        *t = (char)0;
        t = t + 1l;
      }

      if(!(t == ((char *)NULL)))
      {
        signed long int return_value_strtol_11;
        return_value_strtol_11=strtol(t, &t2, 10);
        sock_any_pton__1__4__port = (signed int)return_value_strtol_11;
        if(sock_any_pton__1__4__port >= 65536 || !(*t2 == 0) || !(sock_any_pton__1__4__port >= 1))
          goto __CPROVER_DUMP_L30;

      }

      signed int return_value_getaddrinfo_12;
      return_value_getaddrinfo_12=getaddrinfo(buf, (const char *)(void *)0, (struct addrinfo *)(void *)0, &res);
      if(!(res == ((struct addrinfo *)NULL)) && return_value_getaddrinfo_12 == 0)
      {
        memcpy((void *)&any->s.a, (const void *)res->ai_addr, sizeof(struct sockaddr) /*16ul*/ );
        any->namelen = (unsigned long int)res->ai_addrlen;
        freeaddrinfo(res);
        unsigned short int return_value_htons_13;
        return_value_htons_13=htons((unsigned short int)(sock_any_pton__1__4__port <= 0 ? defport : sock_any_pton__1__4__port));
        sock_any_pton__1__4__port = (signed int)return_value_htons_13;
        if((signed int)any->s.a.sa_family == 2)
          any->s.in.sin_port = (unsigned short int)sock_any_pton__1__4__port;

        return (signed int)any->s.a.sa_family;
      }

    }

  }


__CPROVER_DUMP_L30:
  ;
  return -1;
}

// sp_add_log
// file ../common/smtppass.h line 189
void sp_add_log(struct spctx *ctx, char *prefix, char *line)
{
  char *t = ctx->logline;
  signed int l;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(t);
  l = (signed int)return_value_strlen_1;
  signed int x;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(prefix);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(line);
  x = (signed int)((unsigned long int)2 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)1);
  if(l + x >= 768)
    l = 768 - x;

  t = t + (signed long int)l;
  l = 768 - l;
  *t = (char)0;
  if(!((signed int)ctx->logline[0l] == 0))
    strlcat(t, ", ", (unsigned long int)l);

  strlcat(t, prefix, (unsigned long int)l);
  line=trim_start(line);
  strlcat(t, line, (unsigned long int)l);
  trim_end(t);
}

// sp_cache_data
// file ../common/smtppass.h line 212
signed int sp_cache_data(struct spctx *ctx)
{
  signed int r;
  signed int count = 0;
  const char *data;
  do
  {
    r=sp_read_data(ctx, &data);
    if(r == 0)
      break;

    if(!(r >= 0))
      return -1;

    count = count + r;
    r=sp_write_data(ctx, data, r);
    if(!(r >= 0))
      return -1;

  }
  while((_Bool)1);
  signed int return_value_sp_write_data_1;
  return_value_sp_write_data_1=sp_write_data(ctx, (const char *)(void *)0, 0);
  if(!(return_value_sp_write_data_1 >= 0))
    return -1;

  else
  {
    sp_messagex(ctx, 7, "wrote %d bytes to cache", count);
    return count;
  }
}

// sp_done
// file ../common/smtppass.h line 169
void sp_done()
{
  pthread_mutex_destroy(&g_mutex);
  pthread_mutexattr_destroy(&g_mtxattr);
  if(!(g_state._p == ((char *)NULL)))
    free((void *)g_state._p);

  memset((void *)&g_state, 0, sizeof(struct spstate) /*784ul*/ );
}

// sp_done_data
// file ../common/smtppass.h line 218
signed int sp_done_data(struct spctx *ctx, const char *headertmpl)
{
  struct _IO_FILE *file = ((struct _IO_FILE *)NULL);
  signed int ret = 0;
  char *line;
  char header[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned long int header_len;
  unsigned long int line_len;
  signed int header_prepend = 0;
  signed long int rc;
  memset((void *)header, 0, sizeof(char [1024l]) /*1024ul*/ );
  line_len = (unsigned long int)(4096 + 128);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(line_len);
  line = (char *)return_value_malloc_1;
  signed int return_value_spio_write_data_2;
  signed int return_value_read_server_response_3;
  signed int return_value_is_first_word_5;
  _Bool tmp_if_expr_10;
  signed int return_value_spio_write_data_raw_9;
  _Bool tmp_if_expr_14;
  signed int return_value_spio_write_data_raw_13;
  signed int return_value_ferror_17;
  signed int return_value_ferror_18;
  _Bool tmp_if_expr_20;
  signed int return_value_spio_write_data_19;
  signed int return_value_read_server_response_21;
  signed int return_value_spio_write_data_22;
  if(line == ((char *)NULL))
    ret = -1;

  else
  {
    file=fopen(ctx->cachename, "r");
    if(file == ((struct _IO_FILE *)NULL))
    {
      sp_message(ctx, 3, "couldn't open cache file: %s", (const void *)ctx->cachename);
      ret = -1;
    }

    else
    {
      return_value_spio_write_data_2=spio_write_data(ctx, &ctx->server, "DATA\r\n");
      if(return_value_spio_write_data_2 == -1)
        ret = -1;

      else
      {
        return_value_read_server_response_3=read_server_response(ctx);
        if(return_value_read_server_response_3 == -1)
          ret = -1;

        else
        {
          return_value_is_first_word_5=is_first_word(ctx->server.line, "354", (signed int)((sizeof(char [4l]) /*4ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
          if(return_value_is_first_word_5 == 0)
          {
            signed int return_value_spio_write_data_4;
            return_value_spio_write_data_4=spio_write_data(ctx, &ctx->client, ctx->server.line);
            if(return_value_spio_write_data_4 == -1)
            {
              ret = -1;
              goto cleanup;
            }

            sp_messagex(ctx, 7, "server refused data transfer");
            ret = 0;
            goto cleanup;
          }

          sp_messagex(ctx, 7, "sending from cache file: %s", (const void *)ctx->cachename);
          if(!(headertmpl == ((const char *)NULL)))
          {
            signed int return_value_make_header_6;
            return_value_make_header_6=make_header(ctx, headertmpl, header);
            header_len = (unsigned long int)return_value_make_header_6;
            signed int return_value_is_first_word_7;
            return_value_is_first_word_7=is_first_word("Received:", header, (signed int)((sizeof(char [10l]) /*10ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
            if(!(return_value_is_first_word_7 == 0))
              header_prepend = 1;

          }

          if(!((signed int)header[0l] == 0))
          {
            if(!(header_prepend == 0))
            {
              signed int return_value_spio_write_data_raw_8;
              return_value_spio_write_data_raw_8=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)header, (signed int)header_len);
              if(return_value_spio_write_data_raw_8 == -1)
                tmp_if_expr_10 = (_Bool)1;

              else
              {
                return_value_spio_write_data_raw_9=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)"\r\n", (signed int)((sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                tmp_if_expr_10 = return_value_spio_write_data_raw_9 == -1 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_10)
              {
                ret = -1;
                goto cleanup;
              }

              header[(signed long int)0] = (char)0;
            }

          }

          do
          {
            rc=getline(&line, &line_len, file);
            if(rc == -1l)
              break;

            signed int return_value_strcmp_11;
            return_value_strcmp_11=strcmp(line, ".\r\n");
            if(return_value_strcmp_11 == 0)
              strncpy(line, ". \r\n", (unsigned long int)(4096 + 128));

            if(!((signed int)header[0l] == 0))
            {
              signed int return_value_is_blank_line_15;
              return_value_is_blank_line_15=is_blank_line(line);
              if(!(return_value_is_blank_line_15 == 0))
              {
                signed int return_value_spio_write_data_raw_12;
                return_value_spio_write_data_raw_12=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)header, (signed int)header_len);
                if(return_value_spio_write_data_raw_12 == -1)
                  tmp_if_expr_14 = (_Bool)1;

                else
                {
                  return_value_spio_write_data_raw_13=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)"\r\n", (signed int)((sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
                  tmp_if_expr_14 = return_value_spio_write_data_raw_13 == -1 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_14)
                {
                  ret = -1;
                  goto cleanup;
                }

                header[(signed long int)0] = (char)0;
              }

            }

            signed int return_value_spio_write_data_raw_16;
            return_value_spio_write_data_raw_16=spio_write_data_raw(ctx, &ctx->server, (unsigned char *)line, (signed int)rc);
            if(return_value_spio_write_data_raw_16 == -1)
            {
              ret = -1;
              goto cleanup;
            }

          }
          while((_Bool)1);
          return_value_ferror_17=ferror(file);
          if(!(return_value_ferror_17 == 0))
            sp_message(ctx, 3, "error reading cache file: %s", (const void *)ctx->cachename);

          return_value_ferror_18=ferror(file);
          if(!(return_value_ferror_18 == 0))
            tmp_if_expr_20 = (_Bool)1;

          else
          {
            return_value_spio_write_data_19=spio_write_data(ctx, &ctx->server, ".\r\n");
            tmp_if_expr_20 = return_value_spio_write_data_19 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_20)
          {
            spio_write_data(ctx, &ctx->client, "451 Local Error\r\n");
            ret = -1;
          }

          else
          {
            sp_messagex(ctx, 7, "sent email data");
            return_value_read_server_response_21=read_server_response(ctx);
            if(return_value_read_server_response_21 == -1)
              ret = -1;

            else
            {
              return_value_spio_write_data_22=spio_write_data(ctx, &ctx->client, ctx->server.line);
              if(return_value_spio_write_data_22 == -1)
                ret = -1;

            }
          }
        }
      }
    }
  }

cleanup:
  ;
  if(!(line == ((char *)NULL)))
    free((void *)line);

  if(!(file == ((struct _IO_FILE *)NULL)))
    fclose(file);

  return ret;
}

// sp_fail_data
// file ../common/smtppass.h line 224
signed int sp_fail_data(struct spctx *ctx, const char *smtp_status)
{
  char buf[281l];
  char *t = (char *)(void *)0;
  signed int len;
  signed int x;
  signed int pref = 0;
  signed int crlf = 0;
  if(smtp_status == ((const char *)NULL))
    smtp_status = "451 Local Error\r\n";

  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(smtp_status, &t, 10);
  x = (signed int)return_value_strtol_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(smtp_status);
  len = (signed int)return_value_strlen_2;
  if(x == 0 || !(t == smtp_status + 3l))
    pref = 1;

  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(smtp_status + (signed long int)((unsigned long int)len - (sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ), "\r\n");
  if(!(return_value_strcmp_3 == 0))
    crlf = 1;

  if(!(crlf == 0) || !(pref == 0))
  {
    snprintf(buf, sizeof(char [281l]) /*281ul*/ , "%s%.256s%s", pref != 0 ? "550 Content Rejected; " : "", smtp_status, crlf != 0 ? "\r\n" : "");
    buf[(signed long int)(sizeof(char [281l]) /*281ul*/  - (unsigned long int)1)] = (char)0;
    smtp_status = buf;
  }

  signed int return_value_spio_write_data_4;
  return_value_spio_write_data_4=spio_write_data(ctx, &ctx->client, smtp_status);
  _Bool tmp_if_expr_7;
  signed int return_value_read_server_response_6;
  if(return_value_spio_write_data_4 == -1)
    return -1;

  else
  {
    signed int return_value_spio_write_data_5;
    return_value_spio_write_data_5=spio_write_data(ctx, &ctx->server, "RSET\r\n");
    if(return_value_spio_write_data_5 == -1)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_read_server_response_6=read_server_response(ctx);
      tmp_if_expr_7 = return_value_read_server_response_6 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return -1;

    else
      return 0;
  }
}

// sp_init
// file ../common/smtppass.h line 145
void sp_init(const char *name)
{
  signed int r;
  memset((void *)&g_state, 0, sizeof(struct spstate) /*784ul*/ );
  sp_message((struct spctx *)(void *)0, 7, "%s (%s)", name, (const void *)"1.10");
  g_state.debug_level = -1;
  g_state.max_threads = 64;
  g_state.timeout.tv_sec = (signed long int)180;
  g_state.keepalives = 0;
  g_state.directory = "/tmp/";
  g_state.name = name;
  r=sp_parse_option("Listen", "10025");
  signed int return_value_pthread_mutexattr_init_1;
  return_value_pthread_mutexattr_init_1=pthread_mutexattr_init(&g_mtxattr);
  _Bool tmp_if_expr_3;
  signed int return_value_pthread_mutexattr_settype_2;
  if(!(return_value_pthread_mutexattr_init_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_mutexattr_settype_2=pthread_mutexattr_settype(&g_mtxattr, 2);
    tmp_if_expr_3 = return_value_pthread_mutexattr_settype_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_pthread_mutex_init_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_pthread_mutex_init_4=pthread_mutex_init(&g_mutex, &g_mtxattr);
    tmp_if_expr_5 = return_value_pthread_mutex_init_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    errx(1, "threading problem. can't create mutex or condition var");

}

// sp_is_quit
// file ../common/smtppass.h line 163
signed int sp_is_quit()
{
  return g_state.quit != 0 ? 1 : 0;
}

// sp_lock
// file ../common/smtppass.c line 1879
void sp_lock()
{
  signed int r;
  r=pthread_mutex_lock(&g_mutex);
  if(!(r == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = r;
    sp_message((struct spctx *)(void *)0, 2, "threading problem. couldn't lock mutex");
  }

}

// sp_message
// file ../common/smtppass.h line 238
void sp_message(struct spctx *ctx, signed int level, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vmessage(ctx, level, 1, msg, ap);
  ap = ((void **)NULL);
}

// sp_messagex
// file ../common/smtppass.h line 239
void sp_messagex(struct spctx *ctx, signed int level, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vmessage(ctx, level, 0, msg, ap);
  ap = ((void **)NULL);
}

// sp_parse_option
// file ../common/smtppass.h line 177
signed int sp_parse_option(const char *name, const char *value)
{
  char *t;
  signed int ret = 0;
  signed int return_value_strcasecmp_17;
  return_value_strcasecmp_17=strcasecmp("MaxConnections", name);
  signed int return_value_strcasecmp_16;
  signed int return_value_strcasecmp_15;
  signed int return_value_strcasecmp_14;
  signed int return_value_strcasecmp_13;
  signed int return_value_strcasecmp_12;
  signed int return_value_strcasecmp_11;
  signed int return_value_strcasecmp_10;
  signed int return_value_strcasecmp_9;
  signed int return_value_strcasecmp_8;
  if(return_value_strcasecmp_17 == 0)
  {
    signed long int return_value_strtol_1;
    return_value_strtol_1=strtol(value, &t, 10);
    g_state.max_threads = (signed int)return_value_strtol_1;
    if(g_state.max_threads >= 1024 || !(*t == 0) || !(g_state.max_threads >= 2))
      errx(2, "invalid setting: MaxConnections (must be between 1 and 1024)");

    ret = 1;
  }

  else
  {
    return_value_strcasecmp_16=strcasecmp("TimeOut", name);
    if(return_value_strcasecmp_16 == 0)
    {
      g_state.timeout.tv_sec=strtol(value, &t, 10);
      if(!(*t == 0) || !(g_state.timeout.tv_sec >= 1l))
        errx(2, "invalid setting: TimeOut");

      ret = 1;
    }

    else
    {
      return_value_strcasecmp_15=strcasecmp("KeepAlives", name);
      if(return_value_strcasecmp_15 == 0)
      {
        signed long int return_value_strtol_2;
        return_value_strtol_2=strtol(value, &t, 10);
        g_state.keepalives = (signed int)return_value_strtol_2;
        if(!(*t == 0) || !(g_state.keepalives >= 0))
          errx(2, "invalid setting: KeepAlives");

        ret = 1;
      }

      else
      {
        return_value_strcasecmp_14=strcasecmp("XClient", name);
        if(return_value_strcasecmp_14 == 0)
        {
          g_state.xclient=strtob(value);
          if(g_state.xclient == -1)
            errx(2, "invalid value for XClient");

          ret = 1;
        }

        else
        {
          return_value_strcasecmp_13=strcasecmp("OutAddress", name);
          if(return_value_strcasecmp_13 == 0)
          {
            signed int return_value_sock_any_pton_3;
            return_value_sock_any_pton_3=sock_any_pton(value, &g_state.outaddr, (signed int)(25 & 0xFFFF));
            if(return_value_sock_any_pton_3 == -1)
              errx(2, "invalid OutAddress socket name or ip: %s", value);

            g_state.outname = value;
            ret = 1;
          }

          else
          {
            return_value_strcasecmp_12=strcasecmp("Listen", name);
            if(return_value_strcasecmp_12 == 0)
            {
              signed int return_value_sock_any_pton_4;
              return_value_sock_any_pton_4=sock_any_pton(value, &g_state.listenaddr, 0x00000000 | (signed int)(10025 & 0xFFFF));
              if(return_value_sock_any_pton_4 == -1)
                errx(2, "invalid Listen socket name or ip: %s", value);

              g_state.listenname = value;
              ret = 1;
            }

            else
            {
              return_value_strcasecmp_11=strcasecmp("TransparentProxy", name);
              if(return_value_strcasecmp_11 == 0)
              {
                g_state.transparent=strtob(value);
                if(g_state.transparent == -1)
                  errx(2, "invalid value for TransparentProxy");

                ret = 1;
              }

              else
              {
                return_value_strcasecmp_10=strcasecmp("TempDirectory", name);
                if(return_value_strcasecmp_10 == 0)
                {
                  unsigned long int return_value_strlen_5;
                  return_value_strlen_5=strlen(value);
                  if(return_value_strlen_5 == 0ul)
                    errx(2, "invalid setting: TempDirectory");

                  g_state.directory = value;
                  ret = 1;
                }

                else
                {
                  return_value_strcasecmp_9=strcasecmp("User", name);
                  if(return_value_strcasecmp_9 == 0)
                  {
                    unsigned long int return_value_strlen_6;
                    return_value_strlen_6=strlen(value);
                    if(return_value_strlen_6 == 0ul)
                      errx(2, "invalid setting: User");

                    g_state.user = value;
                    ret = 1;
                  }

                  else
                  {
                    return_value_strcasecmp_8=strcasecmp("PidFile", name);
                    if(return_value_strcasecmp_8 == 0)
                    {
                      if(!(g_state.pidfile == ((const char *)NULL)))
                        sp_messagex((struct spctx *)(void *)0, 4, "ignoring pid file specified on the command line. ");

                      unsigned long int return_value_strlen_7;
                      return_value_strlen_7=strlen(value);
                      if(return_value_strlen_7 == 0ul)
                        g_state.pidfile = (const char *)(void *)0;

                      else
                        g_state.pidfile = value;
                      ret = 1;
                    }

                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_cb_parse_option_18;
  return_value_cb_parse_option_18=cb_parse_option(name, value);
  if(return_value_cb_parse_option_18 == 1)
    ret = 1;

  return ret;
}

// sp_quit
// file ../common/smtppass.c line 355
void sp_quit()
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  kill(return_value_getpid_1, 15);
}

// sp_read_data
// file ../common/smtppass.c line 1288
signed int sp_read_data(struct spctx *ctx, const char **data)
{
  signed int r;
  *data = (const char *)(void *)0;
  r=spio_read_line(ctx, &ctx->client, 0x00000004);
  if(!(r == 0))
  {
    if(r == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    sp_messagex(ctx, 3, "unexpected end of data from client");
    return -1;

  __CPROVER_DUMP_L2:
    ;
    return -1;
  }
  if(g_state.keepalives >= 1)
  {
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    if(!(ctx->server.last_action + (signed long int)g_state.keepalives >= return_value_time_1))
      do_server_noop(ctx);

  }

  signed int return_value_strcmp_2;
  if(!(ctx->_crlf == 0))
  {
    return_value_strcmp_2=strcmp(ctx->client.line, ".\r\n");
    if(!(return_value_strcmp_2 == 0))
      goto __CPROVER_DUMP_L6;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp("\r\n", ctx->client.line + (signed long int)((unsigned long int)r - (sizeof(char [3l]) /*3ul*/  - (unsigned long int)1) / sizeof(char) /*1ul*/ ));
    ctx->_crlf = (signed int)(return_value_strcmp_3 == 0);
    *data = ctx->client.line;
    return r;
  }
}

// sp_run
// file ../common/smtppass.h line 151
signed int sp_run(const char *configfile, const char *pidfile, signed int dbg_level)
{
  signed int sock;
  signed int true = 1;
  if(!(dbg_level == -1) && dbg_level >= 8)
    errx(2, "invalid debug log level (must be between 1 and 4)");

  g_state.debug_level = dbg_level;
  g_state.pidfile = pidfile;
  signed int return_value_parse_config_file_1;
  return_value_parse_config_file_1=parse_config_file(configfile);
  if(return_value_parse_config_file_1 == -1)
    warnx("configuration file not found: %s", configfile);

  if(g_state.outname == ((const char *)NULL) && g_state.transparent == 0)
    errx(2, "no OutAddress specified.");

  else
    if(!(g_state.outname == ((const char *)NULL)) && !(g_state.transparent == 0))
      warnx("the OutAddress option will be ignored when TransparentProxy is enabled");

  sp_messagex((struct spctx *)(void *)0, 7, "starting up (%s)...", (const void *)"1.10");
  drop_privileges();
  if(g_state.debug_level == -1)
  {
    signed int return_value_daemon_2;
    return_value_daemon_2=daemon(0, 0);
    if(return_value_daemon_2 == -1)
    {
      sp_message((struct spctx *)(void *)0, 3, "couldn't run as daemon");
      exit(1);
    }

    sp_messagex((struct spctx *)(void *)0, 7, "running as a daemon");
    g_state.daemonized = 1;
    openlog(g_state.name, 0, 2 << 3);
  }

  signal(13, (void (*)(signed int))1);
  signal(1, (void (*)(signed int))1);
  signal(2, on_quit);
  signal(15, on_quit);
  siginterrupt(2, 1);
  siginterrupt(15, 1);
  sock=socket((signed int)g_state.listenaddr.s.a.sa_family, 1, 0);
  if(!(sock >= 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't open socket");
    exit(1);
  }

  signed int return_value_fcntl_3;
  return_value_fcntl_3=fcntl(sock, 1, 0);
  fcntl(sock, 2, return_value_fcntl_3 | 1);
  setsockopt(sock, 1, 2, (void *)&true, (unsigned int)sizeof(signed int) /*4ul*/ );
  if((signed int)g_state.listenaddr.s.a.sa_family == 1)
    unlink(g_state.listenname);

  signed int return_value_bind_4;
  return_value_bind_4=bind(sock, &g_state.listenaddr.s.a, (unsigned int)g_state.listenaddr.namelen);
  if(!(return_value_bind_4 == 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't bind to address: %s", g_state.listenname);
    exit(1);
  }

  sp_messagex((struct spctx *)(void *)0, 7, "created socket: %s", g_state.listenname);
  signed int return_value_listen_5;
  return_value_listen_5=listen(sock, 5);
  if(!(return_value_listen_5 == 0))
  {
    sp_message((struct spctx *)(void *)0, 2, "couldn't listen on socket");
    exit(1);
  }

  pid_file(1);
  sp_messagex((struct spctx *)(void *)0, 7, "accepting connections");
  connection_loop(sock);
  pid_file(0);
  close(sock);
  sp_messagex((struct spctx *)(void *)0, 7, "stopped processing");
  return 0;
}

// sp_setup_forked
// file ../common/smtppass.h line 231
void sp_setup_forked(struct spctx *ctx, signed int file)
{
  signal(13, (void (*)(signed int))0);
  signal(1, (void (*)(signed int))0);
  signal(2, (void (*)(signed int))0);
  signal(15, (void (*)(signed int))0);
  siginterrupt(2, 0);
  siginterrupt(15, 0);
  if(!(ctx->sender == ((char *)NULL)))
    setenv("SENDER", ctx->sender, 1);

  if(!(ctx->recipients == ((char *)NULL)))
    setenv("RECIPIENTS", ctx->recipients, 1);

  if(!(file == 0))
  {
    if(!(ctx->cachename[0l] == 0))
      setenv("EMAIL", ctx->cachename, 1);

  }

  if(!(ctx->client.fd == -1))
    setenv("CLIENT", ctx->client.peername, 1);

  if(!(ctx->xforwardaddr == ((char *)NULL)))
    setenv("REMOTE", ctx->xforwardaddr, 1);

  if(!(ctx->xforwardhelo == ((char *)NULL)))
    setenv("REMOTE_HELO", ctx->xforwardhelo, 1);

  if(!(ctx->server.fd == -1))
    setenv("SERVER", ctx->server.peername, 1);

  setenv("TMPDIR", g_state.directory, 1);
}

// sp_unlock
// file ../common/smtppass.c line 1915
void sp_unlock()
{
  signed int r;
  r=pthread_mutex_unlock(&g_mutex);
  if(!(r == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = r;
    sp_message((struct spctx *)(void *)0, 2, "threading problem. couldn't unlock mutex");
  }

}

// sp_write_data
// file ../common/smtppass.c line 1327
signed int sp_write_data(struct spctx *ctx, const char *buf, signed int len)
{
  signed int r = 0;
  _Bool tmp_if_expr_2;
  if(buf == ((const char *)NULL))
  {
    if(!(ctx->cachefile == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_fclose_1;
      return_value_fclose_1=fclose(ctx->cachefile);
      if(return_value_fclose_1 == -1)
      {
        sp_message(ctx, 3, "couldn't write to cache file: %s", (const void *)ctx->cachename);
        r = -1;
      }

      ctx->cachefile = (struct _IO_FILE *)(void *)0;
    }

    return r;
  }

  else
  {
    if(ctx->cachefile == ((struct _IO_FILE *)NULL))
    {
      signed int tfd;
      if(!(ctx->cachename[0l] == 0))
        unlink(ctx->cachename);

      snprintf(ctx->cachename, (unsigned long int)4096, "%s/%s.XXXXXX", g_state.directory, g_state.name);
      tfd=mkstemp(ctx->cachename);
      if(tfd == -1)
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        ctx->cachefile=fdopen(tfd, "w");
        tmp_if_expr_2 = ctx->cachefile == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
      {
        if(!(tfd == -1))
          close(tfd);

        sp_message(ctx, 3, "couldn't open cache file");
        return -1;
      }

      fchmod(tfd, (unsigned int)0640);
      signed int return_value_fcntl_3;
      return_value_fcntl_3=fcntl(tfd, 1, 0);
      fcntl(tfd, 2, return_value_fcntl_3 | 1);
      sp_messagex(ctx, 7, "created cache file: %s", (const void *)ctx->cachename);
    }

    fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)len, ctx->cachefile);
    signed int return_value_ferror_4;
    return_value_ferror_4=ferror(ctx->cachefile);
    if(!(return_value_ferror_4 == 0))
    {
      sp_message(ctx, 3, "couldn't write to cache file: %s", (const void *)ctx->cachename);
      return -1;
    }

    else
      return len;
  }
}

// spio_attach
// file ../common/spio.c line 113
void spio_attach(struct spctx *ctx, struct spio *io, signed int fd, struct sockaddr_any *peer)
{
  struct sockaddr_any peeraddr;
  struct sockaddr_any locaddr;
  io->fd = fd;
  memset((void *)&locaddr, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  locaddr.namelen = sizeof(struct sockaddr_any) /*224ul*/ ;
  signed int return_value_getsockname_3;
  return_value_getsockname_3=getsockname(fd, &locaddr.s.a, (unsigned int *)&locaddr.namelen);
  _Bool tmp_if_expr_5;
  signed int return_value_sock_any_ntop_4;
  if(return_value_getsockname_3 == -1)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_sock_any_ntop_4=sock_any_ntop(&locaddr, io->localname, (unsigned long int)4096, 0x01000000);
    tmp_if_expr_5 = return_value_sock_any_ntop_4 == -1 ? (_Bool)1 : (_Bool)0;
  }
  const char *tmp_if_expr_1;
  if(tmp_if_expr_5)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 97))
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr_1 = io->name;

      else
        tmp_if_expr_1 = "???   ";
      sp_message(ctx, 4, "%s: couldn't get socket address", tmp_if_expr_1);
    }

    strlcpy(io->localname, "UNKNOWN", (unsigned long int)4096);
  }

  if(peer == ((struct sockaddr_any *)NULL))
    peer = &peeraddr;

  memset((void *)peer, 0, sizeof(struct sockaddr_any) /*224ul*/ );
  peer->namelen = sizeof(struct sockaddr_any) /*224ul*/ ;
  signed int return_value_getpeername_8;
  return_value_getpeername_8=getpeername(fd, &peer->s.a, (unsigned int *)&peer->namelen);
  _Bool tmp_if_expr_10;
  signed int return_value_sock_any_ntop_9;
  if(return_value_getpeername_8 == -1)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_sock_any_ntop_9=sock_any_ntop(peer, io->peername, (unsigned long int)4096, 0x01000000);
    tmp_if_expr_10 = return_value_sock_any_ntop_9 == -1 ? (_Bool)1 : (_Bool)0;
  }
  const char *tmp_if_expr_6;
  if(tmp_if_expr_10)
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    if(!(*return_value___errno_location_7 == 97))
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr_6 = io->name;

      else
        tmp_if_expr_6 = "???   ";
      sp_message(ctx, 4, "%s: couldn't get peer address", tmp_if_expr_6);
    }

    strlcpy(io->peername, "UNKNOWN", (unsigned long int)4096);
  }

  io->line[(signed long int)0] = (char)0;
  io->_nx = (char *)(void *)0;
  io->_ln = (unsigned long int)0;
}

// spio_connect
// file ../common/smtppass.h line 89
signed int spio_connect(struct spctx *ctx, struct spio *io, struct sockaddr_any *sany, const char *addrname)
{
  signed int ret = 0;
  signed int fd;
  fd=socket((signed int)sany->s.a.sa_family, 1, 0);
  signed int return_value_setsockopt_2;
  _Bool tmp_if_expr_4;
  signed int return_value_setsockopt_3;
  const char *tmp_if_expr_1;
  signed int return_value_fcntl_5;
  signed int return_value_connect_6;
  if(fd == -1)
    ret = -1;

  else
  {
    return_value_setsockopt_2=setsockopt(fd, 1, 20, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
    if(return_value_setsockopt_2 == -1)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_setsockopt_3=setsockopt(fd, 1, 21, (const void *)&g_state.timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
      tmp_if_expr_4 = return_value_setsockopt_3 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr_1 = io->name;

      else
        tmp_if_expr_1 = "???   ";
      sp_messagex(ctx, 7, "%s: couldn't set timeouts on connection", tmp_if_expr_1);
    }

    return_value_fcntl_5=fcntl(fd, 1, 0);
    fcntl(fd, 2, return_value_fcntl_5 | 1);
    return_value_connect_6=connect(fd, &sany->s.a, (unsigned int)sany->namelen);
    if(return_value_connect_6 == -1)
    {
      close_raw(&fd);
      ret = -1;
    }

    else
      spio_attach(ctx, io, fd, (struct sockaddr_any *)(void *)0);
  }

cleanup:
  ;
  const char *tmp_if_expr_7;
  const char *tmp_if_expr_8;
  if(!(ret >= 0))
  {
    if(!(io == ((struct spio *)NULL)))
    {
      if(!(io->fd == -1))
        close_raw(&io->fd);

    }

    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr_7 = io->name;

    else
      tmp_if_expr_7 = "???   ";
    sp_message(ctx, 3, "%s: couldn't connect to: %s", tmp_if_expr_7, addrname);
    return -1;
  }

  else
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr_8 = io->name;

    else
      tmp_if_expr_8 = "???   ";
    sp_messagex(ctx, 7, "%s connected to: %s", tmp_if_expr_8, (const void *)io->peername);
    return 0;
  }
}

// spio_disconnect
// file ../common/smtppass.h line 90
void spio_disconnect(struct spctx *ctx, struct spio *io)
{
  const char *tmp_if_expr_1;
  if(!(io == ((struct spio *)NULL)))
  {
    if(!(io->fd == -1))
    {
      close_raw(&io->fd);
      if(!(io->name == ((const char *)NULL)))
        tmp_if_expr_1 = io->name;

      else
        tmp_if_expr_1 = "???   ";
      sp_messagex(ctx, 7, "%s connection closed", tmp_if_expr_1);
    }

  }

}

// spio_init
// file ../common/smtppass.h line 83
void spio_init(struct spio *io, const char *name)
{
  memset((void *)io, 0, sizeof(struct spio) /*12456ul*/ );
  io->name = name;
  io->fd = -1;
}

// spio_read_junk
// file ../common/smtppass.h line 107
void spio_read_junk(struct spctx *ctx, struct spio *io)
{
  char buf[16l];
  const char *t;
  signed int said = 0;
  signed int l;
  io->_ln = (unsigned long int)0;
  io->_nx = ((char *)NULL);
  _Bool tmp_if_expr_1;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr_1 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  const char *tmp_if_expr_4;
  if(tmp_if_expr_1)
  {
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(io->fd, 3, 0);
    fcntl(io->fd, 4, return_value_fcntl_2 | 04000);
    do
    {
      signed long int return_value_read_3;
      return_value_read_3=read(io->fd, (void *)buf, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
      l = (signed int)return_value_read_3;
      if(!(l >= 1))
        break;

      io->last_action=time((signed long int *)(void *)0);
      buf[(signed long int)l] = (char)0;
      t=trim_start(buf);
      if(said == 0)
      {
        if(!(*t == 0))
        {
          if(!(io->name == ((const char *)NULL)))
            tmp_if_expr_4 = io->name;

          else
            tmp_if_expr_4 = "???   ";
          sp_messagex(ctx, 7, "%s: received junk data from daemon", tmp_if_expr_4);
          said = 1;
        }

      }

    }
    while((_Bool)1);
    signed int return_value_fcntl_5;
    return_value_fcntl_5=fcntl(io->fd, 3, 0);
    fcntl(io->fd, 4, return_value_fcntl_5 & ~04000);
  }

}

// spio_read_line
// file ../common/smtppass.h line 98
signed int spio_read_line(struct spctx *ctx, struct spio *io, signed int opts)
{
  signed int x;
  signed int l;
  char *t;
  _Bool tmp_if_expr_2;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr_2 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  const char *tmp_if_expr_1;
  const unsigned short int **return_value___ctype_b_loc_3;
  const unsigned short int **return_value___ctype_b_loc_4;
  if(!tmp_if_expr_2)
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr_1 = io->name;

    else
      tmp_if_expr_1 = "???   ";
    sp_messagex(ctx, 4, "%s: tried to read from a closed connection", tmp_if_expr_1);
    return 0;
  }

  else
  {
    x=read_raw(ctx, io, opts);
    if(x >= 1)
    {
      if(!((0x00000001 & opts) == 0))
      {
        t = io->line;
        for( ; !(*t == 0); t = t + 1l)
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*t]) == 0)
            break;

        }
        l = (signed int)(t - io->line);
        memmove((void *)io->line, (const void *)t, (unsigned long int)((x + 1) - l));
        x = x - l;
        t = io->line + (signed long int)x;
        for( ; !(io->line >= t); x = x - 1)
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)t[-1l]]) == 0)
            break;

          t = t - 1l;
          *t = (char)0;
        }
      }

      if((0x00000004 & opts) == 0)
        log_io_data(ctx, io, io->line, 1);

    }

    return x;
  }
}

// spio_select
// file ../common/spio.c line 205
unsigned int spio_select(struct spctx *ctx, ...)
{
  struct anonymous_0 mask;
  struct spio *io;
  signed int ret = 0;
  signed int have = 0;
  signed int i = 0;
  __builtin_va_list ap;
  struct timeval timeout;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&mask)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  va_start(ap, ctx);
  do
  {
    io=va_arg(ap, __typeof__(io));
    if(io == ((struct spio *)NULL))
      break;

    if(!(io == ((struct spio *)NULL)))
    {
      if(!(io->fd == -1))
      {
        if((unsigned long int)i >= 31ul)
          break;

        if(io->_ln >= 1ul)
          ret = ret | 1 << i;

        (&mask)->__fds_bits[(signed long int)(io->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&mask)->__fds_bits[(signed long int)(io->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << io->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        have = 1;
      }

    }

    i = i + 1;
  }
  while((_Bool)1);
  va_end(ap);
  if(!(ret == 0))
    return (unsigned int)ret;

  else
    if(have == 0)
      return (unsigned int)~0;

    else
    {
      do
      {
        memcpy((void *)&timeout, (const void *)&g_state.timeout, sizeof(struct timeval) /*16ul*/ );
        signed int return_value_select_1;
        return_value_select_1=select(1024, &mask, (struct anonymous_0 *)(void *)0, (struct anonymous_0 *)(void *)0, &timeout);
        if(!(return_value_select_1 == 0))
        {
          if(return_value_select_1 == -1)
            goto __CPROVER_DUMP_L9;

        }

        else
        {
          sp_messagex(ctx, 3, "network operation timed out");
          return (unsigned int)~0;

        __CPROVER_DUMP_L9:
          ;
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(*return_value___errno_location_3 == 4)
          {
            signed int return_value_sp_is_quit_2;
            return_value_sp_is_quit_2=sp_is_quit();
            if(return_value_sp_is_quit_2 == 0)
              continue;

          }

          else
            sp_message(ctx, 3, "couldn't select on sockets");
          return (unsigned int)~0;
        }
        break;
      }
      while((_Bool)1);
      i = 0;
      va_start(ap, ctx);
      do
      {
        io=va_arg(ap, __typeof__(io));
        if(io == ((struct spio *)NULL))
          break;

        if(!(io == ((struct spio *)NULL)))
        {
          if(!(io->fd == -1))
          {
            if((unsigned long int)i >= 31ul)
              break;

            io->last_action=time((signed long int *)(void *)0);
            if(!((mask.__fds_bits[(signed long int)(io->fd / 8)] & (signed long int)(1UL << io->fd % 8)) == 0l))
              ret = ret | 1 << i;

          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      va_end(ap);
      return (unsigned int)ret;
    }
}

// spio_write_data
// file ../common/smtppass.h line 102
signed int spio_write_data(struct spctx *ctx, struct spio *io, const char *data)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(data);
  len = (signed int)return_value_strlen_1;
  _Bool tmp_if_expr_3;
  if(!(io == ((struct spio *)NULL)))
    tmp_if_expr_3 = io->fd != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  const char *tmp_if_expr_2;
  if(!tmp_if_expr_3)
  {
    if(!(io->name == ((const char *)NULL)))
      tmp_if_expr_2 = io->name;

    else
      tmp_if_expr_2 = "???   ";
    sp_message(ctx, 3, "%s: connection closed. can't write data", tmp_if_expr_2);
    return -1;
  }

  else
  {
    log_io_data(ctx, io, data, 0);
    signed int return_value_spio_write_data_raw_4;
    return_value_spio_write_data_raw_4=spio_write_data_raw(ctx, io, (unsigned char *)data, len);
    return return_value_spio_write_data_raw_4;
  }
}

// spio_write_data_raw
// file ../common/spio.c line 552
signed int spio_write_data_raw(struct spctx *ctx, struct spio *io, const unsigned char *buf, signed int len)
{
  signed int r;
  const char *tmp_if_expr_4;
  const char *tmp_if_expr_5;
  if(io->fd == -1)
    return 0;

  else
  {
    io->last_action=time((signed long int *)(void *)0);
    while(len >= 1)
    {
      signed long int return_value_write_1;
      return_value_write_1=write(io->fd, (const void *)buf, (unsigned long int)len);
      r = (signed int)return_value_write_1;
      if(r >= 1)
      {
        buf = buf + (signed long int)r;
        len = len - r;
      }

      else
        if(r == -1)
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(*return_value___errno_location_3 == 4)
          {
            signed int return_value_sp_is_quit_2;
            return_value_sp_is_quit_2=sp_is_quit();
            if(!(return_value_sp_is_quit_2 == 0))
              return -1;

            continue;
          }

          close_raw(&io->fd);
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          if(*return_value___errno_location_6 == 11)
          {
            if(!(io->name == ((const char *)NULL)))
              tmp_if_expr_4 = io->name;

            else
              tmp_if_expr_4 = "???   ";
            sp_messagex(ctx, 4, "%s: network write operation timed out", tmp_if_expr_4);
          }

          else
          {
            if(!(io->name == ((const char *)NULL)))
              tmp_if_expr_5 = io->name;

            else
              tmp_if_expr_5 = "???   ";
            sp_message(ctx, 3, "%s: couldn't write data to socket", tmp_if_expr_5);
          }
          return -1;
        }

    }
    return 0;
  }
}

// spio_write_dataf
// file ../common/spio.c line 535
signed int spio_write_dataf(struct spctx *ctx, struct spio *io, const char *fmt, ...)
{
  char buf[4224l];
  void **ap;
  buf[(signed long int)0] = (char)0;
  ap = (void **)&fmt;
  vsnprintf(buf, (unsigned long int)(4096 + 128), fmt, ap);
  ap = ((void **)NULL);
  buf[(signed long int)((4096 + 128) - 1)] = (char)0;
  signed int return_value_spio_write_data_1;
  return_value_spio_write_data_1=spio_write_data(ctx, io, buf);
  return return_value_spio_write_data_1;
}

// strlcat
// file ../common/compat.h line 84
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    return_value_strlen_2=strlen(s);
    return dlen + return_value_strlen_2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../common/compat.h line 88
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  char *tmp_post_1;
  const char *tmp_post_2;
  if(!(n == 0ul))
  {
    n = n - 1ul;
    if(!(n == 0ul))
      do
      {
        tmp_post_1 = d;
        d = d + 1l;
        tmp_post_2 = s;
        s = s + 1l;
        *tmp_post_1 = *tmp_post_2;
        if((signed int)*tmp_post_1 == 0)
          break;

        n = n - 1ul;
      }
      while(!(n == 0ul));

  }

  const char *tmp_post_3;
  if(n == 0ul)
  {
    if(!(siz == 0ul))
      *d = (char)0;

    do
    {
      tmp_post_3 = s;
      s = s + 1l;
      if(*tmp_post_3 == 0)
        break;

    }
    while((_Bool)1);
  }

  return (unsigned long int)((s - src) - (signed long int)1);
}

// strlwr
// file ../common/compat.c line 89
char * strlwr(char *s)
{
  char *t = s;
  while(!(*t == 0))
  {
    signed int return_value_tolower_1;
    return_value_tolower_1=tolower((signed int)*t);
    *t = (char)return_value_tolower_1;
    t = t + 1l;
  }
  return s;
}

// strtob
// file ../common/stringx.h line 51
signed int strtob(const char *str)
{
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(str, "0");
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcasecmp_2=strcasecmp(str, "no");
    tmp_if_expr_3 = return_value_strcasecmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcasecmp_4=strcasecmp(str, "false");
    tmp_if_expr_5 = return_value_strcasecmp_4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_strcasecmp_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strcasecmp_6=strcasecmp(str, "f");
    tmp_if_expr_7 = return_value_strcasecmp_6 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_strcasecmp_8=strcasecmp(str, "off");
    tmp_if_expr_9 = return_value_strcasecmp_8 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_12;
  signed int return_value_strcasecmp_11;
  _Bool tmp_if_expr_14;
  signed int return_value_strcasecmp_13;
  _Bool tmp_if_expr_16;
  signed int return_value_strcasecmp_15;
  _Bool tmp_if_expr_18;
  signed int return_value_strcasecmp_17;
  if(tmp_if_expr_9)
    return 0;

  else
  {
    signed int return_value_strcasecmp_10;
    return_value_strcasecmp_10=strcasecmp(str, "1");
    if(return_value_strcasecmp_10 == 0)
      tmp_if_expr_12 = (_Bool)1;

    else
    {
      return_value_strcasecmp_11=strcasecmp(str, "yes");
      tmp_if_expr_12 = return_value_strcasecmp_11 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_12)
      tmp_if_expr_14 = (_Bool)1;

    else
    {
      return_value_strcasecmp_13=strcasecmp(str, "true");
      tmp_if_expr_14 = return_value_strcasecmp_13 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_14)
      tmp_if_expr_16 = (_Bool)1;

    else
    {
      return_value_strcasecmp_15=strcasecmp(str, "t");
      tmp_if_expr_16 = return_value_strcasecmp_15 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_16)
      tmp_if_expr_18 = (_Bool)1;

    else
    {
      return_value_strcasecmp_17=strcasecmp(str, "on");
      tmp_if_expr_18 = return_value_strcasecmp_17 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_18)
      return 1;

    else
      return -1;
  }
}

// strupr
// file ../common/compat.c line 102
char * strupr(char *s)
{
  char *t = s;
  while(!(*t == 0))
  {
    signed int return_value_toupper_1;
    return_value_toupper_1=toupper((signed int)*t);
    *t = (char)return_value_toupper_1;
    t = t + 1l;
  }
  return s;
}

// thread_main
// file ../common/smtppass.c line 680
static void * thread_main(void *arg)
{
  struct spthread *thread = (struct spthread *)arg;
  struct spctx *ctx = (struct spctx *)(void *)0;
  signed int processing = 0;
  signed int ret = 0;
  signed int fd;
  siginterrupt(2, 1);
  siginterrupt(15, 1);
  sp_lock();
  fd = thread->fd;
  sp_unlock();
  signed int return_value_sp_is_quit_1;
  return_value_sp_is_quit_1=sp_is_quit();
  _Bool tmp_if_expr_2;
  if(!(return_value_sp_is_quit_1 == 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    ctx=init_thread(fd);
    tmp_if_expr_2 = ctx == (struct spctx *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    close(fd);
    ret = -1;
  }

  else
  {
    processing = 1;
    ret=smtp_passthru(ctx);
  }

cleanup:
  ;
  if(!(ctx == ((struct spctx *)NULL)))
  {
    if(processing == 0 && ret == -1)
    {
      if(!(ctx->client.fd == -1))
        spio_write_data(ctx, &ctx->client, "421 Local Error, cannot start thread\r\n");

    }

    done_thread(ctx);
  }

  sp_lock();
  thread->fd = -1;
  sp_unlock();
  return (void *)(ret == 0 ? 0 : 1);
}

// trim_end
// file ../common/stringx.h line 48
char * trim_end(char *data)
{
  char *t;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(data);
  t = data + (signed long int)return_value_strlen_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  for( ; !(data >= t); *t = (char)0)
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)t[-1l]]) == 0)
      break;

    t = t - 1l;
  }
  return data;
}

// trim_space
// file ../common/stringx.h line 49
char * trim_space(char *data)
{
  char *return_value_trim_start_1;
  return_value_trim_start_1=trim_start(data);
  data = (char *)return_value_trim_start_1;
  char *return_value_trim_end_2;
  return_value_trim_end_2=trim_end(data);
  return return_value_trim_end_2;
}

// trim_start
// file ../common/stringx.h line 47
char * trim_start(const char *data)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*data == 0); data = data + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*data]) == 0)
      break;

  }
  return (char *)data;
}

// usage
// file clamsmtpd.c line 338
static void usage()
{
  fprintf(stderr, "usage: clamsmtpd [-d debuglevel] [-f configfile] [-p pidfile]\n");
  fprintf(stderr, "       clamsmtpd -v\n");
  exit(2);
}

// virus_action
// file clamsmtpd.c line 701
static signed int virus_action(struct clctx *ctx, const char *virus)
{
  char qfilename[4096l];
  struct spctx *sp = &ctx->sp;
  char *t;
  signed int i;
  signed int pid;
  if(!(g_clstate.quarantine == 0))
  {
    strlcpy(qfilename, g_clstate.directory, (unsigned long int)4096);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(qfilename);
    if(!((signed int)qfilename[-1l + (signed long int)return_value_strlen_1] == 47))
      strlcat(qfilename, "/", (unsigned long int)4096);

    strlcat(qfilename, "virus.", (unsigned long int)4096);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(qfilename);
    t = qfilename + (signed long int)return_value_strlen_2;
    do
    {
      *t = (char)0;
      strlcat(qfilename, "XXXXXX", (unsigned long int)4096);
      char *return_value_mktemp_3;
      return_value_mktemp_3=mktemp(qfilename);
      if(return_value_mktemp_3 == ((char *)NULL))
      {
        sp_message(sp, 3, "couldn't create quarantine file name");
        return -1;
      }

      signed int return_value_link_5;
      return_value_link_5=link(sp->cachename, qfilename);
      if(return_value_link_5 == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 17)
        {
          sp_message(sp, 4, "race condition when quarantining virus file: %s", (const void *)qfilename);
          continue;
        }

        sp_message(sp, 3, "couldn't quarantine virus file");
        return -1;
      }

      break;
    }
    while((_Bool)1);
    sp_messagex(sp, 6, "quarantined virus file as: %s", (const void *)qfilename);
  }

  signed int return_value_waitpid_6;
  if(!(g_clstate.virusaction == ((const char *)NULL)))
  {
    do
    {
      return_value_waitpid_6=waitpid(-1, &i, 1);
      if(!(return_value_waitpid_6 >= 1))
        break;

    }
    while((_Bool)1);
    sp_messagex(sp, 7, "executing virus action: %s", g_clstate.virusaction);
    pid=fork();
    if(!(pid == -1))
    {
      if(pid == 0)
        goto __CPROVER_DUMP_L12;

    }

    else
    {
      sp_message(sp, 3, "couldn't fork for virus action");
      return -1;

    __CPROVER_DUMP_L12:
      ;
      i = 0;
      for( ; !(i >= 3); i = i + 1)
        close(i);
      sp_setup_forked(sp, 0);
      if(!(g_clstate.quarantine == 0))
        setenv("EMAIL", qfilename, 1);

      if(!(virus == ((const char *)NULL)))
        setenv("VIRUS", virus, 1);

      execl("/bin/sh", "sh", (const void *)"-c", g_clstate.virusaction, (void *)0);
      _exit(1);
    }
  }

  return 0;
}

// vmessage
// file ../common/smtppass.c line 1811
static void vmessage(struct spctx *ctx, signed int level, signed int err, const char *msg, void **ap)
{
  char buf[1024l];
  signed int e;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  e = *return_value___errno_location_1;
  if(!(g_state.daemonized == 0))
  {
    if(level >= 7)
      goto __CPROVER_DUMP_L9;

  }

  else
    if(!(g_state.debug_level >= level))
      goto __CPROVER_DUMP_L9;

  if(!(ctx == ((struct spctx *)NULL)))
    snprintf(buf, (unsigned long int)1024, "%06X: %s%s", ctx->id, msg, err != 0 ? ": " : "");

  else
    snprintf(buf, (unsigned long int)1024, "%s%s", msg, err != 0 ? ": " : "");
  if(!(err == 0))
  {
    sp_lock();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(e);
    strncat(buf, return_value_strerror_2, (unsigned long int)1024);
    sp_unlock();
  }

  buf[(signed long int)(1024 - 1)] = (char)0;
  if(!(g_state.daemonized == 0))
    vsyslog(level, buf, ap);

  else
    vwarnx(buf, ap);

__CPROVER_DUMP_L9:
  ;
}

