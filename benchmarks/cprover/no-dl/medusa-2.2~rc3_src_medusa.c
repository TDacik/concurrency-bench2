// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_17;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_15;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_1;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_0;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_5;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_6;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_7;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_23;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous_2;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_25;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_10;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_20;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_16;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_24;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_21;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_22;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous_19;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_3;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_18;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_14;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_13;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_11;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_4;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_26;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-SSLSOCKETINFO
// file medusa-net.c line 63
struct SSLSOCKETINFO;

// tag-UT_hash_bucket
// file uthash.h line 859
struct UT_hash_bucket;

// tag-UT_hash_handle
// file uthash.h line 860
struct UT_hash_handle;

// tag-UT_hash_table
// file uthash.h line 883
struct UT_hash_table;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__sAudit
// file medusa.h line 162
struct __sAudit;

// tag-__sConnectParams
// file medusa-net.h line 53
struct __sConnectParams;

// tag-__sCredentialSet
// file medusa.h line 154
struct __sCredentialSet;

// tag-__sHost
// file medusa.h line 131
struct __sHost;

// tag-__sLogin
// file medusa.h line 183
struct __sLogin;

// tag-__sModuleStart
// file medusa.h line 265
struct __sModuleStart;

// tag-__sPass
// file medusa.h line 97
struct __sPass;

// tag-__sServer
// file medusa.h line 161
struct __sServer;

// tag-__sUser
// file medusa.h line 111
struct __sUser;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-active
// file medusa-thread-pool.c line 33
struct active;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-job
// file medusa-thread-pool.c line 23
struct job;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-thr_pool
// file medusa-thread-pool.h line 19
struct thr_pool;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// CRYPTO_free
// file /usr/include/openssl/crypto.h line 536
void CRYPTO_free(void *);
// CRYPTO_malloc
// file /usr/include/openssl/crypto.h line 534
void * CRYPTO_malloc(signed int, const char *, signed int);
// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_id_callback
// file /usr/include/openssl/crypto.h line 462
void CRYPTO_set_id_callback(unsigned long int (*)(void));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CIPHER_get_name
// file /usr/include/openssl/ssl.h line 2145
const char * SSL_CIPHER_get_name(const struct ssl_cipher_st *);
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_default_verify_paths
// file /usr/include/openssl/ssl.h line 2441
signed int SSL_CTX_set_default_verify_paths(struct ssl_ctx_st *);
// SSL_CTX_set_tmp_rsa_callback
// file /usr/include/openssl/ssl.h line 2510
void SSL_CTX_set_tmp_rsa_callback(struct ssl_ctx_st *, struct rsa_st * (*)(struct ssl_st *, signed int, signed int));
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_connect
// file /usr/include/openssl/ssl.h line 2333
signed int SSL_connect(struct ssl_st *);
// SSL_get_current_cipher
// file /usr/include/openssl/ssl.h line 2142
const struct ssl_cipher_st * SSL_get_current_cipher(const struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSLv23_client_method
// file /usr/include/openssl/ssl.h line 2364
const struct ssl_method_st * SSLv23_client_method(void);
// TLSv1_client_method
// file /usr/include/openssl/ssl.h line 2369
const struct ssl_method_st * TLSv1_client_method(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_6 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_6 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_6 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// addMissedCredSet
// file medusa.c line 1452
signed int addMissedCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet);
// alphasort
// file /usr/include/dirent.h line 324
extern signed int alphasort(struct dirent **, struct dirent **);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// base64_decode
// file medusa-utils.c line 96
extern signed int base64_decode(const char *base64, char *to);
// base64_encode
// file medusa-utils.c line 37
extern signed int base64_encode(const char *str, signed int length, char *b64store);
// basic_authentication_encode
// file medusa-utils.c line 177
extern char * basic_authentication_encode(const char *user, const char *passwd);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// checkOptions
// file medusa.c line 98
signed int checkOptions(signed int argc, char **argv, struct __sAudit *_psAudit);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clone_attributes
// file medusa-thread-pool.c line 248
static void clone_attributes(union pthread_attr_t *new_attr, union pthread_attr_t *old_attr);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// create_worker
// file medusa-thread-pool.c line 77
static signed int create_worker(struct thr_pool *pool);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// findLocalPass
// file medusa.c line 881
char * findLocalPass(struct __sAudit *_psAudit);
// findNextHost
// file medusa.c line 684
char * findNextHost(struct __sAudit *_psAudit, char *_pHost);
// findNextUser
// file medusa.c line 807
char * findNextUser(struct __sAudit *_psAudit, char *_pUser);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeModuleParams
// file medusa.c line 40
void freeModuleParams();
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getNextCredSet
// file medusa.c line 1306
signed int getNextCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet);
// getNextMissedCredSet
// file medusa.c line 1258
signed int getNextMissedCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet);
// getNextNormalCredSet
// file medusa.c line 1143
signed int getNextNormalCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet);
// getNextPass
// file medusa.c line 1058
char * getNextPass(struct __sLogin *_psLogin);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// index
// file /usr/include/string.h line 488
extern char * index(const char *, signed int);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// initConnectionParams
// file medusa-net.c line 84
void initConnectionParams(struct __sLogin *pLogin, struct __sConnectParams *pParams);
// init_crypto_locks
// file medusa-thread-ssl.h line 10
extern void init_crypto_locks(void);
// init_locks_openssl
// file medusa-thread-ssl.c line 40
void init_locks_openssl(void);
// invokeModule
// file medusa.c line 365
signed int invokeModule(char *pModuleName, struct __sLogin *pLogin, signed int argc, char **argv);
// invokeModule::1::pGo_object
//
signed int pGo_object(struct __sLogin *, signed int, char **);
// invokeModule::1::pUsage_object
//
void pUsage_object();
// job_cleanup
// file medusa-thread-pool.c line 133
static void job_cleanup(struct thr_pool *pool);
// kill_crypto_locks
// file medusa-thread-ssl.h line 11
extern void kill_crypto_locks(void);
// kill_locks_openssl
// file medusa-thread-ssl.c line 55
void kill_locks_openssl(void);
// listModules
// file listModules.c line 44
void listModules(char **arrPaths, signed int nTerminateNow);
// listModules::1::pSummary_object
//
signed int pSummary_object(char **);
// loadFile
// file medusa.c line 463
void loadFile(char *pFile, char **pFileContent, signed int *iFileCnt);
// loadLoginInfo
// file medusa.c line 913
signed int loadLoginInfo(struct __sAudit *_psAudit);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lock_callback
// file medusa-thread-ssl.c line 20
static void lock_callback(signed int mode, signed int type, char *file, signed int line);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// makeToLower
// file medusa-net.c line 887
extern signed int makeToLower(char *buf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// medusaCheckSocket
// file medusa-net.c line 745
extern signed int medusaCheckSocket(signed int socket, signed int usec);
// medusaConnect
// file medusa-net.c line 616
extern signed int medusaConnect(struct __sConnectParams *pParams);
// medusaConnectInternal
// file medusa-net.c line 102
signed int medusaConnectInternal(unsigned long int nHost, signed int nPort, signed int nProtocol, signed int nType, signed int nWaitTime, signed int nRetries, signed int nRetryWait, unsigned long int nProxyStringIP, signed int nProxyStringPort, char *szProxyAuthentication, signed int nSourcePort);
// medusaConnectSSL
// file medusa-net.c line 622
extern signed int medusaConnectSSL(struct __sConnectParams *pParams);
// medusaConnectSSLInternal
// file medusa-net.c line 334
signed int medusaConnectSSLInternal(struct __sConnectParams *pParams, signed int hSocket);
// medusaConnectSocketSSL
// file medusa-net.c line 642
extern signed int medusaConnectSocketSSL(struct __sConnectParams *pParams, signed int hSocket);
// medusaConnectTCP
// file medusa-net.c line 663
extern signed int medusaConnectTCP(struct __sConnectParams *pParams);
// medusaConnectUDP
// file medusa-net.c line 670
extern signed int medusaConnectUDP(struct __sConnectParams *pParams);
// medusaDataReady
// file medusa-net.c line 739
extern signed int medusaDataReady(signed int socket);
// medusaDataReadyTimed
// file medusa-net.c line 726
extern signed int medusaDataReadyTimed(signed int socket, signed long int sec, signed long int usec);
// medusaDataReadyWriting
// file medusa-net.c line 721
extern signed int medusaDataReadyWriting(signed int socket);
// medusaDataReadyWritingTimed
// file medusa-net.c line 708
extern signed int medusaDataReadyWritingTimed(signed int socket, signed long int sec, signed long int usec);
// medusaDisconnect
// file medusa-net.c line 678
extern signed int medusaDisconnect(signed int hSocket);
// medusaReceive
// file medusa-net.c line 755
extern signed int medusaReceive(signed int socket, unsigned char *buf, signed int length);
// medusaReceiveDataInternal
// file medusa-net.c line 468
unsigned char * medusaReceiveDataInternal(signed int socket, signed int *nBufferSize, signed int nConvertNullsToSpaces, signed int nReceiveDelay1, signed int nReceiveDelay2);
// medusaReceiveInternal
// file medusa-net.c line 421
signed int medusaReceiveInternal(signed int socket, unsigned char *buf, signed int length);
// medusaReceiveLine
// file medusa-net.c line 774
extern unsigned char * medusaReceiveLine(signed int socket, signed int *nBufferSize);
// medusaReceiveLineDelay
// file medusa-net.c line 779
extern unsigned char * medusaReceiveLineDelay(signed int socket, signed int *nBufferSize, signed int nReceiveDelay1, signed int nReceiveDelay2);
// medusaReceiveRaw
// file medusa-net.c line 764
extern unsigned char * medusaReceiveRaw(signed int socket, signed int *nBufferSize);
// medusaReceiveRawDelay
// file medusa-net.c line 769
extern unsigned char * medusaReceiveRawDelay(signed int socket, signed int *nBufferSize, signed int nReceiveDelay1, signed int nReceiveDelay2);
// medusaReceiveRegex
// file medusa-net.c line 794
extern signed int medusaReceiveRegex(signed int hSocket, unsigned char **szBufReceive, signed int *nBufReceive, const char *regex);
// medusaSend
// file medusa-net.c line 871
extern signed int medusaSend(signed int socket, unsigned char *buf, signed int size, signed int options);
// medusaSendInternal
// file medusa-net.c line 576
signed int medusaSendInternal(signed int socket, unsigned char *buf, signed int size, signed int options);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// notify_waiters
// file medusa-thread-pool.c line 121
static void notify_waiters(struct thr_pool *pool);
// processComboFile
// file medusa.c line 554
signed int processComboFile(struct __sAudit **_psAudit);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_getguardsize
// file /usr/include/pthread.h line 307
extern signed int pthread_attr_getguardsize(const union pthread_attr_t *, unsigned long int *);
// pthread_attr_getinheritsched
// file /usr/include/pthread.h line 337
extern signed int pthread_attr_getinheritsched(const union pthread_attr_t *, signed int *);
// pthread_attr_getschedparam
// file /usr/include/pthread.h line 318
extern signed int pthread_attr_getschedparam(const union pthread_attr_t *, struct sched_param *);
// pthread_attr_getschedpolicy
// file /usr/include/pthread.h line 328
extern signed int pthread_attr_getschedpolicy(const union pthread_attr_t *, signed int *);
// pthread_attr_getscope
// file /usr/include/pthread.h line 348
extern signed int pthread_attr_getscope(const union pthread_attr_t *, signed int *);
// pthread_attr_getstack
// file /usr/include/pthread.h line 383
extern signed int pthread_attr_getstack(const union pthread_attr_t *, void ** restrict , unsigned long int *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setguardsize
// file /usr/include/pthread.h line 312
extern signed int pthread_attr_setguardsize(union pthread_attr_t *, unsigned long int);
// pthread_attr_setinheritsched
// file /usr/include/pthread.h line 342
extern signed int pthread_attr_setinheritsched(union pthread_attr_t *, signed int);
// pthread_attr_setschedparam
// file /usr/include/pthread.h line 323
extern signed int pthread_attr_setschedparam(union pthread_attr_t *, struct sched_param *);
// pthread_attr_setschedpolicy
// file /usr/include/pthread.h line 333
extern signed int pthread_attr_setschedpolicy(union pthread_attr_t *, signed int);
// pthread_attr_setscope
// file /usr/include/pthread.h line 353
extern signed int pthread_attr_setscope(union pthread_attr_t *, signed int);
// pthread_attr_setstack
// file /usr/include/pthread.h line 391
extern signed int pthread_attr_setstack(union pthread_attr_t *, void *, unsigned long int);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_13 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_13 *, const union anonymous_14 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_13 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_13 *, union anonymous_11 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_13 *, union anonymous_11 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_11 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_11 *, const union anonymous_14 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_11 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_11 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_5 *, struct anonymous_5 *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous_2 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// scandir
// file /usr/include/dirent.h line 254
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_0 *, struct anonymous_0 *, struct anonymous_0 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setPassResult
// file medusa.c line 1371
void setPassResult(struct __sLogin *_psLogin, char *_pPass);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_5 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_5 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_5 *);
// sigint_handler
// file medusa.c line 1857
void sigint_handler(signed int sig);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_5 *, struct anonymous_5 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sslTempRSACallback
// file medusa-net.c line 323
struct rsa_st * sslTempRSACallback(struct ssl_st *ssl, signed int export, signed int keylength);
// startLoginThreadPool
// file medusa.c line 1528
void startLoginThreadPool(void *arg);
// startModule
// file medusa.c line 1503
void startModule(void *pParams);
// startServerThreadPool
// file medusa.c line 1682
signed int startServerThreadPool(struct __sAudit *_psAudit);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// thr_pool_create
// file medusa-thread-pool.h line 33
extern struct thr_pool * thr_pool_create(unsigned int min_threads, unsigned int max_threads, unsigned int linger, union pthread_attr_t *attr);
// thr_pool_destroy
// file medusa-thread-pool.h line 60
extern void thr_pool_destroy(struct thr_pool *pool);
// thr_pool_destroy::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// thr_pool_queue
// file medusa-thread-pool.h line 50
extern signed int thr_pool_queue(struct thr_pool *pool, void *func, void *arg);
// thr_pool_wait
// file medusa-thread-pool.h line 55
extern void thr_pool_wait(struct thr_pool *pool);
// thr_pool_wait::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// thread_id
// file medusa-thread-ssl.c line 32
static unsigned long int thread_id(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// usage
// file medusa.c line 55
void usage();
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// worker_cleanup
// file medusa-thread-pool.c line 106
static void worker_cleanup(struct thr_pool *pool);
// worker_thread
// file medusa-thread-pool.c line 153
static void * worker_thread(void *arg);
// worker_thread::1::1::2::1::1::2::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// worker_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);

//

// writeError
// file medusa-trace.h line 47
void writeError(signed int iLevel, char *pMsg, ...);
// writeErrorBin
// file ../medusa-trace.c line 207
void writeErrorBin(signed int iLevel, char *pMsg, unsigned char *pData, signed int iLength);
// writeVerbose
// file modsrc/../medusa-trace.h line 46
void writeVerbose(signed int iLevel, char *pMsg, ...);

struct anonymous_17
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_15
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_1
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_0
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_5
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_7
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_6
{
  // __cancel_jmp_buf
  struct anonymous_7 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_23
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_2
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_25
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_16
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_18
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_8 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_10 _rt;
  // _sigchld
  struct anonymous_12 _sigchld;
  // _sigfault
  struct anonymous_15 _sigfault;
  // _sigpoll
  struct anonymous_16 _sigpoll;
  // _sigsys
  struct anonymous_17 _sigsys;
};

struct anonymous_20
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_18 _sifields;
};

struct anonymous
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_24
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_21
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous_22
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_20 *, void *);
};

union anonymous_19
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_3
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_14
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_13
{
  // __data
  struct anonymous_23 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_11
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_4
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_26
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct UT_hash_handle
{
  // tbl
  struct UT_hash_table *tbl;
  // prev
  void *prev;
  // next
  void *next;
  // hh_prev
  struct UT_hash_handle *hh_prev;
  // hh_next
  struct UT_hash_handle *hh_next;
  // key
  void *key;
  // keylen
  unsigned int keylen;
  // hashv
  unsigned int hashv;
};

struct SSLSOCKETINFO
{
  // id
  signed int id;
  // nUseSSL
  signed int nUseSSL;
  // ssl
  struct ssl_st *ssl;
  // sslContext
  struct ssl_ctx_st *sslContext;
  // hh
  struct UT_hash_handle hh;
};

struct UT_hash_bucket
{
  // hh_head
  struct UT_hash_handle *hh_head;
  // count
  unsigned int count;
  // expand_mult
  unsigned int expand_mult;
};

struct UT_hash_table
{
  // buckets
  struct UT_hash_bucket *buckets;
  // num_buckets
  unsigned int num_buckets;
  // log2_num_buckets
  unsigned int log2_num_buckets;
  // num_items
  unsigned int num_items;
  // tail
  struct UT_hash_handle *tail;
  // hho
  signed long int hho;
  // ideal_chain_maxlen
  unsigned int ideal_chain_maxlen;
  // nonideal_items
  unsigned int nonideal_items;
  // ineff_expands
  unsigned int ineff_expands;
  // noexpand
  unsigned int noexpand;
  // signature
  unsigned int signature;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __sAudit
{
  // pOptHost
  char *pOptHost;
  // pOptUser
  char *pOptUser;
  // pOptPass
  char *pOptPass;
  // pOptCombo
  char *pOptCombo;
  // pOptOutput
  char *pOptOutput;
  // pOptResume
  char *pOptResume;
  // pModuleName
  char *pModuleName;
  // pGlobalHost
  char *pGlobalHost;
  // pGlobalUser
  char *pGlobalUser;
  // pGlobalPass
  char *pGlobalPass;
  // pGlobalCombo
  char *pGlobalCombo;
  // pHostFile
  char *pHostFile;
  // pUserFile
  char *pUserFile;
  // pPassFile
  char *pPassFile;
  // pComboFile
  char *pComboFile;
  // iHostCnt
  signed int iHostCnt;
  // iUserCnt
  signed int iUserCnt;
  // iPassCnt
  signed int iPassCnt;
  // iComboCnt
  signed int iComboCnt;
  // iServerCnt
  signed int iServerCnt;
  // iLoginCnt
  signed int iLoginCnt;
  // iHostsDone
  signed int iHostsDone;
  // iPortOverride
  signed int iPortOverride;
  // iUseSSL
  signed int iUseSSL;
  // iTimeout
  signed int iTimeout;
  // iRetryWait
  signed int iRetryWait;
  // iRetries
  signed int iRetries;
  // iSocketWait
  signed int iSocketWait;
  // HostType
  signed int HostType;
  // UserType
  signed int UserType;
  // PassType
  signed int PassType;
  // iShowModuleHelp
  signed int iShowModuleHelp;
  // pComboEntryTmp
  char *pComboEntryTmp;
  // iHostListFlag
  signed int iHostListFlag;
  // iUserListFlag
  signed int iUserListFlag;
  // iAuditFlag
  signed int iAuditFlag;
  // iPasswordBlankFlag
  signed int iPasswordBlankFlag;
  // iPasswordUsernameFlag
  signed int iPasswordUsernameFlag;
  // iFoundPairExitFlag
  signed int iFoundPairExitFlag;
  // iParallelLoginFlag
  signed int iParallelLoginFlag;
  // iValidPairFound
  signed int iValidPairFound;
  // iStatus
  signed int iStatus;
  // psHostRoot
  struct __sHost *psHostRoot;
  // server_pool
  struct thr_pool *server_pool;
  // ptmMutex
  union anonymous_11 ptmMutex;
};

struct __sConnectParams
{
  // nHost
  signed long int nHost;
  // nPort
  signed int nPort;
  // nUseSSL
  signed int nUseSSL;
  // nSSLVersion
  float nSSLVersion;
  // nProtocol
  signed int nProtocol;
  // nType
  signed int nType;
  // nProxyStringIP
  unsigned long int nProxyStringIP;
  // nProxyStringPort
  signed int nProxyStringPort;
  // szProxyAuthentication
  char *szProxyAuthentication;
  // nTimeout
  signed int nTimeout;
  // nRetries
  signed int nRetries;
  // nRetryWait
  signed int nRetryWait;
  // nSourcePort
  signed int nSourcePort;
};

struct __sCredentialSet
{
  // psCredentialSetNext
  struct __sCredentialSet *psCredentialSetNext;
  // psUser
  struct __sUser *psUser;
  // pPass
  char *pPass;
  // iStatus
  signed int iStatus;
};

struct __sHost
{
  // psHostNext
  struct __sHost *psHostNext;
  // pHost
  char *pHost;
  // iUseSSL
  signed int iUseSSL;
  // iPortOverride
  signed int iPortOverride;
  // iTimeout
  signed int iTimeout;
  // iRetryWait
  signed int iRetryWait;
  // iRetries
  signed int iRetries;
  // psUser
  struct __sUser *psUser;
  // psUserCurrent
  struct __sUser *psUserCurrent;
  // psUserPrevTmp
  struct __sUser *psUserPrevTmp;
  // iUserCnt
  signed int iUserCnt;
  // iUserPassCnt
  signed int iUserPassCnt;
  // iUsersDone
  signed int iUsersDone;
  // iUserStatus
  signed int iUserStatus;
  // iId
  signed int iId;
};

struct __sLogin
{
  // psServer
  struct __sServer *psServer;
  // psUser
  struct __sUser *psUser;
  // iResult
  signed int iResult;
  // pErrorMsg
  char *pErrorMsg;
  // iId
  signed int iId;
  // iLoginsDone
  signed int iLoginsDone;
};

struct __sModuleStart
{
  // szModuleName
  char *szModuleName;
  // pLogin
  struct __sLogin *pLogin;
  // argc
  signed int argc;
  // argv
  char **argv;
};

struct __sPass
{
  // psPassNext
  struct __sPass *psPassNext;
  // pPass
  char *pPass;
};

struct __sServer
{
  // psAudit
  struct __sAudit *psAudit;
  // psHost
  struct __sHost *psHost;
  // pHostIP
  char *pHostIP;
  // iValidPairFound
  signed int iValidPairFound;
  // iId
  signed int iId;
  // iLoginCnt
  signed int iLoginCnt;
  // iLoginsDone
  signed int iLoginsDone;
  // psCredentialSetMissed
  struct __sCredentialSet *psCredentialSetMissed;
  // psCredentialSetMissedCurrent
  struct __sCredentialSet *psCredentialSetMissedCurrent;
  // psCredentialSetMissedTail
  struct __sCredentialSet *psCredentialSetMissedTail;
  // iCredentialsMissed
  signed int iCredentialsMissed;
  // ptmMutex
  union anonymous_11 ptmMutex;
};

struct __sUser
{
  // psUserNext
  struct __sUser *psUserNext;
  // pUser
  char *pUser;
  // psPass
  struct __sPass *psPass;
  // psPassCurrent
  struct __sPass *psPassCurrent;
  // psPassPrevTmp
  struct __sPass *psPassPrevTmp;
  // pPass
  char *pPass;
  // iPassCnt
  signed int iPassCnt;
  // iLoginsDone
  signed int iLoginsDone;
  // iPassStatus
  signed int iPassStatus;
  // iId
  signed int iId;
};

struct active
{
  // active_next
  struct active *active_next;
  // active_tid
  unsigned long int active_tid;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_21 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous_19 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_24 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_3 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct job
{
  // job_next
  struct job *job_next;
  // job_func
  void * (*job_func)(void *);
  // job_arg
  void *job_arg;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_22 __sigaction_handler;
  // sa_mask
  struct anonymous_5 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_1 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_25 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct thr_pool
{
  // pool_forw
  struct thr_pool *pool_forw;
  // pool_back
  struct thr_pool *pool_back;
  // pool_mutex
  union anonymous_11 pool_mutex;
  // pool_busycv
  union anonymous_13 pool_busycv;
  // pool_workcv
  union anonymous_13 pool_workcv;
  // pool_waitcv
  union anonymous_13 pool_waitcv;
  // pool_active
  struct active *pool_active;
  // pool_head
  struct job *pool_head;
  // pool_tail
  struct job *pool_tail;
  // pool_attr
  union pthread_attr_t pool_attr;
  // pool_flags
  signed int pool_flags;
  // pool_linger
  unsigned int pool_linger;
  // pool_minimum
  signed int pool_minimum;
  // pool_maximum
  signed int pool_maximum;
  // pool_nthreads
  signed int pool_nthreads;
  // pool_idle
  signed int pool_idle;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// arrModuleParams
// file medusa.c line 35
char **arrModuleParams;
// fillset
// file medusa-thread-pool.c line 72
static struct anonymous_5 fillset;
// iErrorLevel
// file modsrc/../medusa.h line 65
signed int iErrorLevel;
// iVerboseLevel
// file modsrc/../medusa.h line 64
signed int iVerboseLevel;
// lockarray
// file medusa-thread-ssl.c line 17
static union anonymous_11 *lockarray;
// nModuleParamCount
// file medusa.c line 36
signed int nModuleParamCount;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pOutputFile
// file modsrc/../medusa.h line 62
struct _IO_FILE *pOutputFile;
// psAudit
// file medusa.c line 38
struct __sAudit *psAudit = (struct __sAudit *)(void *)0;
// psSSLSocketInfo
// file medusa-net.c line 72
struct SSLSOCKETINFO *psSSLSocketInfo = (struct SSLSOCKETINFO *)(void *)0;
// ptmFileMutex
// file modsrc/../medusa.h line 63
union anonymous_11 ptmFileMutex;
// ptmSSLMutex
// file medusa-net.c line 73
union anonymous_11 ptmSSLMutex;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// szModuleName
// file medusa.c line 32
char *szModuleName;
// szModulePaths
// file medusa.c line 34
char *szModulePaths[3l] = { "a", "b", "c" };
// szTempModuleParam
// file medusa.c line 33
char *szTempModuleParam;
// thr_pool_lock
// file medusa-thread-pool.c line 69
static union anonymous_11 thr_pool_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// thr_pools
// file medusa-thread-pool.c line 66
static struct thr_pool *thr_pools = (struct thr_pool *)(void *)0;

// addMissedCredSet
// file medusa.c line 1452
signed int addMissedCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet)
{
  struct __sCredentialSet *psCredSetMissed = (struct __sCredentialSet *)(void *)0;
  pthread_mutex_lock(&_psLogin->psServer->ptmMutex);
  writeError(5, "[%s] Host: %s - Login thread (%d) prematurely ended. The current number of parallel login threads may exceed what this service can reasonably handle. The total number of threads for this host will be decreased.", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->iId);
  if(_psLogin->psServer->iLoginCnt >= 2)
    _psLogin->psServer->iLoginCnt = _psLogin->psServer->iLoginCnt - 1;

  writeError(5, "[%s] Host: %s User: %s Password: %s - The noted credentials have been added to the end of the queue for testing.", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psCredSet->psUser->pUser, _psCredSet->pPass);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct __sCredentialSet) /*32ul*/ );
  psCredSetMissed = (struct __sCredentialSet *)return_value_malloc_1;
  memset((void *)psCredSetMissed, 0, sizeof(struct __sCredentialSet) /*32ul*/ );
  psCredSetMissed->psUser = _psCredSet->psUser;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(_psCredSet->pPass);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)1);
  psCredSetMissed->pPass = (char *)return_value_malloc_3;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(_psCredSet->pPass);
  memset((void *)psCredSetMissed->pPass, 0, return_value_strlen_4 + (unsigned long int)1);
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(_psCredSet->pPass);
  strncpy(psCredSetMissed->pPass, _psCredSet->pPass, return_value_strlen_5);
  if(_psLogin->psServer->psCredentialSetMissed == ((struct __sCredentialSet *)NULL))
  {
    _psLogin->psServer->psCredentialSetMissed = psCredSetMissed;
    _psLogin->psServer->psCredentialSetMissedCurrent = psCredSetMissed;
  }

  else
    _psLogin->psServer->psCredentialSetMissedTail->psCredentialSetNext = psCredSetMissed;
  _psLogin->psServer->psCredentialSetMissedTail = psCredSetMissed;
  _psLogin->psServer->iCredentialsMissed = _psLogin->psServer->iCredentialsMissed + 1;
  pthread_mutex_unlock(&_psLogin->psServer->ptmMutex);
  return 0;
}

// base64_decode
// file medusa-utils.c line 96
extern signed int base64_decode(const char *base64, char *to)
{
  const char *p = base64;
  char *q = to;
  const char *tmp_post_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  const char *tmp_post_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  char *tmp_post_7;
  const char *tmp_post_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  const char *tmp_post_13;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  char *tmp_post_14;
  const char *tmp_post_17;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_15;
  char *tmp_post_18;
  while((_Bool)1)
  {
    unsigned char c;
    unsigned long int value;
    static signed short int base64_char_to_value[128l] = { (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)62, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)63, (signed short int)52, (signed short int)53, (signed short int)54, (signed short int)55, (signed short int)56, (signed short int)57, (signed short int)58, (signed short int)59, (signed short int)60, (signed short int)61, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)0, (signed short int)1, (signed short int)2, (signed short int)3, (signed short int)4, (signed short int)5, (signed short int)6, (signed short int)7, (signed short int)8, (signed short int)9, (signed short int)10, (signed short int)11, (signed short int)12, (signed short int)13, (signed short int)14, (signed short int)15, (signed short int)16, (signed short int)17, (signed short int)18, (signed short int)19, (signed short int)20, (signed short int)21, (signed short int)22, (signed short int)23, (signed short int)24, (signed short int)25, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)26, (signed short int)27, (signed short int)28, (signed short int)29, (signed short int)30, (signed short int)31, (signed short int)32, (signed short int)33, (signed short int)34, (signed short int)35, (signed short int)36, (signed short int)37, (signed short int)38, (signed short int)39, (signed short int)40, (signed short int)41, (signed short int)42, (signed short int)43, (signed short int)44, (signed short int)45, (signed short int)46, (signed short int)47, (signed short int)48, (signed short int)49, (signed short int)50, (signed short int)51, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1, (signed short int)-1 };
    do
    {
      tmp_post_3 = p;
      p = p + 1l;
      c = (unsigned char)*tmp_post_3;
      if(!((signed int)c == 0))
      {
        if((0x80 & (signed int)c) == 0)
          tmp_if_expr_1 = (signed int)base64_char_to_value[(signed long int)c] >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = !(tmp_if_expr_1 ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(c == 0)
      break;

    if((signed int)c == 61)
      return -1;

    value = (unsigned long int)((signed int)base64_char_to_value[(signed long int)c] << 18);
    do
    {
      tmp_post_6 = p;
      p = p + 1l;
      c = (unsigned char)*tmp_post_6;
      if(!((signed int)c == 0))
      {
        if((0x80 & (signed int)c) == 0)
          tmp_if_expr_4 = (signed int)base64_char_to_value[(signed long int)c] >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = !(tmp_if_expr_4 ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
    }
    while(tmp_if_expr_5);
    if(c == 0)
      return -1;

    if((signed int)c == 61)
      return -1;

    value = value | (unsigned long int)((signed int)base64_char_to_value[(signed long int)c] << 12);
    tmp_post_7 = q;
    q = q + 1l;
    *tmp_post_7 = (char)(value >> 16);
    do
    {
      tmp_post_10 = p;
      p = p + 1l;
      c = (unsigned char)*tmp_post_10;
      if(!((signed int)c == 0))
      {
        if((0x80 & (signed int)c) == 0)
          tmp_if_expr_8 = (signed int)base64_char_to_value[(signed long int)c] >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        tmp_if_expr_9 = !(tmp_if_expr_8 ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_9 = (_Bool)0;
    }
    while(tmp_if_expr_9);
    if(c == 0)
      return -1;

    if((signed int)c == 61)
    {
      do
      {
        tmp_post_13 = p;
        p = p + 1l;
        c = (unsigned char)*tmp_post_13;
        if(!((signed int)c == 0))
        {
          if((0x80 & (signed int)c) == 0)
            tmp_if_expr_11 = (signed int)base64_char_to_value[(signed long int)c] >= 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_11 = (_Bool)0;
          tmp_if_expr_12 = !(tmp_if_expr_11 ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
      }
      while(tmp_if_expr_12);
      if(c == 0)
        return -1;

      if(!((signed int)c == 61))
        return -1;

    }

    else
    {
      value = value | (unsigned long int)((signed int)base64_char_to_value[(signed long int)c] << 6);
      tmp_post_14 = q;
      q = q + 1l;
      *tmp_post_14 = (char)((unsigned long int)0xff & value >> 8);
      do
      {
        tmp_post_17 = p;
        p = p + 1l;
        c = (unsigned char)*tmp_post_17;
        if(!((signed int)c == 0))
        {
          if((0x80 & (signed int)c) == 0)
            tmp_if_expr_15 = (signed int)base64_char_to_value[(signed long int)c] >= 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_15 = (_Bool)0;
          tmp_if_expr_16 = !(tmp_if_expr_15 ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_16 = (_Bool)0;
      }
      while(tmp_if_expr_16);
      if(c == 0)
        return -1;

      if(!((signed int)c == 61))
      {
        value = value | (unsigned long int)base64_char_to_value[(signed long int)c];
        tmp_post_18 = q;
        q = q + 1l;
        *tmp_post_18 = (char)((unsigned long int)0xff & value);
      }

    }
  }
  return (signed int)(q - to);
}

// base64_encode
// file medusa-utils.c line 37
extern signed int base64_encode(const char *str, signed int length, char *b64store)
{
  signed int i;
  const unsigned char *s = (const unsigned char *)str;
  char *p = b64store;
  i = 0;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  for( ; !(i >= length); i = i + 3)
  {
    tmp_post_1 = p;
    p = p + 1l;
    static char tbl[64l] = { (char)65, (char)66, (char)67, (char)68, (char)69, (char)70, (char)71, (char)72, (char)73, (char)74, (char)75, (char)76, (char)77, (char)78, (char)79, (char)80, (char)81, (char)82, (char)83, (char)84, (char)85, (char)86, (char)87, (char)88, (char)89, (char)90, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102, (char)103, (char)104, (char)105, (char)106, (char)107, (char)108, (char)109, (char)110, (char)111, (char)112, (char)113, (char)114, (char)115, (char)116, (char)117, (char)118, (char)119, (char)120, (char)121, (char)122, (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)43, (char)47 };
    *tmp_post_1 = tbl[(signed long int)((signed int)s[(signed long int)0] >> 2)];
    tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = tbl[(signed long int)((((signed int)s[(signed long int)0] & 3) << 4) + ((signed int)s[(signed long int)1] >> 4))];
    tmp_post_3 = p;
    p = p + 1l;
    *tmp_post_3 = tbl[(signed long int)((((signed int)s[(signed long int)1] & 0xf) << 2) + ((signed int)s[(signed long int)2] >> 6))];
    tmp_post_4 = p;
    p = p + 1l;
    *tmp_post_4 = tbl[(signed long int)((signed int)s[(signed long int)2] & 0x3f)];
    s = s + (signed long int)3;
  }
  if(i == 1 + length)
    *(p - (signed long int)1) = (char)61;

  else
    if(i == 2 + length)
    {
      *(p - (signed long int)2) = (char)61;
      *(p - (signed long int)1) = *(p - (signed long int)2);
    }

  *p = (char)0;
  return (signed int)(p - b64store);
}

// basic_authentication_encode
// file medusa-utils.c line 177
extern char * basic_authentication_encode(const char *user, const char *passwd)
{
  char *t1;
  char *t2;
  signed int len1;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(user);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(passwd);
  len1 = (signed int)(return_value_strlen_1 + (unsigned long int)1 + return_value_strlen_2);
  void *return_value___builtin_alloca_3;
  return_value___builtin_alloca_3=__builtin_alloca((unsigned long int)(len1 + 1));
  t1 = (char *)return_value___builtin_alloca_3;
  sprintf(t1, "%s:%s", user, passwd);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(4 * ((len1 + 2) / 3) + 1));
  t2 = (char *)return_value_malloc_4;
  base64_encode(t1, len1, t2);
  return t2;
}

// checkOptions
// file medusa.c line 98
signed int checkOptions(signed int argc, char **argv, struct __sAudit *_psAudit)
{
  signed int opt;
  signed int ret = 0;
  signed int i = 0;
  signed int nIgnoreBanner = 0;
  _psAudit->iServerCnt = 1;
  _psAudit->iLoginCnt = 1;
  _psAudit->iParallelLoginFlag = 2;
  _psAudit->iPortOverride = 0;
  _psAudit->iUseSSL = 0;
  _psAudit->iTimeout = 3;
  _psAudit->iRetryWait = 3;
  _psAudit->iRetries = 3;
  _psAudit->iSocketWait = 500;
  _psAudit->iShowModuleHelp = 0;
  iVerboseLevel = 5;
  iErrorLevel = 5;
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    char *return_value_strstr_1;
    return_value_strstr_1=strstr(argv[(signed long int)i], "-b");
    if(!(return_value_strstr_1 == ((char *)NULL)))
    {
      nIgnoreBanner = 1;
      break;
    }

  }
  if(nIgnoreBanner == 0)
    writeVerbose(1, "%s v%s [%s] (C) %s %s\n", (const void *)"Medusa", (const void *)"2.2_rc3", (const void *)"http://www.foofus.net", (const void *)"JoMo-Kun / Foofus Networks", (const void *)"<jmk@foofus.net>");

  unsigned long int return_value_strlen_26;
  void *return_value_malloc_27;
  unsigned long int return_value_strlen_28;
  unsigned long int return_value_strlen_29;
  unsigned long int return_value_strlen_30;
  void *return_value_malloc_31;
  unsigned long int return_value_strlen_32;
  unsigned long int return_value_strlen_33;
  signed int return_value_strcmp_38;
  signed int return_value_strcmp_37;
  signed int return_value_strcmp_34;
  _Bool tmp_if_expr_36;
  signed int return_value_strcmp_35;
  unsigned long int return_value_strlen_39;
  void *return_value_malloc_40;
  unsigned long int return_value_strlen_41;
  unsigned long int return_value_strlen_42;
  unsigned long int return_value_strlen_43;
  void *return_value_malloc_44;
  unsigned long int return_value_strlen_45;
  unsigned long int return_value_strlen_46;
  void *return_value_realloc_47;
  unsigned long int return_value_strlen_48;
  void *return_value_malloc_49;
  unsigned long int return_value_strlen_50;
  unsigned long int return_value_strlen_51;
  do
  {
    opt=getopt(argc, argv, "h:H:u:U:p:P:C:O:e:M:m:g:r:R:c:t:T:n:bqdsLfFVv:w:Z:");
    if(opt == -1)
      break;

    switch(opt)
    {
      case 104:
      {
        if(!(_psAudit->HostType == 0))
        {
          writeError(1, "Options 'h' and 'H' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(optarg);
          void *return_value_malloc_3;
          return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)1);
          _psAudit->pGlobalHost = (char *)return_value_malloc_3;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(optarg);
          memset((void *)_psAudit->pGlobalHost, 0, return_value_strlen_4 + (unsigned long int)1);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(optarg);
          strncpy(_psAudit->pGlobalHost, optarg, return_value_strlen_5);
          _psAudit->HostType = 1;
        }
        break;
      }
      case 72:
      {
        if(!(_psAudit->HostType == 0))
        {
          writeError(1, "Options 'h' and 'H' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(optarg);
          void *return_value_malloc_7;
          return_value_malloc_7=malloc(return_value_strlen_6 + (unsigned long int)1);
          _psAudit->pOptHost = (char *)return_value_malloc_7;
          unsigned long int return_value_strlen_8;
          return_value_strlen_8=strlen(optarg);
          memset((void *)_psAudit->pOptHost, 0, return_value_strlen_8 + (unsigned long int)1);
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(optarg);
          strncpy(_psAudit->pOptHost, optarg, return_value_strlen_9);
          _psAudit->HostType = 2;
        }
        break;
      }
      case 117:
      {
        if(!(_psAudit->UserType == 0))
        {
          writeError(1, "Options 'u' and 'U' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_10;
          return_value_strlen_10=strlen(optarg);
          void *return_value_malloc_11;
          return_value_malloc_11=malloc(return_value_strlen_10 + (unsigned long int)1);
          _psAudit->pGlobalUser = (char *)return_value_malloc_11;
          unsigned long int return_value_strlen_12;
          return_value_strlen_12=strlen(optarg);
          memset((void *)_psAudit->pGlobalUser, 0, return_value_strlen_12 + (unsigned long int)1);
          unsigned long int return_value_strlen_13;
          return_value_strlen_13=strlen(optarg);
          strncpy(_psAudit->pGlobalUser, optarg, return_value_strlen_13);
          _psAudit->UserType = 1;
          _psAudit->iUserCnt = 1;
        }
        break;
      }
      case 85:
      {
        if(!(_psAudit->UserType == 0))
        {
          writeError(1, "Options 'u' and 'U' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_14;
          return_value_strlen_14=strlen(optarg);
          void *return_value_malloc_15;
          return_value_malloc_15=malloc(return_value_strlen_14 + (unsigned long int)1);
          _psAudit->pOptUser = (char *)return_value_malloc_15;
          unsigned long int return_value_strlen_16;
          return_value_strlen_16=strlen(optarg);
          memset((void *)_psAudit->pOptUser, 0, return_value_strlen_16 + (unsigned long int)1);
          unsigned long int return_value_strlen_17;
          return_value_strlen_17=strlen(optarg);
          strncpy(_psAudit->pOptUser, optarg, return_value_strlen_17);
          _psAudit->UserType = 2;
        }
        break;
      }
      case 112:
      {
        if(!(_psAudit->PassType == 0))
        {
          writeError(1, "Options 'p' and 'P' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_18;
          return_value_strlen_18=strlen(optarg);
          void *return_value_malloc_19;
          return_value_malloc_19=malloc(return_value_strlen_18 + (unsigned long int)2);
          _psAudit->pGlobalPass = (char *)return_value_malloc_19;
          unsigned long int return_value_strlen_20;
          return_value_strlen_20=strlen(optarg);
          memset((void *)_psAudit->pGlobalPass, 0, return_value_strlen_20 + (unsigned long int)2);
          unsigned long int return_value_strlen_21;
          return_value_strlen_21=strlen(optarg);
          strncpy(_psAudit->pGlobalPass, optarg, return_value_strlen_21);
          _psAudit->PassType = 1;
          _psAudit->iPassCnt = 1;
        }
        break;
      }
      case 80:
      {
        if(!(_psAudit->PassType == 0))
        {
          writeError(1, "Options 'p' and 'P' are mutually exclusive.");
          ret = 1;
        }

        else
        {
          unsigned long int return_value_strlen_22;
          return_value_strlen_22=strlen(optarg);
          void *return_value_malloc_23;
          return_value_malloc_23=malloc(return_value_strlen_22 + (unsigned long int)1);
          _psAudit->pOptPass = (char *)return_value_malloc_23;
          unsigned long int return_value_strlen_24;
          return_value_strlen_24=strlen(optarg);
          memset((void *)_psAudit->pOptPass, 0, return_value_strlen_24 + (unsigned long int)1);
          unsigned long int return_value_strlen_25;
          return_value_strlen_25=strlen(optarg);
          strncpy(_psAudit->pOptPass, optarg, return_value_strlen_25);
          _psAudit->PassType = 2;
        }
        break;
      }
      case 67:
      {
        return_value_strlen_26=strlen(optarg);
        return_value_malloc_27=malloc(return_value_strlen_26 + (unsigned long int)1);
        _psAudit->pOptCombo = (char *)return_value_malloc_27;
        return_value_strlen_28=strlen(optarg);
        memset((void *)_psAudit->pOptCombo, 0, return_value_strlen_28 + (unsigned long int)1);
        return_value_strlen_29=strlen(optarg);
        strncpy(_psAudit->pOptCombo, optarg, return_value_strlen_29);
        break;
      }
      case 79:
      {
        return_value_strlen_30=strlen(optarg);
        return_value_malloc_31=malloc(return_value_strlen_30 + (unsigned long int)1);
        _psAudit->pOptOutput = (char *)return_value_malloc_31;
        return_value_strlen_32=strlen(optarg);
        memset((void *)_psAudit->pOptOutput, 0, return_value_strlen_32 + (unsigned long int)1);
        return_value_strlen_33=strlen(optarg);
        strncpy(_psAudit->pOptOutput, optarg, return_value_strlen_33);
        break;
      }
      case 101:
      {
        return_value_strcmp_38=strcmp(optarg, "n");
        if(return_value_strcmp_38 == 0)
        {
          _psAudit->iPasswordBlankFlag = 1;
          _psAudit->iPasswordUsernameFlag = 0;
        }

        else
        {
          return_value_strcmp_37=strcmp(optarg, "s");
          if(return_value_strcmp_37 == 0)
          {
            _psAudit->iPasswordBlankFlag = 0;
            _psAudit->iPasswordUsernameFlag = 1;
          }

          else
          {
            return_value_strcmp_34=strcmp(optarg, "ns");
            if(return_value_strcmp_34 == 0)
              tmp_if_expr_36 = (_Bool)1;

            else
            {
              return_value_strcmp_35=strcmp(optarg, "sn");
              tmp_if_expr_36 = return_value_strcmp_35 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_36)
            {
              _psAudit->iPasswordBlankFlag = 1;
              _psAudit->iPasswordUsernameFlag = 1;
            }

            else
            {
              writeError(1, "Option 'e' requires value of n, s, or ns.");
              ret = 1;
            }
          }
        }
        break;
      }
      case 115:
      {
        _psAudit->iUseSSL = 1;
        break;
      }
      case 76:
      {
        _psAudit->iParallelLoginFlag = 1;
        break;
      }
      case 102:
      {
        _psAudit->iFoundPairExitFlag = 1;
        break;
      }
      case 70:
      {
        _psAudit->iFoundPairExitFlag = 2;
        break;
      }
      case 116:
      {
        _psAudit->iLoginCnt=atoi(optarg);
        break;
      }
      case 84:
      {
        _psAudit->iServerCnt=atoi(optarg);
        break;
      }
      case 110:
      {
        _psAudit->iPortOverride=atoi(optarg);
        break;
      }
      case 118:
      {
        iVerboseLevel=atoi(optarg);
        break;
      }
      case 119:
      {
        iErrorLevel=atoi(optarg);
        break;
      }
      case 86:
      {
        writeVerbose(0, "");
        break;
      }
      case 77:
      {
        return_value_strlen_39=strlen(optarg);
        return_value_malloc_40=malloc(return_value_strlen_39 + (unsigned long int)1);
        szModuleName = (char *)return_value_malloc_40;
        return_value_strlen_41=strlen(optarg);
        memset((void *)szModuleName, 0, return_value_strlen_41 + (unsigned long int)1);
        return_value_strlen_42=strlen(optarg);
        strncpy(szModuleName, optarg, return_value_strlen_42);
        _psAudit->pModuleName = szModuleName;
        break;
      }
      case 109:
      {
        nModuleParamCount = nModuleParamCount + 1;
        return_value_strlen_43=strlen(optarg);
        return_value_malloc_44=malloc(return_value_strlen_43 + (unsigned long int)1);
        szTempModuleParam = (char *)return_value_malloc_44;
        return_value_strlen_45=strlen(optarg);
        memset((void *)szTempModuleParam, 0, return_value_strlen_45 + (unsigned long int)1);
        return_value_strlen_46=strlen(optarg);
        strncpy(szTempModuleParam, optarg, return_value_strlen_46);
        return_value_realloc_47=realloc((void *)arrModuleParams, (unsigned long int)nModuleParamCount * sizeof(char *) /*8ul*/ );
        arrModuleParams = (char **)return_value_realloc_47;
        arrModuleParams[(signed long int)(nModuleParamCount - 1)] = szTempModuleParam;
        break;
      }
      case 100:
      {
        listModules(szModulePaths, 1);
        break;
      }
      case 98:
        break;
      case 113:
      {
        _psAudit->iShowModuleHelp = 1;
        break;
      }
      case 103:
      {
        _psAudit->iTimeout=atoi(optarg);
        break;
      }
      case 114:
      {
        _psAudit->iRetryWait=atoi(optarg);
        break;
      }
      case 82:
      {
        _psAudit->iRetries=atoi(optarg);
        break;
      }
      case 99:
      {
        _psAudit->iSocketWait=atoi(optarg);
        break;
      }
      case 90:
      {
        return_value_strlen_48=strlen(optarg);
        return_value_malloc_49=malloc(return_value_strlen_48 + (unsigned long int)1);
        _psAudit->pOptResume = (char *)return_value_malloc_49;
        return_value_strlen_50=strlen(optarg);
        memset((void *)_psAudit->pOptResume, 0, return_value_strlen_50 + (unsigned long int)1);
        return_value_strlen_51=strlen(optarg);
        strncpy(_psAudit->pOptResume, optarg, return_value_strlen_51);
        break;
      }
      default:
      {
        writeError(2, "Unknown error processing command-line options.");
        ret = 1;
      }
    }
  }
  while((_Bool)1);
  if(!(argc >= 2))
    ret = 1;

  _Bool tmp_if_expr_56;
  _Bool tmp_if_expr_55;
  _Bool tmp_if_expr_52;
  _Bool tmp_if_expr_53;
  _Bool tmp_if_expr_54;
  if(!(_psAudit->iShowModuleHelp == 0))
  {
    ret=invokeModule(_psAudit->pModuleName, (struct __sLogin *)(void *)0, 0, (char **)(void *)0);
    if(!(ret >= 0))
      writeError(2, "invokeModule failed - see previous errors for an explanation");

  }

  else
  {
    if(!(_psAudit->HostType == 0))
      tmp_if_expr_56 = (_Bool)1;

    else
      tmp_if_expr_56 = _psAudit->pOptCombo != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_56)
    {
      writeError(1, "Host information must be supplied.");
      ret = 1;
    }

    else
    {
      if(!(_psAudit->UserType == 0))
        tmp_if_expr_55 = (_Bool)1;

      else
        tmp_if_expr_55 = _psAudit->pOptCombo != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_55)
      {
        writeError(1, "User logon information must be supplied.");
        ret = 1;
      }

      else
      {
        if(!(_psAudit->PassType == 0))
          tmp_if_expr_52 = (_Bool)1;

        else
          tmp_if_expr_52 = _psAudit->pOptCombo != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_52)
          tmp_if_expr_53 = (_Bool)1;

        else
          tmp_if_expr_53 = _psAudit->iPasswordBlankFlag != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_53)
          tmp_if_expr_54 = (_Bool)1;

        else
          tmp_if_expr_54 = _psAudit->iPasswordUsernameFlag != 0 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_54)
        {
          writeError(1, "Password information must be supplied.");
          ret = 1;
        }

      }
    }
  }
  return ret;
}

// clone_attributes
// file medusa-thread-pool.c line 248
static void clone_attributes(union pthread_attr_t *new_attr, union pthread_attr_t *old_attr)
{
  struct sched_param param;
  void *addr;
  unsigned long int size;
  signed int value;
  pthread_attr_init(new_attr);
  if(!(old_attr == ((union pthread_attr_t *)NULL)))
  {
    pthread_attr_getstack(old_attr, &addr, &size);
    pthread_attr_setstack(new_attr, (void *)0, size);
    pthread_attr_getscope(old_attr, &value);
    pthread_attr_setscope(new_attr, value);
    pthread_attr_getinheritsched(old_attr, &value);
    pthread_attr_setinheritsched(new_attr, value);
    pthread_attr_getschedpolicy(old_attr, &value);
    pthread_attr_setschedpolicy(new_attr, value);
    pthread_attr_getschedparam(old_attr, &param);
    pthread_attr_setschedparam(new_attr, &param);
    pthread_attr_getguardsize(old_attr, &size);
    pthread_attr_setguardsize(new_attr, size);
  }

  pthread_attr_setdetachstate(new_attr, 1);
}

// create_worker
// file medusa-thread-pool.c line 77
static signed int create_worker(struct thr_pool *pool)
{
  struct anonymous_5 oset;
  signed int error;
  unsigned long int *ppthread;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/ );
  ppthread = (unsigned long int *)return_value_malloc_1;
  memset((void *)ppthread, 0, sizeof(unsigned long int) /*8ul*/ );
  pthread_sigmask(2, &fillset, &oset);
  error=pthread_create(ppthread, &pool->pool_attr, worker_thread, (void *)pool);
  pthread_sigmask(2, &oset, (struct anonymous_5 *)(void *)0);
  free((void *)ppthread);
  return error;
}

// findLocalPass
// file medusa.c line 881
char * findLocalPass(struct __sAudit *_psAudit)
{
  char *pPass;
  char *pComboTmp;
  _Bool tmp_if_expr_1;
  if(_psAudit->PassType == 3)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = _psAudit->PassType == 4 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(!(_psAudit->pGlobalCombo == ((char *)NULL)))
    {
      pComboTmp = _psAudit->pComboEntryTmp;
      for( ; !((signed int)*pComboTmp == 0); pComboTmp = pComboTmp + 1l)
        ;
      pComboTmp = pComboTmp + 1l;
      for( ; !((signed int)*pComboTmp == 0); pComboTmp = pComboTmp + 1l)
        ;
      pComboTmp = pComboTmp + 1l;
    }

    pPass = pComboTmp;
    writeError(7, "[findLocalPass] pPass: %s", pPass);
  }

  else
    pPass = (char *)(void *)0;
  return pPass;
}

// findNextHost
// file medusa.c line 684
char * findNextHost(struct __sAudit *_psAudit, char *_pHost)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(_psAudit->pGlobalCombo == ((char *)NULL)))
  {
    writeError(7, "[findNextHost] Process global combo file.");
    if(_psAudit->iUserListFlag == 1)
    {
      if(_psAudit->iHostListFlag == 1)
      {
        writeError(7, "[findNextHost] Advance to next entry in combo list.");
        for( ; !((signed int)*_psAudit->pGlobalCombo == 0); _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l)
          ;
        _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l;
        for( ; !((signed int)*_psAudit->pGlobalCombo == 0); _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l)
          ;
        _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l;
        for( ; !((signed int)*_psAudit->pGlobalCombo == 0); _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l)
          ;
        _psAudit->pGlobalCombo = _psAudit->pGlobalCombo + 1l;
        if((signed int)*_psAudit->pGlobalCombo == 0)
          _psAudit->iAuditFlag = 1;

        else
          _psAudit->iAuditFlag = 0;
      }

    }

    if(_psAudit->pComboEntryTmp == ((char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      if(_psAudit->iUserListFlag == 1)
        tmp_if_expr_1 = _psAudit->iHostListFlag == 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      writeError(7, "[findNextHost] Convert ':' to '\\0' in combo entries.");
      _psAudit->pComboEntryTmp = _psAudit->pGlobalCombo;
      if(!((signed int)*_psAudit->pComboEntryTmp == 0))
      {
        for( ; !((signed int)*_psAudit->pComboEntryTmp == 58); _psAudit->pComboEntryTmp = _psAudit->pComboEntryTmp + 1l)
          ;
        memset((void *)_psAudit->pComboEntryTmp, 0, (unsigned long int)1);
        for( ; !((signed int)*_psAudit->pComboEntryTmp == 58); _psAudit->pComboEntryTmp = _psAudit->pComboEntryTmp + 1l)
          ;
        memset((void *)_psAudit->pComboEntryTmp, 0, (unsigned long int)1);
      }

    }

    _psAudit->pComboEntryTmp = _psAudit->pGlobalCombo;
  }

  else
    if(_psAudit->iUserListFlag == 1)
    {
      if(_psAudit->iHostListFlag == 1)
        _psAudit->iAuditFlag = 1;

    }

  _psAudit->iHostListFlag = 1;
  if(_psAudit->iAuditFlag == 1)
    _pHost = (char *)(void *)0;

  else
    if(_psAudit->HostType == 3)
    {
      if((signed int)*_psAudit->pGlobalCombo == 0)
        _pHost = (char *)(void *)0;

      else
        _pHost = _psAudit->pGlobalCombo;
    }

    else
      if(_psAudit->HostType == 2)
      {
        if(!((signed int)*_psAudit->pGlobalHost == 0))
        {
          _pHost = _psAudit->pGlobalHost;
          for( ; !((signed int)*_psAudit->pGlobalHost == 0); _psAudit->pGlobalHost = _psAudit->pGlobalHost + 1l)
            ;
          _psAudit->pGlobalHost = _psAudit->pGlobalHost + 1l;
          if(!((signed int)*_psAudit->pGlobalHost == 0))
            _psAudit->iHostListFlag = 0;

          else
            _psAudit->pGlobalHost = _psAudit->pHostFile;
        }

      }

      else
        if(_psAudit->HostType == 1)
        {
          _pHost = _psAudit->pGlobalHost;
          _psAudit->iAuditFlag = 1;
        }

        else
          writeError(0, "[findNextHost] HostType not properly defined.");
  return _pHost;
}

// findNextUser
// file medusa.c line 807
char * findNextUser(struct __sAudit *_psAudit, char *_pUser)
{
  char *pComboTmp;
  _psAudit->iUserListFlag = 1;
  if(_psAudit->UserType == 3)
  {
    if(!(_psAudit->pGlobalCombo == ((char *)NULL)))
    {
      pComboTmp = _psAudit->pComboEntryTmp;
      for( ; !((signed int)*pComboTmp == 0); pComboTmp = pComboTmp + 1l)
        ;
      pComboTmp = pComboTmp + 1l;
    }

    if(!(_pUser == ((char *)NULL)))
      _pUser = (char *)(void *)0;

    else
      _pUser = pComboTmp;
    writeError(7, "[findNextUser] Combo User: %s", _pUser);
  }

  else
    if(_psAudit->UserType == 4)
    {
      if(!(_pUser == ((char *)NULL)))
        _pUser = (char *)(void *)0;

      else
        _pUser = _psAudit->pComboEntryTmp;
      writeError(7, "[findNextUser] PwDump User: %s", _pUser);
    }

    else
      if(_psAudit->UserType == 2)
      {
        _pUser = _psAudit->pGlobalUser;
        if(!((signed int)*_psAudit->pGlobalUser == 0))
        {
          for( ; !((signed int)*_psAudit->pGlobalUser == 0); _psAudit->pGlobalUser = _psAudit->pGlobalUser + 1l)
            ;
          _psAudit->pGlobalUser = _psAudit->pGlobalUser + 1l;
          _psAudit->iUserListFlag = 0;
        }

        else
        {
          _psAudit->pGlobalUser = _psAudit->pUserFile;
          _pUser = (char *)(void *)0;
        }
        writeError(7, "[findNextUser] L_FILE User: %s", _pUser);
      }

      else
        if(_psAudit->UserType == 1)
        {
          if(!(_pUser == ((char *)NULL)))
            _pUser = (char *)(void *)0;

          else
            _pUser = _psAudit->pGlobalUser;
        }

        else
          writeError(0, "[findNextUser] UserType (%d) not properly defined.", _psAudit->UserType);
  return _pUser;
}

// freeModuleParams
// file medusa.c line 40
void freeModuleParams()
{
  signed int i = 0;
  for( ; !(i >= nModuleParamCount); i = i + 1)
    free((void *)arrModuleParams[(signed long int)i]);
  free((void *)arrModuleParams);
}

// getNextCredSet
// file medusa.c line 1306
signed int getNextCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet)
{
  if(_psCredSet == ((struct __sCredentialSet *)NULL))
    writeError(0, "getNextCredSet() called, but not supplied allocated memory for _psCredSet");

  memset((void *)_psCredSet, 0, sizeof(struct __sCredentialSet) /*32ul*/ );
  pthread_mutex_lock(&_psLogin->psServer->ptmMutex);
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  signed int return_value_getNextNormalCredSet_1;
  signed int return_value_getNextMissedCredSet_2;
  signed int return_value_getNextMissedCredSet_3;
  if(_psLogin->psServer->psAudit->iStatus == 1)
  {
    writeError(6, "Audit aborting... notifying login module: %d", _psLogin->iId);
    _psCredSet->iStatus = 3;
  }

  else
  {
    if(!(_psLogin->psServer->iValidPairFound == 0))
      tmp_if_expr_5 = _psLogin->psServer->psAudit->iFoundPairExitFlag == 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      writeError(6, "Exiting Login Module: %d [Stop Host Scan After Valid Pair Found Enabled]", _psLogin->iId);
      _psCredSet->iStatus = 3;
    }

    else
    {
      if(!(_psLogin->psServer->psAudit->iValidPairFound == 0))
        tmp_if_expr_4 = _psLogin->psServer->psAudit->iFoundPairExitFlag == 2 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        writeError(6, "Exiting Login Module: %d [Stop Audit Scans After Valid Pair Found Enabled]", _psLogin->iId);
        _psCredSet->iStatus = 3;
      }

      else
        switch(_psLogin->psServer->psHost->iUserStatus)
        {
          case 0:

          case 1:
          {
            return_value_getNextNormalCredSet_1=getNextNormalCredSet(_psLogin, _psCredSet);
            if(!(return_value_getNextNormalCredSet_1 == 0))
              writeError(0, "getNextNormalCredSet() function call failed.");

            if(_psLogin->psServer->psHost->iUserStatus == 2)
            {
              return_value_getNextMissedCredSet_2=getNextMissedCredSet(_psLogin, _psCredSet);
              if(!(return_value_getNextMissedCredSet_2 == 0))
                writeError(0, "getNextMissedCredSet() function call failed.");

            }

            break;
          }
          case 2:
          {
            return_value_getNextMissedCredSet_3=getNextMissedCredSet(_psLogin, _psCredSet);
            if(!(return_value_getNextMissedCredSet_3 == 0))
              writeError(0, "getNextMissedCredSet() function call failed.");

            break;
          }
          case 3:
          {
            writeError(6, "Login Module: %d - No additional users/passwords, setting credential status to CREDENTIAL_DONE.", _psLogin->iId);
            _psCredSet->iStatus = 3;
            break;
          }
          default:
            writeError(7, "Login Module: %d - Entered undefined state (%d) within getNextCredSet()", _psLogin->iId, _psLogin->psServer->psHost->iUserStatus);
        }
    }
  }
  pthread_mutex_unlock(&_psLogin->psServer->ptmMutex);
  return 0;
}

// getNextMissedCredSet
// file medusa.c line 1258
signed int getNextMissedCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet)
{
  struct __sCredentialSet *psCredSetMissed = (struct __sCredentialSet *)(void *)0;
  writeError(7, "Retrieving the next available credential set from list of previously missed sets.");
  psCredSetMissed = _psLogin->psServer->psCredentialSetMissedCurrent;
  for( ; !(psCredSetMissed == ((struct __sCredentialSet *)NULL)); _psLogin->psServer->psCredentialSetMissedCurrent = psCredSetMissed)
  {
    if(!(psCredSetMissed->psUser->iPassStatus == 6))
      break;

    psCredSetMissed = _psLogin->psServer->psCredentialSetMissedCurrent->psCredentialSetNext;
  }
  if(!(psCredSetMissed == ((struct __sCredentialSet *)NULL)))
  {
    _psCredSet->psUser = psCredSetMissed->psUser;
    _psCredSet->pPass = psCredSetMissed->pPass;
    _psLogin->psServer->psCredentialSetMissedCurrent = psCredSetMissed->psCredentialSetNext;
    if(_psLogin->psUser == _psCredSet->psUser)
      _psCredSet->iStatus = 1;

    else
      _psCredSet->iStatus = 2;
    _psLogin->psServer->iCredentialsMissed = _psLogin->psServer->iCredentialsMissed - 1;
    writeError(7, "Login Module: %d - Selected next credential set from list of previously missed sets (%s/%s).", _psLogin->iId, _psCredSet->psUser->pUser, _psCredSet->pPass);
  }

  else
  {
    writeError(6, "Login Module: %d - No additional missed users/passwords, setting credential status to CREDENTIAL_DONE.", _psLogin->iId);
    _psCredSet->iStatus = 3;
    _psLogin->psServer->psHost->iUserStatus = 3;
  }
  _psLogin->psUser = _psCredSet->psUser;
  return 0;
}

// getNextNormalCredSet
// file medusa.c line 1143
signed int getNextNormalCredSet(struct __sLogin *_psLogin, struct __sCredentialSet *_psCredSet)
{
  signed int nUserListChecked = 0;
  _psCredSet->iStatus = 1;
  if(_psLogin->psUser == ((struct __sUser *)NULL))
  {
    writeError(7, "[getNextNormalCred] Initial credential set request for login module.");
    _psLogin->psServer->psHost->iUserStatus = 1;
    _psCredSet->iStatus = 2;
    if(_psLogin->psServer->psAudit->iParallelLoginFlag == 2)
    {
      if(_psLogin->psServer->psHost->psUserCurrent == ((struct __sUser *)NULL))
        _psLogin->psServer->psHost->psUserCurrent = _psLogin->psServer->psHost->psUser;

      _psLogin->psUser = _psLogin->psServer->psHost->psUserCurrent;
      if(!(_psLogin->psUser == ((struct __sUser *)NULL)))
        writeError(7, "[getNextNormalCred] (PARALLEL_LOGINS_PASSWORD) setting user: %s", _psLogin->psUser->pUser);

    }

    else
    {
      if(_psLogin->psServer->psHost->psUserCurrent == ((struct __sUser *)NULL))
      {
        writeError(7, "[getNextNormalCred] Assigning initial user for host being tested.");
        _psLogin->psServer->psHost->psUserCurrent = _psLogin->psServer->psHost->psUser;
        _psLogin->psUser = _psLogin->psServer->psHost->psUserCurrent;
      }

      else
      {
        writeError(7, "[getNextNormalCred] Assigning next available user for host being tested.");
        _psLogin->psUser = _psLogin->psServer->psHost->psUserCurrent->psUserNext;
        _psLogin->psServer->psHost->psUserCurrent = _psLogin->psUser;
      }
      if(!(_psLogin->psUser == ((struct __sUser *)NULL)))
        writeError(7, "[getNextNormalCred] (PARALLEL_LOGINS_USER) setting NEW user: %s", _psLogin->psUser->pUser);

    }
  }

  _Bool tmp_if_expr_1;
  while(!(_psLogin->psUser == ((struct __sUser *)NULL)))
  {
    _psCredSet->pPass=getNextPass(_psLogin);
    if(!(_psCredSet->pPass == ((char *)NULL)))
      break;

    if(_psLogin->psUser->iPassStatus == 5)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = _psLogin->psUser->iPassStatus == 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      writeError(6, "Login Module: %d - Current user password list is complete, selecting next user.", _psLogin->iId);
      if(_psLogin->psServer->psHost->psUserCurrent == ((struct __sUser *)NULL))
        _psLogin->psUser = (struct __sUser *)(void *)0;

      else
      {
        _psLogin->psUser = _psLogin->psServer->psHost->psUserCurrent->psUserNext;
        _psLogin->psServer->psHost->psUserCurrent = _psLogin->psUser;
      }
      if(_psLogin->psUser == ((struct __sUser *)NULL))
      {
        if(nUserListChecked == 0)
        {
          writeError(6, "Login Module: %d - Current user password list is complete, rescanning userlist for unfinished credentials.", _psLogin->iId);
          _psLogin->psUser = _psLogin->psServer->psHost->psUser;
          _psLogin->psServer->psHost->psUserCurrent = _psLogin->psUser;
          nUserListChecked = 1;
        }

        else
        {
          writeError(6, "Login Module: %d - No more user accounts available for testing.", _psLogin->iId);
          _psCredSet->iStatus = 3;
        }
      }

      else
      {
        writeError(6, "Login Module: %d - Selecting next password for user: %s", _psLogin->iId, _psLogin->psUser->pUser);
        _psCredSet->iStatus = 2;
      }
    }

  }
  _Bool tmp_if_expr_2;
  if(_psLogin->psUser == ((struct __sUser *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = _psCredSet->pPass == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    writeError(6, "Login Module: %d - No more users/passwords available in the normal queue.", _psLogin->iId);
    _psLogin->psServer->psHost->iUserStatus = 2;
  }

  _psCredSet->psUser = _psLogin->psUser;
  return 0;
}

// getNextPass
// file medusa.c line 1058
char * getNextPass(struct __sLogin *_psLogin)
{
  struct __sAudit *_psAudit = _psLogin->psServer->psAudit;
  struct __sUser *_psUser = _psLogin->psUser;
  char *pPass = (char *)(void *)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  if(!(_psUser->iPassStatus == 5))
  {
    if(!(_psUser->iPassStatus == 6))
    {
      if(_psUser->iPassStatus == 0)
        _psUser->iPassStatus = 1;

      if(_psUser->iPassStatus == 1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = _psUser->iPassStatus == 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(_psUser->iPassStatus == 1)
          tmp_if_expr_1 = _psAudit->iPasswordBlankFlag != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
        {
          pPass = "";
          _psUser->iPassStatus = 2;
        }

        else
          if(!(_psAudit->iPasswordUsernameFlag == 0))
          {
            pPass = _psUser->pUser;
            _psUser->iPassStatus = 3;
          }

          else
            _psUser->iPassStatus = 3;
      }

      if(pPass == ((char *)NULL))
      {
        if(_psUser->iPassStatus == 3)
          tmp_if_expr_3 = _psUser->psPassCurrent != ((struct __sPass *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
        {
          pPass = _psUser->psPassCurrent->pPass;
          _psUser->psPassCurrent = _psUser->psPassCurrent->psPassNext;
        }

        else
          if(!(_psAudit->pGlobalPass == ((char *)NULL)))
          {
            _psUser->iPassStatus = 4;
            if(!(_psUser->pPass == ((char *)NULL)))
            {
              for( ; !((signed int)*_psUser->pPass == 0); _psUser->pPass = _psUser->pPass + 1l)
                ;
              _psUser->pPass = _psUser->pPass + 1l;
              if(!((signed int)*_psUser->pPass == 0))
                pPass = _psUser->pPass;

              else
              {
                _psUser->iPassStatus = 5;
                _psLogin->psServer->psHost->iUsersDone = _psLogin->psServer->psHost->iUsersDone + 1;
              }
            }

            else
            {
              _psUser->pPass = _psAudit->pGlobalPass;
              pPass = _psUser->pPass;
            }
          }

          else
          {
            _psUser->iPassStatus = 5;
            _psLogin->psServer->psHost->iUsersDone = _psLogin->psServer->psHost->iUsersDone + 1;
          }
      }

    }

  }

  return pPass;
}

// initConnectionParams
// file medusa-net.c line 84
void initConnectionParams(struct __sLogin *pLogin, struct __sConnectParams *pParams)
{
  unsigned int return_value_inet_addr_1;
  return_value_inet_addr_1=inet_addr(pLogin->psServer->pHostIP);
  pParams->nHost = (signed long int)return_value_inet_addr_1;
  if(!(pLogin->psServer->psHost->iPortOverride == 0))
    pParams->nPort = pLogin->psServer->psHost->iPortOverride;

  pParams->nUseSSL = pLogin->psServer->psHost->iUseSSL;
  pParams->nTimeout = pLogin->psServer->psHost->iTimeout;
  pParams->nRetryWait = pLogin->psServer->psHost->iRetryWait;
  pParams->nRetries = pLogin->psServer->psHost->iRetries;
  if(pParams->nProtocol == 0)
    pParams->nProtocol = 1;

  if(pParams->nType == 0)
    pParams->nType = 6;

}

// init_crypto_locks
// file medusa-thread-ssl.h line 10
extern void init_crypto_locks(void)
{
  init_locks_openssl();
}

// init_locks_openssl
// file medusa-thread-ssl.c line 40
void init_locks_openssl(void)
{
  signed int i;
  signed int return_value_CRYPTO_num_locks_1;
  return_value_CRYPTO_num_locks_1=CRYPTO_num_locks();
  void *return_value_CRYPTO_malloc_2;
  return_value_CRYPTO_malloc_2=CRYPTO_malloc((signed int)((unsigned long int)(signed int)return_value_CRYPTO_num_locks_1 * sizeof(union anonymous_11) /*40ul*/ ), "medusa-thread-ssl.c", 45);
  lockarray = (union anonymous_11 *)return_value_CRYPTO_malloc_2;
  i = 0;
  signed int return_value_CRYPTO_num_locks_3;
  do
  {
    return_value_CRYPTO_num_locks_3=CRYPTO_num_locks();
    if(i >= return_value_CRYPTO_num_locks_3)
      break;

    pthread_mutex_init(&lockarray[(signed long int)i], (const union anonymous_14 *)(void *)0);
    i = i + 1;
  }
  while((_Bool)1);
  CRYPTO_set_id_callback((unsigned long int (*)())thread_id);
  CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void (*)())lock_callback);
}

// invokeModule
// file medusa.c line 365
signed int invokeModule(char *pModuleName, struct __sLogin *pLogin, signed int argc, char **argv)
{
  void *pLibrary;
  signed int iReturn;
  signed int (*pGo)(struct __sLogin *, signed int, char **);
  void (*pUsage)();
  char *modPath;
  signed int nPathLength;
  signed int i;
  signed int nSuccess = 0;
  iReturn = -1;
  pLibrary = (void *)0;
  pGo = (signed int (*)(struct __sLogin *, signed int, char **))(void *)0;
  pUsage = (void (*)())(void *)0;
  if(pModuleName == ((char *)NULL))
  {
    listModules(szModulePaths, 0);
    writeError(2, "invokeModule called with no name");
    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= 3); i = i + 1)
    {
      if(!(szModulePaths[(signed long int)i] == ((char *)NULL)))
      {
        writeError(7, "Trying module path of %s", szModulePaths[(signed long int)i]);
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(szModulePaths[(signed long int)i]);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(pModuleName);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(".mod");
        nPathLength = (signed int)(return_value_strlen_1 + return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)2);
        void *return_value_malloc_4;
        return_value_malloc_4=malloc((unsigned long int)nPathLength);
        modPath = (char *)return_value_malloc_4;
        memset((void *)modPath, 0, (unsigned long int)nPathLength);
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(szModulePaths[(signed long int)i]);
        strncpy(modPath, szModulePaths[(signed long int)i], return_value_strlen_5);
        strncat(modPath, "/", (unsigned long int)1);
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(pModuleName);
        strncat(modPath, pModuleName, return_value_strlen_6);
        unsigned long int return_value_strlen_7;
        return_value_strlen_7=strlen(".mod");
        strncat(modPath, ".mod", return_value_strlen_7);
        writeError(7, "Attempting to load %s", modPath);
        pLibrary=dlopen(modPath, 0x00002);
        if(pLibrary == NULL)
          goto __CPROVER_DUMP_L10;

        else
          if(pLogin == ((struct __sLogin *)NULL))
          {
            void *return_value_dlsym_8;
            return_value_dlsym_8=dlsym(pLibrary, "showUsage");
            pUsage = (void (*)())return_value_dlsym_8;
            writeError(7, "Attempting to display usage information for module: %s", modPath);
            if(pUsage == ((void (*)())NULL))
            {
              char *return_value_dlerror_9;
              return_value_dlerror_9=dlerror();
              writeError(1, "Couldn't get a pointer to \"showUsage\" for module %s [%s]", modPath, return_value_dlerror_9);
              return -1;
            }

            else
            {
              nSuccess = 1;
              pUsage();
            }
            dlclose(pLibrary);
            exit(0);
          }

          else
          {
            void *return_value_dlsym_10;
            return_value_dlsym_10=dlsym(pLibrary, "go");
            pGo = (signed int (*)(struct __sLogin *, signed int, char **))return_value_dlsym_10;
            if(pGo == ((signed int (*)(struct __sLogin *, signed int, char **))NULL))
            {
              char *return_value_dlerror_11;
              return_value_dlerror_11=dlerror();
              writeError(1, "Couldn't get a pointer to \"go\" for module %s [%s]", modPath, return_value_dlerror_11);
              return -1;
            }

            else
            {
              nSuccess = 1;
              iReturn=pGo(pLogin, argc, argv);
              break;
            }
            dlclose(pLibrary);
          }
      }


    __CPROVER_DUMP_L10:
      ;
    }
    if(nSuccess == 0)
    {
      char *return_value_dlerror_12;
      return_value_dlerror_12=dlerror();
      writeVerbose(3, "Couldn't load \"%s\" [%s]. Place the module in the medusa directory, set the MEDUSA_MODULE_NAME environment variable or run the configure script again using --with-default-mod-path=[path].", pModuleName, return_value_dlerror_12);
      iReturn = -1;
    }

    return iReturn;
  }
}

// job_cleanup
// file medusa-thread-pool.c line 133
static void job_cleanup(struct thr_pool *pool)
{
  unsigned long int my_tid;
  my_tid=pthread_self();
  struct active *activep;
  struct active **activepp;
  pthread_mutex_lock(&pool->pool_mutex);
  activepp = &pool->pool_active;
  do
  {
    activep = *activepp;
    if(activep == ((struct active *)NULL))
      break;

    if(activep->active_tid == my_tid)
    {
      *activepp = activep->active_next;
      break;
    }

    activepp = &activep->active_next;
  }
  while((_Bool)1);
  if(!((0x01 & pool->pool_flags) == 0))
    notify_waiters(pool);

}

// kill_crypto_locks
// file medusa-thread-ssl.h line 11
extern void kill_crypto_locks(void)
{
  kill_locks_openssl();
}

// kill_locks_openssl
// file medusa-thread-ssl.c line 55
void kill_locks_openssl(void)
{
  signed int i;
  CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
  i = 0;
  signed int return_value_CRYPTO_num_locks_1;
  do
  {
    return_value_CRYPTO_num_locks_1=CRYPTO_num_locks();
    if(i >= return_value_CRYPTO_num_locks_1)
      break;

    pthread_mutex_destroy(&lockarray[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  CRYPTO_free((void *)lockarray);
}

// listModules
// file listModules.c line 44
void listModules(char **arrPaths, signed int nTerminateNow)
{
  struct dirent **pdeEntry;
  char *pszTarget;
  signed int iLength;
  void *pLibrary;
  signed int (*pSummary)(char **);
  char *pszUsage;
  char *pszLibName;
  char *pszDir;
  signed int i;
  signed int j;
  signed int k;
  pszTarget = (char *)(void *)0;
  iLength = 0;
  pLibrary = (void *)0;
  pSummary = (signed int (*)(char **))(void *)0;
  pszUsage = (char *)(void *)0;
  pszLibName = (char *)(void *)0;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    pszDir = arrPaths[(signed long int)i];
    if(pszDir == ((char *)NULL))
      goto __CPROVER_DUMP_L16;

    else
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(pszDir);
      iLength = (signed int)(return_value_strlen_1 + (unsigned long int)1);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)iLength);
      pszTarget = (char *)return_value_malloc_2;
      memset((void *)pszTarget, 0, (unsigned long int)iLength);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(pszDir);
      strncpy(pszTarget, pszDir, return_value_strlen_3);
      iLength = 0;
    }
    writeVerbose(1, "  Available modules in \"%s\" :", pszTarget);
    k=scandir(pszTarget, &pdeEntry, ((signed int (*)(struct dirent *))NULL), alphasort);
    if(!(k >= 0))
    {
      if(nTerminateNow >= 1)
        writeVerbose(0, "\tCouldn't open directory \"%s\"", pszTarget);

      else
        writeVerbose(1, "\tCouldn't open directory \"%s\"", pszTarget);
    }

    else
    {
      j = -1;
      do
      {
        j = j + 1;
        if(j >= k)
          break;

        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(pdeEntry[(signed long int)j]->d_name);
        iLength = (signed int)return_value_strlen_4;
        if(iLength >= 5)
        {
          unsigned long int return_value_strlen_13;
          return_value_strlen_13=strlen(pdeEntry[(signed long int)j]->d_name);
          signed int return_value_strcmp_14;
          return_value_strcmp_14=strcmp((char *)((pdeEntry[(signed long int)j]->d_name + (signed long int)return_value_strlen_13) - (signed long int)4), ".mod");
          if(return_value_strcmp_14 == 0)
          {
            unsigned long int return_value_strlen_5;
            return_value_strlen_5=strlen(pdeEntry[(signed long int)j]->d_name);
            unsigned long int return_value_strlen_6;
            return_value_strlen_6=strlen(pszTarget);
            iLength = (signed int)(return_value_strlen_5 + return_value_strlen_6 + (unsigned long int)2);
            void *return_value_malloc_7;
            return_value_malloc_7=malloc((unsigned long int)iLength);
            pszLibName = (char *)return_value_malloc_7;
            memset((void *)pszLibName, 0, (unsigned long int)iLength);
            unsigned long int return_value_strlen_8;
            return_value_strlen_8=strlen(pszTarget);
            strncpy(pszLibName, pszTarget, return_value_strlen_8);
            strncat(pszLibName, "/", (unsigned long int)1);
            unsigned long int return_value_strlen_9;
            return_value_strlen_9=strlen(pdeEntry[(signed long int)j]->d_name);
            strncat(pszLibName, pdeEntry[(signed long int)j]->d_name, return_value_strlen_9);
            pLibrary=dlopen(pszLibName, 0x00002);
            if(pLibrary == NULL)
            {
              char *return_value_dlerror_10;
              return_value_dlerror_10=dlerror();
              writeVerbose(1, "    + %s : Couldn't load \"%s\" [%s]", (const void *)pdeEntry[(signed long int)j]->d_name, pszLibName, return_value_dlerror_10);
            }

            else
            {
              void *return_value_dlsym_11;
              return_value_dlsym_11=dlsym(pLibrary, "summaryUsage");
              pSummary = (signed int (*)(char **))return_value_dlsym_11;
              if(pSummary == ((signed int (*)(char **))NULL))
              {
                char *return_value_dlerror_12;
                return_value_dlerror_12=dlerror();
                writeVerbose(1, "    + %s : Invalid module %s [no export of summaryUsage() : %s]", (const void *)pdeEntry[(signed long int)j]->d_name, pszLibName, return_value_dlerror_12);
              }

              else
              {
                pszUsage = (char *)(void *)0;
                pSummary((char **)&pszUsage);
                writeVerbose(1, "    + %s : %s", (const void *)pdeEntry[(signed long int)j]->d_name, pszUsage);
                free((void *)pszUsage);
              }
              dlclose(pLibrary);
            }
            free((void *)pszLibName);
          }

        }

        free((void *)pdeEntry[(signed long int)j]);
      }
      while((_Bool)1);
      writeVerbose(1, "");
    }
    free((void *)pszTarget);

  __CPROVER_DUMP_L16:
    ;
  }
  if(nTerminateNow >= 1)
    writeVerbose(0, "");

}

// loadFile
// file medusa.c line 463
void loadFile(char *pFile, char **pFileContent, signed int *iFileCnt)
{
  struct _IO_FILE *pfFile;
  unsigned long int stFileSize = (unsigned long int)0;
  char tmp[16384l];
  char *ptr;
  *iFileCnt = 0;
  pfFile=fopen(pFile, "r");
  signed int return_value_feof_3;
  signed int return_value_feof_7;
  _Bool tmp_if_expr_14;
  unsigned long int return_value_strlen_8;
  unsigned long int return_value_strlen_10;
  if(pfFile == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    writeError(0, "Failed to open file %s - %s", pFile, return_value_strerror_2);
  }

  else
  {
    do
    {
      return_value_feof_3=feof(pfFile);
      if(!(return_value_feof_3 == 0))
        break;

      char *return_value_fgets_5;
      return_value_fgets_5=fgets(tmp, 16384, pfFile);
      if(!(return_value_fgets_5 == ((char *)NULL)))
      {
        if(!((signed int)tmp[0l] == 0))
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(tmp);
          stFileSize = stFileSize + return_value_strlen_4 + (unsigned long int)1;
          *iFileCnt = *iFileCnt + 1;
        }

      }

    }
    while((_Bool)1);
    rewind(pfFile);
    void *return_value_malloc_6;
    return_value_malloc_6=malloc(stFileSize + (unsigned long int)1);
    *pFileContent = (char *)return_value_malloc_6;
    if(pFileContent == ((char **)NULL))
      writeError(0, "Failed to allocate memory for file %s.", pFile);

    memset((void *)*pFileContent, 0, stFileSize + (unsigned long int)1);
    ptr = *pFileContent;
    do
    {
      return_value_feof_7=feof(pfFile);
      if(!(return_value_feof_7 == 0))
        break;

      char *return_value_fgets_15;
      return_value_fgets_15=fgets(tmp, 16384, pfFile);
      if(!(return_value_fgets_15 == ((char *)NULL)))
      {
        if((signed int)tmp[0l] == 10)
          tmp_if_expr_14 = (_Bool)1;

        else
          tmp_if_expr_14 = (signed int)tmp[(signed long int)0] == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_14)
        {
          *iFileCnt = *iFileCnt - 1;
          writeError(7, "Ignoring blank line in file: %s. Resetting total count: %d.", pFile, *iFileCnt);
        }

        else
          if(!((signed int)tmp[0l] == 0))
          {
            unsigned long int return_value_strlen_9;
            return_value_strlen_9=strlen(tmp);
            if((signed int)tmp[-1l + (signed long int)return_value_strlen_9] == 10)
            {
              return_value_strlen_8=strlen(tmp);
              tmp[(signed long int)(return_value_strlen_8 - (unsigned long int)1)] = (char)0;
            }

            unsigned long int return_value_strlen_11;
            return_value_strlen_11=strlen(tmp);
            if((signed int)tmp[-1l + (signed long int)return_value_strlen_11] == 13)
            {
              return_value_strlen_10=strlen(tmp);
              tmp[(signed long int)(return_value_strlen_10 - (unsigned long int)1)] = (char)0;
            }

            unsigned long int return_value_strlen_12;
            return_value_strlen_12=strlen(tmp);
            memcpy((void *)ptr, (const void *)tmp, return_value_strlen_12 + (unsigned long int)1);
            unsigned long int return_value_strlen_13;
            return_value_strlen_13=strlen(tmp);
            ptr = ptr + (signed long int)(return_value_strlen_13 + (unsigned long int)1);
          }

      }

    }
    while((_Bool)1);
    *ptr = (char)0;
  }
  if(*iFileCnt == 0)
    writeError(0, "Error loading user supplied file (%s) -- file may be empty.", pFile);

  free((void *)pFile);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// loadLoginInfo
// file medusa.c line 913
signed int loadLoginInfo(struct __sAudit *_psAudit)
{
  struct __sHost *psHost = (struct __sHost *)(void *)0;
  struct __sHost *psHostPrevTmp = (struct __sHost *)(void *)0;
  char *pHost = (char *)(void *)0;
  struct __sUser *psUser = (struct __sUser *)(void *)0;
  char *pUser = (char *)(void *)0;
  struct __sPass *psPass = (struct __sPass *)(void *)0;
  char *pPass = (char *)(void *)0;
  _psAudit->iHostCnt = 0;
  _psAudit->iHostsDone = 0;
  do
  {
    pHost=findNextHost(_psAudit, pHost);
    if(pHost == ((char *)NULL))
      break;

    psHost = _psAudit->psHostRoot;
    while(!(psHost == ((struct __sHost *)NULL)))
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(pHost, psHost->pHost);
      if(!(return_value_strcmp_1 == 0))
        psHost = psHost->psHostNext;

      else
        break;
    }
    if(psHost == ((struct __sHost *)NULL))
    {
      _psAudit->iHostCnt = _psAudit->iHostCnt + 1;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct __sHost) /*88ul*/ );
      psHost = (struct __sHost *)return_value_malloc_2;
      memset((void *)psHost, 0, sizeof(struct __sHost) /*88ul*/ );
      if(_psAudit->psHostRoot == ((struct __sHost *)NULL))
      {
        _psAudit->psHostRoot = psHost;
        psHostPrevTmp = _psAudit->psHostRoot;
      }

      else
      {
        psHostPrevTmp->psHostNext = psHost;
        psHostPrevTmp = psHost;
      }
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(pHost);
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(return_value_strlen_3 + (unsigned long int)1);
      psHost->pHost = (char *)return_value_malloc_4;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(pHost);
      memset((void *)psHost->pHost, 0, return_value_strlen_5 + (unsigned long int)1);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(pHost);
      strncpy(psHost->pHost, pHost, return_value_strlen_6 + (unsigned long int)1);
      psHost->iPortOverride = _psAudit->iPortOverride;
      psHost->iUseSSL = _psAudit->iUseSSL;
      psHost->iTimeout = _psAudit->iTimeout;
      psHost->iRetryWait = _psAudit->iRetryWait;
      psHost->iRetries = _psAudit->iRetries;
      psHost->iUserCnt = 0;
      psHost->iId = _psAudit->iHostCnt;
    }

    do
    {
      pUser=findNextUser(_psAudit, pUser);
      if(pUser == ((char *)NULL))
        break;

      psUser = psHost->psUser;
      while(!(psUser == ((struct __sUser *)NULL)))
      {
        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(pUser, psUser->pUser);
        if(!(return_value_strcmp_7 == 0))
          psUser = psUser->psUserNext;

        else
          break;
      }
      if(psUser == ((struct __sUser *)NULL))
      {
        psHost->iUserCnt = psHost->iUserCnt + 1;
        void *return_value_malloc_8;
        return_value_malloc_8=malloc(sizeof(struct __sUser) /*64ul*/ );
        psUser = (struct __sUser *)return_value_malloc_8;
        memset((void *)psUser, 0, sizeof(struct __sUser) /*64ul*/ );
        if(!(psHost->psUserPrevTmp == ((struct __sUser *)NULL)))
          psHost->psUserPrevTmp->psUserNext = psUser;

        else
          psHost->psUser = psUser;
        psHost->psUserPrevTmp = psUser;
        unsigned long int return_value_strlen_9;
        return_value_strlen_9=strlen(pUser);
        void *return_value_malloc_10;
        return_value_malloc_10=malloc(return_value_strlen_9 + (unsigned long int)1);
        psUser->pUser = (char *)return_value_malloc_10;
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen(pUser);
        memset((void *)psUser->pUser, 0, return_value_strlen_11 + (unsigned long int)1);
        unsigned long int return_value_strlen_12;
        return_value_strlen_12=strlen(pUser);
        strncpy(psUser->pUser, pUser, return_value_strlen_12);
        psUser->iPassCnt = _psAudit->iPassCnt;
        psUser->iPassStatus = 0;
        psUser->iId = psHost->iUserCnt;
        psHost->iUserPassCnt = psHost->iUserPassCnt + _psAudit->iPassCnt;
        if(!(_psAudit->iPasswordUsernameFlag == 0))
        {
          psHost->iUserPassCnt = psHost->iUserPassCnt + 1;
          psUser->iPassCnt = psUser->iPassCnt + 1;
        }

        if(!(_psAudit->iPasswordBlankFlag == 0))
        {
          psHost->iUserPassCnt = psHost->iUserPassCnt + 1;
          psUser->iPassCnt = psUser->iPassCnt + 1;
        }

      }

      pPass=findLocalPass(_psAudit);
      if(!(pPass == ((char *)NULL)))
      {
        void *return_value_malloc_13;
        return_value_malloc_13=malloc(sizeof(struct __sPass) /*16ul*/ );
        psPass = (struct __sPass *)return_value_malloc_13;
        memset((void *)psPass, 0, sizeof(struct __sPass) /*16ul*/ );
        unsigned long int return_value_strlen_14;
        return_value_strlen_14=strlen(pPass);
        void *return_value_malloc_15;
        return_value_malloc_15=malloc(return_value_strlen_14 + (unsigned long int)1);
        psPass->pPass = (char *)return_value_malloc_15;
        unsigned long int return_value_strlen_16;
        return_value_strlen_16=strlen(pPass);
        memset((void *)psPass->pPass, 0, return_value_strlen_16 + (unsigned long int)1);
        unsigned long int return_value_strlen_17;
        return_value_strlen_17=strlen(pPass);
        strncpy(psPass->pPass, pPass, return_value_strlen_17);
        psUser->iPassCnt = psUser->iPassCnt + 1;
        psHost->iUserPassCnt = psHost->iUserPassCnt + 1;
        if(!(psUser->psPassPrevTmp == ((struct __sPass *)NULL)))
          psUser->psPassPrevTmp->psPassNext = psPass;

        else
        {
          psUser->psPass = psPass;
          psUser->psPassCurrent = psPass;
        }
        psUser->psPassPrevTmp = psPass;
      }

    }
    while((_Bool)1);
  }
  while((_Bool)1);
  return 0;
}

// lock_callback
// file medusa-thread-ssl.c line 20
static void lock_callback(signed int mode, signed int type, char *file, signed int line)
{
  (void)file;
  (void)line;
  if(!((1 & mode) == 0))
    pthread_mutex_lock(&lockarray[(signed long int)type]);

  else
    pthread_mutex_unlock(&lockarray[(signed long int)type]);
}

// main
// file medusa.c line 1977
signed int main(signed int argc, char **argv, char **envp)
{
  struct sigaction sig_action;
  signed int iExitStatus = 0;
  signed int i;
  struct tm *tm_ptr;
  signed long int the_time;
  char time_buf[256l];
  sig_action.sa_flags = 0;
  sigemptyset(&sig_action.sa_mask);
  sigaddset(&sig_action.sa_mask, 2);
  sig_action.__sigaction_handler.sa_handler = sigint_handler;
  sigaction(2, &sig_action, ((struct sigaction *)NULL));
  szModuleName = (char *)(void *)0;
  szModulePaths[(signed long int)0]=getenv("MEDUSA_MODULE_PATH");
  szModulePaths[(signed long int)1] = ".";
  szModulePaths[(signed long int)2] = "/usr/lib/medusa/modules";
  szTempModuleParam = (char *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char *) /*8ul*/ );
  arrModuleParams = (char **)return_value_malloc_1;
  memset((void *)arrModuleParams, 0, sizeof(char *) /*8ul*/ );
  nModuleParamCount = 0;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct __sAudit) /*296ul*/ );
  psAudit = (struct __sAudit *)return_value_malloc_2;
  memset((void *)psAudit, 0, sizeof(struct __sAudit) /*296ul*/ );
  signed int return_value_pthread_mutex_init_5;
  return_value_pthread_mutex_init_5=pthread_mutex_init(&psAudit->ptmMutex, (const union anonymous_14 *)(void *)0);
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(return_value_pthread_mutex_init_5 == 0))
  {
    return_value___errno_location_3=__errno_location();
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    writeError(0, "Audit mutex initialization failed - %s\n", return_value_strerror_4);
  }

  signed int return_value_checkOptions_6;
  return_value_checkOptions_6=checkOptions(argc, argv, psAudit);
  if(!(return_value_checkOptions_6 == 0))
  {
    usage();
    exit(1);
  }

  i = 0;
  for( ; !(i >= nModuleParamCount); i = i + 1)
    writeVerbose(6, "Module parameter: %s", arrModuleParams[(signed long int)i]);
  if(szModuleName == ((char *)NULL))
  {
    writeVerbose(0, "You must specify a module to execute using -M MODULE_NAME");
    freeModuleParams();
    exit(1);
  }

  if(psAudit->HostType == 2)
  {
    loadFile(psAudit->pOptHost, &psAudit->pHostFile, &psAudit->iHostCnt);
    psAudit->pGlobalHost = psAudit->pHostFile;
  }

  if(psAudit->UserType == 2)
  {
    loadFile(psAudit->pOptUser, &psAudit->pUserFile, &psAudit->iUserCnt);
    psAudit->pGlobalUser = psAudit->pUserFile;
  }

  if(psAudit->PassType == 2)
  {
    loadFile(psAudit->pOptPass, &psAudit->pPassFile, &psAudit->iPassCnt);
    psAudit->pGlobalPass = psAudit->pPassFile;
  }

  if(!(psAudit->pOptCombo == ((char *)NULL)))
  {
    loadFile(psAudit->pOptCombo, &psAudit->pComboFile, &psAudit->iComboCnt);
    psAudit->pGlobalCombo = psAudit->pComboFile;
    signed int return_value_processComboFile_7;
    return_value_processComboFile_7=processComboFile(&psAudit);
    if(!(return_value_processComboFile_7 == 0))
      exit(iExitStatus);

  }

  signed int return_value_loadLoginInfo_8;
  return_value_loadLoginInfo_8=loadLoginInfo(psAudit);
  if(return_value_loadLoginInfo_8 == 0)
    writeError(7, "Successfully loaded login information.");

  else
    writeError(0, "Failed to load login information.");
  if(!(psAudit->pOptCombo == ((char *)NULL)))
    free((void *)psAudit->pComboFile);

  if(!(psAudit->pHostFile == ((char *)NULL)))
    free((void *)psAudit->pHostFile);

  if(!(psAudit->pUserFile == ((char *)NULL)))
    free((void *)psAudit->pUserFile);

  signed int *return_value___errno_location_11;
  char *return_value_strerror_12;
  if(!(psAudit->pOptOutput == ((char *)NULL)))
  {
    pOutputFile=fopen(psAudit->pOptOutput, "a+");
    if(pOutputFile == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(*return_value___errno_location_9);
      writeError(0, "Failed to open output file %s - %s", psAudit->pOptOutput, return_value_strerror_10);
    }

    else
    {
      signed int return_value_pthread_mutex_init_13;
      return_value_pthread_mutex_init_13=pthread_mutex_init(&ptmFileMutex, (const union anonymous_14 *)(void *)0);
      if(!(return_value_pthread_mutex_init_13 == 0))
      {
        return_value___errno_location_11=__errno_location();
        return_value_strerror_12=strerror(*return_value___errno_location_11);
        writeError(0, "File mutex initialization failed - %s\n", return_value_strerror_12);
      }

      time(&the_time);
      tm_ptr=localtime(&the_time);
      strftime(time_buf, (unsigned long int)256, "%Y-%m-%d %H:%M:%S", tm_ptr);
      writeVerbose(2, "# Medusa v.%s (%s)\n", (const void *)"2.2_rc3", (const void *)time_buf);
      writeVerbose(2, "# ");
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        writeVerbose(2, "%s ", argv[(signed long int)i]);
      writeVerbose(2, "\n");
    }
  }

  signed int return_value_startServerThreadPool_14;
  return_value_startServerThreadPool_14=startServerThreadPool(psAudit);
  if(return_value_startServerThreadPool_14 == 0)
  {
    time(&the_time);
    tm_ptr=localtime(&the_time);
    strftime(time_buf, (unsigned long int)256, "%Y-%m-%d %H:%M:%S", tm_ptr);
    writeVerbose(2, "# Medusa has finished (%s).\n", (const void *)time_buf);
    writeVerbose(6, "Medusa has finished.");
    iExitStatus = 0;
  }

  else
  {
    time(&the_time);
    tm_ptr=localtime(&the_time);
    strftime(time_buf, (unsigned long int)256, "%Y-%m-%d %H:%M:%S", tm_ptr);
    writeVerbose(2, "# Medusa failed (%s).\n", (const void *)time_buf);
    writeError(2, "Medusa failed.");
    iExitStatus = 1;
  }
  signed int return_value_pthread_mutex_destroy_17;
  signed int *return_value___errno_location_15;
  char *return_value_strerror_16;
  if(!(psAudit->pOptOutput == ((char *)NULL)))
  {
    return_value_pthread_mutex_destroy_17=pthread_mutex_destroy(&ptmFileMutex);
    if(!(return_value_pthread_mutex_destroy_17 == 0))
    {
      return_value___errno_location_15=__errno_location();
      return_value_strerror_16=strerror(*return_value___errno_location_15);
      writeError(0, "File mutex destroy call failed - %s\n", return_value_strerror_16);
    }

  }

  signed int return_value_pthread_mutex_destroy_20;
  return_value_pthread_mutex_destroy_20=pthread_mutex_destroy(&psAudit->ptmMutex);
  signed int *return_value___errno_location_18;
  char *return_value_strerror_19;
  if(!(return_value_pthread_mutex_destroy_20 == 0))
  {
    return_value___errno_location_18=__errno_location();
    return_value_strerror_19=strerror(*return_value___errno_location_18);
    writeError(0, "Audit mutex destroy call failed - %s\n", return_value_strerror_19);
  }

  free((void *)psAudit->pPassFile);
  free((void *)psAudit);
  if(!(szModuleName == ((char *)NULL)))
    free((void *)szModuleName);

  freeModuleParams();
  exit(iExitStatus);
}

// makeToLower
// file medusa-net.c line 887
extern signed int makeToLower(char *buf)
{
  if(buf == ((char *)NULL))
    return 1;

  else
  {
    while(!((signed int)*buf == 0))
    {
      signed int return_value_tolower_1;
      return_value_tolower_1=tolower((signed int)buf[(signed long int)0]);
      buf[(signed long int)0] = (char)return_value_tolower_1;
      buf = buf + 1l;
    }
    return 1;
  }
}

// medusaCheckSocket
// file medusa-net.c line 745
extern signed int medusaCheckSocket(signed int socket, signed int usec)
{
  writeError(7, "Socket Check - wait time: %d", usec);
  signed int return_value_medusaDataReadyTimed_1;
  return_value_medusaDataReadyTimed_1=medusaDataReadyTimed(socket, (signed long int)0, (signed long int)usec);
  if(return_value_medusaDataReadyTimed_1 == 0)
    return 1;

  else
    return 0;
}

// medusaConnect
// file medusa-net.c line 616
extern signed int medusaConnect(struct __sConnectParams *pParams)
{
  signed int return_value_medusaConnectInternal_1;
  return_value_medusaConnectInternal_1=medusaConnectInternal((unsigned long int)pParams->nHost, pParams->nPort, pParams->nProtocol, pParams->nType, pParams->nTimeout, pParams->nRetries, pParams->nRetryWait, pParams->nProxyStringIP, pParams->nProxyStringPort, pParams->szProxyAuthentication, pParams->nSourcePort);
  return return_value_medusaConnectInternal_1;
}

// medusaConnectInternal
// file medusa-net.c line 102
signed int medusaConnectInternal(unsigned long int nHost, signed int nPort, signed int nProtocol, signed int nType, signed int nWaitTime, signed int nRetries, signed int nRetryWait, unsigned long int nProxyStringIP, signed int nProxyStringPort, char *szProxyAuthentication, signed int nSourcePort)
{
  signed int s;
  signed int ret = -1;
  signed int nFail = 0;
  struct sockaddr_in target;
  struct sockaddr_in source;
  char *buf;
  char *tmpptr = (char *)(void *)0;
  char out[16l];
  signed long int flag;
  signed int nOpt;
  unsigned int nSize;
  struct anonymous_0 myset;
  struct timeval tv;
  signed int nUseProxy = nProxyStringIP > (unsigned long int)0 ? 1 : 0;
  s=socket(2, nProtocol, nType);
  unsigned int return_value_getuid_1;
  _Bool tmp_if_expr_20;
  signed int *return_value___errno_location_19;
  const char *return_value_inet_ntop_29;
  const char *return_value_inet_ntop_30;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_35;
  if(s >= 0)
  {
    if(!(nSourcePort == 0))
    {
      signed int bind_ok = 0;
      source.sin_family = (unsigned short int)2;
      source.sin_port=htons((unsigned short int)nSourcePort);
      source.sin_addr.s_addr = (unsigned int)0x00000000;
      while(bind_ok == 0 && nSourcePort >= 512)
      {
        signed int return_value_bind_4;
        return_value_bind_4=bind(s, (struct sockaddr *)&source, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
        if(return_value_bind_4 == -1)
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(*return_value___errno_location_3 == 98)
          {
            writeError(7, "Port %d in use trying next lower port.", nSourcePort);
            nSourcePort = nSourcePort - 1;
            source.sin_port=htons((unsigned short int)nSourcePort);
          }

          else
          {
            signed int *return_value___errno_location_2;
            return_value___errno_location_2=__errno_location();
            if(*return_value___errno_location_2 == 13)
            {
              return_value_getuid_1=getuid();
              if(return_value_getuid_1 >= 1u)
              {
                writeError(3, "Source port for this service requires root privileges.");
                return -1;
              }

            }

          }
        }

        else
          bind_ok = 1;
      }
    }

    if(nUseProxy >= 1)
    {
      target.sin_port=htons((unsigned short int)nProxyStringPort);
      memcpy((void *)&target.sin_addr.s_addr, (const void *)&nProxyStringIP, sizeof(unsigned long int) /*8ul*/ );
    }

    else
    {
      target.sin_port=htons((unsigned short int)nPort);
      memcpy((void *)&target.sin_addr.s_addr, (const void *)&nHost, sizeof(unsigned long int) /*8ul*/ );
    }
    target.sin_family = (unsigned short int)2;
    signed int return_value_fcntl_7;
    return_value_fcntl_7=fcntl(s, 3, (void *)0);
    flag = (signed long int)return_value_fcntl_7;
    if(!(flag >= 0l))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      writeError(3, "Error fcntl(..., F_GETFL) (%s)", return_value_strerror_6);
      return -1;
    }

    flag = flag | (signed long int)04000;
    signed int return_value_fcntl_10;
    return_value_fcntl_10=fcntl(s, 4, flag);
    if(!(return_value_fcntl_10 >= 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      char *return_value_strerror_9;
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      writeError(3, "Error fcntl(..., F_SETFL) (%s)", return_value_strerror_9);
      return -1;
    }

    nFail = 0;
    ret=connect(s, (struct sockaddr *)&target, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    signed int *return_value___errno_location_21;
    return_value___errno_location_21=__errno_location();
    if(*return_value___errno_location_21 == 115)
      while((_Bool)1)
      {
        if(nFail >= 1 && nRetries >= nFail)
        {
          unsigned long int return_value_pthread_self_11;
          return_value_pthread_self_11=pthread_self();
          const char *return_value_inet_ntop_12;
          return_value_inet_ntop_12=inet_ntop(2, (const void *)&target.sin_addr, out, (unsigned int)sizeof(char [16l]) /*16ul*/ );
          writeError(3, "Thread %X: Host: %s Cannot connect [unreachable], retrying (%d of %d retries)", (signed int)return_value_pthread_self_11, return_value_inet_ntop_12, nFail, nRetries);
          sleep((unsigned int)nRetryWait);
        }

        else
          if(!(nRetries >= nFail))
            return -1;

        tv.tv_sec = (signed long int)nWaitTime;
        tv.tv_usec = (signed long int)0;
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&myset)->fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&myset)->fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&myset)->fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        ret=select(s + 1, (struct anonymous_0 *)(void *)0, &myset, (struct anonymous_0 *)(void *)0, &tv);
        if(!(ret >= 0))
        {
          return_value___errno_location_19=__errno_location();
          tmp_if_expr_20 = *return_value___errno_location_19 != 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_20 = (_Bool)0;
        if(tmp_if_expr_20)
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          char *return_value_strerror_14;
          return_value_strerror_14=strerror(*return_value___errno_location_13);
          writeError(3, "Error connecting to host: %s", return_value_strerror_14);
          return -1;
        }

        else
          if(ret >= 1)
          {
            nSize = (unsigned int)sizeof(signed int) /*4ul*/ ;
            signed int return_value_getsockopt_17;
            return_value_getsockopt_17=getsockopt(s, 1, 4, (void *)&nOpt, &nSize);
            if(!(return_value_getsockopt_17 >= 0))
            {
              signed int *return_value___errno_location_15;
              return_value___errno_location_15=__errno_location();
              char *return_value_strerror_16;
              return_value_strerror_16=strerror(*return_value___errno_location_15);
              writeError(3, "Error in getsockopt() %s", return_value_strerror_16);
              return -1;
            }

            if(!(nOpt == 0))
            {
              const char *return_value_inet_ntop_18;
              return_value_inet_ntop_18=inet_ntop(2, (const void *)&target.sin_addr, out, (unsigned int)sizeof(char [16l]) /*16ul*/ );
              writeVerbose(6, "Unable to connect (invalid socket): unreachable destination - %s", return_value_inet_ntop_18);
              return -1;
            }

            ret = 0;
            break;
          }

          else
            nFail = nFail + 1;
      }

    if(!(ret == 0) || !(nRetries >= nFail))
    {
      writeVerbose(6, "Unable to connect: unreachable destination");
      ret = -1;
      return ret;
    }

    signed int return_value_fcntl_24;
    return_value_fcntl_24=fcntl(s, 3, (void *)0);
    flag = (signed long int)return_value_fcntl_24;
    if(!(flag >= 0l))
    {
      signed int *return_value___errno_location_22;
      return_value___errno_location_22=__errno_location();
      char *return_value_strerror_23;
      return_value_strerror_23=strerror(*return_value___errno_location_22);
      writeError(3, "Error fcntl(..., F_GETFL) (%s)", return_value_strerror_23);
      return -1;
    }

    flag = flag & (signed long int)~04000;
    signed int return_value_fcntl_27;
    return_value_fcntl_27=fcntl(s, 4, flag);
    if(!(return_value_fcntl_27 >= 0))
    {
      signed int *return_value___errno_location_25;
      return_value___errno_location_25=__errno_location();
      char *return_value_strerror_26;
      return_value_strerror_26=strerror(*return_value___errno_location_25);
      writeError(3, "Error fcntl(..., F_SETFL) (%s)", return_value_strerror_26);
      return -1;
    }

    ret = s;
    writeError(7, "Connected (internal)");
    if(nUseProxy >= 1)
    {
      void *return_value_malloc_28;
      return_value_malloc_28=malloc((unsigned long int)4096);
      buf = (char *)return_value_malloc_28;
      memset((void *)buf, 0, (unsigned long int)4096);
      memset((void *)&target, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      memcpy((void *)&target.sin_addr.s_addr, (const void *)&nHost, sizeof(unsigned long int) /*8ul*/ );
      target.sin_family = (unsigned short int)2;
      if(szProxyAuthentication == ((char *)NULL))
      {
        return_value_inet_ntop_29=inet_ntop(2, (const void *)&target.sin_addr, out, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        snprintf(buf, (unsigned long int)4095, "CONNECT %s:%d HTTP/1.0\r\n\r\n", return_value_inet_ntop_29, nPort);
      }

      else
      {
        return_value_inet_ntop_30=inet_ntop(2, (const void *)&target.sin_addr, out, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        snprintf(buf, (unsigned long int)4095, "CONNECT %s:%d HTTP/1.0\r\nProxy-Authorization: Basic %s\r\n\r\n", return_value_inet_ntop_30, nPort, szProxyAuthentication);
      }
      unsigned long int return_value_strlen_31;
      return_value_strlen_31=strlen(buf);
      send(s, (const void *)buf, return_value_strlen_31, 0);
      recv(s, (void *)buf, (unsigned long int)4096, 0);
      unsigned long int return_value_strlen_32;
      return_value_strlen_32=strlen("HTTP/");
      signed int return_value_strncmp_33;
      return_value_strncmp_33=strncmp("HTTP/", buf, return_value_strlen_32);
      if(return_value_strncmp_33 == 0)
      {
        tmpptr=index(buf, 32);
        tmp_if_expr_34 = tmpptr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_34 = (_Bool)0;
      if(tmp_if_expr_34)
      {
        tmpptr = tmpptr + 1l;
        tmp_if_expr_35 = (signed int)*tmpptr == 50 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_35 = (_Bool)0;
      if(tmp_if_expr_35)
        writeError(7, "Connected (with proxy)");

      else
      {
        writeError(3, "CONNECT call to proxy failed with code %c%c%c", *tmpptr, tmpptr[(signed long int)1], tmpptr[(signed long int)2]);
        close(s);
        ret = -1;
        free((void *)buf);
        return ret;
      }
      free((void *)buf);
    }

    nFail = 0;
    return ret;
  }

  return ret;
}

// medusaConnectSSL
// file medusa-net.c line 622
extern signed int medusaConnectSSL(struct __sConnectParams *pParams)
{
  signed int hSocket;
  hSocket=medusaConnectSSLInternal(pParams, -1);
  if(hSocket >= 1)
    pParams->nUseSSL = 1;

  return hSocket;
}

// medusaConnectSSLInternal
// file medusa-net.c line 334
signed int medusaConnectSSLInternal(struct __sConnectParams *pParams, signed int hSocket)
{
  signed int err;
  struct SSLSOCKETINFO *s;
  struct ssl_st *ssl = (struct ssl_st *)(void *)0;
  struct ssl_ctx_st *sslContext = (struct ssl_ctx_st *)(void *)0;
  pthread_mutex_lock(&ptmSSLMutex);
  SSL_load_error_strings();
  SSL_library_init();
  const struct ssl_method_st *return_value_TLSv1_client_method_1;
  if(IEEE_FLOAT_EQUAL(pParams->nSSLVersion, 3.100000e+0f))
  {
    return_value_TLSv1_client_method_1=TLSv1_client_method();
    sslContext=SSL_CTX_new(return_value_TLSv1_client_method_1);
  }

  else
  {
    const struct ssl_method_st *return_value_SSLv23_client_method_2;
    return_value_SSLv23_client_method_2=SSLv23_client_method();
    sslContext=SSL_CTX_new(return_value_SSLv23_client_method_2);
  }
  if(sslContext == ((struct ssl_ctx_st *)NULL))
  {
    unsigned long int return_value_ERR_get_error_3;
    return_value_ERR_get_error_3=ERR_get_error();
    err = (signed int)return_value_ERR_get_error_3;
    char *return_value_ERR_error_string_4;
    return_value_ERR_error_string_4=ERR_error_string((unsigned long int)err, (char *)(void *)0);
    writeError(3, "SSL: Error allocating context: %s", return_value_ERR_error_string_4);
    return -1;
  }

  SSL_CTX_ctrl(sslContext, 32, 0x80000BFFL, (void *)0);
  SSL_CTX_set_default_verify_paths(sslContext);
  SSL_CTX_set_tmp_rsa_callback(sslContext, sslTempRSACallback);
  SSL_CTX_set_verify(sslContext, 0x00, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
  unsigned int tmp_if_expr_16;
  if(!(hSocket >= 0))
  {
    hSocket=medusaConnect(pParams);
    if(hSocket >= 0)
      goto __CPROVER_DUMP_L4;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    ssl=SSL_new(sslContext);
    if(ssl == ((struct ssl_st *)NULL))
    {
      unsigned long int return_value_ERR_get_error_5;
      return_value_ERR_get_error_5=ERR_get_error();
      err = (signed int)return_value_ERR_get_error_5;
      char *return_value_ERR_error_string_6;
      return_value_ERR_error_string_6=ERR_error_string((unsigned long int)err, (char *)(void *)0);
      writeError(3, "Error preparing an SSL context: %s", return_value_ERR_error_string_6);
      return -1;
    }

    SSL_set_fd(ssl, hSocket);
    signed int return_value_SSL_connect_9;
    return_value_SSL_connect_9=SSL_connect(ssl);
    if(!(return_value_SSL_connect_9 >= 1))
    {
      unsigned long int return_value_ERR_get_error_7;
      return_value_ERR_get_error_7=ERR_get_error();
      err = (signed int)return_value_ERR_get_error_7;
      char *return_value_ERR_error_string_8;
      return_value_ERR_error_string_8=ERR_error_string((unsigned long int)err, (char *)(void *)0);
      writeError(3, "Could not create an SSL session: %s", return_value_ERR_error_string_8);
      return -1;
    }

    const struct ssl_cipher_st *return_value_SSL_get_current_cipher_10;
    return_value_SSL_get_current_cipher_10=SSL_get_current_cipher(ssl);
    const char *return_value_SSL_CIPHER_get_name_11;
    return_value_SSL_CIPHER_get_name_11=SSL_CIPHER_get_name(return_value_SSL_get_current_cipher_10);
    writeError(7, "SSL negotiated cipher: %s", return_value_SSL_CIPHER_get_name_11);
    void *return_value_malloc_12;
    return_value_malloc_12=malloc(sizeof(struct SSLSOCKETINFO) /*80ul*/ );
    s = (struct SSLSOCKETINFO *)return_value_malloc_12;
    memset((void *)s, 0, sizeof(struct SSLSOCKETINFO) /*80ul*/ );
    s->id = hSocket;
    s->nUseSSL = 1;
    s->ssl = ssl;
    s->sslContext = sslContext;
    do
    {
      unsigned int _ha_bkt;
      s->hh.next = (void *)0;
      s->hh.key = (void *)(char *)&s->id;
      s->hh.keylen = (unsigned int)sizeof(signed int) /*4ul*/ ;
      if(psSSLSocketInfo == ((struct SSLSOCKETINFO *)NULL))
      {
        psSSLSocketInfo = s;
        psSSLSocketInfo->hh.prev = (void *)0;
        do
        {
          void *return_value_malloc_13;
          return_value_malloc_13=malloc(sizeof(struct UT_hash_table) /*64ul*/ );
          psSSLSocketInfo->hh.tbl = (struct UT_hash_table *)return_value_malloc_13;
          if(psSSLSocketInfo->hh.tbl == ((struct UT_hash_table *)NULL))
            exit(-1);

          memset((void *)psSSLSocketInfo->hh.tbl, 0, sizeof(struct UT_hash_table) /*64ul*/ );
          psSSLSocketInfo->hh.tbl->tail = &psSSLSocketInfo->hh;
          psSSLSocketInfo->hh.tbl->num_buckets = (unsigned int)32;
          psSSLSocketInfo->hh.tbl->log2_num_buckets = (unsigned int)5;
          psSSLSocketInfo->hh.tbl->hho = (char *)&psSSLSocketInfo->hh - (char *)psSSLSocketInfo;
          void *return_value_malloc_14;
          return_value_malloc_14=malloc((unsigned long int)32 * sizeof(struct UT_hash_bucket) /*16ul*/ );
          psSSLSocketInfo->hh.tbl->buckets = (struct UT_hash_bucket *)return_value_malloc_14;
          if(psSSLSocketInfo->hh.tbl->buckets == ((struct UT_hash_bucket *)NULL))
            exit(-1);

          memset((void *)psSSLSocketInfo->hh.tbl->buckets, 0, (unsigned long int)32 * sizeof(struct UT_hash_bucket) /*16ul*/ );
          psSSLSocketInfo->hh.tbl->signature = 0xa0111fe1;
        }
        while((_Bool)0);
      }

      else
      {
        psSSLSocketInfo->hh.tbl->tail->next = (void *)s;
        s->hh.prev = (void *)((char *)psSSLSocketInfo->hh.tbl->tail - psSSLSocketInfo->hh.tbl->hho);
        psSSLSocketInfo->hh.tbl->tail = &s->hh;
      }
      psSSLSocketInfo->hh.tbl->num_items = psSSLSocketInfo->hh.tbl->num_items + 1u;
      s->hh.tbl = psSSLSocketInfo->hh.tbl;
      do
      {
        unsigned int _hj_i;
        unsigned int _hj_j;
        unsigned int _hj_k;
        char *_hj_key = (char *)&s->id;
        s->hh.hashv = 0xfeedbeef;
        _hj_j = 0x9e3779b9;
        _hj_i = _hj_j;
        _hj_k = (unsigned int)sizeof(signed int) /*4ul*/ ;
        for( ; _hj_k >= 12u; _hj_k = _hj_k - (unsigned int)12)
        {
          _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0] + ((unsigned int)_hj_key[(signed long int)1] << 8) + ((unsigned int)_hj_key[(signed long int)2] << 16) + ((unsigned int)_hj_key[(signed long int)3] << 24);
          _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4] + ((unsigned int)_hj_key[(signed long int)5] << 8) + ((unsigned int)_hj_key[(signed long int)6] << 16) + ((unsigned int)_hj_key[(signed long int)7] << 24);
          s->hh.hashv = s->hh.hashv + (unsigned int)_hj_key[(signed long int)8] + ((unsigned int)_hj_key[(signed long int)9] << 8) + ((unsigned int)_hj_key[(signed long int)10] << 16) + ((unsigned int)_hj_key[(signed long int)11] << 24);
          do
          {
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - s->hh.hashv;
            _hj_i = _hj_i ^ s->hh.hashv >> 13;
            _hj_j = _hj_j - s->hh.hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 8;
            s->hh.hashv = s->hh.hashv - _hj_i;
            s->hh.hashv = s->hh.hashv - _hj_j;
            s->hh.hashv = s->hh.hashv ^ _hj_j >> 13;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - s->hh.hashv;
            _hj_i = _hj_i ^ s->hh.hashv >> 12;
            _hj_j = _hj_j - s->hh.hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 16;
            s->hh.hashv = s->hh.hashv - _hj_i;
            s->hh.hashv = s->hh.hashv - _hj_j;
            s->hh.hashv = s->hh.hashv ^ _hj_j >> 5;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - s->hh.hashv;
            _hj_i = _hj_i ^ s->hh.hashv >> 3;
            _hj_j = _hj_j - s->hh.hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 10;
            s->hh.hashv = s->hh.hashv - _hj_i;
            s->hh.hashv = s->hh.hashv - _hj_j;
            s->hh.hashv = s->hh.hashv ^ _hj_j >> 15;
          }
          while((_Bool)0);
          _hj_key = _hj_key + (signed long int)12;
        }
        s->hh.hashv = s->hh.hashv + (unsigned int)sizeof(signed int) /*4ul*/ ;
        switch(_hj_k)
        {
          case (unsigned int)11:
            s->hh.hashv = s->hh.hashv + ((unsigned int)_hj_key[(signed long int)10] << 24);
          case (unsigned int)10:
            s->hh.hashv = s->hh.hashv + ((unsigned int)_hj_key[(signed long int)9] << 16);
          case (unsigned int)9:
            s->hh.hashv = s->hh.hashv + ((unsigned int)_hj_key[(signed long int)8] << 8);
          case (unsigned int)8:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)7] << 24);
          case (unsigned int)7:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)6] << 16);
          case (unsigned int)6:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)5] << 8);
          case (unsigned int)5:
            _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4];
          case (unsigned int)4:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)3] << 24);
          case (unsigned int)3:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)2] << 16);
          case (unsigned int)2:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)1] << 8);
          case (unsigned int)1:
            _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0];
        }
        do
        {
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - s->hh.hashv;
          _hj_i = _hj_i ^ s->hh.hashv >> 13;
          _hj_j = _hj_j - s->hh.hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 8;
          s->hh.hashv = s->hh.hashv - _hj_i;
          s->hh.hashv = s->hh.hashv - _hj_j;
          s->hh.hashv = s->hh.hashv ^ _hj_j >> 13;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - s->hh.hashv;
          _hj_i = _hj_i ^ s->hh.hashv >> 12;
          _hj_j = _hj_j - s->hh.hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 16;
          s->hh.hashv = s->hh.hashv - _hj_i;
          s->hh.hashv = s->hh.hashv - _hj_j;
          s->hh.hashv = s->hh.hashv ^ _hj_j >> 5;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - s->hh.hashv;
          _hj_i = _hj_i ^ s->hh.hashv >> 3;
          _hj_j = _hj_j - s->hh.hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 10;
          s->hh.hashv = s->hh.hashv - _hj_i;
          s->hh.hashv = s->hh.hashv - _hj_j;
          s->hh.hashv = s->hh.hashv ^ _hj_j >> 15;
        }
        while((_Bool)0);
        _ha_bkt = s->hh.hashv & psSSLSocketInfo->hh.tbl->num_buckets - (unsigned int)1;
      }
      while((_Bool)0);
      do
      {
        (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->count = (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->count + 1u;
        (&s->hh)->hh_next = (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->hh_head;
        (&s->hh)->hh_prev = (struct UT_hash_handle *)(void *)0;
        if(!((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->hh_head == ((struct UT_hash_handle *)NULL)))
          (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->hh_head->hh_prev = &s->hh;

        (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->hh_head = &s->hh;
        if((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->count >= (1u + (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_ha_bkt)->expand_mult) * 10u)
        {
          if(!(s->hh.tbl->noexpand == 1u))
            do
            {
              unsigned int _he_bkt;
              unsigned int _he_bkt_i;
              struct UT_hash_handle *_he_thh;
              struct UT_hash_handle *_he_hh_nxt;
              struct UT_hash_bucket *_he_new_buckets;
              struct UT_hash_bucket *_he_newbkt;
              void *return_value_malloc_15;
              return_value_malloc_15=malloc((unsigned long int)((unsigned int)2 * (&s->hh)->tbl->num_buckets) * sizeof(struct UT_hash_bucket) /*16ul*/ );
              _he_new_buckets = (struct UT_hash_bucket *)return_value_malloc_15;
              if(_he_new_buckets == ((struct UT_hash_bucket *)NULL))
                exit(-1);

              memset((void *)_he_new_buckets, 0, (unsigned long int)((unsigned int)2 * (&s->hh)->tbl->num_buckets) * sizeof(struct UT_hash_bucket) /*16ul*/ );
              (&s->hh)->tbl->ideal_chain_maxlen = ((&s->hh)->tbl->num_items >> (&s->hh)->tbl->log2_num_buckets + (unsigned int)1) + (unsigned int)(((&s->hh)->tbl->num_items & (&s->hh)->tbl->num_buckets * (unsigned int)2 - (unsigned int)1) != 0u ? 1 : 0);
              (&s->hh)->tbl->nonideal_items = (unsigned int)0;
              _he_bkt_i = (unsigned int)0;
              for( ; !(_he_bkt_i >= s->hh.tbl->num_buckets); _he_bkt_i = _he_bkt_i + 1u)
              {
                _he_thh = ((&s->hh)->tbl->buckets + (signed long int)_he_bkt_i)->hh_head;
                for( ; !(_he_thh == ((struct UT_hash_handle *)NULL)); _he_thh = _he_hh_nxt)
                {
                  _he_hh_nxt = _he_thh->hh_next;
                  do
                    _he_bkt = _he_thh->hashv & (&s->hh)->tbl->num_buckets * (unsigned int)2 - (unsigned int)1;
                  while((_Bool)0);
                  _he_newbkt = &_he_new_buckets[(signed long int)_he_bkt];
                  _he_newbkt->count = _he_newbkt->count + 1u;
                  if(!(s->hh.tbl->ideal_chain_maxlen >= _he_newbkt->count))
                  {
                    (&s->hh)->tbl->nonideal_items = (&s->hh)->tbl->nonideal_items + 1u;
                    _he_newbkt->expand_mult = _he_newbkt->count / (&s->hh)->tbl->ideal_chain_maxlen;
                  }

                  _he_thh->hh_prev = (struct UT_hash_handle *)(void *)0;
                  _he_thh->hh_next = _he_newbkt->hh_head;
                  if(!(_he_newbkt->hh_head == ((struct UT_hash_handle *)NULL)))
                    _he_newbkt->hh_head->hh_prev = _he_thh;

                  _he_newbkt->hh_head = _he_thh;
                }
              }
              (&s->hh)->tbl->num_buckets = (&s->hh)->tbl->num_buckets * (unsigned int)2;
              (&s->hh)->tbl->log2_num_buckets = (&s->hh)->tbl->log2_num_buckets + 1u;
              free((void *)(&s->hh)->tbl->buckets);
              (&s->hh)->tbl->buckets = _he_new_buckets;
              if(!(s->hh.tbl->num_items >> 1 >= s->hh.tbl->nonideal_items))
                tmp_if_expr_16 = (&s->hh)->tbl->ineff_expands + (unsigned int)1;

              else
                tmp_if_expr_16 = (unsigned int)0;
              (&s->hh)->tbl->ineff_expands = tmp_if_expr_16;
              if(s->hh.tbl->ineff_expands >= 2u)
                (&s->hh)->tbl->noexpand = (unsigned int)1;

            }
            while((_Bool)0);

        }

      }
      while((_Bool)0);
    }
    while((_Bool)0);
    pthread_mutex_unlock(&ptmSSLMutex);
    return hSocket;
  }
}

// medusaConnectSocketSSL
// file medusa-net.c line 642
extern signed int medusaConnectSocketSSL(struct __sConnectParams *pParams, signed int hSocket)
{
  if(hSocket >= 1)
  {
    pParams->nUseSSL = 1;
    signed int return_value_medusaConnectSSLInternal_1;
    return_value_medusaConnectSSLInternal_1=medusaConnectSSLInternal(pParams, hSocket);
    return return_value_medusaConnectSSLInternal_1;
  }

  else
  {
    writeError(3, "Invalid socket handle.");
    pParams->nUseSSL = 0;
    return -1;
  }
}

// medusaConnectTCP
// file medusa-net.c line 663
extern signed int medusaConnectTCP(struct __sConnectParams *pParams)
{
  pParams->nProtocol = 1;
  pParams->nType = 6;
  signed int return_value_medusaConnect_1;
  return_value_medusaConnect_1=medusaConnect(pParams);
  return return_value_medusaConnect_1;
}

// medusaConnectUDP
// file medusa-net.c line 670
extern signed int medusaConnectUDP(struct __sConnectParams *pParams)
{
  pParams->nProtocol = 2;
  pParams->nType = 17;
  signed int return_value_medusaConnect_1;
  return_value_medusaConnect_1=medusaConnect(pParams);
  return return_value_medusaConnect_1;
}

// medusaDataReady
// file medusa-net.c line 739
extern signed int medusaDataReady(signed int socket)
{
  signed int return_value_medusaDataReadyTimed_1;
  return_value_medusaDataReadyTimed_1=medusaDataReadyTimed(socket, (signed long int)0, (signed long int)0);
  return return_value_medusaDataReadyTimed_1;
}

// medusaDataReadyTimed
// file medusa-net.c line 726
extern signed int medusaDataReadyTimed(signed int socket, signed long int sec, signed long int usec)
{
  struct anonymous_0 fds;
  struct timeval tv;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  tv.tv_sec = sec;
  tv.tv_usec = usec;
  signed int return_value_select_1;
  return_value_select_1=select(socket + 1, &fds, (struct anonymous_0 *)(void *)0, (struct anonymous_0 *)(void *)0, &tv);
  return return_value_select_1;
}

// medusaDataReadyWriting
// file medusa-net.c line 721
extern signed int medusaDataReadyWriting(signed int socket)
{
  signed int return_value_medusaDataReadyWritingTimed_1;
  return_value_medusaDataReadyWritingTimed_1=medusaDataReadyWritingTimed(socket, (signed long int)30, (signed long int)0);
  return return_value_medusaDataReadyWritingTimed_1;
}

// medusaDataReadyWritingTimed
// file medusa-net.c line 708
extern signed int medusaDataReadyWritingTimed(signed int socket, signed long int sec, signed long int usec)
{
  struct anonymous_0 fds;
  struct timeval tv;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  tv.tv_sec = sec;
  tv.tv_usec = usec;
  signed int return_value_select_1;
  return_value_select_1=select(socket + 1, &fds, (struct anonymous_0 *)(void *)0, (struct anonymous_0 *)(void *)0, &tv);
  return return_value_select_1;
}

// medusaDisconnect
// file medusa-net.c line 678
extern signed int medusaDisconnect(signed int hSocket)
{
  struct SSLSOCKETINFO *s;
  void *tmp_if_expr_1;
  void *tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(hSocket >= 1))
    return -1;

  else
  {
    pthread_mutex_lock(&ptmSSLMutex);
    do
    {
      unsigned int _hf_bkt;
      unsigned int _hf_hashv;
      s = (struct SSLSOCKETINFO *)(void *)0;
      if(!(psSSLSocketInfo == ((struct SSLSOCKETINFO *)NULL)))
      {
        do
        {
          unsigned int _hj_i;
          unsigned int _hj_j;
          unsigned int _hj_k;
          char *_hj_key = (char *)&hSocket;
          _hf_hashv = 0xfeedbeef;
          _hj_j = 0x9e3779b9;
          _hj_i = _hj_j;
          _hj_k = (unsigned int)sizeof(signed int) /*4ul*/ ;
          for( ; _hj_k >= 12u; _hj_k = _hj_k - (unsigned int)12)
          {
            _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0] + ((unsigned int)_hj_key[(signed long int)1] << 8) + ((unsigned int)_hj_key[(signed long int)2] << 16) + ((unsigned int)_hj_key[(signed long int)3] << 24);
            _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4] + ((unsigned int)_hj_key[(signed long int)5] << 8) + ((unsigned int)_hj_key[(signed long int)6] << 16) + ((unsigned int)_hj_key[(signed long int)7] << 24);
            _hf_hashv = _hf_hashv + (unsigned int)_hj_key[(signed long int)8] + ((unsigned int)_hj_key[(signed long int)9] << 8) + ((unsigned int)_hj_key[(signed long int)10] << 16) + ((unsigned int)_hj_key[(signed long int)11] << 24);
            do
            {
              _hj_i = _hj_i - _hj_j;
              _hj_i = _hj_i - _hf_hashv;
              _hj_i = _hj_i ^ _hf_hashv >> 13;
              _hj_j = _hj_j - _hf_hashv;
              _hj_j = _hj_j - _hj_i;
              _hj_j = _hj_j ^ _hj_i << 8;
              _hf_hashv = _hf_hashv - _hj_i;
              _hf_hashv = _hf_hashv - _hj_j;
              _hf_hashv = _hf_hashv ^ _hj_j >> 13;
              _hj_i = _hj_i - _hj_j;
              _hj_i = _hj_i - _hf_hashv;
              _hj_i = _hj_i ^ _hf_hashv >> 12;
              _hj_j = _hj_j - _hf_hashv;
              _hj_j = _hj_j - _hj_i;
              _hj_j = _hj_j ^ _hj_i << 16;
              _hf_hashv = _hf_hashv - _hj_i;
              _hf_hashv = _hf_hashv - _hj_j;
              _hf_hashv = _hf_hashv ^ _hj_j >> 5;
              _hj_i = _hj_i - _hj_j;
              _hj_i = _hj_i - _hf_hashv;
              _hj_i = _hj_i ^ _hf_hashv >> 3;
              _hj_j = _hj_j - _hf_hashv;
              _hj_j = _hj_j - _hj_i;
              _hj_j = _hj_j ^ _hj_i << 10;
              _hf_hashv = _hf_hashv - _hj_i;
              _hf_hashv = _hf_hashv - _hj_j;
              _hf_hashv = _hf_hashv ^ _hj_j >> 15;
            }
            while((_Bool)0);
            _hj_key = _hj_key + (signed long int)12;
          }
          _hf_hashv = _hf_hashv + (unsigned int)sizeof(signed int) /*4ul*/ ;
          switch(_hj_k)
          {
            case (unsigned int)11:
              _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)10] << 24);
            case (unsigned int)10:
              _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)9] << 16);
            case (unsigned int)9:
              _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)8] << 8);
            case (unsigned int)8:
              _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)7] << 24);
            case (unsigned int)7:
              _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)6] << 16);
            case (unsigned int)6:
              _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)5] << 8);
            case (unsigned int)5:
              _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4];
            case (unsigned int)4:
              _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)3] << 24);
            case (unsigned int)3:
              _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)2] << 16);
            case (unsigned int)2:
              _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)1] << 8);
            case (unsigned int)1:
              _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0];
          }
          do
          {
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 13;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 8;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 13;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 12;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 16;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 5;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 3;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 10;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 15;
          }
          while((_Bool)0);
          _hf_bkt = _hf_hashv & psSSLSocketInfo->hh.tbl->num_buckets - (unsigned int)1;
        }
        while((_Bool)0);
        if(!((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head == ((struct UT_hash_handle *)NULL)))
          tmp_if_expr_1 = (void *)((char *)(psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head - psSSLSocketInfo->hh.tbl->hho);

        else
          tmp_if_expr_1 = (void *)0;
        s = (struct SSLSOCKETINFO *)tmp_if_expr_1;
        for( ; !(s == ((struct SSLSOCKETINFO *)NULL)); s = (struct SSLSOCKETINFO *)tmp_if_expr_3)
        {
          if((unsigned long int)s->hh.keylen == sizeof(signed int) /*4ul*/ )
          {
            signed int return_value_memcmp_2;
            return_value_memcmp_2=memcmp(s->hh.key, (const void *)&hSocket, sizeof(signed int) /*4ul*/ );
            if(return_value_memcmp_2 == 0)
              break;

          }

          if(!(s->hh.hh_next == ((struct UT_hash_handle *)NULL)))
            tmp_if_expr_3 = (void *)((char *)s->hh.hh_next - psSSLSocketInfo->hh.tbl->hho);

          else
            tmp_if_expr_3 = (void *)0;
        }
      }

    }
    while((_Bool)0);
    if(!(s == ((struct SSLSOCKETINFO *)NULL)))
      do
      {
        unsigned int _hd_bkt;
        struct UT_hash_handle *_hd_hh_del;
        if(s->hh.prev == NULL)
          tmp_if_expr_4 = s->hh.next == (void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          free((void *)psSSLSocketInfo->hh.tbl->buckets);
          free((void *)psSSLSocketInfo->hh.tbl);
          psSSLSocketInfo = (struct SSLSOCKETINFO *)(void *)0;
        }

        else
        {
          _hd_hh_del = &s->hh;
          if(s == (struct SSLSOCKETINFO *)((char *)psSSLSocketInfo->hh.tbl->tail + -psSSLSocketInfo->hh.tbl->hho))
            psSSLSocketInfo->hh.tbl->tail = (struct UT_hash_handle *)((char *)s->hh.prev + psSSLSocketInfo->hh.tbl->hho);

          if(!(s->hh.prev == NULL))
            ((struct UT_hash_handle *)((char *)s->hh.prev + psSSLSocketInfo->hh.tbl->hho))->next = s->hh.next;

          else
            psSSLSocketInfo = (struct SSLSOCKETINFO *)s->hh.next;
          if(!(_hd_hh_del->next == NULL))
            ((struct UT_hash_handle *)((char *)_hd_hh_del->next + psSSLSocketInfo->hh.tbl->hho))->prev = _hd_hh_del->prev;

          do
            _hd_bkt = _hd_hh_del->hashv & psSSLSocketInfo->hh.tbl->num_buckets - (unsigned int)1;
          while((_Bool)0);
          (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hd_bkt)->count = (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hd_bkt)->count - 1u;
          if((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hd_bkt)->hh_head == _hd_hh_del)
            (psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hd_bkt)->hh_head = _hd_hh_del->hh_next;

          if(!(_hd_hh_del->hh_prev == ((struct UT_hash_handle *)NULL)))
            _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;

          if(!(_hd_hh_del->hh_next == ((struct UT_hash_handle *)NULL)))
            _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;

          psSSLSocketInfo->hh.tbl->num_items = psSSLSocketInfo->hh.tbl->num_items - 1u;
        }
      }
      while((_Bool)0);

    close(hSocket);
    pthread_mutex_unlock(&ptmSSLMutex);
    writeError(7, "Disconnect successful");
    return -1;
  }
}

// medusaReceive
// file medusa-net.c line 755
extern signed int medusaReceive(signed int socket, unsigned char *buf, signed int length)
{
  signed int ret;
  ret=medusaReceiveInternal(socket, buf, length);
  writeError(7, "Data received (%d): %s", ret, buf);
  return ret;
}

// medusaReceiveDataInternal
// file medusa-net.c line 468
unsigned char * medusaReceiveDataInternal(signed int socket, signed int *nBufferSize, signed int nConvertNullsToSpaces, signed int nReceiveDelay1, signed int nReceiveDelay2)
{
  const signed int BUFFER_SIZE = 1500;
  unsigned char *szBufReceive;
  unsigned char *szBufReceiveTmp;
  signed int nBufReceive = 0;
  signed int nBufReceiveTmp = 0;
  signed int BufReceiveIndex = 0;
  signed int bSocketStatus = 0;
  signed int nReceiveDelay1sec = 0;
  signed int nReceiveDelay1usec = 0;
  signed int nReceiveDelay2sec = 0;
  signed int nReceiveDelay2usec = 0;
  *nBufferSize = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(BUFFER_SIZE + 1));
  szBufReceive = (unsigned char *)return_value_malloc_1;
  memset((void *)szBufReceive, 0, (unsigned long int)(BUFFER_SIZE + 1));
  nReceiveDelay1sec = nReceiveDelay1 / 1000000;
  nReceiveDelay1usec = nReceiveDelay1 % 1000000;
  nReceiveDelay2sec = nReceiveDelay2 / 1000000;
  nReceiveDelay2usec = nReceiveDelay2 % 1000000;
  bSocketStatus=medusaDataReadyTimed(socket, (signed long int)nReceiveDelay1sec, (signed long int)nReceiveDelay1usec);
  if(bSocketStatus >= 1)
  {
    writeError(7, "Data receive: Data waiting.");
    nBufReceive=medusaReceive(socket, szBufReceive, BUFFER_SIZE);
    if(!(nBufReceive >= 1))
    {
      writeError(7, "Data receive: Socket indicated data present, but none found.");
      free((void *)szBufReceive);
      return (unsigned char *)(void *)0;
    }

  }

  else
    if(bSocketStatus == 0)
    {
      writeError(7, "Data receive: No data.");
      free((void *)szBufReceive);
      return (unsigned char *)(void *)0;
    }

    else
    {
      writeError(3, "Data receive: Failed to read from network socket.");
      free((void *)szBufReceive);
      return (unsigned char *)(void *)0;
    }
  signed int return_value_medusaDataReadyTimed_2;
  do
  {
    return_value_medusaDataReadyTimed_2=medusaDataReadyTimed(socket, (signed long int)nReceiveDelay2sec, (signed long int)nReceiveDelay2usec);
    if(!(return_value_medusaDataReadyTimed_2 >= 1))
      break;

    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)(BUFFER_SIZE + 1));
    szBufReceiveTmp = (unsigned char *)return_value_malloc_3;
    memset((void *)szBufReceiveTmp, 0, (unsigned long int)(BUFFER_SIZE + 1));
    nBufReceiveTmp=medusaReceive(socket, szBufReceiveTmp, BUFFER_SIZE);
    if(!(nBufReceiveTmp >= 1))
    {
      writeError(7, "Data receive: No additional data.");
      free((void *)szBufReceiveTmp);
      break;
    }

    if(!(BUFFER_SIZE >= nBufReceive + nBufReceiveTmp))
    {
      writeError(7, "Additional data received. Increasing receive buffer %d bytes to %d.", nBufReceiveTmp, nBufReceive + nBufReceiveTmp + 1);
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)szBufReceive, (unsigned long int)(nBufReceive + nBufReceiveTmp + 1));
      szBufReceive = (unsigned char *)return_value_realloc_4;
    }

    memcpy((void *)(szBufReceive + (signed long int)nBufReceive), (const void *)szBufReceiveTmp, (unsigned long int)nBufReceiveTmp);
    nBufReceive = nBufReceive + nBufReceiveTmp;
    nBufReceiveTmp = 0;
    free((void *)szBufReceiveTmp);
  }
  while((_Bool)1);
  szBufReceive[(signed long int)nBufReceive] = (unsigned char)0;
  if(!(nConvertNullsToSpaces == 0))
  {
    BufReceiveIndex = 0;
    for( ; !(BufReceiveIndex >= nBufReceive); BufReceiveIndex = BufReceiveIndex + 1)
      if((signed int)szBufReceive[(signed long int)BufReceiveIndex] == 0)
        szBufReceive[(signed long int)BufReceiveIndex] = (unsigned char)32;

  }

  writeError(7, "Formatted data received (size %d): %s", nBufReceive, szBufReceive);
  *nBufferSize = nBufReceive;
  return szBufReceive;
}

// medusaReceiveInternal
// file medusa-net.c line 421
signed int medusaReceiveInternal(signed int socket, unsigned char *buf, signed int length)
{
  signed int err;
  signed int nRet;
  struct SSLSOCKETINFO *s;
  void *tmp_if_expr_1;
  void *tmp_if_expr_3;
  do
  {
    unsigned int _hf_bkt;
    unsigned int _hf_hashv;
    s = (struct SSLSOCKETINFO *)(void *)0;
    if(!(psSSLSocketInfo == ((struct SSLSOCKETINFO *)NULL)))
    {
      do
      {
        unsigned int _hj_i;
        unsigned int _hj_j;
        unsigned int _hj_k;
        char *_hj_key = (char *)&socket;
        _hf_hashv = 0xfeedbeef;
        _hj_j = 0x9e3779b9;
        _hj_i = _hj_j;
        _hj_k = (unsigned int)sizeof(signed int) /*4ul*/ ;
        for( ; _hj_k >= 12u; _hj_k = _hj_k - (unsigned int)12)
        {
          _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0] + ((unsigned int)_hj_key[(signed long int)1] << 8) + ((unsigned int)_hj_key[(signed long int)2] << 16) + ((unsigned int)_hj_key[(signed long int)3] << 24);
          _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4] + ((unsigned int)_hj_key[(signed long int)5] << 8) + ((unsigned int)_hj_key[(signed long int)6] << 16) + ((unsigned int)_hj_key[(signed long int)7] << 24);
          _hf_hashv = _hf_hashv + (unsigned int)_hj_key[(signed long int)8] + ((unsigned int)_hj_key[(signed long int)9] << 8) + ((unsigned int)_hj_key[(signed long int)10] << 16) + ((unsigned int)_hj_key[(signed long int)11] << 24);
          do
          {
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 13;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 8;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 13;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 12;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 16;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 5;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 3;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 10;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 15;
          }
          while((_Bool)0);
          _hj_key = _hj_key + (signed long int)12;
        }
        _hf_hashv = _hf_hashv + (unsigned int)sizeof(signed int) /*4ul*/ ;
        switch(_hj_k)
        {
          case (unsigned int)11:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)10] << 24);
          case (unsigned int)10:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)9] << 16);
          case (unsigned int)9:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)8] << 8);
          case (unsigned int)8:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)7] << 24);
          case (unsigned int)7:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)6] << 16);
          case (unsigned int)6:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)5] << 8);
          case (unsigned int)5:
            _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4];
          case (unsigned int)4:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)3] << 24);
          case (unsigned int)3:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)2] << 16);
          case (unsigned int)2:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)1] << 8);
          case (unsigned int)1:
            _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0];
        }
        do
        {
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 13;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 8;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 13;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 12;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 16;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 5;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 3;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 10;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 15;
        }
        while((_Bool)0);
        _hf_bkt = _hf_hashv & psSSLSocketInfo->hh.tbl->num_buckets - (unsigned int)1;
      }
      while((_Bool)0);
      if(!((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head == ((struct UT_hash_handle *)NULL)))
        tmp_if_expr_1 = (void *)((char *)(psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head - psSSLSocketInfo->hh.tbl->hho);

      else
        tmp_if_expr_1 = (void *)0;
      s = (struct SSLSOCKETINFO *)tmp_if_expr_1;
      for( ; !(s == ((struct SSLSOCKETINFO *)NULL)); s = (struct SSLSOCKETINFO *)tmp_if_expr_3)
      {
        if((unsigned long int)s->hh.keylen == sizeof(signed int) /*4ul*/ )
        {
          signed int return_value_memcmp_2;
          return_value_memcmp_2=memcmp(s->hh.key, (const void *)&socket, sizeof(signed int) /*4ul*/ );
          if(return_value_memcmp_2 == 0)
            break;

        }

        if(!(s->hh.hh_next == ((struct UT_hash_handle *)NULL)))
          tmp_if_expr_3 = (void *)((char *)s->hh.hh_next - psSSLSocketInfo->hh.tbl->hho);

        else
          tmp_if_expr_3 = (void *)0;
      }
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_9;
  if(!(s == ((struct SSLSOCKETINFO *)NULL)))
    tmp_if_expr_9 = s->nUseSSL != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_9 = (_Bool)0;
  char *return_value_ERR_error_string_6;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  signed long int return_value_recv_8;
  if(tmp_if_expr_9)
  {
    do
    {
      nRet=SSL_read(s->ssl, (void *)buf, length);
      if(!(nRet >= 1))
      {
        err=SSL_get_error(s->ssl, nRet);
        switch(err)
        {
          case 6:
          {
            writeError(7, "The TLS/SSL connection has been closed.");
            break;
          }
          case 1:
          {
            writeError(3, "A failure in the SSL library occurred, usually a protocol error.");
            break;
          }
          case 5:
          {
            return_value_ERR_error_string_6=ERR_error_string((unsigned long int)err, (char *)(void *)0);
            writeError(7, "TLS/SSL I/O error occurered (%d - %s)", err, return_value_ERR_error_string_6);
            break;
          }
          default:
          {
            char *return_value_ERR_error_string_7;
            return_value_ERR_error_string_7=ERR_error_string((unsigned long int)err, (char *)(void *)0);
            writeError(3, "Unknown TLS/SSL error occurred (%d - %s)", err, return_value_ERR_error_string_7);
          }
        }
      }

      if(err == 5 && nRet == -1)
      {
        return_value___errno_location_4=__errno_location();
        tmp_if_expr_5 = *return_value___errno_location_4 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
    }
    while(tmp_if_expr_5);
    return nRet;
  }

  else
  {
    return_value_recv_8=recv(socket, (void *)buf, (unsigned long int)length, 0);
    return (signed int)return_value_recv_8;
  }
}

// medusaReceiveLine
// file medusa-net.c line 774
extern unsigned char * medusaReceiveLine(signed int socket, signed int *nBufferSize)
{
  unsigned char *return_value_medusaReceiveDataInternal_1;
  return_value_medusaReceiveDataInternal_1=medusaReceiveDataInternal(socket, nBufferSize, 1, 20 * 1000000, 0);
  return return_value_medusaReceiveDataInternal_1;
}

// medusaReceiveLineDelay
// file medusa-net.c line 779
extern unsigned char * medusaReceiveLineDelay(signed int socket, signed int *nBufferSize, signed int nReceiveDelay1, signed int nReceiveDelay2)
{
  unsigned char *return_value_medusaReceiveDataInternal_1;
  return_value_medusaReceiveDataInternal_1=medusaReceiveDataInternal(socket, nBufferSize, 1, nReceiveDelay1, nReceiveDelay2);
  return return_value_medusaReceiveDataInternal_1;
}

// medusaReceiveRaw
// file medusa-net.c line 764
extern unsigned char * medusaReceiveRaw(signed int socket, signed int *nBufferSize)
{
  unsigned char *return_value_medusaReceiveDataInternal_1;
  return_value_medusaReceiveDataInternal_1=medusaReceiveDataInternal(socket, nBufferSize, 0, 20 * 1000000, 0);
  return return_value_medusaReceiveDataInternal_1;
}

// medusaReceiveRawDelay
// file medusa-net.c line 769
extern unsigned char * medusaReceiveRawDelay(signed int socket, signed int *nBufferSize, signed int nReceiveDelay1, signed int nReceiveDelay2)
{
  unsigned char *return_value_medusaReceiveDataInternal_1;
  return_value_medusaReceiveDataInternal_1=medusaReceiveDataInternal(socket, nBufferSize, 0, nReceiveDelay1, nReceiveDelay2);
  return return_value_medusaReceiveDataInternal_1;
}

// medusaReceiveRegex
// file medusa-net.c line 794
extern signed int medusaReceiveRegex(signed int hSocket, unsigned char **szBufReceive, signed int *nBufReceive, const char *regex)
{
  unsigned char *szBufReceiveTmp = (unsigned char *)(void *)0;
  signed int nBufReceiveTmp = 0;
  struct re_pattern_buffer preg;
  signed int errcode = 1;
  char errmsg[512l];
  signed int nAttempt = 1;
  const signed int BUFFER_SIZE = 1500;
  writeError(7, "Regural expession: \"%s\"", regex);
  errcode=regcomp(&preg, regex, 1 | 1 << 1 | ((1 << 1) << 1) << 1);
  if(!(errcode == 0))
  {
    memset((void *)errmsg, 0, (unsigned long int)512);
    regerror(errcode, &preg, errmsg, (unsigned long int)512);
    writeError(3, "Regex compilation failed: %s", (const void *)errmsg);
    return -1;
  }

  else
  {
    *szBufReceive=medusaReceiveDataInternal(hSocket, nBufReceive, 0, 20 * 1000000, 0);
    if(*szBufReceive == ((unsigned char *)NULL))
      return -1;

    else
    {
      do
      {
        errcode=regexec(&preg, (char *)*szBufReceive, (unsigned long int)0, ((struct anonymous_2 *)NULL), 0);
        if(errcode == 1)
        {
          writeError(7, "Failed to match regex. Checking for additional data.");
          signed int return_value_medusaDataReadyTimed_3;
          return_value_medusaDataReadyTimed_3=medusaDataReadyTimed(hSocket, (signed long int)0, (signed long int)(20000 * nAttempt));
          if(return_value_medusaDataReadyTimed_3 >= 1)
          {
            void *return_value_malloc_1;
            return_value_malloc_1=malloc((unsigned long int)(BUFFER_SIZE + 1));
            szBufReceiveTmp = (unsigned char *)return_value_malloc_1;
            memset((void *)szBufReceiveTmp, 0, (unsigned long int)(BUFFER_SIZE + 1));
            nBufReceiveTmp=medusaReceive(hSocket, szBufReceiveTmp, BUFFER_SIZE);
            if(!(nBufReceiveTmp >= 1))
            {
              writeError(7, "Data receive: No additional data.");
              free((void *)szBufReceiveTmp);
              break;
            }

            if(!(BUFFER_SIZE >= *nBufReceive + nBufReceiveTmp))
            {
              writeError(7, "Additional data received. Increasing receive buffer %d bytes to %d.", nBufReceiveTmp, *nBufReceive + nBufReceiveTmp + 1);
              void *return_value_realloc_2;
              return_value_realloc_2=realloc((void *)*szBufReceive, (unsigned long int)(*nBufReceive + nBufReceiveTmp + 1));
              *szBufReceive = (unsigned char *)return_value_realloc_2;
            }

            memcpy((void *)(*szBufReceive + (signed long int)*nBufReceive), (const void *)szBufReceiveTmp, (unsigned long int)nBufReceiveTmp);
            *nBufReceive = *nBufReceive + nBufReceiveTmp;
            nBufReceiveTmp = 0;
            free((void *)szBufReceiveTmp);
          }

          else
          {
            writeError(7, "No additional data found (attempt %d/5)", nAttempt);
            nAttempt = nAttempt + 1;
          }
        }

        else
        {
          regfree(&preg);
          writeError(7, "Successfully matched regex.");
          return 0;
        }
      }
      while(!(nAttempt >= 6));
      regfree(&preg);
      writeError(3, "Failed to match regex pattern within server's response.");
      return -1;
    }
  }
}

// medusaSend
// file medusa-net.c line 871
extern signed int medusaSend(signed int socket, unsigned char *buf, signed int size, signed int options)
{
  const signed long int medusaSend_array_size0 = (signed long int)(size + 1);
  char debugbuf[medusaSend_array_size0];
  signed int k;
  memset((void *)debugbuf, 0, (unsigned long int)(size + 1));
  k = 0;
  for( ; !(k >= size); k = k + 1)
    if((signed int)buf[(signed long int)k] == 0)
      debugbuf[(signed long int)k] = (char)32;

    else
      debugbuf[(signed long int)k] = (char)buf[(signed long int)k];
  writeError(7, "Data sent: %s", (const void *)debugbuf);
  signed int return_value_medusaSendInternal_1;
  return_value_medusaSendInternal_1=medusaSendInternal(socket, buf, size, options);
  return return_value_medusaSendInternal_1;
}

// medusaSendInternal
// file medusa-net.c line 576
signed int medusaSendInternal(signed int socket, unsigned char *buf, signed int size, signed int options)
{
  struct SSLSOCKETINFO *s;
  void *tmp_if_expr_1;
  void *tmp_if_expr_3;
  do
  {
    unsigned int _hf_bkt;
    unsigned int _hf_hashv;
    s = (struct SSLSOCKETINFO *)(void *)0;
    if(!(psSSLSocketInfo == ((struct SSLSOCKETINFO *)NULL)))
    {
      do
      {
        unsigned int _hj_i;
        unsigned int _hj_j;
        unsigned int _hj_k;
        char *_hj_key = (char *)&socket;
        _hf_hashv = 0xfeedbeef;
        _hj_j = 0x9e3779b9;
        _hj_i = _hj_j;
        _hj_k = (unsigned int)sizeof(signed int) /*4ul*/ ;
        for( ; _hj_k >= 12u; _hj_k = _hj_k - (unsigned int)12)
        {
          _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0] + ((unsigned int)_hj_key[(signed long int)1] << 8) + ((unsigned int)_hj_key[(signed long int)2] << 16) + ((unsigned int)_hj_key[(signed long int)3] << 24);
          _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4] + ((unsigned int)_hj_key[(signed long int)5] << 8) + ((unsigned int)_hj_key[(signed long int)6] << 16) + ((unsigned int)_hj_key[(signed long int)7] << 24);
          _hf_hashv = _hf_hashv + (unsigned int)_hj_key[(signed long int)8] + ((unsigned int)_hj_key[(signed long int)9] << 8) + ((unsigned int)_hj_key[(signed long int)10] << 16) + ((unsigned int)_hj_key[(signed long int)11] << 24);
          do
          {
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 13;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 8;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 13;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 12;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 16;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 5;
            _hj_i = _hj_i - _hj_j;
            _hj_i = _hj_i - _hf_hashv;
            _hj_i = _hj_i ^ _hf_hashv >> 3;
            _hj_j = _hj_j - _hf_hashv;
            _hj_j = _hj_j - _hj_i;
            _hj_j = _hj_j ^ _hj_i << 10;
            _hf_hashv = _hf_hashv - _hj_i;
            _hf_hashv = _hf_hashv - _hj_j;
            _hf_hashv = _hf_hashv ^ _hj_j >> 15;
          }
          while((_Bool)0);
          _hj_key = _hj_key + (signed long int)12;
        }
        _hf_hashv = _hf_hashv + (unsigned int)sizeof(signed int) /*4ul*/ ;
        switch(_hj_k)
        {
          case (unsigned int)11:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)10] << 24);
          case (unsigned int)10:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)9] << 16);
          case (unsigned int)9:
            _hf_hashv = _hf_hashv + ((unsigned int)_hj_key[(signed long int)8] << 8);
          case (unsigned int)8:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)7] << 24);
          case (unsigned int)7:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)6] << 16);
          case (unsigned int)6:
            _hj_j = _hj_j + ((unsigned int)_hj_key[(signed long int)5] << 8);
          case (unsigned int)5:
            _hj_j = _hj_j + (unsigned int)_hj_key[(signed long int)4];
          case (unsigned int)4:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)3] << 24);
          case (unsigned int)3:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)2] << 16);
          case (unsigned int)2:
            _hj_i = _hj_i + ((unsigned int)_hj_key[(signed long int)1] << 8);
          case (unsigned int)1:
            _hj_i = _hj_i + (unsigned int)_hj_key[(signed long int)0];
        }
        do
        {
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 13;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 8;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 13;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 12;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 16;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 5;
          _hj_i = _hj_i - _hj_j;
          _hj_i = _hj_i - _hf_hashv;
          _hj_i = _hj_i ^ _hf_hashv >> 3;
          _hj_j = _hj_j - _hf_hashv;
          _hj_j = _hj_j - _hj_i;
          _hj_j = _hj_j ^ _hj_i << 10;
          _hf_hashv = _hf_hashv - _hj_i;
          _hf_hashv = _hf_hashv - _hj_j;
          _hf_hashv = _hf_hashv ^ _hj_j >> 15;
        }
        while((_Bool)0);
        _hf_bkt = _hf_hashv & psSSLSocketInfo->hh.tbl->num_buckets - (unsigned int)1;
      }
      while((_Bool)0);
      if(!((psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head == ((struct UT_hash_handle *)NULL)))
        tmp_if_expr_1 = (void *)((char *)(psSSLSocketInfo->hh.tbl->buckets + (signed long int)_hf_bkt)->hh_head - psSSLSocketInfo->hh.tbl->hho);

      else
        tmp_if_expr_1 = (void *)0;
      s = (struct SSLSOCKETINFO *)tmp_if_expr_1;
      for( ; !(s == ((struct SSLSOCKETINFO *)NULL)); s = (struct SSLSOCKETINFO *)tmp_if_expr_3)
      {
        if((unsigned long int)s->hh.keylen == sizeof(signed int) /*4ul*/ )
        {
          signed int return_value_memcmp_2;
          return_value_memcmp_2=memcmp(s->hh.key, (const void *)&socket, sizeof(signed int) /*4ul*/ );
          if(return_value_memcmp_2 == 0)
            break;

        }

        if(!(s->hh.hh_next == ((struct UT_hash_handle *)NULL)))
          tmp_if_expr_3 = (void *)((char *)s->hh.hh_next - psSSLSocketInfo->hh.tbl->hho);

        else
          tmp_if_expr_3 = (void *)0;
      }
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr_8;
  if(!(s == ((struct SSLSOCKETINFO *)NULL)))
    tmp_if_expr_8 = s->nUseSSL != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_8 = (_Bool)0;
  if(tmp_if_expr_8)
  {
    signed int return_value_SSL_write_4;
    return_value_SSL_write_4=SSL_write(s->ssl, (const void *)buf, size);
    return return_value_SSL_write_4;
  }

  else
  {
    signed int nRet;
    signed long int return_value_send_5;
    return_value_send_5=send(socket, (const void *)buf, (unsigned long int)size, options);
    nRet = (signed int)return_value_send_5;
    if(!(nRet >= 0))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      writeError(3, "Error in send() %s", return_value_strerror_7);
    }

    return nRet;
  }
}

// notify_waiters
// file medusa-thread-pool.c line 121
static void notify_waiters(struct thr_pool *pool)
{
  if(pool->pool_head == ((struct job *)NULL))
  {
    if(pool->pool_active == ((struct active *)NULL))
    {
      pool->pool_flags = pool->pool_flags & ~0x01;
      pthread_cond_broadcast(&pool->pool_waitcv);
    }

  }

}

// processComboFile
// file medusa.c line 554
signed int processComboFile(struct __sAudit **_psAudit)
{
  signed int ret = 0;
  signed int iColonCount = 0;
  char *pComboTmp;
  writeError(7, "[processComboFile] Processing user supplied combo file.");
  pComboTmp = (*_psAudit)->pGlobalCombo;
  writeError(7, "[processComboFile] PwDump file check.");
  while(!((signed int)*pComboTmp == 0))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(pComboTmp, ":::");
    if(return_value_strcmp_1 == 0)
    {
      iColonCount = iColonCount + 3;
      pComboTmp = pComboTmp + (signed long int)3;
    }

    else
      if((signed int)*pComboTmp == 58)
      {
        iColonCount = iColonCount + 1;
        pComboTmp = pComboTmp + 1l;
      }

      else
        pComboTmp = pComboTmp + 1l;
    if(iColonCount == 6)
    {
      if((signed int)*pComboTmp == 0)
      {
        writeError(7, "[processComboFile] Combo format scan detected PwDump file.");
        if(!((*_psAudit)->HostType == 1))
        {
          if(!((*_psAudit)->HostType == 2))
            writeError(0, "Combo format used requires host information via (-h/-H).");

        }

        if(!((*_psAudit)->UserType == 1))
        {
          if(!((*_psAudit)->UserType == 2))
            (*_psAudit)->UserType = 4;

        }

        (*_psAudit)->PassType = 4;
        return ret;
      }

    }

  }
  if(!(iColonCount == 2) && !(iColonCount == 3))
  {
    writeError(7, "[processComboFile] Number of colons detected in first entry: %d", iColonCount);
    writeError(0, "Invalid combo file format.");
  }

  pComboTmp = (*_psAudit)->pGlobalCombo;
  if((signed int)*pComboTmp == 58)
  {
    writeError(7, "[processComboFile] No host combo field specified.");
    if(!((*_psAudit)->HostType == 1))
    {
      if(!((*_psAudit)->HostType == 2))
        writeError(0, "Combo format used requires host information via (-h/-H).");

    }

  }

  else
  {
    writeError(7, "[processComboFile] Host combo field specified.");
    (*_psAudit)->HostType = 3;
    for( ; !((signed int)*pComboTmp == 58); pComboTmp = pComboTmp + 1l)
      if(pComboTmp == ((char *)NULL))
        writeError(0, "Failed to process combo file. Incorrect format.");

  }
  pComboTmp = pComboTmp + 1l;
  if((signed int)*pComboTmp == 58)
  {
    writeError(7, "[processComboFile] No user combo field specified.");
    if(!((*_psAudit)->UserType == 1))
    {
      if(!((*_psAudit)->UserType == 2))
        writeError(0, "Combo format used requires user information via (-u/-U).");

    }

  }

  else
  {
    writeError(7, "[processComboFile] User combo field specified.");
    (*_psAudit)->UserType = 3;
    for( ; !((signed int)*pComboTmp == 58); pComboTmp = pComboTmp + 1l)
      if(pComboTmp == ((char *)NULL))
        writeError(0, "Failed to process combo file. Incorrect format.");

  }
  pComboTmp = pComboTmp + 1l;
  if((signed int)*pComboTmp == 0)
  {
    writeError(7, "[processComboFile] No password combo field specified.");
    if(!((*_psAudit)->PassType == 1))
    {
      if(!((*_psAudit)->PassType == 2))
      {
        if((*_psAudit)->iPasswordBlankFlag == 0)
        {
          if((*_psAudit)->iPasswordUsernameFlag == 0)
            writeError(0, "Combo format used requires password information via (-p/-P).");

        }

      }

    }

  }

  else
  {
    writeError(7, "[processComboFile] Password combo field specified.");
    (*_psAudit)->PassType = 3;
  }
  return ret;
}

// setPassResult
// file medusa.c line 1371
void setPassResult(struct __sLogin *_psLogin, char *_pPass)
{
  pthread_mutex_lock(&_psLogin->psServer->ptmMutex);
  writeVerbose(5, "[%s] Host: %s (%d of %d, %d complete) User: %s (%d of %d, %d complete) Password: %s (%d of %d complete)", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psServer->psHost->iId, _psLogin->psServer->psAudit->iHostCnt, _psLogin->psServer->psAudit->iHostsDone, _psLogin->psUser->pUser, _psLogin->psUser->iId, _psLogin->psServer->psHost->iUserCnt, _psLogin->psServer->psHost->iUsersDone, _pPass, _psLogin->psUser->iLoginsDone + 1, _psLogin->psUser->iPassCnt);
  _psLogin->iLoginsDone = _psLogin->iLoginsDone + 1;
  _psLogin->psUser->iLoginsDone = _psLogin->psUser->iLoginsDone + 1;
  _psLogin->psServer->iLoginsDone = _psLogin->psServer->iLoginsDone + 1;
  switch(_psLogin->iResult)
  {
    case 2:
    {
      if(!(_psLogin->pErrorMsg == ((char *)NULL)))
      {
        writeVerbose(4, "[%s] Host: %s User: %s Password: %s [SUCCESS (%s)]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _pPass, _psLogin->pErrorMsg);
        free((void *)_psLogin->pErrorMsg);
        _psLogin->pErrorMsg = (char *)(void *)0;
      }

      else
        writeVerbose(4, "[%s] Host: %s User: %s Password: %s [SUCCESS]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _pPass);
      _psLogin->psServer->psAudit->iValidPairFound = 1;
      _psLogin->psServer->iValidPairFound = 1;
      _psLogin->psUser->iPassStatus = 6;
      _psLogin->psServer->psHost->iUsersDone = _psLogin->psServer->psHost->iUsersDone + 1;
      break;
    }
    case 3:
    {
      if(!(_psLogin->pErrorMsg == ((char *)NULL)))
      {
        writeError(6, "[%s] Host: %s User: %s [FAILED (%s)]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _psLogin->pErrorMsg);
        free((void *)_psLogin->pErrorMsg);
        _psLogin->pErrorMsg = (char *)(void *)0;
      }

      else
        writeError(6, "[%s] Host: %s User: %s [FAILED]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser);
      break;
    }
    case 4:
    {
      if(!(_psLogin->pErrorMsg == ((char *)NULL)))
      {
        writeVerbose(4, "[%s] Host: %s User: %s Password: %s [ERROR (%s)]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _pPass, _psLogin->pErrorMsg);
        free((void *)_psLogin->pErrorMsg);
        _psLogin->pErrorMsg = (char *)(void *)0;
      }

      else
        writeVerbose(4, "[%s] Host: %s User: %s Password: %s [ERROR]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _pPass);
      _psLogin->psUser->iPassStatus = 6;
      _psLogin->psServer->psHost->iUsersDone = _psLogin->psServer->psHost->iUsersDone + 1;
      break;
    }
    default:
      writeError(6, "[%s] Host: %s User: %s [UNKNOWN %d]", _psLogin->psServer->psAudit->pModuleName, _psLogin->psServer->psHost->pHost, _psLogin->psUser->pUser, _psLogin->iResult);
  }
  pthread_mutex_unlock(&_psLogin->psServer->ptmMutex);
}

// sigint_handler
// file medusa.c line 1857
void sigint_handler(signed int sig)
{
  struct __sHost *psHost;
  struct __sUser *psUser;
  char szTmp[11l];
  char *szResumeMap = (char *)(void *)0;
  signed int nResumeMapSize = 0;
  signed int nItemByteSize = 0;
  struct sigaction sig_action;
  sig_action.sa_flags = 0;
  sigemptyset(&sig_action.sa_mask);
  sigaddset(&sig_action.sa_mask, 2);
  sig_action.__sigaction_handler.sa_handler = (void (*)(signed int))0;
  sigaction(2, &sig_action, ((struct sigaction *)NULL));
  sigprocmask(1, &sig_action.sa_mask, ((struct anonymous_5 *)NULL));
  writeError(1, "Medusa received SIGINT - Sending notification to login threads that we are are aborting.");
  psAudit->iStatus = 1;
  writeError(6, "Waiting for login threads to terminate...");
  thr_pool_wait(psAudit->server_pool);
  double return_value_log10_1;
  double return_value_log10_2;
  if(!(psAudit->iUserCnt >= psAudit->iHostCnt))
  {
    return_value_log10_1=log10((double)psAudit->iHostCnt);
    nItemByteSize = 1 + (signed int)return_value_log10_1 + 1;
  }

  else
  {
    return_value_log10_2=log10((double)psAudit->iUserCnt);
    nItemByteSize = 1 + (signed int)return_value_log10_2 + 1;
  }
  nResumeMapSize = nItemByteSize * (psAudit->iServerCnt * psAudit->iLoginCnt + psAudit->iServerCnt + 1) + 1;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(nResumeMapSize + 1));
  szResumeMap = (char *)return_value_malloc_3;
  memset((void *)szResumeMap, 0, (unsigned long int)(nResumeMapSize + 1));
  memset((void *)szTmp, 0, (unsigned long int)(10 + 1));
  psHost = psAudit->psHostRoot;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  for( ; !(psHost == ((struct __sHost *)NULL)); psHost = psHost->psHostNext)
  {
    if(psHost->iUserStatus == 0)
      break;

    if(!(psHost->iUserStatus == 3))
      tmp_if_expr_5 = psHost->iUserStatus != 4 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      writeError(7, "Incomplete Host: %d", psHost->iId);
      memset((void *)szTmp, 0, (unsigned long int)(10 + 1));
      snprintf(szTmp, (unsigned long int)10, "h%d", psHost->iId);
      strncat(szResumeMap, szTmp, (unsigned long int)10);
      psUser = psHost->psUser;
      for( ; !(psUser == ((struct __sUser *)NULL)); psUser = psUser->psUserNext)
      {
        if(psUser->iPassStatus == 0)
          break;

        if(psUser->iPassStatus == 5)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = psUser->iPassStatus == 6 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
          writeError(7, "Complete User: %d", psUser->iId);

        else
        {
          writeError(7, "Incomplete User: %d", psUser->iId);
          memset((void *)szTmp, 0, (unsigned long int)(10 + 1));
          snprintf(szTmp, (unsigned long int)10, "u%d", psUser->iId);
          strncat(szResumeMap, szTmp, (unsigned long int)10);
        }
      }
      if(!(psUser == ((struct __sUser *)NULL)))
      {
        if(psUser->iPassStatus == 0)
        {
          writeError(7, "First New User: %d", psUser->iId);
          memset((void *)szTmp, 0, (unsigned long int)(10 + 1));
          snprintf(szTmp, (unsigned long int)10, "u%d", psUser->iId);
          strncat(szResumeMap, szTmp, (unsigned long int)10);
        }

      }

    }

    else
      writeError(7, "Complete Host: %d", psHost->iId);
  }
  if(!(psHost == ((struct __sHost *)NULL)))
  {
    if(psHost->iUserStatus == 0)
    {
      writeError(7, "First New Host: %d", psHost->iId);
      memset((void *)szTmp, 0, (unsigned long int)(10 + 1));
      snprintf(szTmp, (unsigned long int)8, "h%d", psHost->iId);
      strncat(szResumeMap, szTmp, (unsigned long int)8);
    }

  }

  strncat(szResumeMap, ".", (unsigned long int)1);
  writeError(1, "To resume scan, add the following to your original command: \"-Z %s\"", szResumeMap);
  free((void *)szResumeMap);
  exit(0);
}

// sslTempRSACallback
// file medusa-net.c line 323
struct rsa_st * sslTempRSACallback(struct ssl_st *ssl, signed int export, signed int keylength)
{
  struct rsa_st *rsa = (struct rsa_st *)(void *)0;
  if(rsa == ((struct rsa_st *)NULL))
    rsa=RSA_generate_key(512, (unsigned long int)0x10001L, (void (*)(signed int, signed int, void *))(void *)0, (void *)0);

  return rsa;
}

// startLoginThreadPool
// file medusa.c line 1528
void startLoginThreadPool(void *arg)
{
  struct __sServer *_psServer = (struct __sServer *)arg;
  struct thr_pool *login_pool = (struct thr_pool *)(void *)0;
  const signed long int login_pool_array_size0 = (signed long int)_psServer->psAudit->iLoginCnt;
  struct __sLogin psLogin[login_pool_array_size0];
  const signed long int psLogin_array_size0 = (signed long int)_psServer->psAudit->iLoginCnt;
  struct __sModuleStart modParams[psLogin_array_size0];
  signed int iLoginId = 0;
  signed int iLoginCnt = _psServer->psAudit->iLoginCnt;
  struct addrinfo hints;
  struct addrinfo *res;
  signed int errcode;
  void *ptr;
  writeError(9, "Server ID: %d Host: %s iUserPassCnt: %d iLoginCnt: %d", _psServer->iId, _psServer->psHost->pHost, _psServer->psHost->iUserPassCnt, iLoginCnt);
  if(!(_psServer->psHost->iUserPassCnt >= iLoginCnt))
    iLoginCnt = _psServer->psHost->iUserPassCnt;

  login_pool=thr_pool_create((unsigned int)0, (unsigned int)iLoginCnt, (unsigned int)1, (union pthread_attr_t *)(void *)0);
  if(login_pool == ((struct thr_pool *)NULL))
    writeError(0, "Failed to create root login thread pool for host: %s", _psServer->psHost->pHost);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)100);
  _psServer->pHostIP = (char *)return_value_malloc_1;
  memset((void *)_psServer->pHostIP, 0, (unsigned long int)100);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_flags = hints.ai_flags | 0x0002;
  errcode=getaddrinfo(_psServer->psHost->pHost, (const char *)(void *)0, &hints, &res);
  if(!(errcode == 0))
  {
    const char *return_value_gai_strerror_2;
    return_value_gai_strerror_2=gai_strerror(errcode);
    writeError(2, "Failed to resolve hostname: %s - %s", _psServer->psHost->pHost, return_value_gai_strerror_2);
    goto __CPROVER_DUMP_L16;
  }

  if(!(res->ai_next == ((struct addrinfo *)NULL)))
    writeError(3, "Hostname resolved to multiple addresses. Selecting first address for testing.");

  inet_ntop(res->ai_family, (const void *)res->ai_addr->sa_data, _psServer->pHostIP, (unsigned int)100);
  switch(res->ai_family)
  {
    case 2:
    {
      ptr = (void *)&((struct sockaddr_in *)res->ai_addr)->sin_addr;
      break;
    }
    case 10:
      ptr = (void *)&((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
  }
  inet_ntop(res->ai_family, ptr, _psServer->pHostIP, (unsigned int)100);
  writeError(9, "Set IPv%d address: %s (%s)", res->ai_family == 10 ? 6 : 4, _psServer->pHostIP, res->ai_canonname);
  freeaddrinfo(res);
  iLoginId = 0;
  for( ; !(iLoginId >= iLoginCnt); iLoginId = iLoginId + 1)
  {
    writeError(9, "Adding new login task (%d) to server queue (%d)", iLoginId, _psServer->iId);
    psLogin[(signed long int)iLoginId].iId = iLoginId;
    psLogin[(signed long int)iLoginId].psServer = _psServer;
    psLogin[(signed long int)iLoginId].iResult = 1;
    psLogin[(signed long int)iLoginId].pErrorMsg = (char *)(void *)0;
    psLogin[(signed long int)iLoginId].iLoginsDone = 0;
    psLogin[(signed long int)iLoginId].psUser = (struct __sUser *)(void *)0;
    modParams[(signed long int)iLoginId].szModuleName = szModuleName;
    modParams[(signed long int)iLoginId].pLogin = &psLogin[(signed long int)iLoginId];
    modParams[(signed long int)iLoginId].argc = nModuleParamCount;
    modParams[(signed long int)iLoginId].argv = (char **)arrModuleParams;
    signed int return_value_thr_pool_queue_3;
    return_value_thr_pool_queue_3=thr_pool_queue(login_pool, (void *)startModule, (void *)&modParams[(signed long int)iLoginId]);
    if(!(return_value_thr_pool_queue_3 >= 0))
    {
      writeError(2, "Failed to add module launch task to login thread pool for server queue: %d.", _psServer->iId);
      goto __CPROVER_DUMP_L16;
    }

  }
  writeError(9, "waiting for server %d login pool to end", _psServer->iId);
  thr_pool_wait(login_pool);
  iLoginId = 0;
  if(!(_psServer->psAudit->iStatus == 1))
  {
    if(_psServer->iCredentialsMissed >= 1)
    {
      writeError(9, "Adding new clean-up login task to server queue (%d) for %d missed logins", _psServer->iId, _psServer->iCredentialsMissed);
      _psServer->psHost->iUserStatus = 2;
      psLogin[(signed long int)iLoginId].iResult = 1;
      psLogin[(signed long int)iLoginId].pErrorMsg = (char *)(void *)0;
      psLogin[(signed long int)iLoginId].psUser = (struct __sUser *)(void *)0;
      signed int return_value_thr_pool_queue_4;
      return_value_thr_pool_queue_4=thr_pool_queue(login_pool, (void *)startModule, (void *)&modParams[(signed long int)iLoginId]);
      if(!(return_value_thr_pool_queue_4 >= 0))
      {
        writeError(2, "Failed to add module launch task to login thread pool for server queue: %d.", _psServer->iId);
        goto __CPROVER_DUMP_L16;
      }

      writeError(9, "waiting for server %d login pool to end", _psServer->iId);
      thr_pool_wait(login_pool);
    }

  }

  writeError(9, "destroying server %d login pool", _psServer->iId);
  thr_pool_destroy(login_pool);
  pthread_mutex_lock(&_psServer->psAudit->ptmMutex);
  _psServer->psAudit->iHostsDone = _psServer->psAudit->iHostsDone + 1;
  pthread_mutex_unlock(&_psServer->psAudit->ptmMutex);
  _Bool tmp_if_expr_5;
  if(!(_psServer->psAudit->iStatus == 1))
  {
    if(_psServer->psHost->iUserStatus == 1)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = _psServer->psHost->iUserStatus == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      writeError(9, "Server thread exiting and server's userlist testing was marked as in progress. Was this host prematurely aborted?");
      _psServer->psHost->iUserStatus = 4;
    }

  }

  writeError(9, "exiting server: %d", _psServer->iId);
  free((void *)_psServer->pHostIP);
  goto __CPROVER_DUMP_L16;

__CPROVER_DUMP_L16:
  ;
}

// startModule
// file medusa.c line 1503
void startModule(void *pParams)
{
  signed long int nRet = (signed long int)0;
  struct __sModuleStart *modParams = (struct __sModuleStart *)pParams;
  if(modParams == ((struct __sModuleStart *)NULL))
    writeError(0, "Bad pointer passed to invokeModule");

  else
  {
    writeError(7, "startModule iId: %d pLogin: %X modParams->argv: %X modParams: %X", modParams->pLogin->iId, modParams->pLogin, modParams->argv, modParams);
    signed int return_value_invokeModule_1;
    return_value_invokeModule_1=invokeModule(modParams->szModuleName, modParams->pLogin, modParams->argc, modParams->argv);
    nRet = (signed long int)return_value_invokeModule_1;
    if(!(nRet >= 0l))
      writeVerbose(0, "invokeModule failed - see previous errors for an explanation");

    goto __CPROVER_DUMP_L3;
  }

__CPROVER_DUMP_L3:
  ;
}

// startServerThreadPool
// file medusa.c line 1682
signed int startServerThreadPool(struct __sAudit *_psAudit)
{
  const signed long int startServerThreadPool_array_size0 = (signed long int)_psAudit->iHostCnt;
  struct __sServer psServer[startServerThreadPool_array_size0];
  struct __sHost *psHost;
  signed int iServerId;
  struct __sUser *psUser;
  char *szResumeMap = (char *)(void *)0;
  char *szUserMap = (char *)(void *)0;
  signed int nAddHost;
  signed int nUserMapSize;
  signed int nFirstNewHostFound;
  signed int nFirstNewUserFound;
  char szTmp[11l];
  char szTmp1[11l];
  char szTmp2[11l];
  writeVerbose(6, "Parallel Hosts: %d Parallel Logins: %d", _psAudit->iServerCnt, _psAudit->iLoginCnt);
  writeVerbose(6, "Total Hosts: %d ", _psAudit->iHostCnt);
  if(_psAudit->iUserCnt == 0)
    writeVerbose(6, "Total Users: [combo]");

  else
    writeVerbose(6, "Total Users: %d", _psAudit->iUserCnt);
  if(_psAudit->iPassCnt == 0)
    writeVerbose(6, "Total Passwords: [combo]");

  else
    writeVerbose(6, "Total Passwords: %d", _psAudit->iPassCnt);
  if(!(_psAudit->iHostCnt >= _psAudit->iServerCnt))
    _psAudit->iServerCnt = _psAudit->iHostCnt;

  init_crypto_locks();
  _psAudit->server_pool=thr_pool_create((unsigned int)0, (unsigned int)_psAudit->iServerCnt, (unsigned int)1, (union pthread_attr_t *)(void *)0);
  char *return_value_index_1;
  char *return_value_index_4;
  char *return_value_index_2;
  unsigned long int return_value_strlen_3;
  char *return_value_strstr_10;
  char *return_value_strstr_7;
  _Bool tmp_if_expr_9;
  char *return_value_strstr_8;
  char *return_value_strstr_11;
  signed int *return_value___errno_location_12;
  char *return_value_strerror_13;
  signed int *return_value___errno_location_16;
  char *return_value_strerror_17;
  if(_psAudit->server_pool == ((struct thr_pool *)NULL))
  {
    writeError(3, "Failed to create root server thread pool.");
    return -1;
  }

  else
  {
    memset((void *)psServer, 0, sizeof(struct __sServer) /*112ul*/  * (unsigned long int)_psAudit->iHostCnt);
    psHost = _psAudit->psHostRoot;
    nFirstNewHostFound = 0;
    iServerId = 0;
    for( ; !(iServerId >= _psAudit->iHostCnt); iServerId = iServerId + 1)
    {
      nAddHost = 1;
      if(!(_psAudit->pOptResume == ((char *)NULL)))
      {
        memset((void *)szTmp, 0, (unsigned long int)11);
        memset((void *)szTmp1, 0, (unsigned long int)11);
        snprintf(szTmp, (unsigned long int)10, "h%d.", psHost->iId);
        snprintf(szTmp1, (unsigned long int)10, "h%du", psHost->iId);
        if(nFirstNewHostFound == 1)
          writeError(9, "[Host Resume] Adding host: %d (we've passed the point of the previous run)", psHost->iId);

        else
        {
          szResumeMap=strstr(_psAudit->pOptResume, szTmp1);
          if(!(szResumeMap == ((char *)NULL)))
          {
            writeError(9, "[Host Resume] Adding host: %d (host was located in resume map)", psHost->iId);
            char *return_value_index_5;
            return_value_index_5=index(szResumeMap + (signed long int)1, 0x68);
            if(!(return_value_index_5 == ((char *)NULL)))
            {
              return_value_index_1=index(szResumeMap + (signed long int)1, 0x68);
              nUserMapSize = (signed int)(return_value_index_1 - szResumeMap);
            }

            else
            {
              return_value_index_4=index(szResumeMap + (signed long int)1, 0x2e);
              if(!(return_value_index_4 == ((char *)NULL)))
              {
                return_value_index_2=index(szResumeMap + (signed long int)1, 0x2e);
                nUserMapSize = (signed int)(return_value_index_2 - szResumeMap);
              }

              else
              {
                return_value_strlen_3=strlen(szResumeMap);
                nUserMapSize = (signed int)return_value_strlen_3;
              }
            }
            if(!(nUserMapSize >= 4))
              writeError(0, "Error extacting user resume map for host: %d", psHost->iId);

            void *return_value_malloc_6;
            return_value_malloc_6=malloc((unsigned long int)(nUserMapSize + 1));
            szUserMap = (char *)return_value_malloc_6;
            memset((void *)szUserMap, 0, (unsigned long int)(nUserMapSize + 1));
            strncpy(szUserMap, szResumeMap, (unsigned long int)nUserMapSize);
            writeError(9, "[Host Resume] Host: %d - Processing host's user resume map: %s", psHost->iId, szUserMap);
            nFirstNewUserFound = 0;
            psUser = psHost->psUser;
            while(!(psUser == ((struct __sUser *)NULL)))
            {
              memset((void *)szTmp, 0, (unsigned long int)11);
              memset((void *)szTmp1, 0, (unsigned long int)11);
              snprintf(szTmp, (unsigned long int)10, "u%du", psUser->iId);
              snprintf(szTmp1, (unsigned long int)10, "u%dh", psUser->iId);
              snprintf(szTmp2, (unsigned long int)10, "u%d.", psUser->iId);
              if(nFirstNewUserFound == 1)
                writeError(9, "[User Resume] Adding user: %d (we've passed the point of the previous run)", psUser->iId);

              else
              {
                return_value_strstr_10=strstr(szResumeMap, szTmp);
                if(!(return_value_strstr_10 == ((char *)NULL)))
                  writeError(9, "[User Resume] Adding user: %d (user was located in resume map)", psUser->iId);

                else
                {
                  return_value_strstr_7=strstr(szResumeMap, szTmp1);
                  if(!(return_value_strstr_7 == ((char *)NULL)))
                    tmp_if_expr_9 = (_Bool)1;

                  else
                  {
                    return_value_strstr_8=strstr(szResumeMap, szTmp2);
                    tmp_if_expr_9 = return_value_strstr_8 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_9)
                  {
                    writeError(9, "[User Resume] Adding user: %d (user was located in resume map and identified as first untouched account)", psUser->iId);
                    nFirstNewUserFound = 1;
                  }

                  else
                  {
                    writeError(9, "[User Resume] Skipping user: %d (user has already been tested)", psUser->iId);
                    psUser->iPassStatus = 5;
                  }
                }
              }
              psUser = psUser->psUserNext;
            }
          }

          else
          {
            return_value_strstr_11=strstr(_psAudit->pOptResume, szTmp);
            if(!(return_value_strstr_11 == ((char *)NULL)))
            {
              writeError(9, "[Host Resume] Adding host: %d (host was located in resume map and identified as first untouched system)", psHost->iId);
              nFirstNewHostFound = 1;
            }

            else
            {
              writeError(9, "[Host Resume] Skipping host: %d (host has already been tested)", psHost->iId);
              nAddHost = 0;
              psHost->iUserStatus = 3;
            }
          }
        }
      }

      if(!(nAddHost == 0))
      {
        writeError(8, "adding new server (%d) to queue", iServerId);
        signed int return_value_pthread_mutex_init_14;
        return_value_pthread_mutex_init_14=pthread_mutex_init(&psServer[(signed long int)iServerId].ptmMutex, (const union anonymous_14 *)(void *)0);
        if(!(return_value_pthread_mutex_init_14 == 0))
        {
          return_value___errno_location_12=__errno_location();
          return_value_strerror_13=strerror(*return_value___errno_location_12);
          writeError(0, "Server (%d) mutex initialization failed - %s\n", iServerId, return_value_strerror_13);
        }

        psServer[(signed long int)iServerId].psAudit = _psAudit;
        psServer[(signed long int)iServerId].iId = iServerId;
        psServer[(signed long int)iServerId].psHost = psHost;
        psServer[(signed long int)iServerId].iLoginCnt = _psAudit->iLoginCnt;
        psServer[(signed long int)iServerId].iLoginsDone = 0;
        psServer[(signed long int)iServerId].iCredentialsMissed = 0;
        signed int return_value_thr_pool_queue_15;
        return_value_thr_pool_queue_15=thr_pool_queue(_psAudit->server_pool, (void *)startLoginThreadPool, (void *)&psServer[(signed long int)iServerId]);
        if(!(return_value_thr_pool_queue_15 >= 0))
        {
          writeError(3, "Failed to add host task to server thread pool.");
          return -1;
        }

      }

      psHost = psHost->psHostNext;
    }
    writeError(8, "waiting for server pool to end");
    thr_pool_wait(_psAudit->server_pool);
    writeError(8, "destroying server pool");
    thr_pool_destroy(_psAudit->server_pool);
    iServerId = 0;
    for( ; !(iServerId >= _psAudit->iHostCnt); iServerId = iServerId + 1)
    {
      signed int return_value_pthread_mutex_init_18;
      return_value_pthread_mutex_init_18=pthread_mutex_init(&psServer[(signed long int)iServerId].ptmMutex, (const union anonymous_14 *)(void *)0);
      if(!(return_value_pthread_mutex_init_18 == 0))
      {
        return_value___errno_location_16=__errno_location();
        return_value_strerror_17=strerror(*return_value___errno_location_16);
        writeError(0, "Server (%d) mutex destroy call failed - %s\n", iServerId, return_value_strerror_17);
      }

    }
    kill_crypto_locks();
    return 0;
  }
}

// thr_pool_create
// file medusa-thread-pool.h line 33
extern struct thr_pool * thr_pool_create(unsigned int min_threads, unsigned int max_threads, unsigned int linger, union pthread_attr_t *attr)
{
  struct thr_pool *pool;
  sigfillset(&fillset);
  if(!(max_threads >= 1u) || !(max_threads >= min_threads))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return (struct thr_pool *)(void *)0;
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct thr_pool) /*304ul*/ );
  pool = (struct thr_pool *)return_value_malloc_3;
  if(pool == ((struct thr_pool *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 12;
    return (struct thr_pool *)(void *)0;
  }

  pthread_mutex_init(&pool->pool_mutex, (const union anonymous_14 *)(void *)0);
  pthread_cond_init(&pool->pool_busycv, (const union anonymous_14 *)(void *)0);
  pthread_cond_init(&pool->pool_workcv, (const union anonymous_14 *)(void *)0);
  pthread_cond_init(&pool->pool_waitcv, (const union anonymous_14 *)(void *)0);
  pool->pool_active = (struct active *)(void *)0;
  pool->pool_head = (struct job *)(void *)0;
  pool->pool_tail = (struct job *)(void *)0;
  pool->pool_flags = 0;
  pool->pool_linger = linger;
  pool->pool_minimum = (signed int)min_threads;
  pool->pool_maximum = (signed int)max_threads;
  pool->pool_nthreads = 0;
  pool->pool_idle = 0;
  clone_attributes(&pool->pool_attr, attr);
  pthread_mutex_lock(&thr_pool_lock);
  if(thr_pools == ((struct thr_pool *)NULL))
  {
    pool->pool_forw = pool;
    pool->pool_back = pool;
    thr_pools = pool;
  }

  else
  {
    thr_pools->pool_back->pool_forw = pool;
    pool->pool_forw = thr_pools;
    pool->pool_back = thr_pools->pool_back;
    thr_pools->pool_back = pool;
  }
  pthread_mutex_unlock(&thr_pool_lock);
  return pool;
}

// thr_pool_destroy
// file medusa-thread-pool.h line 60
extern void thr_pool_destroy(struct thr_pool *pool)
{
  struct active *activep;
  struct job *job;
  pthread_mutex_lock(&pool->pool_mutex);
  do
  {
    struct anonymous_6 __cancel_buf;
    void (*__cancel_routine)(void *) = (void (*)(void *))(void *)pthread_mutex_unlock;
    void *__cancel_arg = (void *)&pool->pool_mutex;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      pool->pool_flags = pool->pool_flags | 0x02;
      pthread_cond_broadcast(&pool->pool_workcv);
      activep = pool->pool_active;
      for( ; !(activep == ((struct active *)NULL)); activep = activep->active_next)
        pthread_cancel(activep->active_tid);
      while(!(pool->pool_active == ((struct active *)NULL)))
      {
        pool->pool_flags = pool->pool_flags | 0x01;
        pthread_cond_wait(&pool->pool_waitcv, &pool->pool_mutex);
      }
      while(!(pool->pool_nthreads == 0))
        pthread_cond_wait(&pool->pool_busycv, &pool->pool_mutex);

    __CPROVER_DUMP_L7:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  pthread_mutex_lock(&thr_pool_lock);
  if(thr_pools == pool)
    thr_pools = pool->pool_forw;

  if(thr_pools == pool)
    thr_pools = (struct thr_pool *)(void *)0;

  else
  {
    pool->pool_back->pool_forw = pool->pool_forw;
    pool->pool_forw->pool_back = pool->pool_back;
  }
  pthread_mutex_unlock(&thr_pool_lock);
  job = pool->pool_head;
  for( ; !(job == ((struct job *)NULL)); job = pool->pool_head)
  {
    pool->pool_head = job->job_next;
    free((void *)job);
  }
  pthread_attr_destroy(&pool->pool_attr);
  free((void *)pool);
}

// thr_pool_queue
// file medusa-thread-pool.h line 50
extern signed int thr_pool_queue(struct thr_pool *pool, void *func, void *arg)
{
  struct job *job;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct job) /*24ul*/ );
  job = (struct job *)return_value_malloc_2;
  if(job == ((struct job *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 12;
    return -1;
  }

  job->job_next = (struct job *)(void *)0;
  job->job_func = (void * (*)(void *))func;
  job->job_arg = arg;
  pthread_mutex_lock(&pool->pool_mutex);
  if(pool->pool_head == ((struct job *)NULL))
    pool->pool_head = job;

  else
    pool->pool_tail->job_next = job;
  pool->pool_tail = job;
  signed int return_value_create_worker_3;
  if(pool->pool_idle >= 1)
    pthread_cond_signal(&pool->pool_workcv);

  else
    if(!(pool->pool_nthreads >= pool->pool_maximum))
    {
      return_value_create_worker_3=create_worker(pool);
      if(return_value_create_worker_3 == 0)
        pool->pool_nthreads = pool->pool_nthreads + 1;

    }

  pthread_mutex_unlock(&pool->pool_mutex);
  return 0;
}

// thr_pool_wait
// file medusa-thread-pool.h line 55
extern void thr_pool_wait(struct thr_pool *pool)
{
  pthread_mutex_lock(&pool->pool_mutex);
  do
  {
    struct anonymous_6 __cancel_buf;
    void (*__cancel_routine)(void *) = (void (*)(void *))(void *)pthread_mutex_unlock;
    void *__cancel_arg = (void *)&pool->pool_mutex;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);

  __CPROVER_DUMP_L3:
    ;
    do
    {
      if(pool->pool_head == ((struct job *)NULL))
      {
        if(!(pool->pool_active == ((struct active *)NULL)))
          goto __CPROVER_DUMP_L4;

      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        pool->pool_flags = pool->pool_flags | 0x01;
        pthread_cond_wait(&pool->pool_waitcv, &pool->pool_mutex);
        goto __CPROVER_DUMP_L3;
      }

    __CPROVER_DUMP_L5:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
}

// thread_id
// file medusa-thread-ssl.c line 32
static unsigned long int thread_id(void)
{
  unsigned long int ret;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  ret = (unsigned long int)return_value_pthread_self_1;
  return ret;
}

// usage
// file medusa.c line 55
void usage()
{
  writeVerbose(1, "");
  writeVerbose(1, "Syntax: %s [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]", (const void *)"Medusa");
  writeVerbose(1, "  -h [TEXT]    : Target hostname or IP address");
  writeVerbose(1, "  -H [FILE]    : File containing target hostnames or IP addresses");
  writeVerbose(1, "  -u [TEXT]    : Username to test");
  writeVerbose(1, "  -U [FILE]    : File containing usernames to test");
  writeVerbose(1, "  -p [TEXT]    : Password to test");
  writeVerbose(1, "  -P [FILE]    : File containing passwords to test");
  writeVerbose(1, "  -C [FILE]    : File containing combo entries. See README for more information.");
  writeVerbose(1, "  -O [FILE]    : File to append log information to");
  writeVerbose(1, "  -e [n/s/ns]  : Additional password checks ([n] No Password, [s] Password = Username)");
  writeVerbose(1, "  -M [TEXT]    : Name of the module to execute (without the .mod extension)");
  writeVerbose(1, "  -m [TEXT]    : Parameter to pass to the module. This can be passed multiple times with a");
  writeVerbose(1, "                 different parameter each time and they will all be sent to the module (i.e.");
  writeVerbose(1, "                 -m Param1 -m Param2, etc.)");
  writeVerbose(1, "  -d           : Dump all known modules");
  writeVerbose(1, "  -n [NUM]     : Use for non-default TCP port number");
  writeVerbose(1, "  -s           : Enable SSL");
  writeVerbose(1, "  -g [NUM]     : Give up after trying to connect for NUM seconds (default 3)");
  writeVerbose(1, "  -r [NUM]     : Sleep NUM seconds between retry attempts (default 3)");
  writeVerbose(1, "  -R [NUM]     : Attempt NUM retries before giving up. The total number of attempts will be NUM + 1.");
  writeVerbose(1, "  -c [NUM]     : Time to wait in usec to verify socket is available (default 500 usec).");
  writeVerbose(1, "  -t [NUM]     : Total number of logins to be tested concurrently");
  writeVerbose(1, "  -T [NUM]     : Total number of hosts to be tested concurrently");
  writeVerbose(1, "  -L           : Parallelize logins using one username per thread. The default is to process ");
  writeVerbose(1, "                 the entire username before proceeding.");
  writeVerbose(1, "  -f           : Stop scanning host after first valid username/password found.");
  writeVerbose(1, "  -F           : Stop audit after first valid username/password found on any host.");
  writeVerbose(1, "  -b           : Suppress startup banner");
  writeVerbose(1, "  -q           : Display module's usage information");
  writeVerbose(1, "  -v [NUM]     : Verbose level [0 - 6 (more)]");
  writeVerbose(1, "  -w [NUM]     : Error debug level [0 - 10 (more)]");
  writeVerbose(1, "  -V           : Display version");
  writeVerbose(1, "  -Z [TEXT]    : Resume scan based on map of previous scan");
  writeVerbose(1, "\n");
}

// worker_cleanup
// file medusa-thread-pool.c line 106
static void worker_cleanup(struct thr_pool *pool)
{
  pool->pool_nthreads = pool->pool_nthreads - 1;
  signed int return_value_create_worker_1;
  if(!((0x02 & pool->pool_flags) == 0))
  {
    if(pool->pool_nthreads == 0)
      pthread_cond_broadcast(&pool->pool_busycv);

  }

  else
    if(!(pool->pool_head == ((struct job *)NULL)))
    {
      if(!(pool->pool_nthreads >= pool->pool_maximum))
      {
        return_value_create_worker_1=create_worker(pool);
        if(return_value_create_worker_1 == 0)
          pool->pool_nthreads = pool->pool_nthreads + 1;

      }

    }

  pthread_mutex_unlock(&pool->pool_mutex);
}

// worker_thread
// file medusa-thread-pool.c line 153
static void * worker_thread(void *arg)
{
  struct thr_pool *pool = (struct thr_pool *)arg;
  signed int timedout;
  struct job *job;
  void * (*func)(void *);
  struct active active;
  struct timespec ts;
  pthread_mutex_lock(&pool->pool_mutex);
  _Bool tmp_if_expr_2;
  signed int return_value_pthread_cond_timedwait_1;
  do
  {
    struct anonymous_6 worker_thread__1__1____cancel_buf;
    void (*__cancel_routine)(void *) = (void (*)(void *))(void *)worker_cleanup;
    void *worker_thread__1__1____cancel_arg = (void *)pool;
    signed int worker_thread__1__1____not_first_call;
    worker_thread__1__1____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)worker_thread__1__1____cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)worker_thread__1__1____not_first_call == 0l))
    {
      __cancel_routine(worker_thread__1__1____cancel_arg);
      __pthread_unwind_next(&worker_thread__1__1____cancel_buf);
    }

    __pthread_register_cancel(&worker_thread__1__1____cancel_buf);
    do
    {
      active.active_tid=pthread_self();
      do
      {
        pthread_sigmask(2, &fillset, (struct anonymous_5 *)(void *)0);
        pthread_setcanceltype(0, (signed int *)(void *)0);
        pthread_setcancelstate(0, (signed int *)(void *)0);
        timedout = 0;
        pool->pool_idle = pool->pool_idle + 1;
        if(!((0x01 & pool->pool_flags) == 0))
          notify_waiters(pool);

        while(pool->pool_head == ((struct job *)NULL))
        {
          if(!((0x02 & pool->pool_flags) == 0))
            break;

          if(pool->pool_minimum >= pool->pool_nthreads)
            pthread_cond_wait(&pool->pool_workcv, &pool->pool_mutex);

          else
          {
            clock_gettime(0, &ts);
            ts.tv_sec = ts.tv_sec + (signed long int)pool->pool_linger;
            if(pool->pool_linger == 0u)
              tmp_if_expr_2 = (_Bool)1;

            else
            {
              return_value_pthread_cond_timedwait_1=pthread_cond_timedwait(&pool->pool_workcv, &pool->pool_mutex, &ts);
              tmp_if_expr_2 = return_value_pthread_cond_timedwait_1 == 110 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_2)
            {
              timedout = 1;
              break;
            }

          }
        }
        pool->pool_idle = pool->pool_idle - 1;
        if(!((0x02 & pool->pool_flags) == 0))
          break;

        job = pool->pool_head;
        if(!(job == ((struct job *)NULL)))
        {
          timedout = 0;
          func = job->job_func;
          arg = job->job_arg;
          pool->pool_head = job->job_next;
          if(job == pool->pool_tail)
            pool->pool_tail = (struct job *)(void *)0;

          active.active_next = pool->pool_active;
          pool->pool_active = &active;
          pthread_mutex_unlock(&pool->pool_mutex);
          struct anonymous_6 __cancel_buf;
          void (*worker_thread__1__1__2__1__1__2__1____cancel_routine)(void *) = (void (*)(void *))(void *)job_cleanup;
          void *__cancel_arg = (void *)pool;
          signed int __not_first_call;
          __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
          if(!((signed long int)__not_first_call == 0l))
          {
            worker_thread__1__1__2__1__1__2__1____cancel_routine(__cancel_arg);
            __pthread_unwind_next(&__cancel_buf);
          }

          __pthread_register_cancel(&__cancel_buf);
          free((void *)job);
          func(arg);
          __pthread_unregister_cancel(&__cancel_buf);
          worker_thread__1__1__2__1__1__2__1____cancel_routine(__cancel_arg);
        }

        if(!(timedout == 0))
        {
          if(!(pool->pool_minimum >= pool->pool_nthreads))
            break;

        }

      }
      while((_Bool)1);

    __CPROVER_DUMP_L20:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&worker_thread__1__1____cancel_buf);
    __cancel_routine(worker_thread__1__1____cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// writeError
// file medusa-trace.h line 47
void writeError(signed int iLevel, char *pMsg, ...)
{
  void **ap;
  char buf[4096l];
  char bufOut[16384l];
  char temp[6l];
  unsigned char cTemp;
  unsigned int i = (unsigned int)0;
  unsigned long int return_value_pthread_self_1;
  unsigned long int return_value_pthread_self_2;
  unsigned long int return_value_pthread_self_3;
  unsigned long int return_value_pthread_self_4;
  unsigned long int return_value_pthread_self_5;
  if(pMsg == ((char *)NULL))
    fprintf(stderr, "CRITICAL: writeError() called with NULL message.\n");

  else
    if(iErrorLevel >= iLevel)
    {
      ap = (void **)&pMsg;
      memset((void *)bufOut, 0, (unsigned long int)16384);
      memset((void *)buf, 0, (unsigned long int)4096);
      vsnprintf(buf, sizeof(char [4096l]) /*4096ul*/ , pMsg, ap);
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= sizeof(char [4096l]) /*4096ul*/ ); i = i + 1u)
      {
        memset((void *)temp, 0, (unsigned long int)6);
        cTemp = (unsigned char)buf[(signed long int)i];
        if((signed int)cTemp >= 127 || (signed int)cTemp >= 1 && !((signed int)cTemp >= 32))
          snprintf(temp, (unsigned long int)6, "[%02X]", cTemp);

        else
          snprintf(temp, (unsigned long int)6, "%c", cTemp);
        strncat(bufOut, temp, (unsigned long int)6);
      }
      switch(iLevel)
      {
        case 0:
        {
          fprintf(stderr, "FATAL: %s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          exit(1);
          break;
        }
        case 1:
        {
          fprintf(stderr, "ALERT: ");
          break;
        }
        case 2:
        {
          fprintf(stderr, "CRITICAL: ");
          break;
        }
        case 3:
        {
          fprintf(stderr, "ERROR: ");
          break;
        }
        case 4:
        {
          fprintf(stderr, "WARNING: ");
          break;
        }
        case 5:
        {
          fprintf(stderr, "NOTICE: ");
          break;
        }
        case 6:
        {
          fprintf(stderr, "INFO: ");
          break;
        }
        case 7:
        {
          return_value_pthread_self_1=pthread_self();
          fprintf(stderr, "DEBUG [%X]: ", (signed int)return_value_pthread_self_1);
          break;
        }
        case 8:
        {
          return_value_pthread_self_2=pthread_self();
          fprintf(stderr, "DEBUG AUDIT [%X]: ", (signed int)return_value_pthread_self_2);
          break;
        }
        case 9:
        {
          return_value_pthread_self_3=pthread_self();
          fprintf(stderr, "DEBUG SERVER [%X]: ", (signed int)return_value_pthread_self_3);
          break;
        }
        case 10:
        {
          return_value_pthread_self_4=pthread_self();
          fprintf(stderr, "DEBUG MODULE [%X]: ", (signed int)return_value_pthread_self_4);
          break;
        }
        default:
        {
          return_value_pthread_self_5=pthread_self();
          fprintf(stdout, "UNKNOWN ERROR [%X]: ", (signed int)return_value_pthread_self_5);
        }
      }
      fprintf(stderr, "%s\n", (const void *)bufOut);
      ap = ((void **)NULL);
    }

  goto __CPROVER_DUMP_L20;

__CPROVER_DUMP_L20:
  ;
}

// writeErrorBin
// file ../medusa-trace.c line 207
void writeErrorBin(signed int iLevel, char *pMsg, unsigned char *pData, signed int iLength)
{
  signed int i;
  if(iErrorLevel >= iLevel)
  {
    fprintf(stderr, "DATA: %s ", pMsg);
    i = 0;
    for( ; !(i >= iLength); i = i + 1)
      fprintf(stderr, "%2.2X", (signed int)pData[(signed long int)i] & 0xFF);
    fprintf(stderr, "\n");
  }

  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// writeVerbose
// file modsrc/../medusa-trace.h line 46
void writeVerbose(signed int iLevel, char *pMsg, ...)
{
  void **ap;
  char buf[512l];
  char bufOut[2049l];
  char temp[6l];
  unsigned char cTemp;
  unsigned int i = (unsigned int)0;
  if(pMsg == ((char *)NULL))
    fprintf(stderr, "CRITICAL: writeDebug() called with NULL message.\n");

  else
    if(iVerboseLevel >= iLevel)
    {
      ap = (void **)&pMsg;
      memset((void *)bufOut, 0, sizeof(char [2049l]) /*2049ul*/ );
      memset((void *)buf, 0, sizeof(char [512l]) /*512ul*/ );
      vsnprintf(buf, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, pMsg, ap);
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= sizeof(char [512l]) /*512ul*/ ); i = i + 1u)
      {
        memset((void *)temp, 0, (unsigned long int)6);
        cTemp = (unsigned char)buf[(signed long int)i];
        if((signed int)cTemp >= 127 || (signed int)cTemp >= 1 && !((signed int)cTemp == 9) && !((signed int)cTemp == 10) && !((signed int)cTemp == 13) && !((signed int)cTemp >= 32))
          sprintf(temp, "[%02X]", cTemp);

        else
          sprintf(temp, "%c", cTemp);
        strncat(bufOut, temp, (unsigned long int)6);
      }
      switch(iLevel)
      {
        case 4:
        {
          fprintf(stdout, "ACCOUNT FOUND: %s\n", (const void *)bufOut);
          if(!(pOutputFile == ((struct _IO_FILE *)NULL)))
          {
            pthread_mutex_lock(&ptmFileMutex);
            fprintf(pOutputFile, "ACCOUNT FOUND: %s\n", (const void *)buf);
            fflush(pOutputFile);
            pthread_mutex_unlock(&ptmFileMutex);
          }

          ap = ((void **)NULL);
          break;
        }
        case 5:
        {
          fprintf(stdout, "ACCOUNT CHECK: %s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          break;
        }
        case 3:
        {
          fprintf(stdout, "IMPORTANT: %s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          break;
        }
        case 6:
        {
          fprintf(stdout, "GENERAL: %s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          break;
        }
        case 1:
        {
          fprintf(stdout, "%s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          break;
        }
        case 2:
        {
          if(!(pOutputFile == ((struct _IO_FILE *)NULL)))
          {
            pthread_mutex_lock(&ptmFileMutex);
            fprintf(pOutputFile, "%s", (const void *)bufOut);
            fflush(pOutputFile);
            pthread_mutex_unlock(&ptmFileMutex);
          }

          ap = ((void **)NULL);
          break;
        }
        case 0:
        {
          fprintf(stdout, "%s\n", (const void *)bufOut);
          ap = ((void **)NULL);
          exit(0);
          break;
        }
        default:
        {
          fprintf(stdout, "UNKNOWN: %s\n", (const void *)bufOut);
          ap = ((void **)NULL);
        }
      }
    }

  goto __CPROVER_DUMP_L17;

__CPROVER_DUMP_L17:
  ;
}

