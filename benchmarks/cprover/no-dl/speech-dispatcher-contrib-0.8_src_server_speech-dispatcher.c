// #anon_enum$G_FILE_TEST_IS_REGULAR=1$G_FILE_TEST_IS_SYMLINK=2$G_FILE_TEST_IS_DIR=4$G_FILE_TEST_IS_EXECUTABLE=8$G_FILE_TEST_EXISTS=16
// file /usr/include/glib-2.0/glib/gfileutils.h line 66
enum anonymous$15 { G_FILE_TEST_IS_REGULAR=1, G_FILE_TEST_IS_SYMLINK=2, G_FILE_TEST_IS_DIR=4, G_FILE_TEST_IS_EXECUTABLE=8, G_FILE_TEST_EXISTS=16 };

// #anon_enum$G_REGEX_CASELESS=1$G_REGEX_MULTILINE=2$G_REGEX_DOTALL=4$G_REGEX_EXTENDED=8$G_REGEX_ANCHORED=16$G_REGEX_DOLLAR_ENDONLY=32$G_REGEX_UNGREEDY=512$G_REGEX_RAW=2048$G_REGEX_NO_AUTO_CAPTURE=4096$G_REGEX_OPTIMIZE=8192$G_REGEX_FIRSTLINE=262144$G_REGEX_DUPNAMES=524288$G_REGEX_NEWLINE_CR=1048576$G_REGEX_NEWLINE_LF=2097152$G_REGEX_NEWLINE_CRLF=3145728$G_REGEX_NEWLINE_ANYCRLF=5242880$G_REGEX_BSR_ANYCRLF=8388608$G_REGEX_JAVASCRIPT_COMPAT=33554432
// file /usr/include/glib-2.0/glib/gregex.h line 297
enum anonymous$19 { G_REGEX_CASELESS=1, G_REGEX_MULTILINE=2, G_REGEX_DOTALL=4, G_REGEX_EXTENDED=8, G_REGEX_ANCHORED=16, G_REGEX_DOLLAR_ENDONLY=32, G_REGEX_UNGREEDY=512, G_REGEX_RAW=2048, G_REGEX_NO_AUTO_CAPTURE=4096, G_REGEX_OPTIMIZE=8192, G_REGEX_FIRSTLINE=262144, G_REGEX_DUPNAMES=524288, G_REGEX_NEWLINE_CR=1048576, G_REGEX_NEWLINE_LF=2097152, G_REGEX_NEWLINE_CRLF=3145728, G_REGEX_NEWLINE_ANYCRLF=5242880, G_REGEX_BSR_ANYCRLF=8388608, G_REGEX_JAVASCRIPT_COMPAT=33554432 };

// #anon_enum$G_REGEX_MATCH_ANCHORED=16$G_REGEX_MATCH_NOTBOL=128$G_REGEX_MATCH_NOTEOL=256$G_REGEX_MATCH_NOTEMPTY=1024$G_REGEX_MATCH_PARTIAL=32768$G_REGEX_MATCH_NEWLINE_CR=1048576$G_REGEX_MATCH_NEWLINE_LF=2097152$G_REGEX_MATCH_NEWLINE_CRLF=3145728$G_REGEX_MATCH_NEWLINE_ANY=4194304$G_REGEX_MATCH_NEWLINE_ANYCRLF=5242880$G_REGEX_MATCH_BSR_ANYCRLF=8388608$G_REGEX_MATCH_BSR_ANY=16777216$G_REGEX_MATCH_PARTIAL_SOFT=32768$G_REGEX_MATCH_PARTIAL_HARD=134217728$G_REGEX_MATCH_NOTEMPTY_ATSTART=268435456
// file /usr/include/glib-2.0/glib/gregex.h line 387
enum anonymous$20 { G_REGEX_MATCH_ANCHORED=16, G_REGEX_MATCH_NOTBOL=128, G_REGEX_MATCH_NOTEOL=256, G_REGEX_MATCH_NOTEMPTY=1024, G_REGEX_MATCH_PARTIAL=32768, G_REGEX_MATCH_NEWLINE_CR=1048576, G_REGEX_MATCH_NEWLINE_LF=2097152, G_REGEX_MATCH_NEWLINE_CRLF=3145728, G_REGEX_MATCH_NEWLINE_ANY=4194304, G_REGEX_MATCH_NEWLINE_ANYCRLF=5242880, G_REGEX_MATCH_BSR_ANYCRLF=8388608, G_REGEX_MATCH_BSR_ANY=16777216, G_REGEX_MATCH_PARTIAL_SOFT=32768, G_REGEX_MATCH_PARTIAL_HARD=134217728, G_REGEX_MATCH_NOTEMPTY_ATSTART=268435456 };

// #anon_enum$SORT_BY_TIME=0$SORT_BY_ALPHABET=1
// file ../../include/speechd_types.h line 93
enum anonymous$18 { SORT_BY_TIME=0, SORT_BY_ALPHABET=1 };

// #anon_enum$SPD_BEGIN=1$SPD_END=2$SPD_INDEX_MARKS=4$SPD_CANCEL=8$SPD_PAUSE=16$SPD_RESUME=32$SPD_ALL=63
// file ../../include/speechd_types.h line 73
enum anonymous$17 { SPD_BEGIN=1, SPD_END=2, SPD_INDEX_MARKS=4, SPD_CANCEL=8, SPD_PAUSE=16, SPD_RESUME=32, SPD_ALL=63 };

// #anon_enum$SPD_CAP_NONE=0$SPD_CAP_SPELL=1$SPD_CAP_ICON=2
// file ../../include/speechd_types.h line 32
enum anonymous$4 { SPD_CAP_NONE=0, SPD_CAP_SPELL=1, SPD_CAP_ICON=2 };

// #anon_enum$SPD_DATA_TEXT=0$SPD_DATA_SSML=1
// file ../../include/speechd_types.h line 60
enum anonymous$5 { SPD_DATA_TEXT=0, SPD_DATA_SSML=1 };

// #anon_enum$SPD_IMPORTANT=1$SPD_MESSAGE=2$SPD_TEXT=3$SPD_NOTIFICATION=4$SPD_PROGRESS=5
// file ../../include/speechd_types.h line 65
enum anonymous$9 { SPD_IMPORTANT=1, SPD_MESSAGE=2, SPD_TEXT=3, SPD_NOTIFICATION=4, SPD_PROGRESS=5 };

// #anon_enum$SPD_MALE1=1$SPD_MALE2=2$SPD_MALE3=3$SPD_FEMALE1=4$SPD_FEMALE2=5$SPD_FEMALE3=6$SPD_CHILD_MALE=7$SPD_CHILD_FEMALE=8
// file ../../include/speechd_types.h line 43
enum anonymous$27 { SPD_MALE1=1, SPD_MALE2=2, SPD_MALE3=3, SPD_FEMALE1=4, SPD_FEMALE2=5, SPD_FEMALE3=6, SPD_CHILD_MALE=7, SPD_CHILD_FEMALE=8 };

// #anon_enum$SPD_MODE_DAEMON=0$SPD_MODE_SINGLE=1
// file speechd.h line 120
enum anonymous$25 { SPD_MODE_DAEMON=0, SPD_MODE_SINGLE=1 };

// #anon_enum$SPD_MSGTYPE_TEXT=0$SPD_MSGTYPE_SOUND_ICON=1$SPD_MSGTYPE_CHAR=2$SPD_MSGTYPE_KEY=3$SPD_MSGTYPE_SPELL=99
// file ../../include/speechd_types.h line 98
enum anonymous$8 { SPD_MSGTYPE_TEXT=0, SPD_MSGTYPE_SOUND_ICON=1, SPD_MSGTYPE_CHAR=2, SPD_MSGTYPE_KEY=3, SPD_MSGTYPE_SPELL=99 };

// #anon_enum$SPD_PUNCT_ALL=0$SPD_PUNCT_NONE=1$SPD_PUNCT_SOME=2
// file ../../include/speechd_types.h line 26
enum anonymous$2 { SPD_PUNCT_ALL=0, SPD_PUNCT_NONE=1, SPD_PUNCT_SOME=2 };

// #anon_enum$SPD_SPELL_OFF=0$SPD_SPELL_ON=1
// file ../../include/speechd_types.h line 38
enum anonymous$1 { SPD_SPELL_OFF=0, SPD_SPELL_ON=1 };

// tag-#anon#ST[*{S8}$S8$'communication_method'||S32'communication_method_set'||U32'$pad0'||*{S8}$S8$'socket_path'||S32'socket_path_set'||S32'port'||S32'port_set'||S32'localhost_access_only'||S32'localhost_access_only_set'||S32'log_level'||S32'log_level_set'||U32'$pad1'||*{S8}$S8$'pid_file'||*{S8}$S8$'conf_file'||*{S8}$S8$'conf_dir'||*{S8}$S8$'runtime_speechd_dir'||*{S8}$S8$'log_dir'||S32'log_dir_set'||S32'spawn'||S32'debug'||U32'$pad2'||*{S8}$S8$'debug_destination'||*{S8}$S8$'debug_logfile'||S32'max_history_messages'||U32'$pad3'|]
// file speechd.h line 150
struct anonymous$24;

// tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'filename'||*{S8}$S8$'configfilename'||*{S8}$S8$'debugfilename'||ARR2{S32}$S32$'pipe_in'||ARR2{S32}$S32$'pipe_out'||*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'stream_out'||S32'stderr_redirect'||S32'pid'||S32'working'||U32'$pad0'|]
// file module.h line 31
struct anonymous$10;

// tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'language'||*{S8}$S8$'variant'|]
// file ../../include/speechd_types.h line 54
struct anonymous$6;

// tag-#anon#ST[*{S8}$S8$'pattern'||SYM#tag-#anon#ST[U32'uid'||S32'fd'||S32'active'||S32'paused'||S32'paused_while_speaking'||EN#anon_enum$SPD_MSGTYPE_TEXT=0$SPD_MSGTYPE_SOUND_ICON=1$SPD_MSGTYPE_CHAR=2$SPD_MSGTYPE_KEY=3$SPD_MSGTYPE_SPELL=99#{U32}$U32$'type'||EN#anon_enum$SPD_DATA_TEXT=0$SPD_DATA_SSML=1#{U32}$U32$'ssml_mode'||EN#anon_enum$SPD_IMPORTANT=1$SPD_MESSAGE=2$SPD_TEXT=3$SPD_NOTIFICATION=4$SPD_PROGRESS=5#{U32}$U32$'priority'||SYM#tag-#anon#ST[S32'rate'||S32'pitch'||S32'volume'||EN#anon_enum$SPD_PUNCT_ALL=0$SPD_PUNCT_NONE=1$SPD_PUNCT_SOME=2#{U32}$U32$'punctuation_mode'||EN#anon_enum$SPD_SPELL_OFF=0$SPD_SPELL_ON=1#{U32}$U32$'spelling_mode'||EN#anon_enum$SPD_CAP_NONE=0$SPD_CAP_SPELL=1$SPD_CAP_ICON=2#{U32}$U32$'cap_let_recogn'||EN#anon_enum$SPD_MALE1=1$SPD_MALE2=2$SPD_MALE3=3$SPD_FEMALE1=4$SPD_FEMALE2=5$SPD_FEMALE3=6$SPD_CHILD_MALE=7$SPD_CHILD_FEMALE=8#{U32}$U32$'voice_type'||U32'$pad0'||SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'language'||*{S8}$S8$'variant'|]#'voice'|]#'msg_settings'||*{S8}$S8$'client_name'||*{S8}$S8$'output_module'||EN#anon_enum$SPD_BEGIN=1$SPD_END=2$SPD_INDEX_MARKS=4$SPD_CANCEL=8$SPD_PAUSE=16$SPD_RESUME=32$SPD_ALL=63#{U32}$U32$'notification'||S32'reparted'||U32'min_delay_progress'||S32'pause_context'||*{S8}$S8$'index_mark'||*{S8}$S8$'audio_output_method'||*{S8}$S8$'audio_oss_device'||*{S8}$S8$'audio_alsa_device'||*{S8}$S8$'audio_nas_server'||*{S8}$S8$'audio_pulse_server'||S32'audio_pulse_min_length'||S32'log_level'||U32'hist_cur_uid'||S32'hist_cur_pos'||EN#anon_enum$SORT_BY_TIME=0$SORT_BY_ALPHABET=1#{U32}$U32$'hist_sorted'||U32'$pad0'|]#'val'|]
// file speechd.h line 111
struct anonymous$26;

// tag-#anon#ST[*{SYM#tag-_GList#}$SYM#tag-_GList#$'p1'||*{SYM#tag-_GList#}$SYM#tag-_GList#$'p2'||*{SYM#tag-_GList#}$SYM#tag-_GList#$'p3'||*{SYM#tag-_GList#}$SYM#tag-_GList#$'p4'||*{SYM#tag-_GList#}$SYM#tag-_GList#$'p5'|]
// file speechd.h line 128
struct anonymous$29;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$23;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$30;

// tag-#anon#ST[S32'awaiting_data'||S32'inside_block'||U64'o_bytes'||*{SYM#tag-_GString#}$SYM#tag-_GString#$'o_buf'|]
// file speechd.h line 221
struct anonymous$0;

// tag-#anon#ST[S32'max_uid'||S32'max_gid'||S32'max_fd'|]
// file speechd.h line 171
struct anonymous$28;

// tag-#anon#ST[S32'rate'||S32'pitch'||S32'volume'||EN#anon_enum$SPD_PUNCT_ALL=0$SPD_PUNCT_NONE=1$SPD_PUNCT_SOME=2#{U32}$U32$'punctuation_mode'||EN#anon_enum$SPD_SPELL_OFF=0$SPD_SPELL_ON=1#{U32}$U32$'spelling_mode'||EN#anon_enum$SPD_CAP_NONE=0$SPD_CAP_SPELL=1$SPD_CAP_ICON=2#{U32}$U32$'cap_let_recogn'||EN#anon_enum$SPD_MALE1=1$SPD_MALE2=2$SPD_MALE3=3$SPD_FEMALE1=4$SPD_FEMALE2=5$SPD_FEMALE3=6$SPD_CHILD_MALE=7$SPD_CHILD_FEMALE=8#{U32}$U32$'voice_type'||U32'$pad0'||SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'language'||*{S8}$S8$'variant'|]#'voice'|]
// file ../../include/speechd_types.h line 106
struct anonymous$16;

// tag-#anon#ST[S64'value'||*{S8}$S8$'str'||*{*{S8}$S8$}$*{S8}$S8$$'list'||F64'dvalue'|]
// file /usr/include/dotconf.h line 170
struct anonymous$14;

// tag-#anon#ST[U32'id'||U32'$pad0'||S64'time'||*{S8}$S8$'buf'||S32'bytes'||U32'$pad1'||SYM#tag-#anon#ST[U32'uid'||S32'fd'||S32'active'||S32'paused'||S32'paused_while_speaking'||EN#anon_enum$SPD_MSGTYPE_TEXT=0$SPD_MSGTYPE_SOUND_ICON=1$SPD_MSGTYPE_CHAR=2$SPD_MSGTYPE_KEY=3$SPD_MSGTYPE_SPELL=99#{U32}$U32$'type'||EN#anon_enum$SPD_DATA_TEXT=0$SPD_DATA_SSML=1#{U32}$U32$'ssml_mode'||EN#anon_enum$SPD_IMPORTANT=1$SPD_MESSAGE=2$SPD_TEXT=3$SPD_NOTIFICATION=4$SPD_PROGRESS=5#{U32}$U32$'priority'||SYM#tag-#anon#ST[S32'rate'||S32'pitch'||S32'volume'||EN#anon_enum$SPD_PUNCT_ALL=0$SPD_PUNCT_NONE=1$SPD_PUNCT_SOME=2#{U32}$U32$'punctuation_mode'||EN#anon_enum$SPD_SPELL_OFF=0$SPD_SPELL_ON=1#{U32}$U32$'spelling_mode'||EN#anon_enum$SPD_CAP_NONE=0$SPD_CAP_SPELL=1$SPD_CAP_ICON=2#{U32}$U32$'cap_let_recogn'||EN#anon_enum$SPD_MALE1=1$SPD_MALE2=2$SPD_MALE3=3$SPD_FEMALE1=4$SPD_FEMALE2=5$SPD_FEMALE3=6$SPD_CHILD_MALE=7$SPD_CHILD_FEMALE=8#{U32}$U32$'voice_type'||U32'$pad0'||SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'language'||*{S8}$S8$'variant'|]#'voice'|]#'msg_settings'||*{S8}$S8$'client_name'||*{S8}$S8$'output_module'||EN#anon_enum$SPD_BEGIN=1$SPD_END=2$SPD_INDEX_MARKS=4$SPD_CANCEL=8$SPD_PAUSE=16$SPD_RESUME=32$SPD_ALL=63#{U32}$U32$'notification'||S32'reparted'||U32'min_delay_progress'||S32'pause_context'||*{S8}$S8$'index_mark'||*{S8}$S8$'audio_output_method'||*{S8}$S8$'audio_oss_device'||*{S8}$S8$'audio_alsa_device'||*{S8}$S8$'audio_nas_server'||*{S8}$S8$'audio_pulse_server'||S32'audio_pulse_min_length'||S32'log_level'||U32'hist_cur_uid'||S32'hist_cur_pos'||EN#anon_enum$SORT_BY_TIME=0$SORT_BY_ALPHABET=1#{U32}$U32$'hist_sorted'||U32'$pad0'|]#'settings'|]
// file speechd.h line 139
struct anonymous$7;

// tag-#anon#ST[U32'uid'||S32'fd'||S32'active'||S32'paused'||S32'paused_while_speaking'||EN#anon_enum$SPD_MSGTYPE_TEXT=0$SPD_MSGTYPE_SOUND_ICON=1$SPD_MSGTYPE_CHAR=2$SPD_MSGTYPE_KEY=3$SPD_MSGTYPE_SPELL=99#{U32}$U32$'type'||EN#anon_enum$SPD_DATA_TEXT=0$SPD_DATA_SSML=1#{U32}$U32$'ssml_mode'||EN#anon_enum$SPD_IMPORTANT=1$SPD_MESSAGE=2$SPD_TEXT=3$SPD_NOTIFICATION=4$SPD_PROGRESS=5#{U32}$U32$'priority'||SYM#tag-#anon#ST[S32'rate'||S32'pitch'||S32'volume'||EN#anon_enum$SPD_PUNCT_ALL=0$SPD_PUNCT_NONE=1$SPD_PUNCT_SOME=2#{U32}$U32$'punctuation_mode'||EN#anon_enum$SPD_SPELL_OFF=0$SPD_SPELL_ON=1#{U32}$U32$'spelling_mode'||EN#anon_enum$SPD_CAP_NONE=0$SPD_CAP_SPELL=1$SPD_CAP_ICON=2#{U32}$U32$'cap_let_recogn'||EN#anon_enum$SPD_MALE1=1$SPD_MALE2=2$SPD_MALE3=3$SPD_FEMALE1=4$SPD_FEMALE2=5$SPD_FEMALE3=6$SPD_CHILD_MALE=7$SPD_CHILD_FEMALE=8#{U32}$U32$'voice_type'||U32'$pad0'||SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'language'||*{S8}$S8$'variant'|]#'voice'|]#'msg_settings'||*{S8}$S8$'client_name'||*{S8}$S8$'output_module'||EN#anon_enum$SPD_BEGIN=1$SPD_END=2$SPD_INDEX_MARKS=4$SPD_CANCEL=8$SPD_PAUSE=16$SPD_RESUME=32$SPD_ALL=63#{U32}$U32$'notification'||S32'reparted'||U32'min_delay_progress'||S32'pause_context'||*{S8}$S8$'index_mark'||*{S8}$S8$'audio_output_method'||*{S8}$S8$'audio_oss_device'||*{S8}$S8$'audio_alsa_device'||*{S8}$S8$'audio_nas_server'||*{S8}$S8$'audio_pulse_server'||S32'audio_pulse_min_length'||S32'log_level'||U32'hist_cur_uid'||S32'hist_cur_pos'||EN#anon_enum$SORT_BY_TIME=0$SORT_BY_ALPHABET=1#{U32}$U32$'hist_sorted'||U32'$pad0'|]
// file speechd.h line 75
struct anonymous$11;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$22;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$13;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$12;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$3;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMatchInfo
// file /usr/include/glib-2.0/glib/gregex.h line 423
struct _GMatchInfo;

// tag-_GRegex
// file /usr/include/glib-2.0/glib/gregex.h line 414
struct _GRegex;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-command_t
// file /usr/include/dotconf.h line 116
struct command_t;

// tag-configfile_t
// file /usr/include/dotconf.h line 113
struct configfile_t;

// tag-configoption_t
// file /usr/include/dotconf.h line 114
struct configoption_t;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// ECapLetRecogn2str
// file ../../include/fdsetconv.h line 20
char * ECapLetRecogn2str(enum anonymous$4 recogn);
// EPunctMode2str
// file ../../include/fdsetconv.h line 12
char * EPunctMode2str(enum anonymous$2 punct);
// ESpellMode2str
// file ../../include/fdsetconv.h line 16
char * ESpellMode2str(enum anonymous$1 spell);
// EVoice2str
// file ../../include/fdsetconv.h line 8
char * EVoice2str(enum anonymous$27 voice);
// MSG
// file speechd.c line 214
void MSG(signed int level, char *format, ...);
// MSG2
// file speechd.c line 129
void MSG2(signed int level, char *kind, char *format, ...);
// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$3, unsigned int *);
// add_config_option
// file configuration.h line 39
struct configoption_t * add_config_option(struct configoption_t *options, signed int *num_config_options, char *name, signed int type, const char * (*callback)(struct command_t *, void *), void *info, unsigned long int context);
// add_config_option::callback$object
//
const char * callback$object(struct command_t *, void *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$3, unsigned int);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// cb_AddModule
// file configuration.c line 296
const char * cb_AddModule(struct command_t *cmd, void *ctx);
// cb_AudioALSADevice
// file configuration.c line 183
const char * cb_AudioALSADevice(struct command_t *cmd, void *ctx);
// cb_AudioNASServer
// file configuration.c line 184
const char * cb_AudioNASServer(struct command_t *cmd, void *ctx);
// cb_AudioOSSDevice
// file configuration.c line 182
const char * cb_AudioOSSDevice(struct command_t *cmd, void *ctx);
// cb_AudioOutputMethod
// file configuration.c line 181
const char * cb_AudioOutputMethod(struct command_t *cmd, void *ctx);
// cb_AudioPulseMinLength
// file configuration.c line 186
const char * cb_AudioPulseMinLength(struct command_t *cmd, void *ctx);
// cb_AudioPulseServer
// file configuration.c line 185
const char * cb_AudioPulseServer(struct command_t *cmd, void *ctx);
// cb_BeginClient
// file configuration.c line 318
const char * cb_BeginClient(struct command_t *cmd, void *ctx);
// cb_CommunicationMethod
// file configuration.c line 209
const char * cb_CommunicationMethod(struct command_t *cmd, void *ctx);
// cb_CustomLogFile
// file configuration.c line 262
const char * cb_CustomLogFile(struct command_t *cmd, void *ctx);
// cb_DefaultCapLetRecognition
// file configuration.c line 205
const char * cb_DefaultCapLetRecognition(struct command_t *cmd, void *ctx);
// cb_DefaultClientName
// file configuration.c line 179
const char * cb_DefaultClientName(struct command_t *cmd, void *ctx);
// cb_DefaultLanguage
// file configuration.c line 178
const char * cb_DefaultLanguage(struct command_t *cmd, void *ctx);
// cb_DefaultModule
// file configuration.c line 177
const char * cb_DefaultModule(struct command_t *cmd, void *ctx);
// cb_DefaultPauseContext
// file configuration.c line 196
const char * cb_DefaultPauseContext(struct command_t *cmd, void *ctx);
// cb_DefaultPitch
// file configuration.c line 190
const char * cb_DefaultPitch(struct command_t *cmd, void *ctx);
// cb_DefaultPriority
// file configuration.c line 198
const char * cb_DefaultPriority(struct command_t *cmd, void *ctx);
// cb_DefaultPunctuationMode
// file configuration.c line 202
const char * cb_DefaultPunctuationMode(struct command_t *cmd, void *ctx);
// cb_DefaultRate
// file configuration.c line 188
const char * cb_DefaultRate(struct command_t *cmd, void *ctx);
// cb_DefaultSpelling
// file configuration.c line 194
const char * cb_DefaultSpelling(struct command_t *cmd, void *ctx);
// cb_DefaultVoiceType
// file configuration.c line 200
const char * cb_DefaultVoiceType(struct command_t *cmd, void *ctx);
// cb_DefaultVolume
// file configuration.c line 192
const char * cb_DefaultVolume(struct command_t *cmd, void *ctx);
// cb_DisableAutoSpawn
// file configuration.c line 379
const char * cb_DisableAutoSpawn(struct command_t *cmd, void *ctx);
// cb_EndClient
// file configuration.c line 356
const char * cb_EndClient(struct command_t *cmd, void *ctx);
// cb_LanguageDefaultModule
// file configuration.c line 219
const char * cb_LanguageDefaultModule(struct command_t *cmd, void *ctx);
// cb_LocalhostAccessOnly
// file configuration.c line 212
const char * cb_LocalhostAccessOnly(struct command_t *cmd, void *ctx);
// cb_LogDir
// file configuration.c line 249
const char * cb_LogDir(struct command_t *cmd, void *ctx);
// cb_LogFile
// file configuration.c line 237
const char * cb_LogFile(struct command_t *cmd, void *ctx);
// cb_LogLevel
// file configuration.c line 214
const char * cb_LogLevel(struct command_t *cmd, void *ctx);
// cb_MaxHistoryMessages
// file configuration.c line 216
const char * cb_MaxHistoryMessages(struct command_t *cmd, void *ctx);
// cb_Port
// file configuration.c line 211
const char * cb_Port(struct command_t *cmd, void *ctx);
// cb_SocketPath
// file configuration.c line 210
const char * cb_SocketPath(struct command_t *cmd, void *ctx);
// cb_unknown
// file configuration.c line 372
const char * cb_unknown(struct command_t *cmd, void *ctx);
// check_locked
// file speechd.c line 1240
void check_locked(union anonymous$12 *lock);
// client_has_messages
// file speaking.c line 1056
signed int client_has_messages(signed int uid);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// compare_message_fd
// file compare.c line 37
signed int compare_message_fd(const void *element, const void *value, void *x);
// compare_message_uid
// file compare.c line 51
signed int compare_message_uid(const void *element, const void *value, void *x);
// create_pid_file
// file speechd.c line 749
signed int create_pid_file(void);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// deescape_dot
// file parse.c line 1019
char * deescape_dot(const char *orig_text, unsigned long int orig_len);
// default_fd_set
// file set.h line 93
struct anonymous$11 * default_fd_set(void);
// destroy_module
// file module.c line 42
void destroy_module(struct anonymous$10 *module);
// destroy_pid_file
// file speechd.c line 808
void destroy_pid_file(void);
// detect_output_modules
// file module.h line 44
struct _GList * detect_output_modules(char *dirname);
// dotconf_cleanup
// file /usr/include/dotconf.h line 183
void dotconf_cleanup(struct configfile_t *);
// dotconf_command_loop
// file /usr/include/dotconf.h line 186
signed int dotconf_command_loop(struct configfile_t *);
// dotconf_create
// file /usr/include/dotconf.h line 179
struct configfile_t * dotconf_create(char *, const struct configoption_t *, void *, unsigned long int);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// empty_queue
// file speaking.c line 775
struct _GList * empty_queue(struct _GList *queue);
// empty_queue_by_time
// file speaking.c line 789
struct _GList * empty_queue_by_time(struct _GList *queue, unsigned int uid);
// escape_dot
// file output.c line 822
char * escape_dot(char *otext);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fatal_error
// file speechd.c line 121
void fatal_error(void);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_index_mark
// file index_marking.h line 40
char * find_index_mark(struct anonymous$7 *msg, signed int mark);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free_config_options
// file configuration.h line 38
void free_config_options(struct configoption_t *opts, signed int *num);
// g_ascii_strdown
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 190
extern char * g_ascii_strdown(const char *, signed long int);
// g_build_filename
// file /usr/include/glib-2.0/glib/gfileutils.h line 131
extern char * g_build_filename(const char *, ...);
// g_file_get_contents
// file /usr/include/glib-2.0/glib/gfileutils.h line 85
extern signed int g_file_get_contents(const char *, char **, unsigned long int *, struct _GError **);
// g_file_test
// file /usr/include/glib-2.0/glib/gfileutils.h line 82
extern signed int g_file_test(const char *, enum anonymous$15);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_get_user_config_dir
// file /usr/include/glib-2.0/glib/gutils.h line 109
extern const char * g_get_user_config_dir(void);
// g_get_user_runtime_dir
// file /usr/include/glib-2.0/glib/gutils.h line 138
extern const char * g_get_user_runtime_dir(void);
// g_hash_table_destroy
// file /usr/include/glib-2.0/glib/ghash.h line 65
extern void g_hash_table_destroy(struct _GHashTable *);
// g_hash_table_foreach_remove
// file /usr/include/glib-2.0/glib/ghash.h line 107
extern unsigned int g_hash_table_foreach_remove(struct _GHashTable *, signed int (*)(void *, void *, void *), void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new
// file /usr/include/glib-2.0/glib/ghash.h line 57
extern struct _GHashTable * g_hash_table_new(unsigned int (*)(const void *), signed int (*)(const void *, const void *));
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_remove
// file /usr/include/glib-2.0/glib/ghash.h line 78
extern signed int g_hash_table_remove(struct _GHashTable *, const void *);
// g_int_equal
// file /usr/include/glib-2.0/glib/ghash.h line 160
extern signed int g_int_equal(const void *, const void *);
// g_int_hash
// file /usr/include/glib-2.0/glib/ghash.h line 163
extern unsigned int g_int_hash(const void *);
// g_list_append
// file /usr/include/glib-2.0/glib/glist.h line 59
extern struct _GList * g_list_append(struct _GList *, void *);
// g_list_delete_link
// file /usr/include/glib-2.0/glib/glist.h line 94
extern struct _GList * g_list_delete_link(struct _GList *, struct _GList *);
// g_list_find
// file /usr/include/glib-2.0/glib/glist.h line 113
extern struct _GList * g_list_find(struct _GList *, const void *);
// g_list_find_custom
// file /usr/include/glib-2.0/glib/glist.h line 116
extern struct _GList * g_list_find_custom(struct _GList *, const void *, signed int (*)(const void *, const void *));
// g_list_first
// file /usr/include/glib-2.0/glib/glist.h line 128
extern struct _GList * g_list_first(struct _GList *);
// g_list_foreach
// file /usr/include/glib-2.0/glib/glist.h line 132
extern void g_list_foreach(struct _GList *, void (*)(void *, void *), void *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_list_free_1
// file /usr/include/glib-2.0/glib/glist.h line 53
extern void g_list_free_1(struct _GList *);
// g_list_index
// file /usr/include/glib-2.0/glib/glist.h line 123
extern signed int g_list_index(struct _GList *, const void *);
// g_list_insert
// file /usr/include/glib-2.0/glib/glist.h line 65
extern struct _GList * g_list_insert(struct _GList *, void *, signed int);
// g_list_insert_sorted
// file /usr/include/glib-2.0/glib/glist.h line 69
extern struct _GList * g_list_insert_sorted(struct _GList *, void *, signed int (*)(const void *, const void *));
// g_list_last
// file /usr/include/glib-2.0/glib/glist.h line 126
extern struct _GList * g_list_last(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_nth
// file /usr/include/glib-2.0/glib/glist.h line 107
extern struct _GList * g_list_nth(struct _GList *, unsigned int);
// g_list_nth_data
// file /usr/include/glib-2.0/glib/glist.h line 143
extern void * g_list_nth_data(struct _GList *, unsigned int);
// g_list_remove
// file /usr/include/glib-2.0/glib/glist.h line 85
extern struct _GList * g_list_remove(struct _GList *, const void *);
// g_list_remove_link
// file /usr/include/glib-2.0/glib/glist.h line 91
extern struct _GList * g_list_remove_link(struct _GList *, struct _GList *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_mkdir_with_parents
// file /usr/include/glib-2.0/glib/gfileutils.h line 137
extern signed int g_mkdir_with_parents(const char *, signed int);
// g_module_supported
// file /usr/include/glib-2.0/gmodule.h line 55
extern signed int g_module_supported(void);
// g_path_get_dirname
// file /usr/include/glib-2.0/glib/gfileutils.h line 178
extern char * g_path_get_dirname(const char *);
// g_realloc
// file /usr/include/glib-2.0/glib/gmem.h line 82
extern void * g_realloc(void *, unsigned long int);
// g_regex_match
// file /usr/include/glib-2.0/glib/gregex.h line 488
extern signed int g_regex_match(const struct _GRegex *, const char *, enum anonymous$20, struct _GMatchInfo **);
// g_regex_new
// file /usr/include/glib-2.0/glib/gregex.h line 448
extern struct _GRegex * g_regex_new(const char *, enum anonymous$19, enum anonymous$20, struct _GError **);
// g_regex_unref
// file /usr/include/glib-2.0/glib/gregex.h line 455
extern void g_regex_unref(struct _GRegex *);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_append_len
// file /usr/include/glib-2.0/glib/gstring.h line 83
extern struct _GString * g_string_append_len(struct _GString *, const char *, signed long int);
// g_string_append_printf
// file /usr/include/glib-2.0/glib/gstring.h line 149
extern void g_string_append_printf(struct _GString *, const char *, ...);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_insert_len
// file /usr/include/glib-2.0/glib/gstring.h line 75
extern struct _GString * g_string_insert_len(struct _GString *, signed long int, const char *, signed long int);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_string_printf
// file /usr/include/glib-2.0/glib/gstring.h line 140
extern void g_string_printf(struct _GString *, const char *, ...);
// g_strsplit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 270
extern char ** g_strsplit(const char *, const char *, signed int);
// g_thread_init
// file /usr/include/glib-2.0/glib/deprecated/gthread.h line 265
extern void g_thread_init(void *);
// g_unichar_isspace
// file /usr/include/glib-2.0/glib/gunicode.h line 580
extern signed int g_unichar_isspace(unsigned int);
// g_unichar_to_utf8
// file /usr/include/glib-2.0/glib/gunicode.h line 786
extern signed int g_unichar_to_utf8(unsigned int, char *);
// g_unlink
// file /usr/include/glib-2.0/glib/gstdio.h line 84
extern signed int g_unlink(const char *);
// g_utf8_find_next_char
// file /usr/include/glib-2.0/glib/gunicode.h line 710
extern char * g_utf8_find_next_char(const char *, const char *);
// g_utf8_get_char
// file /usr/include/glib-2.0/glib/gunicode.h line 696
extern unsigned int g_utf8_get_char(const char *);
// g_utf8_validate
// file /usr/include/glib-2.0/glib/gunicode.h line 790
extern signed int g_utf8_validate(const char *, signed long int, const char **);
// get_client_settings_by_fd
// file set.h line 32
struct anonymous$11 * get_client_settings_by_fd(signed int fd);
// get_client_settings_by_uid
// file set.h line 31
struct anonymous$11 * get_client_settings_by_uid(signed int uid);
// get_client_uid_by_fd
// file set.h line 34
signed int get_client_uid_by_fd(signed int fd);
// get_message_from_queues
// file speaking.c line 1014
struct anonymous$7 * get_message_from_queues();
// get_messages_by_client
// file history.c line 350
struct _GList * get_messages_by_client(signed int uid);
// get_output_module
// file output.h line 27
struct anonymous$10 * get_output_module(const struct anonymous$7 *message);
// get_output_module_by_name
// file output.c line 83
struct anonymous$10 * get_output_module_by_name(char *name);
// get_param
// file parse.c line 1084
char * get_param(const char *buf, const signed int n, const signed int bytes, const signed int lower_case);
// get_speaking_client_uid
// file speaking.c line 749
signed int get_speaking_client_uid(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// history_add_message
// file history.h line 44
signed int history_add_message(struct anonymous$7 *msg);
// history_cursor_backward
// file history.c line 262
char * history_cursor_backward(signed int fd);
// history_cursor_forward
// file history.c line 245
char * history_cursor_forward(signed int fd);
// history_cursor_get
// file history.c line 277
char * history_cursor_get(signed int fd);
// history_cursor_set_first
// file history.c line 210
char * history_cursor_set_first(signed int fd, unsigned int client_id);
// history_cursor_set_last
// file history.c line 194
char * history_cursor_set_last(signed int fd, unsigned int client_id);
// history_cursor_set_pos
// file history.c line 223
char * history_cursor_set_pos(signed int fd, unsigned int client_id, signed int pos);
// history_get_client_id
// file history.c line 74
char * history_get_client_id(signed int fd);
// history_get_client_list
// file history.c line 50
char * history_get_client_list();
// history_get_last
// file history.c line 176
char * history_get_last(signed int fd);
// history_get_message
// file history.c line 91
char * history_get_message(signed int uid);
// history_get_message_list
// file history.c line 133
char * history_get_message_list(unsigned int client_id, signed int from, signed int num);
// history_say_id
// file history.c line 300
char * history_say_id(signed int fd, signed int id);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// i18n_init
// file ../../include/i18n.h line 38
void i18n_init(void);
// insert_index_marks
// file index_marking.h line 36
void insert_index_marks(struct anonymous$7 *msg, enum anonymous$5 ssml_mode);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_sb_speaking
// file speaking.c line 661
signed int is_sb_speaking(void);
// isanum
// file parse.c line 1071
signed int isanum(const char *str);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// load_config_options
// file configuration.h line 37
struct configoption_t * load_config_options(signed int *num_options);
// load_default_global_set_options
// file configuration.h line 44
void load_default_global_set_options();
// load_output_module
// file module.c line 122
struct anonymous$10 * load_output_module(char *mod_name, char *mod_prog, char *mod_cfgfile, char *mod_dbgfile);
// logging_init
// file speechd.c line 813
void logging_init(void);
// make_inet_socket
// file speechd.c line 874
signed int make_inet_socket(const signed int port);
// make_local_socket
// file speechd.c line 844
signed int make_local_socket(const char *filename);
// mem_free_fdset
// file alloc.h line 14
void mem_free_fdset(struct anonymous$11 *fdset);
// mem_free_message
// file alloc.h line 11
void mem_free_message(struct anonymous$7 *msg);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// message_compare_id
// file history.c line 41
signed int message_compare_id(const void *element, const void *value);
// message_has_uid
// file speaking.c line 1046
signed int message_has_uid(const void *msg, const void *uid);
// message_nto_speak
// file speaking.c line 872
signed int message_nto_speak(const void *data, const void *nothing);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// module_add_load_request
// file module.h line 53
void module_add_load_request(char *module_name, char *module_cmd, char *module_cfgfile, char *module_dbgfile);
// module_already_requested
// file module.c line 455
signed int module_already_requested(char *module_name, char *module_cmd, char *module_cfgfile);
// module_load_requested_modules
// file module.h line 55
void module_load_requested_modules(void);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// options_parse
// file options.h line 28
void options_parse(signed int argc, char **argv);
// options_print_help
// file options.c line 58
void options_print_help(char **argv);
// options_print_version
// file options.c line 110
void options_print_version(void);
// output_check_module
// file output.h line 35
signed int output_check_module(struct anonymous$10 *output);
// output_close
// file output.h line 49
signed int output_close(struct anonymous$10 *module);
// output_get_voices
// file output.c line 286
static struct anonymous$6 ** output_get_voices(struct anonymous$10 *module);
// output_is_speaking
// file output.h line 32
signed int output_is_speaking(char **index_mark);
// output_list_voices
// file output.h line 50
struct anonymous$6 ** output_list_voices(char *module_name);
// output_lock
// file output.c line 162
static void output_lock(void);
// output_module_debug
// file module.h line 49
signed int output_module_debug(struct anonymous$10 *module);
// output_module_is_speaking
// file output.c line 608
signed int output_module_is_speaking(struct anonymous$10 *output, char **index_mark);
// output_module_nodebug
// file module.h line 50
signed int output_module_nodebug(struct anonymous$10 *module);
// output_pause
// file output.h line 31
unsigned long int output_pause();
// output_read_reply
// file output.c line 178
struct _GString * output_read_reply(struct anonymous$10 *output);
// output_read_reply2
// file output.c line 217
char * output_read_reply2(struct anonymous$10 *output);
// output_send_audio_settings
// file output.h line 44
signed int output_send_audio_settings(struct anonymous$10 *output);
// output_send_data
// file output.h line 42
signed int output_send_data(char *cmd, struct anonymous$10 *output, signed int wfr);
// output_send_debug
// file output.h line 33
signed int output_send_debug(struct anonymous$10 *output, signed int flag, char *log_path);
// output_send_loglevel_setting
// file output.h line 45
signed int output_send_loglevel_setting(struct anonymous$10 *output);
// output_send_settings
// file output.c line 398
signed int output_send_settings(struct anonymous$7 *msg, struct anonymous$10 *output);
// output_set_speaking_monitor
// file output.c line 74
void output_set_speaking_monitor(struct anonymous$7 *msg, struct anonymous$10 *output);
// output_speak
// file output.h line 29
signed int output_speak(struct anonymous$7 *msg);
// output_stop
// file output.h line 30
signed int output_stop();
// output_unlock
// file output.c line 168
static void output_unlock(void);
// p_msg_comp_id$object
//
signed int p_msg_comp_id$object();
// p_msg_lc$object
//
signed int p_msg_lc$object();
// p_msg_uid_lc$object
//
signed int p_msg_uid_lc$object();
// parse
// file parse.h line 5
char * parse(const char *buf, const signed int bytes, const signed int fd);
// parse_block
// file parse.c line 975
char * parse_block(const char *buf, const signed int bytes, const signed int fd, struct anonymous$0 *speechd_socket);
// parse_cancel
// file parse.c line 650
char * parse_cancel(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_char
// file parse.c line 800
char * parse_char(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_general_event
// file parse.c line 755
char * parse_general_event(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket, enum anonymous$8 type);
// parse_get
// file parse.c line 888
char * parse_get(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_help
// file parse.c line 953
char * parse_help(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_history
// file parse.c line 260
char * parse_history(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_key
// file parse.c line 806
char * parse_key(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_list
// file parse.c line 812
char * parse_list(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_pause
// file parse.c line 682
char * parse_pause(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_resume
// file parse.c line 724
char * parse_resume(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_set
// file parse.c line 388
char * parse_set(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_snd_icon
// file parse.c line 794
char * parse_snd_icon(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// parse_stop
// file parse.c line 612
char * parse_stop(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$12 *, const union anonymous$13 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$12 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$12 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$12 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$30 *, struct anonymous$30 *);
// queue_message
// file server.c line 68
signed int queue_message(struct anonymous$7 *new, signed int fd, signed int history_flag, enum anonymous$8 type, signed int reparted);
// queue_remove_message
// file speaking.c line 762
struct _GList * queue_remove_message(struct _GList *queue, struct _GList *gl);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// reload_message
// file speaking.c line 304
signed int reload_message(struct anonymous$7 *msg);
// reload_output_module
// file module.h line 48
signed int reload_output_module(struct anonymous$10 *old_module);
// remove_client_settings_by_uid
// file set.c line 556
void remove_client_settings_by_uid(signed int uid);
// report_begin
// file speaking.c line 655
signed int report_begin(struct anonymous$7 *msg);
// report_cancel
// file speaking.c line 659
signed int report_cancel(struct anonymous$7 *msg);
// report_end
// file speaking.c line 656
signed int report_end(struct anonymous$7 *msg);
// report_index_mark
// file speaking.c line 619
signed int report_index_mark(struct anonymous$7 *msg, char *index_mark);
// report_pause
// file speaking.c line 657
signed int report_pause(struct anonymous$7 *msg);
// report_resume
// file speaking.c line 658
signed int report_resume(struct anonymous$7 *msg);
// resolve_priorities
// file speaking.h line 82
void resolve_priorities(enum anonymous$9 priority);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$23 *, struct anonymous$23 *, struct anonymous$23 *, struct timeval *);
// serve
// file server.h line 29
signed int serve(signed int fd);
// server_data_off
// file server.c line 216
void server_data_off(signed int fd);
// server_data_on
// file server.c line 203
signed int server_data_on(signed int fd);
// set_capital_letter_recognition_all
// file set.h line 87
signed int set_capital_letter_recognition_all(enum anonymous$4 capital_letter_recognition);
// set_capital_letter_recognition_self
// file set.h line 68
signed int set_capital_letter_recognition_self(signed int fd, enum anonymous$4 capital_letter_recognition);
// set_capital_letter_recognition_uid
// file set.h line 48
signed int set_capital_letter_recognition_uid(signed int uid, enum anonymous$4 recogn);
// set_client_name_self
// file set.h line 64
signed int set_client_name_self(signed int fd, char *client_name);
// set_debug_all
// file set.h line 90
signed int set_debug_all(signed int debug);
// set_debug_self
// file set.h line 72
signed int set_debug_self(signed int fd, signed int debug);
// set_debug_uid
// file set.h line 52
signed int set_debug_uid(signed int uid, signed int debug);
// set_language_all
// file set.h line 76
signed int set_language_all(char *language);
// set_language_self
// file set.h line 56
signed int set_language_self(signed int fd, char *language);
// set_language_uid
// file set.h line 37
signed int set_language_uid(signed int uid, char *language);
// set_notification_self
// file set.h line 70
signed int set_notification_self(signed int fd, char *type, signed int val);
// set_output_module_all
// file set.h line 83
signed int set_output_module_all(char *output_module);
// set_output_module_self
// file set.h line 44
signed int set_output_module_self(signed int fd, char *output_module);
// set_output_module_uid
// file set.h line 49
signed int set_output_module_uid(signed int uid, char *output_module);
// set_param_str
// file set.c line 570
char * set_param_str(char *parameter, char *value);
// set_pause_context_all
// file set.h line 89
signed int set_pause_context_all(signed int pause_context);
// set_pause_context_self
// file set.h line 71
signed int set_pause_context_self(signed int fd, signed int pause_context);
// set_pause_context_uid
// file set.h line 51
signed int set_pause_context_uid(signed int uid, signed int pause_context);
// set_pitch_all
// file set.h line 78
signed int set_pitch_all(signed int pitch);
// set_pitch_self
// file set.h line 58
signed int set_pitch_self(signed int fd, signed int pitch);
// set_pitch_uid
// file set.h line 39
signed int set_pitch_uid(signed int uid, signed int pitch);
// set_priority_self
// file set.h line 55
signed int set_priority_self(signed int fd, enum anonymous$9 priority);
// set_priority_uid
// file set.c line 53
signed int set_priority_uid(signed int uid, enum anonymous$9 priority);
// set_punctuation_mode_all
// file set.h line 86
signed int set_punctuation_mode_all(enum anonymous$2 punctuation_mode);
// set_punctuation_mode_self
// file set.h line 67
signed int set_punctuation_mode_self(signed int fd, enum anonymous$2 punctuation_mode);
// set_punctuation_mode_uid
// file set.h line 47
signed int set_punctuation_mode_uid(signed int uid, enum anonymous$2 punctuation);
// set_rate_all
// file set.h line 77
signed int set_rate_all(signed int rate);
// set_rate_self
// file set.h line 57
signed int set_rate_self(signed int fd, signed int rate);
// set_rate_uid
// file set.h line 38
signed int set_rate_uid(signed int uid, signed int rate);
// set_speak_thread_attributes
// file speaking.c line 892
void set_speak_thread_attributes();
// set_spelling_all
// file set.h line 82
signed int set_spelling_all(enum anonymous$1 spelling);
// set_spelling_self
// file set.h line 62
signed int set_spelling_self(signed int fd, enum anonymous$1 spelling);
// set_spelling_uid
// file set.h line 43
signed int set_spelling_uid(signed int uid, enum anonymous$1 spelling);
// set_ssml_mode_all
// file set.h line 88
signed int set_ssml_mode_all(enum anonymous$5 ssml_mode);
// set_ssml_mode_self
// file set.h line 69
signed int set_ssml_mode_self(signed int fd, enum anonymous$5 ssml_mode);
// set_ssml_mode_uid
// file set.h line 50
signed int set_ssml_mode_uid(signed int uid, enum anonymous$5 ssml_mode);
// set_synthesis_voice_all
// file set.h line 85
signed int set_synthesis_voice_all(char *synthesis_voice);
// set_synthesis_voice_self
// file set.h line 66
signed int set_synthesis_voice_self(signed int fd, char *synthesis_voice);
// set_synthesis_voice_uid
// file set.h line 46
signed int set_synthesis_voice_uid(signed int uid, char *synthesis_voice);
// set_voice_all
// file set.h line 84
signed int set_voice_all(char *voice);
// set_voice_self
// file set.h line 65
signed int set_voice_self(signed int fd, char *voice);
// set_voice_uid
// file set.h line 45
signed int set_voice_uid(signed int uid, char *voice);
// set_volume_all
// file set.h line 79
signed int set_volume_all(signed int volume);
// set_volume_self
// file set.h line 59
signed int set_volume_self(signed int fd, signed int volume);
// set_volume_uid
// file set.h line 40
signed int set_volume_uid(signed int uid, signed int volume);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$30 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socket_send_msg
// file speaking.c line 603
signed int socket_send_msg(signed int fd, char *msg);
// sortbyuid
// file speaking.c line 1126
signed int sortbyuid(const void *a, const void *b);
// spd_fdset_copy
// file alloc.c line 8
struct anonymous$11 spd_fdset_copy(struct anonymous$11 old);
// spd_get_path
// file speechd.c line 102
char * spd_get_path(char *filename, char *startdir);
// spd_getline
// file ../../include/spd_utils.h line 29
signed long int spd_getline(char **lineptr, unsigned long int *n, struct _IO_FILE *f);
// spd_message_copy
// file alloc.h line 8
struct anonymous$7 * spd_message_copy(struct anonymous$7 *old);
// spd_str_compare
// file set.c line 35
signed int spd_str_compare(const void *a, const void *b);
// spd_utf8_read_char
// file parse.c line 1138
signed int spd_utf8_read_char(char *pointer, char *character);
// speak
// file speaking.h line 45
void * speak(void *data);
// speaking_cancel
// file speaking.h line 54
void speaking_cancel(signed int uid);
// speaking_cancel_all
// file speaking.h line 55
void speaking_cancel_all();
// speaking_get_queue
// file speaking.c line 1074
struct _GList * speaking_get_queue(enum anonymous$9 priority);
// speaking_pause
// file speaking.c line 522
signed int speaking_pause(signed int fd, signed int uid);
// speaking_pause_all
// file speaking.c line 503
signed int speaking_pause_all(signed int fd);
// speaking_resume
// file speaking.h line 60
signed int speaking_resume(signed int uid);
// speaking_resume_all
// file speaking.h line 61
signed int speaking_resume_all();
// speaking_semaphore_post
// file sem_functions.h line 24
void speaking_semaphore_post(void);
// speaking_set_queue
// file speaking.c line 1102
void speaking_set_queue(enum anonymous$9 priority, struct _GList *queue);
// speaking_stop
// file speaking.h line 51
void speaking_stop(signed int uid);
// speaking_stop_all
// file speaking.h line 52
void speaking_stop_all();
// speechd_client_terminate
// file speechd.c line 425
signed int speechd_client_terminate(void *key, void *value, void *user);
// speechd_connection_destroy
// file speechd.c line 385
signed int speechd_connection_destroy(signed int fd);
// speechd_connection_new
// file speechd.c line 333
signed int speechd_connection_new(signed int server_socket);
// speechd_init
// file speechd.c line 550
void speechd_init(void);
// speechd_load_configuration
// file speechd.c line 646
void speechd_load_configuration(signed int sig);
// speechd_module_debug
// file speechd.c line 477
void speechd_module_debug(void *data, void *user_data);
// speechd_module_nodebug
// file speechd.c line 492
void speechd_module_nodebug(void *data, void *user_data);
// speechd_modules_debug
// file speechd.c line 516
void speechd_modules_debug(void);
// speechd_modules_nodebug
// file speechd.c line 523
void speechd_modules_nodebug(void);
// speechd_modules_reload
// file speechd.c line 462
void speechd_modules_reload(void *data, void *user_data);
// speechd_modules_terminate
// file speechd.c line 448
void speechd_modules_terminate(void *data, void *user_data);
// speechd_options_init
// file speechd.c line 531
void speechd_options_init(void);
// speechd_quit
// file speechd.c line 706
void speechd_quit(signed int sig);
// speechd_reload_dead_modules
// file speechd.c line 507
void speechd_reload_dead_modules(signed int sig);
// speechd_socket_free
// file speechd.c line 313
void speechd_socket_free(struct anonymous$0 *speechd_socket);
// speechd_socket_get_by_fd
// file speechd.c line 327
struct anonymous$0 * speechd_socket_get_by_fd(signed int fd);
// speechd_socket_register
// file speechd.c line 297
signed int speechd_socket_register(signed int fd);
// speechd_socket_unregister
// file speechd.c line 321
signed int speechd_socket_unregister(signed int fd);
// speechd_sockets_status_init
// file speechd.c line 284
signed int speechd_sockets_status_init(void);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stop_from_uid
// file speaking.c line 857
void stop_from_uid(const signed int uid);
// stop_priority
// file speaking.c line 812
signed int stop_priority(enum anonymous$9 priority);
// stop_priority_except_first
// file speaking.c line 912
void stop_priority_except_first(enum anonymous$9 priority);
// stop_priority_from_uid
// file speaking.c line 846
struct _GList * stop_priority_from_uid(struct _GList *queue, const signed int uid);
// stop_priority_older_than
// file speaking.c line 829
signed int stop_priority_older_than(enum anonymous$9 priority, unsigned int uid);
// str2ECapLetRecogn
// file ../../include/fdsetconv.h line 22
enum anonymous$4 str2ECapLetRecogn(char *str);
// str2EPunctMode
// file ../../include/fdsetconv.h line 14
enum anonymous$2 str2EPunctMode(char *str);
// str2ESpellMode
// file fdsetconv.c line 149
enum anonymous$1 str2ESpellMode(char *str);
// str2EVoice
// file ../../include/fdsetconv.h line 10
enum anonymous$27 str2EVoice(char *str);
// str2intpriority
// file ../../include/fdsetconv.h line 24
enum anonymous$9 str2intpriority(char *str);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strip_index_marks
// file index_marking.h line 44
char * strip_index_marks(char *buf, enum anonymous$5 ssml_mode);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 183
extern char * strndup(const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// ungetc
// file /usr/include/stdio.h line 702
extern signed int ungetc(signed int, struct _IO_FILE *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unload_output_module
// file module.h line 47
signed int unload_output_module(struct anonymous$10 *module);
// update_cl_settings
// file set.c line 275
void update_cl_settings(void *data, void *user_data);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// waitpid_with_timeout
// file output.c line 718
signed int waitpid_with_timeout(signed int pid, signed int *status_ptr, signed int options, unsigned long int timeout);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$24
{
  // communication_method
  char *communication_method;
  // communication_method_set
  signed int communication_method_set;
  // socket_path
  char *socket_path;
  // socket_path_set
  signed int socket_path_set;
  // port
  signed int port;
  // port_set
  signed int port_set;
  // localhost_access_only
  signed int localhost_access_only;
  // localhost_access_only_set
  signed int localhost_access_only_set;
  // log_level
  signed int log_level;
  // log_level_set
  signed int log_level_set;
  // pid_file
  char *pid_file;
  // conf_file
  char *conf_file;
  // conf_dir
  char *conf_dir;
  // runtime_speechd_dir
  char *runtime_speechd_dir;
  // log_dir
  char *log_dir;
  // log_dir_set
  signed int log_dir_set;
  // spawn
  signed int spawn;
  // debug
  signed int debug;
  // debug_destination
  char *debug_destination;
  // debug_logfile
  char *debug_logfile;
  // max_history_messages
  signed int max_history_messages;
};

struct anonymous$10
{
  // name
  char *name;
  // filename
  char *filename;
  // configfilename
  char *configfilename;
  // debugfilename
  char *debugfilename;
  // pipe_in
  signed int pipe_in[2l];
  // pipe_out
  signed int pipe_out[2l];
  // stream_out
  struct _IO_FILE *stream_out;
  // stderr_redirect
  signed int stderr_redirect;
  // pid
  signed int pid;
  // working
  signed int working;
};

struct anonymous$6
{
  // name
  char *name;
  // language
  char *language;
  // variant
  char *variant;
};

struct anonymous$16
{
  // rate
  signed int rate;
  // pitch
  signed int pitch;
  // volume
  signed int volume;
  // punctuation_mode
  enum anonymous$2 punctuation_mode;
  // spelling_mode
  enum anonymous$1 spelling_mode;
  // cap_let_recogn
  enum anonymous$4 cap_let_recogn;
  // voice_type
  enum anonymous$27 voice_type;
  // voice
  struct anonymous$6 voice;
};

struct anonymous$11
{
  // uid
  unsigned int uid;
  // fd
  signed int fd;
  // active
  signed int active;
  // paused
  signed int paused;
  // paused_while_speaking
  signed int paused_while_speaking;
  // type
  enum anonymous$8 type;
  // ssml_mode
  enum anonymous$5 ssml_mode;
  // priority
  enum anonymous$9 priority;
  // msg_settings
  struct anonymous$16 msg_settings;
  // client_name
  char *client_name;
  // output_module
  char *output_module;
  // notification
  enum anonymous$17 notification;
  // reparted
  signed int reparted;
  // min_delay_progress
  unsigned int min_delay_progress;
  // pause_context
  signed int pause_context;
  // index_mark
  char *index_mark;
  // audio_output_method
  char *audio_output_method;
  // audio_oss_device
  char *audio_oss_device;
  // audio_alsa_device
  char *audio_alsa_device;
  // audio_nas_server
  char *audio_nas_server;
  // audio_pulse_server
  char *audio_pulse_server;
  // audio_pulse_min_length
  signed int audio_pulse_min_length;
  // log_level
  signed int log_level;
  // hist_cur_uid
  unsigned int hist_cur_uid;
  // hist_cur_pos
  signed int hist_cur_pos;
  // hist_sorted
  enum anonymous$18 hist_sorted;
};

struct anonymous$26
{
  // pattern
  char *pattern;
  // val
  struct anonymous$11 val;
};

struct anonymous$29
{
  // p1
  struct _GList *p1;
  // p2
  struct _GList *p2;
  // p3
  struct _GList *p3;
  // p4
  struct _GList *p4;
  // p5
  struct _GList *p5;
};

struct anonymous$23
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$30
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$0
{
  // awaiting_data
  signed int awaiting_data;
  // inside_block
  signed int inside_block;
  // o_bytes
  unsigned long int o_bytes;
  // o_buf
  struct _GString *o_buf;
};

struct anonymous$28
{
  // max_uid
  signed int max_uid;
  // max_gid
  signed int max_gid;
  // max_fd
  signed int max_fd;
};

struct anonymous$14
{
  // value
  signed long int value;
  // str
  char *str;
  // list
  char **list;
  // dvalue
  double dvalue;
};

struct anonymous$7
{
  // id
  unsigned int id;
  // time
  signed long int time;
  // buf
  char *buf;
  // bytes
  signed int bytes;
  // settings
  struct anonymous$11 settings;
};

union anonymous$22
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$13
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$12
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$21
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$3
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct command_t
{
  // name
  const char *name;
  // option
  struct configoption_t *option;
  // configfile
  struct configfile_t *configfile;
  // context
  void *context;
  // arg_count
  signed int arg_count;
  // data
  struct anonymous$14 data;
};

struct configfile_t
{
  // stream
  struct _IO_FILE *stream;
  // eof
  char eof;
  // size
  unsigned long int size;
  // context
  void *context;
  // config_options
  const struct configoption_t **config_options;
  // config_option_count
  signed int config_option_count;
  // filename
  char *filename;
  // line
  unsigned long int line;
  // flags
  unsigned long int flags;
  // includepath
  char *includepath;
  // errorhandler
  signed int (*errorhandler)(struct configfile_t *, signed int, unsigned long int, const char *);
  // contextchecker
  const char * (*contextchecker)(struct command_t *, unsigned long int);
  // cmp_func
  signed int (*cmp_func)(const char *, const char *, unsigned long int);
};

struct configoption_t
{
  // name
  const char *name;
  // type
  signed int type;
  // callback
  const char * (*callback)(struct command_t *, void *);
  // info
  void *info;
  // context
  unsigned long int context;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct in6_addr
{
  // __in6_u
  union anonymous$22 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// GlobalFDSet
// file speechd.h line 211
struct anonymous$11 GlobalFDSet;
// MessagePausedList
// file speechd.h line 202
struct _GList *MessagePausedList;
// MessageQueue
// file speechd.h line 200
struct anonymous$29 *MessageQueue;
// SPEAKING
// file speaking.c line 46
signed int SPEAKING = 0;
// SpeechdOptions
// file speechd.h line 169
struct anonymous$24 SpeechdOptions;
// SpeechdStatus
// file speechd.h line 175
struct anonymous$28 SpeechdStatus;
// cl_spec_section
// file configuration.c line 37
static struct anonymous$26 *cl_spec_section;
// client_specific_settings
// file speechd.h line 205
struct _GList *client_specific_settings;
// current_message
// file speaking.c line 43
struct anonymous$7 *current_message = (struct anonymous$7 *)(void *)0;
// custom_log_kind
// file speechd.h line 243
char *custom_log_kind;
// custom_logfile
// file speechd.h line 242
struct _IO_FILE *custom_logfile;
// debug_logfile
// file speechd.h line 244
struct _IO_FILE *debug_logfile;
// element_free_mutex
// file speechd.h line 180
union anonymous$12 element_free_mutex;
// fd_settings
// file speechd.h line 193
struct _GHashTable *fd_settings;
// fd_uid
// file speechd.h line 197
struct _GHashTable *fd_uid;
// highest_priority
// file speaking.c line 44
static enum anonymous$9 highest_priority = (enum anonymous$9)0;
// language_default_modules
// file speechd.h line 195
struct _GHashTable *language_default_modules;
// last_message_id
// file server.c line 35
signed int last_message_id = 0;
// last_p5_block
// file speechd.h line 208
struct _GList *last_p5_block;
// logfile
// file speechd.h line 241
struct _IO_FILE *logfile;
// logging_mutex
// file speechd.h line 179
union anonymous$12 logging_mutex;
// message_history
// file history.c line 37
static struct _GList *message_history;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// output_layer_mutex
// file speechd.h line 181
union anonymous$12 output_layer_mutex;
// output_modules
// file speechd.c line 52
struct _GList *output_modules;
// p_msg_comp_id
// file history.c line 48
signed int (*p_msg_comp_id)();
// p_msg_comp_id
// file history.c line 48
signed int (*p_msg_comp_id)() = (signed int (*)())message_compare_id;
// p_msg_lc
// file compare.h line 33
signed int (*p_msg_lc)();
// p_msg_lc
// file compare.h line 33
signed int (*p_msg_lc)() = (signed int (*)())compare_message_fd;
// p_msg_uid_lc
// file compare.h line 34
signed int (*p_msg_uid_lc)();
// p_msg_uid_lc
// file compare.h line 34
signed int (*p_msg_uid_lc)() = (signed int (*)())compare_message_uid;
// pause_requested
// file speaking.h line 36
signed int pause_requested;
// pause_requested_fd
// file speaking.h line 37
signed int pause_requested_fd;
// pause_requested_uid
// file speaking.h line 38
signed int pause_requested_uid;
// poll_count
// file speaking.c line 47
signed int poll_count;
// readfds
// file speechd.h line 214
struct anonymous$23 readfds;
// requested_modules
// file module.c line 427
static struct _GList *requested_modules = (struct _GList *)(void *)0;
// resume_requested
// file speaking.h line 39
signed int resume_requested;
// server_socket
// file speechd.c line 59
signed int server_socket;
// socket_com_mutex
// file speechd.h line 182
union anonymous$12 socket_com_mutex;
// spd_long_options
// file options.c line 39
static struct option spd_long_options[14l] = { { .name="run-daemon", .has_arg=0, .flag=((signed int *)NULL), .val=100 },
    { .name="run-single", .has_arg=0, .flag=((signed int *)NULL), .val=115 },
    { .name="spawn", .has_arg=0, .flag=((signed int *)NULL), .val=97 },
    { .name="log-level", .has_arg=1, .flag=((signed int *)NULL), .val=108 },
    { .name="log-dir", .has_arg=1, .flag=((signed int *)NULL), .val=76 },
    { .name="communication-method", .has_arg=1, .flag=((signed int *)NULL),
    .val=99 },
    { .name="socket-path", .has_arg=1, .flag=((signed int *)NULL), .val=83 },
    { .name="port", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="pid-file", .has_arg=1, .flag=((signed int *)NULL), .val=80 },
    { .name="config-dir", .has_arg=1, .flag=((signed int *)NULL), .val=67 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="debug", .has_arg=0, .flag=((signed int *)NULL), .val=68 },
    { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// spd_mode
// file speechd.h line 125
enum anonymous$25 spd_mode;
// spd_num_options
// file configuration.h line 35
signed int spd_num_options;
// spd_options
// file configuration.h line 34
struct configoption_t *spd_options;
// spd_short_options
// file options.c line 56
static const char * const spd_short_options = "dsal:L:c:S:p:P:C:vDh";
// speak_thread
// file speechd.h line 178
unsigned long int speak_thread;
// speaking_gid
// file speaking.h line 33
signed int speaking_gid;
// speaking_module
// file speaking.h line 31
struct anonymous$10 *speaking_module;
// speaking_pipe
// file speechd.h line 217
signed int speaking_pipe[2l];
// speaking_sem_id
// file speechd.h line 187
signed int speaking_sem_id;
// speaking_sem_key
// file speechd.h line 186
signed int speaking_sem_key;
// speaking_uid
// file speaking.h line 32
signed int speaking_uid;
// speechd_sockets_status
// file speechd.h line 220
struct _GHashTable *speechd_sockets_status;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// ECapLetRecogn2str
// file ../../include/fdsetconv.h line 20
char * ECapLetRecogn2str(enum anonymous$4 recogn)
{
  char *str;
  switch((signed int)recogn)
  {
    case SPD_CAP_NONE:
    {
      str=g_strdup("none");
      break;
    }
    case SPD_CAP_SPELL:
    {
      str=g_strdup("spell");
      break;
    }
    case SPD_CAP_ICON:
    {
      str=g_strdup("icon");
      break;
    }
    default:
      str = (char *)(void *)0;
  }
  return str;
}

// EPunctMode2str
// file ../../include/fdsetconv.h line 12
char * EPunctMode2str(enum anonymous$2 punct)
{
  char *str;
  switch((signed int)punct)
  {
    case SPD_PUNCT_NONE:
    {
      str=g_strdup("none");
      break;
    }
    case SPD_PUNCT_ALL:
    {
      str=g_strdup("all");
      break;
    }
    case SPD_PUNCT_SOME:
    {
      str=g_strdup("some");
      break;
    }
    default:
      str = (char *)(void *)0;
  }
  return str;
}

// ESpellMode2str
// file ../../include/fdsetconv.h line 16
char * ESpellMode2str(enum anonymous$1 spell)
{
  char *str;
  switch((signed int)spell)
  {
    case SPD_SPELL_ON:
    {
      str=g_strdup("on");
      break;
    }
    case SPD_SPELL_OFF:
    {
      str=g_strdup("off");
      break;
    }
    default:
      str = (char *)(void *)0;
  }
  return str;
}

// EVoice2str
// file ../../include/fdsetconv.h line 8
char * EVoice2str(enum anonymous$27 voice)
{
  char *str;
  switch((signed int)voice)
  {
    case SPD_MALE1:
    {
      str=g_strdup("male1");
      break;
    }
    case SPD_MALE2:
    {
      str=g_strdup("male2");
      break;
    }
    case SPD_MALE3:
    {
      str=g_strdup("male3");
      break;
    }
    case SPD_FEMALE1:
    {
      str=g_strdup("female1");
      break;
    }
    case SPD_FEMALE2:
    {
      str=g_strdup("female2");
      break;
    }
    case SPD_FEMALE3:
    {
      str=g_strdup("female3");
      break;
    }
    case SPD_CHILD_MALE:
    {
      str=g_strdup("child_male");
      break;
    }
    case SPD_CHILD_FEMALE:
    {
      str=g_strdup("child_female");
      break;
    }
    default:
      str = (char *)(void *)0;
  }
  return str;
}

// MSG
// file speechd.c line 214
void MSG(signed int level, char *format, ...)
{
  if(SpeechdOptions.log_level >= level || !(SpeechdOptions.debug == 0))
  {
    void **args;
    signed int i;
    pthread_mutex_lock(&logging_mutex);
    signed long int t;
    char *tstr;
    struct timeval tv;
    t=time((signed long int *)(void *)0);
    char *return_value_ctime$1;
    return_value_ctime$1=ctime(&t);
    tstr=g_strdup(return_value_ctime$1);
    gettimeofday(&tv, (struct timezone *)(void *)0);
    /* assertion tstr */
    assert(tstr != ((char *)NULL));
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(tstr);
    /* assertion strlen(tstr) > 1 */
    assert(return_value_strlen$2 > (unsigned long int)1);
    /* assertion (level >= -1) && (level <= 5) */
    assert(level >= -1 && level <= 5);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(tstr);
    tstr[(signed long int)(return_value_strlen$3 - (unsigned long int)1)] = (char)0;
    if(SpeechdOptions.log_level >= level)
      fprintf(logfile, "[%s : %d] speechd: ", tstr, (signed int)tv.tv_usec);

    if(!(SpeechdOptions.debug == 0))
      fprintf(debug_logfile, "[%s : %d] speechd: ", tstr, (signed int)tv.tv_usec);

    g_free((void *)tstr);
    i = 1;
    for( ; !(i >= level); i = i + 1)
      fprintf(logfile, " ");
    if(SpeechdOptions.log_level >= level)
    {
      args = (void **)&format;
      vfprintf(logfile, format, args);
      args = ((void **)NULL);
      fprintf(logfile, "\n");
      fflush(logfile);
    }

    if(!(SpeechdOptions.debug == 0))
    {
      args = (void **)&format;
      vfprintf(debug_logfile, format, args);
      args = ((void **)NULL);
      fprintf(debug_logfile, "\n");
      fflush(debug_logfile);
    }

    if(level == -1)
    {
      args = (void **)&format;
      vfprintf(stderr, format, args);
      args = ((void **)NULL);
      fprintf(stderr, "\n");
      fflush(stderr);
    }

    pthread_mutex_unlock(&logging_mutex);
  }

}

// MSG2
// file speechd.c line 129
void MSG2(signed int level, char *kind, char *format, ...)
{
  signed int std_log = (signed int)(level <= SpeechdOptions.log_level);
  signed int custom_log;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(!(kind == ((char *)NULL)) && !(custom_log_kind == ((char *)NULL)))
  {
    return_value_strcmp$1=strcmp(kind, custom_log_kind);
    tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  custom_log = (signed int)(tmp_if_expr$2 ? (custom_logfile != (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0) : (_Bool)0);
  if(!(custom_log == 0) || !(std_log == 0))
  {
    void **args;
    signed int i;
    pthread_mutex_lock(&logging_mutex);
    signed long int t;
    char *tstr;
    struct timeval tv;
    t=time((signed long int *)(void *)0);
    char *return_value_ctime$3;
    return_value_ctime$3=ctime(&t);
    tstr=g_strdup(return_value_ctime$3);
    gettimeofday(&tv, (struct timezone *)(void *)0);
    /* assertion tstr */
    assert(tstr != ((char *)NULL));
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(tstr);
    /* assertion strlen(tstr) > 1 */
    assert(return_value_strlen$4 > (unsigned long int)1);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(tstr);
    tstr[(signed long int)(return_value_strlen$5 - (unsigned long int)1)] = (char)0;
    if(!(std_log == 0))
      fprintf(logfile, "[%s : %d] speechd: ", tstr, (signed int)tv.tv_usec);

    if(!(custom_log == 0))
      fprintf(custom_logfile, "[%s : %d] speechd: ", tstr, (signed int)tv.tv_usec);

    if(!(SpeechdOptions.debug == 0))
      fprintf(debug_logfile, "[%s : %d] speechd: ", tstr, (signed int)tv.tv_usec);

    g_free((void *)tstr);
    i = 1;
    for( ; !(i >= level); i = i + 1)
    {
      if(!(std_log == 0))
        fprintf(logfile, " ");

      if(!(custom_log == 0))
        fprintf(custom_logfile, " ");

    }
    if(!(std_log == 0))
    {
      args = (void **)&format;
      vfprintf(logfile, format, args);
      args = ((void **)NULL);
      fprintf(logfile, "\n");
      fflush(logfile);
    }

    if(!(custom_log == 0))
    {
      args = (void **)&format;
      vfprintf(custom_logfile, format, args);
      args = ((void **)NULL);
      fprintf(custom_logfile, "\n");
      fflush(custom_logfile);
    }

    if(!(SpeechdOptions.debug == 0))
    {
      args = (void **)&format;
      vfprintf(debug_logfile, format, args);
      args = ((void **)NULL);
      fprintf(debug_logfile, "\n");
      fflush(debug_logfile);
    }

    pthread_mutex_unlock(&logging_mutex);
  }

}

// add_config_option
// file configuration.h line 39
struct configoption_t * add_config_option(struct configoption_t *options, signed int *num_config_options, char *name, signed int type, const char * (*callback)(struct command_t *, void *), void *info, unsigned long int context)
{
  struct configoption_t *opts;
  *num_config_options = *num_config_options + 1;
  void *return_value_g_realloc$1;
  return_value_g_realloc$1=g_realloc((void *)options, (unsigned long int)*num_config_options * sizeof(struct configoption_t) /*40ul*/ );
  opts = (struct configoption_t *)return_value_g_realloc$1;
  (opts + (signed long int)(*num_config_options - 1))->name=g_strdup(name);
  (opts + (signed long int)(*num_config_options - 1))->type = type;
  (opts + (signed long int)(*num_config_options - 1))->callback = callback;
  (opts + (signed long int)(*num_config_options - 1))->info = info;
  (opts + (signed long int)(*num_config_options - 1))->context = context;
  return opts;
}

// cb_AddModule
// file configuration.c line 296
const char * cb_AddModule(struct command_t *cmd, void *ctx)
{
  if(*cmd->data.list == ((char *)NULL))
  {
    MSG(3, "No output module name specified in configuration under AddModule");
    return (const char *)(void *)0;
  }

  else
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup(cmd->data.list[(signed long int)0]);
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup(cmd->data.list[(signed long int)1]);
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup(cmd->data.list[(signed long int)2]);
    char *return_value_g_strdup_printf$4;
    return_value_g_strdup_printf$4=g_strdup_printf("%s/%s.log", SpeechdOptions.log_dir, cmd->data.list[(signed long int)0]);
    module_add_load_request(return_value_g_strdup$1, return_value_g_strdup$2, return_value_g_strdup$3, return_value_g_strdup_printf$4);
    return (const char *)(void *)0;
  }
}

// cb_AudioALSADevice
// file configuration.c line 183
const char * cb_AudioALSADevice(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_alsa_device=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.audio_alsa_device=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_AudioNASServer
// file configuration.c line 184
const char * cb_AudioNASServer(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_nas_server=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.audio_nas_server=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_AudioOSSDevice
// file configuration.c line 182
const char * cb_AudioOSSDevice(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_oss_device=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.audio_oss_device=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_AudioOutputMethod
// file configuration.c line 181
const char * cb_AudioOutputMethod(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_output_method=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.audio_output_method=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_AudioPulseMinLength
// file configuration.c line 186
const char * cb_AudioPulseMinLength(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_pulse_min_length = val;

  else
    cl_spec_section->val.audio_pulse_min_length = val;
  return (const char *)(void *)0;
}

// cb_AudioPulseServer
// file configuration.c line 185
const char * cb_AudioPulseServer(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.audio_pulse_server=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.audio_pulse_server=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_BeginClient
// file configuration.c line 318
const char * cb_BeginClient(struct command_t *cmd, void *ctx)
{
  struct anonymous$26 *cl_spec;
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Configuration: Already in client specific section, can't open a new one!", (const void *)"configuration.c", 324);
    exit(1);
  }

  if(cmd->data.str == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Configuration: You must specify some client's name for BeginClient", (const void *)"configuration.c", 328);
    exit(1);
  }

  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$26) /*200ul*/ );
  cl_spec = (struct anonymous$26 *)return_value_g_malloc$1;
  cl_spec->pattern=g_strdup(cmd->data.str);
  cl_spec_section = cl_spec;
  MSG(4, "Reading configuration for pattern %s", cl_spec->pattern);
  cl_spec->val.msg_settings.rate = -101;
  cl_spec->val.msg_settings.pitch = -101;
  cl_spec->val.msg_settings.volume = -101;
  cl_spec->val.msg_settings.punctuation_mode = (enum anonymous$2)-1;
  cl_spec->val.msg_settings.spelling_mode = (enum anonymous$1)-1;
  cl_spec->val.msg_settings.voice_type = (enum anonymous$27)-1;
  cl_spec->val.msg_settings.cap_let_recogn = (enum anonymous$4)-1;
  cl_spec->val.pause_context = -1;
  cl_spec->val.ssml_mode = (enum anonymous$5)-1;
  cl_spec->val.msg_settings.voice.language = (char *)(void *)0;
  cl_spec->val.output_module = (char *)(void *)0;
  return (const char *)(void *)0;
}

// cb_CommunicationMethod
// file configuration.c line 209
const char * cb_CommunicationMethod(struct command_t *cmd, void *ctx)
{
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 209);
    exit(1);
  }

  if(SpeechdOptions.communication_method_set == 0)
    SpeechdOptions.communication_method=g_strdup(cmd->data.str);

  return (const char *)(void *)0;
}

// cb_CustomLogFile
// file configuration.c line 262
const char * cb_CustomLogFile(struct command_t *cmd, void *ctx)
{
  char *kind;
  char *file;
  if(*cmd->data.list == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:No log kind specified in CustomLogFile", (const void *)"configuration.c", 268);
    exit(1);
  }

  if(cmd->data.list[1l] == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:No log file specified in CustomLogFile", (const void *)"configuration.c", 270);
    exit(1);
  }

  kind=g_strdup(cmd->data.list[(signed long int)0]);
  /* assertion kind != ((void *)0) */
  assert(kind != (char *)(void *)0);
  file=g_strdup(cmd->data.list[(signed long int)1]);
  /* assertion file != ((void *)0) */
  assert(file != (char *)(void *)0);
  custom_log_kind = kind;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(file, "stdout", (unsigned long int)6);
  if(return_value_strncmp$1 == 0)
  {
    custom_logfile = stdout;
    return (const char *)(void *)0;
  }

  else
  {
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(file, "stderr", (unsigned long int)6);
    if(return_value_strncmp$2 == 0)
    {
      custom_logfile = stderr;
      return (const char *)(void *)0;
    }

    else
    {
      custom_logfile=fopen(file, "a");
      if(custom_logfile == ((struct _IO_FILE *)NULL))
      {
        fprintf(stderr, "Error: can't open custom log file, using stdout\n");
        custom_logfile = stdout;
      }

      MSG(2, "Speech Dispatcher custom logging to file %s", file);
      return (const char *)(void *)0;
    }
  }
}

// cb_DefaultCapLetRecognition
// file configuration.c line 205
const char * cb_DefaultCapLetRecognition(struct command_t *cmd, void *ctx)
{
  char *val_str;
  enum anonymous$4 val;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cmd->data.str);
  val_str=g_ascii_strdown(cmd->data.str, (signed long int)return_value_strlen$1);
  if(val_str == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration", (const void *)"configuration.c", 207);
    exit(1);
  }

  val=str2ECapLetRecogn(val_str);
  g_free((void *)val_str);
  if((signed int)val == -1)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration.", (const void *)"configuration.c", 207);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.cap_let_recogn = val;

  else
    cl_spec_section->val.msg_settings.cap_let_recogn = val;
  return (const char *)(void *)0;
}

// cb_DefaultClientName
// file configuration.c line 179
const char * cb_DefaultClientName(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.client_name=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.client_name=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_DefaultLanguage
// file configuration.c line 178
const char * cb_DefaultLanguage(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.voice.language=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.msg_settings.voice.language=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_DefaultModule
// file configuration.c line 177
const char * cb_DefaultModule(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.output_module=g_strdup(cmd->data.str);

  else
    cl_spec_section->val.output_module=g_strdup(cmd->data.str);
  return (const char *)(void *)0;
}

// cb_DefaultPauseContext
// file configuration.c line 196
const char * cb_DefaultPauseContext(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.pause_context = val;

  else
    cl_spec_section->val.pause_context = val;
  return (const char *)(void *)0;
}

// cb_DefaultPitch
// file configuration.c line 190
const char * cb_DefaultPitch(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(val >= -100) || val >= 101)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Pitch out of range.", (const void *)"configuration.c", 191);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.pitch = val;

  else
    cl_spec_section->val.msg_settings.pitch = val;
  return (const char *)(void *)0;
}

// cb_DefaultPriority
// file configuration.c line 198
const char * cb_DefaultPriority(struct command_t *cmd, void *ctx)
{
  char *val_str;
  enum anonymous$9 val;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cmd->data.str);
  val_str=g_ascii_strdown(cmd->data.str, (signed long int)return_value_strlen$1);
  if(val_str == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration", (const void *)"configuration.c", 199);
    exit(1);
  }

  val=str2intpriority(val_str);
  g_free((void *)val_str);
  if((signed int)val == -1)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration.", (const void *)"configuration.c", 199);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.priority = val;

  else
    cl_spec_section->val.priority = val;
  return (const char *)(void *)0;
}

// cb_DefaultPunctuationMode
// file configuration.c line 202
const char * cb_DefaultPunctuationMode(struct command_t *cmd, void *ctx)
{
  char *val_str;
  enum anonymous$2 val;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cmd->data.str);
  val_str=g_ascii_strdown(cmd->data.str, (signed long int)return_value_strlen$1);
  if(val_str == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration", (const void *)"configuration.c", 204);
    exit(1);
  }

  val=str2EPunctMode(val_str);
  g_free((void *)val_str);
  if((signed int)val == -1)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration.", (const void *)"configuration.c", 204);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.punctuation_mode = val;

  else
    cl_spec_section->val.msg_settings.punctuation_mode = val;
  return (const char *)(void *)0;
}

// cb_DefaultRate
// file configuration.c line 188
const char * cb_DefaultRate(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(val >= -100) || val >= 101)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Rate out of range.", (const void *)"configuration.c", 189);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.rate = val;

  else
    cl_spec_section->val.msg_settings.rate = val;
  return (const char *)(void *)0;
}

// cb_DefaultSpelling
// file configuration.c line 194
const char * cb_DefaultSpelling(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.spelling_mode = (enum anonymous$1)val;

  else
    cl_spec_section->val.msg_settings.spelling_mode = (enum anonymous$1)val;
  return (const char *)(void *)0;
}

// cb_DefaultVoiceType
// file configuration.c line 200
const char * cb_DefaultVoiceType(struct command_t *cmd, void *ctx)
{
  char *val_str;
  enum anonymous$27 val;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cmd->data.str);
  val_str=g_ascii_strdown(cmd->data.str, (signed long int)return_value_strlen$1);
  if(val_str == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration", (const void *)"configuration.c", 201);
    exit(1);
  }

  val=str2EVoice(val_str);
  g_free((void *)val_str);
  if((signed int)val == -1)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter in configuration.", (const void *)"configuration.c", 201);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.voice_type = val;

  else
    cl_spec_section->val.msg_settings.voice_type = val;
  return (const char *)(void *)0;
}

// cb_DefaultVolume
// file configuration.c line 192
const char * cb_DefaultVolume(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(val >= -100) || val >= 101)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Volume out of range.", (const void *)"configuration.c", 193);
    exit(1);
  }

  if(cl_spec_section == ((struct anonymous$26 *)NULL))
    GlobalFDSet.msg_settings.volume = val;

  else
    cl_spec_section->val.msg_settings.volume = val;
  return (const char *)(void *)0;
}

// cb_DisableAutoSpawn
// file configuration.c line 379
const char * cb_DisableAutoSpawn(struct command_t *cmd, void *ctx)
{
  return (const char *)(void *)0;
}

// cb_EndClient
// file configuration.c line 356
const char * cb_EndClient(struct command_t *cmd, void *ctx)
{
  if(cl_spec_section == ((struct anonymous$26 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Configuration: Already outside the client specific section!", (const void *)"configuration.c", 360);
    exit(1);
  }

  client_specific_settings=g_list_append(client_specific_settings, (void *)cl_spec_section);
  cl_spec_section = (struct anonymous$26 *)(void *)0;
  return (const char *)(void *)0;
}

// cb_LanguageDefaultModule
// file configuration.c line 219
const char * cb_LanguageDefaultModule(struct command_t *cmd, void *ctx)
{
  char *key;
  char *value;
  if(*cmd->data.list == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:No language specified for LanguageDefaultModule", (const void *)"configuration.c", 225);
    exit(1);
  }

  if(*cmd->data.list == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:No module specified for LanguageDefaultModule", (const void *)"configuration.c", 227);
    exit(1);
  }

  key=g_strdup(cmd->data.list[(signed long int)0]);
  value=g_strdup(cmd->data.list[(signed long int)1]);
  g_hash_table_insert(language_default_modules, (void *)key, (void *)value);
  return (const char *)(void *)0;
}

// cb_LocalhostAccessOnly
// file configuration.c line 212
const char * cb_LocalhostAccessOnly(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 213);
    exit(1);
  }

  if(!(val >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid access controll mode!", (const void *)"configuration.c", 213);
    exit(1);
  }

  if(SpeechdOptions.localhost_access_only_set == 0)
    SpeechdOptions.localhost_access_only = val;

  return (const char *)(void *)0;
}

// cb_LogDir
// file configuration.c line 249
const char * cb_LogDir(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(cmd->data.str, "default");
  if(!(return_value_strcmp$1 == 0))
  {
    if(SpeechdOptions.log_dir_set == 0)
      SpeechdOptions.log_dir=g_strdup(cmd->data.str);

  }

  logging_init();
  return (const char *)(void *)0;
}

// cb_LogFile
// file configuration.c line 237
const char * cb_LogFile(struct command_t *cmd, void *ctx)
{
  /* assertion cmd->data.str != ((void *)0) */
  assert(cmd->data.str != (char *)(void *)0);
  SpeechdOptions.log_dir=g_path_get_dirname(cmd->data.str);
  logging_init();
  MSG(1, "WARNING: The LogFile option is deprecated. Directory accepted but filename ignored");
  return (const char *)(void *)0;
}

// cb_LogLevel
// file configuration.c line 214
const char * cb_LogLevel(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 215);
    exit(1);
  }

  if(!(val >= 0) || val >= 6)
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid log (verbosity) level!", (const void *)"configuration.c", 215);
    exit(1);
  }

  if(SpeechdOptions.log_level_set == 0)
  {
    SpeechdOptions.log_level = val;
    GlobalFDSet.log_level = val;
  }

  return (const char *)(void *)0;
}

// cb_MaxHistoryMessages
// file configuration.c line 216
const char * cb_MaxHistoryMessages(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 217);
    exit(1);
  }

  if(!(val >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid parameter!", (const void *)"configuration.c", 217);
    exit(1);
  }

  SpeechdOptions.max_history_messages = val;
  return (const char *)(void *)0;
}

// cb_Port
// file configuration.c line 211
const char * cb_Port(struct command_t *cmd, void *ctx)
{
  signed int val = (signed int)cmd->data.value;
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 211);
    exit(1);
  }

  if(!(val >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Invalid port number!", (const void *)"configuration.c", 211);
    exit(1);
  }

  if(SpeechdOptions.port_set == 0)
    SpeechdOptions.port = val;

  return (const char *)(void *)0;
}

// cb_SocketPath
// file configuration.c line 210
const char * cb_SocketPath(struct command_t *cmd, void *ctx)
{
  if(!(cl_spec_section == ((struct anonymous$26 *)NULL)))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:This command isn't allowed in a client specific section!", (const void *)"configuration.c", 210);
    exit(1);
  }

  if(SpeechdOptions.socket_path_set == 0)
    SpeechdOptions.socket_path=g_strdup(cmd->data.str);

  return (const char *)(void *)0;
}

// cb_unknown
// file configuration.c line 372
const char * cb_unknown(struct command_t *cmd, void *ctx)
{
  MSG(2, "Unknown option in configuration!");
  return (const char *)(void *)0;
}

// check_locked
// file speechd.c line 1240
void check_locked(union anonymous$12 *lock)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(lock);
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    MSG(1, "CRITICAL ERROR: Not locked but accessing structure data!");
    fprintf(stderr, "WARNING! WARNING! MUTEX CHECK FAILED!\n");
    fflush(stderr);
    exit(0);
  }

}

// client_has_messages
// file speaking.c line 1056
signed int client_has_messages(signed int uid)
{
  struct _GList *return_value_g_list_find_custom$1;
  return_value_g_list_find_custom$1=g_list_find_custom(MessageQueue->p5, (const void *)&uid, message_has_uid);
  _Bool tmp_if_expr$3;
  struct _GList *return_value_g_list_find_custom$2;
  if(!(return_value_g_list_find_custom$1 == ((struct _GList *)NULL)))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_g_list_find_custom$2=g_list_find_custom(MessageQueue->p4, (const void *)&uid, message_has_uid);
    tmp_if_expr$3 = return_value_g_list_find_custom$2 != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  struct _GList *return_value_g_list_find_custom$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_g_list_find_custom$4=g_list_find_custom(MessageQueue->p3, (const void *)&uid, message_has_uid);
    tmp_if_expr$5 = return_value_g_list_find_custom$4 != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  struct _GList *return_value_g_list_find_custom$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_g_list_find_custom$6=g_list_find_custom(MessageQueue->p2, (const void *)&uid, message_has_uid);
    tmp_if_expr$7 = return_value_g_list_find_custom$6 != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  struct _GList *return_value_g_list_find_custom$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_g_list_find_custom$8=g_list_find_custom(MessageQueue->p1, (const void *)&uid, message_has_uid);
    tmp_if_expr$9 = return_value_g_list_find_custom$8 != ((struct _GList *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$9)
    return 1;

  else
    return 0;
}

// compare_message_fd
// file compare.c line 37
signed int compare_message_fd(const void *element, const void *value, void *x)
{
  signed int *fd_val;
  struct anonymous$7 *message;
  fd_val = (signed int *)value;
  message = (struct anonymous$7 *)element;
  /* assertion message != ((void *)0) */
  assert(message != (struct anonymous$7 *)(void *)0);
  /* assertion message->settings.fd != 0 */
  assert(message->settings.fd != 0);
  return message->settings.fd - *fd_val;
}

// compare_message_uid
// file compare.c line 51
signed int compare_message_uid(const void *element, const void *value, void *x)
{
  signed int *uid_val;
  struct anonymous$7 *message;
  uid_val = (signed int *)value;
  message = (struct anonymous$7 *)element;
  /* assertion message != ((void *)0) */
  assert(message != (struct anonymous$7 *)(void *)0);
  return (signed int)(message->settings.uid - (unsigned int)*uid_val);
}

// create_pid_file
// file speechd.c line 749
signed int create_pid_file(void)
{
  struct _IO_FILE *pid_file;
  signed int pid_fd;
  struct flock lock;
  signed int ret;
  pid_file=fopen(SpeechdOptions.pid_file, "r");
  if(!(pid_file == ((struct _IO_FILE *)NULL)))
  {
    pid_fd=fileno(pid_file);
    lock.l_type = (signed short int)1;
    lock.l_whence = (signed short int)0;
    lock.l_start = (signed long int)1;
    lock.l_len = (signed long int)3;
    ret=fcntl(pid_fd, 5, &lock);
    if(ret == -1)
    {
      MSG(-1, "Can't check lock status of an existing pid file.\n");
      return -1;
    }

    fclose(pid_file);
    if(!((signed int)lock.l_type == 2))
    {
      MSG(-1, "Speech Dispatcher already running.\n");
      return -1;
    }

    unlink(SpeechdOptions.pid_file);
  }

  pid_file=fopen(SpeechdOptions.pid_file, "w");
  if(pid_file == ((struct _IO_FILE *)NULL))
  {
    MSG(-1, "Can't create pid file in %s, wrong permissions?\n", SpeechdOptions.pid_file);
    return -1;
  }

  else
  {
    signed int return_value_getpid$1;
    return_value_getpid$1=getpid();
    fprintf(pid_file, "%d\n", return_value_getpid$1);
    fflush(pid_file);
    pid_fd=fileno(pid_file);
    lock.l_type = (signed short int)1;
    lock.l_whence = (signed short int)0;
    lock.l_start = (signed long int)1;
    lock.l_len = (signed long int)3;
    ret=fcntl(pid_fd, 6, &lock);
    if(ret == -1)
    {
      MSG(-1, "Can't set lock on pid file.\n");
      return -1;
    }

    else
      return 0;
  }
}

// deescape_dot
// file parse.c line 1019
char * deescape_dot(const char *orig_text, unsigned long int orig_len)
{
  char *out_text = (char *)(void *)0;
  char *out_ptr;
  const char *orig_end = orig_text + (signed long int)orig_len;
  char *tmp_post$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  char *tmp_post$3;
  const char *tmp_post$4;
  if(orig_text == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    void *return_value_g_malloc$1;
    return_value_g_malloc$1=g_malloc(orig_len + (unsigned long int)1);
    out_text = (char *)return_value_g_malloc$1;
    out_ptr = out_text;
    if(orig_len >= 2ul)
    {
      if((signed int)*orig_text == 46)
      {
        if((signed int)orig_text[1l] == 46)
        {
          tmp_post$2 = out_ptr;
          out_ptr = out_ptr + 1l;
          *tmp_post$2 = (char)46;
          orig_text = orig_text + (signed long int)2;
        }

      }

    }

    while(!(orig_text >= orig_end))
    {
      if((signed int)*orig_text == 13)
        tmp_if_expr$5 = (signed int)orig_text[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (signed int)orig_text[(signed long int)2] == 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (signed int)orig_text[(signed long int)3] == 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
      {
        static const unsigned long int DOTLINELEN = (const unsigned long int)3;
        static const char *DOTLINE = "\r\n.";
        memcpy((void *)out_ptr, (const void *)DOTLINE, DOTLINELEN);
        out_ptr = out_ptr + (signed long int)DOTLINELEN;
        static const unsigned long int ESCAPED_DOTLINELEN = (const unsigned long int)4;
        orig_text = orig_text + (signed long int)ESCAPED_DOTLINELEN;
      }

      else
      {
        tmp_post$3 = out_ptr;
        out_ptr = out_ptr + 1l;
        tmp_post$4 = orig_text;
        orig_text = orig_text + 1l;
        *tmp_post$3 = *tmp_post$4;
      }
    }
    *out_ptr = (char)0;
    return out_text;
  }
}

// default_fd_set
// file set.h line 93
struct anonymous$11 * default_fd_set(void)
{
  struct anonymous$11 *new;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$11) /*192ul*/ );
  new = (struct anonymous$11 *)return_value_g_malloc$1;
  new->paused = 0;
  new->priority = GlobalFDSet.priority;
  new->msg_settings.punctuation_mode = GlobalFDSet.msg_settings.punctuation_mode;
  new->msg_settings.rate = GlobalFDSet.msg_settings.rate;
  new->msg_settings.pitch = GlobalFDSet.msg_settings.pitch;
  new->msg_settings.volume = GlobalFDSet.msg_settings.volume;
  new->msg_settings.voice.language=g_strdup(GlobalFDSet.msg_settings.voice.language);
  new->output_module=g_strdup(GlobalFDSet.output_module);
  new->client_name=g_strdup(GlobalFDSet.client_name);
  new->index_mark=g_strdup(GlobalFDSet.index_mark);
  new->audio_output_method=g_strdup(GlobalFDSet.audio_output_method);
  new->audio_oss_device=g_strdup(GlobalFDSet.audio_oss_device);
  new->audio_alsa_device=g_strdup(GlobalFDSet.audio_alsa_device);
  new->audio_nas_server=g_strdup(GlobalFDSet.audio_nas_server);
  new->audio_pulse_server=g_strdup(GlobalFDSet.audio_pulse_server);
  new->msg_settings.voice_type = GlobalFDSet.msg_settings.voice_type;
  new->msg_settings.voice.name = (char *)(void *)0;
  new->msg_settings.spelling_mode = GlobalFDSet.msg_settings.spelling_mode;
  new->msg_settings.cap_let_recogn = GlobalFDSet.msg_settings.cap_let_recogn;
  new->pause_context = GlobalFDSet.pause_context;
  new->ssml_mode = GlobalFDSet.ssml_mode;
  new->notification = GlobalFDSet.notification;
  new->active = 1;
  new->hist_cur_uid = (unsigned int)-1;
  new->hist_cur_pos = -1;
  new->hist_sorted = (enum anonymous$18)0;
  new->index_mark = (char *)(void *)0;
  new->paused_while_speaking = 0;
  return new;
}

// destroy_module
// file module.c line 42
void destroy_module(struct anonymous$10 *module)
{
  g_free((void *)module->name);
  g_free((void *)module->filename);
  g_free((void *)module->configfilename);
  g_free((void *)module);
}

// destroy_pid_file
// file speechd.c line 808
void destroy_pid_file(void)
{
  unlink(SpeechdOptions.pid_file);
}

// detect_output_modules
// file module.h line 44
struct _GList * detect_output_modules(char *dirname)
{
  struct __dirstream *module_dir;
  module_dir=opendir(dirname);
  struct dirent *entry;
  char **module_parameters;
  struct _GList *modules = (struct _GList *)(void *)0;
  char *full_path;
  struct stat fileinfo;
  signed int sys_ret;
  if(module_dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    MSG(3, "couldn't open directory %s because of error %s\n", dirname, return_value_strerror$2);
    return (struct _GList *)(void *)0;
  }

  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$7;
  do
  {
    entry=readdir(module_dir);
    if(entry == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(entry->d_name, ".");
    if(return_value_strcmp$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcmp$4=strcmp(entry->d_name, "..");
      tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
    {
      full_path=spd_get_path(entry->d_name, dirname);
      sys_ret=stat(full_path, &fileinfo);
      g_free((void *)full_path);
      if(!(sys_ret == 0))
        MSG(4, "stat failed on file %s in %s", (const void *)entry->d_name, dirname);

      else
        if(!((61440u & fileinfo.st_mode) == 32768u))
          MSG(4, "Ignoring %s in %s; not a regular file.", (const void *)entry->d_name, dirname);

        else
        {
          signed int return_value_strncmp$6;
          static const signed int FNAME_PREFIX_LENGTH = 3;
          return_value_strncmp$6=strncmp(entry->d_name, "sd_", (unsigned long int)FNAME_PREFIX_LENGTH);
          if(!(return_value_strncmp$6 == 0))
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = (signed int)entry->d_name[(signed long int)FNAME_PREFIX_LENGTH] == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            MSG(1, "Module discovery ignoring %s: malformed filename.", (const void *)entry->d_name);

          else
          {
            void *return_value_g_malloc$8;
            return_value_g_malloc$8=g_malloc((unsigned long int)4 * sizeof(char *) /*8ul*/ );
            module_parameters = (char **)return_value_g_malloc$8;
            module_parameters[(signed long int)0]=g_strdup(entry->d_name + (signed long int)FNAME_PREFIX_LENGTH);
            module_parameters[(signed long int)1]=g_strdup(entry->d_name);
            module_parameters[(signed long int)2]=g_strdup_printf("%s.conf", module_parameters[(signed long int)0]);
            module_parameters[(signed long int)3]=g_strdup_printf("%s/%s.log", SpeechdOptions.log_dir, module_parameters[(signed long int)0]);
            modules=g_list_append(modules, (void *)module_parameters);
            MSG(5, "Module name=%s being inserted into detected_modules list", module_parameters[(signed long int)0]);
          }
        }
    }

  }
  while((_Bool)1);
  closedir(module_dir);
  return modules;
}

// empty_queue
// file speaking.c line 775
struct _GList * empty_queue(struct _GList *queue)
{
  signed int num;
  signed int i;
  struct _GList *gl;
  unsigned int return_value_g_list_length$1;
  return_value_g_list_length$1=g_list_length(queue);
  num = (signed int)return_value_g_list_length$1;
  i = 0;
  for( ; num + -1 >= i; i = i + 1)
  {
    gl=g_list_first(queue);
    queue=queue_remove_message(queue, gl);
  }
  return queue;
}

// empty_queue_by_time
// file speaking.c line 789
struct _GList * empty_queue_by_time(struct _GList *queue, unsigned int uid)
{
  signed int num;
  signed int i;
  struct _GList *gl;
  struct _GList *gln;
  struct anonymous$7 *msg;
  unsigned int return_value_g_list_length$1;
  return_value_g_list_length$1=g_list_length(queue);
  num = (signed int)return_value_g_list_length$1;
  gl=g_list_first(queue);
  i = 0;
  struct _GList *tmp_if_expr$2;
  for( ; num + -1 >= i; i = i + 1)
  {
    if(!(gl == ((struct _GList *)NULL)))
      tmp_if_expr$2 = ((struct _GList *)gl)->next;

    else
      tmp_if_expr$2 = (struct _GList *)(void *)0;
    gln = tmp_if_expr$2;
    if(gl == ((struct _GList *)NULL))
      break;

    /* assertion gl->data != ((void *)0) */
    assert(gl->data != (void *)0);
    msg = (struct anonymous$7 *)gl->data;
    if(!(msg->id >= uid))
      queue=queue_remove_message(queue, gl);

    gl = gln;
  }
  return queue;
}

// escape_dot
// file output.c line 822
char * escape_dot(char *otext)
{
  char *seq;
  struct _GString *ntext;
  char *ootext;
  char *ret = (char *)(void *)0;
  signed int len;
  if(otext == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    MSG2(5, "escaping", "Incoming text: |%s|", otext);
    ootext = otext;
    ntext=g_string_new("");
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(otext);
    if(return_value_strlen$2 == 1ul)
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(otext, ".");
      if(return_value_strcmp$1 == 0)
      {
        g_string_append(ntext, "..");
        otext = otext + (signed long int)1;
      }

    }

    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(otext);
    if(return_value_strlen$3 >= 2ul)
    {
      if((signed int)*otext == 46)
      {
        if((signed int)otext[1l] == 10)
        {
          g_string_append(ntext, "..\n");
          otext = otext + (signed long int)2;
        }

      }

    }

    MSG2(6, "escaping", "Altering text (I): |%s|", ntext->str);
    do
    {
      seq=strstr(otext, "\n.\n");
      if(seq == ((char *)NULL))
        break;

      *seq = (char)0;
      g_string_append(ntext, otext);
      g_string_append(ntext, "\n..\n");
      otext = seq + (signed long int)3;
    }
    while((_Bool)1);
    MSG2(6, "escaping", "Altering text (II): |%s|", ntext->str);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(otext);
    len = (signed int)return_value_strlen$4;
    if(len >= 2)
    {
      if((signed int)otext[(signed long int)(len + -2)] == 10)
      {
        if((signed int)otext[(signed long int)(len + -1)] == 46)
        {
          g_string_append(ntext, otext);
          g_string_append(ntext, ".");
          otext = otext + (signed long int)len;
          MSG2(6, "escaping", "Altering text (II-b): |%s|", ntext->str);
        }

      }

    }

    if(otext == ootext)
    {
      g_string_free(ntext, 1);
      ret = otext;
    }

    else
    {
      g_string_append(ntext, otext);
      g_free((void *)ootext);
      ret = ntext->str;
      g_string_free(ntext, 0);
    }
    MSG2(6, "escaping", "Altered text: |%s|", ret);
    return ret;
  }
}

// fatal_error
// file speechd.c line 121
void fatal_error(void)
{
  signed int i = 0;
  i = i + 1;
}

// find_index_mark
// file index_marking.h line 40
char * find_index_mark(struct anonymous$7 *msg, signed int mark)
{
  char str_mark[64l];
  char *pos;
  char *p;
  MSG(5, "Trying to find index mark %d", mark);
  sprintf(str_mark, "<mark name=\"__spd_%d\"/>", mark);
  p=strstr(msg->buf, str_mark);
  if(p == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str_mark);
    pos = p + (signed long int)return_value_strlen$1;
    MSG(5, "Search for index mark sucessfull");
    return pos;
  }
}

// free_config_options
// file configuration.h line 38
void free_config_options(struct configoption_t *opts, signed int *num)
{
  signed int i = 0;
  if(!(opts == ((struct configoption_t *)NULL)))
  {
    i = 0;
    for( ; *num + -1 >= i; i = i + 1)
      g_free((void *)(char *)(opts + (signed long int)i)->name);
    g_free((void *)opts);
    *num = 0;
    opts = (struct configoption_t *)(void *)0;
  }

}

// get_client_settings_by_fd
// file set.h line 32
struct anonymous$11 * get_client_settings_by_fd(signed int fd)
{
  struct anonymous$11 *settings;
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return (struct anonymous$11 *)(void *)0;

  else
  {
    void *return_value_g_hash_table_lookup$1;
    return_value_g_hash_table_lookup$1=g_hash_table_lookup(fd_settings, (const void *)&uid);
    settings = (struct anonymous$11 *)return_value_g_hash_table_lookup$1;
    return settings;
  }
}

// get_client_settings_by_uid
// file set.h line 31
struct anonymous$11 * get_client_settings_by_uid(signed int uid)
{
  struct anonymous$11 *element;
  if(!(uid >= 0))
    return (struct anonymous$11 *)(void *)0;

  else
  {
    void *return_value_g_hash_table_lookup$1;
    return_value_g_hash_table_lookup$1=g_hash_table_lookup(fd_settings, (const void *)&uid);
    element = (struct anonymous$11 *)return_value_g_hash_table_lookup$1;
    return element;
  }
}

// get_client_uid_by_fd
// file set.h line 34
signed int get_client_uid_by_fd(signed int fd)
{
  signed int *uid;
  if(!(fd >= 1))
    return 0;

  else
  {
    void *return_value_g_hash_table_lookup$1;
    return_value_g_hash_table_lookup$1=g_hash_table_lookup(fd_uid, (const void *)&fd);
    uid = (signed int *)return_value_g_hash_table_lookup$1;
    if(uid == ((signed int *)NULL))
      return 0;

    else
      return *uid;
  }
}

// get_message_from_queues
// file speaking.c line 1014
struct anonymous$7 * get_message_from_queues()
{
  struct _GList *gl;
  enum anonymous$9 prio;
  struct anonymous$7 *message;
  prio = (enum anonymous$9)SPD_IMPORTANT;
  struct _GList *tmp_if_expr$1;
  for( ; !((signed int)prio >= 6); prio = (enum anonymous$9)((signed int)prio + 1))
  {
    struct _GList *current_queue;
    current_queue=speaking_get_queue(prio);
    check_locked(&element_free_mutex);
    gl=g_list_first(current_queue);
    while(!(gl == ((struct _GList *)NULL)))
    {
      signed int return_value_message_nto_speak$2;
      return_value_message_nto_speak$2=message_nto_speak((const void *)(struct anonymous$7 *)gl->data, (void *)0);
      if(!(return_value_message_nto_speak$2 == 0))
      {
        if(!(gl == ((struct _GList *)NULL)))
          tmp_if_expr$1 = ((struct _GList *)gl)->next;

        else
          tmp_if_expr$1 = (struct _GList *)(void *)0;
        gl = tmp_if_expr$1;
      }

      else
      {
        struct _GList *return_value_g_list_remove_link$3;
        return_value_g_list_remove_link$3=g_list_remove_link(current_queue, gl);
        speaking_set_queue(prio, return_value_g_list_remove_link$3);
        highest_priority = prio;
        message = (struct anonymous$7 *)gl->data;
        g_list_free(gl);
        return (struct anonymous$7 *)message;
      }
    }
  }
  return (struct anonymous$7 *)(void *)0;
}

// get_messages_by_client
// file history.c line 350
struct _GList * get_messages_by_client(signed int uid)
{
  struct _GList *list = (struct _GList *)(void *)0;
  struct _GList *gl;
  struct anonymous$7 *msg;
  unsigned int i;
  unsigned int history_length;
  history_length=g_list_length(message_history);
  i = (unsigned int)0;
  for( ; !(i >= history_length); i = i + 1u)
  {
    gl=g_list_nth(message_history, i);
    /* assertion gl != ((void *)0) */
    assert(gl != (struct _GList *)(void *)0);
    msg = (struct anonymous$7 *)gl->data;
    if(msg->settings.uid == (unsigned int)uid)
      list=g_list_append(list, (void *)msg);

  }
  return list;
}

// get_output_module
// file output.h line 27
struct anonymous$10 * get_output_module(const struct anonymous$7 *message)
{
  struct anonymous$10 *output = (struct anonymous$10 *)(void *)0;
  signed int i;
  signed int len;
  _Bool tmp_if_expr$4;
  if(!(message->settings.output_module == ((char *)NULL)))
  {
    MSG(5, "Desired output module is %s", message->settings.output_module);
    output=get_output_module_by_name(message->settings.output_module);
    if(output == ((struct anonymous$10 *)NULL))
      goto __CPROVER_DUMP_L1;

    if(output->working == 0)
      goto __CPROVER_DUMP_L1;

    return output;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    MSG(3, "Warning: Didn't find preferred output module, using default");
    if(!(GlobalFDSet.output_module == ((char *)NULL)))
      output=get_output_module_by_name(GlobalFDSet.output_module);

    if(!(output == ((struct anonymous$10 *)NULL)))
    {
      if(output->working == 0)
        goto __CPROVER_DUMP_L3;

      return output;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      MSG(3, "Couldn't load default output module, trying other modules");
      unsigned int return_value_g_list_length$1;
      return_value_g_list_length$1=g_list_length(output_modules);
      len = (signed int)return_value_g_list_length$1;
      i = 0;
      for( ; !(i >= len); i = i + 1)
      {
        void *return_value_g_list_nth_data$2;
        return_value_g_list_nth_data$2=g_list_nth_data(output_modules, (unsigned int)i);
        output = (struct anonymous$10 *)return_value_g_list_nth_data$2;
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(output->name, "dummy");
        if(!(return_value_strcmp$3 == 0))
        {
          if(!(output->working == 0))
          {
            MSG(3, "Output module %s seems to be working, using it", output->name);
            return output;
          }

        }

      }
      if(output == ((struct anonymous$10 *)NULL))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = !(output->working != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        output=get_output_module_by_name("dummy");

      if(output == ((struct anonymous$10 *)NULL))
        MSG(1, "Error: No output module working, not even dummy, no sound produced!\n");

      return output;
    }
  }
}

// get_output_module_by_name
// file output.c line 83
struct anonymous$10 * get_output_module_by_name(char *name)
{
  struct anonymous$10 *output;
  signed int i = 0;
  unsigned int return_value_g_list_length$1;
  do
  {
    return_value_g_list_length$1=g_list_length(output_modules);
    if((unsigned int)i >= return_value_g_list_length$1)
      break;

    void *return_value_g_list_nth_data$2;
    return_value_g_list_nth_data$2=g_list_nth_data(output_modules, (unsigned int)i);
    output = (struct anonymous$10 *)return_value_g_list_nth_data$2;
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(output->name, name);
    if(return_value_strcmp$3 == 0)
    {
      if(!(output->working == 0))
        return output;

      else
        return (struct anonymous$10 *)(void *)0;
    }

    i = i + 1;
  }
  while((_Bool)1);
  return (struct anonymous$10 *)(void *)0;
}

// get_param
// file parse.c line 1084
char * get_param(const char *buf, const signed int n, const signed int bytes, const signed int lower_case)
{
  char *param;
  char *par;
  signed int i;
  signed int y;
  signed int z = 0;
  /* assertion bytes != 0 */
  assert(bytes != 0);
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)bytes);
  param = (char *)return_value_g_malloc$1;
  /* assertion param != ((void *)0) */
  assert(param != (char *)(void *)0);
  strcpy(param, "");
  i = 0;
  y = 0;
  for( ; n >= y; y = y + 1)
  {
    z = 0;
    for( ; !(i >= bytes); i = i + 1)
    {
      if((signed int)buf[(signed long int)i] == 32)
        break;

      param[(signed long int)z] = buf[(signed long int)i];
      z = z + 1;
    }
    i = i + 1;
  }
  if(!(z >= 1))
  {
    g_free((void *)param);
    return (char *)(void *)0;
  }

  else
  {
    if(i >= bytes)
      param[(signed long int)(z > 1 ? z - 2 : 0)] = (char)0;

    else
      param[(signed long int)z] = (char)0;
    if(!(lower_case == 0))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(param);
      par=g_ascii_strdown(param, (signed long int)return_value_strlen$2);
      g_free((void *)param);
    }

    else
      par = param;
    return par;
  }
}

// get_speaking_client_uid
// file speaking.c line 749
signed int get_speaking_client_uid(void)
{
  signed int speaking = 0;
  if(SPEAKING == 0)
  {
    speaking_uid = 0;
    return 0;
  }

  else
  {
    if(!(speaking_uid == 0))
      speaking = speaking_uid;

    return speaking;
  }
}

// history_add_message
// file history.h line 44
signed int history_add_message(struct anonymous$7 *msg)
{
  struct anonymous$7 *hist_msg;
  struct anonymous$7 *return_value_spd_message_copy$1;
  return_value_spd_message_copy$1=spd_message_copy(msg);
  hist_msg = (struct anonymous$7 *)return_value_spd_message_copy$1;
  if(hist_msg == ((struct anonymous$7 *)NULL))
    return -1;

  else
  {
    unsigned int return_value_g_list_length$2;
    return_value_g_list_length$2=g_list_length(message_history);
    if(return_value_g_list_length$2 >= (unsigned int)SpeechdOptions.max_history_messages)
    {
      struct _GList *gl;
      MSG(5, "Discarding older history message, limit reached");
      gl=g_list_first(message_history);
      if(!(gl == ((struct _GList *)NULL)))
      {
        message_history=g_list_remove_link(message_history, gl);
        if(!(gl->data == NULL))
          mem_free_message((struct anonymous$7 *)gl->data);

      }

    }

    message_history=g_list_append(message_history, (void *)hist_msg);
    return 0;
  }
}

// history_cursor_backward
// file history.c line 262
char * history_cursor_backward(signed int fd)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_fd(fd);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 268);
    exit(1);
  }

  char *return_value_g_strdup$1;
  if(!(settings->hist_cur_pos + -1 >= 0))
  {
    return_value_g_strdup$1=g_strdup("404 ERR POSITION TOO LOW\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    settings->hist_cur_pos = settings->hist_cur_pos - 1;
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup("224 OK CURSOR MOVED BACKWARD\r\n");
    return return_value_g_strdup$2;
  }
}

// history_cursor_forward
// file history.c line 245
char * history_cursor_forward(signed int fd)
{
  struct anonymous$11 *settings;
  struct _GList *client_msgs;
  settings=get_client_settings_by_fd(fd);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 252);
    exit(1);
  }

  client_msgs=get_messages_by_client((signed int)settings->hist_cur_uid);
  unsigned int return_value_g_list_length$2;
  return_value_g_list_length$2=g_list_length(client_msgs);
  char *return_value_g_strdup$1;
  if(!(return_value_g_list_length$2 + 4294967295u >= 1u + (unsigned int)settings->hist_cur_pos))
  {
    return_value_g_strdup$1=g_strdup("405 ERR POSITION TOO HIGH\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    settings->hist_cur_pos = settings->hist_cur_pos + 1;
    char *return_value_g_strdup$3;
    return_value_g_strdup$3=g_strdup("223 OK CURSOR MOVED FORWARD\r\n");
    return return_value_g_strdup$3;
  }
}

// history_cursor_get
// file history.c line 277
char * history_cursor_get(signed int fd)
{
  struct anonymous$11 *settings;
  struct anonymous$7 *new;
  struct _GString *reply;
  struct _GList *gl;
  struct _GList *client_msgs;
  reply=g_string_new("");
  settings=get_client_settings_by_fd(fd);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 288);
    exit(1);
  }

  client_msgs=get_messages_by_client((signed int)settings->hist_cur_uid);
  gl=g_list_nth(client_msgs, (unsigned int)(signed int)settings->hist_cur_pos);
  char *return_value_g_strdup$1;
  if(gl == ((struct _GList *)NULL))
  {
    return_value_g_strdup$1=g_strdup("403 ERR NO MESSAGE\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    new = (struct anonymous$7 *)gl->data;
    g_string_printf(reply, "243-%d\r\n243 OK CURSOR POSITION RETURNED\r\n", new->id);
    return reply->str;
  }
}

// history_cursor_set_first
// file history.c line 210
char * history_cursor_set_first(signed int fd, unsigned int client_id)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_fd(fd);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 216);
    exit(1);
  }

  settings->hist_cur_pos = 0;
  settings->hist_cur_uid = client_id;
  char *return_value_g_strdup$1;
  return_value_g_strdup$1=g_strdup("220 OK CURSOR SET FIRST\r\n");
  return return_value_g_strdup$1;
}

// history_cursor_set_last
// file history.c line 194
char * history_cursor_set_last(signed int fd, unsigned int client_id)
{
  struct _GList *client_msgs;
  struct anonymous$11 *settings;
  settings=get_client_settings_by_fd(fd);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 201);
    exit(1);
  }

  client_msgs=get_messages_by_client((signed int)client_id);
  unsigned int return_value_g_list_length$1;
  return_value_g_list_length$1=g_list_length(client_msgs);
  settings->hist_cur_pos = (signed int)(return_value_g_list_length$1 - (unsigned int)1);
  settings->hist_cur_uid = client_id;
  char *return_value_g_strdup$2;
  return_value_g_strdup$2=g_strdup("221 OK CURSOR SET LAST\r\n");
  return return_value_g_strdup$2;
}

// history_cursor_set_pos
// file history.c line 223
char * history_cursor_set_pos(signed int fd, unsigned int client_id, signed int pos)
{
  struct anonymous$11 *settings;
  struct _GList *client_msgs;
  char *return_value_g_strdup$1;
  char *return_value_g_strdup$2;
  if(!(pos >= 0))
  {
    return_value_g_strdup$1=g_strdup("404 ERR POSITION TOO LOW\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    client_msgs=get_messages_by_client((signed int)client_id);
    unsigned int return_value_g_list_length$3;
    return_value_g_list_length$3=g_list_length(client_msgs);
    if(!(return_value_g_list_length$3 + 4294967295u >= (unsigned int)pos))
    {
      return_value_g_strdup$2=g_strdup("405 ERR POSITION TOO HIGH\r\n");
      return return_value_g_strdup$2;
    }

    else
    {
      settings=get_client_settings_by_fd(fd);
      if(settings == ((struct anonymous$11 *)NULL))
      {
        fatal_error();
        MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client", (const void *)"history.c", 237);
        exit(1);
      }

      settings->hist_cur_pos = pos;
      settings->hist_cur_uid = client_id;
      MSG(4, "cursor pos:%d\n", settings->hist_cur_pos);
      char *return_value_g_strdup$4;
      return_value_g_strdup$4=g_strdup("222 OK CURSOR SET TO POSITION\r\n");
      return return_value_g_strdup$4;
    }
  }
}

// history_get_client_id
// file history.c line 74
char * history_get_client_id(signed int fd)
{
  struct _GString *cid;
  signed int uid;
  cid=g_string_new("");
  uid=get_client_uid_by_fd(fd);
  char *return_value_g_strdup$1;
  if(uid == 0)
  {
    return_value_g_strdup$1=g_strdup("300 ERR INTERNAL\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    g_string_append_printf(cid, "245-%d\r\n", uid);
    g_string_append_printf(cid, "245 OK CLIENT ID SENT\r\n");
    return cid->str;
  }
}

// history_get_client_list
// file history.c line 50
char * history_get_client_list()
{
  struct anonymous$11 *client;
  struct _GString *clist;
  signed int i;
  clist=g_string_new("");
  i = 1;
  for( ; SpeechdStatus.max_uid >= i; i = i + 1)
  {
    MSG(4, "Getting settings for client %d of %d", i, SpeechdStatus.max_uid - 1);
    client=get_client_settings_by_uid(i);
    /* assertion client != ((void *)0) */
    assert(client != (struct anonymous$11 *)(void *)0);
    g_string_append_printf(clist, "240-");
    g_string_append_printf(clist, "%d ", client->uid);
    g_string_append(clist, client->client_name);
    g_string_append_printf(clist, " %d", client->active);
    g_string_append(clist, "\r\n");
  }
  g_string_append_printf(clist, "240 OK CLIENTS LIST SENT\r\n");
  return clist->str;
}

// history_get_last
// file history.c line 176
char * history_get_last(signed int fd)
{
  struct anonymous$7 *message;
  struct _GString *lastm;
  struct _GList *gl;
  lastm=g_string_new("");
  gl=g_list_last(message_history);
  char *return_value_g_strdup$1;
  if(gl == ((struct _GList *)NULL))
  {
    return_value_g_strdup$1=g_strdup("403 ERR NO MESSAGE\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    message = (struct anonymous$7 *)gl->data;
    g_string_append_printf(lastm, "242-%d\r\n", message->id);
    g_string_append_printf(lastm, "242 OK LAST MSG SAID\r\n");
    return lastm->str;
  }
}

// history_get_message
// file history.c line 91
char * history_get_message(signed int uid)
{
  char *return_value_g_strdup$1;
  return_value_g_strdup$1=g_strdup("380 ERR NOT YET IMPLEMENTED\r\n");
  return return_value_g_strdup$1;
}

// history_get_message_list
// file history.c line 133
char * history_get_message_list(unsigned int client_id, signed int from, signed int num)
{
  struct anonymous$7 *message;
  struct _GString *mlist;
  struct _GList *gl;
  struct anonymous$11 *client_settings;
  struct _GList *client_msgs;
  signed int i;
  MSG(4, "message_list: from %d num %d, client %d\n", from, num, client_id);
  mlist=g_string_new("");
  client_settings=get_client_settings_by_uid((signed int)client_id);
  char *return_value_g_strdup$1;
  if(client_settings == ((struct anonymous$11 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("402 ERR NO SUCH CLIENT\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    client_msgs=get_messages_by_client((signed int)client_id);
    i = from;
    for( ; from + num + -1 >= i; i = i + 1)
    {
      gl=g_list_nth(client_msgs, (unsigned int)i);
      if(gl == ((struct _GList *)NULL))
      {
        g_string_append_printf(mlist, "241 OK MSGS LIST SENT\r\n");
        return mlist->str;
      }

      message = (struct anonymous$7 *)gl->data;
      if(message == ((struct anonymous$7 *)NULL))
      {
        char *return_value_g_strdup$2;
        return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$2;
      }

      g_string_append_printf(mlist, "241-");
      g_string_append_printf(mlist, "%d %s\r\n", message->id, client_settings->client_name);
    }
    g_string_append_printf(mlist, "241 OK MSGS LIST SENT\r\n");
    return mlist->str;
  }
}

// history_say_id
// file history.c line 300
char * history_say_id(signed int fd, signed int id)
{
  struct anonymous$7 *msg;
  struct anonymous$7 *new;
  struct _GList *gl;
  gl=g_list_find_custom(message_history, (const void *)&id, (signed int (*)(const void *, const void *))p_msg_comp_id);
  char *return_value_g_strdup$1;
  char *return_value_g_strdup$2;
  if(gl == ((struct _GList *)NULL))
  {
    return_value_g_strdup$1=g_strdup("406 ERR ID DOESNT EXIST\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    msg = (struct anonymous$7 *)gl->data;
    if(msg == ((struct anonymous$7 *)NULL))
    {
      return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
      return return_value_g_strdup$2;
    }

    else
    {
      MSG(4, "putting history message into queue\n");
      struct anonymous$7 *return_value_spd_message_copy$3;
      return_value_spd_message_copy$3=spd_message_copy(msg);
      new = (struct anonymous$7 *)return_value_spd_message_copy$3;
      char *return_value_g_strdup$4;
      return_value_g_strdup$4=g_strdup("225 OK MESSAGE QUEUED\r\n");
      return return_value_g_strdup$4;
    }
  }
}

// i18n_init
// file ../../include/i18n.h line 38
void i18n_init(void)
{
  char *return_value_setlocale$1;
  return_value_setlocale$1=setlocale(6, "");
  if(return_value_setlocale$1 == ((char *)NULL))
  {
    perror("setlocale");
    exit(1);
  }

  char *return_value_bindtextdomain$2;
  return_value_bindtextdomain$2=bindtextdomain("speech-dispatcher", "/usr/share/locale");
  if(return_value_bindtextdomain$2 == ((char *)NULL))
  {
    perror("bindtextdomain");
    exit(1);
  }

  char *return_value_textdomain$3;
  return_value_textdomain$3=textdomain("speech-dispatcher");
  if(return_value_textdomain$3 == ((char *)NULL))
  {
    perror("textdomain");
    exit(1);
  }

}

// insert_index_marks
// file index_marking.h line 36
void insert_index_marks(struct anonymous$7 *msg, enum anonymous$5 ssml_mode)
{
  struct _GString *marked_text;
  char *pos;
  char character[6l];
  char character2[6l];
  unsigned int u_char;
  signed int n = 0;
  signed int ret;
  signed int inside_tag = 0;
  marked_text=g_string_new("");
  /* assertion msg != ((void *)0) */
  assert(msg != (struct anonymous$7 *)(void *)0);
  /* assertion msg->buf != ((void *)0) */
  assert(msg->buf != (char *)(void *)0);
  MSG2(5, "index_marking", "MSG before index marking: |%s|, ssml_mode=%d", msg->buf, ssml_mode);
  if((signed int)ssml_mode == SPD_DATA_TEXT)
    g_string_printf(marked_text, "<speak>");

  pos = msg->buf;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  while(!(pos == ((char *)NULL)))
  {
    ret=spd_utf8_read_char(pos, character);
    if(ret == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_strlen$1=strlen(character);
      tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      break;

    u_char=g_utf8_get_char(character);
    if(u_char == 60u)
    {
      if((signed int)ssml_mode == SPD_DATA_SSML)
      {
        inside_tag = 1;
        g_string_append_printf(marked_text, "%s", (const void *)character);
      }

      else
        g_string_append_printf(marked_text, "&lt;");
    }

    else
      if(u_char == 62u)
      {
        if((signed int)ssml_mode == SPD_DATA_SSML)
        {
          inside_tag = 0;
          g_string_append_printf(marked_text, "%s", (const void *)character);
        }

        else
          g_string_append_printf(marked_text, "&gt;");
      }

      else
        if(u_char == 38u)
        {
          if((signed int)ssml_mode == SPD_DATA_SSML)
            g_string_append_printf(marked_text, "%s", (const void *)character);

          else
            if(inside_tag == 0)
              g_string_append_printf(marked_text, "&amp;");

        }

        else
          if(inside_tag == 0 && (u_char == 33u || u_char == 46u || u_char == 63u))
          {
            pos=g_utf8_find_next_char(pos, (const char *)(void *)0);
            ret=spd_utf8_read_char(pos, character2);
            if(ret == 0)
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              return_value_strlen$3=strlen(character2);
              tmp_if_expr$4 = return_value_strlen$3 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$4)
            {
              g_string_append_printf(marked_text, "%s", (const void *)character);
              MSG2(6, "index_marking", "MSG altering 1: |%s|", marked_text->str);
              break;
            }

            u_char=g_utf8_get_char(character2);
            signed int return_value_g_unichar_isspace$5;
            return_value_g_unichar_isspace$5=g_unichar_isspace(u_char);
            if(u_char == 38u || u_char == 60u || !(return_value_g_unichar_isspace$5 == 0))
            {
              g_string_append_printf(marked_text, "%s<mark name=\"__spd_%d\"/>", (const void *)character, n);
              n = n + 1;
              MSG2(6, "index_marking", "MSG altering 2: |%s|", marked_text->str);
              continue;
            }

            else
            {
              g_string_append_printf(marked_text, "%s", (const void *)character);
              MSG2(6, "index_marking", "MSG altering 3: |%s|", marked_text->str);
              continue;
            }
          }

          else
            g_string_append_printf(marked_text, "%s", (const void *)character);
    pos=g_utf8_find_next_char(pos, (const char *)(void *)0);
  }
  if((signed int)ssml_mode == SPD_DATA_TEXT)
    g_string_append_printf(marked_text, "</speak>");

  g_free((void *)msg->buf);
  msg->buf = marked_text->str;
  g_string_free(marked_text, 0);
  MSG2(5, "index_marking", "MSG after index marking: |%s|", msg->buf);
}

// is_sb_speaking
// file speaking.c line 661
signed int is_sb_speaking(void)
{
  signed int ret;
  char *index_mark;
  struct anonymous$11 *settings;
  MSG(5, "is_sb_speaking(), SPEAKING=%d", SPEAKING);
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  if(!(speaking_module == ((struct anonymous$10 *)NULL)))
  {
    if(current_message == ((struct anonymous$7 *)NULL))
    {
      MSG(1, "Error: Current message is NULL in is_sb_speaking()");
      return -1;
    }

    settings = &current_message->settings;
    ret=output_is_speaking(&index_mark);
    if(index_mark == ((char *)NULL))
    {
      SPEAKING = 0;
      return SPEAKING;
    }

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(index_mark, "no");
    if(return_value_strcmp$1 == 0)
    {
      g_free((void *)index_mark);
      return SPEAKING;
    }

    MSG(5, "INDEX MARK: %s", index_mark);
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(index_mark, "__spd_begin");
    if(return_value_strcmp$6 == 0)
    {
      SPEAKING = 1;
      if(settings->paused_while_speaking == 0)
      {
        if(!((SPD_BEGIN & (signed int)settings->notification) == 0))
          report_begin(current_message);

      }

      else
      {
        if(!((SPD_RESUME & (signed int)settings->notification) == 0))
          report_resume(current_message);

        settings->paused_while_speaking = 0;
      }
    }

    else
    {
      return_value_strcmp$5=strcmp(index_mark, "__spd_end");
      if(return_value_strcmp$5 == 0)
      {
        SPEAKING = 0;
        poll_count = 1;
        if(!((SPD_END & (signed int)settings->notification) == 0))
          report_end(current_message);

        speaking_semaphore_post();
      }

      else
      {
        return_value_strcmp$4=strcmp(index_mark, "__spd_paused");
        if(return_value_strcmp$4 == 0)
        {
          SPEAKING = 0;
          poll_count = 1;
          if(!((SPD_PAUSE & (signed int)settings->notification) == 0))
            report_pause(current_message);

          current_message = (struct anonymous$7 *)(void *)0;
        }

        else
        {
          return_value_strcmp$3=strcmp(index_mark, "__spd_stopped");
          if(return_value_strcmp$3 == 0)
          {
            SPEAKING = 0;
            poll_count = 1;
            if(!((SPD_CANCEL & (signed int)settings->notification) == 0))
              report_cancel(current_message);

            speaking_semaphore_post();
          }

          else
            if(!(index_mark == ((char *)NULL)))
            {
              signed int return_value_strncmp$2;
              return_value_strncmp$2=strncmp(index_mark, "__spd_", (unsigned long int)6);
              if(!(return_value_strncmp$2 == 0))
              {
                if(!((SPD_INDEX_MARKS & (signed int)settings->notification) == 0))
                  report_index_mark(current_message, index_mark);

              }

              else
              {
                MSG(5, "Setting current index_mark for the message to %s", index_mark);
                if(!(current_message->settings.index_mark == ((char *)NULL)))
                  g_free((void *)current_message->settings.index_mark);

                current_message->settings.index_mark=g_strdup(index_mark);
              }
            }

        }
      }
    }
    g_free((void *)index_mark);
  }

  else
  {
    MSG(5, "Speaking module is NULL, SPEAKING==%d", SPEAKING);
    SPEAKING = 0;
  }
  if(SPEAKING == 0)
    speaking_module = (struct anonymous$10 *)(void *)0;

  return SPEAKING;
}

// isanum
// file parse.c line 1071
signed int isanum(const char *str)
{
  signed int i;
  const unsigned short int **return_value___ctype_b_loc$2;
  return_value___ctype_b_loc$2=__ctype_b_loc();
  _Bool tmp_if_expr$1;
  unsigned long int return_value_strlen$3;
  if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*str]) == 0)
  {
    if((signed int)*str == 43)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)str[(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      goto __CPROVER_DUMP_L3;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    i = 1;
    do
    {
      return_value_strlen$3=strlen(str);
      if(!(return_value_strlen$3 + 18446744073709551615ul >= (unsigned long int)i))
        break;

      const unsigned short int **return_value___ctype_b_loc$4;
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)str[(signed long int)i]]) == 0)
        return 0;

      i = i + 1;
    }
    while((_Bool)1);
    return 1;
  }
}

// load_config_options
// file configuration.h line 37
struct configoption_t * load_config_options(signed int *num_options)
{
  struct configoption_t *options = (struct configoption_t *)(void *)0;
  cl_spec_section = (struct anonymous$26 *)(void *)0;
  options=add_config_option(options, num_options, "CommunicationMethod", 2, cb_CommunicationMethod, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "SocketPath", 2, cb_SocketPath, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "Port", 1, cb_Port, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DisableAutoSpawn", 6, cb_DisableAutoSpawn, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "LocalhostAccessOnly", 1, cb_LocalhostAccessOnly, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "LogFile", 2, cb_LogFile, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "LogDir", 2, cb_LogDir, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "CustomLogFile", 3, cb_CustomLogFile, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "LogLevel", 1, cb_LogLevel, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultModule", 2, cb_DefaultModule, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "LanguageDefaultModule", 3, cb_LanguageDefaultModule, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultRate", 1, cb_DefaultRate, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultPitch", 1, cb_DefaultPitch, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultVolume", 1, cb_DefaultVolume, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultLanguage", 2, cb_DefaultLanguage, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultPriority", 2, cb_DefaultPriority, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "MaxHistoryMessages", 1, cb_MaxHistoryMessages, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultPunctuationMode", 2, cb_DefaultPunctuationMode, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultClientName", 2, cb_DefaultClientName, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultVoiceType", 2, cb_DefaultVoiceType, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultSpelling", 0, cb_DefaultSpelling, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultCapLetRecognition", 2, cb_DefaultCapLetRecognition, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "DefaultPauseContext", 1, cb_DefaultPauseContext, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AddModule", 3, cb_AddModule, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioOutputMethod", 2, cb_AudioOutputMethod, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioOSSDevice", 2, cb_AudioOSSDevice, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioALSADevice", 2, cb_AudioALSADevice, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioNASServer", 2, cb_AudioNASServer, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioPulseServer", 2, cb_AudioPulseServer, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "AudioPulseMinLength", 1, cb_AudioPulseMinLength, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "BeginClient", 2, cb_BeginClient, NULL, (unsigned long int)0);
  options=add_config_option(options, num_options, "EndClient", 6, cb_EndClient, NULL, (unsigned long int)0);
  return options;
}

// load_default_global_set_options
// file configuration.h line 44
void load_default_global_set_options()
{
  GlobalFDSet.priority = (enum anonymous$9)SPD_MESSAGE;
  GlobalFDSet.msg_settings.punctuation_mode = (enum anonymous$2)SPD_PUNCT_NONE;
  GlobalFDSet.msg_settings.spelling_mode = (enum anonymous$1)0;
  GlobalFDSet.msg_settings.rate = 0;
  GlobalFDSet.msg_settings.pitch = 0;
  GlobalFDSet.msg_settings.volume = 0;
  GlobalFDSet.client_name=g_strdup("unknown:unknown:unknown");
  GlobalFDSet.msg_settings.voice.language=g_strdup("en");
  GlobalFDSet.output_module = (char *)(void *)0;
  GlobalFDSet.msg_settings.voice_type = (enum anonymous$27)SPD_MALE1;
  GlobalFDSet.msg_settings.cap_let_recogn = (enum anonymous$4)SPD_CAP_NONE;
  GlobalFDSet.min_delay_progress = (unsigned int)2000;
  GlobalFDSet.pause_context = 0;
  GlobalFDSet.ssml_mode = (enum anonymous$5)SPD_DATA_TEXT;
  GlobalFDSet.notification = (enum anonymous$17)0;
  GlobalFDSet.audio_output_method=g_strdup("pulse");
  GlobalFDSet.audio_oss_device=g_strdup("/dev/dsp");
  GlobalFDSet.audio_alsa_device=g_strdup("default");
  GlobalFDSet.audio_nas_server=g_strdup("tcp/localhost:5450");
  GlobalFDSet.audio_pulse_server=g_strdup("default");
  GlobalFDSet.audio_pulse_min_length = 100;
  SpeechdOptions.max_history_messages = 10000;
  if(SpeechdOptions.log_level_set == 0)
    SpeechdOptions.log_level = 3;

  if(SpeechdOptions.communication_method_set == 0)
    SpeechdOptions.communication_method=g_strdup("unix_socket");

  if(SpeechdOptions.socket_path_set == 0)
    SpeechdOptions.socket_path=g_strdup("default");

  if(SpeechdOptions.port_set == 0)
    SpeechdOptions.port = 6560;

  if(SpeechdOptions.localhost_access_only_set == 0)
    SpeechdOptions.localhost_access_only = 1;

  logfile = stderr;
  custom_logfile = (struct _IO_FILE *)(void *)0;
}

// load_output_module
// file module.c line 122
struct anonymous$10 * load_output_module(char *mod_name, char *mod_prog, char *mod_cfgfile, char *mod_dbgfile)
{
  struct anonymous$10 *module;
  signed int fr;
  char *argv[3l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL) };
  signed int ret;
  char *module_conf_dir;
  char *rep_line = (char *)(void *)0;
  struct _IO_FILE *f;
  unsigned long int n = (unsigned long int)0;
  char s;
  struct _GString *reply;
  _Bool tmp_if_expr$8;
  signed int return_value_pipe$7;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  char *tmp_if_expr$11;
  if(mod_name == ((char *)NULL))
    return (struct anonymous$10 *)(void *)0;

  else
  {
    void *return_value_g_malloc$1;
    return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$10) /*72ul*/ );
    module = (struct anonymous$10 *)return_value_g_malloc$1;
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup(mod_name);
    module->name = (char *)return_value_g_strdup$2;
    char *return_value_spd_get_path$3;
    return_value_spd_get_path$3=spd_get_path(mod_prog, "/usr/lib/speech-dispatcher-modules");
    module->filename = (char *)return_value_spd_get_path$3;
    module_conf_dir=g_strdup_printf("%s/modules", SpeechdOptions.conf_dir);
    char *return_value_spd_get_path$4;
    return_value_spd_get_path$4=spd_get_path(mod_cfgfile, module_conf_dir);
    module->configfilename = (char *)return_value_spd_get_path$4;
    g_free((void *)module_conf_dir);
    if(!(mod_dbgfile == ((char *)NULL)))
      module->debugfilename=g_strdup(mod_dbgfile);

    else
      module->debugfilename = (char *)(void *)0;
    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(mod_name, "testing");
    if(return_value_strcmp$5 == 0)
    {
      module->pipe_in[(signed long int)1] = 1;
      module->pipe_out[(signed long int)0] = 0;
      return module;
    }

    else
    {
      signed int return_value_pipe$6;
      return_value_pipe$6=pipe(module->pipe_in);
      if(!(return_value_pipe$6 == 0))
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_pipe$7=pipe(module->pipe_out);
        tmp_if_expr$8 = return_value_pipe$7 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
      {
        MSG(3, "Can't open pipe! Module not loaded.");
        return (struct anonymous$10 *)(void *)0;
      }

      else
      {
        argv[(signed long int)0] = module->filename;
        if(!(mod_cfgfile == ((char *)NULL)))
          argv[(signed long int)1] = module->configfilename;

        if(!(module->debugfilename == ((char *)NULL)))
        {
          module->stderr_redirect=open(module->debugfilename, 01 | 0100 | 01000, 0400 | 0200);
          if(module->stderr_redirect == -1)
          {
            return_value___errno_location$9=__errno_location();
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            MSG(1, "ERROR: Openning debug file for %s failed: (error=%d) %s", module->name, module->stderr_redirect, return_value_strerror$10);
          }

        }

        else
          module->stderr_redirect = -1;
        MSG(2, "Initializing output module %s with binary %s and configuration %s", module->name, module->filename, module->configfilename);
        if(module->stderr_redirect >= 0)
          MSG(3, "Output module is logging to file %s", module->debugfilename);

        else
          MSG(3, "Output module is logging to standard error output (stderr)");
        fr=fork();
        if(fr == -1)
        {
          printf("Can't fork, error! Module not loaded.");
          return (struct anonymous$10 *)(void *)0;
        }

        else
        {
          if(fr == 0)
          {
            ret=dup2(module->pipe_in[(signed long int)0], 0);
            close(module->pipe_in[(signed long int)0]);
            close(module->pipe_in[(signed long int)1]);
            ret=dup2(module->pipe_out[(signed long int)1], 1);
            close(module->pipe_out[(signed long int)1]);
            close(module->pipe_out[(signed long int)0]);
            if(module->stderr_redirect >= 0)
              ret=dup2(module->stderr_redirect, 2);

            execvp(argv[(signed long int)0], argv);
            if(!(argv[1l] == ((char *)NULL)))
              tmp_if_expr$11 = argv[(signed long int)1];

            else
              tmp_if_expr$11 = "<none>";
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            char *return_value_strerror$14;
            return_value_strerror$14=strerror(*return_value___errno_location$13);
            MSG(1, "Exec of module \"%s\" with config \"%s\" failed with error %d: %s", argv[(signed long int)0], tmp_if_expr$11, *return_value___errno_location$12, return_value_strerror$14);
            exit(1);
          }

          module->pid = fr;
          close(module->pipe_in[(signed long int)0]);
          close(module->pipe_out[(signed long int)1]);
          usleep((unsigned int)100);
          ret=waitpid(module->pid, (signed int *)(void *)0, 1);
          if(!(ret == 0))
          {
            MSG(2, "ERROR: Can't load output module %s with binary %s. Bad filename in configuration?", module->name, module->filename);
            destroy_module(module);
            return (struct anonymous$10 *)(void *)0;
          }

          else
          {
            module->working = 1;
            MSG(2, "Module %s loaded.", module->name);
            module->stream_out=fdopen(module->pipe_out[(signed long int)0], "r");
            if(module->stream_out == ((struct _IO_FILE *)NULL))
            {
              fatal_error();
              MSG(-1, "Fatal error [%s:%d]:Can't create a stream for socket, fdopen() failed.", (const void *)"module.c", 245);
              exit(1);
            }

            ret=setvbuf(module->stream_out, (char *)(void *)0, 2, (unsigned long int)4096);
            if(!(ret == 0))
            {
              fatal_error();
              MSG(-1, "Fatal error [%s:%d]:Can't set line buffering, setvbuf failed.", (const void *)"module.c", 250);
              exit(1);
            }

            MSG(4, "Trying to initialize %s.", module->name);
            signed int return_value_output_send_data$15;
            return_value_output_send_data$15=output_send_data("INIT\n", module, 0);
            if(!(return_value_output_send_data$15 == 0))
            {
              MSG(1, "ERROR: Something wrong with %s, can't initialize", module->name);
              output_close(module);
              return (struct anonymous$10 *)(void *)0;
            }

            else
            {
              reply=g_string_new("\n---------------\n");
              signed int return_value_dup$16;
              return_value_dup$16=dup(module->pipe_out[(signed long int)0]);
              f=fdopen(return_value_dup$16, "r");
              while((_Bool)1)
              {
                signed long int return_value_spd_getline$17;
                return_value_spd_getline$17=spd_getline(&rep_line, &n, f);
                ret = (signed int)return_value_spd_getline$17;
                if(!(ret >= 1))
                {
                  MSG(1, "ERROR: Bad syntax from output module %s 1", module->name);
                  if(!(rep_line == ((char *)NULL)))
                    g_free((void *)rep_line);

                  return (struct anonymous$10 *)(void *)0;
                }

                /* assertion rep_line != ((void *)0) */
                assert(rep_line != (char *)(void *)0);
                MSG(5, "Reply from output module: %d %s", n, rep_line);
                if(!(ret >= 5))
                {
                  MSG(1, "ERROR: Bad syntax from output module %s 2", module->name);
                  g_free((void *)rep_line);
                  return (struct anonymous$10 *)(void *)0;
                }

                if(!((signed int)rep_line[3l] == 45))
                {
                  s = rep_line[(signed long int)0];
                  g_free((void *)rep_line);
                  break;
                }

                g_string_append(reply, rep_line + (signed long int)4);
              }
              fclose(f);
              g_string_append_printf(reply, "---------------\n");
              if((signed int)s == 51)
              {
                MSG(1, "ERROR: Module %s failed to initialize. Reason: %s", module->name, reply->str);
                module->working = 0;
                kill(module->pid, 9);
                waitpid(module->pid, (signed int *)(void *)0, 1);
                destroy_module(module);
                g_string_free(reply, (signed int)!(0 != 0));
                return (struct anonymous$10 *)(void *)0;
              }

              else
              {
                if((signed int)s == 50)
                  MSG(2, "Module %s started successfully with message: %s", module->name, reply->str);

                g_string_free(reply, 1);
                if(!(SpeechdOptions.debug == 0))
                {
                  MSG(4, "Switching debugging on for output module %s", module->name);
                  output_module_debug(module);
                }

                ret=output_send_audio_settings(module);
                if(!(ret == 0))
                {
                  MSG(1, "ERROR: Can't initialize audio in output module, see reason above.");
                  module->working = 0;
                  kill(module->pid, 9);
                  waitpid(module->pid, (signed int *)(void *)0, 1);
                  destroy_module(module);
                  return (struct anonymous$10 *)(void *)0;
                }

                else
                {
                  ret=output_send_loglevel_setting(module);
                  if(!(ret == 0))
                  {
                    MSG(1, "ERROR: Can't set the log level inin the output module.");
                    module->working = 0;
                    kill(module->pid, 9);
                    waitpid(module->pid, (signed int *)(void *)0, 1);
                    destroy_module(module);
                    return (struct anonymous$10 *)(void *)0;
                  }

                  else
                    return module;
                }
              }
            }
          }
        }
      }
    }
  }
}

// logging_init
// file speechd.c line 813
void logging_init(void)
{
  char *file_name;
  file_name=g_strdup_printf("%s/speech-dispatcher.log", SpeechdOptions.log_dir);
  /* assertion file_name != ((void *)0) */
  assert(file_name != (char *)(void *)0);
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(file_name, "stdout", (unsigned long int)6);
  signed int return_value_strncmp$1;
  if(return_value_strncmp$2 == 0)
    logfile = stdout;

  else
  {
    return_value_strncmp$1=strncmp(file_name, "stderr", (unsigned long int)6);
    if(return_value_strncmp$1 == 0)
      logfile = stderr;

    else
    {
      logfile=fopen(file_name, "a");
      if(logfile == ((struct _IO_FILE *)NULL))
      {
        fprintf(stderr, "Error: can't open logging file %s! Using stdout.\n", file_name);
        logfile = stdout;
      }

      else
        MSG(3, "Speech Dispatcher Logging to file %s", file_name);
    }
  }
  if(debug_logfile == ((struct _IO_FILE *)NULL))
    debug_logfile = stdout;

  g_free((void *)file_name);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// main
// file speechd.c line 920
signed int main(signed int argc, char **argv)
{
  struct anonymous$23 testfds;
  signed int fd;
  signed int ret;
  char *spawn_communication_method = (char *)(void *)0;
  signed int spawn_port = 0;
  char *spawn_socket_path = (char *)(void *)0;
  g_thread_init((void *)0);
  umask((unsigned int)007);
  logfile = stdout;
  SpeechdOptions.log_level = 1;
  custom_logfile = (struct _IO_FILE *)(void *)0;
  custom_log_kind = (char *)(void *)0;
  i18n_init();
  speechd_options_init();
  options_parse(argc, argv);
  if(!(SpeechdOptions.spawn == 0))
  {
    if(!(SpeechdOptions.communication_method_set == 0))
    {
      spawn_communication_method=g_strdup(SpeechdOptions.communication_method);
      g_free((void *)SpeechdOptions.communication_method);
      SpeechdOptions.communication_method_set = 0;
    }

    if(!(SpeechdOptions.port_set == 0))
    {
      spawn_port = SpeechdOptions.port;
      SpeechdOptions.port_set = 0;
    }

    if(!(SpeechdOptions.socket_path_set == 0))
    {
      spawn_socket_path=g_strdup(SpeechdOptions.socket_path);
      g_free((void *)SpeechdOptions.socket_path);
      SpeechdOptions.socket_path_set = 0;
    }

  }

  MSG(1, "Speech Dispatcher 0.8 starting");
  const char *user_runtime_dir;
  const char *user_config_dir;
  user_runtime_dir=g_get_user_runtime_dir();
  user_config_dir=g_get_user_config_dir();
  SpeechdOptions.runtime_speechd_dir=g_strdup_printf("%s/speech-dispatcher", user_runtime_dir);
  MSG(4, "Trying to find %s", SpeechdOptions.runtime_speechd_dir);
  g_mkdir_with_parents(SpeechdOptions.runtime_speechd_dir, 0400 | 0200 | 0100);
  MSG(4, "Using directory: %s for pidfile and logging", SpeechdOptions.runtime_speechd_dir);
  if(SpeechdOptions.pid_file == ((char *)NULL))
  {
    SpeechdOptions.pid_file=g_strdup_printf("%s/pid/speech-dispatcher.pid", SpeechdOptions.runtime_speechd_dir);
    char *return_value_g_path_get_dirname$1;
    return_value_g_path_get_dirname$1=g_path_get_dirname(SpeechdOptions.pid_file);
    mkdir(return_value_g_path_get_dirname$1, (unsigned int)(0400 | 0200 | 0100));
  }

  if(SpeechdOptions.conf_dir == ((char *)NULL))
  {
    SpeechdOptions.conf_dir=g_build_filename(user_config_dir, (const void *)"speech-dispatcher", (void *)0);
    signed int return_value_g_file_test$3;
    return_value_g_file_test$3=g_file_test(SpeechdOptions.conf_dir, (enum anonymous$15)G_FILE_TEST_IS_DIR);
    if(return_value_g_file_test$3 == 0)
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp("/etc/speech-dispatcher", "");
      if(!(return_value_strcmp$2 == 0))
        SpeechdOptions.conf_dir=g_strdup("/etc/speech-dispatcher");

      else
        SpeechdOptions.conf_dir=g_strdup("/etc/speech-dispatcher/");
    }

  }

  SpeechdOptions.conf_file=g_strdup_printf("%s/speechd.conf", SpeechdOptions.conf_dir);
  signed int return_value_create_pid_file$4;
  return_value_create_pid_file$4=create_pid_file();
  if(!(return_value_create_pid_file$4 == 0))
    exit(1);

  if(!(SpeechdOptions.spawn == 0))
  {
    char *config_contents;
    signed int err;
    struct _GRegex *regexp;
    signed int result;
    err=g_file_get_contents(SpeechdOptions.conf_file, &config_contents, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);
    if(err == 0)
    {
      MSG(-1, "Error openning %s", SpeechdOptions.conf_file);
      fatal_error();
      MSG(-1, "Fatal error [%s:%d]:Can't open conf file", (const void *)"speechd.c", 1029);
      exit(1);
    }

    regexp=g_regex_new("^[ ]*DisableAutoSpawn", (enum anonymous$19)G_REGEX_MULTILINE, (enum anonymous$20)0, (struct _GError **)(void *)0);
    result=g_regex_match(regexp, config_contents, (enum anonymous$20)0, (struct _GMatchInfo **)(void *)0);
    if(!(result == 0))
    {
      MSG(-1, "Autospawn requested but disabled in configuration");
      exit(1);
    }

    g_free((void *)config_contents);
    g_regex_unref(regexp);
    MSG(2, "Starting Speech Dispatcher due to auto-spawn");
  }

  ret=pthread_mutex_init(&logging_mutex, (const union anonymous$13 *)(void *)0);
  if(!(ret == 0))
  {
    fprintf(stderr, "Mutex initialization failed");
    exit(1);
  }

  signal(2, speechd_quit);
  signal(1, speechd_load_configuration);
  signal(13, (void (*)(signed int))1);
  signal(10, speechd_reload_dead_modules);
  speechd_init();
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(SpeechdOptions.socket_path, "default");
  if(return_value_strcmp$5 == 0)
  {
    struct _GString *socket_filename;
    socket_filename=g_string_new("");
    if(!(SpeechdOptions.runtime_speechd_dir == ((char *)NULL)))
      g_string_printf(socket_filename, "%s/speechd.sock", SpeechdOptions.runtime_speechd_dir);

    else
    {
      fatal_error();
      MSG(-1, "Fatal error [%s:%d]:Socket name file not set and user has no runtime directory", (const void *)"speechd.c", 1073);
      exit(1);
    }
    g_free((void *)SpeechdOptions.socket_path);
    SpeechdOptions.socket_path=g_strdup(socket_filename->str);
    g_string_free(socket_filename, 1);
  }

  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  if(!(SpeechdOptions.spawn == 0))
  {
    if(!(spawn_communication_method == ((char *)NULL)))
    {
      signed int return_value_strcmp$9;
      return_value_strcmp$9=strcmp(spawn_communication_method, SpeechdOptions.communication_method);
      if(!(return_value_strcmp$9 == 0))
      {
        MSG(-1, "Autospawn failed: Mismatch in communication methods. Client requests %s, most probably due to its configuration or the value of the SPEECHD_ADDRESS environment variable, but the server is configured to provide the %s method.", spawn_communication_method, SpeechdOptions.communication_method);
        exit(1);
      }

      else
      {
        signed int return_value_strcmp$8;
        return_value_strcmp$8=strcmp(SpeechdOptions.communication_method, "inet_socket");
        if(return_value_strcmp$8 == 0)
        {
          if(!(spawn_port == 0))
          {
            if(!(spawn_port == SpeechdOptions.port))
            {
              MSG(-1, "Autospawn failed: Mismatch in port numbers. Server is configured to use the inet_socket method on the port %d while the client requests port %d, most probably due to its configuration or the value of the SPEECHD_ADDRESS environment variable.", SpeechdOptions.port, spawn_port);
              exit(1);
            }

          }

        }

        else
        {
          return_value_strcmp$7=strcmp(SpeechdOptions.communication_method, "unix_socket");
          if(return_value_strcmp$7 == 0)
          {
            if(!(spawn_socket_path == ((char *)NULL)))
            {
              return_value_strcmp$6=strcmp(spawn_socket_path, SpeechdOptions.socket_path);
              if(!(return_value_strcmp$6 == 0))
              {
                MSG(-1, "Autospawn failed: Mismatch in socket names. The server is configured to provide a socket interface in %s, but the client requests a different path: %s. This is most probably due to the client application configuration or the value of the SPEECHD_ADDRESS environment variable.", SpeechdOptions.socket_path, spawn_socket_path);
                exit(1);
              }

            }

          }

          else
            /* assertion 0 */
            assert(0 != 0);
        }
      }
    }

    g_free((void *)spawn_communication_method);
    g_free((void *)spawn_socket_path);
  }

  signed int return_value_strcmp$13;
  return_value_strcmp$13=strcmp(SpeechdOptions.communication_method, "inet_socket");
  signed int return_value_strcmp$12;
  signed int return_value_g_unlink$10;
  if(return_value_strcmp$13 == 0)
  {
    MSG(4, "Speech Dispatcher will use inet port %d", SpeechdOptions.port);
    server_socket=make_inet_socket(SpeechdOptions.port);
  }

  else
  {
    return_value_strcmp$12=strcmp(SpeechdOptions.communication_method, "unix_socket");
    if(return_value_strcmp$12 == 0)
    {
      MSG(4, "Speech Dispatcher will use local unix socket: %s", SpeechdOptions.socket_path);
      signed int return_value_g_file_test$11;
      return_value_g_file_test$11=g_file_test(SpeechdOptions.socket_path, (enum anonymous$15)G_FILE_TEST_EXISTS);
      if(!(return_value_g_file_test$11 == 0))
      {
        return_value_g_unlink$10=g_unlink(SpeechdOptions.socket_path);
        if(return_value_g_unlink$10 == -1)
        {
          fatal_error();
          MSG(-1, "Fatal error [%s:%d]:Local socket file exists but impossible to delete. Wrong permissions?", (const void *)"speechd.c", 1156);
          exit(1);
        }

      }

      server_socket=make_local_socket(SpeechdOptions.socket_path);
    }

    else
    {
      fatal_error();
      MSG(-1, "Fatal error [%s:%d]:Unknown communication method", (const void *)"speechd.c", 1160);
      exit(1);
    }
  }
  if((signed int)spd_mode == SPD_MODE_DAEMON)
  {
    signed int return_value_daemon$14;
    return_value_daemon$14=daemon(0, 0);
    if(!(return_value_daemon$14 == 0))
    {
      fatal_error();
      MSG(-1, "Fatal error [%s:%d]:Can't fork child process", (const void *)"speechd.c", 1166);
      exit(1);
    }

    unlink(SpeechdOptions.pid_file);
    signed int return_value_create_pid_file$15;
    return_value_create_pid_file$15=create_pid_file();
    if(return_value_create_pid_file$15 == -1)
      return -1;

  }

  MSG(4, "Creating new thread for speak()");
  ret=pthread_create(&speak_thread, (const union pthread_attr_t *)(void *)0, speak, (void *)0);
  if(!(ret == 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Speak thread failed!\n", (const void *)"speechd.c", 1177);
    exit(1);
  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$23) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&readfds)->fds_bits[(signed long int)(server_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(server_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << server_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  SpeechdStatus.max_fd = server_socket;
  MSG(1, "Speech Dispatcher started and waiting for clients ...");
  while((_Bool)1)
  {
    testfds = readfds;
    signed int return_value_select$17;
    return_value_select$17=select(1024, &testfds, (struct anonymous$23 *)0, (struct anonymous$23 *)0, (struct timeval *)(void *)0);
    if(return_value_select$17 >= 1)
    {
      fd = 0;
      for( ; SpeechdStatus.max_fd >= fd && !(fd >= 1024); fd = fd + 1)
        if(!((testfds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        {
          MSG(4, "Activity on fd %d ...", fd);
          if(fd == server_socket)
          {
            ret=speechd_connection_new(server_socket);
            if(!(ret == 0))
              MSG(2, "Error: Failed to add new client!");

          }

          else
          {
            signed int nread;
            ioctl(fd, (unsigned long int)0x541B, &nread);
            if(nread == 0)
            {
              speechd_connection_destroy(fd);
              if(!(ret == 0))
                MSG(2, "Error: Failed to close the client!");

            }

            else
            {
              signed int return_value_serve$16;
              return_value_serve$16=serve(fd);
              if(return_value_serve$16 == -1)
                MSG(2, "Error: Failed to serve client on fd %d!", fd);

            }
          }
        }

    }

  }
}

// make_inet_socket
// file speechd.c line 874
signed int make_inet_socket(const signed int port)
{
  struct sockaddr_in server_address;
  signed int make_inet_socket$$1$$server_socket;
  make_inet_socket$$1$$server_socket=socket(2, 1, 0);
  if(!(make_inet_socket$$1$$server_socket >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Can't create inet socket", (const void *)"speechd.c", 882);
    exit(1);
  }

  const signed int flag = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(make_inet_socket$$1$$server_socket, 1, 2, (const void *)&flag, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt$1 == 0))
    MSG(2, "Error: Setting socket option failed!");

  server_address.sin_family = (unsigned short int)2;
  if(!(SpeechdOptions.localhost_access_only == 0))
    server_address.sin_addr.s_addr=htonl((unsigned int)0x7f000001);

  else
    server_address.sin_addr.s_addr=htonl((unsigned int)0x00000000);
  server_address.sin_port=htons((unsigned short int)port);
  MSG(4, "Openning inet socket connection");
  signed int return_value_bind$4;
  return_value_bind$4=bind(make_inet_socket$$1$$server_socket, (struct sockaddr *)&server_address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(return_value_bind$4 == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    MSG(-1, "bind() failed: %s", return_value_strerror$3);
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't open inet socket, try a few minutes later.", (const void *)"speechd.c", 906);
    exit(1);
  }

  signed int return_value_listen$7;
  return_value_listen$7=listen(make_inet_socket$$1$$server_socket, 50);
  if(return_value_listen$7 == -1)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    MSG(2, "ERRNO:%s", return_value_strerror$6);
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:listen() failed for inet socket, another Speech Dispatcher running?", (const void *)"speechd.c", 912);
    exit(1);
  }

  return make_inet_socket$$1$$server_socket;
}

// make_local_socket
// file speechd.c line 844
signed int make_local_socket(const char *filename)
{
  struct sockaddr_un name;
  signed int sock;
  unsigned long int size;
  sock=socket(1, 1, 0);
  if(!(sock >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Can't create local socket", (const void *)"speechd.c", 853);
    exit(1);
  }

  name.sun_family = (unsigned short int)1;
  strncpy(name.sun_path, filename, sizeof(char [108l]) /*108ul*/ );
  name.sun_path[(signed long int)(sizeof(char [108l]) /*108ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((&name)->sun_path);
  size = (unsigned long int)((struct sockaddr_un *)0)->sun_path + return_value_strlen$1;
  signed int return_value_bind$2;
  return_value_bind$2=bind(sock, (struct sockaddr *)&name, (unsigned int)size);
  if(!(return_value_bind$2 >= 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Can't bind local socket", (const void *)"speechd.c", 863);
    exit(1);
  }

  signed int return_value_listen$5;
  return_value_listen$5=listen(sock, 50);
  if(return_value_listen$5 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    MSG(2, "listen failed: ERRNO:%s", return_value_strerror$4);
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:listen() failed for local socket", (const void *)"speechd.c", 868);
    exit(1);
  }

  return sock;
}

// mem_free_fdset
// file alloc.h line 14
void mem_free_fdset(struct anonymous$11 *fdset)
{
  g_free((void *)fdset->client_name);
  g_free((void *)fdset->msg_settings.voice.language);
  g_free((void *)fdset->msg_settings.voice.name);
  g_free((void *)fdset->output_module);
  g_free((void *)fdset->index_mark);
  g_free((void *)fdset->audio_output_method);
  g_free((void *)fdset->audio_oss_device);
  g_free((void *)fdset->audio_alsa_device);
  g_free((void *)fdset->audio_nas_server);
  g_free((void *)fdset->audio_pulse_server);
}

// mem_free_message
// file alloc.h line 11
void mem_free_message(struct anonymous$7 *msg)
{
  if(!(msg == ((struct anonymous$7 *)NULL)))
  {
    g_free((void *)msg->buf);
    mem_free_fdset(&msg->settings);
    g_free((void *)msg);
  }

}

// message_compare_id
// file history.c line 41
signed int message_compare_id(const void *element, const void *value)
{
  signed int ret = (signed int)(((struct anonymous$7 *)element)->id - (unsigned int)*((signed int *)value));
  return ret;
}

// message_has_uid
// file speaking.c line 1046
signed int message_has_uid(const void *msg, const void *uid)
{
  if(((struct anonymous$7 *)msg)->settings.uid == (unsigned int)*((signed int *)uid))
    return 0;

  else
    return 1;
}

// message_nto_speak
// file speaking.c line 872
signed int message_nto_speak(const void *data, const void *nothing)
{
  struct anonymous$11 *global_settings;
  struct anonymous$7 *message = (struct anonymous$7 *)data;
  if(message == ((struct anonymous$7 *)NULL))
    return 0;

  else
  {
    global_settings=get_client_settings_by_fd(message->settings.fd);
    if(global_settings == ((struct anonymous$11 *)NULL))
      return 0;

    else
      if(global_settings->paused == 0)
        return 0;

      else
        return 1;
  }
}

// module_add_load_request
// file module.h line 53
void module_add_load_request(char *module_name, char *module_cmd, char *module_cfgfile, char *module_dbgfile)
{
  char **module_params = (char **)(void *)0;
  signed int return_value_module_already_requested$1;
  return_value_module_already_requested$1=module_already_requested(module_name, module_cmd, module_cfgfile);
  if(!(return_value_module_already_requested$1 == 0))
  {
    MSG(1, "Load request for module %s with command %s and configuration file %s was previously received; ignoring the second one.", module_name, module_cmd, module_cfgfile);
    g_free((void *)module_name);
    g_free((void *)module_cmd);
    g_free((void *)module_cfgfile);
    g_free((void *)module_dbgfile);
  }

  else
  {
    void *return_value_g_malloc$2;
    return_value_g_malloc$2=g_malloc((unsigned long int)4 * sizeof(char *) /*8ul*/ );
    module_params = (char **)return_value_g_malloc$2;
    module_params[(signed long int)0] = module_name;
    module_params[(signed long int)1] = module_cmd;
    module_params[(signed long int)2] = module_cfgfile;
    module_params[(signed long int)3] = module_dbgfile;
    requested_modules=g_list_append(requested_modules, (void *)module_params);
    MSG(5, "Module name=%s being inserted into requested_modules list", module_params[(signed long int)0]);
  }
}

// module_already_requested
// file module.c line 455
signed int module_already_requested(char *module_name, char *module_cmd, char *module_cfgfile)
{
  struct _GList *lp = requested_modules;
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  for( ; !(lp == ((struct _GList *)NULL)); lp = lp->next)
  {
    char **params = (char **)lp->data;
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(module_name, params[(signed long int)0]);
    if(return_value_strcmp$1 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcmp$2=strcmp(module_cmd, params[(signed long int)1]);
      if(return_value_strcmp$2 == 0)
      {
        return_value_strcmp$3=strcmp(module_cfgfile, params[(signed long int)2]);
        tmp_if_expr$4 = return_value_strcmp$3 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      return (signed int)!(0 != 0);

  }
  return 0;
}

// module_load_requested_modules
// file module.h line 55
void module_load_requested_modules(void)
{
  while(!(requested_modules == ((struct _GList *)NULL)))
  {
    struct anonymous$10 *new_module;
    char **module_params = (char **)requested_modules->data;
    new_module=load_output_module(module_params[(signed long int)0], module_params[(signed long int)1], module_params[(signed long int)2], module_params[(signed long int)3]);
    if(!(new_module == ((struct anonymous$10 *)NULL)))
      output_modules=g_list_append(output_modules, (void *)new_module);

    g_free((void *)module_params[(signed long int)0]);
    g_free((void *)module_params[(signed long int)1]);
    g_free((void *)module_params[(signed long int)2]);
    g_free((void *)module_params[(signed long int)3]);
    g_free((void *)module_params);
    requested_modules=g_list_delete_link(requested_modules, requested_modules);
  }
}

// options_parse
// file options.h line 28
void options_parse(signed int argc, char **argv)
{
  char *tail_ptr;
  signed int c_opt;
  signed int option_index;
  signed int val;
  signed int ret;
  char *tmpdir;
  char *debug_logfile_path;
  /* assertion argc > 0 */
  assert(argc > 0);
  /* assertion argv */
  assert(argv != ((char **)NULL));
  signed long int return_value_strtol$1;
  signed long int return_value_strtol$2;
  char *return_value_getenv$3;
  while((_Bool)1)
  {
    option_index = 0;
    c_opt=getopt_long(argc, argv, spd_short_options, spd_long_options, &option_index);
    if(c_opt == -1)
      break;

    switch(c_opt)
    {
      case 100:
      {
        spd_mode = (enum anonymous$25)SPD_MODE_DAEMON;
        break;
      }
      case 115:
      {
        spd_mode = (enum anonymous$25)SPD_MODE_SINGLE;
        break;
      }
      case 108:
      {
        return_value_strtol$1=strtol(optarg, &tail_ptr, 10);
        val = (signed int)return_value_strtol$1;
        if(!(tail_ptr == optarg))
        {
          SpeechdOptions.log_level_set = 1;
          SpeechdOptions.log_level = val;
        }

        break;
      }
      case 76:
      {
        SpeechdOptions.log_dir=g_strdup(optarg);
        SpeechdOptions.log_dir_set = 1;
        break;
      }
      case 99:
      {
        SpeechdOptions.communication_method=g_strdup(optarg);
        SpeechdOptions.communication_method_set = 1;
        break;
      }
      case 83:
      {
        SpeechdOptions.socket_path=g_strdup(optarg);
        SpeechdOptions.socket_path_set = 1;
        break;
      }
      case 112:
      {
        return_value_strtol$2=strtol(optarg, &tail_ptr, 10);
        val = (signed int)return_value_strtol$2;
        if(!(tail_ptr == optarg))
        {
          SpeechdOptions.port_set = 1;
          SpeechdOptions.port = val;
        }

        break;
      }
      case 97:
      {
        SpeechdOptions.spawn = (signed int)!(0 != 0);
        break;
      }
      case 80:
      {
        SpeechdOptions.pid_file=g_strdup(optarg);
        break;
      }
      case 67:
      {
        SpeechdOptions.conf_dir=g_strdup(optarg);
        break;
      }
      case 118:
      {
        options_print_version();
        exit(0);
        break;
      }
      case 68:
      {
        return_value_getenv$3=getenv("TMPDIR");
        tmpdir=g_strdup(return_value_getenv$3);
        if(tmpdir == ((char *)NULL))
          tmpdir=g_strdup("/tmp");

        SpeechdOptions.debug_destination=g_strdup_printf("%s/speechd-debug", tmpdir);
        g_free((void *)tmpdir);
        ret=mkdir(SpeechdOptions.debug_destination, (unsigned int)(0400 | 0200 | 0100));
        if(!(ret == 0))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          char *return_value_strerror$6;
          return_value_strerror$6=strerror(*return_value___errno_location$5);
          MSG(1, "Can't create additional debug destination in %s, reason %d-%s", SpeechdOptions.debug_destination, *return_value___errno_location$4, return_value_strerror$6);
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          if(*return_value___errno_location$7 == 17)
            MSG(1, "Debugging directory %s already exists, please delete it first", SpeechdOptions.debug_destination);

          exit(1);
        }

        debug_logfile_path=g_strdup_printf("%s/speech-dispatcher.log", SpeechdOptions.debug_destination);
        debug_logfile=fopen(debug_logfile_path, "wx");
        g_free((void *)debug_logfile_path);
        if(debug_logfile == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          char *return_value_strerror$10;
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          MSG(1, "Error: can't open additional debug logging file %s [%d-%s]!\n", debug_logfile_path, *return_value___errno_location$8, return_value_strerror$10);
          exit(1);
        }

        SpeechdOptions.debug = 1;
        break;
      }
      case 104:
      {
        options_print_help(argv);
        exit(0);
        break;
      }
      default:
      {
        MSG(2, "Unrecognized option\n");
        options_print_help(argv);
        exit(1);
      }
    }
  }
}

// options_print_help
// file options.c line 58
void options_print_help(char **argv)
{
  /* assertion argv */
  assert(argv != ((char **)NULL));
  /* assertion argv[0] */
  assert(argv[(signed long int)0] != ((char *)NULL));
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Usage: ");
  printf(return_value_gettext$1);
  printf("%s [-{d|s}] [-l {1|2|3|4|5}] [-c com_method] [-S socket_path] [-p port] | [-v] | [-h]\n", argv[(signed long int)0]);
  char *return_value_gettext$2;
  return_value_gettext$2=gettext("%s -- Common interface for Speech Synthesis %s\n\n");
  printf(return_value_gettext$2, (const void *)"Speech Dispatcher", (const void *)"(GNU GPL)");
  printf("-d, --run-daemon\t");
  char *return_value_gettext$3;
  return_value_gettext$3=gettext("Run as a daemon\n");
  printf(return_value_gettext$3);
  printf("-s, --run-single\t");
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Run as single application\n");
  printf(return_value_gettext$4);
  printf("-a, --spawn\t\t");
  char *return_value_gettext$5;
  return_value_gettext$5=gettext("Start only if autospawn is not disabled\n");
  printf(return_value_gettext$5);
  printf("-l, --log-level\t\t");
  char *return_value_gettext$6;
  return_value_gettext$6=gettext("Set log level (between %d and %d)\n");
  printf(return_value_gettext$6, 1, 5);
  printf("-L, --log-dir\t\t");
  char *return_value_gettext$7;
  return_value_gettext$7=gettext("Set path to logging\n");
  printf(return_value_gettext$7);
  printf("-c, --communication-method\t");
  char *return_value_gettext$8;
  return_value_gettext$8=gettext("Communication method to use ('%s' or '%s')\n");
  printf(return_value_gettext$8, (const void *)"unix_socket", (const void *)"inet_socket");
  printf("-S, --socket-path\t");
  char *return_value_gettext$9;
  return_value_gettext$9=gettext("Socket path to use for '%s' method (filesystem path or '%s')\n");
  printf(return_value_gettext$9, (const void *)"unix_socket", (const void *)"default");
  printf("-p, --port\t\t");
  char *return_value_gettext$10;
  return_value_gettext$10=gettext("Specify a port number for '%s' method\n");
  printf(return_value_gettext$10, (const void *)"inet_socket");
  printf("-P, --pid-file\t\t");
  char *return_value_gettext$11;
  return_value_gettext$11=gettext("Set path to pid file\n");
  printf(return_value_gettext$11);
  printf("-C, --config-dir\t");
  char *return_value_gettext$12;
  return_value_gettext$12=gettext("Set path to configuration\n");
  printf(return_value_gettext$12);
  printf("-v, --version\t\t");
  char *return_value_gettext$13;
  return_value_gettext$13=gettext("Report version of this program\n");
  printf(return_value_gettext$13);
  printf("-D, --debug\t\t");
  char *return_value_gettext$14;
  return_value_gettext$14=gettext("Output debugging information into %s\n");
  printf(return_value_gettext$14, (const void *)"/tmp/.speech-dispatcher");
  printf("-h, --help\t\t");
  char *return_value_gettext$15;
  return_value_gettext$15=gettext("Print this info\n");
  printf(return_value_gettext$15);
  printf("\n");
  char *return_value_gettext$16;
  return_value_gettext$16=gettext("Copyright (C) %d-%d Brailcom, o.p.s.\nThis is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version. Please see COPYING for more details.\n\nPlease report bugs to %s\n\n");
  printf(return_value_gettext$16, 2002, 2012, (const void *)"speechd@lists.freebsoft.org");
}

// options_print_version
// file options.c line 110
void options_print_version(void)
{
  printf("%s %s\n", (const void *)"speech-dispatcher", (const void *)"0.8");
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Copyright (C) %d-%d Brailcom, o.p.s.\n%s comes with ABSOLUTELY NO WARRANTY.\nYou may redistribute copies of this program\nunder the terms of the GNU General Public License.\nFor more information about these matters, see the file named COPYING.\n");
  printf(return_value_gettext$1, 2002, 2012, (const void *)"Speech Dispatcher");
}

// output_check_module
// file output.h line 35
signed int output_check_module(struct anonymous$10 *output)
{
  signed int ret;
  signed int err;
  signed int status;
  if(output == ((struct anonymous$10 *)NULL))
    return -1;

  else
  {
    MSG(4, "Output module working status: %d (pid:%d)", output->working, output->pid);
    if(output->working == 0)
    {
      ret=waitpid(output->pid, &status, 1);
      if(ret == 0)
      {
        MSG(2, "Output module not running.");
        return 0;
      }

      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      ret = (signed int)((((union anonymous){ .__in=status }).__i & 0x7f) == 0);
      MSG(2, "Output module terminated abnormally, probably crashed.");
    }

    return 0;
  }
}

// output_close
// file output.h line 49
signed int output_close(struct anonymous$10 *module)
{
  signed int err;
  signed int ret;
  struct anonymous$10 *output = module;
  if(output == ((struct anonymous$10 *)NULL))
    return -1;

  else
  {
    output_lock();
    /* assertion output->name != ((void *)0) */
    assert(output->name != (char *)(void *)0);
    MSG(3, "Closing module \"%s\"...", output->name);
    if(!(output->working == 0))
    {
      err=output_send_data("STOP\n", output, 0);
      if(!(err >= 0))
      {
        output_unlock();
        return err;
      }

      err=output_send_data("QUIT\n", output, 1);
      if(!(err >= 0))
      {
        output_unlock();
        return err;
      }

      usleep((unsigned int)100);
    }

    MSG(4, "Waiting for module pid %d", module->pid);
    ret=waitpid_with_timeout(module->pid, (signed int *)(void *)0, 0, (unsigned long int)1000);
    if(ret >= 1)
      MSG(4, "Ok, module closed successfully.");

    else
      if(ret == 0)
      {
        signed int ret2;
        MSG(1, "ERROR: Timed out when waiting for child cancellation");
        MSG(3, "Killing the module");
        kill(module->pid, 9);
        MSG(4, "Waiting until the child terminates.");
        ret2=waitpid_with_timeout(module->pid, (signed int *)(void *)0, 0, (unsigned long int)1000);
        if(ret2 >= 1)
          MSG(3, "Module terminated");

        else
          MSG(1, "ERROR: Module is not able to terminate, giving up.");
      }

      else
        MSG(1, "ERROR: waitpid() failed when waiting for child (module).");
    output_unlock();
    return 0;
  }
}

// output_get_voices
// file output.c line 286
static struct anonymous$6 ** output_get_voices(struct anonymous$10 *module)
{
  struct anonymous$6 **voice_dscr;
  struct _GString *reply;
  char **lines;
  char **atoms;
  signed int i;
  signed int ret = 0;
  signed int errors = 0;
  output_lock();
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(module == ((struct anonymous$10 *)NULL))
  {
    MSG(1, "ERROR: Can't list voices for broken output module");
    output_unlock();
    return (struct anonymous$6 **)(void *)0;
  }

  else
  {
    output_send_data("LIST VOICES\n", module, 0);
    reply=output_read_reply(module);
    if(reply == ((struct _GString *)NULL))
    {
      output_unlock();
      return (struct anonymous$6 **)(void *)0;
    }

    else
    {
      lines=g_strsplit(reply->str, "\n", 256);
      g_string_free(reply, (signed int)!(0 != 0));
      void *return_value_g_malloc$1;
      return_value_g_malloc$1=g_malloc((unsigned long int)256 * sizeof(struct anonymous$6 *) /*8ul*/ );
      voice_dscr = (struct anonymous$6 **)return_value_g_malloc$1;
      i = 0;
      do
      {
        if(errors == 0)
          tmp_if_expr$2 = lines[(signed long int)i] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        MSG(1, "LINE here:|%s|", lines[(signed long int)i]);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(lines[(signed long int)i]);
        if(!(return_value_strlen$6 >= 5ul))
        {
          MSG(1, "ERROR: Bad communication from driver in synth_voices");
          ret = -1;
          errors = (signed int)!(0 != 0);
        }

        else
          if((signed int)lines[(signed long int)i][3l] == 32)
            break;

          else
            if((signed int)lines[(signed long int)i][3l] == 45)
            {
              atoms=g_strsplit(&lines[(signed long int)i][(signed long int)4], " ", 0);
              if(*atoms == ((char *)NULL))
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = atoms[(signed long int)1] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = atoms[(signed long int)2] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$5)
              {
                ret = -1;
                errors = (signed int)!(0 != 0);
              }

              else
              {
                void *return_value_g_malloc$3;
                return_value_g_malloc$3=g_malloc(sizeof(struct anonymous$6) /*24ul*/ );
                voice_dscr[(signed long int)i] = (struct anonymous$6 *)return_value_g_malloc$3;
                voice_dscr[(signed long int)i]->name=g_strdup(atoms[(signed long int)0]);
                voice_dscr[(signed long int)i]->language=g_strdup(atoms[(signed long int)1]);
                voice_dscr[(signed long int)i]->variant=g_strdup(atoms[(signed long int)2]);
              }
              if(!(atoms == ((char **)NULL)))
                g_strfreev(atoms);

            }

        i = i + 1;
      }
      while((_Bool)1);
      voice_dscr[(signed long int)i] = (struct anonymous$6 *)(void *)0;
      g_strfreev(lines);
      output_unlock();
      return voice_dscr;
    }
  }
}

// output_is_speaking
// file output.h line 32
signed int output_is_speaking(char **index_mark)
{
  signed int err;
  struct anonymous$10 *output = speaking_module;
  err=output_module_is_speaking(output, index_mark);
  if(!(err >= 0))
    *index_mark = (char *)(void *)0;

  return err;
}

// output_list_voices
// file output.h line 50
struct anonymous$6 ** output_list_voices(char *module_name)
{
  struct anonymous$10 *module;
  if(module_name == ((char *)NULL))
    return (struct anonymous$6 **)(void *)0;

  else
  {
    module=get_output_module_by_name(module_name);
    if(module == ((struct anonymous$10 *)NULL))
    {
      MSG(1, "ERROR: Can't list voices for module %s", module_name);
      return (struct anonymous$6 **)(void *)0;
    }

    else
    {
      struct anonymous$6 **return_value_output_get_voices$1;
      return_value_output_get_voices$1=output_get_voices(module);
      return return_value_output_get_voices$1;
    }
  }
}

// output_lock
// file output.c line 162
static void output_lock(void)
{
  pthread_mutex_lock(&output_layer_mutex);
}

// output_module_debug
// file module.h line 49
signed int output_module_debug(struct anonymous$10 *module)
{
  char *new_log_path;
  /* assertion module != ((void *)0) */
  assert(module != (struct anonymous$10 *)(void *)0);
  /* assertion module->name != ((void *)0) */
  assert(module->name != (char *)(void *)0);
  if(module->working == 0)
    return -1;

  else
  {
    MSG(4, "Output module debug logging for %s into %s", module->name, SpeechdOptions.debug_destination);
    new_log_path=g_strdup_printf("%s/%s.log", SpeechdOptions.debug_destination, module->name);
    output_send_debug(module, 1, new_log_path);
    return 0;
  }
}

// output_module_is_speaking
// file output.c line 608
signed int output_module_is_speaking(struct anonymous$10 *output, char **index_mark)
{
  struct _GString *response;
  signed int retcode = -1;
  output_lock();
  MSG(5, "output_module_is_speaking()");
  signed int return_value_strncmp$11;
  char *return_value_g_strdup$2;
  signed int return_value_strncmp$10;
  char *return_value_g_strdup$3;
  signed int return_value_strncmp$9;
  char *return_value_g_strdup$4;
  signed int return_value_strncmp$8;
  char *return_value_g_strdup$5;
  signed int return_value_strncmp$7;
  if(output == ((struct anonymous$10 *)NULL))
  {
    MSG(5, "output==NULL in output_module_is_speaking()");
    output_unlock();
    return -1;
  }

  else
  {
    response=output_read_reply(output);
    if(response == ((struct _GString *)NULL))
    {
      *index_mark = (char *)(void *)0;
      output_unlock();
      return -1;
    }

    else
    {
      MSG2(5, "output_module", "Reply from output module: |%s|", response->str);
      if(!(response->len >= 4ul))
      {
        MSG2(2, "output_module", "Error: Wrong communication from output module! Reply less than four bytes.");
        g_string_free(response, (signed int)!(0 != 0));
        output_unlock();
        return -1;
      }

      else
      {
        switch((signed int)response->str[(signed long int)0])
        {
          case 51:
          {
            MSG(2, "Error: Module reported error in request from speechd (code 3xx).");
            retcode = -2;
            break;
          }
          case 52:
          {
            MSG(2, "Error: Module reported error in itself (code 4xx).");
            retcode = -3;
            break;
          }
          case 50:
          {
            retcode = 0;
            if(response->len >= 5ul)
            {
              if((signed int)response->str[3l] == 45)
              {
                char *p;
                p=strchr(response->str, 10);
                char *return_value_strndup$1;
                return_value_strndup$1=strndup(response->str + (signed long int)4, (unsigned long int)((p - response->str) - (signed long int)4));
                *index_mark = (char *)return_value_strndup$1;
                MSG2(5, "output_module", "Detected INDEX MARK: %s", *index_mark);
              }

              else
              {
                MSG2(2, "output_module", "Error: Wrong communication from output module!Reply on SPEAKING not multi-line.");
                retcode = -1;
              }
            }

            break;
          }
          case 55:
          {
            retcode = 0;
            MSG2(5, "output_module", "Received event:\n %s", response->str);
            return_value_strncmp$11=strncmp(response->str, "701", (unsigned long int)3);
            if(return_value_strncmp$11 == 0)
            {
              return_value_g_strdup$2=g_strdup("__spd_begin");
              *index_mark = (char *)return_value_g_strdup$2;
            }

            else
            {
              return_value_strncmp$10=strncmp(response->str, "702", (unsigned long int)3);
              if(return_value_strncmp$10 == 0)
              {
                return_value_g_strdup$3=g_strdup("__spd_end");
                *index_mark = (char *)return_value_g_strdup$3;
              }

              else
              {
                return_value_strncmp$9=strncmp(response->str, "703", (unsigned long int)3);
                if(return_value_strncmp$9 == 0)
                {
                  return_value_g_strdup$4=g_strdup("__spd_stopped");
                  *index_mark = (char *)return_value_g_strdup$4;
                }

                else
                {
                  return_value_strncmp$8=strncmp(response->str, "704", (unsigned long int)3);
                  if(return_value_strncmp$8 == 0)
                  {
                    return_value_g_strdup$5=g_strdup("__spd_paused");
                    *index_mark = (char *)return_value_g_strdup$5;
                  }

                  else
                  {
                    return_value_strncmp$7=strncmp(response->str, "700", (unsigned long int)3);
                    if(return_value_strncmp$7 == 0)
                    {
                      char *output_module_is_speaking$$1$$4$$2$$p;
                      output_module_is_speaking$$1$$4$$2$$p=strchr(response->str, 10);
                      MSG2(5, "output_module", "response:|%s|\n p:|%s|", response->str, output_module_is_speaking$$1$$4$$2$$p);
                      char *return_value_strndup$6;
                      return_value_strndup$6=strndup(response->str + (signed long int)4, (unsigned long int)((output_module_is_speaking$$1$$4$$2$$p - response->str) - (signed long int)4));
                      *index_mark = (char *)return_value_strndup$6;
                      MSG2(5, "output_module", "Detected INDEX MARK: %s", *index_mark);
                    }

                    else
                    {
                      MSG2(2, "output_module", "ERROR: Unknown event received from output module");
                      retcode = -5;
                    }
                  }
                }
              }
            }
            break;
          }
          default:
          {
            MSG(3, "Unknown response from output module!");
            retcode = -3;
          }
        }
        g_string_free(response, (signed int)!(0 != 0));
        output_unlock();
        return retcode;
      }
    }
  }
}

// output_module_nodebug
// file module.h line 50
signed int output_module_nodebug(struct anonymous$10 *module)
{
  /* assertion module != ((void *)0) */
  assert(module != (struct anonymous$10 *)(void *)0);
  /* assertion module->name != ((void *)0) */
  assert(module->name != (char *)(void *)0);
  if(module->working == 0)
    return -1;

  else
  {
    MSG(4, "Output module debug logging off for", module->name);
    output_send_debug(module, 0, (char *)(void *)0);
    return 0;
  }
}

// output_pause
// file output.h line 31
unsigned long int output_pause()
{
  output_lock();
  static struct anonymous$10 *output;
  if(speaking_module == ((struct anonymous$10 *)NULL))
  {
    output_unlock();
    return (unsigned long int)0;
  }

  else
    output = speaking_module;
  MSG(4, "Module pause!");
  static signed int err;
  err=output_send_data("PAUSE\n", output, 0);
  if(!(err >= 0))
  {
    output_unlock();
    return (unsigned long int)err;
  }

  else
  {
    output_unlock();
    return (unsigned long int)0;
  }
}

// output_read_reply
// file output.c line 178
struct _GString * output_read_reply(struct anonymous$10 *output)
{
  struct _GString *rstr;
  signed int bytes;
  char *line = (char *)(void *)0;
  unsigned long int N = (unsigned long int)0;
  signed int errors = 0;
  rstr=g_string_new("");
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$2;
  do
  {
    signed long int return_value_spd_getline$4;
    return_value_spd_getline$4=spd_getline(&line, &N, output->stream_out);
    bytes = (signed int)return_value_spd_getline$4;
    if(bytes == -1)
    {
      MSG(2, "Error: Broken pipe to module.");
      output->working = 0;
      speaking_module = (struct anonymous$10 *)(void *)0;
      output_check_module(output);
      errors = (signed int)!(0 != 0);
    }

    else
    {
      MSG(5, "Got %d bytes from output module over socket", bytes);
      g_string_append(rstr, line);
    }
    if(errors == 0)
    {
      return_value_strlen$1=strlen(line);
      if(!(return_value_strlen$1 >= 4ul))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)line[(signed long int)3] == 32 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$3 = !tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  if(!(line == ((char *)NULL)))
    g_free((void *)line);

  if(!(errors == 0))
  {
    g_string_free(rstr, (signed int)!(0 != 0));
    rstr = (struct _GString *)(void *)0;
  }

  return rstr;
}

// output_read_reply2
// file output.c line 217
char * output_read_reply2(struct anonymous$10 *output)
{
  signed int bytes;
  char *reply;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)1024 * sizeof(char) /*1ul*/ );
  reply = (char *)return_value_g_malloc$1;
  signed long int return_value_read$2;
  return_value_read$2=read(output->pipe_out[(signed long int)0], (void *)reply, (unsigned long int)1024);
  bytes = (signed int)return_value_read$2;
  reply[(signed long int)bytes] = (char)0;
  MSG2(1, "output_module", "2Read: %d bytes: <%s>", bytes, reply);
  return reply;
}

// output_send_audio_settings
// file output.h line 44
signed int output_send_audio_settings(struct anonymous$10 *output)
{
  struct _GString *set_str;
  signed int err;
  MSG(4, "Module set parameters.");
  set_str=g_string_new("");
  if(!(GlobalFDSet.audio_output_method == ((char *)NULL)))
    g_string_append_printf(set_str, "audio_output_method=%s\n", GlobalFDSet.audio_output_method);

  else
    g_string_append_printf(set_str, "audio_output_method=NULL\n");
  if(!(GlobalFDSet.audio_oss_device == ((char *)NULL)))
    g_string_append_printf(set_str, "audio_oss_device=%s\n", GlobalFDSet.audio_oss_device);

  else
    g_string_append_printf(set_str, "audio_oss_device=NULL\n");
  if(!(GlobalFDSet.audio_alsa_device == ((char *)NULL)))
    g_string_append_printf(set_str, "audio_alsa_device=%s\n", GlobalFDSet.audio_alsa_device);

  else
    g_string_append_printf(set_str, "audio_alsa_device=NULL\n");
  if(!(GlobalFDSet.audio_nas_server == ((char *)NULL)))
    g_string_append_printf(set_str, "audio_nas_server=%s\n", GlobalFDSet.audio_nas_server);

  else
    g_string_append_printf(set_str, "audio_nas_server=NULL\n");
  if(!(GlobalFDSet.audio_pulse_server == ((char *)NULL)))
    g_string_append_printf(set_str, "audio_pulse_server=%s\n", GlobalFDSet.audio_pulse_server);

  else
    g_string_append_printf(set_str, "audio_pulse_server=NULL\n");
  g_string_append_printf(set_str, "audio_pulse_min_length=%d\n", GlobalFDSet.audio_pulse_min_length);
  err=output_send_data("AUDIO\n", output, 1);
  if(!(err >= 0))
    return err;

  else
  {
    err=output_send_data(set_str->str, output, 0);
    if(!(err >= 0))
      return err;

    else
    {
      err=output_send_data(".\n", output, 1);
      if(!(err >= 0))
        return err;

      else
      {
        g_string_free(set_str, 1);
        return 0;
      }
    }
  }
}

// output_send_data
// file output.h line 42
signed int output_send_data(char *cmd, struct anonymous$10 *output, signed int wfr)
{
  signed int output_send_data$$1$$ret;
  struct _GString *response;
  signed long int tmp_statement_expression$1;
  unsigned long int return_value_strlen$4;
  signed long int return_value_write$5;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(output == ((struct anonymous$10 *)NULL))
    return -1;

  else
    if(cmd == ((char *)NULL))
      return -1;

    else
    {
      signed long int __result;
      do
      {
        return_value_strlen$4=strlen(cmd);
        return_value_write$5=write(output->pipe_in[(signed long int)1], (const void *)cmd, return_value_strlen$4);
        __result = (signed long int)return_value_write$5;
        if(__result == -1l)
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
      }
      while(tmp_if_expr$3);
      tmp_statement_expression$1 = __result;
      output_send_data$$1$$ret = (signed int)tmp_statement_expression$1;
      fflush((struct _IO_FILE *)(void *)0);
      if(output_send_data$$1$$ret == -1)
      {
        MSG(2, "Error: Broken pipe to module.");
        output->working = 0;
        speaking_module = (struct anonymous$10 *)(void *)0;
        output_check_module(output);
        return -1;
      }

      else
      {
        MSG2(5, "output_module", "Command sent to output module: |%s| (%d)", cmd, wfr);
        if(!(wfr == 0))
        {
          signed int ret = 0;
          response=output_read_reply(output);
          if(response == ((struct _GString *)NULL))
            return -1;

          MSG2(5, "output_module", "Reply from output module: |%s|", response->str);
          switch((signed int)response->str[(signed long int)0])
          {
            case 51:
            {
              MSG(2, "Error: Module reported error in request from speechd (code 3xx): %s.", response->str);
              ret = -2;
              break;
            }
            case 52:
            {
              MSG(2, "Error: Module reported error in itself (code 4xx): %s", response->str);
              ret = -3;
              break;
            }
            case 50:
            {
              ret = 0;
              break;
            }
            default:
            {
              MSG(3, "Unknown response from output module!");
              ret = -3;
            }
          }
          g_string_free(response, (signed int)!(0 != 0));
          return ret;
        }

        return 0;
      }
    }
}

// output_send_debug
// file output.h line 33
signed int output_send_debug(struct anonymous$10 *output, signed int flag, char *log_path)
{
  char *cmd_str;
  signed int err;
  MSG(4, "Module sending debug flag %d with file %s", flag, log_path);
  output_lock();
  if(!(flag == 0))
  {
    cmd_str=g_strdup_printf("DEBUG ON %s \n", log_path);
    err=output_send_data(cmd_str, output, 1);
    g_free((void *)cmd_str);
    if(!(err == 0))
    {
      MSG(3, "ERROR: Can't set debugging on for output module %s", output->name);
      output_unlock();
      return -1;
    }

  }

  else
  {
    err=output_send_data("DEBUG OFF \n", output, 1);
    if(!(err == 0))
    {
      MSG(3, "ERROR: Can't switch debugging off for output module %s", output->name);
      output_unlock();
      return -1;
    }

  }
  output_unlock();
  return 0;
}

// output_send_loglevel_setting
// file output.h line 45
signed int output_send_loglevel_setting(struct anonymous$10 *output)
{
  struct _GString *set_str;
  signed int err;
  MSG(4, "Module set parameters.");
  set_str=g_string_new("");
  g_string_append_printf(set_str, "log_level=%d\n", GlobalFDSet.log_level);
  err=output_send_data("LOGLEVEL\n", output, 1);
  if(!(err >= 0))
    return err;

  else
  {
    err=output_send_data(set_str->str, output, 0);
    if(!(err >= 0))
      return err;

    else
    {
      err=output_send_data(".\n", output, 1);
      if(!(err >= 0))
        return err;

      else
      {
        g_string_free(set_str, 1);
        return 0;
      }
    }
  }
}

// output_send_settings
// file output.c line 398
signed int output_send_settings(struct anonymous$7 *msg, struct anonymous$10 *output)
{
  struct _GString *set_str;
  char *val;
  signed int err;
  MSG(4, "Module set parameters.");
  set_str=g_string_new("");
  g_string_append_printf(set_str, "pitch=%d\n", msg->settings.msg_settings.pitch);
  g_string_append_printf(set_str, "rate=%d\n", msg->settings.msg_settings.rate);
  g_string_append_printf(set_str, "volume=%d\n", msg->settings.msg_settings.volume);
  val=EPunctMode2str(msg->settings.msg_settings.punctuation_mode);
  if(!(val == ((char *)NULL)))
    g_string_append_printf(set_str, "punctuation_mode=%s\n", val);

  g_free((void *)val);
  val=ESpellMode2str(msg->settings.msg_settings.spelling_mode);
  if(!(val == ((char *)NULL)))
    g_string_append_printf(set_str, "spelling_mode=%s\n", val);

  g_free((void *)val);
  val=ECapLetRecogn2str(msg->settings.msg_settings.cap_let_recogn);
  if(!(val == ((char *)NULL)))
    g_string_append_printf(set_str, "cap_let_recogn=%s\n", val);

  g_free((void *)val);
  val=EVoice2str(msg->settings.msg_settings.voice_type);
  if(!(val == ((char *)NULL)))
    g_string_append_printf(set_str, "voice=%s\n", val);

  g_free((void *)val);
  if(!(msg->settings.msg_settings.voice.language == ((char *)NULL)))
    g_string_append_printf(set_str, "language=%s\n", msg->settings.msg_settings.voice.language);

  else
    g_string_append_printf(set_str, "language=NULL\n");
  if(!(msg->settings.msg_settings.voice.name == ((char *)NULL)))
    g_string_append_printf(set_str, "synthesis_voice=%s\n", msg->settings.msg_settings.voice.name);

  else
    g_string_append_printf(set_str, "synthesis_voice=NULL\n");
  err=output_send_data("SET\n", output, 1);
  if(!(err >= 0))
    return err;

  else
  {
    err=output_send_data(set_str->str, output, 0);
    if(!(err >= 0))
      return err;

    else
    {
      err=output_send_data(".\n", output, 1);
      if(!(err >= 0))
        return err;

      else
      {
        g_string_free(set_str, 1);
        return 0;
      }
    }
  }
}

// output_set_speaking_monitor
// file output.c line 74
void output_set_speaking_monitor(struct anonymous$7 *msg, struct anonymous$10 *output)
{
  speaking_module = output;
  speaking_uid = (signed int)msg->settings.uid;
  speaking_gid = msg->settings.reparted;
}

// output_speak
// file output.h line 29
signed int output_speak(struct anonymous$7 *msg)
{
  struct anonymous$10 *output;
  signed int err;
  signed int ret;
  if(msg == ((struct anonymous$7 *)NULL))
    return -1;

  else
  {
    output_lock();
    output=get_output_module(msg);
    if(output == ((struct anonymous$10 *)NULL))
    {
      MSG(3, "Output module doesn't work...");
      output_unlock();
      return -1;
    }

    else
    {
      msg->buf=escape_dot(msg->buf);
      msg->bytes = -1;
      output_set_speaking_monitor(msg, output);
      ret=output_send_settings(msg, output);
      if(!(ret == 0))
      {
        output_unlock();
        return ret;
      }

      else
      {
        MSG(4, "Module speak!");
        switch((signed int)msg->settings.type)
        {
          case SPD_MSGTYPE_TEXT:
          {
            err=output_send_data("SPEAK\n", output, 1);
            if(!(err >= 0))
            {
              output_unlock();
              return err;
            }

            break;
          }
          case SPD_MSGTYPE_SOUND_ICON:
          {
            err=output_send_data("SOUND_ICON\n", output, 1);
            if(!(err >= 0))
            {
              output_unlock();
              return err;
            }

            break;
          }
          case SPD_MSGTYPE_CHAR:
          {
            err=output_send_data("CHAR\n", output, 1);
            if(!(err >= 0))
            {
              output_unlock();
              return err;
            }

            break;
          }
          case SPD_MSGTYPE_KEY:
          {
            err=output_send_data("KEY\n", output, 1);
            if(!(err >= 0))
            {
              output_unlock();
              return err;
            }

            break;
          }
          default:
            MSG(2, "Invalid message type in output_speak()!");
        }
        err=output_send_data(msg->buf, output, 0);
        if(!(err >= 0))
        {
          output_unlock();
          return err;
        }

        else
        {
          err=output_send_data("\n.\n", output, 1);
          if(!(err >= 0))
          {
            output_unlock();
            return err;
          }

          else
          {
            output_unlock();
            return 0;
          }
        }
      }
    }
  }
}

// output_stop
// file output.h line 30
signed int output_stop()
{
  signed int err;
  struct anonymous$10 *output;
  output_lock();
  if(speaking_module == ((struct anonymous$10 *)NULL))
  {
    output_unlock();
    return 0;
  }

  else
    output = speaking_module;
  MSG(4, "Module stop!");
  err=output_send_data("STOP\n", output, 0);
  if(!(err >= 0))
  {
    output_unlock();
    return err;
  }

  else
  {
    output_unlock();
    return 0;
  }
}

// output_unlock
// file output.c line 168
static void output_unlock(void)
{
  pthread_mutex_unlock(&output_layer_mutex);
}

// parse
// file parse.h line 5
char * parse(const char *buf, const signed int bytes, const signed int fd)
{
  struct anonymous$7 *new;
  char *command;
  signed int r;
  signed int end_data;
  char *pos;
  signed int reparted;
  signed int msg_uid;
  struct _GString *ok_queued_reply;
  char *reply;
  struct anonymous$0 *speechd_socket;
  speechd_socket=speechd_socket_get_by_fd(fd);
  /* assertion speechd_socket */
  assert(speechd_socket != ((struct anonymous$0 *)NULL));
  end_data = 0;
  if(buf == ((const char *)NULL) || bytes == 0)
  {
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("300 ERR INTERNAL\r\n");
    return return_value_g_strdup$1;
  }

  char *return_value_g_strdup$3;
  char *return_value_g_strdup$6;
  char *return_value_g_strdup$9;
  char *return_value_g_strdup$12;
  char *return_value_g_strdup$15;
  char *return_value_g_strdup$18;
  char *return_value_g_strdup$21;
  char *return_value_g_strdup$24;
  char *return_value_g_strdup$27;
  char *return_value_g_strdup$30;
  char *return_value_g_strdup$33;
  char *return_value_g_strdup$36;
  char *return_value_g_strdup$39;
  _Bool tmp_if_expr$49;
  signed int return_value_strcmp$48;
  _Bool tmp_if_expr$60;
  signed int return_value_strncmp$59;
  _Bool tmp_if_expr$63;
  _Bool tmp_if_expr$62;
  signed int return_value_strncmp$61;
  char *return_value_g_strdup$54;
  if(speechd_socket->awaiting_data == 0)
  {
    command=get_param(buf, 0, bytes, 1);
    MSG(5, "Command caught: \"%s\"", command);
    if(command == ((char *)NULL))
    {
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
      return return_value_g_strdup$2;
    }

    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(command, "set");
    if(return_value_strcmp$5 == 0)
    {
      g_free((void *)command);
      char *return_value_parse_set$4;
      return_value_parse_set$4=parse_set(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_set$4;
    }

    signed int return_value_strcmp$8;
    return_value_strcmp$8=strcmp(command, "history");
    if(return_value_strcmp$8 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$6=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$6;
      }

      char *return_value_parse_history$7;
      return_value_parse_history$7=parse_history(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_history$7;
    }

    signed int return_value_strcmp$11;
    return_value_strcmp$11=strcmp(command, "stop");
    if(return_value_strcmp$11 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$9=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$9;
      }

      char *return_value_parse_stop$10;
      return_value_parse_stop$10=parse_stop(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_stop$10;
    }

    signed int return_value_strcmp$14;
    return_value_strcmp$14=strcmp(command, "cancel");
    if(return_value_strcmp$14 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$12=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$12;
      }

      char *return_value_parse_cancel$13;
      return_value_parse_cancel$13=parse_cancel(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_cancel$13;
    }

    signed int return_value_strcmp$17;
    return_value_strcmp$17=strcmp(command, "pause");
    if(return_value_strcmp$17 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$15=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$15;
      }

      char *return_value_parse_pause$16;
      return_value_parse_pause$16=parse_pause(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_pause$16;
    }

    signed int return_value_strcmp$20;
    return_value_strcmp$20=strcmp(command, "resume");
    if(return_value_strcmp$20 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$18=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$18;
      }

      char *return_value_parse_resume$19;
      return_value_parse_resume$19=parse_resume(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_resume$19;
    }

    signed int return_value_strcmp$23;
    return_value_strcmp$23=strcmp(command, "sound_icon");
    if(return_value_strcmp$23 == 0)
    {
      g_free((void *)command);
      char *return_value_parse_snd_icon$22;
      return_value_parse_snd_icon$22=parse_snd_icon(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_snd_icon$22;
    }

    signed int return_value_strcmp$26;
    return_value_strcmp$26=strcmp(command, "char");
    if(return_value_strcmp$26 == 0)
    {
      g_free((void *)command);
      char *return_value_parse_char$25;
      return_value_parse_char$25=parse_char(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_char$25;
    }

    signed int return_value_strcmp$29;
    return_value_strcmp$29=strcmp(command, "key");
    if(return_value_strcmp$29 == 0)
    {
      g_free((void *)command);
      char *return_value_parse_key$28;
      return_value_parse_key$28=parse_key(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_key$28;
    }

    signed int return_value_strcmp$32;
    return_value_strcmp$32=strcmp(command, "list");
    if(return_value_strcmp$32 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$30=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$30;
      }

      char *return_value_parse_list$31;
      return_value_parse_list$31=parse_list(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_list$31;
    }

    signed int return_value_strcmp$35;
    return_value_strcmp$35=strcmp(command, "get");
    if(return_value_strcmp$35 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$33=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$33;
      }

      char *return_value_parse_get$34;
      return_value_parse_get$34=parse_get(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_get$34;
    }

    signed int return_value_strcmp$38;
    return_value_strcmp$38=strcmp(command, "help");
    if(return_value_strcmp$38 == 0)
    {
      g_free((void *)command);
      if(!(speechd_socket->inside_block == 0))
      {
        return_value_g_strdup$36=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        return return_value_g_strdup$36;
      }

      char *return_value_parse_help$37;
      return_value_parse_help$37=parse_help(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_help$37;
    }

    signed int return_value_strcmp$41;
    return_value_strcmp$41=strcmp(command, "block");
    if(return_value_strcmp$41 == 0)
    {
      g_free((void *)command);
      char *return_value_parse_block$40;
      return_value_parse_block$40=parse_block(buf, bytes, fd, speechd_socket);
      return (char *)return_value_parse_block$40;
    }

    signed int return_value_strcmp$47;
    return_value_strcmp$47=strcmp(command, "bye");
    if(return_value_strcmp$47 == 0)
      tmp_if_expr$49 = (_Bool)1;

    else
    {
      return_value_strcmp$48=strcmp(command, "quit");
      tmp_if_expr$49 = !(return_value_strcmp$48 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$49)
    {
      MSG(4, "Bye received.");
      unsigned long int return_value_strlen$44;
      return_value_strlen$44=strlen("231 HAPPY HACKING\r\n");
      signed long int return_value_write$45;
      return_value_write$45=write(fd, (const void *)"231 HAPPY HACKING\r\n", return_value_strlen$44);
      if(!(return_value_write$45 == 0l))
      {
        signed int *return_value___errno_location$42;
        return_value___errno_location$42=__errno_location();
        char *return_value_strerror$43;
        return_value_strerror$43=strerror(*return_value___errno_location$42);
        MSG(2, "ERROR: Can't write OK_BYE message to client socket: %s", return_value_strerror$43);
      }

      speechd_connection_destroy(fd);
      g_free((void *)command);
      char *return_value_g_strdup$46;
      return_value_g_strdup$46=g_strdup("999 CLIENT GONE");
      return return_value_g_strdup$46;
    }

    signed int return_value_strcmp$52;
    return_value_strcmp$52=strcmp(command, "speak");
    if(return_value_strcmp$52 == 0)
    {
      g_free((void *)command);
      r=server_data_on(fd);
      if(!(r == 0))
      {
        char *return_value_g_strdup$50;
        return_value_g_strdup$50=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$50;
      }

      char *return_value_g_strdup$51;
      return_value_g_strdup$51=g_strdup("230 OK RECEIVING DATA\r\n");
      return return_value_g_strdup$51;
    }

    g_free((void *)command);
    char *return_value_g_strdup$53;
    return_value_g_strdup$53=g_strdup("500 ERR INVALID COMMAND\r\n");
    return return_value_g_strdup$53;
  }

  else
  {

  enddata:
    ;
    MSG(5, "Buffer: |%s| bytes:", buf, bytes);
    if(bytes >= 5)
    {
      return_value_strncmp$59=strncmp(buf, "\r\n.\r\n", (unsigned long int)bytes);
      tmp_if_expr$60 = !(return_value_strncmp$59 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$60 = (_Bool)0;
    if(end_data == 1 || tmp_if_expr$60)
      tmp_if_expr$63 = (_Bool)1;

    else
    {
      if(bytes == 3)
      {
        return_value_strncmp$61=strncmp(buf, ".\r\n", (unsigned long int)bytes);
        tmp_if_expr$62 = !(return_value_strncmp$61 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$62 = (_Bool)0;
      tmp_if_expr$63 = tmp_if_expr$62 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$63)
    {
      MSG(5, "Finishing data");
      end_data = 0;
      MSG(5, "Switching back to command mode...");
      speechd_socket->awaiting_data = 0;
      if(bytes == 3)
      {
        if(speechd_socket->o_bytes >= 3ul)
          speechd_socket->o_bytes = speechd_socket->o_bytes - (unsigned long int)2;

      }

      if(speechd_socket->o_bytes == 0ul)
      {
        return_value_g_strdup$54=g_strdup("227 OK MESSAGE CANCELED\r\n");
        return return_value_g_strdup$54;
      }

      signed int return_value_g_utf8_validate$56;
      return_value_g_utf8_validate$56=g_utf8_validate(speechd_socket->o_buf->str, (signed long int)speechd_socket->o_bytes, (const char **)(void *)0);
      if(return_value_g_utf8_validate$56 == 0)
      {
        MSG(4, "ERROR: Invalid character encoding on input (failed UTF-8 validation)");
        MSG(4, "Rejecting this message.");
        char *return_value_g_strdup$55;
        return_value_g_strdup$55=g_strdup("501 ERR INVALID ENCODING\r\n");
        return return_value_g_strdup$55;
      }

      void *return_value_g_malloc$57;
      return_value_g_malloc$57=g_malloc(sizeof(struct anonymous$7) /*224ul*/ );
      new = (struct anonymous$7 *)return_value_g_malloc$57;
      new->bytes = (signed int)speechd_socket->o_bytes;
      /* assertion speechd_socket->o_buf != ((void *)0) */
      assert(speechd_socket->o_buf != (struct _GString *)(void *)0);
      new->buf=deescape_dot(speechd_socket->o_buf->str, (unsigned long int)new->bytes);
      reparted = speechd_socket->inside_block;
      MSG(5, "New buf is now: |%s|", new->buf);
      msg_uid=queue_message(new, fd, 1, (enum anonymous$8)SPD_MSGTYPE_TEXT, reparted);
      if(msg_uid == 0)
      {
        g_free((void *)new->buf);
        g_free((void *)new);
        char *return_value_g_strdup$58;
        return_value_g_strdup$58=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$58;
      }

      server_data_off(fd);
      ok_queued_reply=g_string_new("");
      g_string_printf(ok_queued_reply, "225-%d\r\n225 OK MESSAGE QUEUED\r\n", msg_uid);
      reply = ok_queued_reply->str;
      g_string_free(ok_queued_reply, 0);
      return reply;
    }

    signed int real_bytes;
    if(bytes >= 5)
    {
      pos=strstr(buf, "\r\n.\r\n");
      if(!(pos == ((char *)NULL)))
      {
        real_bytes = (signed int)(pos - buf);
        end_data = 1;
        MSG(5, "Command in data caught");
      }

      else
        real_bytes = bytes;
    }

    else
      real_bytes = bytes;
    speechd_socket->o_bytes = speechd_socket->o_bytes + (unsigned long int)real_bytes;
    g_string_insert_len(speechd_socket->o_buf, (signed long int)-1, buf, (signed long int)real_bytes);
  }
  if(end_data == 1)
    goto enddata;

  char *return_value_g_strdup$64;
  return_value_g_strdup$64=g_strdup("999 DATA");
  return return_value_g_strdup$64;
}

// parse_block
// file parse.c line 975
char * parse_block(const char *buf, const signed int bytes, const signed int fd, struct anonymous$0 *speechd_socket)
{
  char *cmd_main;
  cmd_main=get_param(buf, 1, bytes, 1);
  if(cmd_main == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$9;
  return_value_strcmp$9=strcmp(cmd_main, "begin");
  signed int tmp_if_expr$10;
  if(return_value_strcmp$9 == 0)
  {
    g_free((void *)cmd_main);
    tmp_if_expr$10 = 1;
  }

  else
    tmp_if_expr$10 = 0;
  signed int return_value_strcmp$7;
  signed int tmp_if_expr$8;
  if(!(tmp_if_expr$10 == 0))
  {
    /* assertion speechd_socket->inside_block >= 0 */
    assert(speechd_socket->inside_block >= 0);
    if(speechd_socket->inside_block == 0)
    {
      SpeechdStatus.max_gid = SpeechdStatus.max_gid + 1;
      speechd_socket->inside_block = SpeechdStatus.max_gid;
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup("260 OK INSIDE BLOCK\r\n");
      return return_value_g_strdup$2;
    }

    else
    {
      char *return_value_g_strdup$3;
      return_value_g_strdup$3=g_strdup("330 ERR ALREADY INSIDE BLOCK\r\n");
      return return_value_g_strdup$3;
    }
  }

  else
  {
    return_value_strcmp$7=strcmp(cmd_main, "end");
    if(return_value_strcmp$7 == 0)
    {
      g_free((void *)cmd_main);
      tmp_if_expr$8 = 1;
    }

    else
      tmp_if_expr$8 = 0;
    if(!(tmp_if_expr$8 == 0))
    {
      /* assertion speechd_socket->inside_block >= 0 */
      assert(speechd_socket->inside_block >= 0);
      if(speechd_socket->inside_block >= 1)
      {
        speechd_socket->inside_block = 0;
        char *return_value_g_strdup$4;
        return_value_g_strdup$4=g_strdup("261 OK OUTSIDE BLOCK\r\n");
        return return_value_g_strdup$4;
      }

      else
      {
        char *return_value_g_strdup$5;
        return_value_g_strdup$5=g_strdup("331 ERR ALREADY OUTSIDE BLOCK\r\n");
        return return_value_g_strdup$5;
      }
    }

    else
    {
      g_free((void *)cmd_main);
      char *return_value_g_strdup$6;
      return_value_g_strdup$6=g_strdup("514 ERR PARAMETER INVALID\r\n");
      return return_value_g_strdup$6;
    }
  }
}

// parse_cancel
// file parse.c line 650
char * parse_cancel(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  signed int uid = 0;
  char *who_s;
  MSG(4, "Cancel received from fd %d.", fd);
  who_s=get_param(buf, 1, bytes, 1);
  if(who_s == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(who_s, "all");
  signed int tmp_if_expr$9;
  if(return_value_strcmp$8 == 0)
  {
    g_free((void *)who_s);
    tmp_if_expr$9 = 1;
  }

  else
    tmp_if_expr$9 = 0;
  signed int return_value_strcmp$6;
  signed int tmp_if_expr$7;
  char *return_value_g_strdup$2;
  signed int return_value_isanum$5;
  char *return_value_g_strdup$3;
  if(!(tmp_if_expr$9 == 0))
    speaking_cancel_all();

  else
  {
    return_value_strcmp$6=strcmp(who_s, "self");
    if(return_value_strcmp$6 == 0)
    {
      g_free((void *)who_s);
      tmp_if_expr$7 = 1;
    }

    else
      tmp_if_expr$7 = 0;
    if(!(tmp_if_expr$7 == 0))
    {
      uid=get_client_uid_by_fd(fd);
      if(uid == 0)
      {
        return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$2;
      }

      speaking_cancel(uid);
    }

    else
    {
      return_value_isanum$5=isanum(who_s);
      if(!(return_value_isanum$5 == 0))
      {
        uid=atoi(who_s);
        g_free((void *)who_s);
        if(!(uid >= 1))
        {
          return_value_g_strdup$3=g_strdup("406 ERR ID DOESNT EXIST\r\n");
          return return_value_g_strdup$3;
        }

        speaking_cancel(uid);
      }

      else
      {
        g_free((void *)who_s);
        char *return_value_g_strdup$4;
        return_value_g_strdup$4=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$4;
      }
    }
  }
  char *return_value_g_strdup$10;
  return_value_g_strdup$10=g_strdup("213 OK CANCELED\r\n");
  return return_value_g_strdup$10;
}

// parse_char
// file parse.c line 800
char * parse_char(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *return_value_parse_general_event$1;
  return_value_parse_general_event$1=parse_general_event(buf, bytes, fd, speechd_socket, (enum anonymous$8)SPD_MSGTYPE_CHAR);
  return return_value_parse_general_event$1;
}

// parse_general_event
// file parse.c line 755
char * parse_general_event(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket, enum anonymous$8 type)
{
  char *param;
  struct anonymous$7 *msg;
  param=get_param(buf, 1, bytes, 0);
  if(param == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  char *return_value_g_strdup$2;
  if(param == ((char *)NULL))
  {
    return_value_g_strdup$2=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$2;
  }

  else
  {
    if((signed int)*param == 0)
    {
      g_free((void *)param);
      char *return_value_g_strdup$3;
      return_value_g_strdup$3=g_strdup("510 ERR MISSING PARAMETER\r\n");
      return return_value_g_strdup$3;
    }

    signed int return_value_g_utf8_validate$5;
    return_value_g_utf8_validate$5=g_utf8_validate(buf, (signed long int)bytes, (const char **)(void *)0);
    if(return_value_g_utf8_validate$5 == 0)
    {
      MSG(4, "ERROR: Invalid character encoding on event input (failed UTF-8 validation)");
      MSG(4, "Rejecting this event (char/key/sound_icon).");
      char *return_value_g_strdup$4;
      return_value_g_strdup$4=g_strdup("501 ERR INVALID ENCODING\r\n");
      return return_value_g_strdup$4;
    }

    void *return_value_g_malloc$6;
    return_value_g_malloc$6=g_malloc(sizeof(struct anonymous$7) /*224ul*/ );
    msg = (struct anonymous$7 *)return_value_g_malloc$6;
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(param);
    msg->bytes = (signed int)return_value_strlen$7;
    msg->buf=g_strdup(param);
    signed int return_value_queue_message$8;
    return_value_queue_message$8=queue_message(msg, fd, 1, type, speechd_socket->inside_block);
    if(return_value_queue_message$8 == 0)
      MSG(2, "Error: Couldn't queue message!\n");

    g_free((void *)param);
    char *return_value_g_strdup$9;
    return_value_g_strdup$9=g_strdup("225 OK MESSAGE QUEUED\r\n");
    return return_value_g_strdup$9;
  }
}

// parse_get
// file parse.c line 888
char * parse_get(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *get_type;
  struct _GString *result;
  char *helper;
  struct anonymous$11 *settings;
  settings=get_client_settings_by_fd(fd);
  char *return_value_g_strdup$1;
  signed int tmp_if_expr$7;
  signed int return_value_strcmp$4;
  signed int tmp_if_expr$5;
  if(settings == ((struct anonymous$11 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("300 ERR INTERNAL\r\n");
    return return_value_g_strdup$1;
  }

  else
  {
    get_type=get_param(buf, 1, bytes, 1);
    if(get_type == ((char *)NULL))
    {
      MSG(4, "Missing parameter from client");
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup("510 ERR MISSING PARAMETER\r\n");
      return return_value_g_strdup$2;
    }

    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(get_type, "voice");
    if(return_value_strcmp$6 == 0)
    {
      g_free((void *)get_type);
      tmp_if_expr$7 = 1;
    }

    else
      tmp_if_expr$7 = 0;
    if(!(tmp_if_expr$7 == 0))
    {
      result=g_string_new("");
      switch((signed int)settings->msg_settings.voice_type)
      {
        case SPD_MALE1:
        {
          g_string_append_printf(result, "251-MALE1\r\n");
          break;
        }
        case SPD_MALE2:
        {
          g_string_append_printf(result, "251-MALE2\r\n");
          break;
        }
        case SPD_MALE3:
        {
          g_string_append_printf(result, "251-MALE3\r\n");
          break;
        }
        case SPD_FEMALE1:
        {
          g_string_append_printf(result, "251-FEMALE1\r\n");
          break;
        }
        case SPD_FEMALE2:
        {
          g_string_append_printf(result, "251-FEMALE2\r\n");
          break;
        }
        case SPD_FEMALE3:
        {
          g_string_append_printf(result, "251-FEMALE3\r\n");
          break;
        }
        case SPD_CHILD_MALE:
        {
          g_string_append_printf(result, "251-CHILD_MALE\r\n");
          break;
        }
        case SPD_CHILD_FEMALE:
        {
          g_string_append_printf(result, "251-CHILD_FEMALE\r\n");
          break;
        }
        default:
          g_string_append_printf(result, "251-NO_VOICE\r\n");
      }
      helper = result->str;
      g_string_free(result, 0);
      return helper;
    }

    else
    {
      return_value_strcmp$4=strcmp(get_type, "output_module");
      if(return_value_strcmp$4 == 0)
      {
        g_free((void *)get_type);
        tmp_if_expr$5 = 1;
      }

      else
        tmp_if_expr$5 = 0;
      if(!(tmp_if_expr$5 == 0))
      {
        result=g_string_new("");
        g_string_append_printf(result, "251-%s\r\n", settings->output_module);
        helper = result->str;
        g_string_free(result, 0);
        return helper;
      }

      else
      {
        g_free((void *)get_type);
        char *return_value_g_strdup$3;
        return_value_g_strdup$3=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$3;
      }
    }
  }
}

// parse_help
// file parse.c line 953
char * parse_help(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *help;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)1024 * sizeof(char) /*1ul*/ );
  help = (char *)return_value_g_malloc$1;
  sprintf(help, "248-  SPEAK           -- say text \r\n248-  KEY             -- say a combination of keys \r\n248-  CHAR            -- say a character \r\n248-  SOUND_ICON      -- execute a sound icon \r\n248-  SET             -- set a parameter \r\n248-  GET             -- get a current parameter \r\n248-  LIST            -- list available arguments \r\n248-  HISTORY         -- commands related to history \r\n248-  QUIT            -- close the connection \r\n248 OK HELP SENT\r\n");
  return help;
}

// parse_history
// file parse.c line 260
char * parse_history(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *cmd_main;
  cmd_main=get_param(buf, 1, bytes, 1);
  if(cmd_main == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$77;
  return_value_strcmp$77=strcmp(cmd_main, "get");
  signed int tmp_if_expr$78;
  if(return_value_strcmp$77 == 0)
  {
    g_free((void *)cmd_main);
    tmp_if_expr$78 = 1;
  }

  else
    tmp_if_expr$78 = 0;
  signed int tmp_if_expr$34;
  signed int return_value_strcmp$31;
  signed int tmp_if_expr$32;
  signed int return_value_strcmp$29;
  signed int tmp_if_expr$30;
  char *return_value_g_strdup$6;
  char *return_value_g_strdup$8;
  char *return_value_g_strdup$10;
  signed int return_value_strcmp$27;
  signed int tmp_if_expr$28;
  signed int return_value_strcmp$25;
  signed int tmp_if_expr$26;
  signed int return_value_strcmp$75;
  signed int tmp_if_expr$76;
  signed int tmp_if_expr$64;
  signed int tmp_if_expr$52;
  signed int return_value_strcmp$49;
  signed int tmp_if_expr$50;
  signed int return_value_strcmp$47;
  signed int tmp_if_expr$48;
  signed int return_value_strcmp$61;
  signed int tmp_if_expr$62;
  signed int return_value_strcmp$59;
  signed int tmp_if_expr$60;
  signed int return_value_strcmp$57;
  signed int tmp_if_expr$58;
  signed int return_value_strcmp$73;
  signed int tmp_if_expr$74;
  signed int return_value_strcmp$71;
  signed int tmp_if_expr$72;
  if(!(tmp_if_expr$78 == 0))
  {
    char *hist_get_sub;
    hist_get_sub=get_param(buf, 2, bytes, 1);
    if(hist_get_sub == ((char *)NULL))
    {
      MSG(4, "Missing parameter from client");
      char *return_value_g_strdup$2;
      return_value_g_strdup$2=g_strdup("510 ERR MISSING PARAMETER\r\n");
      return return_value_g_strdup$2;
    }

    signed int return_value_strcmp$33;
    return_value_strcmp$33=strcmp(hist_get_sub, "client_list");
    if(return_value_strcmp$33 == 0)
    {
      g_free((void *)hist_get_sub);
      tmp_if_expr$34 = 1;
    }

    else
      tmp_if_expr$34 = 0;
    if(!(tmp_if_expr$34 == 0))
    {
      char *return_value_history_get_client_list$3;
      return_value_history_get_client_list$3=history_get_client_list();
      return (char *)return_value_history_get_client_list$3;
    }

    else
    {
      return_value_strcmp$31=strcmp(hist_get_sub, "client_id");
      if(return_value_strcmp$31 == 0)
      {
        g_free((void *)hist_get_sub);
        tmp_if_expr$32 = 1;
      }

      else
        tmp_if_expr$32 = 0;
      if(!(tmp_if_expr$32 == 0))
      {
        char *return_value_history_get_client_id$4;
        return_value_history_get_client_id$4=history_get_client_id(fd);
        return (char *)return_value_history_get_client_id$4;
      }

      else
      {
        return_value_strcmp$29=strcmp(hist_get_sub, "client_messages");
        if(return_value_strcmp$29 == 0)
        {
          g_free((void *)hist_get_sub);
          tmp_if_expr$30 = 1;
        }

        else
          tmp_if_expr$30 = 0;
        if(!(tmp_if_expr$30 == 0))
        {
          signed int start;
          signed int num;
          char *who;
          signed int who_id;
          who=get_param(buf, 3, bytes, 1);
          if(who == ((char *)NULL))
          {
            MSG(4, "Missing parameter from client");
            char *return_value_g_strdup$5;
            return_value_g_strdup$5=g_strdup("510 ERR MISSING PARAMETER\r\n");
            return return_value_g_strdup$5;
          }

          signed int return_value_strcmp$7;
          return_value_strcmp$7=strcmp(who, "self");
          if(return_value_strcmp$7 == 0)
          {
            return_value_g_strdup$6=g_strdup("380 ERR NOT YET IMPLEMENTED\r\n");
            return return_value_g_strdup$6;
          }

          signed int return_value_strcmp$9;
          return_value_strcmp$9=strcmp(who, "all");
          if(return_value_strcmp$9 == 0)
          {
            return_value_g_strdup$8=g_strdup("380 ERR NOT YET IMPLEMENTED\r\n");
            return return_value_g_strdup$8;
          }

          signed int return_value_isanum$11;
          return_value_isanum$11=isanum(who);
          if(return_value_isanum$11 == 0)
          {
            return_value_g_strdup$10=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
            return return_value_g_strdup$10;
          }

          who_id=atoi(who);
          g_free((void *)who);
          char *helper;
          helper=get_param(buf, 4, bytes, 0);
          if(helper == ((char *)NULL))
          {
            MSG(4, "Missing parameter from client");
            char *return_value_g_strdup$12;
            return_value_g_strdup$12=g_strdup("510 ERR MISSING PARAMETER\r\n");
            return return_value_g_strdup$12;
          }

          signed int return_value_isanum$14;
          return_value_isanum$14=isanum(helper);
          if(return_value_isanum$14 == 0)
          {
            g_free((void *)helper);
            char *return_value_g_strdup$13;
            return_value_g_strdup$13=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
            return return_value_g_strdup$13;
          }

          start=atoi(helper);
          g_free((void *)helper);
          char *parse_history$$1$$2$$4$$3$$helper;
          parse_history$$1$$2$$4$$3$$helper=get_param(buf, 5, bytes, 0);
          if(parse_history$$1$$2$$4$$3$$helper == ((char *)NULL))
          {
            MSG(4, "Missing parameter from client");
            char *return_value_g_strdup$15;
            return_value_g_strdup$15=g_strdup("510 ERR MISSING PARAMETER\r\n");
            return return_value_g_strdup$15;
          }

          signed int return_value_isanum$17;
          return_value_isanum$17=isanum(parse_history$$1$$2$$4$$3$$helper);
          if(return_value_isanum$17 == 0)
          {
            g_free((void *)parse_history$$1$$2$$4$$3$$helper);
            char *return_value_g_strdup$16;
            return_value_g_strdup$16=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
            return return_value_g_strdup$16;
          }

          num=atoi(parse_history$$1$$2$$4$$3$$helper);
          g_free((void *)parse_history$$1$$2$$4$$3$$helper);
          char *return_value_history_get_message_list$18;
          return_value_history_get_message_list$18=history_get_message_list((unsigned int)who_id, start, num);
          return (char *)return_value_history_get_message_list$18;
        }

        else
        {
          return_value_strcmp$27=strcmp(hist_get_sub, "last");
          if(return_value_strcmp$27 == 0)
          {
            g_free((void *)hist_get_sub);
            tmp_if_expr$28 = 1;
          }

          else
            tmp_if_expr$28 = 0;
          if(!(tmp_if_expr$28 == 0))
          {
            char *return_value_history_get_last$19;
            return_value_history_get_last$19=history_get_last(fd);
            return (char *)return_value_history_get_last$19;
          }

          else
          {
            return_value_strcmp$25=strcmp(hist_get_sub, "message");
            if(return_value_strcmp$25 == 0)
            {
              g_free((void *)hist_get_sub);
              tmp_if_expr$26 = 1;
            }

            else
              tmp_if_expr$26 = 0;
            if(!(tmp_if_expr$26 == 0))
            {
              signed int msg_id;
              char *parse_history$$1$$2$$6$$1$$helper;
              parse_history$$1$$2$$6$$1$$helper=get_param(buf, 3, bytes, 0);
              if(parse_history$$1$$2$$6$$1$$helper == ((char *)NULL))
              {
                MSG(4, "Missing parameter from client");
                char *return_value_g_strdup$20;
                return_value_g_strdup$20=g_strdup("510 ERR MISSING PARAMETER\r\n");
                return return_value_g_strdup$20;
              }

              signed int return_value_isanum$22;
              return_value_isanum$22=isanum(parse_history$$1$$2$$6$$1$$helper);
              if(return_value_isanum$22 == 0)
              {
                g_free((void *)parse_history$$1$$2$$6$$1$$helper);
                char *return_value_g_strdup$21;
                return_value_g_strdup$21=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
                return return_value_g_strdup$21;
              }

              msg_id=atoi(parse_history$$1$$2$$6$$1$$helper);
              g_free((void *)parse_history$$1$$2$$6$$1$$helper);
              char *return_value_history_get_message$23;
              return_value_history_get_message$23=history_get_message(msg_id);
              return (char *)return_value_history_get_message$23;
            }

            else
            {
              char *return_value_g_strdup$24;
              return_value_g_strdup$24=g_strdup("510 ERR MISSING PARAMETER\r\n");
              return return_value_g_strdup$24;
            }
          }
        }
      }
    }
  }

  else
  {
    return_value_strcmp$75=strcmp(cmd_main, "cursor");
    if(return_value_strcmp$75 == 0)
    {
      g_free((void *)cmd_main);
      tmp_if_expr$76 = 1;
    }

    else
      tmp_if_expr$76 = 0;
    if(!(tmp_if_expr$76 == 0))
    {
      char *hist_cur_sub;
      hist_cur_sub=get_param(buf, 2, bytes, 1);
      if(hist_cur_sub == ((char *)NULL))
      {
        MSG(4, "Missing parameter from client");
        char *return_value_g_strdup$35;
        return_value_g_strdup$35=g_strdup("510 ERR MISSING PARAMETER\r\n");
        return return_value_g_strdup$35;
      }

      signed int return_value_strcmp$63;
      return_value_strcmp$63=strcmp(hist_cur_sub, "set");
      if(return_value_strcmp$63 == 0)
      {
        g_free((void *)hist_cur_sub);
        tmp_if_expr$64 = 1;
      }

      else
        tmp_if_expr$64 = 0;
      if(!(tmp_if_expr$64 == 0))
      {
        signed int parse_history$$1$$3$$2$$who;
        char *location;
        char *parse_history$$1$$3$$2$$1$$helper;
        parse_history$$1$$3$$2$$1$$helper=get_param(buf, 3, bytes, 0);
        if(parse_history$$1$$3$$2$$1$$helper == ((char *)NULL))
        {
          MSG(4, "Missing parameter from client");
          char *return_value_g_strdup$36;
          return_value_g_strdup$36=g_strdup("510 ERR MISSING PARAMETER\r\n");
          return return_value_g_strdup$36;
        }

        signed int return_value_isanum$38;
        return_value_isanum$38=isanum(parse_history$$1$$3$$2$$1$$helper);
        if(return_value_isanum$38 == 0)
        {
          g_free((void *)parse_history$$1$$3$$2$$1$$helper);
          char *return_value_g_strdup$37;
          return_value_g_strdup$37=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
          return return_value_g_strdup$37;
        }

        parse_history$$1$$3$$2$$who=atoi(parse_history$$1$$3$$2$$1$$helper);
        g_free((void *)parse_history$$1$$3$$2$$1$$helper);
        location=get_param(buf, 4, bytes, 1);
        if(location == ((char *)NULL))
        {
          MSG(4, "Missing parameter from client");
          char *return_value_g_strdup$39;
          return_value_g_strdup$39=g_strdup("510 ERR MISSING PARAMETER\r\n");
          return return_value_g_strdup$39;
        }

        signed int return_value_strcmp$51;
        return_value_strcmp$51=strcmp(location, "last");
        if(return_value_strcmp$51 == 0)
        {
          g_free((void *)location);
          tmp_if_expr$52 = 1;
        }

        else
          tmp_if_expr$52 = 0;
        if(!(tmp_if_expr$52 == 0))
        {
          char *return_value_history_cursor_set_last$40;
          return_value_history_cursor_set_last$40=history_cursor_set_last(fd, (unsigned int)parse_history$$1$$3$$2$$who);
          return (char *)return_value_history_cursor_set_last$40;
        }

        else
        {
          return_value_strcmp$49=strcmp(location, "first");
          if(return_value_strcmp$49 == 0)
          {
            g_free((void *)location);
            tmp_if_expr$50 = 1;
          }

          else
            tmp_if_expr$50 = 0;
          if(!(tmp_if_expr$50 == 0))
          {
            char *return_value_history_cursor_set_first$41;
            return_value_history_cursor_set_first$41=history_cursor_set_first(fd, (unsigned int)parse_history$$1$$3$$2$$who);
            return (char *)return_value_history_cursor_set_first$41;
          }

          else
          {
            return_value_strcmp$47=strcmp(location, "pos");
            if(return_value_strcmp$47 == 0)
            {
              g_free((void *)location);
              tmp_if_expr$48 = 1;
            }

            else
              tmp_if_expr$48 = 0;
            if(!(tmp_if_expr$48 == 0))
            {
              signed int pos;
              char *parse_history$$1$$3$$2$$5$$1$$helper;
              parse_history$$1$$3$$2$$5$$1$$helper=get_param(buf, 5, bytes, 0);
              if(parse_history$$1$$3$$2$$5$$1$$helper == ((char *)NULL))
              {
                MSG(4, "Missing parameter from client");
                char *return_value_g_strdup$42;
                return_value_g_strdup$42=g_strdup("510 ERR MISSING PARAMETER\r\n");
                return return_value_g_strdup$42;
              }

              signed int return_value_isanum$44;
              return_value_isanum$44=isanum(parse_history$$1$$3$$2$$5$$1$$helper);
              if(return_value_isanum$44 == 0)
              {
                g_free((void *)parse_history$$1$$3$$2$$5$$1$$helper);
                char *return_value_g_strdup$43;
                return_value_g_strdup$43=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
                return return_value_g_strdup$43;
              }

              pos=atoi(parse_history$$1$$3$$2$$5$$1$$helper);
              g_free((void *)parse_history$$1$$3$$2$$5$$1$$helper);
              char *return_value_history_cursor_set_pos$45;
              return_value_history_cursor_set_pos$45=history_cursor_set_pos(fd, (unsigned int)parse_history$$1$$3$$2$$who, pos);
              return (char *)return_value_history_cursor_set_pos$45;
            }

            else
            {
              g_free((void *)location);
              char *return_value_g_strdup$46;
              return_value_g_strdup$46=g_strdup("510 ERR MISSING PARAMETER\r\n");
              return return_value_g_strdup$46;
            }
          }
        }
      }

      else
      {
        return_value_strcmp$61=strcmp(hist_cur_sub, "forward");
        if(return_value_strcmp$61 == 0)
        {
          g_free((void *)hist_cur_sub);
          tmp_if_expr$62 = 1;
        }

        else
          tmp_if_expr$62 = 0;
        if(!(tmp_if_expr$62 == 0))
        {
          char *return_value_history_cursor_forward$53;
          return_value_history_cursor_forward$53=history_cursor_forward(fd);
          return (char *)return_value_history_cursor_forward$53;
        }

        else
        {
          return_value_strcmp$59=strcmp(hist_cur_sub, "backward");
          if(return_value_strcmp$59 == 0)
          {
            g_free((void *)hist_cur_sub);
            tmp_if_expr$60 = 1;
          }

          else
            tmp_if_expr$60 = 0;
          if(!(tmp_if_expr$60 == 0))
          {
            char *return_value_history_cursor_backward$54;
            return_value_history_cursor_backward$54=history_cursor_backward(fd);
            return (char *)return_value_history_cursor_backward$54;
          }

          else
          {
            return_value_strcmp$57=strcmp(hist_cur_sub, "get");
            if(return_value_strcmp$57 == 0)
            {
              g_free((void *)hist_cur_sub);
              tmp_if_expr$58 = 1;
            }

            else
              tmp_if_expr$58 = 0;
            if(!(tmp_if_expr$58 == 0))
            {
              char *return_value_history_cursor_get$55;
              return_value_history_cursor_get$55=history_cursor_get(fd);
              return (char *)return_value_history_cursor_get$55;
            }

            else
            {
              g_free((void *)hist_cur_sub);
              char *return_value_g_strdup$56;
              return_value_g_strdup$56=g_strdup("510 ERR MISSING PARAMETER\r\n");
              return return_value_g_strdup$56;
            }
          }
        }
      }
    }

    else
    {
      return_value_strcmp$73=strcmp(cmd_main, "say");
      if(return_value_strcmp$73 == 0)
      {
        g_free((void *)cmd_main);
        tmp_if_expr$74 = 1;
      }

      else
        tmp_if_expr$74 = 0;
      if(!(tmp_if_expr$74 == 0))
      {
        signed int parse_history$$1$$4$$msg_id;
        char *parse_history$$1$$4$$1$$helper;
        parse_history$$1$$4$$1$$helper=get_param(buf, 2, bytes, 0);
        if(parse_history$$1$$4$$1$$helper == ((char *)NULL))
        {
          MSG(4, "Missing parameter from client");
          char *return_value_g_strdup$65;
          return_value_g_strdup$65=g_strdup("510 ERR MISSING PARAMETER\r\n");
          return return_value_g_strdup$65;
        }

        signed int return_value_isanum$67;
        return_value_isanum$67=isanum(parse_history$$1$$4$$1$$helper);
        if(return_value_isanum$67 == 0)
        {
          g_free((void *)parse_history$$1$$4$$1$$helper);
          char *return_value_g_strdup$66;
          return_value_g_strdup$66=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
          return return_value_g_strdup$66;
        }

        parse_history$$1$$4$$msg_id=atoi(parse_history$$1$$4$$1$$helper);
        g_free((void *)parse_history$$1$$4$$1$$helper);
        char *return_value_history_say_id$68;
        return_value_history_say_id$68=history_say_id(fd, parse_history$$1$$4$$msg_id);
        return (char *)return_value_history_say_id$68;
      }

      else
      {
        return_value_strcmp$71=strcmp(cmd_main, "sort");
        if(return_value_strcmp$71 == 0)
        {
          g_free((void *)cmd_main);
          tmp_if_expr$72 = 1;
        }

        else
          tmp_if_expr$72 = 0;
        if(!(tmp_if_expr$72 == 0))
        {
          char *return_value_g_strdup$69;
          return_value_g_strdup$69=g_strdup("380 ERR NOT YET IMPLEMENTED\r\n");
          return return_value_g_strdup$69;
        }

        else
        {
          g_free((void *)cmd_main);
          char *return_value_g_strdup$70;
          return_value_g_strdup$70=g_strdup("510 ERR MISSING PARAMETER\r\n");
          return return_value_g_strdup$70;
        }
      }
    }
  }
  char *return_value_g_strdup$79;
  return_value_g_strdup$79=g_strdup("500 ERR INVALID COMMAND\r\n");
  return return_value_g_strdup$79;
}

// parse_key
// file parse.c line 806
char * parse_key(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *return_value_parse_general_event$1;
  return_value_parse_general_event$1=parse_general_event(buf, bytes, fd, speechd_socket, (enum anonymous$8)SPD_MSGTYPE_KEY);
  return return_value_parse_general_event$1;
}

// parse_list
// file parse.c line 812
char * parse_list(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *list_type;
  char *voice_list;
  list_type=get_param(buf, 1, bytes, 1);
  if(list_type == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$13;
  return_value_strcmp$13=strcmp(list_type, "voices");
  signed int tmp_if_expr$14;
  if(return_value_strcmp$13 == 0)
  {
    g_free((void *)list_type);
    tmp_if_expr$14 = 1;
  }

  else
    tmp_if_expr$14 = 0;
  signed int return_value_strcmp$11;
  signed int tmp_if_expr$12;
  signed int return_value_strcmp$9;
  signed int tmp_if_expr$10;
  char *return_value_g_strdup$5;
  char *return_value_g_strdup$6;
  char *return_value_g_strdup$7;
  if(!(tmp_if_expr$14 == 0))
  {
    void *return_value_g_malloc$2;
    return_value_g_malloc$2=g_malloc((unsigned long int)1024);
    voice_list = (char *)return_value_g_malloc$2;
    sprintf(voice_list, "249-MALE1\r\n249-MALE2\r\n249-MALE3\r\n249-FEMALE1\r\n249-FEMALE2\r\n249-FEMALE3\r\n249-CHILD_MALE\r\n249-CHILD_FEMALE\r\n249 OK VOICE LIST SENT\r\n");
    return voice_list;
  }

  else
  {
    return_value_strcmp$11=strcmp(list_type, "output_modules");
    if(return_value_strcmp$11 == 0)
    {
      g_free((void *)list_type);
      tmp_if_expr$12 = 1;
    }

    else
      tmp_if_expr$12 = 0;
    if(!(tmp_if_expr$12 == 0))
    {
      struct _GString *parse_list$$1$$3$$result;
      parse_list$$1$$3$$result=g_string_new("");
      char *parse_list$$1$$3$$helper;
      struct anonymous$10 *mod;
      signed int parse_list$$1$$3$$i;
      signed int len;
      unsigned int return_value_g_list_length$3;
      return_value_g_list_length$3=g_list_length(output_modules);
      len = (signed int)return_value_g_list_length$3;
      parse_list$$1$$3$$i = 0;
      for( ; !(parse_list$$1$$3$$i >= len); parse_list$$1$$3$$i = parse_list$$1$$3$$i + 1)
      {
        void *return_value_g_list_nth_data$4;
        return_value_g_list_nth_data$4=g_list_nth_data(output_modules, (unsigned int)parse_list$$1$$3$$i);
        mod = (struct anonymous$10 *)return_value_g_list_nth_data$4;
        g_string_append_printf(parse_list$$1$$3$$result, "250-%s\r\n", mod->name);
      }
      g_string_append(parse_list$$1$$3$$result, "250 OK VOICE LIST SENT\r\n");
      parse_list$$1$$3$$helper = parse_list$$1$$3$$result->str;
      g_string_free(parse_list$$1$$3$$result, 0);
      return parse_list$$1$$3$$helper;
    }

    else
    {
      return_value_strcmp$9=strcmp(list_type, "synthesis_voices");
      if(return_value_strcmp$9 == 0)
      {
        g_free((void *)list_type);
        tmp_if_expr$10 = 1;
      }

      else
        tmp_if_expr$10 = 0;
      if(!(tmp_if_expr$10 == 0))
      {
        char *module_name;
        signed int uid;
        struct anonymous$11 *settings;
        struct anonymous$6 **voices;
        struct _GString *result;
        signed int i;
        char *helper;
        uid=get_client_uid_by_fd(fd);
        settings=get_client_settings_by_uid(uid);
        if(settings == ((struct anonymous$11 *)NULL))
        {
          return_value_g_strdup$5=g_strdup("300 ERR INTERNAL\r\n");
          return return_value_g_strdup$5;
        }

        module_name = settings->output_module;
        if(module_name == ((char *)NULL))
        {
          return_value_g_strdup$6=g_strdup("321 ERR NO OUTPUT MODULE LOADED\r\n");
          return return_value_g_strdup$6;
        }

        voices=output_list_voices(module_name);
        if(voices == ((struct anonymous$6 **)NULL))
        {
          return_value_g_strdup$7=g_strdup("321 ERR MODULE CANT REPORT VOICES\r\n");
          return return_value_g_strdup$7;
        }

        result=g_string_new("");
        i = 0;
        for( ; !(voices[(signed long int)i] == ((struct anonymous$6 *)NULL)); i = i + 1)
        {
          g_string_append_printf(result, "249-%s %s %s\r\n", voices[(signed long int)i]->name, voices[(signed long int)i]->language, voices[(signed long int)i]->variant);
          g_free((void *)voices[(signed long int)i]->name);
          g_free((void *)voices[(signed long int)i]->language);
          g_free((void *)voices[(signed long int)i]->variant);
          g_free((void *)voices[(signed long int)i]);
        }
        g_string_append(result, "249 OK VOICE LIST SENT\r\n");
        helper = result->str;
        g_string_free(result, 0);
        g_free((void *)voices);
        return helper;
      }

      else
      {
        g_free((void *)list_type);
        char *return_value_g_strdup$8;
        return_value_g_strdup$8=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$8;
      }
    }
  }
}

// parse_pause
// file parse.c line 682
char * parse_pause(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  signed int uid = 0;
  char *who_s;
  MSG(4, "Pause received from fd %d.", fd);
  who_s=get_param(buf, 1, bytes, 1);
  if(who_s == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(who_s, "all");
  signed int tmp_if_expr$9;
  if(return_value_strcmp$8 == 0)
  {
    g_free((void *)who_s);
    tmp_if_expr$9 = 1;
  }

  else
    tmp_if_expr$9 = 0;
  signed int return_value_strcmp$6;
  signed int tmp_if_expr$7;
  char *return_value_g_strdup$2;
  signed int return_value_isanum$5;
  char *return_value_g_strdup$3;
  if(!(tmp_if_expr$9 == 0))
  {
    pause_requested = 1;
    pause_requested_fd = fd;
    speaking_semaphore_post();
  }

  else
  {
    return_value_strcmp$6=strcmp(who_s, "self");
    if(return_value_strcmp$6 == 0)
    {
      g_free((void *)who_s);
      tmp_if_expr$7 = 1;
    }

    else
      tmp_if_expr$7 = 0;
    if(!(tmp_if_expr$7 == 0))
    {
      uid=get_client_uid_by_fd(fd);
      if(uid == 0)
      {
        return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$2;
      }

      pause_requested = 2;
      pause_requested_fd = fd;
      pause_requested_uid = uid;
      speaking_semaphore_post();
    }

    else
    {
      return_value_isanum$5=isanum(who_s);
      if(!(return_value_isanum$5 == 0))
      {
        uid=atoi(who_s);
        g_free((void *)who_s);
        if(!(uid >= 1))
        {
          return_value_g_strdup$3=g_strdup("406 ERR ID DOESNT EXIST\r\n");
          return return_value_g_strdup$3;
        }

        pause_requested = 2;
        pause_requested_fd = fd;
        pause_requested_uid = uid;
        speaking_semaphore_post();
      }

      else
      {
        g_free((void *)who_s);
        char *return_value_g_strdup$4;
        return_value_g_strdup$4=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$4;
      }
    }
  }
  char *return_value_g_strdup$10;
  return_value_g_strdup$10=g_strdup("211 OK PAUSED\r\n");
  return return_value_g_strdup$10;
}

// parse_resume
// file parse.c line 724
char * parse_resume(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  signed int uid = 0;
  char *who_s;
  MSG(4, "Resume received from fd %d.", fd);
  who_s=get_param(buf, 1, bytes, 1);
  if(who_s == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(who_s, "all");
  signed int tmp_if_expr$9;
  if(return_value_strcmp$8 == 0)
  {
    g_free((void *)who_s);
    tmp_if_expr$9 = 1;
  }

  else
    tmp_if_expr$9 = 0;
  signed int return_value_strcmp$6;
  signed int tmp_if_expr$7;
  char *return_value_g_strdup$2;
  signed int return_value_isanum$5;
  char *return_value_g_strdup$3;
  if(!(tmp_if_expr$9 == 0))
    speaking_resume_all();

  else
  {
    return_value_strcmp$6=strcmp(who_s, "self");
    if(return_value_strcmp$6 == 0)
    {
      g_free((void *)who_s);
      tmp_if_expr$7 = 1;
    }

    else
      tmp_if_expr$7 = 0;
    if(!(tmp_if_expr$7 == 0))
    {
      uid=get_client_uid_by_fd(fd);
      if(uid == 0)
      {
        return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$2;
      }

      speaking_resume(uid);
    }

    else
    {
      return_value_isanum$5=isanum(who_s);
      if(!(return_value_isanum$5 == 0))
      {
        uid=atoi(who_s);
        g_free((void *)who_s);
        if(!(uid >= 1))
        {
          return_value_g_strdup$3=g_strdup("406 ERR ID DOESNT EXIST\r\n");
          return return_value_g_strdup$3;
        }

        speaking_resume(uid);
      }

      else
      {
        g_free((void *)who_s);
        char *return_value_g_strdup$4;
        return_value_g_strdup$4=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$4;
      }
    }
  }
  char *return_value_g_strdup$10;
  return_value_g_strdup$10=g_strdup("212 OK RESUMED\r\n");
  return return_value_g_strdup$10;
}

// parse_set
// file parse.c line 388
char * parse_set(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  signed int who;
  signed int uid = -1;
  signed int ret = -1;
  char *set_sub;
  char *who_s;
  who_s=get_param(buf, 1, bytes, 1);
  if(who_s == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(who_s, "self");
  signed int tmp_if_expr$7;
  if(return_value_strcmp$6 == 0)
  {
    g_free((void *)who_s);
    tmp_if_expr$7 = 1;
  }

  else
    tmp_if_expr$7 = 0;
  signed int return_value_strcmp$4;
  signed int tmp_if_expr$5;
  signed int return_value_isanum$3;
  if(!(tmp_if_expr$7 == 0))
    who = 0;

  else
  {
    return_value_strcmp$4=strcmp(who_s, "all");
    if(return_value_strcmp$4 == 0)
    {
      g_free((void *)who_s);
      tmp_if_expr$5 = 1;
    }

    else
      tmp_if_expr$5 = 0;
    if(!(tmp_if_expr$5 == 0))
      who = 2;

    else
    {
      return_value_isanum$3=isanum(who_s);
      if(!(return_value_isanum$3 == 0))
      {
        who = 1;
        uid=atoi(who_s);
        g_free((void *)who_s);
      }

      else
      {
        g_free((void *)who_s);
        char *return_value_g_strdup$2;
        return_value_g_strdup$2=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$2;
      }
    }
  }
  set_sub=get_param(buf, 2, bytes, 1);
  if(set_sub == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$8;
    return_value_g_strdup$8=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$8;
  }

  signed int return_value_strcmp$153;
  return_value_strcmp$153=strcmp(set_sub, "priority");
  signed int tmp_if_expr$154;
  if(return_value_strcmp$153 == 0)
  {
    g_free((void *)set_sub);
    tmp_if_expr$154 = 1;
  }

  else
    tmp_if_expr$154 = 0;
  char *return_value_g_strdup$9;
  char *return_value_g_strdup$10;
  signed int tmp_if_expr$22;
  signed int return_value_strcmp$19;
  signed int tmp_if_expr$20;
  signed int return_value_strcmp$17;
  signed int tmp_if_expr$18;
  signed int return_value_strcmp$15;
  signed int tmp_if_expr$16;
  signed int return_value_strcmp$13;
  signed int tmp_if_expr$14;
  char *return_value_g_strdup$23;
  signed int return_value_strcmp$151;
  signed int tmp_if_expr$152;
  char *return_value_g_strdup$26;
  signed int return_value_strcmp$149;
  signed int tmp_if_expr$150;
  char *return_value_g_strdup$29;
  signed int return_value_strcmp$147;
  signed int tmp_if_expr$148;
  char *return_value_g_strdup$31;
  char *return_value_g_strdup$32;
  char *return_value_g_strdup$34;
  signed int return_value_strcmp$145;
  signed int tmp_if_expr$146;
  char *return_value_g_strdup$39;
  char *return_value_g_strdup$40;
  char *return_value_g_strdup$41;
  signed int return_value_strcmp$143;
  signed int tmp_if_expr$144;
  char *return_value_g_strdup$46;
  char *return_value_g_strdup$47;
  char *return_value_g_strdup$48;
  signed int return_value_strcmp$141;
  signed int tmp_if_expr$142;
  char *return_value_g_strdup$53;
  char *return_value_g_strdup$54;
  char *return_value_g_strdup$55;
  signed int return_value_strcmp$139;
  signed int tmp_if_expr$140;
  char *return_value_g_strdup$58;
  signed int return_value_strcmp$137;
  signed int tmp_if_expr$138;
  signed int tmp_if_expr$67;
  signed int return_value_strcmp$64;
  signed int tmp_if_expr$65;
  signed int return_value_strcmp$62;
  signed int tmp_if_expr$63;
  char *return_value_g_strdup$68;
  signed int return_value_strcmp$135;
  signed int tmp_if_expr$136;
  char *return_value_g_strdup$70;
  char *return_value_g_strdup$72;
  signed int return_value_strcmp$133;
  signed int tmp_if_expr$134;
  signed int tmp_if_expr$81;
  signed int return_value_strcmp$78;
  signed int tmp_if_expr$79;
  signed int return_value_strcmp$76;
  signed int tmp_if_expr$77;
  char *return_value_g_strdup$82;
  signed int return_value_strcmp$131;
  signed int tmp_if_expr$132;
  char *return_value_g_strdup$87;
  signed int return_value_strcmp$130;
  char *return_value_g_strdup$89;
  signed int tmp_if_expr$95;
  signed int return_value_strcmp$92;
  signed int tmp_if_expr$93;
  char *return_value_g_strdup$96;
  signed int return_value_strcmp$129;
  signed int tmp_if_expr$103;
  signed int return_value_strcmp$100;
  signed int tmp_if_expr$101;
  char *return_value_g_strdup$104;
  signed int return_value_strcmp$128;
  signed int tmp_if_expr$111;
  signed int return_value_strcmp$108;
  signed int tmp_if_expr$109;
  char *return_value_g_strdup$112;
  signed int return_value_strcmp$126;
  signed int tmp_if_expr$127;
  char *return_value_g_strdup$115;
  signed int tmp_if_expr$122;
  signed int return_value_strcmp$119;
  signed int tmp_if_expr$120;
  char *return_value_g_strdup$123;
  if(!(tmp_if_expr$154 == 0))
  {
    char *priority_s;
    enum anonymous$9 priority;
    if(speechd_socket->inside_block >= 1)
    {
      return_value_g_strdup$9=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
      return return_value_g_strdup$9;
    }

    if(!(who == 0))
    {
      return_value_g_strdup$10=g_strdup("301 ERR COULDNT SET PRIORITY\r\n");
      return return_value_g_strdup$10;
    }

    priority_s=get_param(buf, 3, bytes, 1);
    if(priority_s == ((char *)NULL))
    {
      MSG(4, "Missing parameter from client");
      char *return_value_g_strdup$11;
      return_value_g_strdup$11=g_strdup("510 ERR MISSING PARAMETER\r\n");
      return return_value_g_strdup$11;
    }

    signed int return_value_strcmp$21;
    return_value_strcmp$21=strcmp(priority_s, "important");
    if(return_value_strcmp$21 == 0)
    {
      g_free((void *)priority_s);
      tmp_if_expr$22 = 1;
    }

    else
      tmp_if_expr$22 = 0;
    if(!(tmp_if_expr$22 == 0))
      priority = (enum anonymous$9)SPD_IMPORTANT;

    else
    {
      return_value_strcmp$19=strcmp(priority_s, "message");
      if(return_value_strcmp$19 == 0)
      {
        g_free((void *)priority_s);
        tmp_if_expr$20 = 1;
      }

      else
        tmp_if_expr$20 = 0;
      if(!(tmp_if_expr$20 == 0))
        priority = (enum anonymous$9)SPD_MESSAGE;

      else
      {
        return_value_strcmp$17=strcmp(priority_s, "text");
        if(return_value_strcmp$17 == 0)
        {
          g_free((void *)priority_s);
          tmp_if_expr$18 = 1;
        }

        else
          tmp_if_expr$18 = 0;
        if(!(tmp_if_expr$18 == 0))
          priority = (enum anonymous$9)SPD_TEXT;

        else
        {
          return_value_strcmp$15=strcmp(priority_s, "notification");
          if(return_value_strcmp$15 == 0)
          {
            g_free((void *)priority_s);
            tmp_if_expr$16 = 1;
          }

          else
            tmp_if_expr$16 = 0;
          if(!(tmp_if_expr$16 == 0))
            priority = (enum anonymous$9)SPD_NOTIFICATION;

          else
          {
            return_value_strcmp$13=strcmp(priority_s, "progress");
            if(return_value_strcmp$13 == 0)
            {
              g_free((void *)priority_s);
              tmp_if_expr$14 = 1;
            }

            else
              tmp_if_expr$14 = 0;
            if(!(tmp_if_expr$14 == 0))
              priority = (enum anonymous$9)SPD_PROGRESS;

            else
            {
              g_free((void *)priority_s);
              char *return_value_g_strdup$12;
              return_value_g_strdup$12=g_strdup("408 ERR UNKNOWN PRIORITY\r\n");
              return return_value_g_strdup$12;
            }
          }
        }
      }
    }
    ret=set_priority_self(fd, priority);
    if(!(ret == 0))
    {
      return_value_g_strdup$23=g_strdup("301 ERR COULDNT SET PRIORITY\r\n");
      return return_value_g_strdup$23;
    }

    char *return_value_g_strdup$24;
    return_value_g_strdup$24=g_strdup("202 OK PRIORITY SET\r\n");
    return return_value_g_strdup$24;
  }

  else
  {
    return_value_strcmp$151=strcmp(set_sub, "language");
    if(return_value_strcmp$151 == 0)
    {
      g_free((void *)set_sub);
      tmp_if_expr$152 = 1;
    }

    else
      tmp_if_expr$152 = 0;
    if(!(tmp_if_expr$152 == 0))
    {
      char *language;
      language=get_param(buf, 3, bytes, 1);
      if(language == ((char *)NULL))
      {
        MSG(4, "Missing parameter from client");
        char *return_value_g_strdup$25;
        return_value_g_strdup$25=g_strdup("510 ERR MISSING PARAMETER\r\n");
        return return_value_g_strdup$25;
      }

      if(who == 0)
        ret=set_language_self(fd, language);

      else
        if(who == 1)
          ret=set_language_uid(uid, language);

        else
          if(who == 2)
            ret=set_language_all(language);

      g_free((void *)language);
      if(!(ret == 0))
      {
        return_value_g_strdup$26=g_strdup("302 ERR COULDNT SET LANGUAGE\r\n");
        return return_value_g_strdup$26;
      }

      char *return_value_g_strdup$27;
      return_value_g_strdup$27=g_strdup("201 OK LANGUAGE SET\r\n");
      return return_value_g_strdup$27;
    }

    else
    {
      return_value_strcmp$149=strcmp(set_sub, "synthesis_voice");
      if(return_value_strcmp$149 == 0)
      {
        g_free((void *)set_sub);
        tmp_if_expr$150 = 1;
      }

      else
        tmp_if_expr$150 = 0;
      if(!(tmp_if_expr$150 == 0))
      {
        char *synthesis_voice;
        synthesis_voice=get_param(buf, 3, bytes, 1);
        if(synthesis_voice == ((char *)NULL))
        {
          MSG(4, "Missing parameter from client");
          char *return_value_g_strdup$28;
          return_value_g_strdup$28=g_strdup("510 ERR MISSING PARAMETER\r\n");
          return return_value_g_strdup$28;
        }

        if(who == 0)
          ret=set_synthesis_voice_self(fd, synthesis_voice);

        else
          if(who == 1)
            ret=set_synthesis_voice_uid(uid, synthesis_voice);

          else
            if(who == 2)
              ret=set_synthesis_voice_all(synthesis_voice);

        g_free((void *)synthesis_voice);
        if(!(ret == 0))
        {
          return_value_g_strdup$29=g_strdup("309 ERR COULDNT SET VOICE\r\n");
          return return_value_g_strdup$29;
        }

        char *return_value_g_strdup$30;
        return_value_g_strdup$30=g_strdup("209 OK VOICE SET\r\n");
        return return_value_g_strdup$30;
      }

      else
      {
        return_value_strcmp$147=strcmp(set_sub, "client_name");
        if(return_value_strcmp$147 == 0)
        {
          g_free((void *)set_sub);
          tmp_if_expr$148 = 1;
        }

        else
          tmp_if_expr$148 = 0;
        if(!(tmp_if_expr$148 == 0))
        {
          char *client_name;
          if(speechd_socket->inside_block >= 1)
          {
            return_value_g_strdup$31=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
            return return_value_g_strdup$31;
          }

          if(!(who == 0))
          {
            return_value_g_strdup$32=g_strdup("514 ERR PARAMETER INVALID\r\n");
            return return_value_g_strdup$32;
          }

          client_name=get_param(buf, 3, bytes, 1);
          if(client_name == ((char *)NULL))
          {
            MSG(4, "Missing parameter from client");
            char *return_value_g_strdup$33;
            return_value_g_strdup$33=g_strdup("510 ERR MISSING PARAMETER\r\n");
            return return_value_g_strdup$33;
          }

          ret=set_client_name_self(fd, client_name);
          g_free((void *)client_name);
          if(!(ret == 0))
          {
            return_value_g_strdup$34=g_strdup("311 ERR COULDNT SET CLIENT_NAME\r\n");
            return return_value_g_strdup$34;
          }

          char *return_value_g_strdup$35;
          return_value_g_strdup$35=g_strdup("208 OK CLIENT NAME SET\r\n");
          return return_value_g_strdup$35;
        }

        else
        {
          return_value_strcmp$145=strcmp(set_sub, "rate");
          if(return_value_strcmp$145 == 0)
          {
            g_free((void *)set_sub);
            tmp_if_expr$146 = 1;
          }

          else
            tmp_if_expr$146 = 0;
          if(!(tmp_if_expr$146 == 0))
          {
            signed int rate;
            char *helper;
            helper=get_param(buf, 3, bytes, 0);
            if(helper == ((char *)NULL))
            {
              MSG(4, "Missing parameter from client");
              char *return_value_g_strdup$36;
              return_value_g_strdup$36=g_strdup("510 ERR MISSING PARAMETER\r\n");
              return return_value_g_strdup$36;
            }

            signed int return_value_isanum$38;
            return_value_isanum$38=isanum(helper);
            if(return_value_isanum$38 == 0)
            {
              g_free((void *)helper);
              char *return_value_g_strdup$37;
              return_value_g_strdup$37=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
              return return_value_g_strdup$37;
            }

            rate=atoi(helper);
            g_free((void *)helper);
            if(!(rate >= -100))
            {
              return_value_g_strdup$39=g_strdup("410 ERR RATE TOO LOW\r\n");
              return return_value_g_strdup$39;
            }

            if(rate >= 101)
            {
              return_value_g_strdup$40=g_strdup("409 ERR RATE TOO HIGH\r\n");
              return return_value_g_strdup$40;
            }

            if(who == 0)
              ret=set_rate_self(fd, rate);

            else
              if(who == 1)
                ret=set_rate_uid(uid, rate);

              else
                if(who == 2)
                  ret=set_rate_all(rate);

            if(!(ret == 0))
            {
              return_value_g_strdup$41=g_strdup("303 ERR COULDNT SET RATE\r\n");
              return return_value_g_strdup$41;
            }

            char *return_value_g_strdup$42;
            return_value_g_strdup$42=g_strdup("203 OK RATE SET\r\n");
            return return_value_g_strdup$42;
          }

          else
          {
            return_value_strcmp$143=strcmp(set_sub, "pitch");
            if(return_value_strcmp$143 == 0)
            {
              g_free((void *)set_sub);
              tmp_if_expr$144 = 1;
            }

            else
              tmp_if_expr$144 = 0;
            if(!(tmp_if_expr$144 == 0))
            {
              signed int pitch;
              char *parse_set$$1$$10$$1$$helper;
              parse_set$$1$$10$$1$$helper=get_param(buf, 3, bytes, 0);
              if(parse_set$$1$$10$$1$$helper == ((char *)NULL))
              {
                MSG(4, "Missing parameter from client");
                char *return_value_g_strdup$43;
                return_value_g_strdup$43=g_strdup("510 ERR MISSING PARAMETER\r\n");
                return return_value_g_strdup$43;
              }

              signed int return_value_isanum$45;
              return_value_isanum$45=isanum(parse_set$$1$$10$$1$$helper);
              if(return_value_isanum$45 == 0)
              {
                g_free((void *)parse_set$$1$$10$$1$$helper);
                char *return_value_g_strdup$44;
                return_value_g_strdup$44=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
                return return_value_g_strdup$44;
              }

              pitch=atoi(parse_set$$1$$10$$1$$helper);
              g_free((void *)parse_set$$1$$10$$1$$helper);
              if(!(pitch >= -100))
              {
                return_value_g_strdup$46=g_strdup("412 ERR PITCH TOO LOW\r\n");
                return return_value_g_strdup$46;
              }

              if(pitch >= 101)
              {
                return_value_g_strdup$47=g_strdup("411 ERR PITCH TOO HIGH\r\n");
                return return_value_g_strdup$47;
              }

              if(who == 0)
                ret=set_pitch_self(fd, pitch);

              else
                if(who == 1)
                  ret=set_pitch_uid(uid, pitch);

                else
                  if(who == 2)
                    ret=set_pitch_all(pitch);

              if(!(ret == 0))
              {
                return_value_g_strdup$48=g_strdup("304 ERR COULDNT SET PITCH\r\n");
                return return_value_g_strdup$48;
              }

              char *return_value_g_strdup$49;
              return_value_g_strdup$49=g_strdup("204 OK PITCH SET\r\n");
              return return_value_g_strdup$49;
            }

            else
            {
              return_value_strcmp$141=strcmp(set_sub, "volume");
              if(return_value_strcmp$141 == 0)
              {
                g_free((void *)set_sub);
                tmp_if_expr$142 = 1;
              }

              else
                tmp_if_expr$142 = 0;
              if(!(tmp_if_expr$142 == 0))
              {
                signed int volume;
                char *parse_set$$1$$11$$1$$helper;
                parse_set$$1$$11$$1$$helper=get_param(buf, 3, bytes, 0);
                if(parse_set$$1$$11$$1$$helper == ((char *)NULL))
                {
                  MSG(4, "Missing parameter from client");
                  char *return_value_g_strdup$50;
                  return_value_g_strdup$50=g_strdup("510 ERR MISSING PARAMETER\r\n");
                  return return_value_g_strdup$50;
                }

                signed int return_value_isanum$52;
                return_value_isanum$52=isanum(parse_set$$1$$11$$1$$helper);
                if(return_value_isanum$52 == 0)
                {
                  g_free((void *)parse_set$$1$$11$$1$$helper);
                  char *return_value_g_strdup$51;
                  return_value_g_strdup$51=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
                  return return_value_g_strdup$51;
                }

                volume=atoi(parse_set$$1$$11$$1$$helper);
                g_free((void *)parse_set$$1$$11$$1$$helper);
                if(!(volume >= -100))
                {
                  return_value_g_strdup$53=g_strdup("414 ERR PITCH TOO LOW\r\n");
                  return return_value_g_strdup$53;
                }

                if(volume >= 101)
                {
                  return_value_g_strdup$54=g_strdup("413 ERR PITCH TOO HIGH\r\n");
                  return return_value_g_strdup$54;
                }

                if(who == 0)
                  ret=set_volume_self(fd, volume);

                else
                  if(who == 1)
                    ret=set_volume_uid(uid, volume);

                  else
                    if(who == 2)
                      ret=set_volume_all(volume);

                if(!(ret == 0))
                {
                  return_value_g_strdup$55=g_strdup("314 ERR COULDNT SET VOLUME\r\n");
                  return return_value_g_strdup$55;
                }

                char *return_value_g_strdup$56;
                return_value_g_strdup$56=g_strdup("218 OK VOLUME SET\r\n");
                return return_value_g_strdup$56;
              }

              else
              {
                return_value_strcmp$139=strcmp(set_sub, "voice");
                if(return_value_strcmp$139 == 0)
                {
                  g_free((void *)set_sub);
                  tmp_if_expr$140 = 1;
                }

                else
                  tmp_if_expr$140 = 0;
                if(!(tmp_if_expr$140 == 0))
                {
                  char *voice;
                  voice=get_param(buf, 3, bytes, 1);
                  if(voice == ((char *)NULL))
                  {
                    MSG(4, "Missing parameter from client");
                    char *return_value_g_strdup$57;
                    return_value_g_strdup$57=g_strdup("510 ERR MISSING PARAMETER\r\n");
                    return return_value_g_strdup$57;
                  }

                  if(who == 0)
                    ret=set_voice_self(fd, voice);

                  else
                    if(who == 1)
                      ret=set_voice_uid(uid, voice);

                    else
                      if(who == 2)
                        ret=set_voice_all(voice);

                  g_free((void *)voice);
                  if(!(ret == 0))
                  {
                    return_value_g_strdup$58=g_strdup("309 ERR COULDNT SET VOICE\r\n");
                    return return_value_g_strdup$58;
                  }

                  char *return_value_g_strdup$59;
                  return_value_g_strdup$59=g_strdup("209 OK VOICE SET\r\n");
                  return return_value_g_strdup$59;
                }

                else
                {
                  return_value_strcmp$137=strcmp(set_sub, "punctuation");
                  if(return_value_strcmp$137 == 0)
                  {
                    g_free((void *)set_sub);
                    tmp_if_expr$138 = 1;
                  }

                  else
                    tmp_if_expr$138 = 0;
                  if(!(tmp_if_expr$138 == 0))
                  {
                    char *punct_s;
                    enum anonymous$2 punctuation_mode;
                    punct_s=get_param(buf, 3, bytes, 1);
                    if(punct_s == ((char *)NULL))
                    {
                      MSG(4, "Missing parameter from client");
                      char *return_value_g_strdup$60;
                      return_value_g_strdup$60=g_strdup("510 ERR MISSING PARAMETER\r\n");
                      return return_value_g_strdup$60;
                    }

                    signed int return_value_strcmp$66;
                    return_value_strcmp$66=strcmp(punct_s, "all");
                    if(return_value_strcmp$66 == 0)
                    {
                      g_free((void *)punct_s);
                      tmp_if_expr$67 = 1;
                    }

                    else
                      tmp_if_expr$67 = 0;
                    if(!(tmp_if_expr$67 == 0))
                      punctuation_mode = (enum anonymous$2)SPD_PUNCT_ALL;

                    else
                    {
                      return_value_strcmp$64=strcmp(punct_s, "some");
                      if(return_value_strcmp$64 == 0)
                      {
                        g_free((void *)punct_s);
                        tmp_if_expr$65 = 1;
                      }

                      else
                        tmp_if_expr$65 = 0;
                      if(!(tmp_if_expr$65 == 0))
                        punctuation_mode = (enum anonymous$2)SPD_PUNCT_SOME;

                      else
                      {
                        return_value_strcmp$62=strcmp(punct_s, "none");
                        if(return_value_strcmp$62 == 0)
                        {
                          g_free((void *)punct_s);
                          tmp_if_expr$63 = 1;
                        }

                        else
                          tmp_if_expr$63 = 0;
                        if(!(tmp_if_expr$63 == 0))
                          punctuation_mode = (enum anonymous$2)SPD_PUNCT_NONE;

                        else
                        {
                          g_free((void *)punct_s);
                          char *return_value_g_strdup$61;
                          return_value_g_strdup$61=g_strdup("514 ERR PARAMETER INVALID\r\n");
                          return return_value_g_strdup$61;
                        }
                      }
                    }
                    if(who == 0)
                      ret=set_punctuation_mode_self(fd, punctuation_mode);

                    else
                      if(who == 1)
                        ret=set_punctuation_mode_uid(uid, punctuation_mode);

                      else
                        if(who == 2)
                          ret=set_punctuation_mode_all(punctuation_mode);

                    if(!(ret == 0))
                    {
                      return_value_g_strdup$68=g_strdup("305 ERR COULDNT SET PUNCT MODE\r\n");
                      return return_value_g_strdup$68;
                    }

                    char *return_value_g_strdup$69;
                    return_value_g_strdup$69=g_strdup("205 OK PUNCTUATION SET\r\n");
                    return return_value_g_strdup$69;
                  }

                  else
                  {
                    return_value_strcmp$135=strcmp(set_sub, "output_module");
                    if(return_value_strcmp$135 == 0)
                    {
                      g_free((void *)set_sub);
                      tmp_if_expr$136 = 1;
                    }

                    else
                      tmp_if_expr$136 = 0;
                    if(!(tmp_if_expr$136 == 0))
                    {
                      char *output_module;
                      if(speechd_socket->inside_block >= 1)
                      {
                        return_value_g_strdup$70=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
                        return return_value_g_strdup$70;
                      }

                      output_module=get_param(buf, 3, bytes, 1);
                      if(output_module == ((char *)NULL))
                      {
                        MSG(4, "Missing parameter from client");
                        char *return_value_g_strdup$71;
                        return_value_g_strdup$71=g_strdup("510 ERR MISSING PARAMETER\r\n");
                        return return_value_g_strdup$71;
                      }

                      if(who == 0)
                        ret=set_output_module_self(fd, output_module);

                      else
                        if(who == 1)
                          ret=set_output_module_uid(uid, output_module);

                        else
                          if(who == 2)
                            ret=set_output_module_all(output_module);

                      g_free((void *)output_module);
                      if(!(ret == 0))
                      {
                        return_value_g_strdup$72=g_strdup("312 ERR COULDNT SET OUTPUT MODULE\r\n");
                        return return_value_g_strdup$72;
                      }

                      char *return_value_g_strdup$73;
                      return_value_g_strdup$73=g_strdup("216 OK OUTPUT MODULE SET\r\n");
                      return return_value_g_strdup$73;
                    }

                    else
                    {
                      return_value_strcmp$133=strcmp(set_sub, "cap_let_recogn");
                      if(return_value_strcmp$133 == 0)
                      {
                        g_free((void *)set_sub);
                        tmp_if_expr$134 = 1;
                      }

                      else
                        tmp_if_expr$134 = 0;
                      if(!(tmp_if_expr$134 == 0))
                      {
                        signed int capital_letter_recognition;
                        char *recognition;
                        recognition=get_param(buf, 3, bytes, 1);
                        if(recognition == ((char *)NULL))
                        {
                          MSG(4, "Missing parameter from client");
                          char *return_value_g_strdup$74;
                          return_value_g_strdup$74=g_strdup("510 ERR MISSING PARAMETER\r\n");
                          return return_value_g_strdup$74;
                        }

                        signed int return_value_strcmp$80;
                        return_value_strcmp$80=strcmp(recognition, "none");
                        if(return_value_strcmp$80 == 0)
                        {
                          g_free((void *)recognition);
                          tmp_if_expr$81 = 1;
                        }

                        else
                          tmp_if_expr$81 = 0;
                        if(!(tmp_if_expr$81 == 0))
                          capital_letter_recognition = SPD_CAP_NONE;

                        else
                        {
                          return_value_strcmp$78=strcmp(recognition, "spell");
                          if(return_value_strcmp$78 == 0)
                          {
                            g_free((void *)recognition);
                            tmp_if_expr$79 = 1;
                          }

                          else
                            tmp_if_expr$79 = 0;
                          if(!(tmp_if_expr$79 == 0))
                            capital_letter_recognition = SPD_CAP_SPELL;

                          else
                          {
                            return_value_strcmp$76=strcmp(recognition, "icon");
                            if(return_value_strcmp$76 == 0)
                            {
                              g_free((void *)recognition);
                              tmp_if_expr$77 = 1;
                            }

                            else
                              tmp_if_expr$77 = 0;
                            if(!(tmp_if_expr$77 == 0))
                              capital_letter_recognition = SPD_CAP_ICON;

                            else
                            {
                              g_free((void *)recognition);
                              char *return_value_g_strdup$75;
                              return_value_g_strdup$75=g_strdup("514 ERR PARAMETER INVALID\r\n");
                              return return_value_g_strdup$75;
                            }
                          }
                        }
                        if(who == 0)
                          ret=set_capital_letter_recognition_self(fd, (enum anonymous$4)capital_letter_recognition);

                        else
                          if(who == 1)
                            ret=set_capital_letter_recognition_uid(uid, (enum anonymous$4)capital_letter_recognition);

                          else
                            if(who == 2)
                              ret=set_capital_letter_recognition_all((enum anonymous$4)capital_letter_recognition);

                        if(!(ret == 0))
                        {
                          return_value_g_strdup$82=g_strdup("306 ERR COULDNT SET CAP LET RECOGNITION\r\n");
                          return return_value_g_strdup$82;
                        }

                        char *return_value_g_strdup$83;
                        return_value_g_strdup$83=g_strdup("206 OK CAP LET RECOGNITION SET\r\n");
                        return return_value_g_strdup$83;
                      }

                      else
                      {
                        return_value_strcmp$131=strcmp(set_sub, "pause_context");
                        if(return_value_strcmp$131 == 0)
                        {
                          g_free((void *)set_sub);
                          tmp_if_expr$132 = 1;
                        }

                        else
                          tmp_if_expr$132 = 0;
                        if(!(tmp_if_expr$132 == 0))
                        {
                          signed int pause_context;
                          char *parse_set$$1$$16$$1$$helper;
                          parse_set$$1$$16$$1$$helper=get_param(buf, 3, bytes, 0);
                          if(parse_set$$1$$16$$1$$helper == ((char *)NULL))
                          {
                            MSG(4, "Missing parameter from client");
                            char *return_value_g_strdup$84;
                            return_value_g_strdup$84=g_strdup("510 ERR MISSING PARAMETER\r\n");
                            return return_value_g_strdup$84;
                          }

                          signed int return_value_isanum$86;
                          return_value_isanum$86=isanum(parse_set$$1$$16$$1$$helper);
                          if(return_value_isanum$86 == 0)
                          {
                            g_free((void *)parse_set$$1$$16$$1$$helper);
                            char *return_value_g_strdup$85;
                            return_value_g_strdup$85=g_strdup("511 ERR PARAMETER NOT A NUMBER\r\n");
                            return return_value_g_strdup$85;
                          }

                          pause_context=atoi(parse_set$$1$$16$$1$$helper);
                          g_free((void *)parse_set$$1$$16$$1$$helper);
                          if(who == 0)
                            ret=set_pause_context_self(fd, pause_context);

                          else
                            if(who == 1)
                              ret=set_pause_context_uid(uid, pause_context);

                            else
                              if(who == 2)
                                ret=set_pause_context_all(pause_context);

                          if(!(ret == 0))
                          {
                            return_value_g_strdup$87=g_strdup("313 ERR COULDNT SET PAUSE CONTEXT\r\n");
                            return return_value_g_strdup$87;
                          }

                          char *return_value_g_strdup$88;
                          return_value_g_strdup$88=g_strdup("217 OK PAUSE CONTEXT SET\r\n");
                          return return_value_g_strdup$88;
                        }

                        else
                        {
                          return_value_strcmp$130=strcmp(set_sub, "spelling");
                          if(return_value_strcmp$130 == 0)
                          {
                            char *helper_s;
                            signed int spelling;
                            if(speechd_socket->inside_block >= 1)
                            {
                              return_value_g_strdup$89=g_strdup("332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
                              return return_value_g_strdup$89;
                            }

                            helper_s=get_param(buf, 3, bytes, 1);
                            if(helper_s == ((char *)NULL))
                            {
                              MSG(4, "Missing parameter from client");
                              char *return_value_g_strdup$90;
                              return_value_g_strdup$90=g_strdup("510 ERR MISSING PARAMETER\r\n");
                              return return_value_g_strdup$90;
                            }

                            signed int return_value_strcmp$94;
                            return_value_strcmp$94=strcmp(helper_s, "on");
                            if(return_value_strcmp$94 == 0)
                            {
                              g_free((void *)helper_s);
                              tmp_if_expr$95 = 1;
                            }

                            else
                              tmp_if_expr$95 = 0;
                            if(!(tmp_if_expr$95 == 0))
                              spelling = 1;

                            else
                            {
                              return_value_strcmp$92=strcmp(helper_s, "off");
                              if(return_value_strcmp$92 == 0)
                              {
                                g_free((void *)helper_s);
                                tmp_if_expr$93 = 1;
                              }

                              else
                                tmp_if_expr$93 = 0;
                              if(!(tmp_if_expr$93 == 0))
                                spelling = 0;

                              else
                              {
                                g_free((void *)helper_s);
                                char *return_value_g_strdup$91;
                                return_value_g_strdup$91=g_strdup("513 ERR PARAMETER NOT ON OR OFF\r\n");
                                return return_value_g_strdup$91;
                              }
                            }
                            if(who == 0)
                              ret=set_spelling_self(fd, (enum anonymous$1)spelling);

                            else
                              if(who == 1)
                                ret=set_spelling_uid(uid, (enum anonymous$1)spelling);

                              else
                                if(who == 2)
                                  ret=set_spelling_all((enum anonymous$1)spelling);

                            if(!(ret == 0))
                            {
                              return_value_g_strdup$96=g_strdup("308 ERR COULDNT SET SPELLING\r\n");
                              return return_value_g_strdup$96;
                            }

                            char *return_value_g_strdup$97;
                            return_value_g_strdup$97=g_strdup("207 OK SPELLING SET\r\n");
                            return return_value_g_strdup$97;
                          }

                          else
                          {
                            return_value_strcmp$129=strcmp(set_sub, "ssml_mode");
                            if(return_value_strcmp$129 == 0)
                            {
                              char *parse_set$$1$$18$$helper_s;
                              signed int ssml_mode;
                              parse_set$$1$$18$$helper_s=get_param(buf, 3, bytes, 1);
                              if(parse_set$$1$$18$$helper_s == ((char *)NULL))
                              {
                                MSG(4, "Missing parameter from client");
                                char *return_value_g_strdup$98;
                                return_value_g_strdup$98=g_strdup("510 ERR MISSING PARAMETER\r\n");
                                return return_value_g_strdup$98;
                              }

                              signed int return_value_strcmp$102;
                              return_value_strcmp$102=strcmp(parse_set$$1$$18$$helper_s, "on");
                              if(return_value_strcmp$102 == 0)
                              {
                                g_free((void *)parse_set$$1$$18$$helper_s);
                                tmp_if_expr$103 = 1;
                              }

                              else
                                tmp_if_expr$103 = 0;
                              if(!(tmp_if_expr$103 == 0))
                                ssml_mode = 1;

                              else
                              {
                                return_value_strcmp$100=strcmp(parse_set$$1$$18$$helper_s, "off");
                                if(return_value_strcmp$100 == 0)
                                {
                                  g_free((void *)parse_set$$1$$18$$helper_s);
                                  tmp_if_expr$101 = 1;
                                }

                                else
                                  tmp_if_expr$101 = 0;
                                if(!(tmp_if_expr$101 == 0))
                                  ssml_mode = 0;

                                else
                                {
                                  g_free((void *)parse_set$$1$$18$$helper_s);
                                  char *return_value_g_strdup$99;
                                  return_value_g_strdup$99=g_strdup("513 ERR PARAMETER NOT ON OR OFF\r\n");
                                  return return_value_g_strdup$99;
                                }
                              }
                              if(who == 0)
                                ret=set_ssml_mode_self(fd, (enum anonymous$5)ssml_mode);

                              else
                                if(who == 1)
                                  ret=set_ssml_mode_uid(uid, (enum anonymous$5)ssml_mode);

                                else
                                  if(who == 2)
                                    ret=set_ssml_mode_all((enum anonymous$5)ssml_mode);

                              if(!(ret == 0))
                              {
                                return_value_g_strdup$104=g_strdup("315 ERR COULDNT SET SSML MODE\r\n");
                                return return_value_g_strdup$104;
                              }

                              char *return_value_g_strdup$105;
                              return_value_g_strdup$105=g_strdup("219 OK SSML MODE SET\r\n");
                              return return_value_g_strdup$105;
                            }

                            else
                            {
                              return_value_strcmp$128=strcmp(set_sub, "debug");
                              if(return_value_strcmp$128 == 0)
                              {
                                char *parse_set$$1$$19$$helper_s;
                                signed int debug;
                                parse_set$$1$$19$$helper_s=get_param(buf, 3, bytes, 1);
                                if(parse_set$$1$$19$$helper_s == ((char *)NULL))
                                {
                                  MSG(4, "Missing parameter from client");
                                  char *return_value_g_strdup$106;
                                  return_value_g_strdup$106=g_strdup("510 ERR MISSING PARAMETER\r\n");
                                  return return_value_g_strdup$106;
                                }

                                signed int return_value_strcmp$110;
                                return_value_strcmp$110=strcmp(parse_set$$1$$19$$helper_s, "on");
                                if(return_value_strcmp$110 == 0)
                                {
                                  g_free((void *)parse_set$$1$$19$$helper_s);
                                  tmp_if_expr$111 = 1;
                                }

                                else
                                  tmp_if_expr$111 = 0;
                                if(!(tmp_if_expr$111 == 0))
                                  debug = 1;

                                else
                                {
                                  return_value_strcmp$108=strcmp(parse_set$$1$$19$$helper_s, "off");
                                  if(return_value_strcmp$108 == 0)
                                  {
                                    g_free((void *)parse_set$$1$$19$$helper_s);
                                    tmp_if_expr$109 = 1;
                                  }

                                  else
                                    tmp_if_expr$109 = 0;
                                  if(!(tmp_if_expr$109 == 0))
                                    debug = 0;

                                  else
                                  {
                                    g_free((void *)parse_set$$1$$19$$helper_s);
                                    char *return_value_g_strdup$107;
                                    return_value_g_strdup$107=g_strdup("513 ERR PARAMETER NOT ON OR OFF\r\n");
                                    return return_value_g_strdup$107;
                                  }
                                }
                                if(who == 0)
                                  ret=set_debug_self(fd, debug);

                                else
                                  if(who == 1)
                                    ret=set_debug_uid(uid, debug);

                                  else
                                    if(who == 2)
                                      ret=set_debug_all(debug);

                                if(!(ret == 0))
                                {
                                  return_value_g_strdup$112=g_strdup("317 ERR COULDNT SET DEBUGGING\r\n");
                                  return return_value_g_strdup$112;
                                }

                                char *return_value_g_strdup_printf$113;
                                return_value_g_strdup_printf$113=g_strdup_printf("262-%s\r\n262 OK DEBUGGING SET\r\n", SpeechdOptions.debug_destination);
                                char *return_value_g_strdup$114;
                                return_value_g_strdup$114=g_strdup(return_value_g_strdup_printf$113);
                                return return_value_g_strdup$114;
                              }

                              else
                              {
                                return_value_strcmp$126=strcmp(set_sub, "notification");
                                if(return_value_strcmp$126 == 0)
                                {
                                  g_free((void *)set_sub);
                                  tmp_if_expr$127 = 1;
                                }

                                else
                                  tmp_if_expr$127 = 0;
                                if(!(tmp_if_expr$127 == 0))
                                {
                                  char *scope;
                                  char *par_s;
                                  signed int par;
                                  if(!(who == 0))
                                  {
                                    return_value_g_strdup$115=g_strdup("514 ERR PARAMETER INVALID\r\n");
                                    return return_value_g_strdup$115;
                                  }

                                  scope=get_param(buf, 3, bytes, 1);
                                  if(scope == ((char *)NULL))
                                  {
                                    MSG(4, "Missing parameter from client");
                                    char *return_value_g_strdup$116;
                                    return_value_g_strdup$116=g_strdup("510 ERR MISSING PARAMETER\r\n");
                                    return return_value_g_strdup$116;
                                  }

                                  par_s=get_param(buf, 4, bytes, 1);
                                  if(par_s == ((char *)NULL))
                                  {
                                    MSG(4, "Missing parameter from client");
                                    char *return_value_g_strdup$117;
                                    return_value_g_strdup$117=g_strdup("510 ERR MISSING PARAMETER\r\n");
                                    return return_value_g_strdup$117;
                                  }

                                  signed int return_value_strcmp$121;
                                  return_value_strcmp$121=strcmp(par_s, "on");
                                  if(return_value_strcmp$121 == 0)
                                  {
                                    g_free((void *)par_s);
                                    tmp_if_expr$122 = 1;
                                  }

                                  else
                                    tmp_if_expr$122 = 0;
                                  if(!(tmp_if_expr$122 == 0))
                                    par = 1;

                                  else
                                  {
                                    return_value_strcmp$119=strcmp(par_s, "off");
                                    if(return_value_strcmp$119 == 0)
                                    {
                                      g_free((void *)par_s);
                                      tmp_if_expr$120 = 1;
                                    }

                                    else
                                      tmp_if_expr$120 = 0;
                                    if(!(tmp_if_expr$120 == 0))
                                      par = 0;

                                    else
                                    {
                                      g_free((void *)par_s);
                                      char *return_value_g_strdup$118;
                                      return_value_g_strdup$118=g_strdup("514 ERR PARAMETER INVALID\r\n");
                                      return return_value_g_strdup$118;
                                    }
                                  }
                                  ret=set_notification_self(fd, scope, par);
                                  g_free((void *)scope);
                                  if(!(ret == 0))
                                  {
                                    return_value_g_strdup$123=g_strdup("316 ERR COULDNT SET NOTIFICATION\r\n");
                                    return return_value_g_strdup$123;
                                  }

                                  char *return_value_g_strdup$124;
                                  return_value_g_strdup$124=g_strdup("220 OK NOTIFICATION SET\r\n");
                                  return return_value_g_strdup$124;
                                }

                                else
                                {
                                  g_free((void *)set_sub);
                                  char *return_value_g_strdup$125;
                                  return_value_g_strdup$125=g_strdup("514 ERR PARAMETER INVALID\r\n");
                                  return return_value_g_strdup$125;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  char *return_value_g_strdup$155;
  return_value_g_strdup$155=g_strdup("500 ERR INVALID COMMAND\r\n");
  return return_value_g_strdup$155;
}

// parse_snd_icon
// file parse.c line 794
char * parse_snd_icon(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  char *return_value_parse_general_event$1;
  return_value_parse_general_event$1=parse_general_event(buf, bytes, fd, speechd_socket, (enum anonymous$8)SPD_MSGTYPE_SOUND_ICON);
  return return_value_parse_general_event$1;
}

// parse_stop
// file parse.c line 612
char * parse_stop(const char *buf, const signed int bytes, const signed int fd, const struct anonymous$0 *speechd_socket)
{
  signed int uid = 0;
  char *who_s;
  MSG(5, "Stop received from fd %d.", fd);
  who_s=get_param(buf, 1, bytes, 1);
  if(who_s == ((char *)NULL))
  {
    MSG(4, "Missing parameter from client");
    char *return_value_g_strdup$1;
    return_value_g_strdup$1=g_strdup("510 ERR MISSING PARAMETER\r\n");
    return return_value_g_strdup$1;
  }

  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(who_s, "all");
  signed int tmp_if_expr$9;
  if(return_value_strcmp$8 == 0)
  {
    g_free((void *)who_s);
    tmp_if_expr$9 = 1;
  }

  else
    tmp_if_expr$9 = 0;
  signed int return_value_strcmp$6;
  signed int tmp_if_expr$7;
  char *return_value_g_strdup$2;
  signed int return_value_isanum$5;
  char *return_value_g_strdup$3;
  if(!(tmp_if_expr$9 == 0))
  {
    pthread_mutex_lock(&element_free_mutex);
    speaking_stop_all();
    pthread_mutex_unlock(&element_free_mutex);
  }

  else
  {
    return_value_strcmp$6=strcmp(who_s, "self");
    if(return_value_strcmp$6 == 0)
    {
      g_free((void *)who_s);
      tmp_if_expr$7 = 1;
    }

    else
      tmp_if_expr$7 = 0;
    if(!(tmp_if_expr$7 == 0))
    {
      uid=get_client_uid_by_fd(fd);
      if(uid == 0)
      {
        return_value_g_strdup$2=g_strdup("300 ERR INTERNAL\r\n");
        return return_value_g_strdup$2;
      }

      pthread_mutex_lock(&element_free_mutex);
      speaking_stop(uid);
      pthread_mutex_unlock(&element_free_mutex);
    }

    else
    {
      return_value_isanum$5=isanum(who_s);
      if(!(return_value_isanum$5 == 0))
      {
        uid=atoi(who_s);
        g_free((void *)who_s);
        if(!(uid >= 1))
        {
          return_value_g_strdup$3=g_strdup("406 ERR ID DOESNT EXIST\r\n");
          return return_value_g_strdup$3;
        }

        pthread_mutex_lock(&element_free_mutex);
        speaking_stop(uid);
        pthread_mutex_unlock(&element_free_mutex);
      }

      else
      {
        g_free((void *)who_s);
        char *return_value_g_strdup$4;
        return_value_g_strdup$4=g_strdup("514 ERR PARAMETER INVALID\r\n");
        return return_value_g_strdup$4;
      }
    }
  }
  char *return_value_g_strdup$10;
  return_value_g_strdup$10=g_strdup("210 OK STOPPED\r\n");
  return return_value_g_strdup$10;
}

// queue_message
// file server.c line 68
signed int queue_message(struct anonymous$7 *new, signed int fd, signed int history_flag, enum anonymous$8 type, signed int reparted)
{
  struct anonymous$11 *settings;
  struct anonymous$7 *message_copy;
  signed int id;
  struct _GList *element;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  if(new == ((struct anonymous$7 *)NULL))
    return -1;

  else
    if(new->buf == ((char *)NULL))
      return -1;

    else
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(new->buf);
      if(!(return_value_strlen$1 >= 1ul))
        return -1;

      else
      {
        if(fd >= 1)
        {
          settings=get_client_settings_by_fd(fd);
          if(settings == ((struct anonymous$11 *)NULL))
          {
            fatal_error();
            MSG(-1, "Fatal error [%s:%d]:Couldn't find settings for active client, internal error.", (const void *)"server.c", 89);
            exit(1);
          }

        }

        else
          if(!(fd >= 0))
            settings=get_client_settings_by_uid(-fd);

          else
            return -1;
        MSG(5, "In queue_message desired output module is %s", settings->output_module);
        if(fd >= 1)
        {
          new->settings = *settings;
          new->settings.type = type;
          new->settings.index_mark = (char *)(void *)0;
          char *return_value_g_strdup$2;
          return_value_g_strdup$2=g_strdup(settings->client_name);
          new->settings.client_name = (char *)return_value_g_strdup$2;
          char *return_value_g_strdup$3;
          return_value_g_strdup$3=g_strdup(settings->output_module);
          new->settings.output_module = (char *)return_value_g_strdup$3;
          char *return_value_g_strdup$4;
          return_value_g_strdup$4=g_strdup(settings->msg_settings.voice.language);
          new->settings.msg_settings.voice.language = (char *)return_value_g_strdup$4;
          char *return_value_g_strdup$5;
          return_value_g_strdup$5=g_strdup(settings->msg_settings.voice.name);
          new->settings.msg_settings.voice.name = (char *)return_value_g_strdup$5;
          char *return_value_g_strdup$6;
          return_value_g_strdup$6=g_strdup(settings->index_mark);
          new->settings.index_mark = (char *)return_value_g_strdup$6;
          char *return_value_g_strdup$7;
          return_value_g_strdup$7=g_strdup(settings->audio_output_method);
          new->settings.audio_output_method = (char *)return_value_g_strdup$7;
          char *return_value_g_strdup$8;
          return_value_g_strdup$8=g_strdup(settings->audio_oss_device);
          new->settings.audio_oss_device = (char *)return_value_g_strdup$8;
          char *return_value_g_strdup$9;
          return_value_g_strdup$9=g_strdup(settings->audio_alsa_device);
          new->settings.audio_alsa_device = (char *)return_value_g_strdup$9;
          char *return_value_g_strdup$10;
          return_value_g_strdup$10=g_strdup(settings->audio_nas_server);
          new->settings.audio_nas_server = (char *)return_value_g_strdup$10;
          char *return_value_g_strdup$11;
          return_value_g_strdup$11=g_strdup(settings->audio_pulse_server);
          new->settings.audio_pulse_server = (char *)return_value_g_strdup$11;
          last_message_id = last_message_id + 1;
          new->id = (unsigned int)last_message_id;
          new->time=time((signed long int *)(void *)0);
          new->settings.paused_while_speaking = 0;
        }

        id = (signed int)new->id;
        new->settings.reparted = reparted;
        MSG(5, "Queueing message |%s| with priority %d", new->buf, settings->priority);
        pthread_mutex_lock(&element_free_mutex);
        check_locked(&element_free_mutex);
        switch((signed int)settings->priority)
        {
          case SPD_IMPORTANT:
          {
            MessageQueue->p1=g_list_append(MessageQueue->p1, (void *)new);
            break;
          }
          case SPD_MESSAGE:
          {
            MessageQueue->p2=g_list_append(MessageQueue->p2, (void *)new);
            break;
          }
          case SPD_TEXT:
          {
            MessageQueue->p3=g_list_append(MessageQueue->p3, (void *)new);
            break;
          }
          case SPD_NOTIFICATION:
          {
            MessageQueue->p4=g_list_append(MessageQueue->p4, (void *)new);
            break;
          }
          case SPD_PROGRESS:
          {
            MessageQueue->p5=g_list_append(MessageQueue->p5, (void *)new);
            element=g_list_last(last_p5_block);
            if(element == ((struct _GList *)NULL))
              tmp_if_expr$12 = (_Bool)1;

            else
              tmp_if_expr$12 = !(element->data != NULL) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$12)
              tmp_if_expr$13 = (_Bool)1;

            else
              tmp_if_expr$13 = ((struct anonymous$7 *)element->data)->settings.reparted != new->settings.reparted ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$13)
            {
              g_list_foreach(last_p5_block, (void (*)(void *, void *))mem_free_message, (void *)0);
              g_list_free(last_p5_block);
              last_p5_block = (struct _GList *)(void *)0;
            }

            message_copy=spd_message_copy(new);
            if(!(message_copy == ((struct anonymous$7 *)NULL)))
              last_p5_block=g_list_append(last_p5_block, (void *)message_copy);

            break;
          }
          default:
          {
            fatal_error();
            MSG(-1, "Fatal error [%s:%d]:Nonexistent priority given", (const void *)"server.c", 180);
            exit(1);
          }
        }
        resolve_priorities(settings->priority);
        pthread_mutex_unlock(&element_free_mutex);
        speaking_semaphore_post();
        MSG(5, "Message inserted into queue.");
        return id;
      }
    }
}

// queue_remove_message
// file speaking.c line 762
struct _GList * queue_remove_message(struct _GList *queue, struct _GList *gl)
{
  struct anonymous$7 *msg;
  /* assertion gl != ((void *)0) */
  assert(gl != (struct _GList *)(void *)0);
  /* assertion gl->data != ((void *)0) */
  assert(gl->data != (void *)0);
  msg = (struct anonymous$7 *)gl->data;
  if(!((SPD_CANCEL & (signed int)msg->settings.notification) == 0))
    report_cancel(msg);

  mem_free_message((struct anonymous$7 *)gl->data);
  queue=g_list_delete_link(queue, gl);
  return queue;
}

// reload_message
// file speaking.c line 304
signed int reload_message(struct anonymous$7 *msg)
{
  struct anonymous$11 *client_settings;
  signed int im;
  char *pos;
  char *newtext;
  char *tptr;
  if(msg == ((struct anonymous$7 *)NULL))
  {
    MSG(4, "Warning: msg == NULL in reload_message()");
    return -1;
  }

  else
  {
    if(!(msg->settings.index_mark == ((char *)NULL)))
    {
      MSG(5, "Recovering index mark %s", msg->settings.index_mark);
      client_settings=get_client_settings_by_uid((signed int)msg->settings.uid);
      MSG(5, "Recovering index mark (number)");
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(msg->settings.index_mark + (signed long int)6, &tptr, 10);
      im = (signed int)return_value_strtol$1;
      MSG(5, "Recovering index mark (comparing tptr)");
      if(msg->settings.index_mark + 6l == tptr)
      {
        MSG2(2, "index_marking", "ERROR: Invalid index_mark '%s'. Message not reloaded.", msg->settings.index_mark);
        return -1;
      }

      MSG(5, "Recovered index mark number: %d", im);
      im = im + client_settings->pause_context;
      MSG2(5, "index_marking", "Requested index mark (with context) is %d (%d+%d)", im, msg->settings.index_mark, client_settings->pause_context);
      if(!(im >= 0))
      {
        im = 0;
        pos = msg->buf;
      }

      else
      {
        pos=find_index_mark(msg, im);
        if(pos == ((char *)NULL))
          return -1;

      }
      newtext=strip_index_marks(pos, client_settings->ssml_mode);
      g_free((void *)msg->buf);
      if(newtext == ((char *)NULL))
        return -1;

      msg->buf = newtext;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(msg->buf);
      msg->bytes = (signed int)return_value_strlen$2;
      signed int return_value_queue_message$3;
      return_value_queue_message$3=queue_message(msg, (signed int)-msg->settings.uid, 0, (enum anonymous$8)SPD_MSGTYPE_TEXT, 0);
      if(return_value_queue_message$3 == 0)
      {
        g_free((void *)msg->buf);
        g_free((void *)msg);
        return -1;
      }

      return 0;
    }

    else
    {
      MSG(5, "Index mark unknown, inserting the whole message.");
      signed int return_value_queue_message$4;
      return_value_queue_message$4=queue_message(msg, (signed int)-msg->settings.uid, 0, (enum anonymous$8)SPD_MSGTYPE_TEXT, 0);
      if(return_value_queue_message$4 == 0)
      {
        g_free((void *)msg->buf);
        g_free((void *)msg);
        return -1;
      }

      return 0;
    }
    return 0;
  }
}

// reload_output_module
// file module.h line 48
signed int reload_output_module(struct anonymous$10 *old_module)
{
  struct anonymous$10 *new_module;
  signed int pos;
  /* assertion old_module != ((void *)0) */
  assert(old_module != (struct anonymous$10 *)(void *)0);
  /* assertion old_module->name != ((void *)0) */
  assert(old_module->name != (char *)(void *)0);
  if(!(old_module->working == 0))
    return 0;

  else
  {
    MSG(3, "Reloading output module %s", old_module->name);
    output_close(old_module);
    close(old_module->pipe_in[(signed long int)1]);
    close(old_module->pipe_out[(signed long int)0]);
    new_module=load_output_module(old_module->name, old_module->filename, old_module->configfilename, old_module->debugfilename);
    if(new_module == ((struct anonymous$10 *)NULL))
    {
      MSG(3, "Can't load module %s while reloading modules.", old_module->name);
      return -1;
    }

    else
    {
      pos=g_list_index(output_modules, (const void *)old_module);
      output_modules=g_list_remove(output_modules, (const void *)old_module);
      output_modules=g_list_insert(output_modules, (void *)new_module, pos);
      destroy_module(old_module);
      return 0;
    }
  }
}

// remove_client_settings_by_uid
// file set.c line 556
void remove_client_settings_by_uid(signed int uid)
{
  struct anonymous$11 *element;
  /* assertion uid > 0 */
  assert(uid > 0);
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(fd_settings, (const void *)&uid);
  element = (struct anonymous$11 *)return_value_g_hash_table_lookup$1;
  if(!(element == ((struct anonymous$11 *)NULL)))
  {
    mem_free_fdset(element);
    g_hash_table_remove(fd_settings, (const void *)&uid);
    g_free((void *)element);
  }

  else
    MSG(5, "Warning: FDSet element to be removed not found");
}

// report_begin
// file speaking.c line 655
signed int report_begin(struct anonymous$7 *msg)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("701-%d\r\n701-%d\r\n701 BEGIN\r\n", msg->id, msg->settings.uid);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(2, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// report_cancel
// file speaking.c line 659
signed int report_cancel(struct anonymous$7 *msg)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("703-%d\r\n703-%d\r\n703 CANCELED\r\n", msg->id, msg->settings.uid);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(2, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// report_end
// file speaking.c line 656
signed int report_end(struct anonymous$7 *msg)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("702-%d\r\n702-%d\r\n702 END\r\n", msg->id, msg->settings.uid);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(2, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// report_index_mark
// file speaking.c line 619
signed int report_index_mark(struct anonymous$7 *msg, char *index_mark)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("700-%d\r\n700-%d\r\n700-%s\r\n700 INDEX MARK\r\n", msg->id, msg->settings.uid, index_mark);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(1, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// report_pause
// file speaking.c line 657
signed int report_pause(struct anonymous$7 *msg)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("704-%d\r\n704-%d\r\n704 PAUSED\r\n", msg->id, msg->settings.uid);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(2, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// report_resume
// file speaking.c line 658
signed int report_resume(struct anonymous$7 *msg)
{
  char *cmd;
  signed int ret;
  cmd=g_strdup_printf("705-%d\r\n705-%d\r\n705 RESUMED\r\n", msg->id, msg->settings.uid);
  ret=socket_send_msg(msg->settings.fd, cmd);
  if(!(ret == 0))
  {
    MSG(2, "ERROR: Can't report index mark!");
    return -1;
  }

  else
  {
    g_free((void *)cmd);
    return 0;
  }
}

// resolve_priorities
// file speaking.h line 82
void resolve_priorities(enum anonymous$9 priority)
{
  if((signed int)priority == SPD_IMPORTANT)
  {
    if(!(SPEAKING == 0) && !((signed int)highest_priority == SPD_IMPORTANT))
      output_stop();

    stop_priority((enum anonymous$9)SPD_NOTIFICATION);
    stop_priority((enum anonymous$9)SPD_PROGRESS);
  }

  if((signed int)priority == SPD_MESSAGE)
  {
    if(!(SPEAKING == 0) && !((signed int)highest_priority == SPD_IMPORTANT) && !((signed int)highest_priority == SPD_MESSAGE))
      output_stop();

    stop_priority((enum anonymous$9)SPD_TEXT);
    stop_priority((enum anonymous$9)SPD_NOTIFICATION);
    stop_priority((enum anonymous$9)SPD_PROGRESS);
  }

  if((signed int)priority == SPD_TEXT)
  {
    stop_priority_except_first((enum anonymous$9)SPD_TEXT);
    stop_priority((enum anonymous$9)SPD_NOTIFICATION);
    stop_priority((enum anonymous$9)SPD_PROGRESS);
  }

  if((signed int)priority == SPD_NOTIFICATION)
  {
    stop_priority_except_first((enum anonymous$9)SPD_NOTIFICATION);
    if(!(SPEAKING == 0) && !((signed int)highest_priority == SPD_NOTIFICATION))
      stop_priority((enum anonymous$9)SPD_NOTIFICATION);

  }

  if((signed int)priority == SPD_PROGRESS)
  {
    stop_priority((enum anonymous$9)SPD_NOTIFICATION);
    if(!(SPEAKING == 0))
    {
      struct _GList *gl;
      check_locked(&element_free_mutex);
      gl=g_list_last(MessageQueue->p5);
      check_locked(&element_free_mutex);
      MessageQueue->p5=g_list_remove_link(MessageQueue->p5, gl);
      if(!(gl == ((struct _GList *)NULL)))
      {
        check_locked(&element_free_mutex);
        MessageQueue->p5=empty_queue(MessageQueue->p5);
        if(!(gl->data == NULL))
          MessageQueue->p5 = gl;

      }

    }

  }

}

// serve
// file server.h line 29
signed int serve(signed int fd)
{
  char *reply;
  signed int ret;
  unsigned long int bytes = (unsigned long int)0;
  signed int buflen = 128;
  char *buf;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)(buflen + 1));
  buf = (char *)return_value_g_malloc$1;
  while((_Bool)1)
  {
    signed int n;
    signed long int return_value_read$2;
    return_value_read$2=read(fd, (void *)(buf + (signed long int)bytes), (unsigned long int)1);
    n = (signed int)return_value_read$2;
    if(!(n >= 1))
    {
      g_free((void *)buf);
      return -1;
    }

    if((signed int)buf[(signed long int)bytes] == 10)
    {
      if(bytes >= 1ul)
      {
        if((signed int)buf[-1l + (signed long int)bytes] == 13)
        {
          bytes = bytes + 1ul;
          buf[(signed long int)bytes] = (char)0;
          break;
        }

      }

    }

    if((signed int)buf[(signed long int)bytes] == 0)
      buf[(signed long int)bytes] = (char)63;

    bytes = bytes + 1ul;
    if(bytes == (unsigned long int)buflen)
    {
      buflen = buflen * 2;
      void *return_value_g_realloc$3;
      return_value_g_realloc$3=g_realloc((void *)buf, (unsigned long int)(buflen + 1));
      buf = (char *)return_value_g_realloc$3;
    }

  }
  MSG2(5, "protocol", "%d:DATA:|%s| (%d)", fd, buf, bytes);
  reply=parse(buf, (const signed int)bytes, fd);
  g_free((void *)buf);
  if(reply == ((char *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Internal error, reply from parse() is NULL!", (const void *)"server.c", 268);
    exit(1);
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(reply);
  if(return_value_strlen$4 == 0ul)
  {
    g_free((void *)reply);
    return 0;
  }

  else
  {
    if(!((signed int)*reply == 57))
    {
      pthread_mutex_lock(&socket_com_mutex);
      MSG2(5, "protocol", "%d:REPLY:|%s|", fd, reply);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(reply);
      signed long int return_value_write$6;
      return_value_write$6=write(fd, (const void *)reply, return_value_strlen$5);
      ret = (signed int)return_value_write$6;
      g_free((void *)reply);
      pthread_mutex_unlock(&socket_com_mutex);
      if(ret == -1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        MSG(5, "write() error: %s", return_value_strerror$8);
        return -1;
      }

    }

    else
      g_free((void *)reply);
    return 0;
  }
}

// server_data_off
// file server.c line 216
void server_data_off(signed int fd)
{
  struct anonymous$0 *speechd_socket;
  speechd_socket=speechd_socket_get_by_fd(fd);
  /* assertion speechd_socket */
  assert(speechd_socket != ((struct anonymous$0 *)NULL));
  /* assertion speechd_socket->o_buf */
  assert(speechd_socket->o_buf != ((struct _GString *)NULL));
  speechd_socket->o_bytes = (unsigned long int)0;
  g_string_free(speechd_socket->o_buf, 1);
  speechd_socket->o_buf = (struct _GString *)(void *)0;
}

// server_data_on
// file server.c line 203
signed int server_data_on(signed int fd)
{
  struct anonymous$0 *speechd_socket;
  speechd_socket=speechd_socket_get_by_fd(fd);
  /* assertion speechd_socket */
  assert(speechd_socket != ((struct anonymous$0 *)NULL));
  speechd_socket->awaiting_data = 1;
  speechd_socket->o_buf=g_string_new("");
  MSG(4, "Switching to data mode...");
  return 0;
}

// set_capital_letter_recognition_all
// file set.h line 87
signed int set_capital_letter_recognition_all(enum anonymous$4 capital_letter_recognition)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_capital_letter_recognition_uid$1;
      return_value_set_capital_letter_recognition_uid$1=set_capital_letter_recognition_uid(uid, capital_letter_recognition);
      err = err + return_value_set_capital_letter_recognition_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_capital_letter_recognition_self
// file set.h line 68
signed int set_capital_letter_recognition_self(signed int fd, enum anonymous$4 capital_letter_recognition)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_capital_letter_recognition_uid$1;
    return_value_set_capital_letter_recognition_uid$1=set_capital_letter_recognition_uid(uid, capital_letter_recognition);
    return return_value_set_capital_letter_recognition_uid$1;
  }
}

// set_capital_letter_recognition_uid
// file set.h line 48
signed int set_capital_letter_recognition_uid(signed int uid, enum anonymous$4 recogn)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->msg_settings.cap_let_recogn = recogn;
    return 0;
  }
}

// set_client_name_self
// file set.h line 64
signed int set_client_name_self(signed int fd, char *client_name)
{
  struct anonymous$11 *settings;
  signed int dividers = 0;
  signed int i;
  /* assertion client_name != ((void *)0) */
  assert(client_name != (char *)(void *)0);
  settings=get_client_settings_by_fd(fd);
  unsigned long int return_value_strlen$1;
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    i = 0;
    do
    {
      return_value_strlen$1=strlen(client_name);
      if(!(return_value_strlen$1 + 18446744073709551615ul >= (unsigned long int)i))
        break;

      if((signed int)client_name[(signed long int)i] == 58)
        dividers = dividers + 1;

      i = i + 1;
    }
    while((_Bool)1);
    if(!(dividers == 2))
      return 1;

    else
    {
      settings->client_name=set_param_str(settings->client_name, client_name);
      g_list_foreach(client_specific_settings, update_cl_settings, (void *)settings);
      return 0;
    }
  }
}

// set_debug_all
// file set.h line 90
signed int set_debug_all(signed int debug)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_debug_uid$1;
      return_value_set_debug_uid$1=set_debug_uid(uid, debug);
      err = err + return_value_set_debug_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_debug_self
// file set.h line 72
signed int set_debug_self(signed int fd, signed int debug)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_debug_uid$1;
    return_value_set_debug_uid$1=set_debug_uid(uid, debug);
    return return_value_set_debug_uid$1;
  }
}

// set_debug_uid
// file set.h line 52
signed int set_debug_uid(signed int uid, signed int debug)
{
  char *debug_logfile_path;
  if(!(SpeechdOptions.debug == 0) && !(debug == 0))
    return 1;

  else
    if(SpeechdOptions.debug == 0 && debug == 0)
      return 1;

    else
    {
      if(!(debug == 0))
      {
        debug_logfile_path=g_strdup_printf("%s/speech-dispatcher.log", SpeechdOptions.debug_destination);
        debug_logfile=fopen(debug_logfile_path, "w");
        if(debug_logfile == ((struct _IO_FILE *)NULL))
        {
          MSG(3, "Error: can't open additional debug logging file %s!\n", debug_logfile_path);
          return 1;
        }

        SpeechdOptions.debug = debug;
        g_free((void *)debug_logfile_path);
        speechd_modules_debug();
      }

      else
      {
        SpeechdOptions.debug = 0;
        speechd_modules_nodebug();
        fclose(debug_logfile);
      }
      return 0;
    }
}

// set_language_all
// file set.h line 76
signed int set_language_all(char *language)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_language_uid$1;
      return_value_set_language_uid$1=set_language_uid(uid, language);
      err = err + return_value_set_language_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_language_self
// file set.h line 56
signed int set_language_self(signed int fd, char *language)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_language_uid$1;
    return_value_set_language_uid$1=set_language_uid(uid, language);
    return return_value_set_language_uid$1;
  }
}

// set_language_uid
// file set.h line 37
signed int set_language_uid(signed int uid, char *language)
{
  struct anonymous$11 *settings;
  char *output_module;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->msg_settings.voice.language=set_param_str(settings->msg_settings.voice.language, language);
    void *return_value_g_hash_table_lookup$1;
    return_value_g_hash_table_lookup$1=g_hash_table_lookup(language_default_modules, (const void *)language);
    output_module = (char *)return_value_g_hash_table_lookup$1;
    if(!(output_module == ((char *)NULL)))
      set_output_module_uid(uid, output_module);

    return 0;
  }
}

// set_notification_self
// file set.h line 70
signed int set_notification_self(signed int fd, char *type, signed int val)
{
  struct anonymous$11 *settings;
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(uid == 0)
    return 1;

  else
  {
    settings=get_client_settings_by_uid(uid);
    if(settings == ((struct anonymous$11 *)NULL))
      return 1;

    else
    {
      signed int return_value_strcmp$7;
      return_value_strcmp$7=strcmp(type, "begin");
      if(return_value_strcmp$7 == 0)
      {
        if(!(val == 0))
          settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_BEGIN);

        else
          settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_BEGIN != 0));
      }

      else
      {
        return_value_strcmp$6=strcmp(type, "end");
        if(return_value_strcmp$6 == 0)
        {
          if(!(val == 0))
            settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_END);

          else
            settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_END != 0));
        }

        else
        {
          return_value_strcmp$5=strcmp(type, "index_marks");
          if(return_value_strcmp$5 == 0)
          {
            if(!(val == 0))
              settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_INDEX_MARKS);

            else
              settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_INDEX_MARKS != 0));
          }

          else
          {
            return_value_strcmp$4=strcmp(type, "pause");
            if(return_value_strcmp$4 == 0)
            {
              if(!(val == 0))
                settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_PAUSE);

              else
                settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_PAUSE != 0));
            }

            else
            {
              return_value_strcmp$3=strcmp(type, "resume");
              if(return_value_strcmp$3 == 0)
              {
                if(!(val == 0))
                  settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_RESUME);

                else
                  settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_RESUME != 0));
              }

              else
              {
                return_value_strcmp$2=strcmp(type, "cancel");
                if(return_value_strcmp$2 == 0)
                {
                  if(!(val == 0))
                    settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_CANCEL);

                  else
                    settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_CANCEL != 0));
                }

                else
                {
                  return_value_strcmp$1=strcmp(type, "all");
                  if(return_value_strcmp$1 == 0)
                  {
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_END);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_END != 0));
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_BEGIN);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_BEGIN != 0));
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_INDEX_MARKS);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_INDEX_MARKS != 0));
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_CANCEL);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_CANCEL != 0));
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_PAUSE);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_PAUSE != 0));
                    if(!(val == 0))
                      settings->notification = (enum anonymous$17)((signed int)settings->notification | SPD_RESUME);

                    else
                      settings->notification = (enum anonymous$17)((signed int)settings->notification & (signed int)!(SPD_RESUME != 0));
                  }

                  else
                    return 1;
                }
              }
            }
          }
        }
      }
      return 0;
    }
  }
}

// set_output_module_all
// file set.h line 83
signed int set_output_module_all(char *output_module)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_output_module_uid$1;
      return_value_set_output_module_uid$1=set_output_module_uid(uid, output_module);
      err = err + return_value_set_output_module_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_output_module_self
// file set.h line 44
signed int set_output_module_self(signed int fd, char *output_module)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_output_module_uid$1;
    return_value_set_output_module_uid$1=set_output_module_uid(uid, output_module);
    return return_value_set_output_module_uid$1;
  }
}

// set_output_module_uid
// file set.h line 49
signed int set_output_module_uid(signed int uid, char *output_module)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
    if(output_module == ((char *)NULL))
      return 1;

    else
    {
      MSG(5, "Setting output module to %s", output_module);
      MSG(5, "In set_output_module the desired output module is x%s", output_module);
      settings->output_module=set_param_str(settings->output_module, output_module);
      if(!(settings->msg_settings.voice.name == ((char *)NULL)))
      {
        g_free((void *)settings->msg_settings.voice.name);
        settings->msg_settings.voice.name = (char *)(void *)0;
      }

      return 0;
    }
}

// set_param_str
// file set.c line 570
char * set_param_str(char *parameter, char *value)
{
  char *new;
  if(value == ((char *)NULL))
  {
    new = (char *)(void *)0;
    return new;
  }

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(value);
    void *return_value_g_realloc$2;
    return_value_g_realloc$2=g_realloc((void *)parameter, (return_value_strlen$1 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    new = (char *)return_value_g_realloc$2;
    strcpy(new, value);
    return new;
  }
}

// set_pause_context_all
// file set.h line 89
signed int set_pause_context_all(signed int pause_context)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_pause_context_uid$1;
      return_value_set_pause_context_uid$1=set_pause_context_uid(uid, pause_context);
      err = err + return_value_set_pause_context_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_pause_context_self
// file set.h line 71
signed int set_pause_context_self(signed int fd, signed int pause_context)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_pause_context_uid$1;
    return_value_set_pause_context_uid$1=set_pause_context_uid(uid, pause_context);
    return return_value_set_pause_context_uid$1;
  }
}

// set_pause_context_uid
// file set.h line 51
signed int set_pause_context_uid(signed int uid, signed int pause_context)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->pause_context = pause_context;
    return 0;
  }
}

// set_pitch_all
// file set.h line 78
signed int set_pitch_all(signed int pitch)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_pitch_uid$1;
      return_value_set_pitch_uid$1=set_pitch_uid(uid, pitch);
      err = err + return_value_set_pitch_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_pitch_self
// file set.h line 58
signed int set_pitch_self(signed int fd, signed int pitch)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_pitch_uid$1;
    return_value_set_pitch_uid$1=set_pitch_uid(uid, pitch);
    return return_value_set_pitch_uid$1;
  }
}

// set_pitch_uid
// file set.h line 39
signed int set_pitch_uid(signed int uid, signed int pitch)
{
  struct anonymous$11 *settings;
  if(pitch >= 101 || !(pitch >= -100))
    return 1;

  else
  {
    settings=get_client_settings_by_uid(uid);
    if(settings == ((struct anonymous$11 *)NULL))
      return 1;

    else
    {
      settings->msg_settings.pitch = pitch;
      return 0;
    }
  }
}

// set_priority_self
// file set.h line 55
signed int set_priority_self(signed int fd, enum anonymous$9 priority)
{
  signed int uid;
  signed int ret;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    ret=set_priority_uid(uid, priority);
    return ret;
  }
}

// set_priority_uid
// file set.c line 53
signed int set_priority_uid(signed int uid, enum anonymous$9 priority)
{
  struct anonymous$11 *settings;
  if((signed int)priority >= 6 || !((signed int)priority >= SPD_IMPORTANT))
    return 1;

  else
  {
    settings=get_client_settings_by_uid(uid);
    if(settings == ((struct anonymous$11 *)NULL))
      return 1;

    else
    {
      settings->priority = priority;
      return 0;
    }
  }
}

// set_punctuation_mode_all
// file set.h line 86
signed int set_punctuation_mode_all(enum anonymous$2 punctuation_mode)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_punctuation_mode_uid$1;
      return_value_set_punctuation_mode_uid$1=set_punctuation_mode_uid(uid, punctuation_mode);
      err = err + return_value_set_punctuation_mode_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_punctuation_mode_self
// file set.h line 67
signed int set_punctuation_mode_self(signed int fd, enum anonymous$2 punctuation_mode)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_punctuation_mode_uid$1;
    return_value_set_punctuation_mode_uid$1=set_punctuation_mode_uid(uid, punctuation_mode);
    return return_value_set_punctuation_mode_uid$1;
  }
}

// set_punctuation_mode_uid
// file set.h line 47
signed int set_punctuation_mode_uid(signed int uid, enum anonymous$2 punctuation)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->msg_settings.punctuation_mode = punctuation;
    return 0;
  }
}

// set_rate_all
// file set.h line 77
signed int set_rate_all(signed int rate)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_rate_uid$1;
      return_value_set_rate_uid$1=set_rate_uid(uid, rate);
      err = err + return_value_set_rate_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_rate_self
// file set.h line 57
signed int set_rate_self(signed int fd, signed int rate)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_rate_uid$1;
    return_value_set_rate_uid$1=set_rate_uid(uid, rate);
    return return_value_set_rate_uid$1;
  }
}

// set_rate_uid
// file set.h line 38
signed int set_rate_uid(signed int uid, signed int rate)
{
  struct anonymous$11 *settings;
  if(rate >= 101 || !(rate >= -100))
    return 1;

  else
  {
    settings=get_client_settings_by_uid(uid);
    if(settings == ((struct anonymous$11 *)NULL))
      return 1;

    else
    {
      settings->msg_settings.rate = rate;
      return 0;
    }
  }
}

// set_speak_thread_attributes
// file speaking.c line 892
void set_speak_thread_attributes()
{
  signed int ret;
  struct anonymous$30 all_signals;
  ret=sigfillset(&all_signals);
  if(ret == 0)
  {
    ret=pthread_sigmask(0, &all_signals, (struct anonymous$30 *)(void *)0);
    if(!(ret == 0))
      MSG(1, "Can't set signal set, expect problems when terminating!");

  }

  else
    MSG(1, "Can't fill signal set, expect problems when terminating!");
  pthread_setcancelstate(0, (signed int *)(void *)0);
  pthread_setcanceltype(1, (signed int *)(void *)0);
}

// set_spelling_all
// file set.h line 82
signed int set_spelling_all(enum anonymous$1 spelling)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_spelling_uid$1;
      return_value_set_spelling_uid$1=set_spelling_uid(uid, spelling);
      err = err + return_value_set_spelling_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_spelling_self
// file set.h line 62
signed int set_spelling_self(signed int fd, enum anonymous$1 spelling)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_spelling_uid$1;
    return_value_set_spelling_uid$1=set_spelling_uid(uid, spelling);
    return return_value_set_spelling_uid$1;
  }
}

// set_spelling_uid
// file set.h line 43
signed int set_spelling_uid(signed int uid, enum anonymous$1 spelling)
{
  struct anonymous$11 *settings;
  /* assertion (spelling == 0) || (spelling == 1) */
  assert((signed int)spelling == 0 || (signed int)spelling == 1);
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->msg_settings.spelling_mode = spelling;
    return 0;
  }
}

// set_ssml_mode_all
// file set.h line 88
signed int set_ssml_mode_all(enum anonymous$5 ssml_mode)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_ssml_mode_uid$1;
      return_value_set_ssml_mode_uid$1=set_ssml_mode_uid(uid, ssml_mode);
      err = err + return_value_set_ssml_mode_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_ssml_mode_self
// file set.h line 69
signed int set_ssml_mode_self(signed int fd, enum anonymous$5 ssml_mode)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_ssml_mode_uid$1;
    return_value_set_ssml_mode_uid$1=set_ssml_mode_uid(uid, ssml_mode);
    return return_value_set_ssml_mode_uid$1;
  }
}

// set_ssml_mode_uid
// file set.h line 50
signed int set_ssml_mode_uid(signed int uid, enum anonymous$5 ssml_mode)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->ssml_mode = ssml_mode;
    return 0;
  }
}

// set_synthesis_voice_all
// file set.h line 85
signed int set_synthesis_voice_all(char *synthesis_voice)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_synthesis_voice_uid$1;
      return_value_set_synthesis_voice_uid$1=set_synthesis_voice_uid(uid, synthesis_voice);
      err = err + return_value_set_synthesis_voice_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_synthesis_voice_self
// file set.h line 66
signed int set_synthesis_voice_self(signed int fd, char *synthesis_voice)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_synthesis_voice_uid$1;
    return_value_set_synthesis_voice_uid$1=set_synthesis_voice_uid(uid, synthesis_voice);
    return return_value_set_synthesis_voice_uid$1;
  }
}

// set_synthesis_voice_uid
// file set.h line 46
signed int set_synthesis_voice_uid(signed int uid, char *synthesis_voice)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->msg_settings.voice.name=set_param_str(settings->msg_settings.voice.name, synthesis_voice);
    settings->msg_settings.voice_type = (enum anonymous$27)-1;
    return 0;
  }
}

// set_voice_all
// file set.h line 84
signed int set_voice_all(char *voice)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_voice_uid$1;
      return_value_set_voice_uid$1=set_voice_uid(uid, voice);
      err = err + return_value_set_voice_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_voice_self
// file set.h line 65
signed int set_voice_self(signed int fd, char *voice)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_voice_uid$1;
    return_value_set_voice_uid$1=set_voice_uid(uid, voice);
    return return_value_set_voice_uid$1;
  }
}

// set_voice_uid
// file set.h line 45
signed int set_voice_uid(signed int uid, char *voice)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    signed int return_value_strcmp$8;
    return_value_strcmp$8=strcmp(voice, "male1");
    if(return_value_strcmp$8 == 0)
      settings->msg_settings.voice_type = (enum anonymous$27)SPD_MALE1;

    else
    {
      return_value_strcmp$7=strcmp(voice, "male2");
      if(return_value_strcmp$7 == 0)
        settings->msg_settings.voice_type = (enum anonymous$27)SPD_MALE2;

      else
      {
        return_value_strcmp$6=strcmp(voice, "male3");
        if(return_value_strcmp$6 == 0)
          settings->msg_settings.voice_type = (enum anonymous$27)SPD_MALE3;

        else
        {
          return_value_strcmp$5=strcmp(voice, "female1");
          if(return_value_strcmp$5 == 0)
            settings->msg_settings.voice_type = (enum anonymous$27)SPD_FEMALE1;

          else
          {
            return_value_strcmp$4=strcmp(voice, "female2");
            if(return_value_strcmp$4 == 0)
              settings->msg_settings.voice_type = (enum anonymous$27)SPD_FEMALE2;

            else
            {
              return_value_strcmp$3=strcmp(voice, "female3");
              if(return_value_strcmp$3 == 0)
                settings->msg_settings.voice_type = (enum anonymous$27)SPD_FEMALE3;

              else
              {
                return_value_strcmp$2=strcmp(voice, "child_male");
                if(return_value_strcmp$2 == 0)
                  settings->msg_settings.voice_type = (enum anonymous$27)SPD_CHILD_MALE;

                else
                {
                  return_value_strcmp$1=strcmp(voice, "child_female");
                  if(return_value_strcmp$1 == 0)
                    settings->msg_settings.voice_type = (enum anonymous$27)SPD_CHILD_FEMALE;

                  else
                    return 1;
                }
              }
            }
          }
        }
      }
    }
    if(!(settings->msg_settings.voice.name == ((char *)NULL)))
    {
      g_free((void *)settings->msg_settings.voice.name);
      settings->msg_settings.voice.name = (char *)(void *)0;
    }

    return 0;
  }
}

// set_volume_all
// file set.h line 79
signed int set_volume_all(signed int volume)
{
  signed int i;
  signed int uid;
  signed int err = 0;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_set_volume_uid$1;
      return_value_set_volume_uid$1=set_volume_uid(uid, volume);
      err = err + return_value_set_volume_uid$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// set_volume_self
// file set.h line 59
signed int set_volume_self(signed int fd, signed int volume)
{
  signed int uid;
  uid=get_client_uid_by_fd(fd);
  if(uid == 0)
    return 1;

  else
  {
    signed int return_value_set_volume_uid$1;
    return_value_set_volume_uid$1=set_volume_uid(uid, volume);
    return return_value_set_volume_uid$1;
  }
}

// set_volume_uid
// file set.h line 40
signed int set_volume_uid(signed int uid, signed int volume)
{
  struct anonymous$11 *settings;
  if(volume >= 101 || !(volume >= -100))
    return 1;

  else
  {
    settings=get_client_settings_by_uid(uid);
    if(settings == ((struct anonymous$11 *)NULL))
      return 1;

    else
    {
      settings->msg_settings.volume = volume;
      return 0;
    }
  }
}

// socket_send_msg
// file speaking.c line 603
signed int socket_send_msg(signed int fd, char *msg)
{
  signed int ret;
  /* assertion msg != ((void *)0) */
  assert(msg != (char *)(void *)0);
  pthread_mutex_lock(&socket_com_mutex);
  MSG2(5, "protocol", "%d:REPLY:|%s|", fd, msg);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(msg);
  signed long int return_value_write$2;
  return_value_write$2=write(fd, (const void *)msg, return_value_strlen$1);
  ret = (signed int)return_value_write$2;
  pthread_mutex_unlock(&socket_com_mutex);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    MSG(1, "write() error: %s", return_value_strerror$4);
    return -1;
  }

  return 0;
}

// sortbyuid
// file speaking.c line 1126
signed int sortbyuid(const void *a, const void *b)
{
  const struct anonymous$7 *msg1 = (const struct anonymous$7 *)a;
  const struct anonymous$7 *msg2 = (const struct anonymous$7 *)b;
  if(msg1 == ((const struct anonymous$7 *)NULL) && !(msg2 == ((const struct anonymous$7 *)NULL)))
    return -1;

  else
    if(msg2 == ((const struct anonymous$7 *)NULL) && !(msg1 == ((const struct anonymous$7 *)NULL)))
      return +1;

    else
      if(msg1 == ((const struct anonymous$7 *)NULL) && msg2 == ((const struct anonymous$7 *)NULL))
        return 0;

      else
        return (signed int)(msg1->id - msg2->id);
}

// spd_fdset_copy
// file alloc.c line 8
struct anonymous$11 spd_fdset_copy(struct anonymous$11 old)
{
  struct anonymous$11 new = old;
  new.msg_settings.voice.language=g_strdup(old.msg_settings.voice.language);
  new.msg_settings.voice.name=g_strdup(old.msg_settings.voice.name);
  new.client_name=g_strdup(old.client_name);
  new.output_module=g_strdup(old.output_module);
  new.index_mark=g_strdup(old.index_mark);
  new.audio_output_method=g_strdup(old.audio_output_method);
  new.audio_oss_device=g_strdup(old.audio_oss_device);
  new.audio_alsa_device=g_strdup(old.audio_alsa_device);
  new.audio_nas_server=g_strdup(old.audio_nas_server);
  new.audio_pulse_server=g_strdup(old.audio_pulse_server);
  return new;
}

// spd_get_path
// file speechd.c line 102
char * spd_get_path(char *filename, char *startdir)
{
  char *ret;
  if(filename == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!((signed int)*filename == 47))
    {
      if(startdir == ((char *)NULL))
        ret=g_strdup(filename);

      else
        ret=g_strdup_printf("%s/%s", startdir, filename);
    }

    else
      ret=g_strdup(filename);
    return ret;
  }
}

// spd_getline
// file ../../include/spd_utils.h line 29
signed long int spd_getline(char **lineptr, unsigned long int *n, struct _IO_FILE *f)
{
  char ch;
  signed long int buf_pos = (signed long int)0;
  signed long int needed = (signed long int)2;
  unsigned long int new_length = (unsigned long int)0;
  char *temp;
  if(lineptr == ((char **)NULL) || f == ((struct _IO_FILE *)NULL) || n == ((unsigned long int *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (signed long int)-1;
  }

  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  signed int *return_value___errno_location$2;
  if(!(*return_value___errno_location$3 == 0))
  {
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
  }

  _Bool tmp_if_expr$5;
  if(*lineptr == ((char *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = *n == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    *n = (unsigned long int)120;
    void *return_value_g_malloc$4;
    return_value_g_malloc$4=g_malloc(*n * sizeof(char) /*1ul*/ );
    *lineptr = (char *)return_value_g_malloc$4;
    if(*lineptr == ((char *)NULL))
    {
      *n = (unsigned long int)0;
      return (signed long int)-1;
    }

  }

  signed int return_value__IO_getc$6;
  signed long int tmp_post$10;
  do
  {
    return_value__IO_getc$6=_IO_getc(f);
    ch = (char)return_value__IO_getc$6;
    if((signed int)ch == -1)
      break;

    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    if(!(*return_value___errno_location$7 == 0))
      return (signed long int)-1;

    if(!(*n >= (unsigned long int)needed))
    {
      new_length = *n * (unsigned long int)2;
      if(*n >= new_length)
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        *return_value___errno_location$8 = 12;
        ungetc((signed int)ch, f);
        return (signed long int)-1;
      }

      void *return_value_g_realloc$9;
      return_value_g_realloc$9=g_realloc((void *)*lineptr, new_length * sizeof(char) /*1ul*/ );
      temp = (char *)return_value_g_realloc$9;
      if(temp == ((char *)NULL))
      {
        ungetc((signed int)ch, f);
        return (signed long int)-1;
      }

      *n = new_length;
      *lineptr = temp;
    }

    tmp_post$10 = buf_pos;
    buf_pos = buf_pos + 1l;
    (*lineptr)[tmp_post$10] = ch;
    if((signed int)ch == 10)
      break;

    if(needed == 0x7fffffffffffffffL)
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      *return_value___errno_location$11 = 12;
      return (signed long int)-1;
    }

    needed = needed + 1l;
  }
  while((_Bool)1);
  (*lineptr)[buf_pos] = (char)0;
  if(buf_pos == 0l)
    buf_pos = (signed long int)-1;

  return buf_pos;
}

// spd_message_copy
// file alloc.h line 8
struct anonymous$7 * spd_message_copy(struct anonymous$7 *old)
{
  struct anonymous$7 *new = (struct anonymous$7 *)(void *)0;
  if(old == ((struct anonymous$7 *)NULL))
    return (struct anonymous$7 *)(void *)0;

  else
  {
    void *return_value_g_malloc$1;
    return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$7) /*224ul*/ );
    new = (struct anonymous$7 *)return_value_g_malloc$1;
    *new = *old;
    void *return_value_g_malloc$2;
    return_value_g_malloc$2=g_malloc((unsigned long int)(old->bytes + 1) * sizeof(char) /*1ul*/ );
    new->buf = (char *)return_value_g_malloc$2;
    memcpy((void *)new->buf, (const void *)old->buf, (unsigned long int)old->bytes);
    new->buf[(signed long int)new->bytes] = (char)0;
    new->settings=spd_fdset_copy(old->settings);
    return new;
  }
}

// spd_str_compare
// file set.c line 35
signed int spd_str_compare(const void *a, const void *b)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp((char *)a, (char *)b);
  return return_value_strcmp$1;
}

// spd_utf8_read_char
// file parse.c line 1138
signed int spd_utf8_read_char(char *pointer, char *character)
{
  signed int bytes;
  unsigned int u_char;
  u_char=g_utf8_get_char(pointer);
  bytes=g_unichar_to_utf8(u_char, character);
  character[(signed long int)bytes] = (char)0;
  return bytes;
}

// speak
// file speaking.h line 45
void * speak(void *data)
{
  struct anonymous$7 *message = (struct anonymous$7 *)(void *)0;
  signed int ret;
  struct pollfd *poll_fds;
  struct pollfd main_pfd;
  struct pollfd helper_pfd;
  signed int revents;
  set_speak_thread_attributes();
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc((unsigned long int)2 * sizeof(struct pollfd) /*8ul*/ );
  poll_fds = (struct pollfd *)return_value_g_malloc$1;
  main_pfd.fd = speaking_pipe[(signed long int)0];
  main_pfd.events = (signed short int)0x001;
  main_pfd.revents = (signed short int)0;
  helper_pfd.fd = -1;
  helper_pfd.events = (signed short int)0x001;
  helper_pfd.revents = (signed short int)0;
  poll_fds[(signed long int)0] = main_pfd;
  poll_fds[(signed long int)1] = helper_pfd;
  poll_count = 1;
  signed long int tmp_statement_expression$2;
  signed long int return_value_read$5;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$11;
  unsigned int return_value_g_list_length$10;
  unsigned int return_value_g_list_length$8;
  while((_Bool)1)
  {
    ret=poll(poll_fds, (unsigned long int)poll_count, -1);
    MSG(5, "Poll in speak() returned socket activity, main_pfd revents=%d, poll_pfd revents=%d", (poll_fds + (signed long int)0)->revents, (poll_fds + (signed long int)1)->revents);
    revents = (signed int)(poll_fds + (signed long int)0)->revents;
    if(!(revents == 0))
    {
      if(!((0x001 & revents) == 0))
      {
        char buf[1l];
        MSG(5, "wait_for_poll: activity in Speech Dispatcher");
        signed long int rd_bytes;
        signed long int __result;
        do
        {
          return_value_read$5=read((poll_fds + (signed long int)0)->fd, (void *)buf, (unsigned long int)1);
          __result = (signed long int)return_value_read$5;
          if(__result == -1l)
          {
            return_value___errno_location$3=__errno_location();
            tmp_if_expr$4 = *return_value___errno_location$3 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4 = (_Bool)0;
        }
        while(tmp_if_expr$4);
        tmp_statement_expression$2 = __result;
        rd_bytes = tmp_statement_expression$2;
        if(!(rd_bytes == 1l))
        {
          fatal_error();
          MSG(-1, "Fatal error [%s:%d]:read from polled fd: could not read 1 byte", (const void *)"speaking.c", 96);
          exit(1);
        }

      }

    }

    if(poll_count >= 2)
    {
      revents = (signed int)(poll_fds + (signed long int)1)->revents;
      if(!(revents == 0))
      {
        if(!((0x001 & revents) == 0) || !((0x002 & revents) == 0))
        {
          MSG(5, "wait_for_poll: activity on output_module");
          is_sb_speaking();
        }

        if(!((0x010 & revents) == 0))
          poll_count = 1;

      }

    }

    if(!(pause_requested == 0))
    {
      MSG(4, "Trying to pause...");
      if(pause_requested == 1)
        speaking_pause_all(pause_requested_fd);

      if(pause_requested == 2)
        speaking_pause(pause_requested_fd, pause_requested_uid);

      MSG(4, "Paused...");
      pause_requested = 0;
    }

    else
      if(!(SPEAKING == 0))
        MSG(5, "Continuing because already speaking in speak()");

      else
      {
        if(!(resume_requested == 0))
        {
          struct _GList *gl;
          MSG(5, "Resume requested");
          unsigned int return_value_g_list_length$7;
          return_value_g_list_length$7=g_list_length(MessagePausedList);
          if(!(return_value_g_list_length$7 == 0u))
            while((_Bool)1)
            {
              pthread_mutex_lock(&element_free_mutex);
              gl=g_list_find_custom(MessagePausedList, (void *)0, message_nto_speak);
              MSG(5, "Message insterted back to the queues!");
              MessagePausedList=g_list_remove_link(MessagePausedList, gl);
              pthread_mutex_unlock(&element_free_mutex);
              if(!(gl == ((struct _GList *)NULL)))
                tmp_if_expr$6 = gl->data != (void *)0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$6 = (_Bool)0;
              if(tmp_if_expr$6)
              {
                MSG(5, "Reloading message");
                reload_message((struct anonymous$7 *)gl->data);
                if(current_message == (struct anonymous$7 *)gl->data)
                  current_message = (struct anonymous$7 *)(void *)0;

              }

              else
                break;
            }

          MSG(5, "End of resume processing");
          resume_requested = 0;
        }

        MSG(5, "Locking element_free_mutex in speak()");
        pthread_mutex_lock(&element_free_mutex);
        check_locked(&element_free_mutex);
        unsigned int return_value_g_list_length$9;
        return_value_g_list_length$9=g_list_length(last_p5_block);
        if(!(return_value_g_list_length$9 == 0u))
        {
          return_value_g_list_length$10=g_list_length(MessageQueue->p5);
          tmp_if_expr$11 = return_value_g_list_length$10 == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
        {
          do
          {
            return_value_g_list_length$8=g_list_length(last_p5_block);
            if(return_value_g_list_length$8 == 0u)
              break;

            struct _GList *item;
            item=g_list_first(last_p5_block);
            message = (struct anonymous$7 *)item->data;
            check_locked(&element_free_mutex);
            MessageQueue->p2=g_list_insert_sorted(MessageQueue->p2, (void *)message, sortbyuid);
            last_p5_block=g_list_remove_link(last_p5_block, item);
            g_list_free_1(item);
          }
          while((_Bool)1);
          /* assertion message != ((void *)0) */
          assert(message != (struct anonymous$7 *)(void *)0);
          highest_priority = (enum anonymous$9)SPD_MESSAGE;
          stop_priority_older_than((enum anonymous$9)SPD_TEXT, message->id);
          stop_priority((enum anonymous$9)SPD_NOTIFICATION);
          stop_priority((enum anonymous$9)SPD_PROGRESS);
          check_locked(&element_free_mutex);
          pthread_mutex_unlock(&element_free_mutex);
          speaking_semaphore_post();
          continue;
        }

        else
        {
          message=get_message_from_queues();
          if(message == ((struct anonymous$7 *)NULL))
          {
            pthread_mutex_unlock(&element_free_mutex);
            MSG(5, "No message in the queue");
            continue;
          }

        }
        signed int return_value_message_nto_speak$12;
        return_value_message_nto_speak$12=message_nto_speak((const void *)message, (void *)0);
        if(!(return_value_message_nto_speak$12 == 0))
        {
          MSG(4, "Inserting message to paused list...");
          MessagePausedList=g_list_append(MessagePausedList, (void *)message);
          pthread_mutex_unlock(&element_free_mutex);
        }

        else
        {
          if((signed int)message->settings.type == SPD_MSGTYPE_TEXT)
            insert_index_marks(message, message->settings.ssml_mode);

          ret=output_speak(message);
          MSG(4, "Message sent to output module");
          if(ret == -1)
          {
            MSG(2, "Error: Output module failed");
            struct anonymous$10 *return_value_get_output_module$13;
            return_value_get_output_module$13=get_output_module(message);
            output_check_module(return_value_get_output_module$13);
            pthread_mutex_unlock(&element_free_mutex);
            continue;
          }

          if(!(ret == 0))
          {
            MSG(2, "ERROR: Can't say message. Module reported error in speaking: %d", ret);
            pthread_mutex_unlock(&element_free_mutex);
          }

          else
          {
            SPEAKING = 1;
            if(!(speaking_module == ((struct anonymous$10 *)NULL)))
            {
              poll_count = 2;
              helper_pfd.fd = speaking_module->pipe_out[(signed long int)0];
              poll_fds[(signed long int)1] = helper_pfd;
            }

            speaking_uid = (signed int)message->settings.uid;
            if(!(current_message == ((struct anonymous$7 *)NULL)))
            {
              if(current_message->settings.paused_while_speaking == 0)
              {
                struct anonymous$11 *return_value_get_client_settings_by_uid$15;
                return_value_get_client_settings_by_uid$15=get_client_settings_by_uid((signed int)current_message->settings.uid);
                if(return_value_get_client_settings_by_uid$15->active == 0)
                {
                  signed int return_value_client_has_messages$14;
                  return_value_client_has_messages$14=client_has_messages((signed int)current_message->settings.uid);
                  if(return_value_client_has_messages$14 == 0)
                  {
                    if(!(current_message->settings.uid == message->settings.uid))
                    {
                      MSG(4, "Removing client settings for uid %d", current_message->settings.uid);
                      remove_client_settings_by_uid((signed int)current_message->settings.uid);
                    }

                  }

                }

                mem_free_message(current_message);
              }

            }

            current_message = message;
            if(!(last_p5_block == ((struct _GList *)NULL)))
            {
              struct _GList *elem;
              struct anonymous$7 *p5_message;
              elem=g_list_last(last_p5_block);
              if(!(elem == ((struct _GList *)NULL)))
              {
                p5_message = (struct anonymous$7 *)elem->data;
                if(p5_message->settings.reparted == message->settings.reparted)
                {
                  g_list_foreach(last_p5_block, (void (*)(void *, void *))mem_free_message, (void *)0);
                  g_list_free(last_p5_block);
                  last_p5_block = (struct _GList *)(void *)0;
                }

              }

            }

            pthread_mutex_unlock(&element_free_mutex);
          }
        }
      }
  }
}

// speaking_cancel
// file speaking.h line 54
void speaking_cancel(signed int uid)
{
  pthread_mutex_lock(&element_free_mutex);
  speaking_stop(uid);
  stop_from_uid(uid);
  pthread_mutex_unlock(&element_free_mutex);
}

// speaking_cancel_all
// file speaking.h line 55
void speaking_cancel_all()
{
  output_stop();
  pthread_mutex_lock(&element_free_mutex);
  stop_priority((enum anonymous$9)SPD_IMPORTANT);
  stop_priority((enum anonymous$9)SPD_MESSAGE);
  stop_priority((enum anonymous$9)SPD_TEXT);
  stop_priority((enum anonymous$9)SPD_NOTIFICATION);
  stop_priority((enum anonymous$9)SPD_PROGRESS);
  pthread_mutex_unlock(&element_free_mutex);
}

// speaking_get_queue
// file speaking.c line 1074
struct _GList * speaking_get_queue(enum anonymous$9 priority)
{
  struct _GList *queue = (struct _GList *)(void *)0;
  /* assertion priority >= SPD_IMPORTANT && priority <= SPD_PROGRESS */
  assert((signed int)priority >= SPD_IMPORTANT && (signed int)priority <= SPD_PROGRESS);
  check_locked(&element_free_mutex);
  switch((signed int)priority)
  {
    case SPD_IMPORTANT:
    {
      queue = MessageQueue->p1;
      break;
    }
    case SPD_MESSAGE:
    {
      queue = MessageQueue->p2;
      break;
    }
    case SPD_TEXT:
    {
      queue = MessageQueue->p3;
      break;
    }
    case SPD_NOTIFICATION:
    {
      queue = MessageQueue->p4;
      break;
    }
    case SPD_PROGRESS:
      queue = MessageQueue->p5;
  }
  return queue;
}

// speaking_pause
// file speaking.c line 522
signed int speaking_pause(signed int fd, signed int uid)
{
  struct anonymous$11 *settings;
  signed int ret;
  MSG(4, "Pause");
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
  {
    MSG(4, "ERROR: Can't get settings of active client in speaking_pause()!");
    return 1;
  }

  else
  {
    settings->paused = 1;
    if(!(speaking_uid == uid))
    {
      MSG(5, "given uid %d not speaking_uid", speaking_uid, uid);
      return 0;
    }

    else
    {
      if(!(SPEAKING == 0))
      {
        if(current_message == ((struct anonymous$7 *)NULL))
        {
          MSG(5, "current_message is null");
          return 0;
        }

        unsigned long int return_value_output_pause$1;
        return_value_output_pause$1=output_pause();
        ret = (signed int)return_value_output_pause$1;
        if(!(ret >= 0))
        {
          MSG(5, "output_pause returned %d", ret);
          return 0;
        }

        MSG(5, "Including current message into the message paused list");
        current_message->settings.paused = 2;
        current_message->settings.paused_while_speaking = 1;
        struct _GList *return_value_g_list_find$2;
        return_value_g_list_find$2=g_list_find(MessagePausedList, (const void *)current_message);
        if(return_value_g_list_find$2 == ((struct _GList *)NULL))
          MessagePausedList=g_list_append(MessagePausedList, (void *)current_message);

      }

      return 0;
    }
  }
}

// speaking_pause_all
// file speaking.c line 503
signed int speaking_pause_all(signed int fd)
{
  signed int err = 0;
  signed int i;
  signed int uid;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_speaking_pause$1;
      return_value_speaking_pause$1=speaking_pause(i, uid);
      err = err + return_value_speaking_pause$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// speaking_resume
// file speaking.h line 60
signed int speaking_resume(signed int uid)
{
  struct anonymous$11 *settings;
  settings=get_client_settings_by_uid(uid);
  if(settings == ((struct anonymous$11 *)NULL))
    return 1;

  else
  {
    settings->paused = 0;
    resume_requested = 1;
    speaking_semaphore_post();
    return 0;
  }
}

// speaking_resume_all
// file speaking.h line 61
signed int speaking_resume_all()
{
  signed int err = 0;
  signed int i;
  signed int uid;
  i = 1;
  for( ; SpeechdStatus.max_fd >= i; i = i + 1)
  {
    uid=get_client_uid_by_fd(i);
    if(!(uid == 0))
    {
      signed int return_value_speaking_resume$1;
      return_value_speaking_resume$1=speaking_resume(uid);
      err = err + return_value_speaking_resume$1;
    }

  }
  if(err >= 1)
    return 1;

  else
    return 0;
}

// speaking_semaphore_post
// file sem_functions.h line 24
void speaking_semaphore_post(void)
{
  char buf[1l];
  buf[(signed long int)0] = (char)42;
  signed long int wr_bytes;
  signed long int tmp_statement_expression$1;
  signed long int __result;
  signed long int return_value_write$4;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    return_value_write$4=write(speaking_pipe[(signed long int)1], (const void *)buf, (unsigned long int)1);
    __result = (signed long int)return_value_write$4;
    if(__result == -1l)
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  tmp_statement_expression$1 = __result;
  wr_bytes = tmp_statement_expression$1;
  if(!(wr_bytes == 1l))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:write to polled fd: could not write 1 byte", (const void *)"sem_functions.c", 39);
    exit(1);
  }

}

// speaking_set_queue
// file speaking.c line 1102
void speaking_set_queue(enum anonymous$9 priority, struct _GList *queue)
{
  /* assertion priority >= SPD_IMPORTANT && priority <= SPD_PROGRESS */
  assert((signed int)priority >= SPD_IMPORTANT && (signed int)priority <= SPD_PROGRESS);
  check_locked(&element_free_mutex);
  switch((signed int)priority)
  {
    case SPD_IMPORTANT:
    {
      MessageQueue->p1 = queue;
      break;
    }
    case SPD_MESSAGE:
    {
      MessageQueue->p2 = queue;
      break;
    }
    case SPD_TEXT:
    {
      MessageQueue->p3 = queue;
      break;
    }
    case SPD_NOTIFICATION:
    {
      MessageQueue->p4 = queue;
      break;
    }
    case SPD_PROGRESS:
      MessageQueue->p5 = queue;
  }
}

// speaking_stop
// file speaking.h line 51
void speaking_stop(signed int uid)
{
  struct anonymous$7 *msg;
  struct _GList *gl;
  struct _GList *queue;
  signed int gid = -1;
  signed int return_value_get_speaking_client_uid$3;
  return_value_get_speaking_client_uid$3=get_speaking_client_uid();
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(return_value_get_speaking_client_uid$3 == uid)
  {
    output_stop();
    queue=speaking_get_queue(highest_priority);
    if(queue == ((struct _GList *)NULL))
      goto __CPROVER_DUMP_L15;

    gl=g_list_last(queue);
    if(gl == ((struct _GList *)NULL))
      goto __CPROVER_DUMP_L15;

    if(gl->data == NULL)
      goto __CPROVER_DUMP_L15;

    msg = (struct anonymous$7 *)gl->data;
    if(!(msg->settings.reparted == 0))
      tmp_if_expr$1 = msg->settings.uid == (unsigned int)uid ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      gid = msg->settings.reparted;

    else
      goto __CPROVER_DUMP_L15;
    while((_Bool)1)
    {
      gl=g_list_last(queue);
      if(gl == ((struct _GList *)NULL))
      {
        speaking_set_queue(highest_priority, queue);
        goto __CPROVER_DUMP_L15;
      }

      if(gl->data == NULL)
        goto __CPROVER_DUMP_L15;

      msg = (struct anonymous$7 *)gl->data;
      if(msg->settings.reparted == gid)
        tmp_if_expr$2 = msg->settings.uid == (unsigned int)uid ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        queue=g_list_remove_link(queue, gl);
        /* assertion gl->data != ((void *)0) */
        assert(gl->data != (void *)0);
        mem_free_message((struct anonymous$7 *)gl->data);
      }

      else
      {
        speaking_set_queue(highest_priority, queue);
        goto __CPROVER_DUMP_L15;
      }
    }
  }


__CPROVER_DUMP_L15:
  ;
}

// speaking_stop_all
// file speaking.h line 52
void speaking_stop_all()
{
  struct anonymous$7 *msg;
  struct _GList *gl;
  struct _GList *queue;
  signed int gid = -1;
  output_stop();
  queue=speaking_get_queue(highest_priority);
  if(!(queue == ((struct _GList *)NULL)))
  {
    gl=g_list_last(queue);
    if(!(gl == ((struct _GList *)NULL)))
    {
      /* assertion gl->data != ((void *)0) */
      assert(gl->data != (void *)0);
      msg = (struct anonymous$7 *)gl->data;
      if(!(msg->settings.reparted == 0))
        gid = msg->settings.reparted;

      else
        goto __CPROVER_DUMP_L10;
      while((_Bool)1)
      {
        gl=g_list_last(queue);
        if(gl == ((struct _GList *)NULL))
        {
          speaking_set_queue(highest_priority, queue);
          goto __CPROVER_DUMP_L10;
        }

        msg = (struct anonymous$7 *)gl->data;
        if(msg->settings.reparted == 1)
        {
          queue=g_list_remove_link(queue, gl);
          /* assertion gl->data != ((void *)0) */
          assert(gl->data != (void *)0);
          mem_free_message((struct anonymous$7 *)gl->data);
        }

        else
        {
          speaking_set_queue(highest_priority, queue);
          goto __CPROVER_DUMP_L10;
        }
      }
    }

  }


__CPROVER_DUMP_L10:
  ;
}

// speechd_client_terminate
// file speechd.c line 425
signed int speechd_client_terminate(void *key, void *value, void *user)
{
  struct anonymous$11 *set = (struct anonymous$11 *)value;
  if(set == ((struct anonymous$11 *)NULL))
  {
    MSG(2, "Error: Empty connection, internal error");
    return (signed int)!(0 != 0);
  }

  else
  {
    if(set->fd >= 1)
    {
      MSG(4, "Closing connection on fd %d\n", set->fd);
      speechd_connection_destroy(set->fd);
    }

    mem_free_fdset(set);
    g_free((void *)set);
    return (signed int)!(0 != 0);
  }
}

// speechd_connection_destroy
// file speechd.c line 385
signed int speechd_connection_destroy(signed int fd)
{
  struct anonymous$11 *fdset_element;
  MSG(4, "Removing client on fd %d", fd);
  MSG(4, "Tagging client as inactive in settings");
  fdset_element=get_client_settings_by_fd(fd);
  if(!(fdset_element == ((struct anonymous$11 *)NULL)))
  {
    fdset_element->fd = -1;
    fdset_element->active = 0;
  }

  MSG(4, "Removing client from the fd->uid table.");
  g_hash_table_remove(fd_uid, (const void *)&fd);
  speechd_socket_unregister(fd);
  MSG(4, "Closing clients file descriptor %d", fd);
  signed int return_value_close$1;
  return_value_close$1=close(fd);
  (&readfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
  if(fd == SpeechdStatus.max_fd)
    SpeechdStatus.max_fd = SpeechdStatus.max_fd - 1;

  MSG(4, "Connection closed");
  return 0;
}

// speechd_connection_new
// file speechd.c line 333
signed int speechd_connection_new(signed int server_socket)
{
  struct anonymous$11 *new_fd_set;
  struct sockaddr_in client_address;
  unsigned int client_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int client_socket;
  signed int *p_client_socket;
  signed int *p_client_uid;
  signed int *p_client_uid2;
  client_socket=accept(server_socket, (struct sockaddr *)&client_address, &client_len);
  if(client_socket == -1)
  {
    MSG(2, "Error: Can't handle connection request of a new client");
    return -1;
  }

  else
  {
    (&readfds)->fds_bits[(signed long int)(client_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(client_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << client_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(SpeechdStatus.max_fd >= client_socket))
      SpeechdStatus.max_fd = client_socket;

    MSG(4, "Adding client on fd %d", client_socket);
    speechd_socket_register(client_socket);
    struct anonymous$11 *return_value_default_fd_set$1;
    return_value_default_fd_set$1=default_fd_set();
    new_fd_set = (struct anonymous$11 *)return_value_default_fd_set$1;
    if(new_fd_set == ((struct anonymous$11 *)NULL))
    {
      MSG(2, "Error: Failed to create a record in fd_settings for the new client");
      if(SpeechdStatus.max_fd == client_socket)
        SpeechdStatus.max_fd = SpeechdStatus.max_fd - 1;

      (&readfds)->fds_bits[(signed long int)(client_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(client_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << client_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      return -1;
    }

    else
    {
      new_fd_set->fd = client_socket;
      SpeechdStatus.max_uid = SpeechdStatus.max_uid + 1;
      new_fd_set->uid = (unsigned int)SpeechdStatus.max_uid;
      void *return_value_g_malloc$2;
      return_value_g_malloc$2=g_malloc(sizeof(signed int) /*4ul*/ );
      p_client_socket = (signed int *)return_value_g_malloc$2;
      void *return_value_g_malloc$3;
      return_value_g_malloc$3=g_malloc(sizeof(signed int) /*4ul*/ );
      p_client_uid = (signed int *)return_value_g_malloc$3;
      void *return_value_g_malloc$4;
      return_value_g_malloc$4=g_malloc(sizeof(signed int) /*4ul*/ );
      p_client_uid2 = (signed int *)return_value_g_malloc$4;
      *p_client_socket = client_socket;
      *p_client_uid = SpeechdStatus.max_uid;
      *p_client_uid2 = SpeechdStatus.max_uid;
      g_hash_table_insert(fd_settings, (void *)p_client_uid, (void *)new_fd_set);
      g_hash_table_insert(fd_uid, (void *)p_client_socket, (void *)p_client_uid2);
      MSG(4, "Data structures for client on fd %d created", client_socket);
      return 0;
    }
  }
}

// speechd_init
// file speechd.c line 550
void speechd_init(void)
{
  signed int ret;
  SpeechdStatus.max_uid = 0;
  SpeechdStatus.max_gid = 0;
  signed int return_value_pipe$3;
  return_value_pipe$3=pipe(speaking_pipe);
  if(!(return_value_pipe$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    MSG(1, "Speaking pipe creation failed (%s)", return_value_strerror$2);
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Can't create pipe", (const void *)"speechd.c", 560);
    exit(1);
  }

  void *return_value_g_malloc0$4;
  return_value_g_malloc0$4=g_malloc0(sizeof(struct anonymous$29) /*40ul*/ );
  MessageQueue = (struct anonymous$29 *)return_value_g_malloc0$4;
  if(MessageQueue == ((struct anonymous$29 *)NULL))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Couldn't alocate memmory for MessageQueue.", (const void *)"speechd.c", 566);
    exit(1);
  }

  MessagePausedList = (struct _GList *)(void *)0;
  fd_settings=g_hash_table_new_full(g_int_hash, g_int_equal, (void (*)(void *))g_free, (void (*)(void *))(void *)0);
  /* assertion fd_settings != ((void *)0) */
  assert(fd_settings != (struct _GHashTable *)(void *)0);
  fd_uid=g_hash_table_new_full(g_int_hash, g_int_equal, (void (*)(void *))g_free, (void (*)(void *))g_free);
  /* assertion fd_uid != ((void *)0) */
  assert(fd_uid != (struct _GHashTable *)(void *)0);
  language_default_modules=g_hash_table_new(g_str_hash, g_str_equal);
  /* assertion language_default_modules != ((void *)0) */
  assert(language_default_modules != (struct _GHashTable *)(void *)0);
  speechd_sockets_status_init();
  pause_requested = 0;
  resume_requested = 0;
  signed int return_value_g_module_supported$5;
  return_value_g_module_supported$5=g_module_supported();
  if(return_value_g_module_supported$5 == 0)
  {
    MSG(0, "Error [%s:%d]:Loadable modules not supported by current platform.\n", (const void *)"speechd.c", 591);
    exit(1);
  }

  GlobalFDSet.min_delay_progress = (unsigned int)2000;
  client_specific_settings = (struct _GList *)(void *)0;
  ret=pthread_mutex_init(&element_free_mutex, (const union anonymous$13 *)(void *)0);
  if(!(ret == 0))
  {
    MSG(0, "Error [%s:%d]:Mutex initialization failed", (const void *)"speechd.c", 605);
    exit(1);
  }

  ret=pthread_mutex_init(&output_layer_mutex, (const union anonymous$13 *)(void *)0);
  if(!(ret == 0))
  {
    MSG(0, "Error [%s:%d]:Mutex initialization failed", (const void *)"speechd.c", 609);
    exit(1);
  }

  ret=pthread_mutex_init(&socket_com_mutex, (const union anonymous$13 *)(void *)0);
  if(!(ret == 0))
  {
    MSG(0, "Error [%s:%d]:Mutex initialization failed", (const void *)"speechd.c", 613);
    exit(1);
  }

  if(SpeechdOptions.log_dir == ((char *)NULL))
  {
    SpeechdOptions.log_dir=g_strdup_printf("%s/log/", SpeechdOptions.runtime_speechd_dir);
    mkdir(SpeechdOptions.log_dir, (unsigned int)(0400 | 0200 | 0100));
    if(SpeechdOptions.debug_destination == ((char *)NULL))
    {
      SpeechdOptions.debug_destination=g_strdup_printf("%s/log/debug", SpeechdOptions.runtime_speechd_dir);
      mkdir(SpeechdOptions.debug_destination, (unsigned int)(0400 | 0200 | 0100));
    }

  }

  MSG(4, "Reading Speech Dispatcher configuration from %s", SpeechdOptions.conf_file);
  speechd_load_configuration(0);
  logging_init();
  unsigned int return_value_g_list_length$8;
  return_value_g_list_length$8=g_list_length(output_modules);
  if(return_value_g_list_length$8 == 0u)
  {
    MSG(0, "Error [%s:%d]:No speech output modules were loaded - aborting...", (const void *)"speechd.c", 636);
    exit(1);
  }

  else
  {
    unsigned int return_value_g_list_length$6;
    return_value_g_list_length$6=g_list_length(output_modules);
    unsigned int return_value_g_list_length$7;
    return_value_g_list_length$7=g_list_length(output_modules);
    MSG(3, "Speech Dispatcher started with %d output module%s", return_value_g_list_length$6, return_value_g_list_length$7 > (unsigned int)1 ? "s" : "");
  }
  last_p5_block = (struct _GList *)(void *)0;
}

// speechd_load_configuration
// file speechd.c line 646
void speechd_load_configuration(signed int sig)
{
  struct configfile_t *configfile = (struct configfile_t *)(void *)0;
  struct _GList *detected_modules = (struct _GList *)(void *)0;
  if(!(output_modules == ((struct _GList *)NULL)))
  {
    g_list_foreach(output_modules, speechd_modules_terminate, (void *)0);
    g_list_free(output_modules);
    output_modules = (struct _GList *)(void *)0;
  }

  signed int return_value_waitpid$1;
  do
  {
    return_value_waitpid$1=waitpid(-1, (signed int *)(void *)0, 1);
    if(!(return_value_waitpid$1 >= 1))
      break;

  }
  while((_Bool)1);
  load_default_global_set_options();
  spd_num_options = 0;
  spd_options=load_config_options(&spd_num_options);
  spd_options=add_config_option(spd_options, &spd_num_options, "", 0, (const char * (*)(struct command_t *, void *))(void *)0, (void *)0, (unsigned long int)0);
  configfile=dotconf_create(SpeechdOptions.conf_file, spd_options, NULL, (unsigned long int)(1 << 0));
  if(!(configfile == ((struct configfile_t *)NULL)))
  {
    configfile->includepath=g_strdup(SpeechdOptions.conf_dir);
    MSG(5, "Config file include path is: %s", configfile->includepath);
    signed int return_value_dotconf_command_loop$2;
    return_value_dotconf_command_loop$2=dotconf_command_loop(configfile);
    if(return_value_dotconf_command_loop$2 == 0)
    {
      MSG(0, "Error [%s:%d]:Error reading config file\n", (const void *)"speechd.c", 679);
      exit(1);
    }

    dotconf_cleanup(configfile);
    MSG(2, "Configuration has been read from \"%s\"", SpeechdOptions.conf_file);
    detected_modules=detect_output_modules("/usr/lib/speech-dispatcher-modules");
    while(!(detected_modules == ((struct _GList *)NULL)))
    {
      char **parameters = (char **)detected_modules->data;
      module_add_load_request(parameters[(signed long int)0], parameters[(signed long int)1], parameters[(signed long int)2], parameters[(signed long int)3]);
      g_free(detected_modules->data);
      detected_modules->data = (void *)0;
      detected_modules=g_list_delete_link(detected_modules, detected_modules);
    }
    module_load_requested_modules();
  }

  else
    MSG(1, "Can't open %s", SpeechdOptions.conf_file);
  free_config_options(spd_options, &spd_num_options);
}

// speechd_module_debug
// file speechd.c line 477
void speechd_module_debug(void *data, void *user_data)
{
  struct anonymous$10 *module = (struct anonymous$10 *)data;
  if(module == ((struct anonymous$10 *)NULL))
    MSG(2, "Empty module, internal error");

  else
  {
    output_module_debug(module);
    goto __CPROVER_DUMP_L2;
  }

__CPROVER_DUMP_L2:
  ;
}

// speechd_module_nodebug
// file speechd.c line 492
void speechd_module_nodebug(void *data, void *user_data)
{
  struct anonymous$10 *module = (struct anonymous$10 *)data;
  if(module == ((struct anonymous$10 *)NULL))
    MSG(2, "Empty module, internal error");

  else
  {
    output_module_nodebug(module);
    goto __CPROVER_DUMP_L2;
  }

__CPROVER_DUMP_L2:
  ;
}

// speechd_modules_debug
// file speechd.c line 516
void speechd_modules_debug(void)
{
  g_list_foreach(output_modules, speechd_module_debug, (void *)0);
}

// speechd_modules_nodebug
// file speechd.c line 523
void speechd_modules_nodebug(void)
{
  g_list_foreach(output_modules, speechd_module_nodebug, (void *)0);
}

// speechd_modules_reload
// file speechd.c line 462
void speechd_modules_reload(void *data, void *user_data)
{
  struct anonymous$10 *module = (struct anonymous$10 *)data;
  if(module == ((struct anonymous$10 *)NULL))
    MSG(2, "Empty module, internal error");

  else
  {
    reload_output_module(module);
    goto __CPROVER_DUMP_L2;
  }

__CPROVER_DUMP_L2:
  ;
}

// speechd_modules_terminate
// file speechd.c line 448
void speechd_modules_terminate(void *data, void *user_data)
{
  struct anonymous$10 *module = (struct anonymous$10 *)data;
  if(module == ((struct anonymous$10 *)NULL))
    MSG(2, "Error: Empty module, internal error");

  else
  {
    unload_output_module(module);
    goto __CPROVER_DUMP_L2;
  }

__CPROVER_DUMP_L2:
  ;
}

// speechd_options_init
// file speechd.c line 531
void speechd_options_init(void)
{
  SpeechdOptions.spawn = 0;
  SpeechdOptions.log_level_set = 0;
  SpeechdOptions.communication_method = (char *)(void *)0;
  SpeechdOptions.socket_path = (char *)(void *)0;
  SpeechdOptions.port_set = 0;
  SpeechdOptions.localhost_access_only_set = 0;
  SpeechdOptions.pid_file = (char *)(void *)0;
  SpeechdOptions.conf_file = (char *)(void *)0;
  SpeechdOptions.runtime_speechd_dir = (char *)(void *)0;
  SpeechdOptions.log_dir = (char *)(void *)0;
  SpeechdOptions.log_dir_set = 0;
  SpeechdOptions.debug = 0;
  SpeechdOptions.debug_destination = (char *)(void *)0;
  debug_logfile = (struct _IO_FILE *)(void *)0;
  spd_mode = (enum anonymous$25)SPD_MODE_DAEMON;
}

// speechd_quit
// file speechd.c line 706
void speechd_quit(signed int sig)
{
  signed int ret;
  MSG(1, "Terminating...");
  MSG(2, "Closing open connections...");
  g_hash_table_foreach_remove(fd_settings, speechd_client_terminate, (void *)0);
  g_hash_table_destroy(fd_settings);
  MSG(4, "Closing speak() thread...");
  ret=pthread_cancel(speak_thread);
  if(!(ret == 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Speak thread failed to cancel!\n", (const void *)"speechd.c", 721);
    exit(1);
  }

  ret=pthread_join(speak_thread, (void **)(void *)0);
  if(!(ret == 0))
  {
    fatal_error();
    MSG(-1, "Fatal error [%s:%d]:Speak thread failed to join!\n", (const void *)"speechd.c", 725);
    exit(1);
  }

  MSG(2, "Closing open output modules...");
  g_list_foreach(output_modules, speechd_modules_terminate, (void *)0);
  g_list_free(output_modules);
  MSG(2, "Closing server connection...");
  signed int return_value_close$3;
  return_value_close$3=close(server_socket);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(return_value_close$3 == -1)
  {
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    MSG(2, "close() failed: %s", return_value_strerror$2);
  }

  (&readfds)->fds_bits[(signed long int)(server_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(server_socket / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << server_socket % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
  MSG(4, "Removing pid file");
  destroy_pid_file();
  fflush((struct _IO_FILE *)(void *)0);
  MSG(2, "Speech Dispatcher terminated correctly");
  exit(0);
}

// speechd_reload_dead_modules
// file speechd.c line 507
void speechd_reload_dead_modules(signed int sig)
{
  g_list_foreach(output_modules, speechd_modules_reload, (void *)0);
  signed int return_value_waitpid$1;
  do
  {
    return_value_waitpid$1=waitpid(-1, (signed int *)(void *)0, 1);
    if(!(return_value_waitpid$1 >= 1))
      break;

  }
  while((_Bool)1);
}

// speechd_socket_free
// file speechd.c line 313
void speechd_socket_free(struct anonymous$0 *speechd_socket)
{
  if(!(speechd_socket->o_buf == ((struct _GString *)NULL)))
    g_string_free(speechd_socket->o_buf, 1);

  g_free((void *)speechd_socket);
}

// speechd_socket_get_by_fd
// file speechd.c line 327
struct anonymous$0 * speechd_socket_get_by_fd(signed int fd)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(speechd_sockets_status, (const void *)&fd);
  return (struct anonymous$0 *)return_value_g_hash_table_lookup$1;
}

// speechd_socket_register
// file speechd.c line 297
signed int speechd_socket_register(signed int fd)
{
  signed int *fd_key;
  struct anonymous$0 *speechd_socket;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$0) /*24ul*/ );
  speechd_socket = (struct anonymous$0 *)return_value_g_malloc$1;
  speechd_socket->o_buf = (struct _GString *)(void *)0;
  speechd_socket->o_bytes = (unsigned long int)0;
  speechd_socket->awaiting_data = 0;
  speechd_socket->inside_block = 0;
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc(sizeof(signed int) /*4ul*/ );
  fd_key = (signed int *)return_value_g_malloc$2;
  *fd_key = fd;
  g_hash_table_insert(speechd_sockets_status, (void *)fd_key, (void *)speechd_socket);
  return 0;
}

// speechd_socket_unregister
// file speechd.c line 321
signed int speechd_socket_unregister(signed int fd)
{
  signed int return_value_g_hash_table_remove$1;
  return_value_g_hash_table_remove$1=g_hash_table_remove(speechd_sockets_status, (const void *)&fd);
  return (signed int)!(return_value_g_hash_table_remove$1 != 0);
}

// speechd_sockets_status_init
// file speechd.c line 284
signed int speechd_sockets_status_init(void)
{
  speechd_sockets_status=g_hash_table_new_full(g_int_hash, g_int_equal, (void (*)(void *))g_free, (void (*)(void *))speechd_socket_free);
  if(!(speechd_sockets_status == ((struct _GHashTable *)NULL)))
    return 0;

  else
    return 1;
}

// stop_from_uid
// file speaking.c line 857
void stop_from_uid(const signed int uid)
{
  check_locked(&element_free_mutex);
  MessageQueue->p1=stop_priority_from_uid(MessageQueue->p1, uid);
  MessageQueue->p2=stop_priority_from_uid(MessageQueue->p2, uid);
  MessageQueue->p3=stop_priority_from_uid(MessageQueue->p3, uid);
  MessageQueue->p4=stop_priority_from_uid(MessageQueue->p4, uid);
  MessageQueue->p5=stop_priority_from_uid(MessageQueue->p5, uid);
}

// stop_priority
// file speaking.c line 812
signed int stop_priority(enum anonymous$9 priority)
{
  struct _GList *queue;
  queue=speaking_get_queue(priority);
  if(highest_priority == priority)
    output_stop();

  queue=empty_queue(queue);
  speaking_set_queue(priority, queue);
  return 0;
}

// stop_priority_except_first
// file speaking.c line 912
void stop_priority_except_first(enum anonymous$9 priority)
{
  struct _GList *queue;
  struct _GList *gl;
  struct anonymous$7 *msg;
  struct _GList *gl_next;
  signed int gid;
  queue=speaking_get_queue(priority);
  gl=g_list_last(queue);
  struct _GList *tmp_if_expr$1;
  if(!(gl == ((struct _GList *)NULL)))
  {
    if(!(gl->data == NULL))
    {
      msg = (struct anonymous$7 *)gl->data;
      if(!(msg->settings.reparted >= 1))
      {
        queue=g_list_remove_link(queue, gl);
        speaking_set_queue(priority, queue);
        stop_priority(priority);
        speaking_set_queue(priority, gl);
      }

      else
      {
        gid = msg->settings.reparted;
        if(highest_priority == priority && !(speaking_gid == gid))
          output_stop();

        gl=g_list_first(queue);
        for( ; !(gl == ((struct _GList *)NULL)); gl = gl_next)
        {
          if(!(gl == ((struct _GList *)NULL)))
            tmp_if_expr$1 = ((struct _GList *)gl)->next;

          else
            tmp_if_expr$1 = (struct _GList *)(void *)0;
          gl_next = tmp_if_expr$1;
          if(!(gl->data == NULL))
          {
            struct anonymous$7 *msgg = (struct anonymous$7 *)gl->data;
            if(!(msgg->settings.reparted == gid))
            {
              queue=g_list_remove_link(queue, gl);
              mem_free_message(msgg);
            }

          }

        }
        speaking_set_queue(priority, queue);
      }
      goto __CPROVER_DUMP_L12;
    }

  }


__CPROVER_DUMP_L12:
  ;
}

// stop_priority_from_uid
// file speaking.c line 846
struct _GList * stop_priority_from_uid(struct _GList *queue, const signed int uid)
{
  struct _GList *ret = queue;
  struct _GList *gl;
  do
  {
    gl=g_list_find_custom(ret, (const void *)&uid, (signed int (*)(const void *, const void *))p_msg_uid_lc);
    if(gl == ((struct _GList *)NULL))
      break;

    ret=queue_remove_message(ret, gl);
  }
  while((_Bool)1);
  return ret;
}

// stop_priority_older_than
// file speaking.c line 829
signed int stop_priority_older_than(enum anonymous$9 priority, unsigned int uid)
{
  struct _GList *queue;
  queue=speaking_get_queue(priority);
  if(highest_priority == priority)
    output_stop();

  queue=empty_queue_by_time(queue, uid);
  speaking_set_queue(priority, queue);
  return 0;
}

// str2ECapLetRecogn
// file ../../include/fdsetconv.h line 22
enum anonymous$4 str2ECapLetRecogn(char *str)
{
  enum anonymous$4 recogn;
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(str, "none");
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$3 == 0)
    recogn = (enum anonymous$4)SPD_CAP_NONE;

  else
  {
    return_value_strcmp$2=strcmp(str, "spell");
    if(return_value_strcmp$2 == 0)
      recogn = (enum anonymous$4)SPD_CAP_SPELL;

    else
    {
      return_value_strcmp$1=strcmp(str, "icon");
      if(return_value_strcmp$1 == 0)
        recogn = (enum anonymous$4)SPD_CAP_ICON;

      else
        recogn = (enum anonymous$4)-1;
    }
  }
  return recogn;
}

// str2EPunctMode
// file ../../include/fdsetconv.h line 14
enum anonymous$2 str2EPunctMode(char *str)
{
  enum anonymous$2 punct;
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(str, "none");
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$3 == 0)
    punct = (enum anonymous$2)SPD_PUNCT_NONE;

  else
  {
    return_value_strcmp$2=strcmp(str, "all");
    if(return_value_strcmp$2 == 0)
      punct = (enum anonymous$2)SPD_PUNCT_ALL;

    else
    {
      return_value_strcmp$1=strcmp(str, "some");
      if(return_value_strcmp$1 == 0)
        punct = (enum anonymous$2)SPD_PUNCT_SOME;

      else
        punct = (enum anonymous$2)-1;
    }
  }
  return punct;
}

// str2ESpellMode
// file fdsetconv.c line 149
enum anonymous$1 str2ESpellMode(char *str)
{
  enum anonymous$1 spell;
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(str, "on");
  signed int return_value_strcmp$1;
  if(return_value_strcmp$2 == 0)
    spell = (enum anonymous$1)SPD_SPELL_ON;

  else
  {
    return_value_strcmp$1=strcmp(str, "off");
    if(return_value_strcmp$1 == 0)
      spell = (enum anonymous$1)SPD_SPELL_OFF;

    else
      spell = (enum anonymous$1)-1;
  }
  return spell;
}

// str2EVoice
// file ../../include/fdsetconv.h line 10
enum anonymous$27 str2EVoice(char *str)
{
  enum anonymous$27 voice;
  signed int return_value_strcmp$8;
  return_value_strcmp$8=strcmp(str, "male1");
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$8 == 0)
    voice = (enum anonymous$27)SPD_MALE1;

  else
  {
    return_value_strcmp$7=strcmp(str, "male2");
    if(return_value_strcmp$7 == 0)
      voice = (enum anonymous$27)SPD_MALE2;

    else
    {
      return_value_strcmp$6=strcmp(str, "male3");
      if(return_value_strcmp$6 == 0)
        voice = (enum anonymous$27)SPD_MALE3;

      else
      {
        return_value_strcmp$5=strcmp(str, "female1");
        if(return_value_strcmp$5 == 0)
          voice = (enum anonymous$27)SPD_FEMALE1;

        else
        {
          return_value_strcmp$4=strcmp(str, "female2");
          if(return_value_strcmp$4 == 0)
            voice = (enum anonymous$27)SPD_FEMALE2;

          else
          {
            return_value_strcmp$3=strcmp(str, "female3");
            if(return_value_strcmp$3 == 0)
              voice = (enum anonymous$27)SPD_FEMALE3;

            else
            {
              return_value_strcmp$2=strcmp(str, "child_male");
              if(return_value_strcmp$2 == 0)
                voice = (enum anonymous$27)SPD_CHILD_MALE;

              else
              {
                return_value_strcmp$1=strcmp(str, "child_female");
                if(return_value_strcmp$1 == 0)
                  voice = (enum anonymous$27)SPD_CHILD_FEMALE;

                else
                  voice = (enum anonymous$27)-1;
              }
            }
          }
        }
      }
    }
  }
  return voice;
}

// str2intpriority
// file ../../include/fdsetconv.h line 24
enum anonymous$9 str2intpriority(char *str)
{
  enum anonymous$9 priority;
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(str, "important");
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$5 == 0)
    priority = (enum anonymous$9)SPD_IMPORTANT;

  else
  {
    return_value_strcmp$4=strcmp(str, "message");
    if(return_value_strcmp$4 == 0)
      priority = (enum anonymous$9)SPD_MESSAGE;

    else
    {
      return_value_strcmp$3=strcmp(str, "text");
      if(return_value_strcmp$3 == 0)
        priority = (enum anonymous$9)SPD_TEXT;

      else
      {
        return_value_strcmp$2=strcmp(str, "notification");
        if(return_value_strcmp$2 == 0)
          priority = (enum anonymous$9)SPD_NOTIFICATION;

        else
        {
          return_value_strcmp$1=strcmp(str, "progress");
          if(return_value_strcmp$1 == 0)
            priority = (enum anonymous$9)SPD_PROGRESS;

          else
            priority = (enum anonymous$9)-1;
        }
      }
    }
  }
  return priority;
}

// strip_index_marks
// file index_marking.h line 44
char * strip_index_marks(char *buf, enum anonymous$5 ssml_mode)
{
  struct _GString *str;
  char *strret;
  char str_mark[19l] = { '<', 'm', 'a', 'r', 'k', ' ', 'n', 'a', 'm', 'e', '=', '"', '_', '_', 's', 'p', 'd', '_', 0 };
  char *p;
  char *p_old;
  if((signed int)ssml_mode == SPD_DATA_SSML)
    str=g_string_new("<speak>");

  else
    str=g_string_new("");
  MSG2(5, "index_marking", "Message before stripping index marks: |%s|", buf);
  p = buf;
  _Bool tmp_if_expr$1;
  while((_Bool)1)
  {
    if((signed int)*p == 0)
      break;

    p_old = p;
    p=strstr(p, str_mark);
    if(!(p == ((char *)NULL)))
      g_string_append_len(str, p_old, (signed long int)(signed int)(p - p_old));

    else
    {
      g_string_append(str, p_old);
      break;
    }
    do
    {
      p = p + 1l;
      if(!((signed int)*p == 62))
        tmp_if_expr$1 = (signed int)*p != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
    }
    while(tmp_if_expr$1);
    if((signed int)*p == 62)
      p = p + 1l;

  }
  if((signed int)ssml_mode == SPD_DATA_TEXT)
  {
    p=strstr(str->str, "</speak>");
    if(!(p == ((char *)NULL)))
      *p = (char)0;

  }

  strret = str->str;
  g_string_free(str, 0);
  MSG2(5, "index_marking", "Message after stripping index marks: |%s|", strret);
  return strret;
}

// unload_output_module
// file module.h line 47
signed int unload_output_module(struct anonymous$10 *module)
{
  /* assertion module != ((void *)0) */
  assert(module != (struct anonymous$10 *)(void *)0);
  MSG(3, "Unloading module name=%s", module->name);
  output_close(module);
  close(module->pipe_in[(signed long int)1]);
  close(module->pipe_out[(signed long int)0]);
  destroy_module(module);
  return 0;
}

// update_cl_settings
// file set.c line 275
void update_cl_settings(void *data, void *user_data)
{
  struct anonymous$26 *cl_set = (struct anonymous$26 *)data;
  struct anonymous$11 *set = (struct anonymous$11 *)user_data;
  MSG(4, "Updating client specific settings %s against %s", set->client_name, cl_set->pattern);
  signed int return_value_fnmatch$1;
  return_value_fnmatch$1=fnmatch(cl_set->pattern, set->client_name, 0);
  if(return_value_fnmatch$1 == 0)
  {
    if(!(cl_set->val.msg_settings.rate == -101))
    {
      set->msg_settings.rate = cl_set->val.msg_settings.rate;
      MSG(4, "parameter msg_settings.rate set to %d", cl_set->val.msg_settings.rate);
    }

    if(!(cl_set->val.msg_settings.pitch == -101))
    {
      set->msg_settings.pitch = cl_set->val.msg_settings.pitch;
      MSG(4, "parameter msg_settings.pitch set to %d", cl_set->val.msg_settings.pitch);
    }

    if(!(cl_set->val.msg_settings.volume == -101))
    {
      set->msg_settings.volume = cl_set->val.msg_settings.volume;
      MSG(4, "parameter msg_settings.volume set to %d", cl_set->val.msg_settings.volume);
    }

    if(!((signed int)cl_set->val.msg_settings.punctuation_mode == -1))
    {
      set->msg_settings.punctuation_mode = cl_set->val.msg_settings.punctuation_mode;
      MSG(4, "parameter msg_settings.punctuation_mode set to %d", cl_set->val.msg_settings.punctuation_mode);
    }

    if(!((signed int)cl_set->val.msg_settings.spelling_mode == -1))
    {
      set->msg_settings.spelling_mode = cl_set->val.msg_settings.spelling_mode;
      MSG(4, "parameter msg_settings.spelling_mode set to %d", cl_set->val.msg_settings.spelling_mode);
    }

    if(!((signed int)cl_set->val.msg_settings.voice_type == -1))
    {
      set->msg_settings.voice_type = cl_set->val.msg_settings.voice_type;
      MSG(4, "parameter msg_settings.voice_type set to %d", cl_set->val.msg_settings.voice_type);
    }

    if(!((signed int)cl_set->val.msg_settings.cap_let_recogn == -1))
    {
      set->msg_settings.cap_let_recogn = cl_set->val.msg_settings.cap_let_recogn;
      MSG(4, "parameter msg_settings.cap_let_recogn set to %d", cl_set->val.msg_settings.cap_let_recogn);
    }

    if(!(cl_set->val.pause_context == -1))
    {
      set->pause_context = cl_set->val.pause_context;
      MSG(4, "parameter pause_context set to %d", cl_set->val.pause_context);
    }

    if(!((signed int)cl_set->val.ssml_mode == -1))
    {
      set->ssml_mode = cl_set->val.ssml_mode;
      MSG(4, "parameter ssml_mode set to %d", cl_set->val.ssml_mode);
    }

    if(!(cl_set->val.msg_settings.voice.language == ((char *)NULL)))
    {
      g_free((void *)set->msg_settings.voice.language);
      set->msg_settings.voice.language=g_strdup(cl_set->val.msg_settings.voice.language);
      MSG(4, "parameter msg_settings.voice.language set to %s", cl_set->val.msg_settings.voice.language);
    }

    if(!(cl_set->val.output_module == ((char *)NULL)))
    {
      g_free((void *)set->output_module);
      set->output_module=g_strdup(cl_set->val.output_module);
      MSG(4, "parameter output_module set to %s", cl_set->val.output_module);
    }

    goto __CPROVER_DUMP_L13;
  }


__CPROVER_DUMP_L13:
  ;
}

// waitpid_with_timeout
// file output.c line 718
signed int waitpid_with_timeout(signed int pid, signed int *status_ptr, signed int options, unsigned long int timeout)
{
  unsigned long int i;
  signed int ret;
  i = (unsigned long int)0;
  for( ; timeout >= i; i = i + (unsigned long int)100)
  {
    ret=waitpid(pid, status_ptr, options | 1);
    if(ret >= 1)
      return ret;

    if(!(ret >= 0))
      return ret;

    usleep((unsigned int)(100 * 1000));
  }
  return 0;
}

