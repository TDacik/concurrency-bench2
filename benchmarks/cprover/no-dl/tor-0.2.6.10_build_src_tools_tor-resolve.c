// #anon_enum_CMP_EXACT=0_CMP_SEMANTIC=1
// file ../src/common/address.h line 200
enum anonymous_18 { CMP_EXACT=0, CMP_SEMANTIC=1 };

// #anon_enum_FN_ERROR=0_FN_NOENT=1_FN_FILE=2_FN_DIR=3_FN_EMPTY=4
// file ../src/common/util.h line 346
enum anonymous_17 { FN_ERROR=0, FN_NOENT=1, FN_FILE=2, FN_DIR=3, FN_EMPTY=4 };

// #anon_enum_LIBSECCOMP2=0
// file ../src/common/sandbox.h line 55
enum anonymous_0 { LIBSECCOMP2=0 };

// tag-#anon#ST[*{SYM#tag-cached_getaddrinfo_item_t#}_SYM#tag-cached_getaddrinfo_item_t#_'hte_next'||U32'hte_hash'||U32'_pad0'|]
// file ../src/common/sandbox.c line 1307
struct anonymous;

// tag-#anon#ST[*{SYM#tag-digest256map_entry_t#}_SYM#tag-digest256map_entry_t#_'hte_next'||U32'hte_hash'||U32'_pad0'|]
// file ../src/common/container.c line 1041
struct anonymous_15;

// tag-#anon#ST[*{SYM#tag-digestmap_entry_t#}_SYM#tag-digestmap_entry_t#_'hte_next'||U32'hte_hash'||U32'_pad0'|]
// file ../src/common/container.c line 1040
struct anonymous_14;

// tag-#anon#ST[*{SYM#tag-strmap_entry_t#}_SYM#tag-strmap_entry_t#_'hte_next'||U32'hte_hash'||U32'_pad0'|]
// file ../src/common/container.c line 1039
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-waitpid_callback_t#}_SYM#tag-waitpid_callback_t#_'hte_next'||U32'hte_hash'||U32'_pad0'|]
// file ../src/common/util_process.c line 39
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#_'tqe_next'||*{*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#_}_*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#__'tqe_prev'|]
// file ../src/common/workqueue.c line 51
struct anonymous_4;

// tag-#anon#ST[*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#_'tqh_first'||*{*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#_}_*{SYM#tag-workqueue_entry_s#}_SYM#tag-workqueue_entry_s#__'tqh_last'|]
// file ../src/common/workqueue.c line 21
struct anonymous_3;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_36;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_34;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_27;

// tag-#anon#ST[ARR23{S64}_S64_'gregs'||*{SYM#tag-_libc_fpstate#}_SYM#tag-_libc_fpstate#_'fpregs'||ARR8{U64}_U64_'__reserved1'|]
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 124
struct anonymous_28;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous_11;

// tag-#anon#ST[S32'mask'||U32'_pad0'||*{U32}_U32_'ba'|]
// file ../src/common/container.h line 638
struct anonymous_12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_30;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_33;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_32;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_25;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_31;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_35;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous_23;

// tag-#anon#UN[*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_broadaddr'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous_20;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_26;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_21;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_6;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_24;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
union anonymous_7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous_8;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_29;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_22;

// tag-#anon#UN[U32'dummy_'||SYM#tag-in_addr#'in_addr'||SYM#tag-in6_addr#'in6_addr'|]
// file ../src/common/address.h line 59
union anonymous_5;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_2;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_9;

// tag-#anon#cST[S32'syscall_num'||U32'_pad0'||*{cS8}_cS8_'syscall_name'|]
// file ../src/common/linux_syscalls.inc line 5
struct anonymous_1;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_libc_fpstate
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 104
struct _libc_fpstate;

// tag-_libc_fpxreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 92
struct _libc_fpxreg;

// tag-_libc_xmmreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 99
struct _libc_xmmreg;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alert_sockets_s
// file ../src/common/compat_threads.h line 90
struct alert_sockets_s;

// tag-cached_getaddrinfo_item_t
// file ../src/common/sandbox.c line 1306
struct cached_getaddrinfo_item_t;

// tag-di_digest256_map_t
// file ../src/common/di_ops.h line 37
struct di_digest256_map_t;

// tag-digest256map_entry_t
// file ../src/common/container.h line 365
struct digest256map_entry_t;

// tag-digest256map_impl
// file ../src/common/container.c line 1041
struct digest256map_impl;

// tag-digest256map_t
// file ../src/common/container.h line 365
struct digest256map_t;

// tag-digestmap_entry_t
// file ../src/common/container.h line 362
struct digestmap_entry_t;

// tag-digestmap_impl
// file ../src/common/container.c line 1040
struct digestmap_impl;

// tag-digestmap_t
// file ../src/common/container.h line 362
struct digestmap_t;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-getaddrinfo_cache
// file ../src/common/sandbox.c line 1341
struct getaddrinfo_cache;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-log_severity_list_t
// file ../src/tools/../common/torlog.h line 117
struct log_severity_list_t;

// tag-logfile_t
// file ../src/common/log.c line 51
struct logfile_t;

// tag-mallinfo
// file /usr/include/malloc.h line 79
struct mallinfo;

// tag-memarea_chunk_t
// file ../src/common/memarea.c line 78
struct memarea_chunk_t;

// tag-memarea_t
// file ../src/common/memarea.h line 8
struct memarea_t;

// tag-open_file_t
// file ../src/common/util.h line 364
struct open_file_t;

// tag-passwd
// file ../src/common/compat.h line 643
struct passwd;

// tag-pending_log_message_t
// file ../src/common/log.c line 120
struct pending_log_message_t;

// tag-process_environment_t
// file ../src/common/util.h line 422
struct process_environment_t;

// tag-process_handle_t
// file ../src/common/util.h line 421
struct process_handle_t;

// tag-process_map
// file ../src/common/util_process.c line 61
struct process_map;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-ratelim_t
// file ../src/common/util.h line 318
struct ratelim_t;

// tag-replyqueue_s
// file ../src/common/workqueue.h line 11
struct replyqueue_s;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sandbox_cfg_elem
// file ../src/common/sandbox.h line 32
struct sandbox_cfg_elem;

// tag-scmp_arg_cmp
// file /usr/include/seccomp.h line 86
struct scmp_arg_cmp;

// tag-scmp_compare
// file /usr/include/seccomp.h line 66
enum scmp_compare { _SCMP_CMP_MIN=0, SCMP_CMP_NE=1, SCMP_CMP_LT=2, SCMP_CMP_LE=3, SCMP_CMP_EQ=4, SCMP_CMP_GE=5, SCMP_CMP_GT=6, SCMP_CMP_MASKED_EQ=7, _SCMP_CMP_MAX=8 };

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigaltstack
// file /usr/include/x86_64-linux-gnu/bits/sigstack.h line 49
struct sigaltstack;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sipkey
// file ../src/ext/siphash.h line 4
struct sipkey;

// tag-sized_chunk_t
// file ../src/common/util.h line 378
struct sized_chunk_t;

// tag-smartlist_t
// file ../src/common/util.h line 248
struct smartlist_t;

// tag-smp_param
// file ../src/common/sandbox.h line 64
struct smp_param;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stream_status
// file ../src/common/util.h line 333
enum stream_status { IO_STREAM_OKAY=0, IO_STREAM_EAGAIN=1, IO_STREAM_TERM=2, IO_STREAM_CLOSED=3 };

// tag-strmap_entry_t
// file ../src/common/container.h line 360
struct strmap_entry_t;

// tag-strmap_impl
// file ../src/common/container.c line 1039
struct strmap_impl;

// tag-strmap_t
// file ../src/common/container.h line 360
struct strmap_t;

// tag-threadpool_s
// file ../src/common/workqueue.h line 13
struct threadpool_s;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-tor_addr_port_t
// file ../src/common/address.h line 68
struct tor_addr_port_t;

// tag-tor_addr_t
// file ../src/common/address.h line 56
struct tor_addr_t;

// tag-tor_cond_t
// file ../src/common/compat_threads.h line 64
struct tor_cond_t;

// tag-tor_lockfile_t
// file ../src/common/compat.h line 421
struct tor_lockfile_t;

// tag-tor_mmap_t
// file ../src/common/compat.h line 283
struct tor_mmap_t;

// tag-tor_mutex_t
// file ../src/common/compat_threads.h line 33
struct tor_mutex_t;

// tag-tor_pthread_data_t
// file ../src/common/compat_pthreads.c line 20
struct tor_pthread_data_t;

// tag-tor_weak_rng_t
// file ../src/common/util.h line 535
struct tor_weak_rng_t;

// tag-trunnel_string_st
// file ../src/ext/trunnel/trunnel.h line 30
struct trunnel_string_st;

// tag-ucontext
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 133
struct ucontext;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-waitpid_callback_t
// file ../src/common/util_process.h line 17
struct waitpid_callback_t;

// tag-workerthread_s
// file ../src/common/workqueue.c line 15
struct workerthread_s;

// tag-workqueue_entry_s
// file ../src/common/workqueue.h line 16
struct workqueue_entry_s;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// TOR_ISALPHA
// file ../src/common/compat.h line 329
static inline signed int TOR_ISALPHA(char c);
// TOR_ISDIGIT
// file ../src/common/compat.h line 332
static inline signed int TOR_ISDIGIT(char c);
// TOR_ISDIGIT_link1
// file ../src/common/compat.h line 332
static inline signed int TOR_ISDIGIT_link1(char c_link1);
// TOR_ISPRINT
// file ../src/common/compat.h line 334
static inline signed int TOR_ISPRINT(char c);
// TOR_ISSPACE
// file ../src/common/compat.h line 331
static inline signed int TOR_ISSPACE(char c);
// TOR_ISSPACE_link1
// file ../src/common/compat.h line 331
static inline signed int TOR_ISSPACE_link1(char c_link1);
// TOR_ISUPPER
// file ../src/common/compat.h line 336
static inline signed int TOR_ISUPPER(char c);
// TOR_ISXDIGIT
// file ../src/common/compat.h line 333
static inline signed int TOR_ISXDIGIT(char c);
// TOR_ISXDIGIT_link1
// file ../src/common/compat.h line 333
static inline signed int TOR_ISXDIGIT_link1(char c_link1);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2);
// __bswap_32_link3
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link3(unsigned int __bsx_link3);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fgets_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 243
extern char * __fgets_alias(char *, signed int, struct _IO_FILE *);
// __fgets_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 241
extern char * __fgets_chk(char *, unsigned long int, signed int, struct _IO_FILE *);
// __fgets_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 246
extern char * __fgets_chk_warn(char *, unsigned long int, signed int, struct _IO_FILE *);
// __fprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 85
extern signed int __fprintf_chk(struct _IO_FILE *, signed int, const char *, ...);
// __fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 399
extern signed int __fxstat(signed int, signed int, struct stat *);
// __getcwd_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 191
extern char * __getcwd_alias(char *, unsigned long int);
// __getcwd_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 189
extern char * __getcwd_chk(char *, unsigned long int, unsigned long int);
// __getcwd_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 193
extern char * __getcwd_chk_warn(char *, unsigned long int, unsigned long int);
// __getgroups_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 256
extern signed int __getgroups_alias(signed int, unsigned int *);
// __getgroups_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 254
extern signed int __getgroups_chk(signed int, unsigned int *, unsigned long int);
// __getgroups_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 258
extern signed int __getgroups_chk_warn(signed int, unsigned int *, unsigned long int);
// __gethostname_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 335
extern signed int __gethostname_alias(char *, unsigned long int);
// __gethostname_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 333
extern signed int __gethostname_chk(char *, unsigned long int, unsigned long int);
// __gethostname_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 337
extern signed int __gethostname_chk_warn(char *, unsigned long int, unsigned long int);
// __open_2
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 26
extern signed int __open_2(const char *, signed int);
// __open_alias
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 27
extern signed int __open_alias(const char *, signed int, ...);
// __open_missing_mode
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 37
extern void __open_missing_mode(void);
// __open_too_many_args
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 35
extern void __open_too_many_args(void);
// __printf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 87
extern signed int __printf_chk(signed int, const char *, ...);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __read_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 25
extern signed long int __read_alias(signed int, void *, unsigned long int);
// __read_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 23
extern signed long int __read_chk(signed int, void *, unsigned long int, unsigned long int);
// __read_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 27
extern signed long int __read_chk_warn(signed int, void *, unsigned long int, unsigned long int);
// __recv_alias
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 25
extern signed long int __recv_alias(signed int, void *, unsigned long int, signed int);
// __recv_chk
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 23
extern signed long int __recv_chk(signed int, void *, unsigned long int, unsigned long int, signed int);
// __recv_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 27
extern signed long int __recv_chk_warn(signed int, void *, unsigned long int, unsigned long int, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __syslog_chk
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 24
extern void __syslog_chk(signed int, signed int, const char *, ...);
// __vasprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 161
extern signed int __vasprintf_chk(char ** restrict , signed int, const char *, void **);
// __warn_memset_zero_len
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 22
extern void __warn_memset_zero_len(void);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// _cmp_double
// file ../src/common/container.c line 1436
static signed int _cmp_double(const void *_a, const void *_b);
// _cmp_int
// file ../src/common/container.c line 1434
static signed int _cmp_int(const void *_a, const void *_b);
// _cmp_int32_t
// file ../src/common/container.c line 1438
static signed int _cmp_int32_t(const void *_a, const void *_b);
// _cmp_long
// file ../src/common/container.c line 1439
static signed int _cmp_long(const void *_a, const void *_b);
// _cmp_time_t
// file ../src/common/container.c line 1435
static signed int _cmp_time_t(const void *_a, const void *_b);
// _cmp_uint32_t
// file ../src/common/container.c line 1437
static signed int _cmp_uint32_t(const void *_a, const void *_b);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abort_writing_to_file
// file ../src/common/util.c line 2451
signed int abort_writing_to_file(struct open_file_t *file_data);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_9, unsigned int *);
// accept4
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 251
extern signed int accept4(signed int, union anonymous_9, unsigned int *, signed int);
// add_callback_log
// file ../src/common/log.c line 967
signed int add_callback_log(const struct log_severity_list_t *severity, void (*cb)(signed int, unsigned int, const char *));
// add_callback_log::cb_object
//
void cb_object(signed int, unsigned int, const char *);
// add_file_log
// file ../src/common/log.c line 1136
signed int add_file_log(const struct log_severity_list_t *severity, const char *filename, const signed int truncate);
// add_laplace_noise
// file ../src/common/util.c line 556
signed long int add_laplace_noise(signed long int signal, double random, double delta_f, double epsilon);
// add_noparam_filter
// file ../src/common/sandbox.c line 1498
static signed int add_noparam_filter(void *ctx);
// add_param_filter
// file ../src/common/sandbox.c line 1476
static signed int add_param_filter(void *ctx, struct sandbox_cfg_elem *cfg);
// add_stream_log
// file ../src/tools/../common/torlog.h line 133
void add_stream_log(const struct log_severity_list_t *severity, const char *name, signed int fd);
// add_stream_log_impl
// file ../src/common/log.c line 895
static void add_stream_log_impl(const struct log_severity_list_t *severity, const char *name, signed int fd);
// add_syslog_log
// file ../src/common/log.c line 1172
signed int add_syslog_log(const struct log_severity_list_t *severity);
// add_temp_log
// file ../src/common/log.c line 951
void add_temp_log(signed int min_severity);
// addr_mask_get_bits
// file ../src/common/address.c line 1739
signed int addr_mask_get_bits(unsigned int mask);
// addr_port_lookup
// file ../src/common/address.h line 262
signed int addr_port_lookup(signed int severity, const char *addrport, char **address, unsigned int *addr, unsigned short int *port_out);
// alert_sockets_close
// file ../src/common/compat_threads.c line 293
void alert_sockets_close(struct alert_sockets_s *socks);
// alert_sockets_create
// file ../src/common/compat_threads.c line 210
signed int alert_sockets_create(struct alert_sockets_s *socks_out, unsigned int flags);
// alloc_chunk
// file ../src/common/memarea.c line 118
static struct memarea_chunk_t * alloc_chunk(unsigned long int sz, signed int freelist_ok);
// alloc_getcwd
// file ../src/common/compat.c line 2111
static char * alloc_getcwd(void);
// append_bytes_to_file
// file ../src/common/util.c line 2532
signed int append_bytes_to_file(const char *fname, const char *str, unsigned long int len, signed int bin);
// approx_time
// file ../src/common/util.h line 288
signed long int approx_time(void);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// backtrace_symbols_fd
// file /usr/include/execinfo.h line 38
extern void backtrace_symbols_fd(void * const *, signed int, signed int);
// base16_decode
// file ../src/common/util.c line 1272
signed int base16_decode(char *dest, unsigned long int destlen, const char *src, unsigned long int srclen);
// base16_encode
// file ../src/common/util.c line 1217
void base16_encode(char *dest, unsigned long int destlen, const char *src, unsigned long int srclen);
// bitarray_free
// file ../src/common/container.h line 613
static inline void bitarray_free(unsigned int *ba);
// bitarray_init_zero
// file ../src/common/container.h line 586
static inline unsigned int * bitarray_init_zero(unsigned int n_bits);
// build_socks_resolve_request
// file ../src/tools/tor-resolve.c line 55
static signed long int build_socks_resolve_request(char **out, const char *username, const char *hostname, signed int reverse, signed int version);
// cached_getaddrinfo_item_free
// file ../src/common/sandbox.c line 1330
static void cached_getaddrinfo_item_free(struct cached_getaddrinfo_item_t *item);
// cached_getaddrinfo_item_hash
// file ../src/common/sandbox.c line 1317
static unsigned int cached_getaddrinfo_item_hash(const struct cached_getaddrinfo_item_t *item);
// cached_getaddrinfo_items_eq
// file ../src/common/sandbox.c line 1323
static unsigned int cached_getaddrinfo_items_eq(const struct cached_getaddrinfo_item_t *a, const struct cached_getaddrinfo_item_t *b);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// change_callback_log_severity
// file ../src/common/log.c line 987
void change_callback_log_severity(signed int loglevelMin, signed int loglevelMax, void (*cb)(signed int, unsigned int, const char *));
// change_callback_log_severity::cb_object
//
void cb_object(signed int, unsigned int, const char *);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_private_dir
// file ../src/common/util.c line 2109
signed int check_private_dir(const char *dirname, unsigned int check, const char *effective_user);
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 284
extern signed int chmod(const char *, unsigned int);
// chunk_free_unchecked
// file ../src/common/memarea.c line 147
static void chunk_free_unchecked(struct memarea_chunk_t *chunk);
// clean_backtrace
// file ../src/common/backtrace.c line 65
void clean_backtrace(void **stack, signed int depth, const struct ucontext *ctx);
// clean_name_for_stat
// file ../src/common/util.c line 2029
static void clean_name_for_stat(char *name);
// clean_up_backtrace_handler
// file ../src/common/backtrace.c line 228
void clean_up_backtrace_handler(void);
// clear_waitpid_callback
// file ../src/common/util_process.h line 21
void clear_waitpid_callback(struct waitpid_callback_t *ent);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_log
// file ../src/common/log.c line 860
static void close_log(struct logfile_t *victim);
// close_temp_logs
// file ../src/common/log.c line 1086
void close_temp_logs(void);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compare_digests256_
// file ../src/common/container.c line 996
static signed int compare_digests256_(const void **_a, const void **_b);
// compare_digests_
// file ../src/common/container.c line 974
static signed int compare_digests_(const void **_a, const void **_b);
// compare_ptrs_
// file ../src/common/container.c line 758
static signed int compare_ptrs_(const void **_a, const void **_b);
// compare_string_ptrs_
// file ../src/common/container.c line 718
static signed int compare_string_ptrs_(const void **_a, const void **_b);
// compute_num_cpus
// file ../src/common/compat.c line 2602
signed int compute_num_cpus(void);
// compute_num_cpus_impl
// file ../src/common/compat.c line 2548
static signed int compute_num_cpus_impl(void);
// configure_backtrace_handler
// file ../src/common/backtrace.c line 215
signed int configure_backtrace_handler(const char *tor_version);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// correct_tm
// file ../src/common/compat.c line 2674
static struct tm * correct_tm(signed int islocal, const signed long int *timep, struct tm *resultbuf, struct tm *r);
// crash_handler
// file ../src/common/backtrace.c line 120
static void crash_handler(signed int sig, struct anonymous_25 *si, void *ctx_);
// delete_log
// file ../src/common/log.c line 841
static void delete_log(struct logfile_t *victim);
// digest256map_assert_ok
// file ../src/common/container.c line 1367
void digest256map_assert_ok(const struct digest256map_t *map);
// digest256map_assign_key
// file ../src/common/container.c line 1146
static inline void digest256map_assign_key(struct digest256map_entry_t *ent, const unsigned char *key);
// digest256map_assign_tmp_key
// file ../src/common/container.c line 1131
static inline void digest256map_assign_tmp_key(struct digest256map_entry_t *ent, const unsigned char *key);
// digest256map_entries_eq
// file ../src/common/container.c line 1073
static inline signed int digest256map_entries_eq(const struct digest256map_entry_t *a, const struct digest256map_entry_t *b);
// digest256map_entry_free
// file ../src/common/container.c line 1115
static inline void digest256map_entry_free(struct digest256map_entry_t *ent);
// digest256map_entry_hash
// file ../src/common/container.c line 1081
static inline unsigned int digest256map_entry_hash(const struct digest256map_entry_t *a);
// digest256map_free
// file ../src/common/container.c line 1367
void digest256map_free(struct digest256map_t *map, void (*free_val)(void *));
// digest256map_free::free_val_object
//
void free_val_object(void *);
// digest256map_get
// file ../src/common/container.c line 1367
void * digest256map_get(const struct digest256map_t *map, const unsigned char *key);
// digest256map_impl_HT_CLEAR
// file ../src/common/container.c line 1099
void digest256map_impl_HT_CLEAR(struct digest256map_impl *head);
// digest256map_impl_HT_FIND
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t * digest256map_impl_HT_FIND(struct digest256map_impl *head, struct digest256map_entry_t *elm);
// digest256map_impl_HT_FIND_P_
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_FIND_P_(struct digest256map_impl *head, struct digest256map_entry_t *elm);
// digest256map_impl_HT_GROW
// file ../src/common/container.c line 1099
signed int digest256map_impl_HT_GROW(struct digest256map_impl *head, unsigned int size);
// digest256map_impl_HT_INIT
// file ../src/common/container.c line 1096
static inline void digest256map_impl_HT_INIT(struct digest256map_impl *head);
// digest256map_impl_HT_NEXT
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_NEXT(struct digest256map_impl *head, struct digest256map_entry_t **elm);
// digest256map_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_NEXT_RMV(struct digest256map_impl *head, struct digest256map_entry_t **elm);
// digest256map_impl_HT_REMOVE
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t * digest256map_impl_HT_REMOVE(struct digest256map_impl *head, struct digest256map_entry_t *elm);
// digest256map_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1099
signed int digest256map_impl_HT_REP_IS_BAD_(struct digest256map_impl *head);
// digest256map_impl_HT_START
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_START(struct digest256map_impl *head);
// digest256map_isempty
// file ../src/common/container.c line 1367
signed int digest256map_isempty(const struct digest256map_t *map);
// digest256map_iter_done
// file ../src/common/container.c line 1367
signed int digest256map_iter_done(struct digest256map_entry_t **iter);
// digest256map_iter_get
// file ../src/common/container.c line 1367
void digest256map_iter_get(struct digest256map_entry_t **iter, const unsigned char **keyp, void **valp);
// digest256map_iter_init
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_init(struct digest256map_t *map);
// digest256map_iter_next
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_next(struct digest256map_t *map, struct digest256map_entry_t **iter);
// digest256map_iter_next_rmv
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_next_rmv(struct digest256map_t *map, struct digest256map_entry_t **iter);
// digest256map_new
// file ../src/common/container.c line 1367
struct digest256map_t * digest256map_new(void);
// digest256map_remove
// file ../src/common/container.c line 1367
void * digest256map_remove(struct digest256map_t *map, const unsigned char *key);
// digest256map_set
// file ../src/common/container.c line 1367
void * digest256map_set(struct digest256map_t *map, const unsigned char *key, void *val);
// digest256map_size
// file ../src/common/container.c line 1367
signed int digest256map_size(const struct digest256map_t *map);
// digestmap_assert_ok
// file ../src/common/container.c line 1366
void digestmap_assert_ok(const struct digestmap_t *map);
// digestmap_assign_key
// file ../src/common/container.c line 1141
static inline void digestmap_assign_key(struct digestmap_entry_t *ent, const char *key);
// digestmap_assign_tmp_key
// file ../src/common/container.c line 1126
static inline void digestmap_assign_tmp_key(struct digestmap_entry_t *ent, const char *key);
// digestmap_entries_eq
// file ../src/common/container.c line 1059
static inline signed int digestmap_entries_eq(const struct digestmap_entry_t *a, const struct digestmap_entry_t *b);
// digestmap_entry_free
// file ../src/common/container.c line 1110
static inline void digestmap_entry_free(struct digestmap_entry_t *ent);
// digestmap_entry_hash
// file ../src/common/container.c line 1066
static inline unsigned int digestmap_entry_hash(const struct digestmap_entry_t *a);
// digestmap_free
// file ../src/common/container.c line 1366
void digestmap_free(struct digestmap_t *map, void (*free_val)(void *));
// digestmap_free::free_val_object
//
void free_val_object(void *);
// digestmap_get
// file ../src/common/container.c line 1366
void * digestmap_get(const struct digestmap_t *map, const char *key);
// digestmap_impl_HT_CLEAR
// file ../src/common/container.c line 1093
void digestmap_impl_HT_CLEAR(struct digestmap_impl *head);
// digestmap_impl_HT_FIND
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t * digestmap_impl_HT_FIND(struct digestmap_impl *head, struct digestmap_entry_t *elm);
// digestmap_impl_HT_FIND_P_
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_FIND_P_(struct digestmap_impl *head, struct digestmap_entry_t *elm);
// digestmap_impl_HT_GROW
// file ../src/common/container.c line 1093
signed int digestmap_impl_HT_GROW(struct digestmap_impl *head, unsigned int size);
// digestmap_impl_HT_INIT
// file ../src/common/container.c line 1091
static inline void digestmap_impl_HT_INIT(struct digestmap_impl *head);
// digestmap_impl_HT_NEXT
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_NEXT(struct digestmap_impl *head, struct digestmap_entry_t **elm);
// digestmap_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_NEXT_RMV(struct digestmap_impl *head, struct digestmap_entry_t **elm);
// digestmap_impl_HT_REMOVE
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t * digestmap_impl_HT_REMOVE(struct digestmap_impl *head, struct digestmap_entry_t *elm);
// digestmap_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1093
signed int digestmap_impl_HT_REP_IS_BAD_(struct digestmap_impl *head);
// digestmap_impl_HT_START
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_START(struct digestmap_impl *head);
// digestmap_isempty
// file ../src/common/container.c line 1366
signed int digestmap_isempty(const struct digestmap_t *map);
// digestmap_iter_done
// file ../src/common/container.c line 1366
signed int digestmap_iter_done(struct digestmap_entry_t **iter);
// digestmap_iter_get
// file ../src/common/container.c line 1366
void digestmap_iter_get(struct digestmap_entry_t **iter, const char **keyp, void **valp);
// digestmap_iter_init
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_init(struct digestmap_t *map);
// digestmap_iter_next
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_next(struct digestmap_t *map, struct digestmap_entry_t **iter);
// digestmap_iter_next_rmv
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_next_rmv(struct digestmap_t *map, struct digestmap_entry_t **iter);
// digestmap_new
// file ../src/common/container.c line 1366
struct digestmap_t * digestmap_new(void);
// digestmap_remove
// file ../src/common/container.c line 1366
void * digestmap_remove(struct digestmap_t *map, const char *key);
// digestmap_set
// file ../src/common/container.c line 1366
void * digestmap_set(struct digestmap_t *map, const char *key, void *val);
// digestmap_size
// file ../src/common/container.c line 1366
signed int digestmap_size(const struct digestmap_t *map);
// digestset_free
// file ../src/common/container.c line 1465
void digestset_free(struct anonymous_12 *set);
// digestset_new
// file ../src/common/container.c line 1444
struct anonymous_12 * digestset_new(signed int max_elements);
// digit_to_num
// file ../src/common/util.c line 3032
static signed int digit_to_num(char d);
// dimap_add_entry
// file ../src/common/di_ops.c line 164
void dimap_add_entry(struct di_digest256_map_t **map, const unsigned char *key, void *val);
// dimap_free
// file ../src/common/di_ops.c line 147
void dimap_free(struct di_digest256_map_t *map, void (*free_fn)(void *));
// dimap_free::free_fn_object
//
void free_fn_object(void *);
// dimap_search
// file ../src/common/di_ops.c line 188
void * dimap_search(const struct di_digest256_map_t *map, const unsigned char *key, void *dflt_val);
// do_resolve
// file ../src/tools/tor-resolve.c line 195
static signed int do_resolve(const char *hostname, unsigned int sockshost, unsigned short int socksport, signed int reverse, signed int version, struct tor_addr_t *result_addr, char **result_hostname);
// domain_to_string
// file ../src/common/log.c line 1243
static char * domain_to_string(unsigned int domain, char *buf, unsigned long int buflen);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// eat_whitespace
// file ../src/common/util.h line 224
const char * eat_whitespace(const char *s);
// eat_whitespace_eos
// file ../src/common/util.c line 815
const char * eat_whitespace_eos(const char *s, const char *eos);
// eat_whitespace_eos_no_nl
// file ../src/common/util.c line 853
const char * eat_whitespace_eos_no_nl(const char *s, const char *eos);
// eat_whitespace_no_nl
// file ../src/common/util.c line 843
const char * eat_whitespace_no_nl(const char *s);
// environment_variable_names_equal
// file ../src/common/util.c line 4477
signed int environment_variable_names_equal(const char *s1, const char *s2);
// esc_for_log
// file ../src/common/util.h line 241
char * esc_for_log(const char *s);
// esc_for_log_len
// file ../src/common/util.c line 1390
char * esc_for_log_len(const char *chars, unsigned long int n);
// escaped
// file ../src/common/util.h line 243
const char * escaped(const char *s);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(signed int, signed int);
// eventfd_alert
// file ../src/common/compat_threads.c line 139
static signed int eventfd_alert(signed int fd);
// eventfd_drain
// file ../src/common/compat_threads.c line 149
static signed int eventfd_drain(signed int fd);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expand_filename
// file ../src/common/util.c line 2973
char * expand_filename(const char *filename);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fast_memcmpstart
// file ../src/common/util.c line 765
signed int fast_memcmpstart(const void *mem, unsigned long int memlen, const char *prefix);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fdopen_file
// file ../src/common/util.c line 2360
struct _IO_FILE * fdopen_file(struct open_file_t *file_data);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream);
// file_status
// file ../src/common/util.c line 2055
enum anonymous_17 file_status(const char *fname);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_nth_double
// file ../src/common/container.c line 1436
double find_nth_double(double *array, signed int n_elements, signed int nth);
// find_nth_int
// file ../src/common/container.c line 1434
signed int find_nth_int(signed int *array, signed int n_elements, signed int nth);
// find_nth_int32
// file ../src/common/container.c line 1438
signed int find_nth_int32(signed int *array, signed int n_elements, signed int nth);
// find_nth_long
// file ../src/common/container.c line 1439
signed long int find_nth_long(signed long int *array, signed int n_elements, signed int nth);
// find_nth_time
// file ../src/common/container.c line 1435
signed long int find_nth_time(signed long int *array, signed int n_elements, signed int nth);
// find_nth_uint32
// file ../src/common/container.c line 1437
unsigned int find_nth_uint32(unsigned int *array, signed int n_elements, signed int nth);
// find_str_at_start_of_line
// file ../src/common/util.c line 911
const char * find_str_at_start_of_line(const char *haystack, const char *needle);
// find_whitespace
// file ../src/common/util.c line 864
const char * find_whitespace(const char *s);
// find_whitespace_eos
// file ../src/common/util.c line 886
const char * find_whitespace_eos(const char *s, const char *eos);
// finish_daemon
// file ../src/common/util.c line 3508
void finish_daemon(const char *desired_cwd);
// finish_writing_to_file
// file ../src/common/util.c line 2443
signed int finish_writing_to_file(struct open_file_t *file_data);
// finish_writing_to_file_impl
// file ../src/common/util.c line 2395
static signed int finish_writing_to_file_impl(struct open_file_t *file_data, signed int abort_write);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// flush_log_messages_from_startup
// file ../src/common/log.c line 1048
void flush_log_messages_from_startup(void);
// flush_pending_log_callbacks
// file ../src/common/log.c line 1006
void flush_pending_log_callbacks(void);
// fmt_addr32
// file ../src/common/address.c line 1126
const char * fmt_addr32(unsigned int addr);
// fmt_addr_impl
// file ../src/common/address.h line 190
const char * fmt_addr_impl(const struct tor_addr_t *addr, signed int decorate);
// fmt_addrport
// file ../src/common/address.c line 1114
const char * fmt_addrport(const struct tor_addr_t *addr, unsigned short int port);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_dec_number_sigsafe
// file ../src/common/util.h line 549
signed int format_dec_number_sigsafe(unsigned long int x, char *buf, signed int buf_len);
// format_helper_exit_status
// file ../src/common/util.c line 3793
static signed int format_helper_exit_status(unsigned char child_state, signed int saved_errno, char *hex_errno);
// format_hex_number_sigsafe
// file ../src/common/util.c line 3764
signed int format_hex_number_sigsafe(unsigned long int x, char *buf, signed int buf_len);
// format_iso_time
// file ../src/common/util.c line 1703
void format_iso_time(char *buf, signed long int t);
// format_iso_time_nospace
// file ../src/common/util.c line 1712
void format_iso_time_nospace(char *buf, signed long int t);
// format_iso_time_nospace_usec
// file ../src/common/util.c line 1722
void format_iso_time_nospace_usec(char *buf, struct timeval *tv);
// format_local_iso_time
// file ../src/common/util.c line 1693
void format_local_iso_time(char *buf, signed long int t);
// format_msg
// file ../src/common/log.c line 272
static inline char * format_msg(char *buf, unsigned long int buf_len, unsigned int domain, signed int severity, const char *funcname, const char *suffix, const char *format, void **ap, unsigned long int *msg_len_out);
// format_number_sigsafe
// file ../src/common/util.c line 3700
static signed int format_number_sigsafe(unsigned long int x, char *buf, signed int buf_len, unsigned int radix);
// format_rfc1123_time
// file ../src/common/util.c line 1595
void format_rfc1123_time(char *buf, signed long int t);
// format_time_interval
// file ../src/common/util.c line 1855
signed int format_time_interval(char *out, unsigned long int out_len, signed long int interval);
// format_win_cmdline_argument
// file ../src/common/util.c line 3600
static char * format_win_cmdline_argument(const char *arg);
// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...);
// fprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link1(struct _IO_FILE * restrict __stream_link1, const char * restrict __fmt_link1, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat(signed int __fd, struct stat *__statbuf);
// fstat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat_link1(signed int __fd_link1, struct stat *__statbuf_link1);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// get_current_process_environment_variables
// file ../src/common/util.c line 4596
struct smartlist_t * get_current_process_environment_variables(void);
// get_environment
// file ../src/common/compat.c line 2188
char ** get_environment(void);
// get_interface_address
// file ../src/common/address.c line 1841
signed int get_interface_address(signed int severity, unsigned int *addr);
// get_interface_address6
// file ../src/common/address.c line 1511
signed int get_interface_address6(signed int severity, unsigned short int family, struct tor_addr_t *addr);
// get_interface_addresses_ifaddrs
// file ../src/common/address.c line 1263
static struct smartlist_t * get_interface_addresses_ifaddrs(signed int severity);
// get_interface_addresses_ioctl
// file ../src/common/address.c line 1426
static struct smartlist_t * get_interface_addresses_ioctl(signed int severity);
// get_interface_addresses_raw
// file ../src/common/address.c line 1471
static struct smartlist_t * get_interface_addresses_raw(signed int severity);
// get_min_log_level
// file ../src/common/log.c line 1401
signed int get_min_log_level(void);
// get_n_open_sockets
// file ../src/common/compat.c line 1302
signed int get_n_open_sockets(void);
// get_parent_directory
// file ../src/common/compat.c line 2063
signed int get_parent_directory(char *fname);
// get_string_from_pipe
// file ../src/common/util.c line 5047
enum stream_status get_string_from_pipe(struct _IO_FILE *stream, char *buf_out, unsigned long int count);
// get_syscall_name
// file ../src/common/sandbox.c line 1568
static const char * get_syscall_name(signed int syscall_num);
// get_total_system_memory
// file ../src/common/compat.c line 3179
signed int get_total_system_memory(unsigned long int *mem_out);
// get_total_system_memory_impl
// file ../src/common/compat.c line 3106
static unsigned long int get_total_system_memory_impl(void);
// get_uint16
// file ../src/common/compat.h line 616
unsigned short int get_uint16(const void *cp);
// get_uint32
// file ../src/common/compat.h line 617
unsigned int get_uint32(const void *cp);
// get_uint64
// file ../src/common/compat.c line 773
unsigned long int get_uint64(const void *cp);
// get_uname
// file ../src/common/compat.c line 2459
const char * get_uname(void);
// get_user_homedir
// file ../src/common/compat.c line 2035
char * get_user_homedir(const char *username);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getaddrinfo_cache_HT_CLEAR
// file ../src/common/sandbox.c line 1347
void getaddrinfo_cache_HT_CLEAR(struct getaddrinfo_cache *head);
// getaddrinfo_cache_HT_FIND
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t * getaddrinfo_cache_HT_FIND(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm);
// getaddrinfo_cache_HT_FIND_P_
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_FIND_P_(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm);
// getaddrinfo_cache_HT_GROW
// file ../src/common/sandbox.c line 1347
signed int getaddrinfo_cache_HT_GROW(struct getaddrinfo_cache *head, unsigned int size);
// getaddrinfo_cache_HT_INIT
// file ../src/common/sandbox.c line 1344
static inline void getaddrinfo_cache_HT_INIT(struct getaddrinfo_cache *head);
// getaddrinfo_cache_HT_INSERT
// file ../src/common/sandbox.c line 1344
static inline void getaddrinfo_cache_HT_INSERT(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm);
// getaddrinfo_cache_HT_NEXT_RMV
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_NEXT_RMV(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t **elm);
// getaddrinfo_cache_HT_REP_IS_BAD_
// file ../src/common/sandbox.c line 1347
signed int getaddrinfo_cache_HT_REP_IS_BAD_(struct getaddrinfo_cache *head);
// getaddrinfo_cache_HT_START
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_START(struct getaddrinfo_cache *head);
// getcwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 200
static inline char * getcwd(char *__buf, unsigned long int __size);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getgrgid
// file /usr/include/grp.h line 105
extern struct group * getgrgid(unsigned int);
// getgroups
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 265
static inline signed int getgroups(signed int __size, unsigned int *__list);
// gethostname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 344
static inline signed int gethostname(char *__buf, unsigned long int __buflen);
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getresgid
// file /usr/include/unistd.h line 738
extern signed int getresgid(unsigned int *, unsigned int *, unsigned int *);
// getresuid
// file /usr/include/unistd.h line 733
extern signed int getresuid(unsigned int *, unsigned int *, unsigned int *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// handle_fw_helper_line
// file ../src/common/util.c line 5098
static void handle_fw_helper_line(const char *executable, const char *line);
// handle_fw_helper_output
// file ../src/common/util.c line 5201
static signed int handle_fw_helper_output(const char *executable, struct process_handle_t *process_handle);
// hex_decode_digit
// file ../src/common/util.h line 260
signed int hex_decode_digit(char c);
// hex_decode_digit_
// file ../src/common/util.c line 1237
static inline signed int hex_decode_digit_(char c);
// hex_str
// file ../src/common/util.c line 623
const char * hex_str(const char *from, unsigned long int fromlen);
// ifaddrs_to_smartlist
// file ../src/common/address.c line 1236
static struct smartlist_t * ifaddrs_to_smartlist(struct ifaddrs *ifa);
// ifreq_to_smartlist
// file ../src/common/address.c line 1390
static struct smartlist_t * ifreq_to_smartlist(char *buf, unsigned long int buflen);
// in_main_thread
// file ../src/common/compat_threads.c line 85
signed int in_main_thread(void);
// init_logging
// file ../src/tools/../common/torlog.h line 126
void init_logging(signed int disable_startup_queue);
// initialise_libseccomp_sandbox
// file ../src/common/sandbox.c line 1703
static signed int initialise_libseccomp_sandbox(struct sandbox_cfg_elem *cfg);
// install_bt_handler
// file ../src/common/backtrace.c line 150
static signed int install_bt_handler(void);
// install_sigsys_debugging
// file ../src/common/sandbox.c line 1648
static signed int install_sigsys_debugging(void);
// install_syscall_filter
// file ../src/common/sandbox.c line 1522
static signed int install_syscall_filter(struct sandbox_cfg_elem *cfg);
// int_array_contains
// file ../src/common/log.c line 583
static signed int int_array_contains(const signed int *array, signed int n, signed int item);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// labs
// file /usr/include/stdlib.h line 776
extern signed long int labs(signed long int);
// libor_get_digests
// file ../src/common/util_codedigest.c line 7
const char * libor_get_digests(void);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_backtrace
// file ../src/common/backtrace.c line 90
void log_backtrace(signed int severity, signed int domain, const char *msg);
// log_credential_status
// file ../src/common/compat.c line 1643
static signed int log_credential_status(void);
// log_fn_
// file ../src/tools/../common/torlog.h line 170
void log_fn_(signed int severity, unsigned int domain, const char *fn, const char *format, ...);
// log_fn_ratelim_
// file ../src/common/log.c line 675
void log_fn_ratelim_(struct ratelim_t *ratelim, signed int severity, unsigned int domain, const char *fn, const char *format, ...);
// log_free
// file ../src/common/log.c line 785
static void log_free(struct logfile_t *victim);
// log_from_pipe
// file ../src/common/util.c line 4999
static signed int log_from_pipe(struct _IO_FILE *stream, signed int severity, const char *executable, signed int *child_status);
// log_level_to_string
// file ../src/common/log.c line 1214
const char * log_level_to_string(signed int level);
// log_portfw_spawn_error_message
// file ../src/common/util.c line 4851
static void log_portfw_spawn_error_message(const char *buf, const char *executable, signed int *child_status);
// log_prefix_
// file ../src/common/log.c line 200
static inline unsigned long int log_prefix_(char *buf, unsigned long int buf_len, signed int severity);
// log_set_application_name
// file ../src/common/log.c line 179
void log_set_application_name(const char *name);
// log_tor_version
// file ../src/common/log.c line 234
static signed int log_tor_version(struct logfile_t *lf, signed int reset);
// logfile_deliver
// file ../src/common/log.c line 401
static inline void logfile_deliver(struct logfile_t *lf, const char *buf, unsigned long int msg_len, const char *msg_after_prefix, unsigned int domain, signed int severity, signed int *callbacks_deferred);
// logfile_wants_message
// file ../src/common/log.c line 378
static inline signed int logfile_wants_message(const struct logfile_t *lf, signed int severity, unsigned int domain);
// logs_free_all
// file ../src/common/log.c line 796
void logs_free_all(void);
// logs_set_domain_logging
// file ../src/common/log.c line 940
void logs_set_domain_logging(signed int enabled);
// logv
// file ../src/common/log.c line 450
static void logv(signed int severity, unsigned int domain, const char *funcname, const char *suffix, const char *format, void **ap);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// make_path_absolute
// file ../src/common/compat.c line 2141
char * make_path_absolute(char *fname);
// mallinfo
// file /usr/include/malloc.h line 94
extern struct mallinfo mallinfo(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mark_logs_temp
// file ../src/common/log.c line 1122
void mark_logs_temp(void);
// memarea_alloc
// file ../src/common/memarea.c line 231
void * memarea_alloc(struct memarea_t *area, unsigned long int sz);
// memarea_alloc_zero
// file ../src/common/memarea.c line 267
void * memarea_alloc_zero(struct memarea_t *area, unsigned long int sz);
// memarea_assert_ok
// file ../src/common/memarea.c line 324
void memarea_assert_ok(struct memarea_t *area);
// memarea_clear
// file ../src/common/memarea.c line 187
void memarea_clear(struct memarea_t *area);
// memarea_clear_freelist
// file ../src/common/memarea.c line 202
void memarea_clear_freelist(void);
// memarea_drop_all
// file ../src/common/memarea.c line 172
void memarea_drop_all(struct memarea_t *area);
// memarea_get_stats
// file ../src/common/memarea.c line 308
void memarea_get_stats(struct memarea_t *area, unsigned long int *allocated_out, unsigned long int *used_out);
// memarea_memdup
// file ../src/common/memarea.c line 276
void * memarea_memdup(struct memarea_t *area, const void *s, unsigned long int n);
// memarea_new
// file ../src/common/memarea.c line 162
struct memarea_t * memarea_new(void);
// memarea_owns_ptr
// file ../src/common/memarea.c line 216
signed int memarea_owns_ptr(const struct memarea_t *area, const void *p);
// memarea_strdup
// file ../src/common/memarea.c line 285
char * memarea_strdup(struct memarea_t *area, const char *s);
// memarea_strndup
// file ../src/common/memarea.c line 292
char * memarea_strndup(struct memarea_t *area, const char *s, unsigned long int n);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len);
// memcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link1(void * restrict __dest_link1, const void * restrict __src_link1, unsigned long int __len_link1);
// memcpy_link10
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link10(void * restrict __dest_link10, const void * restrict __src_link10, unsigned long int __len_link10);
// memcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link2(void * restrict __dest_link2, const void * restrict __src_link2, unsigned long int __len_link2);
// memcpy_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link3(void * restrict __dest_link3, const void * restrict __src_link3, unsigned long int __len_link3);
// memcpy_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link4(void * restrict __dest_link4, const void * restrict __src_link4, unsigned long int __len_link4);
// memcpy_link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link5(void * restrict __dest_link5, const void * restrict __src_link5, unsigned long int __len_link5);
// memcpy_link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link6(void * restrict __dest_link6, const void * restrict __src_link6, unsigned long int __len_link6);
// memcpy_link7
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link7(void * restrict __dest_link7, const void * restrict __src_link7, unsigned long int __len_link7);
// memcpy_link8
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link8(void * restrict __dest_link8, const void * restrict __src_link8, unsigned long int __len_link8);
// memcpy_link9
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link9(void * restrict __dest_link9, const void * restrict __src_link9, unsigned long int __len_link9);
// memmem
// file /usr/include/string.h line 382
extern void * memmem(const void *, unsigned long int, const void *, unsigned long int);
// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len);
// memmove_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
static inline void * memmove_link1(void *__dest_link1, const void *__src_link1, unsigned long int __len_link1);
// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len);
// memset_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link1(void *__dest_link1, signed int __ch_link1, unsigned long int __len_link1);
// memset_link10
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link10(void *__dest_link10, signed int __ch_link10, unsigned long int __len_link10);
// memset_link11
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link11(void *__dest_link11, signed int __ch_link11, unsigned long int __len_link11);
// memset_link12
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link12(void *__dest_link12, signed int __ch_link12, unsigned long int __len_link12);
// memset_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link2(void *__dest_link2, signed int __ch_link2, unsigned long int __len_link2);
// memset_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link3(void *__dest_link3, signed int __ch_link3, unsigned long int __len_link3);
// memset_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link4(void *__dest_link4, signed int __ch_link4, unsigned long int __len_link4);
// memset_link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link5(void *__dest_link5, signed int __ch_link5, unsigned long int __len_link5);
// memset_link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link6(void *__dest_link6, signed int __ch_link6, unsigned long int __len_link6);
// memset_link7
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link7(void *__dest_link7, signed int __ch_link7, unsigned long int __len_link7);
// memset_link8
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link8(void *__dest_link8, signed int __ch_link8, unsigned long int __len_link8);
// memset_link9
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link9(void *__dest_link9, signed int __ch_link9, unsigned long int __len_link9);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// mlockall
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 111
extern signed int mlockall(signed int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mprotect
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 81
extern signed int mprotect(void *, unsigned long int, signed int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// n_bits_set_u8
// file ../src/common/util.c line 573
signed int n_bits_set_u8(unsigned char v);
// n_leapdays
// file ../src/common/util.c line 1514
static signed int n_leapdays(signed int y1, signed int y2);
// network_init
// file ../src/common/compat.h line 551
signed int network_init(void);
// new_element
// file ../src/common/sandbox.c line 1199
static struct sandbox_cfg_elem * new_element(signed int syscall, char *value);
// new_element2
// file ../src/common/sandbox.c line 1183
static struct sandbox_cfg_elem * new_element2(signed int syscall, char *value, char *value2);
// notify_pending_waitpid_callbacks
// file ../src/common/util_process.c line 144
void notify_pending_waitpid_callbacks(void);
// notify_waitpid_callback_by_pid
// file ../src/common/util_process.c line 122
static void notify_waitpid_callback_by_pid(signed int pid, signed int status);
// onion_warning
// file ../src/tools/tor-resolve.c line 112
static void onion_warning(const char *hostname);
// open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open(const char *__path, signed int __oflag, ...);
// open_link1
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open_link1(const char *__path_link1, signed int __oflag_link1, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_config_line_from_str_verbose
// file ../src/common/util.c line 2822
const char * parse_config_line_from_str_verbose(const char *line, char **key_out, char **value_out, const char **err_out);
// parse_http_time
// file ../src/common/util.c line 1784
signed int parse_http_time(const char *date, struct tm *tm);
// parse_iso_time
// file ../src/common/util.c line 1776
signed int parse_iso_time(const char *cp, signed long int *t);
// parse_iso_time_
// file ../src/common/util.c line 1734
signed int parse_iso_time_(const char *cp, signed long int *t, signed int strict);
// parse_log_domain
// file ../src/common/log.c line 1231
static unsigned int parse_log_domain(const char *domain);
// parse_log_level
// file ../src/common/log.c line 1197
signed int parse_log_level(const char *level);
// parse_log_severity_config
// file ../src/common/log.c line 1295
signed int parse_log_severity_config(const char **cfg_ptr, struct log_severity_list_t *severity_out);
// parse_port_range
// file ../src/common/address.c line 1758
signed int parse_port_range(const char *port, unsigned short int *port_min_out, unsigned short int *port_max_out);
// parse_rfc1123_time
// file ../src/common/util.c line 1619
signed int parse_rfc1123_time(const char *buf, signed long int *t);
// parse_socks4a_resolve_response
// file ../src/tools/tor-resolve.c line 128
static signed int parse_socks4a_resolve_response(const char *hostname, const char *response, unsigned long int len, struct tor_addr_t *addr_out);
// path_is_relative
// file ../src/common/util.c line 3417
signed int path_is_relative(const char *filename);
// pending_log_message_free
// file ../src/common/log.c line 365
static void pending_log_message_free(struct pending_log_message_t *msg);
// pending_log_message_new
// file ../src/common/log.c line 352
static struct pending_log_message_t * pending_log_message_new(signed int severity, unsigned int domain, const char *fullmsg, const char *shortmsg);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pipe2
// file /usr/include/unistd.h line 422
extern signed int pipe2(signed int *, signed int);
// pipe_alert
// file ../src/common/compat_threads.c line 161
static signed int pipe_alert(signed int fd);
// pipe_drain
// file ../src/common/compat_threads.c line 170
static signed int pipe_drain(signed int fd);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...);
// process_environment_free
// file ../src/common/util.c line 4489
void process_environment_free(struct process_environment_t *env);
// process_environment_make
// file ../src/common/util.c line 4508
struct process_environment_t * process_environment_make(struct smartlist_t *env_vars);
// process_handle_new
// file ../src/common/util.c line 3947
static struct process_handle_t * process_handle_new(void);
// process_handle_waitpid_cb
// file ../src/common/util.c line 3967
static void process_handle_waitpid_cb(signed int status, void *arg);
// process_map_HT_CLEAR
// file ../src/common/util_process.c line 65
void process_map_HT_CLEAR(struct process_map *head);
// process_map_HT_FIND_P_
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t ** process_map_HT_FIND_P_(struct process_map *head, struct waitpid_callback_t *elm);
// process_map_HT_GROW
// file ../src/common/util_process.c line 65
signed int process_map_HT_GROW(struct process_map *head, unsigned int size);
// process_map_HT_INIT
// file ../src/common/util_process.c line 63
static inline void process_map_HT_INIT(struct process_map *head);
// process_map_HT_REMOVE
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t * process_map_HT_REMOVE(struct process_map *head, struct waitpid_callback_t *elm);
// process_map_HT_REPLACE
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t * process_map_HT_REPLACE(struct process_map *head, struct waitpid_callback_t *elm);
// process_map_HT_REP_IS_BAD_
// file ../src/common/util_process.c line 65
signed int process_map_HT_REP_IS_BAD_(struct process_map *head);
// process_map_entries_eq_
// file ../src/common/util_process.c line 55
static inline unsigned int process_map_entries_eq_(const struct waitpid_callback_t *a, const struct waitpid_callback_t *b);
// process_map_entry_hash_
// file ../src/common/util_process.c line 49
static inline unsigned int process_map_entry_hash_(const struct waitpid_callback_t *ent);
// prot_strings
// file ../src/common/sandbox.c line 1070
static signed int prot_strings(void *ctx, struct sandbox_cfg_elem *cfg);
// prot_strings_helper
// file ../src/common/sandbox.c line 1021
static signed int prot_strings_helper(struct strmap_t *locations, char **pr_mem_next_p, unsigned long int *pr_mem_left_p, char **value_p);
// pthread_attr_init
// file /usr/include/pthread.h line 298
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 310
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous_8 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 984
extern signed int pthread_cond_destroy(union anonymous_8 *);
// pthread_cond_init
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_init(union anonymous_8 *, const union anonymous_7 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 988
extern signed int pthread_cond_signal(union anonymous_8 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1011
extern signed int pthread_cond_timedwait(union anonymous_8 *, union anonymous_29 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous_8 *, union anonymous_29 *);
// pthread_condattr_init
// file /usr/include/pthread.h line 1019
extern signed int pthread_condattr_init(union anonymous_7 *);
// pthread_condattr_setclock
// file /usr/include/pthread.h line 1044
extern signed int pthread_condattr_setclock(union anonymous_7 *, signed int);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 253
extern void pthread_exit(void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 765
extern signed int pthread_mutex_destroy(union anonymous_29 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_init(union anonymous_29 *, const union anonymous_7 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous_29 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous_29 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 817
extern signed int pthread_mutexattr_init(union anonymous_7 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 844
extern signed int pthread_mutexattr_settype(union anonymous_7 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 286
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_27 *, struct anonymous_27 *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// qsort
// file /usr/include/stdlib.h line 765
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// queue_reply
// file ../src/common/workqueue.c line 231
static void queue_reply(struct replyqueue_s *queue, struct workqueue_entry_s *work);
// rate_limit_is_ready
// file ../src/common/util.c line 1931
static signed int rate_limit_is_ready(struct ratelim_t *lim, signed long int now);
// rate_limit_log
// file ../src/common/util.h line 326
char * rate_limit_log(struct ratelim_t *lim, signed long int now);
// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes);
// read_link1
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __nbytes_link1);
// read_all
// file ../src/tools/../common/util.h line 330
signed long int read_all(signed int fd, char *buf, unsigned long int count, signed int isSocket);
// read_file_to_str
// file ../src/common/util.c line 2609
char * read_file_to_str(const char *filename, signed int flags, struct stat *stat_out);
// read_file_to_str_until_eof
// file ../src/common/util.h line 399
char * read_file_to_str_until_eof(signed int fd, unsigned long int max_bytes_to_read, unsigned long int *sz_out);
// read_ni
// file ../src/common/compat_threads.c line 103
static signed int read_ni(signed int fd, void *buf, unsigned long int n);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realign_pointer
// file ../src/common/memarea.c line 65
static inline void * realign_pointer(void *ptr);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 34
static inline signed long int recv(signed int __fd, void *__buf, unsigned long int __n, signed int __flags);
// recv_link1
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 34
static inline signed long int recv_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __n_link1, signed int __flags_link1);
// recv_ni
// file ../src/common/compat_threads.c line 127
static signed int recv_ni(signed int fd, void *buf, unsigned long int n, signed int flags);
// register_cfg
// file ../src/common/sandbox.c line 1678
static signed int register_cfg(struct sandbox_cfg_elem *cfg);
// remove_bt_handler
// file ../src/common/backtrace.c line 188
static void remove_bt_handler(void);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// replace_file
// file ../src/common/compat.c line 815
signed int replace_file(const char *from, const char *to);
// replyqueue_get_socket
// file ../src/common/workqueue.c line 460
signed int replyqueue_get_socket(struct replyqueue_s *rq);
// replyqueue_new
// file ../src/common/workqueue.c line 438
struct replyqueue_s * replyqueue_new(unsigned int alertsocks_flags);
// replyqueue_process
// file ../src/common/workqueue.c line 471
void replyqueue_process(struct replyqueue_s *queue);
// rollback_log_changes
// file ../src/common/log.c line 1110
void rollback_log_changes(void);
// round_int64_to_next_multiple_of
// file ../src/common/util.c line 519
signed long int round_int64_to_next_multiple_of(signed long int number, signed long int divisor);
// round_to_next_multiple_of
// file ../src/common/util.c line 489
unsigned int round_to_next_multiple_of(unsigned int number, unsigned int divisor);
// round_to_power_of_2
// file ../src/common/util.c line 465
unsigned long int round_to_power_of_2(unsigned long int u64);
// round_uint32_to_next_multiple_of
// file ../src/common/util.c line 499
unsigned int round_uint32_to_next_multiple_of(unsigned int number, unsigned int divisor);
// round_uint64_to_next_multiple_of
// file ../src/common/util.c line 509
unsigned long int round_uint64_to_next_multiple_of(unsigned long int number, unsigned long int divisor);
// safe_mem_is_zero
// file ../src/common/di_ops.c line 212
signed int safe_mem_is_zero(const void *mem, unsigned long int sz);
// sample_laplace_distribution
// file ../src/common/util.c line 533
signed long int sample_laplace_distribution(double mu, double b, double p);
// sandbox_add_addrinfo
// file ../src/common/sandbox.c line 1435
signed int sandbox_add_addrinfo(const char *name);
// sandbox_cfg_allow_open_filename
// file ../src/common/sandbox.c line 1228
signed int sandbox_cfg_allow_open_filename(struct sandbox_cfg_elem **cfg, char *file);
// sandbox_cfg_allow_openat_filename
// file ../src/common/sandbox.c line 1263
signed int sandbox_cfg_allow_openat_filename(struct sandbox_cfg_elem **cfg, char *file);
// sandbox_cfg_allow_rename
// file ../src/common/sandbox.c line 1245
signed int sandbox_cfg_allow_rename(struct sandbox_cfg_elem **cfg, char *file1, char *file2);
// sandbox_cfg_allow_stat_filename
// file ../src/common/sandbox.c line 1211
signed int sandbox_cfg_allow_stat_filename(struct sandbox_cfg_elem **cfg, char *file);
// sandbox_cfg_new
// file ../src/common/sandbox.c line 1728
struct sandbox_cfg_elem * sandbox_cfg_new(void);
// sandbox_disable_getaddrinfo_cache
// file ../src/common/sandbox.h line 179
void sandbox_disable_getaddrinfo_cache(void);
// sandbox_free_getaddrinfo_cache
// file ../src/common/sandbox.c line 1457
void sandbox_free_getaddrinfo_cache(void);
// sandbox_freeaddrinfo
// file ../src/common/sandbox.h line 118
void sandbox_freeaddrinfo(struct addrinfo *ai);
// sandbox_getaddrinfo
// file ../src/common/sandbox.h line 115
signed int sandbox_getaddrinfo(const char *name, const char *servname, struct addrinfo *hints, struct addrinfo **res);
// sandbox_init
// file ../src/common/sandbox.c line 1734
signed int sandbox_init(struct sandbox_cfg_elem *cfg);
// sandbox_intern_string
// file ../src/common/sandbox.h line 134
const char * sandbox_intern_string(const char *str);
// sandbox_is_active
// file ../src/common/sandbox.c line 1721
signed int sandbox_is_active(void);
// sb__sysctl
// file ../src/common/sandbox.c line 437
static signed int sb__sysctl(void *ctx, struct sandbox_cfg_elem *filter);
// sb_accept4
// file ../src/common/sandbox.c line 313
static signed int sb_accept4(void *ctx, struct sandbox_cfg_elem *filter);
// sb_epoll_ctl
// file ../src/common/sandbox.c line 736
static signed int sb_epoll_ctl(void *ctx, struct sandbox_cfg_elem *filter);
// sb_fcntl64
// file ../src/common/sandbox.c line 698
static signed int sb_fcntl64(void *ctx, struct sandbox_cfg_elem *filter);
// sb_flock
// file ../src/common/sandbox.c line 836
static signed int sb_flock(void *ctx, struct sandbox_cfg_elem *filter);
// sb_futex
// file ../src/common/sandbox.c line 859
static signed int sb_futex(void *ctx, struct sandbox_cfg_elem *filter);
// sb_getsockopt
// file ../src/common/sandbox.c line 656
static signed int sb_getsockopt(void *ctx, struct sandbox_cfg_elem *filter);
// sb_mmap2
// file ../src/common/sandbox.c line 341
static signed int sb_mmap2(void *ctx, struct sandbox_cfg_elem *filter);
// sb_mprotect
// file ../src/common/sandbox.c line 788
static signed int sb_mprotect(void *ctx, struct sandbox_cfg_elem *filter);
// sb_mremap
// file ../src/common/sandbox.c line 891
static signed int sb_mremap(void *ctx, struct sandbox_cfg_elem *filter);
// sb_open
// file ../src/common/sandbox.c line 404
static signed int sb_open(void *ctx, struct sandbox_cfg_elem *filter);
// sb_openat
// file ../src/common/sandbox.c line 489
static signed int sb_openat(void *ctx, struct sandbox_cfg_elem *filter);
// sb_poll
// file ../src/common/sandbox.c line 909
static signed int sb_poll(void *ctx, struct sandbox_cfg_elem *filter);
// sb_prctl
// file ../src/common/sandbox.c line 767
static signed int sb_prctl(void *ctx, struct sandbox_cfg_elem *filter);
// sb_rename
// file ../src/common/sandbox.c line 458
static signed int sb_rename(void *ctx, struct sandbox_cfg_elem *filter);
// sb_rt_sigaction
// file ../src/common/sandbox.c line 240
static signed int sb_rt_sigaction(void *ctx, struct sandbox_cfg_elem *filter);
// sb_rt_sigprocmask
// file ../src/common/sandbox.c line 811
static signed int sb_rt_sigprocmask(void *ctx, struct sandbox_cfg_elem *filter);
// sb_setsockopt
// file ../src/common/sandbox.c line 611
static signed int sb_setsockopt(void *ctx, struct sandbox_cfg_elem *filter);
// sb_socket
// file ../src/common/sandbox.c line 521
static signed int sb_socket(void *ctx, struct sandbox_cfg_elem *filter);
// sb_socketpair
// file ../src/common/sandbox.c line 586
static signed int sb_socketpair(void *ctx, struct sandbox_cfg_elem *filter);
// sb_stat64
// file ../src/common/sandbox.c line 929
static signed int sb_stat64(void *ctx, struct sandbox_cfg_elem *filter);
// sb_time
// file ../src/common/sandbox.c line 297
static signed int sb_time(void *ctx, struct sandbox_cfg_elem *filter);
// scan_double
// file ../src/common/util.c line 3125
static signed int scan_double(const char **bufp, double *out, signed int width);
// scan_signed
// file ../src/common/util.c line 3081
static signed int scan_signed(const char **bufp, signed long int *out, signed int width);
// scan_string
// file ../src/common/util.c line 3170
static signed int scan_string(const char **bufp, char *out, signed int width);
// scan_unsigned
// file ../src/common/util.c line 3044
static signed int scan_unsigned(const char **bufp, unsigned long int *out, signed int width, signed int base);
// seccomp_init
// file /usr/include/seccomp.h line 248
void * seccomp_init(unsigned int);
// seccomp_load
// file /usr/include/seccomp.h line 360
signed int seccomp_load(void *);
// seccomp_release
// file /usr/include/seccomp.h line 273
void seccomp_release(void *);
// seccomp_rule_add
// file /usr/include/seccomp.h line 467
signed int seccomp_rule_add(void *, unsigned int, signed int, unsigned int, ...);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_ni
// file ../src/common/compat_threads.c line 116
static signed int send_ni(signed int fd, const void *buf, unsigned long int n, signed int flags);
// set_environment_variable_in_smartlist
// file ../src/common/util.c line 4613
void set_environment_variable_in_smartlist(struct smartlist_t *env_vars, const char *new_var, void (*free_old)(void *), signed int free_p);
// set_environment_variable_in_smartlist::free_old_object
//
void free_old_object(void *);
// set_log_severity_config
// file ../src/tools/../common/torlog.h line 131
void set_log_severity_config(signed int loglevelMin, signed int loglevelMax, struct log_severity_list_t *severity_out);
// set_log_time_granularity
// file ../src/common/log.c line 191
void set_log_time_granularity(signed int granularity_msec);
// set_main_thread
// file ../src/common/compat_threads.c line 79
void set_main_thread(void);
// set_max_file_descriptors
// file ../src/common/compat.c line 1538
signed int set_max_file_descriptors(unsigned long int limit, signed int *max_out);
// set_socket_nonblocking
// file ../src/common/compat.c line 1315
signed int set_socket_nonblocking(signed int socket);
// set_uint16
// file ../src/common/compat.h line 619
void set_uint16(void *cp, unsigned short int v);
// set_uint32
// file ../src/common/compat.h line 620
void set_uint32(void *cp, unsigned int v);
// set_uint64
// file ../src/common/compat.c line 803
void set_uint64(void *cp, unsigned long int v);
// set_waitpid_callback
// file ../src/common/util_process.h line 19
struct waitpid_callback_t * set_waitpid_callback(signed int pid, void (*fn)(signed int, void *), void *arg);
// set_waitpid_callback::fn_object
//
void fn_object(signed int, void *);
// setegid
// file /usr/include/unistd.h line 727
extern signed int setegid(unsigned int);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 180
extern signed int setgroups(unsigned long int, const unsigned int *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sev_to_string
// file ../src/common/log.c line 68
static inline const char * sev_to_string(signed int severity);
// should_log_function_name
// file ../src/common/log.c line 84
static inline signed int should_log_function_name(unsigned int domain, signed int severity);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_27 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_27 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_27 *);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_27 *, struct anonymous_27 *);
// sigsys_debugging
// file ../src/common/sandbox.c line 1595
static void sigsys_debugging(signed int nr, struct anonymous_25 *info, void *void_context);
// siphash24
// file ../src/ext/csiphash.c line 99
unsigned long int siphash24(const void *src, unsigned long int src_sz, struct sipkey *key);
// siphash24g
// file ../src/ext/siphash.h line 11
unsigned long int siphash24g(const void *src, unsigned long int src_sz);
// siphash_set_global_key
// file ../src/ext/csiphash.c line 170
void siphash_set_global_key(struct sipkey *key);
// size_mul_check
// file ../src/common/util.c line 207
static inline signed int size_mul_check(const unsigned long int x, const unsigned long int y);
// smartlist_add
// file ../src/common/container.h line 33
void smartlist_add(struct smartlist_t *sl, void *element);
// smartlist_add_all
// file ../src/common/container.c line 103
void smartlist_add_all(struct smartlist_t *s1, const struct smartlist_t *s2);
// smartlist_add_asprintf
// file ../src/common/util.h line 254
void smartlist_add_asprintf(struct smartlist_t *sl, const char *pattern, ...);
// smartlist_add_vasprintf
// file ../src/common/util.c line 3338
void smartlist_add_vasprintf(struct smartlist_t *sl, const char *pattern, void **args);
// smartlist_bsearch
// file ../src/common/container.c line 588
void * smartlist_bsearch(struct smartlist_t *sl, const void *key, signed int (*compare)(const void *, const void **));
// smartlist_bsearch::compare_object
//
signed int compare_object(const void *, const void **);
// smartlist_bsearch_idx
// file ../src/common/container.c line 605
signed int smartlist_bsearch_idx(const struct smartlist_t *sl, const void *key, signed int (*compare)(const void *, const void **), signed int *found_out);
// smartlist_bsearch_idx::compare_object
//
signed int compare_object(const void *, const void **);
// smartlist_clear
// file ../src/common/container.c line 56
void smartlist_clear(struct smartlist_t *sl);
// smartlist_contains
// file ../src/common/container.c line 175
signed int smartlist_contains(const struct smartlist_t *sl, const void *element);
// smartlist_contains_digest
// file ../src/common/container.c line 278
signed int smartlist_contains_digest(const struct smartlist_t *sl, const char *element);
// smartlist_contains_int_as_string
// file ../src/common/container.c line 229
signed int smartlist_contains_int_as_string(const struct smartlist_t *sl, signed int num);
// smartlist_contains_string
// file ../src/common/container.c line 188
signed int smartlist_contains_string(const struct smartlist_t *sl, const char *element);
// smartlist_contains_string_case
// file ../src/common/container.c line 215
signed int smartlist_contains_string_case(const struct smartlist_t *sl, const char *element);
// smartlist_del
// file ../src/common/container.c line 329
void smartlist_del(struct smartlist_t *sl, signed int idx);
// smartlist_del_keeporder
// file ../src/common/container.c line 342
void smartlist_del_keeporder(struct smartlist_t *sl, signed int idx);
// smartlist_ensure_capacity
// file ../src/common/container.c line 63
static inline void smartlist_ensure_capacity(struct smartlist_t *sl, signed int size);
// smartlist_free
// file ../src/common/container.h line 31
void smartlist_free(struct smartlist_t *sl);
// smartlist_get_most_frequent_
// file ../src/common/container.c line 525
void * smartlist_get_most_frequent_(const struct smartlist_t *sl, signed int (*compare)(const void **, const void **), signed int *count_out);
// smartlist_get_most_frequent_::compare_object
//
signed int compare_object(const void **, const void **);
// smartlist_get_most_frequent_digest256
// file ../src/common/container.c line 1011
char * smartlist_get_most_frequent_digest256(struct smartlist_t *sl);
// smartlist_get_most_frequent_string
// file ../src/common/container.c line 733
char * smartlist_get_most_frequent_string(struct smartlist_t *sl);
// smartlist_get_most_frequent_string_
// file ../src/common/container.c line 743
char * smartlist_get_most_frequent_string_(struct smartlist_t *sl, signed int *count_out);
// smartlist_heapify
// file ../src/common/container.c line 848
static inline void smartlist_heapify(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, signed int idx);
// smartlist_heapify::compare_object
//
signed int compare_object(const void *, const void *);
// smartlist_insert
// file ../src/common/container.c line 357
void smartlist_insert(struct smartlist_t *sl, signed int idx, void *val);
// smartlist_intersect
// file ../src/common/container.c line 304
void smartlist_intersect(struct smartlist_t *sl1, const struct smartlist_t *sl2);
// smartlist_ints_eq
// file ../src/common/container.c line 258
signed int smartlist_ints_eq(const struct smartlist_t *sl1, const struct smartlist_t *sl2);
// smartlist_join_strings
// file ../src/common/container.h line 144
char * smartlist_join_strings(struct smartlist_t *sl, const char *join, signed int terminate, unsigned long int *len_out);
// smartlist_join_strings2
// file ../src/common/container.c line 468
char * smartlist_join_strings2(struct smartlist_t *sl, const char *join, unsigned long int join_len, signed int terminate, unsigned long int *len_out);
// smartlist_new
// file ../src/common/container.h line 30
struct smartlist_t * smartlist_new(void);
// smartlist_overlap
// file ../src/common/container.c line 291
signed int smartlist_overlap(const struct smartlist_t *sl1, const struct smartlist_t *sl2);
// smartlist_pop_last
// file ../src/common/container.c line 132
void * smartlist_pop_last(struct smartlist_t *sl);
// smartlist_pqueue_add
// file ../src/common/container.c line 887
void smartlist_pqueue_add(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, void *item);
// smartlist_pqueue_add::compare_object
//
signed int compare_object(const void *, const void *);
// smartlist_pqueue_assert_ok
// file ../src/common/container.c line 960
void smartlist_pqueue_assert_ok(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset);
// smartlist_pqueue_assert_ok::compare_object
//
signed int compare_object(const void *, const void *);
// smartlist_pqueue_pop
// file ../src/common/container.c line 916
void * smartlist_pqueue_pop(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset);
// smartlist_pqueue_pop::compare_object
//
signed int compare_object(const void *, const void *);
// smartlist_pqueue_remove
// file ../src/common/container.c line 938
void smartlist_pqueue_remove(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, void *item);
// smartlist_pqueue_remove::compare_object
//
signed int compare_object(const void *, const void *);
// smartlist_remove
// file ../src/common/container.c line 117
void smartlist_remove(struct smartlist_t *sl, const void *element);
// smartlist_reverse
// file ../src/common/container.c line 143
void smartlist_reverse(struct smartlist_t *sl);
// smartlist_sort
// file ../src/common/container.c line 511
void smartlist_sort(struct smartlist_t *sl, signed int (*compare)(const void **, const void **));
// smartlist_sort::compare_object
//
signed int compare_object(const void **, const void **);
// smartlist_sort_digests
// file ../src/common/container.c line 981
void smartlist_sort_digests(struct smartlist_t *sl);
// smartlist_sort_digests256
// file ../src/common/container.c line 1003
void smartlist_sort_digests256(struct smartlist_t *sl);
// smartlist_sort_pointers
// file ../src/common/container.c line 771
void smartlist_sort_pointers(struct smartlist_t *sl);
// smartlist_sort_strings
// file ../src/common/container.c line 726
void smartlist_sort_strings(struct smartlist_t *sl);
// smartlist_split_string
// file ../src/common/container.c line 391
signed int smartlist_split_string(struct smartlist_t *sl, const char *str, const char *sep, signed int flags, signed int max);
// smartlist_string_pos
// file ../src/common/container.c line 201
signed int smartlist_string_pos(const struct smartlist_t *sl, const char *element);
// smartlist_string_remove
// file ../src/common/container.c line 158
void smartlist_string_remove(struct smartlist_t *sl, const char *element);
// smartlist_strings_eq
// file ../src/common/container.c line 239
signed int smartlist_strings_eq(const struct smartlist_t *sl1, const struct smartlist_t *sl2);
// smartlist_subtract
// file ../src/common/container.c line 318
void smartlist_subtract(struct smartlist_t *sl1, const struct smartlist_t *sl2);
// smartlist_uniq
// file ../src/common/container.c line 567
void smartlist_uniq(struct smartlist_t *sl, signed int (*compare)(const void **, const void **), void (*free_fn)(void *));
// smartlist_uniq::compare_object
//
signed int compare_object(const void **, const void **);
// smartlist_uniq::free_fn_object
//
void free_fn_object(void *);
// smartlist_uniq_digests
// file ../src/common/container.c line 989
void smartlist_uniq_digests(struct smartlist_t *sl);
// smartlist_uniq_digests256
// file ../src/common/container.c line 1020
void smartlist_uniq_digests256(struct smartlist_t *sl);
// smartlist_uniq_strings
// file ../src/common/container.c line 751
void smartlist_uniq_strings(struct smartlist_t *sl);
// sock_alert
// file ../src/common/compat_threads.c line 185
static signed int sock_alert(signed int fd);
// sock_drain
// file ../src/common/compat_threads.c line 194
static signed int sock_drain(signed int fd);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socket_accounting_lock
// file ../src/common/compat.c line 1049
static inline void socket_accounting_lock(void);
// socket_accounting_unlock
// file ../src/common/compat.c line 1058
static inline void socket_accounting_unlock(void);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// socks5_reason_to_string
// file ../src/tools/tor-resolve.c line 164
static const char * socks5_reason_to_string(char reason);
// spawn_exit
// file ../src/common/compat_pthreads.c line 79
void spawn_exit(void);
// spawn_func
// file ../src/common/compat_threads.h line 25
signed int spawn_func(void (*func)(void *), void *data);
// spawn_func::func_object
//
void func_object(void *);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_daemon
// file ../src/common/util.c line 3451
void start_daemon(void);
// start_writing_to_file
// file ../src/common/util.c line 2296
signed int start_writing_to_file(const char *fname, signed int open_flags, signed int mode, struct open_file_t **data_out);
// start_writing_to_stdio_file
// file ../src/common/util.c line 2377
struct _IO_FILE * start_writing_to_stdio_file(const char *fname, signed int open_flags, signed int mode, struct open_file_t **data_out);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// str_num_before
// file ../src/common/util.c line 4465
static inline unsigned long int str_num_before(const char *s, char ch);
// strcasecmp
// file /usr/include/string.h line 534
extern signed int strcasecmp(const char *, const char *);
// strcasecmpend
// file ../src/tools/../common/util.h line 210
signed int strcasecmpend(const char *s1, const char *s2);
// strcasecmpstart
// file ../src/common/util.h line 208
signed int strcasecmpstart(const char *s1, const char *s2);
// strcmp_len
// file ../src/common/util.c line 712
signed int strcmp_len(const char *s1, const char *s2, unsigned long int s1_len);
// strcmp_opt
// file ../src/common/util.c line 683
signed int strcmp_opt(const char *s1, const char *s2);
// strcmpend
// file ../src/common/util.c line 736
signed int strcmpend(const char *s1, const char *s2);
// strcmpstart
// file ../src/common/util.c line 701
signed int strcmpstart(const char *s1, const char *s2);
// stream_status_to_string
// file ../src/common/util.c line 4832
const char * stream_status_to_string(enum stream_status stream_status);
// strerror
// file /usr/include/string.h line 413
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_is_C_identifier
// file ../src/common/util.c line 934
signed int string_is_C_identifier(const char *string);
// string_is_key_value
// file ../src/common/util.c line 993
signed int string_is_key_value(signed int severity, const char *string);
// string_is_valid_hostname
// file ../src/common/util.c line 1048
signed int string_is_valid_hostname(const char *string);
// string_is_valid_ipv4_address
// file ../src/common/util.c line 1026
signed int string_is_valid_ipv4_address(const char *string);
// string_is_valid_ipv6_address
// file ../src/common/util.c line 1037
signed int string_is_valid_ipv6_address(const char *string);
// strlcat
// file ../src/ext/strlcat.c line 45
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz);
// strlcpy
// file ../src/ext/strlcpy.c line 42
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strmap_assert_ok
// file ../src/common/container.c line 1365
void strmap_assert_ok(const struct strmap_t *map);
// strmap_assign_key
// file ../src/common/container.c line 1136
static inline void strmap_assign_key(struct strmap_entry_t *ent, const char *key);
// strmap_assign_tmp_key
// file ../src/common/container.c line 1121
static inline void strmap_assign_tmp_key(struct strmap_entry_t *ent, const char *key);
// strmap_entries_eq
// file ../src/common/container.c line 1045
static inline signed int strmap_entries_eq(const struct strmap_entry_t *a, const struct strmap_entry_t *b);
// strmap_entry_free
// file ../src/common/container.c line 1104
static inline void strmap_entry_free(struct strmap_entry_t *ent);
// strmap_entry_hash
// file ../src/common/container.c line 1052
static inline unsigned int strmap_entry_hash(const struct strmap_entry_t *a);
// strmap_free
// file ../src/common/container.c line 1365
void strmap_free(struct strmap_t *map, void (*free_val)(void *));
// strmap_free::free_val_object
//
void free_val_object(void *);
// strmap_get
// file ../src/common/container.c line 1365
void * strmap_get(const struct strmap_t *map, const char *key);
// strmap_get_lc
// file ../src/common/container.c line 1385
void * strmap_get_lc(const struct strmap_t *map, const char *key);
// strmap_impl_HT_CLEAR
// file ../src/common/container.c line 1088
void strmap_impl_HT_CLEAR(struct strmap_impl *head);
// strmap_impl_HT_FIND
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t * strmap_impl_HT_FIND(struct strmap_impl *head, struct strmap_entry_t *elm);
// strmap_impl_HT_FIND_P_
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_FIND_P_(struct strmap_impl *head, struct strmap_entry_t *elm);
// strmap_impl_HT_GROW
// file ../src/common/container.c line 1088
signed int strmap_impl_HT_GROW(struct strmap_impl *head, unsigned int size);
// strmap_impl_HT_INIT
// file ../src/common/container.c line 1086
static inline void strmap_impl_HT_INIT(struct strmap_impl *head);
// strmap_impl_HT_NEXT
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_NEXT(struct strmap_impl *head, struct strmap_entry_t **elm);
// strmap_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_NEXT_RMV(struct strmap_impl *head, struct strmap_entry_t **elm);
// strmap_impl_HT_REMOVE
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t * strmap_impl_HT_REMOVE(struct strmap_impl *head, struct strmap_entry_t *elm);
// strmap_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1088
signed int strmap_impl_HT_REP_IS_BAD_(struct strmap_impl *head);
// strmap_impl_HT_START
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_START(struct strmap_impl *head);
// strmap_isempty
// file ../src/common/container.c line 1365
signed int strmap_isempty(const struct strmap_t *map);
// strmap_iter_done
// file ../src/common/container.c line 1365
signed int strmap_iter_done(struct strmap_entry_t **iter);
// strmap_iter_get
// file ../src/common/container.c line 1365
void strmap_iter_get(struct strmap_entry_t **iter, const char **keyp, void **valp);
// strmap_iter_init
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_init(struct strmap_t *map);
// strmap_iter_next
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_next(struct strmap_t *map, struct strmap_entry_t **iter);
// strmap_iter_next_rmv
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_next_rmv(struct strmap_t *map, struct strmap_entry_t **iter);
// strmap_new
// file ../src/common/container.c line 1365
struct strmap_t * strmap_new(void);
// strmap_remove
// file ../src/common/container.c line 1365
void * strmap_remove(struct strmap_t *map, const char *key);
// strmap_remove_lc
// file ../src/common/container.c line 1397
void * strmap_remove_lc(struct strmap_t *map, const char *key);
// strmap_set
// file ../src/common/container.c line 1365
void * strmap_set(struct strmap_t *map, const char *key, void *val);
// strmap_set_lc
// file ../src/common/container.c line 1371
void * strmap_set_lc(struct strmap_t *map, const char *key, void *val);
// strmap_size
// file ../src/common/container.c line 1365
signed int strmap_size(const struct strmap_t *map);
// strncasecmp
// file /usr/include/string.h line 538
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 117
static inline char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len);
// strrchr
// file /usr/include/string.h line 263
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 342
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok_helper
// file ../src/common/compat.c line 671
static char * strtok_helper(char *cp, const char *sep);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// switch_id
// file ../src/common/compat.c line 1842
signed int switch_id(const char *user);
// switch_logs_debug
// file ../src/common/log.c line 1416
void switch_logs_debug(void);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...);
// threadpool_get_replyqueue
// file ../src/common/workqueue.c line 428
struct replyqueue_s * threadpool_get_replyqueue(struct threadpool_s *tp);
// threadpool_new
// file ../src/common/workqueue.c line 399
struct threadpool_s * threadpool_new(signed int n_threads, struct replyqueue_s *replyqueue, void * (*new_thread_state_fn)(void *), void (*free_thread_state_fn)(void *), void *arg);
// threadpool_new::free_thread_state_fn_object
//
void free_thread_state_fn_object(void *);
// threadpool_new::new_thread_state_fn_object
//
void * new_thread_state_fn_object(void *);
// threadpool_queue_update
// file ../src/common/workqueue.c line 318
signed int threadpool_queue_update(struct threadpool_s *pool, void * (*dup_fn)(void *), signed int (*fn)(void *, void *), void (*free_fn)(void *), void *arg);
// threadpool_queue_update::1::old_args_free_fn_object
//
void old_args_free_fn_object(void *);
// threadpool_queue_update::dup_fn_object
//
void * dup_fn_object(void *);
// threadpool_queue_update::fn_object
//
signed int fn_object(void *, void *);
// threadpool_queue_update::free_fn_object
//
void free_fn_object(void *);
// threadpool_queue_work
// file ../src/common/workqueue.c line 282
struct workqueue_entry_s * threadpool_queue_work(struct threadpool_s *pool, signed int (*fn)(void *, void *), void (*reply_fn)(void *), void *arg);
// threadpool_queue_work::fn_object
//
signed int fn_object(void *, void *);
// threadpool_queue_work::reply_fn_object
//
void reply_fn_object(void *);
// threadpool_start_threads
// file ../src/common/workqueue.c line 364
static signed int threadpool_start_threads(struct threadpool_s *pool, signed int n);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tor_accept_socket
// file ../src/common/compat.c line 1230
signed int tor_accept_socket(signed int sockfd, struct sockaddr *addr, unsigned int *len);
// tor_accept_socket_nonblocking
// file ../src/common/compat.c line 1238
signed int tor_accept_socket_nonblocking(signed int sockfd, struct sockaddr *addr, unsigned int *len);
// tor_accept_socket_with_extensions
// file ../src/common/compat.c line 1249
signed int tor_accept_socket_with_extensions(signed int sockfd, struct sockaddr *addr, unsigned int *len, signed int cloexec, signed int nonblock);
// tor_addr_compare
// file ../src/common/address.c line 949
signed int tor_addr_compare(const struct tor_addr_t *addr1, const struct tor_addr_t *addr2, enum anonymous_18 how);
// tor_addr_compare_masked
// file ../src/common/address.c line 970
signed int tor_addr_compare_masked(const struct tor_addr_t *addr1, const struct tor_addr_t *addr2, unsigned char mbits, enum anonymous_18 how);
// tor_addr_copy
// file ../src/common/address.c line 905
void tor_addr_copy(struct tor_addr_t *dest, const struct tor_addr_t *src);
// tor_addr_copy_tight
// file ../src/common/address.c line 919
void tor_addr_copy_tight(struct tor_addr_t *dest, const struct tor_addr_t *src);
// tor_addr_family
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family(const struct tor_addr_t *a);
// tor_addr_family_link1
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family_link1(const struct tor_addr_t *a_link1);
// tor_addr_family_link2
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family_link2(const struct tor_addr_t *a_link2);
// tor_addr_from_in6
// file ../src/common/address.c line 897
void tor_addr_from_in6(struct tor_addr_t *dest, struct in6_addr *in6);
// tor_addr_from_ipv4n
// file ../src/common/address.h line 239
void tor_addr_from_ipv4n(struct tor_addr_t *dest, unsigned int v4addr);
// tor_addr_from_ipv6_bytes
// file ../src/common/address.h line 244
void tor_addr_from_ipv6_bytes(struct tor_addr_t *dest, const char *ipv6_bytes);
// tor_addr_from_sockaddr
// file ../src/common/address.c line 138
signed int tor_addr_from_sockaddr(struct tor_addr_t *a, struct sockaddr *sa, unsigned short int *port_out);
// tor_addr_hash
// file ../src/common/address.c line 1062
unsigned long int tor_addr_hash(const struct tor_addr_t *addr);
// tor_addr_hostname_is_local
// file ../src/common/address.c line 1856
signed int tor_addr_hostname_is_local(const char *name);
// tor_addr_is_internal_
// file ../src/common/address.c line 338
signed int tor_addr_is_internal_(const struct tor_addr_t *addr, signed int for_listening, const char *filename, signed int lineno);
// tor_addr_is_loopback
// file ../src/common/address.c line 851
signed int tor_addr_is_loopback(const struct tor_addr_t *addr);
// tor_addr_is_multicast
// file ../src/common/address.c line 1492
static signed int tor_addr_is_multicast(const struct tor_addr_t *a);
// tor_addr_is_null
// file ../src/common/address.c line 826
signed int tor_addr_is_null(const struct tor_addr_t *addr);
// tor_addr_is_v4
// file ../src/common/address.c line 805
signed int tor_addr_is_v4(const struct tor_addr_t *addr);
// tor_addr_lookup
// file ../src/common/address.c line 221
signed int tor_addr_lookup(const char *name, unsigned short int family, struct tor_addr_t *addr);
// tor_addr_make_af_unix
// file ../src/common/address.c line 129
static void tor_addr_make_af_unix(struct tor_addr_t *a);
// tor_addr_make_null
// file ../src/common/address.c line 206
void tor_addr_make_null(struct tor_addr_t *a, unsigned short int family);
// tor_addr_make_unspec
// file ../src/common/address.h line 88
void tor_addr_make_unspec(struct tor_addr_t *a);
// tor_addr_parse
// file ../src/common/address.h line 236
signed int tor_addr_parse(struct tor_addr_t *addr, const char *src);
// tor_addr_parse_PTR_name
// file ../src/common/address.c line 460
signed int tor_addr_parse_PTR_name(struct tor_addr_t *result, const char *address, signed int family, signed int accept_regular);
// tor_addr_parse_mask_ports
// file ../src/common/address.c line 616
signed int tor_addr_parse_mask_ports(const char *s, unsigned int flags, struct tor_addr_t *addr_out, unsigned char *maskbits_out, unsigned short int *port_min_out, unsigned short int *port_max_out);
// tor_addr_port_lookup
// file ../src/common/address.c line 1171
signed int tor_addr_port_lookup(const char *s, struct tor_addr_t *addr_out, unsigned short int *port_out);
// tor_addr_port_new
// file ../src/common/address.c line 1866
struct tor_addr_port_t * tor_addr_port_new(const struct tor_addr_t *addr, unsigned short int port);
// tor_addr_port_parse
// file ../src/common/address.c line 1615
signed int tor_addr_port_parse(signed int severity, const char *addrport, struct tor_addr_t *address_out, unsigned short int *port_out, signed int default_port);
// tor_addr_port_split
// file ../src/common/address.c line 1654
signed int tor_addr_port_split(signed int severity, const char *addrport, char **address_out, unsigned short int *port_out);
// tor_addr_to_PTR_name
// file ../src/common/address.c line 550
signed int tor_addr_to_PTR_name(char *out, unsigned long int outlen, const struct tor_addr_t *addr);
// tor_addr_to_in6
// file ../src/common/address.h line 95
static inline struct in6_addr * tor_addr_to_in6(const struct tor_addr_t *a);
// tor_addr_to_in6_link1
// file ../src/common/address.h line 95
static inline struct in6_addr * tor_addr_to_in6_link1(const struct tor_addr_t *a_link1);
// tor_addr_to_ipv4h
// file ../src/common/address.h line 126
static inline unsigned int tor_addr_to_ipv4h(const struct tor_addr_t *a);
// tor_addr_to_ipv4h_link1
// file ../src/common/address.h line 126
static inline unsigned int tor_addr_to_ipv4h_link1(const struct tor_addr_t *a_link1);
// tor_addr_to_ipv4n
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n(const struct tor_addr_t *a);
// tor_addr_to_ipv4n_link1
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n_link1(const struct tor_addr_t *a_link1);
// tor_addr_to_ipv4n_link2
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n_link2(const struct tor_addr_t *a_link2);
// tor_addr_to_mapped_ipv4h
// file ../src/common/address.h line 135
static inline unsigned int tor_addr_to_mapped_ipv4h(const struct tor_addr_t *a);
// tor_addr_to_sockaddr
// file ../src/common/address.c line 89
unsigned int tor_addr_to_sockaddr(const struct tor_addr_t *a, unsigned short int port, struct sockaddr *sa_out, unsigned int len);
// tor_addr_to_str
// file ../src/common/address.c line 409
const char * tor_addr_to_str(char *dest, const struct tor_addr_t *addr, unsigned long int len, signed int decorate);
// tor_asprintf
// file ../src/common/compat.h line 305
signed int tor_asprintf(char **strp, const char *fmt, ...);
// tor_assertion_failed_
// file ../src/tools/../common/util.h line 56
void tor_assertion_failed_(const char *fname, unsigned int line, const char *func, const char *expr);
// tor_calloc_
// file ../src/common/util.h line 80
void * tor_calloc_(unsigned long int nmemb, unsigned long int size);
// tor_check_port_forwarding
// file ../src/common/util.c line 5231
void tor_check_port_forwarding(const char *filename, struct smartlist_t *ports_to_forward, signed long int now);
// tor_close_socket
// file ../src/common/compat.h line 462
signed int tor_close_socket(signed int s);
// tor_close_socket_simple
// file ../src/common/compat.c line 1067
signed int tor_close_socket_simple(signed int s);
// tor_cond_free
// file ../src/common/compat_threads.c line 65
void tor_cond_free(struct tor_cond_t *c);
// tor_cond_init
// file ../src/common/compat_threads.h line 81
signed int tor_cond_init(struct tor_cond_t *cond);
// tor_cond_new
// file ../src/common/compat_threads.c line 55
struct tor_cond_t * tor_cond_new(void);
// tor_cond_signal_all
// file ../src/common/compat_threads.h line 86
void tor_cond_signal_all(struct tor_cond_t *cond);
// tor_cond_signal_one
// file ../src/common/compat_threads.h line 85
void tor_cond_signal_one(struct tor_cond_t *cond);
// tor_cond_uninit
// file ../src/common/compat_threads.h line 82
void tor_cond_uninit(struct tor_cond_t *cond);
// tor_cond_wait
// file ../src/common/compat_threads.h line 83
signed int tor_cond_wait(struct tor_cond_t *cond, struct tor_mutex_t *mutex, struct timeval *tv);
// tor_digest256_is_zero
// file ../src/common/util.c line 1086
signed int tor_digest256_is_zero(const char *digest);
// tor_digest_is_zero
// file ../src/common/util.c line 981
signed int tor_digest_is_zero(const char *digest);
// tor_disable_debugger_attach
// file ../src/common/compat.c line 1997
signed int tor_disable_debugger_attach(void);
// tor_dup_addr
// file ../src/common/address.c line 1079
char * tor_dup_addr(const struct tor_addr_t *addr);
// tor_dup_ip
// file ../src/common/address.c line 1825
char * tor_dup_ip(unsigned int addr);
// tor_escape_str_for_pt_args
// file ../src/common/util.c line 1422
char * tor_escape_str_for_pt_args(const char *string, const char *chars_to_escape);
// tor_fd_getpos
// file ../src/common/compat.c line 973
signed long int tor_fd_getpos(signed int fd);
// tor_fd_seekend
// file ../src/common/compat.c line 986
signed int tor_fd_seekend(signed int fd);
// tor_fd_setpos
// file ../src/common/compat.c line 1005
signed int tor_fd_setpos(signed int fd, signed long int pos);
// tor_fopen_cloexec
// file ../src/common/compat.c line 170
struct _IO_FILE * tor_fopen_cloexec(const char *path, const char *mode);
// tor_free_
// file ../src/common/util.h line 90
void tor_free_(void *mem);
// tor_ftruncate
// file ../src/common/compat.c line 1017
signed int tor_ftruncate(signed int fd);
// tor_get_exit_code
// file ../src/common/util.c line 4385
signed int tor_get_exit_code(struct process_handle_t *process_handle, signed int block, signed int *exit_code);
// tor_get_lines_from_handle
// file ../src/common/util.c line 4968
struct smartlist_t * tor_get_lines_from_handle(struct _IO_FILE *handle, enum stream_status *stream_status_out);
// tor_get_thread_id
// file ../src/common/compat_threads.h line 55
unsigned long int tor_get_thread_id(void);
// tor_gethostname
// file ../src/common/compat.c line 2205
signed int tor_gethostname(char *name, unsigned long int namelen);
// tor_getpwnam
// file ../src/common/compat.c line 1783
struct passwd * tor_getpwnam(const char *username);
// tor_getpwuid
// file ../src/common/compat.c line 1819
struct passwd * tor_getpwuid(unsigned int uid);
// tor_gettimeofday
// file ../src/common/compat.c line 2621
void tor_gettimeofday(struct timeval *timeval);
// tor_gmtime_r
// file ../src/common/compat.c line 2800
struct tm * tor_gmtime_r(const signed long int *timep, struct tm *result);
// tor_inet_aton
// file ../src/common/compat.h line 545
signed int tor_inet_aton(const char *str, struct in_addr *addr);
// tor_inet_ntoa
// file ../src/common/address.c line 1811
signed int tor_inet_ntoa(struct in_addr *in, char *buf, unsigned long int buf_len);
// tor_inet_ntop
// file ../src/common/compat.h line 546
const char * tor_inet_ntop(signed int af, const void *src, char *dst, unsigned long int len);
// tor_inet_pton
// file ../src/common/compat.h line 547
signed int tor_inet_pton(signed int af, const char *src, void *dst);
// tor_init_weak_random
// file ../src/common/util.c line 5385
void tor_init_weak_random(struct tor_weak_rng_t *rng, unsigned int seed);
// tor_join_win_cmdline
// file ../src/common/util.c line 3672
char * tor_join_win_cmdline(const char **argv);
// tor_listdir
// file ../src/common/util.c line 3353
struct smartlist_t * tor_listdir(const char *dirname);
// tor_llround
// file ../src/common/util.c line 419
signed long int tor_llround(double d);
// tor_localtime_r
// file ../src/common/compat.c line 2757
struct tm * tor_localtime_r(const signed long int *timep, struct tm *result);
// tor_lockfile_lock
// file ../src/common/compat.c line 873
struct tor_lockfile_t * tor_lockfile_lock(const char *filename, signed int blocking, signed int *locked_out);
// tor_lockfile_unlock
// file ../src/common/compat.c line 931
void tor_lockfile_unlock(struct tor_lockfile_t *lockfile);
// tor_log
// file ../src/common/torlog.h line 157
void tor_log(signed int severity, unsigned int domain, const char *format, ...);
// tor_log2
// file ../src/common/util.h line 170
signed int tor_log2(unsigned long int u64);
// tor_log_err_sigsafe
// file ../src/common/torlog.h line 160
void tor_log_err_sigsafe(const char *m, ...);
// tor_log_err_sigsafe_write
// file ../src/common/log.c line 525
static signed int tor_log_err_sigsafe_write(const char *s);
// tor_log_get_logfile_names
// file ../src/common/log.c line 640
void tor_log_get_logfile_names(struct smartlist_t *out);
// tor_log_get_sigsafe_err_fds
// file ../src/common/torlog.h line 161
signed int tor_log_get_sigsafe_err_fds(const signed int **out);
// tor_log_mallinfo
// file ../src/common/util.c line 361
void tor_log_mallinfo(signed int severity);
// tor_log_update_sigsafe_err_fds
// file ../src/common/log.c line 596
void tor_log_update_sigsafe_err_fds(void);
// tor_lookup_hostname
// file ../src/common/compat.h line 548
signed int tor_lookup_hostname(const char *name, unsigned int *addr);
// tor_lround
// file ../src/common/util.c line 404
signed long int tor_lround(double d);
// tor_malloc_
// file ../src/tools/../common/util.h line 78
void * tor_malloc_(unsigned long int size);
// tor_malloc_zero_
// file ../src/tools/../common/util.h line 79
void * tor_malloc_zero_(unsigned long int size);
// tor_mathlog
// file ../src/common/util.c line 395
double tor_mathlog(double d);
// tor_mem_is_zero
// file ../src/common/util.c line 959
signed int tor_mem_is_zero(const char *mem, unsigned long int len);
// tor_memcmp
// file ../src/common/di_ops.h line 17
signed int tor_memcmp(const void *a, const void *b, unsigned long int len);
// tor_memdup_
// file ../src/common/util.h line 86
void * tor_memdup_(const void *mem, unsigned long int len);
// tor_memdup_nulterm_
// file ../src/common/util.c line 339
void * tor_memdup_nulterm_(const void *mem, unsigned long int len);
// tor_memeq
// file ../src/common/di_ops.h line 18
signed int tor_memeq(const void *a, const void *b, unsigned long int sz);
// tor_memmem
// file ../src/common/compat.c line 570
const void * tor_memmem(const void *_haystack, unsigned long int hlen, const void *_needle, unsigned long int nlen);
// tor_mlockall
// file ../src/common/compat.c line 2873
signed int tor_mlockall(void);
// tor_mmap_file
// file ../src/common/compat.c line 199
struct tor_mmap_t * tor_mmap_file(const char *filename);
// tor_munmap_file
// file ../src/common/compat.c line 269
signed int tor_munmap_file(struct tor_mmap_t *handle);
// tor_mutex_acquire
// file ../src/common/compat_threads.h line 51
void tor_mutex_acquire(struct tor_mutex_t *m);
// tor_mutex_free
// file ../src/common/compat_threads.c line 45
void tor_mutex_free(struct tor_mutex_t *m);
// tor_mutex_init
// file ../src/common/compat_threads.h line 49
void tor_mutex_init(struct tor_mutex_t *mutex);
// tor_mutex_init_nonrecursive
// file ../src/common/compat_threads.h line 50
void tor_mutex_init_nonrecursive(struct tor_mutex_t *mutex);
// tor_mutex_new
// file ../src/common/compat_threads.h line 47
struct tor_mutex_t * tor_mutex_new(void);
// tor_mutex_new_nonrecursive
// file ../src/common/compat_threads.c line 37
struct tor_mutex_t * tor_mutex_new_nonrecursive(void);
// tor_mutex_release
// file ../src/common/compat_threads.h line 52
void tor_mutex_release(struct tor_mutex_t *m);
// tor_mutex_uninit
// file ../src/common/compat_threads.h line 54
void tor_mutex_uninit(struct tor_mutex_t *m);
// tor_open_cloexec
// file ../src/common/compat.c line 137
signed int tor_open_cloexec(const char *path, signed int flags, unsigned int mode);
// tor_open_socket
// file ../src/common/compat.h line 466
signed int tor_open_socket(signed int domain, signed int type, signed int protocol);
// tor_open_socket_nonblocking
// file ../src/common/compat.c line 1168
signed int tor_open_socket_nonblocking(signed int domain, signed int type, signed int protocol);
// tor_open_socket_with_extensions
// file ../src/common/compat.c line 1178
signed int tor_open_socket_with_extensions(signed int domain, signed int type, signed int protocol, signed int cloexec, signed int nonblock);
// tor_parse_double
// file ../src/common/util.c line 1165
double tor_parse_double(const char *s, double min, double max, signed int *ok, char **next);
// tor_parse_long
// file ../src/common/util.h line 215
signed long int tor_parse_long(const char *s, signed int base, signed long int min, signed long int max, signed int *ok, char **next);
// tor_parse_uint64
// file ../src/common/util.c line 1178
unsigned long int tor_parse_uint64(const char *s, signed int base, unsigned long int min, unsigned long int max, signed int *ok, char **next);
// tor_parse_ulong
// file ../src/common/util.c line 1146
unsigned long int tor_parse_ulong(const char *s, signed int base, unsigned long int min, unsigned long int max, signed int *ok, char **next);
// tor_passwd_dup
// file ../src/common/compat.c line 1748
static struct passwd * tor_passwd_dup(struct passwd *pw);
// tor_passwd_free
// file ../src/common/compat.c line 1763
static void tor_passwd_free(struct passwd *pw);
// tor_process_get_pid
// file ../src/common/util.c line 3921
signed int tor_process_get_pid(struct process_handle_t *process_handle);
// tor_process_get_stdout_pipe
// file ../src/common/util.c line 3939
struct _IO_FILE * tor_process_get_stdout_pipe(struct process_handle_t *process_handle);
// tor_process_handle_destroy
// file ../src/common/util.c line 4328
void tor_process_handle_destroy(struct process_handle_t *process_handle, signed int also_terminate_process);
// tor_pthread_helper_fn
// file ../src/common/compat_pthreads.c line 28
static void * tor_pthread_helper_fn(void *_data);
// tor_pthread_helper_fn::1::func_object
//
void func_object(void *);
// tor_read_all_from_process_stderr
// file ../src/common/util.c line 4765
signed long int tor_read_all_from_process_stderr(const struct process_handle_t *process_handle, char *buf, unsigned long int count);
// tor_read_all_from_process_stdout
// file ../src/common/util.c line 4751
signed long int tor_read_all_from_process_stdout(const struct process_handle_t *process_handle, char *buf, unsigned long int count);
// tor_read_all_handle
// file ../src/common/util.c line 4704
signed long int tor_read_all_handle(struct _IO_FILE *h, char *buf, unsigned long int count, const struct process_handle_t *process, signed int *eof);
// tor_realloc_
// file ../src/common/util.h line 81
void * tor_realloc_(void *ptr, unsigned long int size);
// tor_reallocarray_
// file ../src/common/util.h line 82
void * tor_reallocarray_(void *ptr, unsigned long int sz1, unsigned long int sz2);
// tor_rename
// file ../src/common/compat.c line 187
signed int tor_rename(const char *path_old, const char *path_new);
// tor_set_max_memlock
// file ../src/common/compat.c line 2840
static signed int tor_set_max_memlock(void);
// tor_snprintf
// file ../src/common/compat.h line 300
signed int tor_snprintf(char *str, unsigned long int size, const char *format, ...);
// tor_sockaddr_to_str
// file ../src/common/address.c line 169
char * tor_sockaddr_to_str(struct sockaddr *sa);
// tor_socketpair
// file ../src/common/compat.c line 1356
signed int tor_socketpair(signed int family, signed int type, signed int protocol, signed int *fd);
// tor_spawn_background
// file ../src/common/util.c line 4019
signed int tor_spawn_background(const char * const filename, const char **argv, struct process_environment_t *env, struct process_handle_t **process_handle_out);
// tor_split_lines
// file ../src/common/util.c line 4783
signed int tor_split_lines(struct smartlist_t *sl, char *buf, signed int len);
// tor_sscanf
// file ../src/common/util.h line 251
signed int tor_sscanf(const char *buf, const char *pattern, ...);
// tor_strclear
// file ../src/common/util.c line 777
void tor_strclear(char *s);
// tor_strdup_
// file ../src/common/util.h line 83
char * tor_strdup_(const char *s);
// tor_strisnonupper
// file ../src/common/util.c line 670
signed int tor_strisnonupper(const char *s);
// tor_strisprint
// file ../src/common/util.c line 657
signed int tor_strisprint(const char *s);
// tor_strlower
// file ../src/common/util.h line 201
void tor_strlower(char *s);
// tor_strndup_
// file ../src/common/util.h line 84
char * tor_strndup_(const char *s, unsigned long int n);
// tor_strstrip
// file ../src/common/util.h line 214
void tor_strstrip(char *s, const char *strip);
// tor_strtok_r_impl
// file ../src/common/compat.c line 686
char * tor_strtok_r_impl(char *str, const char *sep, char **lasts);
// tor_strupper
// file ../src/common/util.c line 646
void tor_strupper(char *s);
// tor_terminate_process
// file ../src/common/util.c line 3898
signed int tor_terminate_process(struct process_handle_t *process_handle);
// tor_threads_init
// file ../src/common/compat_pthreads.c line 276
void tor_threads_init(void);
// tor_timegm
// file ../src/common/util.c line 1529
signed int tor_timegm(struct tm *tm, signed long int *time_out);
// tor_vasprintf
// file ../src/common/compat.c line 504
signed int tor_vasprintf(char **strp, const char *fmt, void **args);
// tor_vsnprintf
// file ../src/common/compat.c line 450
signed int tor_vsnprintf(char *str, unsigned long int size, const char *format, void **args);
// tor_vsscanf
// file ../src/common/util.c line 3187
signed int tor_vsscanf(const char *buf, const char *pattern, __builtin_va_list ap);
// tor_weak_random
// file ../src/common/util.c line 5395
signed int tor_weak_random(struct tor_weak_rng_t *rng);
// tor_weak_random_range
// file ../src/common/util.c line 5411
signed int tor_weak_random_range(struct tor_weak_rng_t *rng, signed int top);
// touch_file
// file ../src/common/compat.c line 840
signed int touch_file(const char *fname);
// truncate_logs
// file ../src/common/log.c line 1431
void truncate_logs(void);
// trunnel_dynarray_expand
// file ../src/ext/trunnel/trunnel.c line 99
void * trunnel_dynarray_expand(unsigned long int *allocated_p, void *ptr, unsigned long int howmanymore, unsigned long int eltsize);
// trunnel_dynarray_setlen
// file ../src/ext/trunnel/trunnel.c line 187
void * trunnel_dynarray_setlen(unsigned long int *allocated_p, unsigned long int *len_p, void *ptr, unsigned long int newlen, unsigned long int eltsize, void (*free_fn)(void *), unsigned char *errcode_ptr);
// trunnel_dynarray_setlen::free_fn_object
//
void free_fn_object(void *);
// trunnel_htonll
// file ../src/ext/trunnel/trunnel.c line 75
unsigned long int trunnel_htonll(unsigned long int a);
// trunnel_ntohll
// file ../src/ext/trunnel/trunnel.c line 86
unsigned long int trunnel_ntohll(unsigned long int a);
// trunnel_reallocarray
// file ../src/ext/trunnel/trunnel.c line 120
void * trunnel_reallocarray(void *a, unsigned long int x, unsigned long int y);
// trunnel_string_getstr
// file ../src/ext/trunnel/trunnel.c line 135
const char * trunnel_string_getstr(struct trunnel_string_st *str);
// trunnel_string_setlen
// file ../src/ext/trunnel/trunnel.c line 166
signed int trunnel_string_setlen(struct trunnel_string_st *str, unsigned long int newlen, unsigned char *errcode_ptr);
// trunnel_string_setstr0
// file ../src/ext/trunnel/trunnel.c line 148
signed int trunnel_string_setstr0(struct trunnel_string_st *str, const char *val, unsigned long int len, unsigned char *errcode_ptr);
// tv_mdiff
// file ../src/common/util.c line 1481
signed long int tv_mdiff(struct timeval *start, struct timeval *end);
// tv_to_msec
// file ../src/common/util.c line 1502
signed long int tv_to_msec(struct timeval *tv);
// tv_udiff
// file ../src/common/util.c line 1463
signed long int tv_udiff(struct timeval *start, struct timeval *end);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unescape_string
// file ../src/common/util.c line 2714
static const char * unescape_string(const char *s, char **result, unsigned long int *size_out);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_approx_time
// file ../src/common/util.c line 1917
void update_approx_time(signed long int now);
// usage
// file ../src/tools/tor-resolve.c line 332
static void usage(void);
// utime
// file /usr/include/utime.h line 45
extern signed int utime(const char *, struct utimbuf *);
// vasprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 207
static inline signed int vasprintf(char ** restrict __ptr, const char * restrict __fmt, void **__ap);
// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// worker_thread_has_work
// file ../src/common/workqueue.c line 160
static signed int worker_thread_has_work(struct workerthread_s *thread);
// worker_thread_main
// file ../src/common/workqueue.c line 170
static void worker_thread_main(void *thread_);
// worker_thread_main::1::1::1::1::update_fn_object
//
signed int update_fn_object(void *, void *);
// workerthread_new
// file ../src/common/workqueue.c line 249
static struct workerthread_s * workerthread_new(void *state, struct threadpool_s *pool, struct replyqueue_s *replyqueue);
// workqueue_entry_cancel
// file ../src/common/workqueue.c line 138
void * workqueue_entry_cancel(struct workqueue_entry_s *ent);
// workqueue_entry_free
// file ../src/common/workqueue.c line 115
static void workqueue_entry_free(struct workqueue_entry_s *ent);
// workqueue_entry_new
// file ../src/common/workqueue.c line 99
static struct workqueue_entry_s * workqueue_entry_new(signed int (*fn)(void *, void *), void (*reply_fn)(void *), void *arg);
// workqueue_entry_new::fn_object
//
signed int fn_object(void *, void *);
// workqueue_entry_new::reply_fn_object
//
void reply_fn_object(void *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file ../src/tools/../common/util.h line 329
signed long int write_all(signed int fd, const char *buf, unsigned long int count, signed int isSocket);
// write_bytes_to_file
// file ../src/common/util.c line 2521
signed int write_bytes_to_file(const char *fname, const char *str, unsigned long int len, signed int bin);
// write_bytes_to_file_impl
// file ../src/common/util.c line 2507
static signed int write_bytes_to_file_impl(const char *fname, const char *str, unsigned long int len, signed int flags);
// write_bytes_to_new_file
// file ../src/common/util.c line 2542
signed int write_bytes_to_new_file(const char *fname, const char *str, unsigned long int len, signed int bin);
// write_chunks_to_file
// file ../src/common/util.c line 2492
signed int write_chunks_to_file(const char *fname, const struct smartlist_t *chunks, signed int bin, signed int no_tempfile);
// write_chunks_to_file_impl
// file ../src/common/util.c line 2461
static signed int write_chunks_to_file_impl(const char *fname, const struct smartlist_t *chunks, signed int open_flags);
// write_ni
// file ../src/common/compat_threads.c line 93
static signed int write_ni(signed int fd, const void *buf, unsigned long int n);
// write_pidfile
// file ../src/common/util.c line 3565
void write_pidfile(char *filename);
// write_str_to_file
// file ../src/common/util.c line 2253
signed int write_str_to_file(const char *fname, const char *str, signed int bin);

struct anonymous
{
  // hte_next
  struct cached_getaddrinfo_item_t *hte_next;
  // hte_hash
  unsigned int hte_hash;
};

struct anonymous_15
{
  // hte_next
  struct digest256map_entry_t *hte_next;
  // hte_hash
  unsigned int hte_hash;
};

struct anonymous_14
{
  // hte_next
  struct digestmap_entry_t *hte_next;
  // hte_hash
  unsigned int hte_hash;
};

struct anonymous_13
{
  // hte_next
  struct strmap_entry_t *hte_next;
  // hte_hash
  unsigned int hte_hash;
};

struct anonymous_19
{
  // hte_next
  struct waitpid_callback_t *hte_next;
  // hte_hash
  unsigned int hte_hash;
};

struct anonymous_4
{
  // tqe_next
  struct workqueue_entry_s *tqe_next;
  // tqe_prev
  struct workqueue_entry_s **tqe_prev;
};

struct anonymous_3
{
  // tqh_first
  struct workqueue_entry_s *tqh_first;
  // tqh_last
  struct workqueue_entry_s **tqh_last;
};

struct anonymous_36
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_34
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_27
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_28
{
  // gregs
  signed long long int gregs[23l];
  // fpregs
  struct _libc_fpstate *fpregs;
  // __reserved1
  unsigned long long int __reserved1[8l];
};

struct anonymous_11
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_12
{
  // mask
  signed int mask;
  // ba
  unsigned int *ba;
};

struct anonymous_30
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_33
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_32
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_31
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_35
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_24
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_30 _kill;
  // _timer
  struct anonymous_31 _timer;
  // _rt
  struct anonymous_32 _rt;
  // _sigchld
  struct anonymous_33 _sigchld;
  // _sigfault
  struct anonymous_34 _sigfault;
  // _sigpoll
  struct anonymous_35 _sigpoll;
  // _sigsys
  struct anonymous_36 _sigsys;
};

struct anonymous_25
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_24 _sifields;
};

union anonymous_23
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_20
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous_26
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_25 *, void *);
};

union anonymous_21
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_6
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_7
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_8
{
  // __data
  struct anonymous_11 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_29
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_22
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct in6_addr
{
  // __in6_u
  union anonymous_6 __in6_u;
};

union anonymous_5
{
  // dummy_
  unsigned int dummy_;
  // in_addr
  struct in_addr in_addr;
  // in6_addr
  struct in6_addr in6_addr;
};

union anonymous_2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_9
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct anonymous_1
{
  // syscall_num
  signed int syscall_num;
  // syscall_name
  const char *syscall_name;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _libc_fpxreg
{
  // significand
  unsigned short int significand[4l];
  // exponent
  unsigned short int exponent;
  // padding
  unsigned short int padding[3l];
};

struct _libc_xmmreg
{
  // element
  unsigned int element[4l];
};

struct _libc_fpstate
{
  // cwd
  unsigned short int cwd;
  // swd
  unsigned short int swd;
  // ftw
  unsigned short int ftw;
  // fop
  unsigned short int fop;
  // rip
  unsigned long int rip;
  // rdp
  unsigned long int rdp;
  // mxcsr
  unsigned int mxcsr;
  // mxcr_mask
  unsigned int mxcr_mask;
  // _st
  struct _libc_fpxreg _st[8l];
  // _xmm
  struct _libc_xmmreg _xmm[16l];
  // padding
  unsigned int padding[24l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alert_sockets_s
{
  // read_fd
  signed int read_fd;
  // write_fd
  signed int write_fd;
  // alert_fn
  signed int (*alert_fn)(signed int);
  // drain_fn
  signed int (*drain_fn)(signed int);
};

struct cached_getaddrinfo_item_t
{
  // node
  struct anonymous node;
  // name
  char *name;
  // family
  signed int family;
  // res
  struct addrinfo *res;
  // err
  signed int err;
};

struct di_digest256_map_t
{
  // next
  struct di_digest256_map_t *next;
  // key
  unsigned char key[32l];
  // val
  void *val;
};

struct digest256map_entry_t
{
  // node
  struct anonymous_15 node;
  // val
  void *val;
  // key
  unsigned char key[32l];
};

struct digest256map_impl
{
  // hth_table
  struct digest256map_entry_t **hth_table;
  // hth_table_length
  unsigned int hth_table_length;
  // hth_n_entries
  unsigned int hth_n_entries;
  // hth_load_limit
  unsigned int hth_load_limit;
  // hth_prime_idx
  signed int hth_prime_idx;
};

struct digest256map_t
{
  // head
  struct digest256map_impl head;
};

struct digestmap_entry_t
{
  // node
  struct anonymous_14 node;
  // val
  void *val;
  // key
  char key[20l];
};

struct digestmap_impl
{
  // hth_table
  struct digestmap_entry_t **hth_table;
  // hth_table_length
  unsigned int hth_table_length;
  // hth_n_entries
  unsigned int hth_n_entries;
  // hth_load_limit
  unsigned int hth_load_limit;
  // hth_prime_idx
  signed int hth_prime_idx;
};

struct digestmap_t
{
  // head
  struct digestmap_impl head;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct getaddrinfo_cache
{
  // hth_table
  struct cached_getaddrinfo_item_t **hth_table;
  // hth_table_length
  unsigned int hth_table_length;
  // hth_n_entries
  unsigned int hth_n_entries;
  // hth_load_limit
  unsigned int hth_load_limit;
  // hth_prime_idx
  signed int hth_prime_idx;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous_20 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_23 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_21 ifr_ifrn;
  // ifr_ifru
  union anonymous_22 ifr_ifru;
};

struct log_severity_list_t
{
  // masks
  unsigned int masks[5l];
};

struct logfile_t
{
  // next
  struct logfile_t *next;
  // filename
  char *filename;
  // fd
  signed int fd;
  // seems_dead
  signed int seems_dead;
  // needs_close
  signed int needs_close;
  // is_temporary
  signed int is_temporary;
  // is_syslog
  signed int is_syslog;
  // callback
  void (*callback)(signed int, unsigned int, const char *);
  // severities
  struct log_severity_list_t *severities;
};

struct mallinfo
{
  // arena
  signed int arena;
  // ordblks
  signed int ordblks;
  // smblks
  signed int smblks;
  // hblks
  signed int hblks;
  // hblkhd
  signed int hblkhd;
  // usmblks
  signed int usmblks;
  // fsmblks
  signed int fsmblks;
  // uordblks
  signed int uordblks;
  // fordblks
  signed int fordblks;
  // keepcost
  signed int keepcost;
};

struct memarea_chunk_t
{
  // next_chunk
  struct memarea_chunk_t *next_chunk;
  // mem_size
  unsigned long int mem_size;
  // next_mem
  char *next_mem;
  // mem
  char mem[0l];
};

struct memarea_t
{
  // first
  struct memarea_chunk_t *first;
};

struct open_file_t
{
  // tempname
  char *tempname;
  // filename
  char *filename;
  // rename_on_close
  unsigned int rename_on_close : 1;
  // binary
  unsigned int binary : 1;
  // fd
  signed int fd;
  // stdio_file
  struct _IO_FILE *stdio_file;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pending_log_message_t
{
  // severity
  signed int severity;
  // domain
  unsigned int domain;
  // fullmsg
  char *fullmsg;
  // msg
  char *msg;
};

struct process_environment_t
{
  // windows_environment_block
  char *windows_environment_block;
  // unixoid_environment_block
  char **unixoid_environment_block;
};

struct process_handle_t
{
  // status
  signed int status;
  // stdout_pipe
  signed int stdout_pipe;
  // stderr_pipe
  signed int stderr_pipe;
  // stdout_handle
  struct _IO_FILE *stdout_handle;
  // stderr_handle
  struct _IO_FILE *stderr_handle;
  // pid
  signed int pid;
  // waitpid_cb
  struct waitpid_callback_t *waitpid_cb;
  // waitpid_exit_status
  signed int waitpid_exit_status;
};

struct process_map
{
  // hth_table
  struct waitpid_callback_t **hth_table;
  // hth_table_length
  unsigned int hth_table_length;
  // hth_n_entries
  unsigned int hth_n_entries;
  // hth_load_limit
  unsigned int hth_load_limit;
  // hth_prime_idx
  signed int hth_prime_idx;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ratelim_t
{
  // rate
  signed int rate;
  // last_allowed
  signed long int last_allowed;
  // n_calls_since_last_time
  signed int n_calls_since_last_time;
};

struct tor_mutex_t
{
  // mutex
  union anonymous_29 mutex;
};

struct replyqueue_s
{
  // lock
  struct tor_mutex_t lock;
  // answers
  struct anonymous_3 answers;
  // alert
  struct alert_sockets_s alert;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct sandbox_cfg_elem
{
  // implem
  enum anonymous_0 implem;
  // param
  struct smp_param *param;
  // next
  struct sandbox_cfg_elem *next;
};

struct scmp_arg_cmp
{
  // arg
  unsigned int arg;
  // op
  enum scmp_compare op;
  // datum_a
  unsigned long int datum_a;
  // datum_b
  unsigned long int datum_b;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_26 __sigaction_handler;
  // sa_mask
  struct anonymous_27 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sigaltstack
{
  // ss_sp
  void *ss_sp;
  // ss_flags
  signed int ss_flags;
  // ss_size
  unsigned long int ss_size;
};

struct sipkey
{
  // k0
  unsigned long int k0;
  // k1
  unsigned long int k1;
};

struct sized_chunk_t
{
  // bytes
  const char *bytes;
  // len
  unsigned long int len;
};

struct smartlist_t
{
  // list
  void **list;
  // num_used
  signed int num_used;
  // capacity
  signed int capacity;
};

struct smp_param
{
  // syscall
  signed int syscall;
  // value
  char *value;
  // value2
  char *value2;
  // prot
  signed int prot;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct strmap_entry_t
{
  // node
  struct anonymous_13 node;
  // val
  void *val;
  // key
  char *key;
};

struct strmap_impl
{
  // hth_table
  struct strmap_entry_t **hth_table;
  // hth_table_length
  unsigned int hth_table_length;
  // hth_n_entries
  unsigned int hth_n_entries;
  // hth_load_limit
  unsigned int hth_load_limit;
  // hth_prime_idx
  signed int hth_prime_idx;
};

struct strmap_t
{
  // head
  struct strmap_impl head;
};

struct tor_cond_t
{
  // cond
  union anonymous_8 cond;
};

struct threadpool_s
{
  // threads
  struct workerthread_s **threads;
  // condition
  struct tor_cond_t condition;
  // work
  struct anonymous_3 work;
  // generation
  unsigned int generation;
  // update_fn
  signed int (*update_fn)(void *, void *);
  // free_update_arg_fn
  void (*free_update_arg_fn)(void *);
  // update_args
  void **update_args;
  // n_threads
  signed int n_threads;
  // lock
  struct tor_mutex_t lock;
  // reply_queue
  struct replyqueue_s *reply_queue;
  // new_thread_state_fn
  void * (*new_thread_state_fn)(void *);
  // free_thread_state_fn
  void (*free_thread_state_fn)(void *);
  // new_thread_state_arg
  void *new_thread_state_arg;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct tor_addr_t
{
  // family
  unsigned short int family;
  // addr
  union anonymous_5 addr;
};

struct tor_addr_port_t
{
  // addr
  struct tor_addr_t addr;
  // port
  unsigned short int port;
};

struct tor_lockfile_t
{
  // filename
  char *filename;
  // fd
  signed int fd;
};

struct tor_mmap_t
{
  // data
  const char *data;
  // size
  unsigned long int size;
  // mapping_size
  unsigned long int mapping_size;
};

struct tor_pthread_data_t
{
  // func
  void (*func)(void *);
  // data
  void *data;
};

struct tor_weak_rng_t
{
  // state
  unsigned int state;
};

struct trunnel_string_st
{
  // n_
  unsigned long int n_;
  // allocated_
  unsigned long int allocated_;
  // elts_
  char *elts_;
};

struct ucontext
{
  // uc_flags
  unsigned long int uc_flags;
  // uc_link
  struct ucontext *uc_link;
  // uc_stack
  struct sigaltstack uc_stack;
  // uc_mcontext
  struct anonymous_28 uc_mcontext;
  // uc_sigmask
  struct anonymous_27 uc_sigmask;
  // __fpregs_mem
  struct _libc_fpstate __fpregs_mem;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};

struct waitpid_callback_t
{
  // node
  struct anonymous_19 node;
  // pid
  signed int pid;
  // userfn
  void (*userfn)(signed int, void *);
  // userdata
  void *userdata;
  // running
  unsigned int running;
};

struct workerthread_s
{
  // index
  signed int index;
  // in_pool
  struct threadpool_s *in_pool;
  // state
  void *state;
  // reply_queue
  struct replyqueue_s *reply_queue;
  // generation
  unsigned int generation;
};

struct workqueue_entry_s
{
  // next_work
  struct anonymous_4 next_work;
  // on_pool
  struct threadpool_s *on_pool;
  // pending
  unsigned char pending;
  // fn
  signed int (*fn)(void *, void *);
  // reply_fn
  void (*reply_fn)(void *);
  // arg
  void *arg;
};


// MONTH_NAMES
// file ../src/common/util.c line 1584
static const char *MONTH_NAMES[12l] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
// SYSCALLS_BY_NUMBER
// file ../src/common/linux_syscalls.inc line 7
static struct anonymous_1 SYSCALLS_BY_NUMBER[382l] = { { .syscall_num=-10026, .syscall_name="_llseek" },
    { .syscall_num=-10032, .syscall_name="_newselect" },
    { .syscall_num=156, .syscall_name="_sysctl" },
    { .syscall_num=43, .syscall_name="accept" },
    { .syscall_num=288, .syscall_name="accept4" },
    { .syscall_num=21, .syscall_name="access" },
    { .syscall_num=163, .syscall_name="acct" },
    { .syscall_num=248, .syscall_name="add_key" },
    { .syscall_num=159, .syscall_name="adjtimex" },
    { .syscall_num=183, .syscall_name="afs_syscall" },
    { .syscall_num=37, .syscall_name="alarm" },
    { .syscall_num=158, .syscall_name="arch_prctl" },
    { .syscall_num=-10002, .syscall_name="bdflush" },
    { .syscall_num=49, .syscall_name="bind" },
    { .syscall_num=-10003, .syscall_name="break" },
    { .syscall_num=12, .syscall_name="brk" },
    { .syscall_num=125, .syscall_name="capget" },
    { .syscall_num=126, .syscall_name="capset" },
    { .syscall_num=80, .syscall_name="chdir" },
    { .syscall_num=90, .syscall_name="chmod" },
    { .syscall_num=92, .syscall_name="chown" },
    { .syscall_num=-10004, .syscall_name="chown32" },
    { .syscall_num=161, .syscall_name="chroot" },
    { .syscall_num=305, .syscall_name="clock_adjtime" },
    { .syscall_num=229, .syscall_name="clock_getres" },
    { .syscall_num=228, .syscall_name="clock_gettime" },
    { .syscall_num=230, .syscall_name="clock_nanosleep" },
    { .syscall_num=227, .syscall_name="clock_settime" },
    { .syscall_num=56, .syscall_name="clone" },
    { .syscall_num=3, .syscall_name="close" },
    { .syscall_num=42, .syscall_name="connect" },
    { .syscall_num=85, .syscall_name="creat" },
    { .syscall_num=174, .syscall_name="create_module" },
    { .syscall_num=176, .syscall_name="delete_module" },
    { .syscall_num=32, .syscall_name="dup" },
    { .syscall_num=33, .syscall_name="dup2" },
    { .syscall_num=292, .syscall_name="dup3" },
    { .syscall_num=213, .syscall_name="epoll_create" },
    { .syscall_num=291, .syscall_name="epoll_create1" },
    { .syscall_num=233, .syscall_name="epoll_ctl" },
    { .syscall_num=214, .syscall_name="epoll_ctl_old" },
    { .syscall_num=281, .syscall_name="epoll_pwait" },
    { .syscall_num=232, .syscall_name="epoll_wait" },
    { .syscall_num=215, .syscall_name="epoll_wait_old" },
    { .syscall_num=284, .syscall_name="eventfd" },
    { .syscall_num=290, .syscall_name="eventfd2" },
    { .syscall_num=59, .syscall_name="execve" },
    { .syscall_num=60, .syscall_name="exit" },
    { .syscall_num=231, .syscall_name="exit_group" },
    { .syscall_num=269, .syscall_name="faccessat" },
    { .syscall_num=221, .syscall_name="fadvise64" },
    { .syscall_num=-10007, .syscall_name="fadvise64_64" },
    { .syscall_num=285, .syscall_name="fallocate" },
    { .syscall_num=300, .syscall_name="fanotify_init" },
    { .syscall_num=301, .syscall_name="fanotify_mark" },
    { .syscall_num=81, .syscall_name="fchdir" },
    { .syscall_num=91, .syscall_name="fchmod" },
    { .syscall_num=268, .syscall_name="fchmodat" },
    { .syscall_num=93, .syscall_name="fchown" },
    { .syscall_num=-10008, .syscall_name="fchown32" },
    { .syscall_num=260, .syscall_name="fchownat" },
    { .syscall_num=72, .syscall_name="fcntl" },
    { .syscall_num=-10009, .syscall_name="fcntl64" },
    { .syscall_num=75, .syscall_name="fdatasync" },
    { .syscall_num=193, .syscall_name="fgetxattr" },
    { .syscall_num=313, .syscall_name="finit_module" },
    { .syscall_num=196, .syscall_name="flistxattr" },
    { .syscall_num=73, .syscall_name="flock" },
    { .syscall_num=57, .syscall_name="fork" },
    { .syscall_num=199, .syscall_name="fremovexattr" },
    { .syscall_num=190, .syscall_name="fsetxattr" },
    { .syscall_num=5, .syscall_name="fstat" },
    { .syscall_num=-10010, .syscall_name="fstat64" },
    { .syscall_num=-10011, .syscall_name="fstatat64" },
    { .syscall_num=138, .syscall_name="fstatfs" },
    { .syscall_num=-10012, .syscall_name="fstatfs64" },
    { .syscall_num=74, .syscall_name="fsync" },
    { .syscall_num=-10013, .syscall_name="ftime" },
    { .syscall_num=77, .syscall_name="ftruncate" },
    { .syscall_num=-10014, .syscall_name="ftruncate64" },
    { .syscall_num=202, .syscall_name="futex" },
    { .syscall_num=261, .syscall_name="futimesat" },
    { .syscall_num=177, .syscall_name="get_kernel_syms" },
    { .syscall_num=239, .syscall_name="get_mempolicy" },
    { .syscall_num=274, .syscall_name="get_robust_list" },
    { .syscall_num=211, .syscall_name="get_thread_area" },
    { .syscall_num=309, .syscall_name="getcpu" },
    { .syscall_num=79, .syscall_name="getcwd" },
    { .syscall_num=78, .syscall_name="getdents" },
    { .syscall_num=217, .syscall_name="getdents64" },
    { .syscall_num=108, .syscall_name="getegid" },
    { .syscall_num=-10015, .syscall_name="getegid32" },
    { .syscall_num=107, .syscall_name="geteuid" },
    { .syscall_num=-10016, .syscall_name="geteuid32" },
    { .syscall_num=104, .syscall_name="getgid" },
    { .syscall_num=-10017, .syscall_name="getgid32" },
    { .syscall_num=115, .syscall_name="getgroups" },
    { .syscall_num=-10018, .syscall_name="getgroups32" },
    { .syscall_num=36, .syscall_name="getitimer" },
    { .syscall_num=52, .syscall_name="getpeername" },
    { .syscall_num=121, .syscall_name="getpgid" },
    { .syscall_num=111, .syscall_name="getpgrp" },
    { .syscall_num=39, .syscall_name="getpid" },
    { .syscall_num=181, .syscall_name="getpmsg" },
    { .syscall_num=110, .syscall_name="getppid" },
    { .syscall_num=140, .syscall_name="getpriority" },
    { .syscall_num=120, .syscall_name="getresgid" },
    { .syscall_num=-10019, .syscall_name="getresgid32" },
    { .syscall_num=118, .syscall_name="getresuid" },
    { .syscall_num=-10020, .syscall_name="getresuid32" },
    { .syscall_num=97, .syscall_name="getrlimit" },
    { .syscall_num=98, .syscall_name="getrusage" },
    { .syscall_num=124, .syscall_name="getsid" },
    { .syscall_num=51, .syscall_name="getsockname" },
    { .syscall_num=55, .syscall_name="getsockopt" },
    { .syscall_num=186, .syscall_name="gettid" },
    { .syscall_num=96, .syscall_name="gettimeofday" },
    { .syscall_num=102, .syscall_name="getuid" },
    { .syscall_num=-10021, .syscall_name="getuid32" },
    { .syscall_num=191, .syscall_name="getxattr" },
    { .syscall_num=-10022, .syscall_name="gtty" },
    { .syscall_num=-10023, .syscall_name="idle" },
    { .syscall_num=175, .syscall_name="init_module" },
    { .syscall_num=254, .syscall_name="inotify_add_watch" },
    { .syscall_num=253, .syscall_name="inotify_init" },
    { .syscall_num=294, .syscall_name="inotify_init1" },
    { .syscall_num=255, .syscall_name="inotify_rm_watch" },
    { .syscall_num=210, .syscall_name="io_cancel" },
    { .syscall_num=207, .syscall_name="io_destroy" },
    { .syscall_num=208, .syscall_name="io_getevents" },
    { .syscall_num=206, .syscall_name="io_setup" },
    { .syscall_num=209, .syscall_name="io_submit" },
    { .syscall_num=16, .syscall_name="ioctl" },
    { .syscall_num=173, .syscall_name="ioperm" },
    { .syscall_num=172, .syscall_name="iopl" },
    { .syscall_num=252, .syscall_name="ioprio_get" },
    { .syscall_num=251, .syscall_name="ioprio_set" },
    { .syscall_num=-10024, .syscall_name="ipc" },
    { .syscall_num=312, .syscall_name="kcmp" },
    { .syscall_num=246, .syscall_name="kexec_load" },
    { .syscall_num=250, .syscall_name="keyctl" },
    { .syscall_num=62, .syscall_name="kill" },
    { .syscall_num=94, .syscall_name="lchown" },
    { .syscall_num=-10025, .syscall_name="lchown32" },
    { .syscall_num=192, .syscall_name="lgetxattr" },
    { .syscall_num=86, .syscall_name="link" },
    { .syscall_num=265, .syscall_name="linkat" },
    { .syscall_num=50, .syscall_name="listen" },
    { .syscall_num=194, .syscall_name="listxattr" },
    { .syscall_num=195, .syscall_name="llistxattr" },
    { .syscall_num=-10027, .syscall_name="lock" },
    { .syscall_num=212, .syscall_name="lookup_dcookie" },
    { .syscall_num=198, .syscall_name="lremovexattr" },
    { .syscall_num=8, .syscall_name="lseek" },
    { .syscall_num=189, .syscall_name="lsetxattr" },
    { .syscall_num=6, .syscall_name="lstat" },
    { .syscall_num=-10028, .syscall_name="lstat64" },
    { .syscall_num=28, .syscall_name="madvise" },
    { .syscall_num=237, .syscall_name="mbind" },
    { .syscall_num=256, .syscall_name="migrate_pages" },
    { .syscall_num=27, .syscall_name="mincore" },
    { .syscall_num=83, .syscall_name="mkdir" },
    { .syscall_num=258, .syscall_name="mkdirat" },
    { .syscall_num=133, .syscall_name="mknod" },
    { .syscall_num=259, .syscall_name="mknodat" },
    { .syscall_num=149, .syscall_name="mlock" },
    { .syscall_num=151, .syscall_name="mlockall" },
    { .syscall_num=9, .syscall_name="mmap" },
    { .syscall_num=-10029, .syscall_name="mmap2" },
    { .syscall_num=154, .syscall_name="modify_ldt" },
    { .syscall_num=165, .syscall_name="mount" },
    { .syscall_num=279, .syscall_name="move_pages" },
    { .syscall_num=10, .syscall_name="mprotect" },
    { .syscall_num=-10030, .syscall_name="mpx" },
    { .syscall_num=245, .syscall_name="mq_getsetattr" },
    { .syscall_num=244, .syscall_name="mq_notify" },
    { .syscall_num=240, .syscall_name="mq_open" },
    { .syscall_num=243, .syscall_name="mq_timedreceive" },
    { .syscall_num=242, .syscall_name="mq_timedsend" },
    { .syscall_num=241, .syscall_name="mq_unlink" },
    { .syscall_num=25, .syscall_name="mremap" },
    { .syscall_num=71, .syscall_name="msgctl" },
    { .syscall_num=68, .syscall_name="msgget" },
    { .syscall_num=70, .syscall_name="msgrcv" },
    { .syscall_num=69, .syscall_name="msgsnd" },
    { .syscall_num=26, .syscall_name="msync" },
    { .syscall_num=150, .syscall_name="munlock" },
    { .syscall_num=152, .syscall_name="munlockall" },
    { .syscall_num=11, .syscall_name="munmap" },
    { .syscall_num=303, .syscall_name="name_to_handle_at" },
    { .syscall_num=35, .syscall_name="nanosleep" },
    { .syscall_num=262, .syscall_name="newfstatat" },
    { .syscall_num=180, .syscall_name="nfsservctl" },
    { .syscall_num=-10033, .syscall_name="nice" },
    { .syscall_num=-10034, .syscall_name="oldfstat" },
    { .syscall_num=-10035, .syscall_name="oldlstat" },
    { .syscall_num=-10036, .syscall_name="oldolduname" },
    { .syscall_num=-10037, .syscall_name="oldstat" },
    { .syscall_num=-10038, .syscall_name="olduname" },
    { .syscall_num=2, .syscall_name="open" },
    { .syscall_num=304, .syscall_name="open_by_handle_at" },
    { .syscall_num=257, .syscall_name="openat" },
    { .syscall_num=34, .syscall_name="pause" },
    { .syscall_num=298, .syscall_name="perf_event_open" },
    { .syscall_num=135, .syscall_name="personality" },
    { .syscall_num=22, .syscall_name="pipe" },
    { .syscall_num=293, .syscall_name="pipe2" },
    { .syscall_num=155, .syscall_name="pivot_root" },
    { .syscall_num=7, .syscall_name="poll" },
    { .syscall_num=271, .syscall_name="ppoll" },
    { .syscall_num=157, .syscall_name="prctl" },
    { .syscall_num=17, .syscall_name="pread64" },
    { .syscall_num=295, .syscall_name="preadv" },
    { .syscall_num=302, .syscall_name="prlimit64" },
    { .syscall_num=310, .syscall_name="process_vm_readv" },
    { .syscall_num=311, .syscall_name="process_vm_writev" },
    { .syscall_num=-10039, .syscall_name="prof" },
    { .syscall_num=-10040, .syscall_name="profil" },
    { .syscall_num=270, .syscall_name="pselect6" },
    { .syscall_num=101, .syscall_name="ptrace" },
    { .syscall_num=182, .syscall_name="putpmsg" },
    { .syscall_num=18, .syscall_name="pwrite64" },
    { .syscall_num=296, .syscall_name="pwritev" },
    { .syscall_num=178, .syscall_name="query_module" },
    { .syscall_num=179, .syscall_name="quotactl" },
    { .syscall_num=0, .syscall_name="read" },
    { .syscall_num=187, .syscall_name="readahead" },
    { .syscall_num=-10041, .syscall_name="readdir" },
    { .syscall_num=89, .syscall_name="readlink" },
    { .syscall_num=267, .syscall_name="readlinkat" },
    { .syscall_num=19, .syscall_name="readv" },
    { .syscall_num=169, .syscall_name="reboot" },
    { .syscall_num=45, .syscall_name="recvfrom" },
    { .syscall_num=299, .syscall_name="recvmmsg" },
    { .syscall_num=47, .syscall_name="recvmsg" },
    { .syscall_num=216, .syscall_name="remap_file_pages" },
    { .syscall_num=197, .syscall_name="removexattr" },
    { .syscall_num=82, .syscall_name="rename" },
    { .syscall_num=264, .syscall_name="renameat" },
    { .syscall_num=249, .syscall_name="request_key" },
    { .syscall_num=219, .syscall_name="restart_syscall" },
    { .syscall_num=84, .syscall_name="rmdir" },
    { .syscall_num=13, .syscall_name="rt_sigaction" },
    { .syscall_num=127, .syscall_name="rt_sigpending" },
    { .syscall_num=14, .syscall_name="rt_sigprocmask" },
    { .syscall_num=129, .syscall_name="rt_sigqueueinfo" },
    { .syscall_num=15, .syscall_name="rt_sigreturn" },
    { .syscall_num=130, .syscall_name="rt_sigsuspend" },
    { .syscall_num=128, .syscall_name="rt_sigtimedwait" },
    { .syscall_num=297, .syscall_name="rt_tgsigqueueinfo" },
    { .syscall_num=146, .syscall_name="sched_get_priority_max" },
    { .syscall_num=147, .syscall_name="sched_get_priority_min" },
    { .syscall_num=204, .syscall_name="sched_getaffinity" },
    { .syscall_num=143, .syscall_name="sched_getparam" },
    { .syscall_num=145, .syscall_name="sched_getscheduler" },
    { .syscall_num=148, .syscall_name="sched_rr_get_interval" },
    { .syscall_num=203, .syscall_name="sched_setaffinity" },
    { .syscall_num=142, .syscall_name="sched_setparam" },
    { .syscall_num=144, .syscall_name="sched_setscheduler" },
    { .syscall_num=24, .syscall_name="sched_yield" },
    { .syscall_num=185, .syscall_name="security" },
    { .syscall_num=23, .syscall_name="select" },
    { .syscall_num=66, .syscall_name="semctl" },
    { .syscall_num=64, .syscall_name="semget" },
    { .syscall_num=65, .syscall_name="semop" },
    { .syscall_num=220, .syscall_name="semtimedop" },
    { .syscall_num=40, .syscall_name="sendfile" },
    { .syscall_num=-10043, .syscall_name="sendfile64" },
    { .syscall_num=307, .syscall_name="sendmmsg" },
    { .syscall_num=46, .syscall_name="sendmsg" },
    { .syscall_num=44, .syscall_name="sendto" },
    { .syscall_num=238, .syscall_name="set_mempolicy" },
    { .syscall_num=273, .syscall_name="set_robust_list" },
    { .syscall_num=205, .syscall_name="set_thread_area" },
    { .syscall_num=218, .syscall_name="set_tid_address" },
    { .syscall_num=171, .syscall_name="setdomainname" },
    { .syscall_num=123, .syscall_name="setfsgid" },
    { .syscall_num=-10044, .syscall_name="setfsgid32" },
    { .syscall_num=122, .syscall_name="setfsuid" },
    { .syscall_num=-10045, .syscall_name="setfsuid32" },
    { .syscall_num=106, .syscall_name="setgid" },
    { .syscall_num=-10046, .syscall_name="setgid32" },
    { .syscall_num=116, .syscall_name="setgroups" },
    { .syscall_num=-10047, .syscall_name="setgroups32" },
    { .syscall_num=170, .syscall_name="sethostname" },
    { .syscall_num=38, .syscall_name="setitimer" },
    { .syscall_num=308, .syscall_name="setns" },
    { .syscall_num=109, .syscall_name="setpgid" },
    { .syscall_num=141, .syscall_name="setpriority" },
    { .syscall_num=114, .syscall_name="setregid" },
    { .syscall_num=-10048, .syscall_name="setregid32" },
    { .syscall_num=119, .syscall_name="setresgid" },
    { .syscall_num=-10049, .syscall_name="setresgid32" },
    { .syscall_num=117, .syscall_name="setresuid" },
    { .syscall_num=-10050, .syscall_name="setresuid32" },
    { .syscall_num=113, .syscall_name="setreuid" },
    { .syscall_num=-10051, .syscall_name="setreuid32" },
    { .syscall_num=160, .syscall_name="setrlimit" },
    { .syscall_num=112, .syscall_name="setsid" },
    { .syscall_num=54, .syscall_name="setsockopt" },
    { .syscall_num=164, .syscall_name="settimeofday" },
    { .syscall_num=105, .syscall_name="setuid" },
    { .syscall_num=-10052, .syscall_name="setuid32" },
    { .syscall_num=188, .syscall_name="setxattr" },
    { .syscall_num=-10053, .syscall_name="sgetmask" },
    { .syscall_num=30, .syscall_name="shmat" },
    { .syscall_num=31, .syscall_name="shmctl" },
    { .syscall_num=67, .syscall_name="shmdt" },
    { .syscall_num=29, .syscall_name="shmget" },
    { .syscall_num=48, .syscall_name="shutdown" },
    { .syscall_num=-10054, .syscall_name="sigaction" },
    { .syscall_num=131, .syscall_name="sigaltstack" },
    { .syscall_num=-10055, .syscall_name="signal" },
    { .syscall_num=282, .syscall_name="signalfd" },
    { .syscall_num=289, .syscall_name="signalfd4" },
    { .syscall_num=-10056, .syscall_name="sigpending" },
    { .syscall_num=-10057, .syscall_name="sigprocmask" },
    { .syscall_num=-10058, .syscall_name="sigreturn" },
    { .syscall_num=-10059, .syscall_name="sigsuspend" },
    { .syscall_num=41, .syscall_name="socket" },
    { .syscall_num=-10060, .syscall_name="socketcall" },
    { .syscall_num=53, .syscall_name="socketpair" },
    { .syscall_num=275, .syscall_name="splice" },
    { .syscall_num=-10061, .syscall_name="ssetmask" },
    { .syscall_num=4, .syscall_name="stat" },
    { .syscall_num=-10062, .syscall_name="stat64" },
    { .syscall_num=137, .syscall_name="statfs" },
    { .syscall_num=-10063, .syscall_name="statfs64" },
    { .syscall_num=-10064, .syscall_name="stime" },
    { .syscall_num=-10065, .syscall_name="stty" },
    { .syscall_num=168, .syscall_name="swapoff" },
    { .syscall_num=167, .syscall_name="swapon" },
    { .syscall_num=88, .syscall_name="symlink" },
    { .syscall_num=266, .syscall_name="symlinkat" },
    { .syscall_num=162, .syscall_name="sync" },
    { .syscall_num=277, .syscall_name="sync_file_range" },
    { .syscall_num=306, .syscall_name="syncfs" },
    { .syscall_num=139, .syscall_name="sysfs" },
    { .syscall_num=99, .syscall_name="sysinfo" },
    { .syscall_num=103, .syscall_name="syslog" },
    { .syscall_num=276, .syscall_name="tee" },
    { .syscall_num=234, .syscall_name="tgkill" },
    { .syscall_num=201, .syscall_name="time" },
    { .syscall_num=222, .syscall_name="timer_create" },
    { .syscall_num=226, .syscall_name="timer_delete" },
    { .syscall_num=225, .syscall_name="timer_getoverrun" },
    { .syscall_num=224, .syscall_name="timer_gettime" },
    { .syscall_num=223, .syscall_name="timer_settime" },
    { .syscall_num=283, .syscall_name="timerfd_create" },
    { .syscall_num=287, .syscall_name="timerfd_gettime" },
    { .syscall_num=286, .syscall_name="timerfd_settime" },
    { .syscall_num=100, .syscall_name="times" },
    { .syscall_num=200, .syscall_name="tkill" },
    { .syscall_num=76, .syscall_name="truncate" },
    { .syscall_num=-10066, .syscall_name="truncate64" },
    { .syscall_num=184, .syscall_name="tuxcall" },
    { .syscall_num=-10068, .syscall_name="ugetrlimit" },
    { .syscall_num=-10069, .syscall_name="ulimit" },
    { .syscall_num=95, .syscall_name="umask" },
    { .syscall_num=-10070, .syscall_name="umount" },
    { .syscall_num=166, .syscall_name="umount2" },
    { .syscall_num=63, .syscall_name="uname" },
    { .syscall_num=87, .syscall_name="unlink" },
    { .syscall_num=263, .syscall_name="unlinkat" },
    { .syscall_num=272, .syscall_name="unshare" },
    { .syscall_num=134, .syscall_name="uselib" },
    { .syscall_num=136, .syscall_name="ustat" },
    { .syscall_num=132, .syscall_name="utime" },
    { .syscall_num=280, .syscall_name="utimensat" },
    { .syscall_num=235, .syscall_name="utimes" },
    { .syscall_num=58, .syscall_name="vfork" },
    { .syscall_num=153, .syscall_name="vhangup" },
    { .syscall_num=-10071, .syscall_name="vm86" },
    { .syscall_num=-10072, .syscall_name="vm86old" },
    { .syscall_num=278, .syscall_name="vmsplice" },
    { .syscall_num=236, .syscall_name="vserver" },
    { .syscall_num=61, .syscall_name="wait4" },
    { .syscall_num=247, .syscall_name="waitid" },
    { .syscall_num=-10073, .syscall_name="waitpid" },
    { .syscall_num=1, .syscall_name="write" },
    { .syscall_num=20, .syscall_name="writev" },
    { .syscall_num=0, .syscall_name=(const char *)(void *)0 } };
// TOR_ISALNUM_TABLE
// file ../src/common/compat.c line 616
const unsigned int TOR_ISALNUM_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0x3ff0000, (const unsigned int)0x7fffffe, (const unsigned int)0x7fffffe, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISALPHA_TABLE
// file ../src/common/compat.c line 614
const unsigned int TOR_ISALPHA_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0, (const unsigned int)0x7fffffe, (const unsigned int)0x7fffffe, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISDIGIT_TABLE
// file ../src/common/compat.c line 621
const unsigned int TOR_ISDIGIT_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0x3ff0000, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISLOWER_TABLE
// file ../src/common/compat.c line 625
const unsigned int TOR_ISLOWER_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0x7fffffe, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISPRINT_TABLE
// file ../src/common/compat.c line 622
const unsigned int TOR_ISPRINT_TABLE[8l] = { (const unsigned int)0, 0xffffffff, 0xffffffff, (const unsigned int)0x7fffffff, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0x0 };
// TOR_ISSPACE_TABLE
// file ../src/common/compat.c line 618
const unsigned int TOR_ISSPACE_TABLE[8l] = { (const unsigned int)0x3e00, (const unsigned int)0x1, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISUPPER_TABLE
// file ../src/common/compat.c line 624
const unsigned int TOR_ISUPPER_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0, (const unsigned int)0x7fffffe, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_ISXDIGIT_TABLE
// file ../src/common/compat.c line 619
const unsigned int TOR_ISXDIGIT_TABLE[8l] = { (const unsigned int)0, (const unsigned int)0x3ff0000, (const unsigned int)0x7e, (const unsigned int)0x7e, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0, (const unsigned int)0 };
// TOR_TOLOWER_TABLE
// file ../src/common/compat.c line 648
const char TOR_TOLOWER_TABLE[256l] = { (const char)0, (const char)1, (const char)2, (const char)3, (const char)4, (const char)5, (const char)6, (const char)7, (const char)8, (const char)9, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)16, (const char)17, (const char)18, (const char)19, (const char)20, (const char)21, (const char)22, (const char)23, (const char)24, (const char)25, (const char)26, (const char)27, (const char)28, (const char)29, (const char)30, (const char)31, (const char)32, (const char)33, (const char)34, (const char)35, (const char)36, (const char)37, (const char)38, (const char)39, (const char)40, (const char)41, (const char)42, (const char)43, (const char)44, (const char)45, (const char)46, (const char)47, (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54, (const char)55, (const char)56, (const char)57, (const char)58, (const char)59, (const char)60, (const char)61, (const char)62, (const char)63, (const char)64, (const char)97, (const char)98, (const char)99, (const char)100, (const char)101, (const char)102, (const char)103, (const char)104, (const char)105, (const char)106, (const char)107, (const char)108, (const char)109, (const char)110, (const char)111, (const char)112, (const char)113, (const char)114, (const char)115, (const char)116, (const char)117, (const char)118, (const char)119, (const char)120, (const char)121, (const char)122, (const char)91, (const char)92, (const char)93, (const char)94, (const char)95, (const char)96, (const char)97, (const char)98, (const char)99, (const char)100, (const char)101, (const char)102, (const char)103, (const char)104, (const char)105, (const char)106, (const char)107, (const char)108, (const char)109, (const char)110, (const char)111, (const char)112, (const char)113, (const char)114, (const char)115, (const char)116, (const char)117, (const char)118, (const char)119, (const char)120, (const char)121, (const char)122, (const char)123, (const char)124, (const char)125, (const char)126, (const char)127, (const char)128, (const char)129, (const char)130, (const char)131, (const char)132, (const char)133, (const char)134, (const char)135, (const char)136, (const char)137, (const char)138, (const char)139, (const char)140, (const char)141, (const char)142, (const char)143, (const char)144, (const char)145, (const char)146, (const char)147, (const char)148, (const char)149, (const char)150, (const char)151, (const char)152, (const char)153, (const char)154, (const char)155, (const char)156, (const char)157, (const char)158, (const char)159, (const char)160, (const char)161, (const char)162, (const char)163, (const char)164, (const char)165, (const char)166, (const char)167, (const char)168, (const char)169, (const char)170, (const char)171, (const char)172, (const char)173, (const char)174, (const char)175, (const char)176, (const char)177, (const char)178, (const char)179, (const char)180, (const char)181, (const char)182, (const char)183, (const char)184, (const char)185, (const char)186, (const char)187, (const char)188, (const char)189, (const char)190, (const char)191, (const char)192, (const char)193, (const char)194, (const char)195, (const char)196, (const char)197, (const char)198, (const char)199, (const char)200, (const char)201, (const char)202, (const char)203, (const char)204, (const char)205, (const char)206, (const char)207, (const char)208, (const char)209, (const char)210, (const char)211, (const char)212, (const char)213, (const char)214, (const char)215, (const char)216, (const char)217, (const char)218, (const char)219, (const char)220, (const char)221, (const char)222, (const char)223, (const char)224, (const char)225, (const char)226, (const char)227, (const char)228, (const char)229, (const char)230, (const char)231, (const char)232, (const char)233, (const char)234, (const char)235, (const char)236, (const char)237, (const char)238, (const char)239, (const char)240, (const char)241, (const char)242, (const char)243, (const char)244, (const char)245, (const char)246, (const char)247, (const char)248, (const char)249, (const char)250, (const char)251, (const char)252, (const char)253, (const char)254, (const char)255 };
// TOR_TOUPPER_TABLE
// file ../src/common/compat.c line 630
const char TOR_TOUPPER_TABLE[256l] = { (const char)0, (const char)1, (const char)2, (const char)3, (const char)4, (const char)5, (const char)6, (const char)7, (const char)8, (const char)9, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)16, (const char)17, (const char)18, (const char)19, (const char)20, (const char)21, (const char)22, (const char)23, (const char)24, (const char)25, (const char)26, (const char)27, (const char)28, (const char)29, (const char)30, (const char)31, (const char)32, (const char)33, (const char)34, (const char)35, (const char)36, (const char)37, (const char)38, (const char)39, (const char)40, (const char)41, (const char)42, (const char)43, (const char)44, (const char)45, (const char)46, (const char)47, (const char)48, (const char)49, (const char)50, (const char)51, (const char)52, (const char)53, (const char)54, (const char)55, (const char)56, (const char)57, (const char)58, (const char)59, (const char)60, (const char)61, (const char)62, (const char)63, (const char)64, (const char)65, (const char)66, (const char)67, (const char)68, (const char)69, (const char)70, (const char)71, (const char)72, (const char)73, (const char)74, (const char)75, (const char)76, (const char)77, (const char)78, (const char)79, (const char)80, (const char)81, (const char)82, (const char)83, (const char)84, (const char)85, (const char)86, (const char)87, (const char)88, (const char)89, (const char)90, (const char)91, (const char)92, (const char)93, (const char)94, (const char)95, (const char)96, (const char)65, (const char)66, (const char)67, (const char)68, (const char)69, (const char)70, (const char)71, (const char)72, (const char)73, (const char)74, (const char)75, (const char)76, (const char)77, (const char)78, (const char)79, (const char)80, (const char)81, (const char)82, (const char)83, (const char)84, (const char)85, (const char)86, (const char)87, (const char)88, (const char)89, (const char)90, (const char)123, (const char)124, (const char)125, (const char)126, (const char)127, (const char)128, (const char)129, (const char)130, (const char)131, (const char)132, (const char)133, (const char)134, (const char)135, (const char)136, (const char)137, (const char)138, (const char)139, (const char)140, (const char)141, (const char)142, (const char)143, (const char)144, (const char)145, (const char)146, (const char)147, (const char)148, (const char)149, (const char)150, (const char)151, (const char)152, (const char)153, (const char)154, (const char)155, (const char)156, (const char)157, (const char)158, (const char)159, (const char)160, (const char)161, (const char)162, (const char)163, (const char)164, (const char)165, (const char)166, (const char)167, (const char)168, (const char)169, (const char)170, (const char)171, (const char)172, (const char)173, (const char)174, (const char)175, (const char)176, (const char)177, (const char)178, (const char)179, (const char)180, (const char)181, (const char)182, (const char)183, (const char)184, (const char)185, (const char)186, (const char)187, (const char)188, (const char)189, (const char)190, (const char)191, (const char)192, (const char)193, (const char)194, (const char)195, (const char)196, (const char)197, (const char)198, (const char)199, (const char)200, (const char)201, (const char)202, (const char)203, (const char)204, (const char)205, (const char)206, (const char)207, (const char)208, (const char)209, (const char)210, (const char)211, (const char)212, (const char)213, (const char)214, (const char)215, (const char)216, (const char)217, (const char)218, (const char)219, (const char)220, (const char)221, (const char)222, (const char)223, (const char)224, (const char)225, (const char)226, (const char)227, (const char)228, (const char)229, (const char)230, (const char)231, (const char)232, (const char)233, (const char)234, (const char)235, (const char)236, (const char)237, (const char)238, (const char)239, (const char)240, (const char)241, (const char)242, (const char)243, (const char)244, (const char)245, (const char)246, (const char)247, (const char)248, (const char)249, (const char)250, (const char)251, (const char)252, (const char)253, (const char)254, (const char)255 };
// WEEKDAY_NAMES
// file ../src/common/util.c line 1581
static const char *WEEKDAY_NAMES[7l] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// appname
// file ../src/common/log.c line 171
static char *appname = (char *)(void *)0;
// attr_detached
// file ../src/common/compat_pthreads.c line 48
static union pthread_attr_t attr_detached;
// attr_recursive
// file ../src/common/compat_pthreads.c line 87
static union anonymous_7 attr_recursive;
// bt_version
// file ../src/common/backtrace.c line 46
static char *bt_version = (char *)(void *)0;
// cached_approx_time
// file ../src/common/util.c line 1901
static signed long int cached_approx_time = (signed long int)0;
// cb_buf
// file ../src/common/backtrace.c line 53
static void *cb_buf[256l];
// cb_buf_mutex
// file ../src/common/backtrace.c line 55
static struct tor_mutex_t cb_buf_mutex;
// daemon_filedes
// file ../src/common/util.c line 3444
static signed int daemon_filedes[2l];
// days_per_month
// file ../src/common/util.c line 1522
static const signed int days_per_month[12l] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
// digest256map_impl_N_PRIMES
// file ../src/common/container.c line 1099
static unsigned int digest256map_impl_N_PRIMES = (unsigned int)(sizeof(unsigned int [24l]) /*96ul*/  / sizeof(unsigned int) /*4ul*/ );
// digest256map_impl_PRIMES
// file ../src/common/container.c line 1099
static unsigned int digest256map_impl_PRIMES[24l] = { (unsigned int)53, (unsigned int)97, (unsigned int)193, (unsigned int)389, (unsigned int)769, (unsigned int)1543, (unsigned int)3079, (unsigned int)6151, (unsigned int)12289, (unsigned int)24593, (unsigned int)49157, (unsigned int)98317, (unsigned int)196613, (unsigned int)393241, (unsigned int)786433, (unsigned int)1572869, (unsigned int)3145739, (unsigned int)6291469, (unsigned int)12582917, (unsigned int)25165843, (unsigned int)50331653, (unsigned int)100663319, (unsigned int)201326611, (unsigned int)402653189 };
// digestmap_impl_N_PRIMES
// file ../src/common/container.c line 1093
static unsigned int digestmap_impl_N_PRIMES = (unsigned int)(sizeof(unsigned int [24l]) /*96ul*/  / sizeof(unsigned int) /*4ul*/ );
// digestmap_impl_PRIMES
// file ../src/common/container.c line 1093
static unsigned int digestmap_impl_PRIMES[24l] = { (unsigned int)53, (unsigned int)97, (unsigned int)193, (unsigned int)389, (unsigned int)769, (unsigned int)1543, (unsigned int)3079, (unsigned int)6151, (unsigned int)12289, (unsigned int)24593, (unsigned int)49157, (unsigned int)98317, (unsigned int)196613, (unsigned int)393241, (unsigned int)786433, (unsigned int)1572869, (unsigned int)3145739, (unsigned int)6291469, (unsigned int)12582917, (unsigned int)25165843, (unsigned int)50331653, (unsigned int)100663319, (unsigned int)201326611, (unsigned int)402653189 };
// domain_list
// file ../src/common/log.c line 1221
static const char *domain_list[24l] = { "GENERAL", "CRYPTO", "NET", "CONFIG", "FS", "PROTOCOL", "MM", "HTTP", "APP", "CONTROL", "CIRC", "REND", "BUG", "DIR", "DIRSERV", "OR", "EDGE", "ACCT", "HIST", "HANDSHAKE", "HEARTBEAT", "CHANNEL", "SCHED", (const char *)(void *)0 };
// environ
// file /usr/include/unistd.h line 545
extern char **environ;
// filter_dynamic
// file ../src/common/sandbox.c line 107
static struct sandbox_cfg_elem *filter_dynamic = (struct sandbox_cfg_elem *)(void *)0;
// filter_func
// file ../src/common/sandbox.c line 958
static signed int (*filter_func[22l])(void *, struct sandbox_cfg_elem *);
// filter_func
// file ../src/common/sandbox.c line 958
static signed int (*filter_func[22l])(void *, struct sandbox_cfg_elem *) = { sb_rt_sigaction, sb_rt_sigprocmask, sb_time, sb_accept4, sb_mmap2, sb_open, sb_openat, sb__sysctl, sb_rename, sb_fcntl64, sb_epoll_ctl, sb_prctl, sb_mprotect, sb_flock, sb_futex, sb_mremap, sb_poll, sb_stat64, sb_socket, sb_setsockopt, sb_getsockopt, sb_socketpair };
// filter_nopar_gen
// file ../src/common/sandbox.c line 124
static signed int filter_nopar_gen[55l] = { 21, 12, 228, 3, 56, 213, 232, 290, 293, 22, 72, 5, -10010, 202, 217, 108, -10015, 107, -10016, 104, -10017, 97, 96, 186, 102, -10021, 8, -10026, 83, 151, 9, 11, 0, 15, 204, 46, 273, -10058, 4, 63, 61, 1, 20, 231, 60, 28, -10062, 49, 50, 42, 51, 47, 45, 44, 87 };
// finish_daemon_called
// file ../src/common/util.c line 3441
static signed int finish_daemon_called = 0;
// freelist
// file ../src/common/memarea.c line 114
static struct memarea_chunk_t *freelist = (struct memarea_chunk_t *)(void *)0;
// freelist_len
// file ../src/common/memarea.c line 111
static signed int freelist_len = 0;
// getaddrinfo_cache
// file ../src/common/sandbox.c line 1342
static struct getaddrinfo_cache getaddrinfo_cache = { .hth_table=(struct cached_getaddrinfo_item_t **)(void *)0, .hth_table_length=(unsigned int)0,
    .hth_n_entries=(unsigned int)0, .hth_load_limit=(unsigned int)0,
    .hth_prime_idx=-1 };
// getaddrinfo_cache_N_PRIMES
// file ../src/common/sandbox.c line 1347
static unsigned int getaddrinfo_cache_N_PRIMES = (unsigned int)(sizeof(unsigned int [24l]) /*96ul*/  / sizeof(unsigned int) /*4ul*/ );
// getaddrinfo_cache_PRIMES
// file ../src/common/sandbox.c line 1347
static unsigned int getaddrinfo_cache_PRIMES[24l] = { (unsigned int)53, (unsigned int)97, (unsigned int)193, (unsigned int)389, (unsigned int)769, (unsigned int)1543, (unsigned int)3079, (unsigned int)6151, (unsigned int)12289, (unsigned int)24593, (unsigned int)49157, (unsigned int)98317, (unsigned int)196613, (unsigned int)393241, (unsigned int)786433, (unsigned int)1572869, (unsigned int)3145739, (unsigned int)6291469, (unsigned int)12582917, (unsigned int)25165843, (unsigned int)50331653, (unsigned int)100663319, (unsigned int)201326611, (unsigned int)402653189 };
// log_domains_are_logged
// file ../src/common/log.c line 110
static signed int log_domains_are_logged = 0;
// log_global_min_severity_
// file ../src/common/log.c line 156
signed int log_global_min_severity_ = 5;
// log_mutex
// file ../src/common/log.c line 103
static struct tor_mutex_t log_mutex;
// log_mutex_initialized
// file ../src/common/log.c line 105
static signed int log_mutex_initialized = 0;
// log_time_granularity
// file ../src/common/log.c line 186
static signed int log_time_granularity = 1;
// logfiles
// file ../src/common/log.c line 108
static struct logfile_t *logfiles = (struct logfile_t *)(void *)0;
// main_thread_id
// file ../src/common/compat_threads.c line 74
static unsigned long int main_thread_id = (unsigned long int)-1;
// n_sigsafe_log_fds
// file ../src/common/log.c line 520
static signed int n_sigsafe_log_fds = 1;
// n_sockets_open
// file ../src/common/compat.c line 1042
static signed int n_sockets_open = 0;
// passwd_cached
// file ../src/common/compat.c line 1740
static struct passwd *passwd_cached = (struct passwd *)(void *)0;
// pending_cb_messages
// file ../src/common/log.c line 128
static struct smartlist_t *pending_cb_messages = (struct smartlist_t *)(void *)0;
// pending_startup_messages
// file ../src/common/log.c line 132
static struct smartlist_t *pending_startup_messages = (struct smartlist_t *)(void *)0;
// pending_startup_messages_len
// file ../src/common/log.c line 137
static unsigned long int pending_startup_messages_len;
// process_map
// file ../src/common/util_process.c line 61
static struct process_map process_map = { .hth_table=(struct waitpid_callback_t **)(void *)0, .hth_table_length=(unsigned int)0,
    .hth_n_entries=(unsigned int)0, .hth_load_limit=(unsigned int)0,
    .hth_prime_idx=-1 };
// process_map_N_PRIMES
// file ../src/common/util_process.c line 65
static unsigned int process_map_N_PRIMES = (unsigned int)(sizeof(unsigned int [24l]) /*96ul*/  / sizeof(unsigned int) /*4ul*/ );
// process_map_PRIMES
// file ../src/common/util_process.c line 65
static unsigned int process_map_PRIMES[24l] = { (unsigned int)53, (unsigned int)97, (unsigned int)193, (unsigned int)389, (unsigned int)769, (unsigned int)1543, (unsigned int)3079, (unsigned int)6151, (unsigned int)12289, (unsigned int)24593, (unsigned int)49157, (unsigned int)98317, (unsigned int)196613, (unsigned int)393241, (unsigned int)786433, (unsigned int)1572869, (unsigned int)3145739, (unsigned int)6291469, (unsigned int)12582917, (unsigned int)25165843, (unsigned int)50331653, (unsigned int)100663319, (unsigned int)201326611, (unsigned int)402653189 };
// queue_startup_messages
// file ../src/common/log.c line 141
static signed int queue_startup_messages = 1;
// sandbox_active
// file ../src/common/sandbox.c line 105
static signed int sandbox_active = 0;
// sandbox_getaddrinfo_cache_disabled
// file ../src/common/sandbox.c line 1353
static signed int sandbox_getaddrinfo_cache_disabled = 0;
// sigsafe_log_fds
// file ../src/common/log.c line 518
static signed int sigsafe_log_fds[8l] = { 2, 0, 0, 0, 0, 0, 0, 0 };
// socket_accounting_mutex
// file ../src/common/compat.c line 1045
static struct tor_mutex_t *socket_accounting_mutex = (struct tor_mutex_t *)(void *)0;
// start_daemon_called
// file ../src/common/util.c line 3439
static signed int start_daemon_called = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// strmap_impl_N_PRIMES
// file ../src/common/container.c line 1088
static unsigned int strmap_impl_N_PRIMES = (unsigned int)(sizeof(unsigned int [24l]) /*96ul*/  / sizeof(unsigned int) /*4ul*/ );
// strmap_impl_PRIMES
// file ../src/common/container.c line 1088
static unsigned int strmap_impl_PRIMES[24l] = { (unsigned int)53, (unsigned int)97, (unsigned int)193, (unsigned int)389, (unsigned int)769, (unsigned int)1543, (unsigned int)3079, (unsigned int)6151, (unsigned int)12289, (unsigned int)24593, (unsigned int)49157, (unsigned int)98317, (unsigned int)196613, (unsigned int)393241, (unsigned int)786433, (unsigned int)1572869, (unsigned int)3145739, (unsigned int)6291469, (unsigned int)12582917, (unsigned int)25165843, (unsigned int)50331653, (unsigned int)100663319, (unsigned int)201326611, (unsigned int)402653189 };
// syscall_cb_buf
// file ../src/common/sandbox.c line 1586
static void *syscall_cb_buf[256l];
// syslog_count
// file ../src/common/log.c line 115
static signed int syslog_count = 0;
// the_siphash_key
// file ../src/ext/csiphash.c line 163
static struct sipkey the_siphash_key;
// the_siphash_key_is_set
// file ../src/ext/csiphash.c line 162
static signed int the_siphash_key_is_set = 0;
// threads_initialized
// file ../src/common/compat_pthreads.c line 50
static signed int threads_initialized = 0;
// uname_result
// file ../src/common/compat.c line 2452
static char uname_result[256l];
// uname_result_is_set
// file ../src/common/compat.c line 2454
static signed int uname_result_is_set = 0;

// TOR_ISALPHA
// file ../src/common/compat.h line 329
static inline signed int TOR_ISALPHA(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISALPHA_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISDIGIT
// file ../src/common/compat.h line 332
static inline signed int TOR_ISDIGIT(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISDIGIT_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISDIGIT_link1
// file ../src/common/compat.h line 332
static inline signed int TOR_ISDIGIT_link1(char c_link1)
{
  unsigned char u_link1 = (unsigned char)c_link1;
  return (signed int)!(!((TOR_ISDIGIT_TABLE[(signed long int)((signed int)u_link1 >> 5 & 7)] & 1u << ((signed int)u_link1 & 31)) != 0u));
}

// TOR_ISPRINT
// file ../src/common/compat.h line 334
static inline signed int TOR_ISPRINT(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISPRINT_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISSPACE
// file ../src/common/compat.h line 331
static inline signed int TOR_ISSPACE(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISSPACE_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISSPACE_link1
// file ../src/common/compat.h line 331
static inline signed int TOR_ISSPACE_link1(char c_link1)
{
  unsigned char u_link1 = (unsigned char)c_link1;
  return (signed int)!(!((TOR_ISSPACE_TABLE[(signed long int)((signed int)u_link1 >> 5 & 7)] & 1u << ((signed int)u_link1 & 31)) != 0u));
}

// TOR_ISUPPER
// file ../src/common/compat.h line 336
static inline signed int TOR_ISUPPER(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISUPPER_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISXDIGIT
// file ../src/common/compat.h line 333
static inline signed int TOR_ISXDIGIT(char c)
{
  unsigned char u = (unsigned char)c;
  return (signed int)!(!((TOR_ISXDIGIT_TABLE[(signed long int)((signed int)u >> 5 & 7)] & 1u << ((signed int)u & 31)) != 0u));
}

// TOR_ISXDIGIT_link1
// file ../src/common/compat.h line 333
static inline signed int TOR_ISXDIGIT_link1(char c_link1)
{
  unsigned char u_link1 = (unsigned char)c_link1;
  return (signed int)!(!((TOR_ISXDIGIT_TABLE[(signed long int)((signed int)u_link1 >> 5 & 7)] & 1u << ((signed int)u_link1 & 31)) != 0u));
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2)
{
  signed long int return_value___builtin_bswap32_1_link2;
  return_value___builtin_bswap32_1_link2=__builtin_bswap32((signed long int)__bsx_link2);
  return (unsigned int)return_value___builtin_bswap32_1_link2;
}

// __bswap_32_link3
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link3(unsigned int __bsx_link3)
{
  signed long int return_value___builtin_bswap32_1_link3;
  return_value___builtin_bswap32_1_link3=__builtin_bswap32((signed long int)__bsx_link3);
  return (unsigned int)return_value___builtin_bswap32_1_link3;
}

// _cmp_double
// file ../src/common/container.c line 1436
static signed int _cmp_double(const void *_a, const void *_b)
{
  const double *a = (const double *)_a;
  const double *b = (const double *)_b;
  if(*a < *b)
    return -1;

  else
    if(*a > *b)
      return 1;

    else
      return 0;
}

// _cmp_int
// file ../src/common/container.c line 1434
static signed int _cmp_int(const void *_a, const void *_b)
{
  const signed int *a = (const signed int *)_a;
  const signed int *b = (const signed int *)_b;
  if(!(*a >= *b))
    return -1;

  else
    if(!(*b >= *a))
      return 1;

    else
      return 0;
}

// _cmp_int32_t
// file ../src/common/container.c line 1438
static signed int _cmp_int32_t(const void *_a, const void *_b)
{
  const signed int *a = (const signed int *)_a;
  const signed int *b = (const signed int *)_b;
  if(!(*a >= *b))
    return -1;

  else
    if(!(*b >= *a))
      return 1;

    else
      return 0;
}

// _cmp_long
// file ../src/common/container.c line 1439
static signed int _cmp_long(const void *_a, const void *_b)
{
  const signed long int *a = (const signed long int *)_a;
  const signed long int *b = (const signed long int *)_b;
  if(!(*a >= *b))
    return -1;

  else
    if(!(*b >= *a))
      return 1;

    else
      return 0;
}

// _cmp_time_t
// file ../src/common/container.c line 1435
static signed int _cmp_time_t(const void *_a, const void *_b)
{
  const signed long int *a = (const signed long int *)_a;
  const signed long int *b = (const signed long int *)_b;
  if(!(*a >= *b))
    return -1;

  else
    if(!(*b >= *a))
      return 1;

    else
      return 0;
}

// _cmp_uint32_t
// file ../src/common/container.c line 1437
static signed int _cmp_uint32_t(const void *_a, const void *_b)
{
  const unsigned int *a = (const unsigned int *)_a;
  const unsigned int *b = (const unsigned int *)_b;
  if(!(*a >= *b))
    return -1;

  else
    if(!(*b >= *a))
      return 1;

    else
      return 0;
}

// abort_writing_to_file
// file ../src/common/util.c line 2451
signed int abort_writing_to_file(struct open_file_t *file_data)
{
  signed int return_value_finish_writing_to_file_impl_1;
  return_value_finish_writing_to_file_impl_1=finish_writing_to_file_impl(file_data, 1);
  return return_value_finish_writing_to_file_impl_1;
}

// add_callback_log
// file ../src/common/log.c line 967
signed int add_callback_log(const struct log_severity_list_t *severity, void (*cb)(signed int, unsigned int, const char *))
{
  struct logfile_t *lf;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct logfile_t) /*56ul*/ );
  lf = (struct logfile_t *)return_value_tor_malloc_zero__1;
  lf->fd = -1;
  void *return_value_tor_memdup__2;
  return_value_tor_memdup__2=tor_memdup_((const void *)severity, sizeof(struct log_severity_list_t) /*20ul*/ );
  lf->severities = (struct log_severity_list_t *)return_value_tor_memdup__2;
  lf->filename=tor_strdup_("<callback>");
  lf->callback = cb;
  lf->next = logfiles;
  tor_mutex_acquire(&log_mutex);
  logfiles = lf;
  log_global_min_severity_=get_min_log_level();
  tor_mutex_release(&log_mutex);
  return 0;
}

// add_file_log
// file ../src/common/log.c line 1136
signed int add_file_log(const struct log_severity_list_t *severity, const char *filename, const signed int truncate)
{
  signed int fd;
  struct logfile_t *lf;
  signed int open_flags = 01 | 0100;
  open_flags = open_flags | (truncate != 0 ? 01000 : 02000);
  fd=tor_open_cloexec(filename, open_flags, (unsigned int)0644);
  if(!(fd >= 0))
    return -1;

  else
  {
    signed int return_value_tor_fd_seekend_1;
    return_value_tor_fd_seekend_1=tor_fd_seekend(fd);
    if(!(return_value_tor_fd_seekend_1 >= 0))
    {
      close(fd);
      return -1;
    }

    else
    {
      tor_mutex_acquire(&log_mutex);
      add_stream_log_impl(severity, filename, fd);
      logfiles->needs_close = 1;
      lf = logfiles;
      log_global_min_severity_=get_min_log_level();
      signed int return_value_log_tor_version_2;
      return_value_log_tor_version_2=log_tor_version(lf, 0);
      if(!(return_value_log_tor_version_2 >= 0))
        delete_log(lf);

      tor_mutex_release(&log_mutex);
      return 0;
    }
  }
}

// add_laplace_noise
// file ../src/common/util.c line 556
signed long int add_laplace_noise(signed long int signal, double random, double delta_f, double epsilon)
{
  signed long int noise;
  noise=sample_laplace_distribution(0.0, delta_f / epsilon, random);
  if(noise >= 1l && !(9223372036854775807L + -noise >= signal))
    return 9223372036854775807L;

  else
    if(!(noise >= 0l) && !(signal >= -9223372036854775808l + -noise))
      return -9223372036854775807L - (signed long int)1;

    else
      return signal + noise;
}

// add_noparam_filter
// file ../src/common/sandbox.c line 1498
static signed int add_noparam_filter(void *ctx)
{
  unsigned int i;
  signed int rc = 0;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 55ul); i = i + 1u)
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, filter_nopar_gen[(signed long int)i], (unsigned int)0);
    if(!(rc == 0))
    {
      log_fn_(3, 1u << 12, "add_noparam_filter", "(Sandbox) failed to add syscall index %d (NR=%d), received libseccomp error %d", i, filter_nopar_gen[(signed long int)i], rc);
      return rc;
    }

  }
  return 0;
}

// add_param_filter
// file ../src/common/sandbox.c line 1476
static signed int add_param_filter(void *ctx, struct sandbox_cfg_elem *cfg)
{
  unsigned int i;
  signed int rc = 0;
  i = (unsigned int)0;
  if(!((unsigned long int)i >= 22ul))
  {
    signed int return_value;
    return_value=filter_func[(signed long int)i](ctx, cfg);
    if(!(return_value == 0))
    {
      log_fn_(3, 1u << 12, "add_param_filter", "(Sandbox) failed to add syscall %d, received libseccomp error %d", i, rc);
      return rc;
    }

    i = i + 1u;
  }

  return 0;
}

// add_stream_log
// file ../src/tools/../common/torlog.h line 133
void add_stream_log(const struct log_severity_list_t *severity, const char *name, signed int fd)
{
  tor_mutex_acquire(&log_mutex);
  add_stream_log_impl(severity, name, fd);
  tor_mutex_release(&log_mutex);
}

// add_stream_log_impl
// file ../src/common/log.c line 895
static void add_stream_log_impl(const struct log_severity_list_t *severity, const char *name, signed int fd)
{
  struct logfile_t *lf;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct logfile_t) /*56ul*/ );
  lf = (struct logfile_t *)return_value_tor_malloc_zero__1;
  lf->fd = fd;
  lf->filename=tor_strdup_(name);
  void *return_value_tor_memdup__2;
  return_value_tor_memdup__2=tor_memdup_((const void *)severity, sizeof(struct log_severity_list_t) /*20ul*/ );
  lf->severities = (struct log_severity_list_t *)return_value_tor_memdup__2;
  lf->next = logfiles;
  logfiles = lf;
  log_global_min_severity_=get_min_log_level();
}

// add_syslog_log
// file ../src/common/log.c line 1172
signed int add_syslog_log(const struct log_severity_list_t *severity)
{
  struct logfile_t *lf;
  signed int tmp_post_1 = syslog_count;
  syslog_count = syslog_count + 1;
  if(tmp_post_1 == 0)
    openlog("Tor", 0x01 | 0x08, 3 << 3);

  void *return_value_tor_malloc_zero__2;
  return_value_tor_malloc_zero__2=tor_malloc_zero_(sizeof(struct logfile_t) /*56ul*/ );
  lf = (struct logfile_t *)return_value_tor_malloc_zero__2;
  lf->fd = -1;
  void *return_value_tor_memdup__3;
  return_value_tor_memdup__3=tor_memdup_((const void *)severity, sizeof(struct log_severity_list_t) /*20ul*/ );
  lf->severities = (struct log_severity_list_t *)return_value_tor_memdup__3;
  lf->filename=tor_strdup_("<syslog>");
  lf->is_syslog = 1;
  tor_mutex_acquire(&log_mutex);
  lf->next = logfiles;
  logfiles = lf;
  log_global_min_severity_=get_min_log_level();
  tor_mutex_release(&log_mutex);
  return 0;
}

// add_temp_log
// file ../src/common/log.c line 951
void add_temp_log(signed int min_severity)
{
  struct log_severity_list_t *s;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct log_severity_list_t) /*20ul*/ );
  s = (struct log_severity_list_t *)return_value_tor_malloc_zero__1;
  set_log_severity_config(min_severity, 3, s);
  tor_mutex_acquire(&log_mutex);
  signed int return_value_fileno_2;
  return_value_fileno_2=fileno(stdout);
  add_stream_log_impl(s, "<temp>", return_value_fileno_2);
  if(!(s == ((struct log_severity_list_t *)NULL)))
  {
    free((void *)s);
    s = (struct log_severity_list_t *)(void *)0;
  }

  logfiles->is_temporary = 1;
  tor_mutex_release(&log_mutex);
}

// addr_mask_get_bits
// file ../src/common/address.c line 1739
signed int addr_mask_get_bits(unsigned int mask)
{
  signed int i;
  if(mask == 0u)
    return 0;

  else
    if(mask == 0xFFFFFFFFu)
      return 32;

    else
    {
      i = 1;
      for( ; !(i >= 33); i = i + 1)
        if(mask == ~((1u << 32 + -i) + 4294967295u))
          return i;

      return -1;
    }
}

// addr_port_lookup
// file ../src/common/address.h line 262
signed int addr_port_lookup(signed int severity, const char *addrport, char **address, unsigned int *addr, unsigned short int *port_out)
{
  const char *colon;
  char *address_ = (char *)(void *)0;
  signed int port_;
  signed int ok = 1;
  if(addrport == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1691, "addr_port_lookup", "addrport");
    abort();
  }

  colon=strrchr(addrport, 58);
  if(!(colon == ((const char *)NULL)))
  {
    address_=tor_strndup_(addrport, (unsigned long int)(colon - addrport));
    signed long int return_value_tor_parse_long_1;
    return_value_tor_parse_long_1=tor_parse_long(colon + (signed long int)1, 10, (signed long int)1, (signed long int)65535, (signed int *)(void *)0, (char **)(void *)0);
    port_ = (signed int)return_value_tor_parse_long_1;
    if(port_ == 0)
    {
      const char *return_value_escaped_2;
      return_value_escaped_2=escaped(colon + (signed long int)1);
      log_fn_(severity, 1u << 0, "addr_port_lookup", "Port %s out of range", return_value_escaped_2);
      ok = 0;
    }

    if(port_out == ((unsigned short int *)NULL))
    {
      char *esc_addrport;
      esc_addrport=esc_for_log(addrport);
      const char *return_value_escaped_3;
      return_value_escaped_3=escaped(colon + (signed long int)1);
      log_fn_(severity, 1u << 0, "addr_port_lookup", "Port %s given on %s when not required", return_value_escaped_3, esc_addrport);
      if(!(esc_addrport == ((char *)NULL)))
      {
        free((void *)esc_addrport);
        esc_addrport = (char *)(void *)0;
      }

      ok = 0;
    }

  }

  else
  {
    address_=tor_strdup_(addrport);
    port_ = 0;
  }
  if(!(addr == ((unsigned int *)NULL)))
  {
    signed int return_value_tor_lookup_hostname_5;
    return_value_tor_lookup_hostname_5=tor_lookup_hostname(address_, addr);
    if(!(return_value_tor_lookup_hostname_5 == 0))
    {
      const char *return_value_escaped_4;
      return_value_escaped_4=escaped(address_);
      log_fn_(severity, 1u << 2, "addr_port_lookup", "Couldn't look up %s", return_value_escaped_4);
      ok = 0;
      *addr = (unsigned int)0;
    }

  }

  if(!(address == ((char **)NULL)) && !(ok == 0))
    *address = address_;

  else
  {
    if(!(address == ((char **)NULL)))
      *address = (char *)(void *)0;

    if(!(address_ == ((char *)NULL)))
    {
      free((void *)address_);
      address_ = (char *)(void *)0;
    }

  }
  if(!(port_out == ((unsigned short int *)NULL)))
    *port_out = (unsigned short int)(ok != 0 ? (signed int)(unsigned short int)port_ : 0);

  return ok != 0 ? 0 : -1;
}

// alert_sockets_close
// file ../src/common/compat_threads.c line 293
void alert_sockets_close(struct alert_sockets_s *socks)
{
  if(socks->alert_fn == sock_alert)
  {
    tor_close_socket(socks->read_fd);
    tor_close_socket(socks->write_fd);
  }

  else
  {
    close(socks->read_fd);
    if(!(socks->write_fd == socks->read_fd))
      close(socks->write_fd);

  }
  socks->write_fd = -1;
  socks->read_fd = socks->write_fd;
}

// alert_sockets_create
// file ../src/common/compat_threads.c line 210
signed int alert_sockets_create(struct alert_sockets_s *socks_out, unsigned int flags)
{
  signed int socks[2l] = { -1, -1 };
  if((1u & flags) == 0u)
    socks[(signed long int)0]=eventfd(0, 524288 | 2048);

  _Bool tmp_if_expr_3;
  signed int return_value_set_socket_nonblocking_2;
  if(!(socks[0l] >= 0))
  {
    if((2u & flags) == 0u)
    {
      socks[(signed long int)0]=eventfd(0, 0);
      if(socks[0l] >= 0)
      {
        signed int return_value_fcntl_1;
        return_value_fcntl_1=fcntl(socks[(signed long int)0], 2, 1);
        if(!(return_value_fcntl_1 >= 0))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_set_socket_nonblocking_2=set_socket_nonblocking(socks[(signed long int)0]);
          tmp_if_expr_3 = return_value_set_socket_nonblocking_2 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          close(socks[(signed long int)0]);
          return -1;
        }

      }

    }

  }

  signed int return_value_pipe2_4;
  signed int return_value_pipe_12;
  _Bool tmp_if_expr_7;
  signed int return_value_fcntl_6;
  _Bool tmp_if_expr_9;
  signed int return_value_set_socket_nonblocking_8;
  _Bool tmp_if_expr_11;
  signed int return_value_set_socket_nonblocking_10;
  signed int return_value_tor_socketpair_16;
  _Bool tmp_if_expr_15;
  signed int return_value_set_socket_nonblocking_14;
  if(socks[0l] >= 0)
  {
    socks_out->write_fd = socks[(signed long int)0];
    socks_out->read_fd = socks_out->write_fd;
    socks_out->alert_fn = eventfd_alert;
    socks_out->drain_fn = eventfd_drain;
    return 0;
  }

  else
    if((4u & flags) == 0u)
    {
      return_value_pipe2_4=pipe2(socks, 04000 | 02000000);
      if(!(return_value_pipe2_4 == 0))
        goto __CPROVER_DUMP_L7;

      socks_out->read_fd = socks[(signed long int)0];
      socks_out->write_fd = socks[(signed long int)1];
      socks_out->alert_fn = pipe_alert;
      socks_out->drain_fn = pipe_drain;
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      if((8u & flags) == 0u)
      {
        return_value_pipe_12=pipe(socks);
        if(return_value_pipe_12 == 0)
        {
          signed int return_value_fcntl_5;
          return_value_fcntl_5=fcntl(socks[(signed long int)0], 2, 1);
          if(!(return_value_fcntl_5 >= 0))
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_fcntl_6=fcntl(socks[(signed long int)1], 2, 1);
            tmp_if_expr_7 = return_value_fcntl_6 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_set_socket_nonblocking_8=set_socket_nonblocking(socks[(signed long int)0]);
            tmp_if_expr_9 = return_value_set_socket_nonblocking_8 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_set_socket_nonblocking_10=set_socket_nonblocking(socks[(signed long int)1]);
            tmp_if_expr_11 = return_value_set_socket_nonblocking_10 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
          {
            close(socks[(signed long int)0]);
            close(socks[(signed long int)1]);
            return -1;
          }

          socks_out->read_fd = socks[(signed long int)0];
          socks_out->write_fd = socks[(signed long int)1];
          socks_out->alert_fn = pipe_alert;
          socks_out->drain_fn = pipe_drain;
          return 0;
        }

      }

      if((16u & flags) == 0u)
      {
        return_value_tor_socketpair_16=tor_socketpair(1, 1, 0, socks);
        if(return_value_tor_socketpair_16 == 0)
        {
          signed int return_value_set_socket_nonblocking_13;
          return_value_set_socket_nonblocking_13=set_socket_nonblocking(socks[(signed long int)0]);
          if(!(return_value_set_socket_nonblocking_13 >= 0))
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_set_socket_nonblocking_14=set_socket_nonblocking(socks[(signed long int)1]);
            tmp_if_expr_15 = return_value_set_socket_nonblocking_14 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_15)
          {
            tor_close_socket(socks[(signed long int)0]);
            tor_close_socket(socks[(signed long int)1]);
            return -1;
          }

          socks_out->read_fd = socks[(signed long int)0];
          socks_out->write_fd = socks[(signed long int)1];
          socks_out->alert_fn = sock_alert;
          socks_out->drain_fn = sock_drain;
          return 0;
        }

      }

      return -1;
    }
}

// alloc_chunk
// file ../src/common/memarea.c line 118
static struct memarea_chunk_t * alloc_chunk(unsigned long int sz, signed int freelist_ok)
{
  if(sz >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)120, "alloc_chunk", "sz < SIZE_T_CEILING");
    abort();
  }

  if(!(freelist == ((struct memarea_chunk_t *)NULL)) && !(freelist_ok == 0))
  {
    struct memarea_chunk_t *res = freelist;
    freelist = res->next_chunk;
    res->next_chunk = (struct memarea_chunk_t *)(void *)0;
    freelist_len = freelist_len - 1;
    unsigned int sent_val;
    sent_val=get_uint32((const void *)&res->mem[(signed long int)res->mem_size]);
    if(!(sent_val == 0x90806622u))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)126, "alloc_chunk", "sent_val == SENTINEL_VAL");
      abort();
    }

    return res;
  }

  else
  {
    unsigned long int chunk_size = freelist_ok != 0 ? (unsigned long int)4096 : sz;
    struct memarea_chunk_t *alloc_chunk__1__3__res;
    chunk_size = chunk_size + sizeof(unsigned int) /*4ul*/ ;
    void *return_value_tor_malloc__1;
    return_value_tor_malloc__1=tor_malloc_(chunk_size);
    alloc_chunk__1__3__res = (struct memarea_chunk_t *)return_value_tor_malloc__1;
    alloc_chunk__1__3__res->next_chunk = (struct memarea_chunk_t *)(void *)0;
    alloc_chunk__1__3__res->mem_size = (chunk_size - 24ul) - sizeof(unsigned int) /*4ul*/ ;
    alloc_chunk__1__3__res->next_mem = alloc_chunk__1__3__res->mem;
    if(!(alloc_chunk__1__3__res->next_mem + (signed long int)alloc_chunk__1__3__res->mem_size + (signed long int)sizeof(unsigned int) /*4l*/  == (char *)alloc_chunk__1__3__res + (signed long int)chunk_size))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)137, "alloc_chunk", "res->next_mem+res->mem_size+SENTINEL_LEN == ((char*)res)+chunk_size");
      abort();
    }

    void *return_value_realign_pointer_2;
    return_value_realign_pointer_2=realign_pointer((void *)alloc_chunk__1__3__res->next_mem);
    if(!((char *)return_value_realign_pointer_2 == alloc_chunk__1__3__res->next_mem))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)138, "alloc_chunk", "realign_pointer(res->next_mem) == res->next_mem");
      abort();
    }

    set_uint32((void *)&alloc_chunk__1__3__res->mem[(signed long int)alloc_chunk__1__3__res->mem_size], 0x90806622u);
    return alloc_chunk__1__3__res;
  }
}

// alloc_getcwd
// file ../src/common/compat.c line 2111
static char * alloc_getcwd(void)
{
  signed int saved_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  saved_errno = *return_value___errno_location_1;
  unsigned long int path_length = (unsigned long int)128;
  char *path;
  void *return_value_tor_malloc__2;
  return_value_tor_malloc__2=tor_malloc_(path_length);
  path = (char *)return_value_tor_malloc__2;
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  *return_value___errno_location_3 = 0;
  char *return_value_getcwd_4;
  do
  {
    return_value_getcwd_4=getcwd(path, path_length);
    if(!(return_value_getcwd_4 == ((char *)NULL)))
      break;

    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    if(*return_value___errno_location_6 == 34 && !(path_length >= 4096ul))
    {
      path_length = path_length * (unsigned long int)2;
      void *return_value_tor_realloc__5;
      return_value_tor_realloc__5=tor_realloc_((void *)path, path_length);
      path = (char *)return_value_tor_realloc__5;
    }

    else
    {
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

      path = (char *)(void *)0;
      break;
    }
  }
  while((_Bool)1);
  signed int *return_value___errno_location_7;
  return_value___errno_location_7=__errno_location();
  *return_value___errno_location_7 = saved_errno;
  return path;
}

// append_bytes_to_file
// file ../src/common/util.c line 2532
signed int append_bytes_to_file(const char *fname, const char *str, unsigned long int len, signed int bin)
{
  signed int return_value_write_bytes_to_file_impl_1;
  return_value_write_bytes_to_file_impl_1=write_bytes_to_file_impl(fname, str, len, 01 | 0100 | 02000 | (bin != 0 ? 0 : 0));
  return return_value_write_bytes_to_file_impl_1;
}

// approx_time
// file ../src/common/util.h line 288
signed long int approx_time(void)
{
  return cached_approx_time;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// base16_decode
// file ../src/common/util.c line 1272
signed int base16_decode(char *dest, unsigned long int destlen, const char *src, unsigned long int srclen)
{
  const char *end;
  signed int v1;
  signed int v2;
  if(!(srclen % 2ul == 0ul))
    return -1;

  else
    if(destlen >= 9223372036854775792ul || !(destlen >= srclen / 2ul))
      return -1;

    else
    {
      memset_link7((void *)dest, 0, destlen);
      end = src + (signed long int)srclen;
      for( ; !(src >= end); src = src + (signed long int)2)
      {
        v1=hex_decode_digit_(*src);
        v2=hex_decode_digit_(src[(signed long int)1]);
        if(!(v1 >= 0) || !(v2 >= 0))
          return -1;

        *((unsigned char *)dest) = (unsigned char)(v1 << 4 | v2);
        dest = dest + 1l;
      }
      return 0;
    }
}

// base16_encode
// file ../src/common/util.c line 1217
void base16_encode(char *dest, unsigned long int destlen, const char *src, unsigned long int srclen)
{
  const char *end;
  char *cp;
  if(!(destlen >= 2ul * srclen + 1ul))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1222, "base16_encode", "destlen >= srclen*2+1");
    abort();
  }

  if(destlen >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1223, "base16_encode", "destlen < SIZE_T_CEILING");
    abort();
  }

  cp = dest;
  end = src + (signed long int)srclen;
  char *tmp_post_1;
  char *tmp_post_2;
  for( ; !(src >= end); src = src + 1l)
  {
    tmp_post_1 = cp;
    cp = cp + 1l;
    *tmp_post_1 = "0123456789ABCDEF"[(signed long int)((signed int)*((const unsigned char *)src) >> 4)];
    tmp_post_2 = cp;
    cp = cp + 1l;
    *tmp_post_2 = "0123456789ABCDEF"[(signed long int)((signed int)*((const unsigned char *)src) & 0xf)];
  }
  *cp = (char)0;
}

// bitarray_free
// file ../src/common/container.h line 613
static inline void bitarray_free(unsigned int *ba)
{
  if(!(ba == ((unsigned int *)NULL)))
  {
    free((void *)ba);
    ba = (unsigned int *)(void *)0;
  }

}

// bitarray_init_zero
// file ../src/common/container.h line 586
static inline unsigned int * bitarray_init_zero(unsigned int n_bits)
{
  unsigned long int sz = (unsigned long int)(n_bits + ((1u << 5) - (unsigned int)1) >> 5);
  void *return_value_tor_calloc__1;
  return_value_tor_calloc__1=tor_calloc_(sz, sizeof(unsigned int) /*4ul*/ );
  return (unsigned int *)return_value_tor_calloc__1;
}

// build_socks_resolve_request
// file ../src/tools/tor-resolve.c line 55
static signed long int build_socks_resolve_request(char **out, const char *username, const char *hostname, signed int reverse, signed int version)
{
  unsigned long int len = (unsigned long int)0;
  if(out == ((char **)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)62, "build_socks_resolve_request", "out");
    abort();
  }

  if(username == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)63, "build_socks_resolve_request", "username");
    abort();
  }

  if(hostname == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)64, "build_socks_resolve_request", "hostname");
    abort();
  }

  unsigned short int tmp_statement_expression_4;
  _Bool tmp_if_expr_11;
  unsigned short int return_value_tor_addr_family_10;
  unsigned long int tmp_if_expr_13;
  unsigned long int return_value_strlen_12;
  struct in6_addr *return_value_tor_addr_to_in6_15;
  unsigned int return_value_tor_addr_to_ipv4n_16;
  if(version == 4)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(username);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(hostname);
    len = (unsigned long int)8 + return_value_strlen_1 + (unsigned long int)1 + return_value_strlen_2 + (unsigned long int)1;
    void *return_value_tor_malloc__3;
    return_value_tor_malloc__3=tor_malloc_(len);
    *out = (char *)return_value_tor_malloc__3;
    (*out)[(signed long int)0] = (char)4;
    (*out)[(signed long int)1] = (char)-16;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)0;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_4 = __v;
    set_uint16((void *)(*out + (signed long int)2), tmp_statement_expression_4);
    unsigned int return_value___bswap_32_5;
    return_value___bswap_32_5=__bswap_32(0x00000001u);
    set_uint32((void *)(*out + (signed long int)4), return_value___bswap_32_5);
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(username);
    memcpy((void *)(*out + (signed long int)8), (const void *)username, return_value_strlen_6 + (unsigned long int)1);
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(username);
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(hostname);
    memcpy((void *)(*out + (signed long int)8 + (signed long int)return_value_strlen_7 + (signed long int)1), (const void *)hostname, return_value_strlen_8 + (unsigned long int)1);
  }

  else
    if(version == 5)
    {
      signed int is_ip_address;
      struct tor_addr_t addr;
      unsigned long int addrlen;
      signed int ipv6;
      signed int return_value_tor_addr_parse_9;
      return_value_tor_addr_parse_9=tor_addr_parse(&addr, hostname);
      is_ip_address = (signed int)(return_value_tor_addr_parse_9 != -1);
      if(is_ip_address == 0 && !(reverse == 0))
      {
        log_fn_(3, 1u << 0, "build_socks_resolve_request", "Tried to do a reverse lookup on a non-IP!");
        return (signed long int)-1;
      }

      if(!(reverse == 0))
      {
        return_value_tor_addr_family_10=tor_addr_family(&addr);
        tmp_if_expr_11 = (signed int)return_value_tor_addr_family_10 == 10 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      ipv6 = (signed int)tmp_if_expr_11;
      if(!(reverse == 0))
        tmp_if_expr_13 = (unsigned long int)(ipv6 != 0 ? 16 : 4);

      else
      {
        return_value_strlen_12=strlen(hostname);
        tmp_if_expr_13 = (unsigned long int)1 + return_value_strlen_12;
      }
      addrlen = tmp_if_expr_13;
      len = (unsigned long int)6 + addrlen;
      void *return_value_tor_malloc__14;
      return_value_tor_malloc__14=tor_malloc_(len);
      *out = (char *)return_value_tor_malloc__14;
      (*out)[(signed long int)0] = (char)5;
      (*out)[(signed long int)1] = (char)(reverse != 0 ? -15 : -16);
      (*out)[(signed long int)2] = (char)0;
      if(!(reverse == 0))
      {
        (*out)[(signed long int)3] = (char)(ipv6 != 0 ? 4 : 1);
        if(!(ipv6 == 0))
        {
          return_value_tor_addr_to_in6_15=tor_addr_to_in6(&addr);
          memcpy((void *)(*out + (signed long int)4), (const void *)return_value_tor_addr_to_in6_15->__in6_u.__u6_addr8, (unsigned long int)16);
        }

        else
        {
          return_value_tor_addr_to_ipv4n_16=tor_addr_to_ipv4n(&addr);
          set_uint32((void *)(*out + (signed long int)4), return_value_tor_addr_to_ipv4n_16);
        }
      }

      else
      {
        (*out)[(signed long int)3] = (char)3;
        (*out)[(signed long int)4] = (char)(unsigned char)(addrlen - (unsigned long int)1);
        memcpy((void *)(*out + (signed long int)5), (const void *)hostname, addrlen - (unsigned long int)1);
      }
      set_uint16((void *)(*out + (signed long int)4 + (signed long int)addrlen), (unsigned short int)0);
    }

    else
    {
      tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)105, "build_socks_resolve_request", "0");
      abort();
    }
  return (signed long int)len;
}

// cached_getaddrinfo_item_free
// file ../src/common/sandbox.c line 1330
static void cached_getaddrinfo_item_free(struct cached_getaddrinfo_item_t *item)
{
  if(!(item == ((struct cached_getaddrinfo_item_t *)NULL)))
  {
    if(!(item->name == ((char *)NULL)))
    {
      free((void *)item->name);
      item->name = (char *)(void *)0;
    }

    if(!(item->res == ((struct addrinfo *)NULL)))
      freeaddrinfo(item->res);

    if(!(item == ((struct cached_getaddrinfo_item_t *)NULL)))
    {
      free((void *)item);
      item = (struct cached_getaddrinfo_item_t *)(void *)0;
    }

  }

}

// cached_getaddrinfo_item_hash
// file ../src/common/sandbox.c line 1317
static unsigned int cached_getaddrinfo_item_hash(const struct cached_getaddrinfo_item_t *item)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(item->name);
  unsigned long int return_value_siphash24g_2;
  return_value_siphash24g_2=siphash24g((const void *)item->name, return_value_strlen_1);
  return (unsigned int)return_value_siphash24g_2 + (unsigned int)item->family;
}

// cached_getaddrinfo_items_eq
// file ../src/common/sandbox.c line 1323
static unsigned int cached_getaddrinfo_items_eq(const struct cached_getaddrinfo_item_t *a, const struct cached_getaddrinfo_item_t *b)
{
  _Bool tmp_if_expr_3;
  signed int tmp_statement_expression_1;
  if(a->family == b->family)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(a->name, b->name);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    tmp_if_expr_3 = 0 == tmp_statement_expression_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return (unsigned int)tmp_if_expr_3;
}

// change_callback_log_severity
// file ../src/common/log.c line 987
void change_callback_log_severity(signed int loglevelMin, signed int loglevelMax, void (*cb)(signed int, unsigned int, const char *))
{
  struct logfile_t *lf;
  struct log_severity_list_t severities;
  set_log_severity_config(loglevelMin, loglevelMax, &severities);
  tor_mutex_acquire(&log_mutex);
  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
    if(lf->callback == cb)
      memcpy_link5((void *)lf->severities, (const void *)&severities, sizeof(struct log_severity_list_t) /*20ul*/ );

  log_global_min_severity_=get_min_log_level();
  tor_mutex_release(&log_mutex);
}

// check_private_dir
// file ../src/common/util.c line 2109
signed int check_private_dir(const char *dirname, unsigned int check, const char *effective_user)
{
  signed int r;
  struct stat st;
  char *f;
  unsigned int unwanted_bits = (unsigned int)0;
  struct passwd *check_private_dir__1__pw = (struct passwd *)(void *)0;
  unsigned int running_uid;
  unsigned int running_gid;
  if(dirname == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2124, "check_private_dir", "dirname");
    abort();
  }

  f=tor_strdup_(dirname);
  clean_name_for_stat(f);
  if(log_global_min_severity_ == 7)
    log_fn_(7, 1u << 4, "check_private_dir", "stat()ing %s", f);

  const char *return_value_sandbox_intern_string_1;
  return_value_sandbox_intern_string_1=sandbox_intern_string(f);
  r=stat(return_value_sandbox_intern_string_1, &st);
  if(!(f == ((char *)NULL)))
  {
    free((void *)f);
    f = (char *)(void *)0;
  }

  if(!(r == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(!(*return_value___errno_location_4 == 2))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_fn_(4, 1u << 4, "check_private_dir", "Directory %s cannot be read: %s", dirname, return_value_strerror_3);
      return -1;
    }

    if(!((1u & check) == 0u))
    {
      log_fn_(6, 1u << 0, "check_private_dir", "Creating directory %s", dirname);
      if(!((8u & check) == 0u))
        r=mkdir(dirname, (unsigned int)0750);

      else
        r=mkdir(dirname, (unsigned int)0700);
      if(!(r == 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        log_fn_(4, 1u << 4, "check_private_dir", "Error creating directory %s: %s", dirname, return_value_strerror_6);
        return -1;
      }

    }

    else
      if((2u & check) == 0u)
      {
        log_fn_(4, 1u << 4, "check_private_dir", "Directory %s does not exist.", dirname);
        return -1;
      }

    return 0;
  }

  char *tmp_if_expr_9;
  char *return_value_tor_strdup__7;
  char *return_value_tor_strdup__8;
  char *tmp_if_expr_10;
  char *tmp_if_expr_13;
  char *return_value_tor_strdup__11;
  char *return_value_tor_strdup__12;
  char *tmp_if_expr_14;
  if((16384u & st.st_mode) == 0u)
  {
    log_fn_(4, 1u << 4, "check_private_dir", "%s is not a directory", dirname);
    return -1;
  }

  else
  {
    if(!(effective_user == ((const char *)NULL)))
    {
      check_private_dir__1__pw=tor_getpwnam(effective_user);
      if(check_private_dir__1__pw == ((struct passwd *)NULL))
      {
        log_fn_(4, 1u << 3, "check_private_dir", "Error setting configured user: %s not found", effective_user);
        return -1;
      }

      running_uid = check_private_dir__1__pw->pw_uid;
      running_gid = check_private_dir__1__pw->pw_gid;
    }

    else
    {
      running_uid=getuid();
      running_gid=getgid();
    }
    if(!(st.st_uid == running_uid))
    {
      struct passwd *pw = (struct passwd *)(void *)0;
      char *process_ownername = (char *)(void *)0;
      pw=tor_getpwuid(running_uid);
      if(!(pw == ((struct passwd *)NULL)))
      {
        return_value_tor_strdup__7=tor_strdup_(pw->pw_name);
        tmp_if_expr_9 = return_value_tor_strdup__7;
      }

      else
      {
        return_value_tor_strdup__8=tor_strdup_("<unknown>");
        tmp_if_expr_9 = return_value_tor_strdup__8;
      }
      process_ownername = tmp_if_expr_9;
      pw=tor_getpwuid(st.st_uid);
      if(!(pw == ((struct passwd *)NULL)))
        tmp_if_expr_10 = pw->pw_name;

      else
        tmp_if_expr_10 = "<unknown>";
      log_fn_(4, 1u << 4, "check_private_dir", "%s is not owned by this user (%s, %d) but by %s (%d). Perhaps you are running Tor as the wrong user?", dirname, process_ownername, (signed int)running_uid, tmp_if_expr_10, (signed int)st.st_uid);
      if(!(process_ownername == ((char *)NULL)))
      {
        free((void *)process_ownername);
        process_ownername = (char *)(void *)0;
      }

      return -1;
    }

    if(!((12u & check) == 0u) && !(st.st_gid == running_gid))
    {
      struct group *gr;
      char *process_groupname = (char *)(void *)0;
      gr=getgrgid(running_gid);
      if(!(gr == ((struct group *)NULL)))
      {
        return_value_tor_strdup__11=tor_strdup_(gr->gr_name);
        tmp_if_expr_13 = return_value_tor_strdup__11;
      }

      else
      {
        return_value_tor_strdup__12=tor_strdup_("<unknown>");
        tmp_if_expr_13 = return_value_tor_strdup__12;
      }
      process_groupname = tmp_if_expr_13;
      gr=getgrgid(st.st_gid);
      if(!(gr == ((struct group *)NULL)))
        tmp_if_expr_14 = gr->gr_name;

      else
        tmp_if_expr_14 = "<unknown>";
      log_fn_(4, 1u << 4, "check_private_dir", "%s is not owned by this group (%s, %d) but by group %s (%d).  Are you running Tor as the wrong user?", dirname, process_groupname, (signed int)running_gid, tmp_if_expr_14, (signed int)st.st_gid);
      if(!(process_groupname == ((char *)NULL)))
      {
        free((void *)process_groupname);
        process_groupname = (char *)(void *)0;
      }

      return -1;
    }

    if(!((12u & check) == 0u))
      unwanted_bits = (unsigned int)0027;

    else
      unwanted_bits = (unsigned int)0077;
    if(!((st.st_mode & unwanted_bits) == 0u))
    {
      unsigned int new_mode;
      if(!((16u & check) == 0u))
      {
        log_fn_(4, 1u << 4, "check_private_dir", "Permissions on directory %s are too permissive.", dirname);
        return -1;
      }

      log_fn_(4, 1u << 4, "check_private_dir", "Fixing permissions on directory %s", dirname);
      new_mode = st.st_mode;
      new_mode = new_mode | (unsigned int)0700;
      if(!((8u & check) == 0u))
        new_mode = new_mode | (unsigned int)0050;

      new_mode = new_mode & ~unwanted_bits;
      signed int return_value_chmod_17;
      return_value_chmod_17=chmod(dirname, new_mode);
      if(!(return_value_chmod_17 == 0))
      {
        signed int *return_value___errno_location_15;
        return_value___errno_location_15=__errno_location();
        char *return_value_strerror_16;
        return_value_strerror_16=strerror(*return_value___errno_location_15);
        log_fn_(4, 1u << 4, "check_private_dir", "Could not chmod directory %s: %s", dirname, return_value_strerror_16);
        return -1;
      }

      else
        return 0;
    }

    return 0;
  }
}

// chunk_free_unchecked
// file ../src/common/memarea.c line 147
static void chunk_free_unchecked(struct memarea_chunk_t *chunk)
{
  unsigned int sent_val;
  sent_val=get_uint32((const void *)&chunk->mem[(signed long int)chunk->mem_size]);
  if(!(sent_val == 0x90806622u))
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)149, "chunk_free_unchecked", "sent_val == SENTINEL_VAL");
    abort();
  }

  if(!(freelist_len >= 4))
  {
    freelist_len = freelist_len + 1;
    chunk->next_chunk = freelist;
    freelist = chunk;
    chunk->next_mem = chunk->mem;
  }

  else
    if(!(chunk == ((struct memarea_chunk_t *)NULL)))
    {
      free((void *)chunk);
      chunk = (struct memarea_chunk_t *)(void *)0;
    }

}

// clean_backtrace
// file ../src/common/backtrace.c line 65
void clean_backtrace(void **stack, signed int depth, const struct ucontext *ctx)
{
  const signed int n = 1;
  if(!(n >= depth))
    stack[(signed long int)n] = (void *)ctx->uc_mcontext.gregs[(signed long int)16];

}

// clean_name_for_stat
// file ../src/common/util.c line 2029
static void clean_name_for_stat(char *name)
{
  (void)name;
}

// clean_up_backtrace_handler
// file ../src/common/backtrace.c line 228
void clean_up_backtrace_handler(void)
{
  remove_bt_handler();
  if(!(bt_version == ((char *)NULL)))
  {
    free((void *)bt_version);
    bt_version = (char *)(void *)0;
  }

}

// clear_waitpid_callback
// file ../src/common/util_process.h line 21
void clear_waitpid_callback(struct waitpid_callback_t *ent)
{
  struct waitpid_callback_t *old_ent;
  if(!(ent == ((struct waitpid_callback_t *)NULL)))
  {
    if(!(ent->running == 0u))
    {
      old_ent=process_map_HT_REMOVE(&process_map, ent);
      if(old_ent == ent)
        goto __CPROVER_DUMP_L2;

      log_fn_(4, 1u << 12, "clear_waitpid_callback", "Couldn't remove waitpid monitor for pid %u.", (unsigned int)ent->pid);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(ent == ((struct waitpid_callback_t *)NULL)))
      {
        free((void *)ent);
        ent = (struct waitpid_callback_t *)(void *)0;
      }

    }
  }

}

// close_log
// file ../src/common/log.c line 860
static void close_log(struct logfile_t *victim)
{
  _Bool tmp_if_expr_1;
  if(!(victim->needs_close == 0))
    tmp_if_expr_1 = victim->fd >= 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    close(victim->fd);
    victim->fd = -1;
  }

  else
    if(!(victim->is_syslog == 0))
    {
      syslog_count = syslog_count - 1;
      if(syslog_count == 0)
        closelog();

    }

}

// close_temp_logs
// file ../src/common/log.c line 1086
void close_temp_logs(void)
{
  struct logfile_t *lf;
  struct logfile_t **p;
  tor_mutex_acquire(&log_mutex);
  p = &logfiles;
  while(!(*p == ((struct logfile_t *)NULL)))
    if(!((*p)->is_temporary == 0))
    {
      lf = *p;
      *p = (*p)->next;
      close_log(lf);
      log_free(lf);
    }

    else
      p = &(*p)->next;
  log_global_min_severity_=get_min_log_level();
  tor_mutex_release(&log_mutex);
}

// compare_digests256_
// file ../src/common/container.c line 996
static signed int compare_digests256_(const void **_a, const void **_b)
{
  signed int return_value_tor_memcmp_1;
  return_value_tor_memcmp_1=tor_memcmp((const void *)(const char *)*_a, (const void *)(const char *)*_b, (unsigned long int)32);
  return return_value_tor_memcmp_1;
}

// compare_digests_
// file ../src/common/container.c line 974
static signed int compare_digests_(const void **_a, const void **_b)
{
  signed int return_value_tor_memcmp_1;
  return_value_tor_memcmp_1=tor_memcmp((const void *)(const char *)*_a, (const void *)(const char *)*_b, (unsigned long int)20);
  return return_value_tor_memcmp_1;
}

// compare_ptrs_
// file ../src/common/container.c line 758
static signed int compare_ptrs_(const void **_a, const void **_b)
{
  const void *a = *_a;
  const void *b = *_b;
  if(!(a >= b))
    return -1;

  else
    if(a == b)
      return 0;

    else
      return 1;
}

// compare_string_ptrs_
// file ../src/common/container.c line 718
static signed int compare_string_ptrs_(const void **_a, const void **_b)
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp((const char *)*_a, (const char *)*_b);
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  return tmp_statement_expression_1;
}

// compute_num_cpus
// file ../src/common/compat.c line 2602
signed int compute_num_cpus(void)
{
  static signed int num_cpus = -2;
  if(num_cpus == -2)
  {
    num_cpus=compute_num_cpus_impl();
    if(num_cpus == -2)
    {
      tor_assertion_failed_("../src/common/compat.c", (unsigned int)2607, "compute_num_cpus", "num_cpus != -2");
      abort();
    }

    if(num_cpus >= 17)
      log_fn_(5, 1u << 0, "compute_num_cpus", "Wow!  I detected that you have %d CPUs. I will not autodetect any more than %d, though.  If you want to configure more, set NumCPUs in your torrc", num_cpus, 16);

  }

  return num_cpus;
}

// compute_num_cpus_impl
// file ../src/common/compat.c line 2548
static signed int compute_num_cpus_impl(void)
{
  signed long int cpus_conf;
  cpus_conf=sysconf(83);
  signed long int cpus_onln;
  cpus_onln=sysconf(84);
  signed long int cpus = (signed long int)-1;
  if(cpus_conf >= 1l && !(cpus_onln >= 0l))
    cpus = cpus_conf;

  else
    if(cpus_onln >= 1l && !(cpus_conf >= 0l))
      cpus = cpus_onln;

    else
      if(cpus_conf >= 1l && cpus_onln >= 1l)
      {
        if(!(cpus_onln >= cpus_conf))
          log_fn_(5, 1u << 0, "compute_num_cpus_impl", "I think we have %ld CPUS, but only %ld of them are available. Telling Tor to only use %ld. You can override this with the NumCPUs option", cpus_conf, cpus_onln, cpus_onln);

        cpus = cpus_onln;
      }

  if(cpus >= 1l && !(cpus >= 2147483647l))
    return (signed int)cpus;

  else
    return -1;
}

// configure_backtrace_handler
// file ../src/common/backtrace.c line 215
signed int configure_backtrace_handler(const char *tor_version)
{
  if(!(bt_version == ((char *)NULL)))
  {
    free((void *)bt_version);
    bt_version = (char *)(void *)0;
  }

  if(tor_version == ((const char *)NULL))
    tor_version = "";

  tor_asprintf(&bt_version, "Tor %s", tor_version);
  signed int return_value_install_bt_handler_1;
  return_value_install_bt_handler_1=install_bt_handler();
  return return_value_install_bt_handler_1;
}

// correct_tm
// file ../src/common/compat.c line 2674
static struct tm * correct_tm(signed int islocal, const signed long int *timep, struct tm *resultbuf, struct tm *r)
{
  const char *outcome;
  signed long long int tmp_if_expr_1;
  if(!(r == ((struct tm *)NULL)))
  {
    if(r->tm_year >= 8100)
    {
      r->tm_year = 8099;
      r->tm_mon = 11;
      r->tm_mday = 31;
      r->tm_yday = 364;
      r->tm_hour = 23;
      r->tm_min = 59;
      r->tm_sec = 59;
    }

    else
      if(!(r->tm_year >= 1))
      {
        r->tm_year = 1 - 1900;
        r->tm_mon = 0;
        r->tm_mday = 1;
        r->tm_yday = 0;
        r->tm_hour = 0;
        r->tm_min = 0;
        r->tm_sec = 0;
      }

    return r;
  }

  else
  {
    if(!(timep == ((const signed long int *)NULL)))
    {
      if(!(*timep >= 0l))
      {
        r = resultbuf;
        r->tm_year = 70;
        r->tm_mon = 0;
        r->tm_mday = 1;
        r->tm_yday = 0;
        r->tm_hour = 0;
        r->tm_min = 0;
        r->tm_sec = 0;
        outcome = "Rounding up to 1970";
        goto done;
      }

      if(!(*timep >= 2147483647l))
        goto __CPROVER_DUMP_L5;

      r = resultbuf;
      r->tm_year = 137;
      r->tm_mon = 11;
      r->tm_mday = 31;
      r->tm_yday = 364;
      r->tm_hour = 23;
      r->tm_min = 59;
      r->tm_sec = 59;
      outcome = "Rounding down to 2037";
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      r = resultbuf;
      memset_link3((void *)resultbuf, 0, sizeof(struct tm) /*56ul*/ );
      outcome = "can't recover";
    }

  done:
    ;
    if(!(timep == ((const signed long int *)NULL)))
      tmp_if_expr_1 = (signed long long int)*timep;

    else
      tmp_if_expr_1 = (signed long int)0;
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    log_fn_(4, 1u << 12, "correct_tm", "%s(%lld) failed with error %s: %s", islocal != 0 ? "localtime" : "gmtime", tmp_if_expr_1, return_value_strerror_3, outcome);
    return r;
  }
}

// crash_handler
// file ../src/common/backtrace.c line 120
static void crash_handler(signed int sig, struct anonymous_25 *si, void *ctx_)
{
  char buf[40l];
  signed int depth;
  struct ucontext *ctx = (struct ucontext *)ctx_;
  signed int n_fds;
  signed int i;
  const signed int *fds = (const signed int *)(void *)0;
  (void)si;
  depth=backtrace(cb_buf, 256);
  clean_backtrace(cb_buf, depth, ctx);
  format_dec_number_sigsafe((unsigned long int)(unsigned int)sig, buf, (signed int)sizeof(char [40l]) /*40ul*/ );
  tor_log_err_sigsafe(bt_version, (const void *)" died: Caught signal ", (const void *)buf, (const void *)"\n", (void *)0);
  n_fds=tor_log_get_sigsafe_err_fds(&fds);
  i = 0;
  for( ; !(i >= n_fds); i = i + 1)
    backtrace_symbols_fd(cb_buf, depth, fds[(signed long int)i]);
  abort();
}

// delete_log
// file ../src/common/log.c line 841
static void delete_log(struct logfile_t *victim)
{
  struct logfile_t *tmpl;
  _Bool tmp_if_expr_1;
  if(victim == logfiles)
    logfiles = victim->next;

  else
  {
    tmpl = logfiles;
    do
    {
      if(!(tmpl == ((struct logfile_t *)NULL)))
        tmp_if_expr_1 = tmpl->next != victim ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      tmpl = tmpl->next;
    }
    while((_Bool)1);
    if(tmpl == ((struct logfile_t *)NULL))
      goto __CPROVER_DUMP_L8;

    tmpl->next = victim->next;
  }
  log_free(victim);

__CPROVER_DUMP_L8:
  ;
}

// digest256map_assert_ok
// file ../src/common/container.c line 1367
void digest256map_assert_ok(const struct digest256map_t *map)
{
  signed int return_value_digest256map_impl_HT_REP_IS_BAD__1;
  return_value_digest256map_impl_HT_REP_IS_BAD__1=digest256map_impl_HT_REP_IS_BAD_(&map->head);
  if(!(return_value_digest256map_impl_HT_REP_IS_BAD__1 == 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_assert_ok", "!digest256map_impl_HT_REP_IS_BAD_(&map->head)");
    abort();
  }

}

// digest256map_assign_key
// file ../src/common/container.c line 1146
static inline void digest256map_assign_key(struct digest256map_entry_t *ent, const unsigned char *key)
{
  memcpy_link3((void *)ent->key, (const void *)key, (unsigned long int)32);
}

// digest256map_assign_tmp_key
// file ../src/common/container.c line 1131
static inline void digest256map_assign_tmp_key(struct digest256map_entry_t *ent, const unsigned char *key)
{
  memcpy_link3((void *)ent->key, (const void *)key, (unsigned long int)32);
}

// digest256map_entries_eq
// file ../src/common/container.c line 1073
static inline signed int digest256map_entries_eq(const struct digest256map_entry_t *a, const struct digest256map_entry_t *b)
{
  signed int return_value_tor_memeq_1;
  return_value_tor_memeq_1=tor_memeq((const void *)a->key, (const void *)b->key, (unsigned long int)32);
  return return_value_tor_memeq_1;
}

// digest256map_entry_free
// file ../src/common/container.c line 1115
static inline void digest256map_entry_free(struct digest256map_entry_t *ent)
{
  if(!(ent == ((struct digest256map_entry_t *)NULL)))
  {
    free((void *)ent);
    ent = (struct digest256map_entry_t *)(void *)0;
  }

}

// digest256map_entry_hash
// file ../src/common/container.c line 1081
static inline unsigned int digest256map_entry_hash(const struct digest256map_entry_t *a)
{
  unsigned long int return_value_siphash24g_1;
  return_value_siphash24g_1=siphash24g((const void *)a->key, (unsigned long int)32);
  return (unsigned int)return_value_siphash24g_1;
}

// digest256map_free
// file ../src/common/container.c line 1367
void digest256map_free(struct digest256map_t *map, void (*free_val)(void *))
{
  struct digest256map_entry_t **ent;
  struct digest256map_entry_t **next;
  struct digest256map_entry_t *this;
  if(!(map == ((struct digest256map_t *)NULL)))
  {
    ent=digest256map_impl_HT_START(&map->head);
    for( ; !(ent == ((struct digest256map_entry_t **)NULL)); ent = next)
    {
      this = *ent;
      next=digest256map_impl_HT_NEXT_RMV(&map->head, ent);
      if(!(free_val == ((void (*)(void *))NULL)))
        free_val(this->val);

      digest256map_entry_free(this);
    }
    if(!(map->head.hth_n_entries == 0u))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_free", "HT_EMPTY(&map->head)");
      abort();
    }

    digest256map_impl_HT_CLEAR(&map->head);
    if(!(map == ((struct digest256map_t *)NULL)))
    {
      free((void *)map);
      map = (struct digest256map_t *)(void *)0;
    }

  }

}

// digest256map_get
// file ../src/common/container.c line 1367
void * digest256map_get(const struct digest256map_t *map, const unsigned char *key)
{
  struct digest256map_entry_t *resolve;
  struct digest256map_entry_t search;
  if(map == ((const struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_get", "map");
    abort();
  }

  if(key == ((const unsigned char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_get", "key");
    abort();
  }

  digest256map_assign_tmp_key(&search, key);
  resolve=digest256map_impl_HT_FIND(&map->head, &search);
  if(!(resolve == ((struct digest256map_entry_t *)NULL)))
    return resolve->val;

  else
    return (void *)0;
}

// digest256map_impl_HT_CLEAR
// file ../src/common/container.c line 1099
void digest256map_impl_HT_CLEAR(struct digest256map_impl *head)
{
  if(!(head->hth_table == ((struct digest256map_entry_t **)NULL)))
    tor_free_((void *)head->hth_table);

  head->hth_table_length = (unsigned int)0;
  digest256map_impl_HT_INIT(head);
}

// digest256map_impl_HT_FIND
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t * digest256map_impl_HT_FIND(struct digest256map_impl *head, struct digest256map_entry_t *elm)
{
  struct digest256map_entry_t **p;
  struct digest256map_impl *h = (struct digest256map_impl *)head;
  do
    elm->node.hte_hash=digest256map_entry_hash(elm);
  while((_Bool)0);
  p=digest256map_impl_HT_FIND_P_(h, elm);
  struct digest256map_entry_t *tmp_if_expr_1;
  if(!(p == ((struct digest256map_entry_t **)NULL)))
    tmp_if_expr_1 = *p;

  else
    tmp_if_expr_1 = (struct digest256map_entry_t *)(void *)0;
  return tmp_if_expr_1;
}

// digest256map_impl_HT_FIND_P_
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_FIND_P_(struct digest256map_impl *head, struct digest256map_entry_t *elm)
{
  struct digest256map_entry_t **p;
  if(head->hth_table == ((struct digest256map_entry_t **)NULL))
    return (struct digest256map_entry_t **)(void *)0;

  else
  {
    p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
    while(!(*p == ((struct digest256map_entry_t *)NULL)))
    {
      signed int return_value_digest256map_entries_eq_1;
      return_value_digest256map_entries_eq_1=digest256map_entries_eq(*p, elm);
      if(!(return_value_digest256map_entries_eq_1 == 0))
        return p;

      p = &(*p)->node.hte_next;
    }
    return p;
  }
}

// digest256map_impl_HT_GROW
// file ../src/common/container.c line 1099
signed int digest256map_impl_HT_GROW(struct digest256map_impl *head, unsigned int size)
{
  unsigned int new_len;
  unsigned int new_load_limit;
  signed int prime_idx;
  struct digest256map_entry_t **new_table;
  if(head->hth_prime_idx == (signed int)digest256map_impl_N_PRIMES + -1)
    return 0;

  else
    if(!(size >= head->hth_load_limit))
      return 0;

    else
    {
      prime_idx = head->hth_prime_idx;
      do
      {
        prime_idx = prime_idx + 1;
        new_len = digest256map_impl_PRIMES[(signed long int)prime_idx];
        new_load_limit = (unsigned int)(0.6 * (double)new_len);
      }
      while(size >= new_load_limit && !(prime_idx >= (signed int)digest256map_impl_N_PRIMES));
      void *return_value_tor_reallocarray__2;
      return_value_tor_reallocarray__2=tor_reallocarray_((void *)0, (unsigned long int)new_len, sizeof(struct digest256map_entry_t *) /*8ul*/ );
      new_table = (struct digest256map_entry_t **)return_value_tor_reallocarray__2;
      if(!(new_table == ((struct digest256map_entry_t **)NULL)))
      {
        unsigned int digest256map_impl_HT_GROW__1__2__b;
        memset_link4((void *)new_table, 0, (unsigned long int)new_len * sizeof(struct digest256map_entry_t *) /*8ul*/ );
        digest256map_impl_HT_GROW__1__2__b = (unsigned int)0;
        for( ; !(digest256map_impl_HT_GROW__1__2__b >= head->hth_table_length); digest256map_impl_HT_GROW__1__2__b = digest256map_impl_HT_GROW__1__2__b + 1u)
        {
          struct digest256map_entry_t *elm;
          struct digest256map_entry_t *next;
          unsigned int b2;
          elm = head->hth_table[(signed long int)digest256map_impl_HT_GROW__1__2__b];
          for( ; !(elm == ((struct digest256map_entry_t *)NULL)); elm = next)
          {
            next = elm->node.hte_next;
            b2 = elm->node.hte_hash % new_len;
            elm->node.hte_next = new_table[(signed long int)b2];
            new_table[(signed long int)b2] = elm;
          }
        }
        if(!(head->hth_table == ((struct digest256map_entry_t **)NULL)))
          tor_free_((void *)head->hth_table);

        head->hth_table = new_table;
      }

      else
      {
        unsigned int b;
        unsigned int digest256map_impl_HT_GROW__1__3__b2;
        void *return_value_tor_reallocarray__1;
        return_value_tor_reallocarray__1=tor_reallocarray_((void *)head->hth_table, (unsigned long int)new_len, sizeof(struct digest256map_entry_t *) /*8ul*/ );
        new_table = (struct digest256map_entry_t **)return_value_tor_reallocarray__1;
        if(new_table == ((struct digest256map_entry_t **)NULL))
          return -1;

        memset_link4((void *)(new_table + (signed long int)head->hth_table_length), 0, (unsigned long int)(new_len - head->hth_table_length) * sizeof(struct digest256map_entry_t *) /*8ul*/ );
        b = (unsigned int)0;
        for( ; !(b >= head->hth_table_length); b = b + 1u)
        {
          struct digest256map_entry_t *e;
          struct digest256map_entry_t **pE = &new_table[(signed long int)b];
          e = *pE;
          for( ; !(e == ((struct digest256map_entry_t *)NULL)); e = *pE)
          {
            digest256map_impl_HT_GROW__1__3__b2 = e->node.hte_hash % new_len;
            if(digest256map_impl_HT_GROW__1__3__b2 == b)
              pE = &e->node.hte_next;

            else
            {
              *pE = e->node.hte_next;
              e->node.hte_next = new_table[(signed long int)digest256map_impl_HT_GROW__1__3__b2];
              new_table[(signed long int)digest256map_impl_HT_GROW__1__3__b2] = e;
            }
          }
        }
        head->hth_table = new_table;
      }
      head->hth_table_length = new_len;
      head->hth_prime_idx = prime_idx;
      head->hth_load_limit = new_load_limit;
      return 0;
    }
}

// digest256map_impl_HT_INIT
// file ../src/common/container.c line 1096
static inline void digest256map_impl_HT_INIT(struct digest256map_impl *head)
{
  head->hth_table_length = (unsigned int)0;
  head->hth_table = (struct digest256map_entry_t **)(void *)0;
  head->hth_n_entries = (unsigned int)0;
  head->hth_load_limit = (unsigned int)0;
  head->hth_prime_idx = -1;
}

// digest256map_impl_HT_NEXT
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_NEXT(struct digest256map_impl *head, struct digest256map_entry_t **elm)
{
  if(!((*elm)->node.hte_next == ((struct digest256map_entry_t *)NULL)))
  {
    if(!((*elm)->node.hte_hash % head->hth_table_length == (*elm)->node.hte_next->node.hte_hash % head->hth_table_length))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1098, "digest256map_impl_HT_NEXT", "(((*elm)->node.hte_hash) % head->hth_table_length) == ((((*elm)->node.hte_next)->node.hte_hash) % head->hth_table_length)");
      abort();
    }

    return &(*elm)->node.hte_next;
  }

  else
  {
    unsigned int b = (*elm)->node.hte_hash % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct digest256map_entry_t *)NULL)))
      {
        if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
        {
          tor_assertion_failed_("../src/common/container.c", (unsigned int)1098, "digest256map_impl_HT_NEXT", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
          abort();
        }

        return &head->hth_table[(signed long int)b];
      }

    return (struct digest256map_entry_t **)(void *)0;
  }
}

// digest256map_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_NEXT_RMV(struct digest256map_impl *head, struct digest256map_entry_t **elm)
{
  unsigned int h = (*elm)->node.hte_hash;
  *elm = (*elm)->node.hte_next;
  head->hth_n_entries = head->hth_n_entries - 1u;
  if(!(*elm == ((struct digest256map_entry_t *)NULL)))
    return elm;

  else
  {
    unsigned int b = h % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct digest256map_entry_t *)NULL)))
        return &head->hth_table[(signed long int)b];

    return (struct digest256map_entry_t **)(void *)0;
  }
}

// digest256map_impl_HT_REMOVE
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t * digest256map_impl_HT_REMOVE(struct digest256map_impl *head, struct digest256map_entry_t *elm)
{
  struct digest256map_entry_t **p;
  struct digest256map_entry_t *r;
  do
    elm->node.hte_hash=digest256map_entry_hash(elm);
  while((_Bool)0);
  p=digest256map_impl_HT_FIND_P_(head, elm);
  _Bool tmp_if_expr_1;
  if(p == ((struct digest256map_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*p != ((struct digest256map_entry_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct digest256map_entry_t *)(void *)0;

  else
  {
    r = *p;
    *p = r->node.hte_next;
    r->node.hte_next = (struct digest256map_entry_t *)(void *)0;
    head->hth_n_entries = head->hth_n_entries - 1u;
    return r;
  }
}

// digest256map_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1099
signed int digest256map_impl_HT_REP_IS_BAD_(struct digest256map_impl *head)
{
  unsigned int n;
  unsigned int i;
  struct digest256map_entry_t *elm;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(head->hth_table_length == 0u)
  {
    if(head->hth_table == ((struct digest256map_entry_t **)NULL))
      tmp_if_expr_1 = !(head->hth_n_entries != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = head->hth_prime_idx == -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return 0;

    return 1;
  }

  else
  {
    if(head->hth_table == ((struct digest256map_entry_t **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = head->hth_prime_idx < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 2;

    else
      if(!(head->hth_load_limit >= head->hth_n_entries))
        return 3;

      else
        if(!(head->hth_table_length == digest256map_impl_PRIMES[(signed long int)head->hth_prime_idx]))
          return 4;

        else
          if(!(head->hth_load_limit == (unsigned int)(0.6 * (double)head->hth_table_length)))
            return 5;

          else
          {
            i = (unsigned int)0;
            n = i;
            for( ; !(i >= head->hth_table_length); i = i + 1u)
            {
              elm = head->hth_table[(signed long int)i];
              for( ; !(elm == ((struct digest256map_entry_t *)NULL)); elm = elm->node.hte_next)
              {
                unsigned int return_value_digest256map_entry_hash_6;
                return_value_digest256map_entry_hash_6=digest256map_entry_hash(elm);
                if(!(elm->node.hte_hash == return_value_digest256map_entry_hash_6))
                  return (signed int)((unsigned int)1000 + i);

                if(!(elm->node.hte_hash % head->hth_table_length == i))
                  return (signed int)((unsigned int)10000 + i);

                n = n + 1u;
              }
            }
            if(!(n == head->hth_n_entries))
              return 6;

            else
              return 0;
          }
  }
}

// digest256map_impl_HT_START
// file ../src/common/container.c line 1096
static inline struct digest256map_entry_t ** digest256map_impl_HT_START(struct digest256map_impl *head)
{
  unsigned int b = (unsigned int)0;
  for( ; !(b >= head->hth_table_length); b = b + 1u)
    if(!(head->hth_table[(signed long int)b] == ((struct digest256map_entry_t *)NULL)))
    {
      if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)1098, "digest256map_impl_HT_START", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
        abort();
      }

      return &head->hth_table[(signed long int)b];
    }

  return (struct digest256map_entry_t **)(void *)0;
}

// digest256map_isempty
// file ../src/common/container.c line 1367
signed int digest256map_isempty(const struct digest256map_t *map)
{
  return (signed int)((&map->head)->hth_n_entries == (unsigned int)0 ? (_Bool)1 : (0 != 0 ? (_Bool)1 : (_Bool)0));
}

// digest256map_iter_done
// file ../src/common/container.c line 1367
signed int digest256map_iter_done(struct digest256map_entry_t **iter)
{
  return (signed int)(iter == (struct digest256map_entry_t **)(void *)0);
}

// digest256map_iter_get
// file ../src/common/container.c line 1367
void digest256map_iter_get(struct digest256map_entry_t **iter, const unsigned char **keyp, void **valp)
{
  if(iter == ((struct digest256map_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_get", "iter");
    abort();
  }

  if(*iter == ((struct digest256map_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_get", "*iter");
    abort();
  }

  if(keyp == ((const unsigned char **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_get", "keyp");
    abort();
  }

  if(valp == ((void **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_get", "valp");
    abort();
  }

  *keyp = (*iter)->key;
  *valp = (*iter)->val;
}

// digest256map_iter_init
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_init(struct digest256map_t *map)
{
  if(map == ((struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_init", "map");
    abort();
  }

  struct digest256map_entry_t **return_value_digest256map_impl_HT_START_1;
  return_value_digest256map_impl_HT_START_1=digest256map_impl_HT_START(&map->head);
  return return_value_digest256map_impl_HT_START_1;
}

// digest256map_iter_next
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_next(struct digest256map_t *map, struct digest256map_entry_t **iter)
{
  if(map == ((struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_next", "map");
    abort();
  }

  if(iter == ((struct digest256map_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_next", "iter");
    abort();
  }

  struct digest256map_entry_t **return_value_digest256map_impl_HT_NEXT_1;
  return_value_digest256map_impl_HT_NEXT_1=digest256map_impl_HT_NEXT(&map->head, iter);
  return return_value_digest256map_impl_HT_NEXT_1;
}

// digest256map_iter_next_rmv
// file ../src/common/container.c line 1367
struct digest256map_entry_t ** digest256map_iter_next_rmv(struct digest256map_t *map, struct digest256map_entry_t **iter)
{
  struct digest256map_entry_t *rmv;
  if(map == ((struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_next_rmv", "map");
    abort();
  }

  if(iter == ((struct digest256map_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_next_rmv", "iter");
    abort();
  }

  if(*iter == ((struct digest256map_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_iter_next_rmv", "*iter");
    abort();
  }

  rmv = *iter;
  iter=digest256map_impl_HT_NEXT_RMV(&map->head, iter);
  digest256map_entry_free(rmv);
  return iter;
}

// digest256map_new
// file ../src/common/container.c line 1367
struct digest256map_t * digest256map_new(void)
{
  struct digest256map_t *result;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct digest256map_t) /*24ul*/ );
  result = (struct digest256map_t *)return_value_tor_malloc__1;
  digest256map_impl_HT_INIT(&result->head);
  return result;
}

// digest256map_remove
// file ../src/common/container.c line 1367
void * digest256map_remove(struct digest256map_t *map, const unsigned char *key)
{
  struct digest256map_entry_t *resolve;
  struct digest256map_entry_t search;
  void *oldval;
  if(map == ((struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_remove", "map");
    abort();
  }

  if(key == ((const unsigned char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_remove", "key");
    abort();
  }

  digest256map_assign_tmp_key(&search, key);
  resolve=digest256map_impl_HT_REMOVE(&map->head, &search);
  if(!(resolve == ((struct digest256map_entry_t *)NULL)))
  {
    oldval = resolve->val;
    digest256map_entry_free(resolve);
    return oldval;
  }

  else
    return (void *)0;
}

// digest256map_set
// file ../src/common/container.c line 1367
void * digest256map_set(struct digest256map_t *map, const unsigned char *key, void *val)
{
  struct digest256map_entry_t search;
  void *oldval;
  if(map == ((struct digest256map_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_set", "map");
    abort();
  }

  if(key == ((const unsigned char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_set", "key");
    abort();
  }

  if(val == NULL)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1367, "digest256map_set", "val");
    abort();
  }

  digest256map_assign_tmp_key(&search, key);
  struct digest256map_impl *ptr_head_ = &map->head;
  struct digest256map_entry_t **ptr;
  _Bool tmp_if_expr_1;
  if(ptr_head_->hth_table == ((struct digest256map_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ptr_head_->hth_n_entries >= ptr_head_->hth_load_limit ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    digest256map_impl_HT_GROW(ptr_head_, ptr_head_->hth_n_entries + (unsigned int)1);

  do
    (&search)->node.hte_hash=digest256map_entry_hash(&search);
  while((_Bool)0);
  ptr=digest256map_impl_HT_FIND_P_(ptr_head_, &search);
  if(!(*ptr == ((struct digest256map_entry_t *)NULL)))
  {
    oldval = (*ptr)->val;
    (*ptr)->val = val;
    return oldval;
  }

  else
  {
    struct digest256map_entry_t *newent;
    void *return_value_tor_malloc_zero__2;
    return_value_tor_malloc_zero__2=tor_malloc_zero_(sizeof(struct digest256map_entry_t) /*56ul*/ );
    newent = (struct digest256map_entry_t *)return_value_tor_malloc_zero__2;
    digest256map_assign_key(newent, key);
    newent->val = val;
    do
      newent->node.hte_hash = (&search)->node.hte_hash;
    while((_Bool)0);
    newent->node.hte_next = (struct digest256map_entry_t *)(void *)0;
    *ptr = newent;
    (&map->head)->hth_n_entries = (&map->head)->hth_n_entries + 1u;
    return (void *)0;
  }
}

// digest256map_size
// file ../src/common/container.c line 1367
signed int digest256map_size(const struct digest256map_t *map)
{
  return (signed int)(&map->head)->hth_n_entries;
}

// digestmap_assert_ok
// file ../src/common/container.c line 1366
void digestmap_assert_ok(const struct digestmap_t *map)
{
  signed int return_value_digestmap_impl_HT_REP_IS_BAD__1;
  return_value_digestmap_impl_HT_REP_IS_BAD__1=digestmap_impl_HT_REP_IS_BAD_(&map->head);
  if(!(return_value_digestmap_impl_HT_REP_IS_BAD__1 == 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_assert_ok", "!digestmap_impl_HT_REP_IS_BAD_(&map->head)");
    abort();
  }

}

// digestmap_assign_key
// file ../src/common/container.c line 1141
static inline void digestmap_assign_key(struct digestmap_entry_t *ent, const char *key)
{
  memcpy_link3((void *)ent->key, (const void *)key, (unsigned long int)20);
}

// digestmap_assign_tmp_key
// file ../src/common/container.c line 1126
static inline void digestmap_assign_tmp_key(struct digestmap_entry_t *ent, const char *key)
{
  memcpy_link3((void *)ent->key, (const void *)key, (unsigned long int)20);
}

// digestmap_entries_eq
// file ../src/common/container.c line 1059
static inline signed int digestmap_entries_eq(const struct digestmap_entry_t *a, const struct digestmap_entry_t *b)
{
  signed int return_value_tor_memeq_1;
  return_value_tor_memeq_1=tor_memeq((const void *)a->key, (const void *)b->key, (unsigned long int)20);
  return return_value_tor_memeq_1;
}

// digestmap_entry_free
// file ../src/common/container.c line 1110
static inline void digestmap_entry_free(struct digestmap_entry_t *ent)
{
  if(!(ent == ((struct digestmap_entry_t *)NULL)))
  {
    free((void *)ent);
    ent = (struct digestmap_entry_t *)(void *)0;
  }

}

// digestmap_entry_hash
// file ../src/common/container.c line 1066
static inline unsigned int digestmap_entry_hash(const struct digestmap_entry_t *a)
{
  unsigned long int return_value_siphash24g_1;
  return_value_siphash24g_1=siphash24g((const void *)a->key, (unsigned long int)20);
  return (unsigned int)return_value_siphash24g_1;
}

// digestmap_free
// file ../src/common/container.c line 1366
void digestmap_free(struct digestmap_t *map, void (*free_val)(void *))
{
  struct digestmap_entry_t **ent;
  struct digestmap_entry_t **next;
  struct digestmap_entry_t *this;
  if(!(map == ((struct digestmap_t *)NULL)))
  {
    ent=digestmap_impl_HT_START(&map->head);
    for( ; !(ent == ((struct digestmap_entry_t **)NULL)); ent = next)
    {
      this = *ent;
      next=digestmap_impl_HT_NEXT_RMV(&map->head, ent);
      if(!(free_val == ((void (*)(void *))NULL)))
        free_val(this->val);

      digestmap_entry_free(this);
    }
    if(!(map->head.hth_n_entries == 0u))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_free", "HT_EMPTY(&map->head)");
      abort();
    }

    digestmap_impl_HT_CLEAR(&map->head);
    if(!(map == ((struct digestmap_t *)NULL)))
    {
      free((void *)map);
      map = (struct digestmap_t *)(void *)0;
    }

  }

}

// digestmap_get
// file ../src/common/container.c line 1366
void * digestmap_get(const struct digestmap_t *map, const char *key)
{
  struct digestmap_entry_t *resolve;
  struct digestmap_entry_t search;
  if(map == ((const struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_get", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_get", "key");
    abort();
  }

  digestmap_assign_tmp_key(&search, key);
  resolve=digestmap_impl_HT_FIND(&map->head, &search);
  if(!(resolve == ((struct digestmap_entry_t *)NULL)))
    return resolve->val;

  else
    return (void *)0;
}

// digestmap_impl_HT_CLEAR
// file ../src/common/container.c line 1093
void digestmap_impl_HT_CLEAR(struct digestmap_impl *head)
{
  if(!(head->hth_table == ((struct digestmap_entry_t **)NULL)))
    tor_free_((void *)head->hth_table);

  head->hth_table_length = (unsigned int)0;
  digestmap_impl_HT_INIT(head);
}

// digestmap_impl_HT_FIND
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t * digestmap_impl_HT_FIND(struct digestmap_impl *head, struct digestmap_entry_t *elm)
{
  struct digestmap_entry_t **p;
  struct digestmap_impl *h = (struct digestmap_impl *)head;
  do
    elm->node.hte_hash=digestmap_entry_hash(elm);
  while((_Bool)0);
  p=digestmap_impl_HT_FIND_P_(h, elm);
  struct digestmap_entry_t *tmp_if_expr_1;
  if(!(p == ((struct digestmap_entry_t **)NULL)))
    tmp_if_expr_1 = *p;

  else
    tmp_if_expr_1 = (struct digestmap_entry_t *)(void *)0;
  return tmp_if_expr_1;
}

// digestmap_impl_HT_FIND_P_
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_FIND_P_(struct digestmap_impl *head, struct digestmap_entry_t *elm)
{
  struct digestmap_entry_t **p;
  if(head->hth_table == ((struct digestmap_entry_t **)NULL))
    return (struct digestmap_entry_t **)(void *)0;

  else
  {
    p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
    while(!(*p == ((struct digestmap_entry_t *)NULL)))
    {
      signed int return_value_digestmap_entries_eq_1;
      return_value_digestmap_entries_eq_1=digestmap_entries_eq(*p, elm);
      if(!(return_value_digestmap_entries_eq_1 == 0))
        return p;

      p = &(*p)->node.hte_next;
    }
    return p;
  }
}

// digestmap_impl_HT_GROW
// file ../src/common/container.c line 1093
signed int digestmap_impl_HT_GROW(struct digestmap_impl *head, unsigned int size)
{
  unsigned int new_len;
  unsigned int new_load_limit;
  signed int prime_idx;
  struct digestmap_entry_t **new_table;
  if(head->hth_prime_idx == (signed int)digestmap_impl_N_PRIMES + -1)
    return 0;

  else
    if(!(size >= head->hth_load_limit))
      return 0;

    else
    {
      prime_idx = head->hth_prime_idx;
      do
      {
        prime_idx = prime_idx + 1;
        new_len = digestmap_impl_PRIMES[(signed long int)prime_idx];
        new_load_limit = (unsigned int)(0.6 * (double)new_len);
      }
      while(size >= new_load_limit && !(prime_idx >= (signed int)digestmap_impl_N_PRIMES));
      void *return_value_tor_reallocarray__2;
      return_value_tor_reallocarray__2=tor_reallocarray_((void *)0, (unsigned long int)new_len, sizeof(struct digestmap_entry_t *) /*8ul*/ );
      new_table = (struct digestmap_entry_t **)return_value_tor_reallocarray__2;
      if(!(new_table == ((struct digestmap_entry_t **)NULL)))
      {
        unsigned int b;
        memset_link4((void *)new_table, 0, (unsigned long int)new_len * sizeof(struct digestmap_entry_t *) /*8ul*/ );
        b = (unsigned int)0;
        for( ; !(b >= head->hth_table_length); b = b + 1u)
        {
          struct digestmap_entry_t *elm;
          struct digestmap_entry_t *next;
          unsigned int b2;
          elm = head->hth_table[(signed long int)b];
          for( ; !(elm == ((struct digestmap_entry_t *)NULL)); elm = next)
          {
            next = elm->node.hte_next;
            b2 = elm->node.hte_hash % new_len;
            elm->node.hte_next = new_table[(signed long int)b2];
            new_table[(signed long int)b2] = elm;
          }
        }
        if(!(head->hth_table == ((struct digestmap_entry_t **)NULL)))
          tor_free_((void *)head->hth_table);

        head->hth_table = new_table;
      }

      else
      {
        unsigned int digestmap_impl_HT_GROW__1__3__b;
        unsigned int digestmap_impl_HT_GROW__1__3__b2;
        void *return_value_tor_reallocarray__1;
        return_value_tor_reallocarray__1=tor_reallocarray_((void *)head->hth_table, (unsigned long int)new_len, sizeof(struct digestmap_entry_t *) /*8ul*/ );
        new_table = (struct digestmap_entry_t **)return_value_tor_reallocarray__1;
        if(new_table == ((struct digestmap_entry_t **)NULL))
          return -1;

        memset_link4((void *)(new_table + (signed long int)head->hth_table_length), 0, (unsigned long int)(new_len - head->hth_table_length) * sizeof(struct digestmap_entry_t *) /*8ul*/ );
        digestmap_impl_HT_GROW__1__3__b = (unsigned int)0;
        for( ; !(digestmap_impl_HT_GROW__1__3__b >= head->hth_table_length); digestmap_impl_HT_GROW__1__3__b = digestmap_impl_HT_GROW__1__3__b + 1u)
        {
          struct digestmap_entry_t *e;
          struct digestmap_entry_t **pE = &new_table[(signed long int)digestmap_impl_HT_GROW__1__3__b];
          e = *pE;
          for( ; !(e == ((struct digestmap_entry_t *)NULL)); e = *pE)
          {
            digestmap_impl_HT_GROW__1__3__b2 = e->node.hte_hash % new_len;
            if(digestmap_impl_HT_GROW__1__3__b2 == digestmap_impl_HT_GROW__1__3__b)
              pE = &e->node.hte_next;

            else
            {
              *pE = e->node.hte_next;
              e->node.hte_next = new_table[(signed long int)digestmap_impl_HT_GROW__1__3__b2];
              new_table[(signed long int)digestmap_impl_HT_GROW__1__3__b2] = e;
            }
          }
        }
        head->hth_table = new_table;
      }
      head->hth_table_length = new_len;
      head->hth_prime_idx = prime_idx;
      head->hth_load_limit = new_load_limit;
      return 0;
    }
}

// digestmap_impl_HT_INIT
// file ../src/common/container.c line 1091
static inline void digestmap_impl_HT_INIT(struct digestmap_impl *head)
{
  head->hth_table_length = (unsigned int)0;
  head->hth_table = (struct digestmap_entry_t **)(void *)0;
  head->hth_n_entries = (unsigned int)0;
  head->hth_load_limit = (unsigned int)0;
  head->hth_prime_idx = -1;
}

// digestmap_impl_HT_NEXT
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_NEXT(struct digestmap_impl *head, struct digestmap_entry_t **elm)
{
  if(!((*elm)->node.hte_next == ((struct digestmap_entry_t *)NULL)))
  {
    if(!((*elm)->node.hte_hash % head->hth_table_length == (*elm)->node.hte_next->node.hte_hash % head->hth_table_length))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1092, "digestmap_impl_HT_NEXT", "(((*elm)->node.hte_hash) % head->hth_table_length) == ((((*elm)->node.hte_next)->node.hte_hash) % head->hth_table_length)");
      abort();
    }

    return &(*elm)->node.hte_next;
  }

  else
  {
    unsigned int b = (*elm)->node.hte_hash % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct digestmap_entry_t *)NULL)))
      {
        if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
        {
          tor_assertion_failed_("../src/common/container.c", (unsigned int)1092, "digestmap_impl_HT_NEXT", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
          abort();
        }

        return &head->hth_table[(signed long int)b];
      }

    return (struct digestmap_entry_t **)(void *)0;
  }
}

// digestmap_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_NEXT_RMV(struct digestmap_impl *head, struct digestmap_entry_t **elm)
{
  unsigned int h = (*elm)->node.hte_hash;
  *elm = (*elm)->node.hte_next;
  head->hth_n_entries = head->hth_n_entries - 1u;
  if(!(*elm == ((struct digestmap_entry_t *)NULL)))
    return elm;

  else
  {
    unsigned int b = h % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct digestmap_entry_t *)NULL)))
        return &head->hth_table[(signed long int)b];

    return (struct digestmap_entry_t **)(void *)0;
  }
}

// digestmap_impl_HT_REMOVE
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t * digestmap_impl_HT_REMOVE(struct digestmap_impl *head, struct digestmap_entry_t *elm)
{
  struct digestmap_entry_t **p;
  struct digestmap_entry_t *r;
  do
    elm->node.hte_hash=digestmap_entry_hash(elm);
  while((_Bool)0);
  p=digestmap_impl_HT_FIND_P_(head, elm);
  _Bool tmp_if_expr_1;
  if(p == ((struct digestmap_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*p != ((struct digestmap_entry_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct digestmap_entry_t *)(void *)0;

  else
  {
    r = *p;
    *p = r->node.hte_next;
    r->node.hte_next = (struct digestmap_entry_t *)(void *)0;
    head->hth_n_entries = head->hth_n_entries - 1u;
    return r;
  }
}

// digestmap_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1093
signed int digestmap_impl_HT_REP_IS_BAD_(struct digestmap_impl *head)
{
  unsigned int n;
  unsigned int i;
  struct digestmap_entry_t *elm;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(head->hth_table_length == 0u)
  {
    if(head->hth_table == ((struct digestmap_entry_t **)NULL))
      tmp_if_expr_1 = !(head->hth_n_entries != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = head->hth_prime_idx == -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return 0;

    return 1;
  }

  else
  {
    if(head->hth_table == ((struct digestmap_entry_t **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = head->hth_prime_idx < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 2;

    else
      if(!(head->hth_load_limit >= head->hth_n_entries))
        return 3;

      else
        if(!(head->hth_table_length == digestmap_impl_PRIMES[(signed long int)head->hth_prime_idx]))
          return 4;

        else
          if(!(head->hth_load_limit == (unsigned int)(0.6 * (double)head->hth_table_length)))
            return 5;

          else
          {
            i = (unsigned int)0;
            n = i;
            for( ; !(i >= head->hth_table_length); i = i + 1u)
            {
              elm = head->hth_table[(signed long int)i];
              for( ; !(elm == ((struct digestmap_entry_t *)NULL)); elm = elm->node.hte_next)
              {
                unsigned int return_value_digestmap_entry_hash_6;
                return_value_digestmap_entry_hash_6=digestmap_entry_hash(elm);
                if(!(elm->node.hte_hash == return_value_digestmap_entry_hash_6))
                  return (signed int)((unsigned int)1000 + i);

                if(!(elm->node.hte_hash % head->hth_table_length == i))
                  return (signed int)((unsigned int)10000 + i);

                n = n + 1u;
              }
            }
            if(!(n == head->hth_n_entries))
              return 6;

            else
              return 0;
          }
  }
}

// digestmap_impl_HT_START
// file ../src/common/container.c line 1091
static inline struct digestmap_entry_t ** digestmap_impl_HT_START(struct digestmap_impl *head)
{
  unsigned int b = (unsigned int)0;
  for( ; !(b >= head->hth_table_length); b = b + 1u)
    if(!(head->hth_table[(signed long int)b] == ((struct digestmap_entry_t *)NULL)))
    {
      if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)1092, "digestmap_impl_HT_START", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
        abort();
      }

      return &head->hth_table[(signed long int)b];
    }

  return (struct digestmap_entry_t **)(void *)0;
}

// digestmap_isempty
// file ../src/common/container.c line 1366
signed int digestmap_isempty(const struct digestmap_t *map)
{
  return (signed int)((&map->head)->hth_n_entries == (unsigned int)0 ? (_Bool)1 : (0 != 0 ? (_Bool)1 : (_Bool)0));
}

// digestmap_iter_done
// file ../src/common/container.c line 1366
signed int digestmap_iter_done(struct digestmap_entry_t **iter)
{
  return (signed int)(iter == (struct digestmap_entry_t **)(void *)0);
}

// digestmap_iter_get
// file ../src/common/container.c line 1366
void digestmap_iter_get(struct digestmap_entry_t **iter, const char **keyp, void **valp)
{
  if(iter == ((struct digestmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_get", "iter");
    abort();
  }

  if(*iter == ((struct digestmap_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_get", "*iter");
    abort();
  }

  if(keyp == ((const char **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_get", "keyp");
    abort();
  }

  if(valp == ((void **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_get", "valp");
    abort();
  }

  *keyp = (*iter)->key;
  *valp = (*iter)->val;
}

// digestmap_iter_init
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_init(struct digestmap_t *map)
{
  if(map == ((struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_init", "map");
    abort();
  }

  struct digestmap_entry_t **return_value_digestmap_impl_HT_START_1;
  return_value_digestmap_impl_HT_START_1=digestmap_impl_HT_START(&map->head);
  return return_value_digestmap_impl_HT_START_1;
}

// digestmap_iter_next
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_next(struct digestmap_t *map, struct digestmap_entry_t **iter)
{
  if(map == ((struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_next", "map");
    abort();
  }

  if(iter == ((struct digestmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_next", "iter");
    abort();
  }

  struct digestmap_entry_t **return_value_digestmap_impl_HT_NEXT_1;
  return_value_digestmap_impl_HT_NEXT_1=digestmap_impl_HT_NEXT(&map->head, iter);
  return return_value_digestmap_impl_HT_NEXT_1;
}

// digestmap_iter_next_rmv
// file ../src/common/container.c line 1366
struct digestmap_entry_t ** digestmap_iter_next_rmv(struct digestmap_t *map, struct digestmap_entry_t **iter)
{
  struct digestmap_entry_t *rmv;
  if(map == ((struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_next_rmv", "map");
    abort();
  }

  if(iter == ((struct digestmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_next_rmv", "iter");
    abort();
  }

  if(*iter == ((struct digestmap_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_iter_next_rmv", "*iter");
    abort();
  }

  rmv = *iter;
  iter=digestmap_impl_HT_NEXT_RMV(&map->head, iter);
  digestmap_entry_free(rmv);
  return iter;
}

// digestmap_new
// file ../src/common/container.c line 1366
struct digestmap_t * digestmap_new(void)
{
  struct digestmap_t *result;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct digestmap_t) /*24ul*/ );
  result = (struct digestmap_t *)return_value_tor_malloc__1;
  digestmap_impl_HT_INIT(&result->head);
  return result;
}

// digestmap_remove
// file ../src/common/container.c line 1366
void * digestmap_remove(struct digestmap_t *map, const char *key)
{
  struct digestmap_entry_t *resolve;
  struct digestmap_entry_t search;
  void *oldval;
  if(map == ((struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_remove", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_remove", "key");
    abort();
  }

  digestmap_assign_tmp_key(&search, key);
  resolve=digestmap_impl_HT_REMOVE(&map->head, &search);
  if(!(resolve == ((struct digestmap_entry_t *)NULL)))
  {
    oldval = resolve->val;
    digestmap_entry_free(resolve);
    return oldval;
  }

  else
    return (void *)0;
}

// digestmap_set
// file ../src/common/container.c line 1366
void * digestmap_set(struct digestmap_t *map, const char *key, void *val)
{
  struct digestmap_entry_t search;
  void *oldval;
  if(map == ((struct digestmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_set", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_set", "key");
    abort();
  }

  if(val == NULL)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1366, "digestmap_set", "val");
    abort();
  }

  digestmap_assign_tmp_key(&search, key);
  struct digestmap_impl *ptr_head_ = &map->head;
  struct digestmap_entry_t **ptr;
  _Bool tmp_if_expr_1;
  if(ptr_head_->hth_table == ((struct digestmap_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ptr_head_->hth_n_entries >= ptr_head_->hth_load_limit ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    digestmap_impl_HT_GROW(ptr_head_, ptr_head_->hth_n_entries + (unsigned int)1);

  do
    (&search)->node.hte_hash=digestmap_entry_hash(&search);
  while((_Bool)0);
  ptr=digestmap_impl_HT_FIND_P_(ptr_head_, &search);
  if(!(*ptr == ((struct digestmap_entry_t *)NULL)))
  {
    oldval = (*ptr)->val;
    (*ptr)->val = val;
    return oldval;
  }

  else
  {
    struct digestmap_entry_t *newent;
    void *return_value_tor_malloc_zero__2;
    return_value_tor_malloc_zero__2=tor_malloc_zero_(sizeof(struct digestmap_entry_t) /*48ul*/ );
    newent = (struct digestmap_entry_t *)return_value_tor_malloc_zero__2;
    digestmap_assign_key(newent, key);
    newent->val = val;
    do
      newent->node.hte_hash = (&search)->node.hte_hash;
    while((_Bool)0);
    newent->node.hte_next = (struct digestmap_entry_t *)(void *)0;
    *ptr = newent;
    (&map->head)->hth_n_entries = (&map->head)->hth_n_entries + 1u;
    return (void *)0;
  }
}

// digestmap_size
// file ../src/common/container.c line 1366
signed int digestmap_size(const struct digestmap_t *map)
{
  return (signed int)(&map->head)->hth_n_entries;
}

// digestset_free
// file ../src/common/container.c line 1465
void digestset_free(struct anonymous_12 *set)
{
  if(!(set == ((struct anonymous_12 *)NULL)))
  {
    bitarray_free(set->ba);
    if(!(set == ((struct anonymous_12 *)NULL)))
    {
      free((void *)set);
      set = (struct anonymous_12 *)(void *)0;
    }

  }

}

// digestset_new
// file ../src/common/container.c line 1444
struct anonymous_12 * digestset_new(signed int max_elements)
{
  signed int n_bits;
  signed int return_value_tor_log2_1;
  return_value_tor_log2_1=tor_log2((unsigned long int)max_elements);
  n_bits = (signed int)(1u << return_value_tor_log2_1 + 5);
  struct anonymous_12 *r;
  void *return_value_tor_malloc__2;
  return_value_tor_malloc__2=tor_malloc_(sizeof(struct anonymous_12) /*16ul*/ );
  r = (struct anonymous_12 *)return_value_tor_malloc__2;
  r->mask = n_bits - 1;
  r->ba=bitarray_init_zero((unsigned int)n_bits);
  return r;
}

// digit_to_num
// file ../src/common/util.c line 3032
static signed int digit_to_num(char d)
{
  signed int num = (signed int)d - (signed int)48;
  if(!(num >= 0) || num >= 10)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)3035, "digit_to_num", "num <= 9 && num >= 0");
    abort();
  }

  return num;
}

// dimap_add_entry
// file ../src/common/di_ops.c line 164
void dimap_add_entry(struct di_digest256_map_t **map, const unsigned char *key, void *val)
{
  struct di_digest256_map_t *new_ent;
  void *old_val;
  old_val=dimap_search(*map, key, (void *)0);
  if(!(old_val == NULL))
  {
    tor_assertion_failed_("../src/common/di_ops.c", (unsigned int)170, "dimap_add_entry", "! old_val");
    abort();
  }

  if(val == NULL)
  {
    tor_assertion_failed_("../src/common/di_ops.c", (unsigned int)171, "dimap_add_entry", "val");
    abort();
  }

  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct di_digest256_map_t) /*48ul*/ );
  new_ent = (struct di_digest256_map_t *)return_value_tor_malloc_zero__1;
  new_ent->next = *map;
  memcpy_link4((void *)new_ent->key, (const void *)key, (unsigned long int)32);
  new_ent->val = val;
  *map = new_ent;
}

// dimap_free
// file ../src/common/di_ops.c line 147
void dimap_free(struct di_digest256_map_t *map, void (*free_fn)(void *))
{
  while(!(map == ((struct di_digest256_map_t *)NULL)))
  {
    struct di_digest256_map_t *victim = map;
    map = map->next;
    if(!(free_fn == ((void (*)(void *))NULL)))
      free_fn(victim->val);

    if(!(victim == ((struct di_digest256_map_t *)NULL)))
    {
      free((void *)victim);
      victim = (struct di_digest256_map_t *)(void *)0;
    }

  }
}

// dimap_search
// file ../src/common/di_ops.c line 188
void * dimap_search(const struct di_digest256_map_t *map, const unsigned char *key, void *dflt_val)
{
  unsigned long int result = (unsigned long int)dflt_val;
  while(!(map == ((const struct di_digest256_map_t *)NULL)))
  {
    unsigned long int r;
    signed int return_value_tor_memeq_1;
    return_value_tor_memeq_1=tor_memeq((const void *)map->key, (const void *)key, (unsigned long int)32);
    r = (unsigned long int)return_value_tor_memeq_1;
    r = r - (unsigned long int)1;
    result = result & r;
    result = result | (unsigned long int)map->val & ~r;
    map = map->next;
  }
  return (void *)result;
}

// do_resolve
// file ../src/tools/tor-resolve.c line 195
static signed int do_resolve(const char *hostname, unsigned int sockshost, unsigned short int socksport, signed int reverse, signed int version, struct tor_addr_t *result_addr, char **result_hostname)
{
  signed int s = -1;
  struct sockaddr_in socksaddr;
  char *req = (char *)(void *)0;
  signed long int len = (signed long int)0;
  if(hostname == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)204, "do_resolve", "hostname");
    abort();
  }

  if(result_addr == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)205, "do_resolve", "result_addr");
    abort();
  }

  if(!(version == 4) && !(version == 5))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)206, "do_resolve", "version == 4 || version == 5");
    abort();
  }

  tor_addr_make_unspec(result_addr);
  *result_hostname = (char *)(void *)0;
  s=tor_open_socket(2, 1, 6);
  unsigned short int tmp_statement_expression_3;
  signed long int return_value_write_all_11;
  signed int return_value_strcasecmpend_16;
  if(!(s >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(3, 1u << 2, "do_resolve", "Error while %s: %s", (const void *)"creating_socket", return_value_strerror_2);
    return -1;
  }

  else
  {
    memset((void *)&socksaddr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    socksaddr.sin_family = (unsigned short int)2;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)socksport;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_3 = __v;
    socksaddr.sin_port = tmp_statement_expression_3;
    socksaddr.sin_addr.s_addr=__bswap_32(sockshost);
    signed int return_value_connect_6;
    return_value_connect_6=connect(s, (struct sockaddr *)&socksaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_connect_6 == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_fn_(3, 1u << 2, "do_resolve", "Error while %s: %s", (const void *)"connecting to SOCKS host", return_value_strerror_5);
    }

    else
    {
      if(version == 5)
      {
        char method_buf[2l];
        signed long int return_value_write_all_7;
        return_value_write_all_7=write_all(s, "\005\001\0", (unsigned long int)3, 1);
        if(!(return_value_write_all_7 == 3l))
        {
          log_fn_(3, 1u << 2, "do_resolve", "Error sending SOCKS5 method list.");
          goto err;
        }

        signed long int return_value_read_all_8;
        return_value_read_all_8=read_all(s, method_buf, (unsigned long int)2, 1);
        if(!(return_value_read_all_8 == 2l))
        {
          log_fn_(3, 1u << 2, "do_resolve", "Error reading SOCKS5 methods.");
          goto err;
        }

        if(!((signed int)method_buf[0l] == 5))
        {
          log_fn_(3, 1u << 2, "do_resolve", "Unrecognized socks version: %u", (unsigned int)method_buf[(signed long int)0]);
          goto err;
        }

        if(!((signed int)method_buf[1l] == 0))
        {
          log_fn_(3, 1u << 2, "do_resolve", "Unrecognized socks authentication method: %u", (unsigned int)method_buf[(signed long int)1]);
          goto err;
        }

      }

      len=build_socks_resolve_request(&req, "", hostname, reverse, version);
      if(!(len >= 0l))
      {
        log_fn_(3, 1u << 12, "do_resolve", "Error generating SOCKS request");
        if(!(req == ((char *)NULL)))
        {
          tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)251, "do_resolve", "!req");
          abort();
        }

      }

      else
      {
        return_value_write_all_11=write_all(s, req, (unsigned long int)len, 1);
        if(!(return_value_write_all_11 == len))
        {
          signed int *return_value___errno_location_9;
          return_value___errno_location_9=__errno_location();
          char *return_value_strerror_10;
          return_value_strerror_10=strerror(*return_value___errno_location_9);
          log_fn_(3, 1u << 2, "do_resolve", "Error while %s: %s", (const void *)"sending SOCKS request", return_value_strerror_10);
          if(!(req == ((char *)NULL)))
          {
            free((void *)req);
            req = (char *)(void *)0;
          }

        }

        else
        {
          if(!(req == ((char *)NULL)))
          {
            free((void *)req);
            req = (char *)(void *)0;
          }

          if(version == 4)
          {
            char reply_buf[8l];
            signed long int return_value_read_all_12;
            return_value_read_all_12=read_all(s, reply_buf, (unsigned long int)8, 1);
            if(!(return_value_read_all_12 == 8l))
            {
              log_fn_(3, 1u << 2, "do_resolve", "Error reading SOCKS4 response.");
              goto err;
            }

            signed int return_value_parse_socks4a_resolve_response_13;
            return_value_parse_socks4a_resolve_response_13=parse_socks4a_resolve_response(hostname, reply_buf, (unsigned long int)8, result_addr);
            if(!(return_value_parse_socks4a_resolve_response_13 >= 0))
              goto err;

          }

          else
          {
            char do_resolve__1__12__reply_buf[16l];
            signed long int return_value_read_all_14;
            return_value_read_all_14=read_all(s, do_resolve__1__12__reply_buf, (unsigned long int)4, 1);
            if(!(return_value_read_all_14 == 4l))
            {
              log_fn_(3, 1u << 2, "do_resolve", "Error reading SOCKS5 response.");
              goto err;
            }

            if(!((signed int)do_resolve__1__12__reply_buf[0l] == 5))
            {
              log_fn_(3, 1u << 2, "do_resolve", "Bad SOCKS5 reply version.");
              goto err;
            }

            if(!((signed int)do_resolve__1__12__reply_buf[1l] == 0))
            {
              const char *return_value_socks5_reason_to_string_15;
              return_value_socks5_reason_to_string_15=socks5_reason_to_string(do_resolve__1__12__reply_buf[(signed long int)1]);
              log_fn_(4, 1u << 2, "do_resolve", "Got SOCKS5 status response '%u': %s", (unsigned int)do_resolve__1__12__reply_buf[(signed long int)1], return_value_socks5_reason_to_string_15);
              if((signed int)do_resolve__1__12__reply_buf[1l] == 4)
              {
                return_value_strcasecmpend_16=strcasecmpend(hostname, ".onion");
                if(return_value_strcasecmpend_16 == 0)
                  onion_warning(hostname);

              }

              goto err;
            }

            if((signed int)do_resolve__1__12__reply_buf[3l] == 1)
            {
              signed long int return_value_read_all_17;
              return_value_read_all_17=read_all(s, do_resolve__1__12__reply_buf, (unsigned long int)4, 1);
              if(!(return_value_read_all_17 == 4l))
              {
                log_fn_(3, 1u << 2, "do_resolve", "Error reading address in socks5 response.");
                goto err;
              }

              unsigned int return_value_get_uint32_18;
              return_value_get_uint32_18=get_uint32((const void *)do_resolve__1__12__reply_buf);
              tor_addr_from_ipv4n(result_addr, return_value_get_uint32_18);
            }

            else
              if((signed int)do_resolve__1__12__reply_buf[3l] == 4)
              {
                signed long int return_value_read_all_19;
                return_value_read_all_19=read_all(s, do_resolve__1__12__reply_buf, (unsigned long int)16, 1);
                if(!(return_value_read_all_19 == 16l))
                {
                  log_fn_(3, 1u << 2, "do_resolve", "Error reading address in socks5 response.");
                  goto err;
                }

                tor_addr_from_ipv6_bytes(result_addr, do_resolve__1__12__reply_buf);
              }

              else
                if((signed int)do_resolve__1__12__reply_buf[3l] == 3)
                {
                  unsigned long int result_len;
                  signed long int return_value_read_all_20;
                  return_value_read_all_20=read_all(s, do_resolve__1__12__reply_buf, (unsigned long int)1, 1);
                  if(!(return_value_read_all_20 == 1l))
                  {
                    log_fn_(3, 1u << 2, "do_resolve", "Error reading address_length in socks5 response.");
                    goto err;
                  }

                  result_len = (unsigned long int)*((unsigned char *)do_resolve__1__12__reply_buf);
                  void *return_value_tor_malloc__21;
                  return_value_tor_malloc__21=tor_malloc_(result_len + (unsigned long int)1);
                  *result_hostname = (char *)return_value_tor_malloc__21;
                  signed long int return_value_read_all_22;
                  return_value_read_all_22=read_all(s, *result_hostname, result_len, 1);
                  if(!(return_value_read_all_22 == (signed long int)(signed int)result_len))
                  {
                    log_fn_(3, 1u << 2, "do_resolve", "Error reading hostname in socks5 response.");
                    goto err;
                  }

                  (*result_hostname)[(signed long int)result_len] = (char)0;
                }

          }
          tor_close_socket(s);
          return 0;
        }
      }
    }

  err:
    ;
    tor_close_socket(s);
    return -1;
  }
}

// domain_to_string
// file ../src/common/log.c line 1243
static char * domain_to_string(unsigned int domain, char *buf, unsigned long int buflen)
{
  char *cp = buf;
  char *eos = buf + (signed long int)buflen;
  buf[(signed long int)0] = (char)0;
  if(domain == 0u)
    return buf;

  else
    while((_Bool)1)
    {
      const char *d;
      signed int bit;
      bit=tor_log2((unsigned long int)domain);
      unsigned long int n;
      if(bit >= 23 || (unsigned long int)(unsigned int)bit >= 23ul)
      {
        tor_snprintf(buf, buflen, "<BUG:Unknown domain %lx>", (signed long int)domain);
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(buf);
        return buf + (signed long int)return_value_strlen_1;
      }

      d = domain_list[(signed long int)bit];
      n=strlcpy(cp, d, (unsigned long int)(eos - cp));
      if(n >= buflen)
      {
        tor_snprintf(buf, buflen, "<BUG:Truncating domain %lx>", (signed long int)domain);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(buf);
        return buf + (signed long int)return_value_strlen_2;
      }

      cp = cp + (signed long int)n;
      domain = domain & (unsigned int)~(1 << bit);
      if(domain == 0u || !(eos - cp >= 2l))
        return cp;

      memcpy_link5((void *)cp, (const void *)",", (unsigned long int)2);
      cp = cp + 1l;
    }
}

// eat_whitespace
// file ../src/common/util.h line 224
const char * eat_whitespace(const char *s)
{
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)790, "eat_whitespace", "s");
    abort();
  }

  while((_Bool)1)
  {
    if(!((signed int)*s == 0))
    {
      if((signed int)*s == 9 || (signed int)*s == 10 || (signed int)*s == 13 || (signed int)*s == 32)
        goto __CPROVER_DUMP_L3;

      if((signed int)*s == 35)
        goto __CPROVER_DUMP_L4;

    }

    return s;

  __CPROVER_DUMP_L3:
    ;
    s = s + 1l;
    continue;

  __CPROVER_DUMP_L4:
    ;
    s = s + 1l;
    for( ; !(*s == 0); s = s + 1l)
      if((signed int)*s == 10)
        break;

  }
}

// eat_whitespace_eos
// file ../src/common/util.c line 815
const char * eat_whitespace_eos(const char *s, const char *eos)
{
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)817, "eat_whitespace_eos", "s");
    abort();
  }

  if(!(eos >= s) || eos == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)818, "eat_whitespace_eos", "eos && s <= eos");
    abort();
  }

  while(!(s >= eos))
    switch((signed int)*s)
    {
      case 0:
        return s;
      case 32:

      case 9:

      case 10:

      case 13:
      {
        s = s + 1l;
        break;
      }
      case 35:
      {
        s = s + 1l;
        for( ; !(s >= eos); s = s + 1l)
        {
          if(*s == 0)
            break;

          if((signed int)*s == 10)
            break;

        }
      }
    }
  return s;
}

// eat_whitespace_eos_no_nl
// file ../src/common/util.c line 853
const char * eat_whitespace_eos_no_nl(const char *s, const char *eos)
{
  for( ; !(s >= eos); s = s + 1l)
    if(!((signed int)*s == 32))
    {
      if(!((signed int)*s == 9))
      {
        if(!((signed int)*s == 13))
          break;

      }

    }

  return s;
}

// eat_whitespace_no_nl
// file ../src/common/util.c line 843
const char * eat_whitespace_no_nl(const char *s)
{
  for( ; (_Bool)1; s = s + 1l)
    if(!((signed int)*s == 32))
    {
      if(!((signed int)*s == 9))
      {
        if(!((signed int)*s == 13))
          goto __CPROVER_DUMP_L3;

      }

    }


__CPROVER_DUMP_L3:
  ;
  return s;
}

// environment_variable_names_equal
// file ../src/common/util.c line 4477
signed int environment_variable_names_equal(const char *s1, const char *s2)
{
  unsigned long int s1_name_len;
  s1_name_len=str_num_before(s1, (char)61);
  unsigned long int s2_name_len;
  s2_name_len=str_num_before(s2, (char)61);
  _Bool tmp_if_expr_2;
  signed int return_value_tor_memeq_1;
  if(s1_name_len == s2_name_len)
  {
    return_value_tor_memeq_1=tor_memeq((const void *)s1, (const void *)s2, s1_name_len);
    tmp_if_expr_2 = return_value_tor_memeq_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// esc_for_log
// file ../src/common/util.h line 241
char * esc_for_log(const char *s)
{
  const char *cp;
  char *result;
  char *outp;
  unsigned long int len = (unsigned long int)3;
  if(s == ((const char *)NULL))
  {
    char *return_value_tor_strdup__1;
    return_value_tor_strdup__1=tor_strdup_("(null)");
    return return_value_tor_strdup__1;
  }

  cp = s;
  _Bool tmp_if_expr_3;
  for( ; !(*cp == 0); cp = cp + 1l)
  {
    if((signed int)*cp == 9 || (signed int)*cp == 10 || (signed int)*cp == 13 || (signed int)*cp == 34 || (signed int)*cp == 39 || (signed int)*cp == 92)
    {
      len = len + (unsigned long int)2;
      goto __CPROVER_DUMP_L9;
    }

    signed int return_value_TOR_ISPRINT_2;
    return_value_TOR_ISPRINT_2=TOR_ISPRINT(*cp);
    if(!(return_value_TOR_ISPRINT_2 == 0))
      tmp_if_expr_3 = (signed int)(unsigned char)*cp < 127 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      len = len + 1ul;

    else
      len = len + (unsigned long int)4;

  __CPROVER_DUMP_L9:
    ;
  }
  if(len >= 9223372036854775808ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1338, "esc_for_log", "len <= SSIZE_MAX");
    abort();
  }

  void *return_value_tor_malloc__4;
  return_value_tor_malloc__4=tor_malloc_(len);
  outp = (char *)return_value_tor_malloc__4;
  result = outp;
  char *tmp_post_5 = outp;
  outp = outp + 1l;
  *tmp_post_5 = (char)34;
  cp = s;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  signed int return_value_TOR_ISPRINT_15;
  _Bool tmp_if_expr_16;
  char *tmp_post_14;
  for( ; !(*cp == 0); cp = cp + 1l)
  {
    if(outp - result >= (signed long int)len + -2l)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)1345, "esc_for_log", "(outp-result) < (ssize_t)len-2");
      abort();
    }

    switch((signed int)*cp)
    {
      case 92:

      case 34:

      case 39:
      {
        tmp_post_6 = outp;
        outp = outp + 1l;
        *tmp_post_6 = (char)92;
        tmp_post_7 = outp;
        outp = outp + 1l;
        *tmp_post_7 = *cp;
        break;
      }
      case 10:
      {
        tmp_post_8 = outp;
        outp = outp + 1l;
        *tmp_post_8 = (char)92;
        tmp_post_9 = outp;
        outp = outp + 1l;
        *tmp_post_9 = (char)110;
        break;
      }
      case 9:
      {
        tmp_post_10 = outp;
        outp = outp + 1l;
        *tmp_post_10 = (char)92;
        tmp_post_11 = outp;
        outp = outp + 1l;
        *tmp_post_11 = (char)116;
        break;
      }
      case 13:
      {
        tmp_post_12 = outp;
        outp = outp + 1l;
        *tmp_post_12 = (char)92;
        tmp_post_13 = outp;
        outp = outp + 1l;
        *tmp_post_13 = (char)114;
        break;
      }
      default:
      {
        return_value_TOR_ISPRINT_15=TOR_ISPRINT(*cp);
        if(!(return_value_TOR_ISPRINT_15 == 0))
          tmp_if_expr_16 = (signed int)(unsigned char)*cp < 127 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
        {
          tmp_post_14 = outp;
          outp = outp + 1l;
          *tmp_post_14 = *cp;
        }

        else
        {
          if(outp - result >= (signed long int)len + -4l)
          {
            tor_assertion_failed_("../src/common/util.c", (unsigned int)1369, "esc_for_log", "(outp-result) < (ssize_t)len-4");
            abort();
          }

          tor_snprintf(outp, (unsigned long int)5, "\\%03o", (signed int)(unsigned char)*cp);
          outp = outp + (signed long int)4;
        }
      }
    }
  }
  if(!((signed long int)len + -2l >= outp - result))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1377, "esc_for_log", "(outp-result) <= (ssize_t)len-2");
    abort();
  }

  char *tmp_post_17 = outp;
  outp = outp + 1l;
  *tmp_post_17 = (char)34;
  char *tmp_post_18 = outp;
  outp = outp + 1l;
  *tmp_post_18 = (char)0;
  return result;
}

// esc_for_log_len
// file ../src/common/util.c line 1390
char * esc_for_log_len(const char *chars, unsigned long int n)
{
  char *string;
  string=tor_strndup_(chars, n);
  char *string_escaped;
  string_escaped=esc_for_log(string);
  if(!(string == ((char *)NULL)))
  {
    free((void *)string);
    string = (char *)(void *)0;
  }

  return string_escaped;
}

// escaped
// file ../src/common/util.h line 243
const char * escaped(const char *s)
{
  static char *escaped_val_ = (char *)(void *)0;
  if(!(escaped_val_ == ((char *)NULL)))
  {
    free((void *)escaped_val_);
    escaped_val_ = (char *)(void *)0;
  }

  if(!(s == ((const char *)NULL)))
    escaped_val_=esc_for_log(s);

  else
    escaped_val_ = (char *)(void *)0;
  return escaped_val_;
}

// eventfd_alert
// file ../src/common/compat_threads.c line 139
static signed int eventfd_alert(signed int fd)
{
  unsigned long int u = (unsigned long int)1;
  signed int r;
  r=write_ni(fd, (void *)&u, sizeof(unsigned long int) /*8ul*/ );
  signed int *return_value___errno_location_1;
  if(!(r >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// eventfd_drain
// file ../src/common/compat_threads.c line 149
static signed int eventfd_drain(signed int fd)
{
  unsigned long int u = (unsigned long int)0;
  signed int r;
  r=read_ni(fd, (void *)&u, sizeof(unsigned long int) /*8ul*/ );
  signed int *return_value___errno_location_1;
  if(!(r >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// expand_filename
// file ../src/common/util.c line 2973
char * expand_filename(const char *filename)
{
  if(filename == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2975, "expand_filename", "filename");
    abort();
  }

  _Bool tmp_if_expr_3;
  signed int return_value_strcmpend_5;
  if((signed int)*filename == 126)
  {
    char *home;
    char *result = (char *)(void *)0;
    const char *rest;
    if((signed int)filename[1l] == 47)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)filename[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      home=getenv("HOME");
      if(home == ((char *)NULL))
      {
        log_fn_(4, 1u << 3, "expand_filename", "Couldn't find _HOME environment variable while expanding \"%s\"; defaulting to \"\".", filename);
        home=tor_strdup_("");
      }

      else
        home=tor_strdup_(home);
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(filename);
      rest = return_value_strlen_1 >= (unsigned long int)2 ? filename + (signed long int)2 : "";
    }

    else
    {
      char *username;
      char *slash;
      char *return_value___builtin_strchr_2;
      return_value___builtin_strchr_2=__builtin_strchr(filename, 47);
      slash = return_value___builtin_strchr_2;
      if(!(slash == ((char *)NULL)))
        username=tor_strndup_(filename + (signed long int)1, (unsigned long int)((slash - filename) - (signed long int)1));

      else
        username=tor_strdup_(filename + (signed long int)1);
      home=get_user_homedir(username);
      if(home == ((char *)NULL))
      {
        log_fn_(4, 1u << 3, "expand_filename", "Couldn't get homedir for \"%s\"", username);
        if(!(username == ((char *)NULL)))
        {
          free((void *)username);
          username = (char *)(void *)0;
        }

        return (char *)(void *)0;
      }

      if(!(username == ((char *)NULL)))
      {
        free((void *)username);
        username = (char *)(void *)0;
      }

      rest = slash != ((char *)NULL) ? slash + (signed long int)1 : "";
    }
    if(home == ((char *)NULL))
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)3013, "expand_filename", "home");
      abort();
    }

    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(home);
    if(return_value_strlen_6 >= 2ul)
    {
      return_value_strcmpend_5=strcmpend(home, "/");
      if(return_value_strcmpend_5 == 0)
      {
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(home);
        home[(signed long int)(return_value_strlen_4 - (unsigned long int)1)] = (char)0;
      }

    }

    tor_asprintf(&result, "%s/%s", home, rest);
    if(!(home == ((char *)NULL)))
    {
      free((void *)home);
      home = (char *)(void *)0;
    }

    return result;
  }

  else
  {
    char *return_value_tor_strdup__7;
    return_value_tor_strdup__7=tor_strdup_(filename);
    return return_value_tor_strdup__7;
  }
}

// fast_memcmpstart
// file ../src/common/util.c line 765
signed int fast_memcmpstart(const void *mem, unsigned long int memlen, const char *prefix)
{
  unsigned long int plen;
  plen=strlen(prefix);
  if(!(memlen >= plen))
    return -1;

  else
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp(mem, (const void *)prefix, plen);
    return return_value_memcmp_1;
  }
}

// fdopen_file
// file ../src/common/util.c line 2360
struct _IO_FILE * fdopen_file(struct open_file_t *file_data)
{
  if(file_data == ((struct open_file_t *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2362, "fdopen_file", "file_data");
    abort();
  }

  if(!(file_data->stdio_file == ((struct _IO_FILE *)NULL)))
    return file_data->stdio_file;

  else
  {
    if(!(file_data->fd >= 0))
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)2365, "fdopen_file", "file_data->fd >= 0");
      abort();
    }

    file_data->stdio_file=fdopen(file_data->fd, file_data->binary != 0u ? "ab" : "a");
    if(file_data->stdio_file == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 4, "fdopen_file", "Couldn't fdopen \"%s\" [%d]: %s", file_data->filename, file_data->fd, return_value_strerror_2);
    }

    return file_data->stdio_file;
  }
}

// fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
static inline char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream)
{
  char *return_value___fgets_chk_1;
  char *return_value___fgets_chk_warn_2;
  char *return_value___fgets_alias_3;
  return_value___fgets_alias_3=__fgets_alias(__s, __n, __stream);
  return return_value___fgets_alias_3;
}

// file_status
// file ../src/common/util.c line 2055
enum anonymous_17 file_status(const char *fname)
{
  struct stat st;
  char *f;
  signed int r;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(fname == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(fname);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (enum anonymous_17)FN_ERROR;

  else
  {
    f=tor_strdup_(fname);
    clean_name_for_stat(f);
    if(log_global_min_severity_ == 7)
      log_fn_(7, 1u << 4, "file_status", "stat()ing %s", f);

    const char *return_value_sandbox_intern_string_3;
    return_value_sandbox_intern_string_3=sandbox_intern_string(f);
    r=stat(return_value_sandbox_intern_string_3, &st);
    if(!(f == ((char *)NULL)))
    {
      free((void *)f);
      f = (char *)(void *)0;
    }

    if(!(r == 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 2)
        return (enum anonymous_17)FN_NOENT;

      return (enum anonymous_17)FN_ERROR;
    }

    if(!((16384u & st.st_mode) == 0u))
      return (enum anonymous_17)FN_DIR;

    else
      if(!((32768u & st.st_mode) == 0u))
      {
        if(st.st_size >= 1l)
          return (enum anonymous_17)FN_FILE;

        else
          if(st.st_size == 0l)
            return (enum anonymous_17)FN_EMPTY;

          else
            return (enum anonymous_17)FN_ERROR;
      }

      else
        if(!((4096u & st.st_mode) == 0u))
          return (enum anonymous_17)FN_FILE;

        else
          return (enum anonymous_17)FN_ERROR;
  }
}

// find_nth_double
// file ../src/common/container.c line 1436
double find_nth_double(double *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1436, "find_nth_double", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1436, "find_nth_double", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(double) /*8ul*/ , _cmp_double);
  return array[(signed long int)nth];
}

// find_nth_int
// file ../src/common/container.c line 1434
signed int find_nth_int(signed int *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1434, "find_nth_int", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1434, "find_nth_int", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(signed int) /*4ul*/ , _cmp_int);
  return array[(signed long int)nth];
}

// find_nth_int32
// file ../src/common/container.c line 1438
signed int find_nth_int32(signed int *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1438, "find_nth_int32", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1438, "find_nth_int32", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(signed int) /*4ul*/ , _cmp_int32_t);
  return array[(signed long int)nth];
}

// find_nth_long
// file ../src/common/container.c line 1439
signed long int find_nth_long(signed long int *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1439, "find_nth_long", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1439, "find_nth_long", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(signed long int) /*8ul*/ , _cmp_long);
  return array[(signed long int)nth];
}

// find_nth_time
// file ../src/common/container.c line 1435
signed long int find_nth_time(signed long int *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1435, "find_nth_time", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1435, "find_nth_time", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(signed long int) /*8ul*/ , _cmp_time_t);
  return array[(signed long int)nth];
}

// find_nth_uint32
// file ../src/common/container.c line 1437
unsigned int find_nth_uint32(unsigned int *array, signed int n_elements, signed int nth)
{
  if(!(nth >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1437, "find_nth_uint32", "nth >= 0");
    abort();
  }

  if(nth >= n_elements)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1437, "find_nth_uint32", "nth < n_elements");
    abort();
  }

  qsort((void *)array, (unsigned long int)n_elements, sizeof(unsigned int) /*4ul*/ , _cmp_uint32_t);
  return array[(signed long int)nth];
}

// find_str_at_start_of_line
// file ../src/common/util.c line 911
const char * find_str_at_start_of_line(const char *haystack, const char *needle)
{
  unsigned long int needle_len;
  needle_len=strlen(needle);
  do
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(haystack, needle, needle_len);
    if(return_value_strncmp_1 == 0)
      return haystack;

    char *return_value___builtin_strchr_2;
    return_value___builtin_strchr_2=__builtin_strchr(haystack, 10);
    haystack = return_value___builtin_strchr_2;
    if(haystack == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      haystack = haystack + 1l;
  }
  while(!(*haystack == 0));
  return (const char *)(void *)0;
}

// find_whitespace
// file ../src/common/util.c line 864
const char * find_whitespace(const char *s)
{
  for( ; (_Bool)1; s = s + 1l)
    if((signed int)*s == 0 || (signed int)*s == 9 || (signed int)*s == 10 || (signed int)*s == 13 || (signed int)*s == 32 || (signed int)*s == 35)
      return s;

}

// find_whitespace_eos
// file ../src/common/util.c line 886
const char * find_whitespace_eos(const char *s, const char *eos)
{
  for( ; !(s >= eos); s = s + 1l)
    if((signed int)*s == 0 || (signed int)*s == 9 || (signed int)*s == 10 || (signed int)*s == 13 || (signed int)*s == 32 || (signed int)*s == 35)
      return s;

  return s;
}

// finish_daemon
// file ../src/common/util.c line 3508
void finish_daemon(const char *desired_cwd)
{
  signed int nullfd;
  char c = (char)46;
  _Bool tmp_if_expr_4;
  signed int return_value_dup2_3;
  _Bool tmp_if_expr_6;
  signed int return_value_dup2_5;
  if(finish_daemon_called == 0)
  {
    if(start_daemon_called == 0)
      start_daemon();

    finish_daemon_called = 1;
    if(desired_cwd == ((const char *)NULL))
      desired_cwd = "/";

    signed int return_value_chdir_1;
    return_value_chdir_1=chdir(desired_cwd);
    if(!(return_value_chdir_1 >= 0))
    {
      log_fn_(3, 1u << 0, "finish_daemon", "chdir to \"%s\" failed. Exiting.", desired_cwd);
      exit(1);
    }

    nullfd=tor_open_cloexec("/dev/null", 02, (unsigned int)0);
    if(!(nullfd >= 0))
    {
      log_fn_(3, 1u << 0, "finish_daemon", "/dev/null can't be opened. Exiting.");
      exit(1);
    }

    signed int return_value_dup2_2;
    return_value_dup2_2=dup2(nullfd, 0);
    if(!(return_value_dup2_2 >= 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_dup2_3=dup2(nullfd, 1);
      tmp_if_expr_4 = return_value_dup2_3 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_dup2_5=dup2(nullfd, 2);
      tmp_if_expr_6 = return_value_dup2_5 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      log_fn_(3, 1u << 0, "finish_daemon", "dup2 failed. Exiting.");
      exit(1);
    }

    if(nullfd >= 3)
      close(nullfd);

    signed long int return_value_write_7;
    return_value_write_7=write(daemon_filedes[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
    if(!((unsigned long int)return_value_write_7 == sizeof(char) /*1ul*/ ))
      log_fn_(3, 1u << 0, "finish_daemon", "write failed. Exiting.");

    close(daemon_filedes[(signed long int)1]);
  }

}

// finish_writing_to_file
// file ../src/common/util.c line 2443
signed int finish_writing_to_file(struct open_file_t *file_data)
{
  signed int return_value_finish_writing_to_file_impl_1;
  return_value_finish_writing_to_file_impl_1=finish_writing_to_file_impl(file_data, 0);
  return return_value_finish_writing_to_file_impl_1;
}

// finish_writing_to_file_impl
// file ../src/common/util.c line 2395
static signed int finish_writing_to_file_impl(struct open_file_t *file_data, signed int abort_write)
{
  signed int r = 0;
  _Bool tmp_if_expr_1;
  if(!(file_data == ((struct open_file_t *)NULL)))
    tmp_if_expr_1 = file_data->filename != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2399, "finish_writing_to_file_impl", "file_data && file_data->filename");
    abort();
  }

  signed int return_value_close_7;
  if(!(file_data->stdio_file == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fclose_4;
    return_value_fclose_4=fclose(file_data->stdio_file);
    if(!(return_value_fclose_4 == 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_fn_(4, 1u << 4, "finish_writing_to_file_impl", "Error closing \"%s\": %s", file_data->filename, return_value_strerror_3);
      r = -1;
      abort_write = r;
    }

  }

  else
    if(file_data->fd >= 0)
    {
      return_value_close_7=close(file_data->fd);
      if(!(return_value_close_7 >= 0))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        char *return_value_strerror_6;
        return_value_strerror_6=strerror(*return_value___errno_location_5);
        log_fn_(4, 1u << 4, "finish_writing_to_file_impl", "Error flushing \"%s\": %s", file_data->filename, return_value_strerror_6);
        r = -1;
        abort_write = r;
      }

    }

  _Bool tmp_if_expr_8;
  signed int tmp_statement_expression_11;
  if(!(file_data->rename_on_close == 0u))
  {
    if(!(file_data->tempname == ((char *)NULL)))
      tmp_if_expr_8 = file_data->filename != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_8 = (_Bool)0;
    if(!tmp_if_expr_8)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)2413, "finish_writing_to_file_impl", "file_data->tempname && file_data->filename");
      abort();
    }

    if(!(abort_write == 0))
    {
      signed int res;
      res=unlink(file_data->tempname);
      if(!(res == 0))
      {
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        char *return_value_strerror_10;
        return_value_strerror_10=strerror(*return_value___errno_location_9);
        log_fn_(4, 1u << 4, "finish_writing_to_file_impl", "Failed to unlink %s: %s", file_data->tempname, return_value_strerror_10);
        r = -1;
      }

    }

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_12;
      return_value___builtin_strcmp_12=__builtin_strcmp(file_data->filename, file_data->tempname);
      tmp_statement_expression_11 = return_value___builtin_strcmp_12;
      if(tmp_statement_expression_11 == 0)
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)2423, "finish_writing_to_file_impl", "strcmp(file_data->filename, file_data->tempname)");
        abort();
      }

      signed int return_value_replace_file_15;
      return_value_replace_file_15=replace_file(file_data->tempname, file_data->filename);
      if(!(return_value_replace_file_15 == 0))
      {
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        log_fn_(4, 1u << 4, "finish_writing_to_file_impl", "Error replacing \"%s\": %s", file_data->filename, return_value_strerror_14);
        r = -1;
      }

    }
  }

  if(!(file_data->filename == ((char *)NULL)))
  {
    free((void *)file_data->filename);
    file_data->filename = (char *)(void *)0;
  }

  if(!(file_data->tempname == ((char *)NULL)))
  {
    free((void *)file_data->tempname);
    file_data->tempname = (char *)(void *)0;
  }

  if(!(file_data == ((struct open_file_t *)NULL)))
  {
    free((void *)file_data);
    file_data = (struct open_file_t *)(void *)0;
  }

  return r;
}

// flush_log_messages_from_startup
// file ../src/common/log.c line 1048
void flush_log_messages_from_startup(void)
{
  struct logfile_t *lf;
  tor_mutex_acquire(&log_mutex);
  queue_startup_messages = 0;
  pending_startup_messages_len = (unsigned long int)0;
  _Bool tmp_if_expr_2;
  if(!(pending_startup_messages == ((struct smartlist_t *)NULL)))
  {
    signed int msg_sl_idx;
    signed int msg_sl_len = pending_startup_messages->num_used;
    struct pending_log_message_t *msg;
    msg_sl_idx = 0;
    for( ; !(msg_sl_idx >= msg_sl_len); msg_sl_idx = msg_sl_idx + 1)
    {
      msg = (struct pending_log_message_t *)pending_startup_messages->list[(signed long int)msg_sl_idx];
      signed int callbacks_deferred = 0;
      lf = logfiles;
      for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
      {
        signed int return_value_logfile_wants_message_1;
        return_value_logfile_wants_message_1=logfile_wants_message(lf, msg->severity, msg->domain);
        if(!(return_value_logfile_wants_message_1 == 0))
        {
          if(lf->fd == 1)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = lf->fd == 2 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_2)
          {
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(msg->fullmsg);
            logfile_deliver(lf, msg->fullmsg, return_value_strlen_3, msg->msg, msg->domain, msg->severity, &callbacks_deferred);
          }

        }

      }
      pending_log_message_free(msg);
      msg = (struct pending_log_message_t *)(void *)0;
    }
    smartlist_free(pending_startup_messages);
    pending_startup_messages = (struct smartlist_t *)(void *)0;
  }


out:
  ;
  tor_mutex_release(&log_mutex);
}

// flush_pending_log_callbacks
// file ../src/common/log.c line 1006
void flush_pending_log_callbacks(void)
{
  struct logfile_t *lf;
  struct smartlist_t *messages;
  struct smartlist_t *messages_tmp;
  tor_mutex_acquire(&log_mutex);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(pending_cb_messages->num_used == 0)
    tor_mutex_release(&log_mutex);

  else
  {
    messages = pending_cb_messages;
    pending_cb_messages=smartlist_new();
    do
    {
      signed int msg_sl_idx;
      signed int msg_sl_len = messages->num_used;
      struct pending_log_message_t *msg;
      msg_sl_idx = 0;
      for( ; !(msg_sl_idx >= msg_sl_len); msg_sl_idx = msg_sl_idx + 1)
      {
        msg = (struct pending_log_message_t *)messages->list[(signed long int)msg_sl_idx];
        const signed int severity = msg->severity;
        const signed int domain = (const signed int)msg->domain;
        lf = logfiles;
        for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
        {
          if(lf->callback == ((void (*)(signed int, unsigned int, const char *))NULL))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = lf->seems_dead != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = !((lf->severities->masks[(signed long int)(severity - 3)] & (unsigned int)domain) != 0u) ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr_2)
            lf->callback(severity, (unsigned int)domain, msg->msg);

        }
        pending_log_message_free(msg);
        msg = (struct pending_log_message_t *)(void *)0;
      }
      smartlist_clear(messages);
      messages_tmp = pending_cb_messages;
      pending_cb_messages = messages;
      messages = messages_tmp;
    }
    while(!(messages->num_used == 0));
    smartlist_free(messages);
    tor_mutex_release(&log_mutex);
  }
}

// fmt_addr32
// file ../src/common/address.c line 1126
const char * fmt_addr32(unsigned int addr)
{
  struct in_addr in;
  in.s_addr=__bswap_32_link1(addr);
  static char buf[16l];
  tor_inet_ntoa(&in, buf, sizeof(char [16l]) /*16ul*/ );
  return buf;
}

// fmt_addr_impl
// file ../src/common/address.h line 190
const char * fmt_addr_impl(const struct tor_addr_t *addr, signed int decorate)
{
  if(addr == ((const struct tor_addr_t *)NULL))
    return "<null>";

  else
  {
    const char *return_value_tor_addr_to_str_1;
    static char buf[48l];
    return_value_tor_addr_to_str_1=tor_addr_to_str(buf, addr, sizeof(char [48l]) /*48ul*/ , decorate);
    if(!(return_value_tor_addr_to_str_1 == ((const char *)NULL)))
      return buf;

    else
      return "???";
  }
}

// fmt_addrport
// file ../src/common/address.c line 1114
const char * fmt_addrport(const struct tor_addr_t *addr, unsigned short int port)
{
  const char *return_value_fmt_addr_impl_1;
  return_value_fmt_addr_impl_1=fmt_addr_impl(addr, 1);
  static char buf[54l];
  tor_snprintf(buf, sizeof(char [54l]) /*54ul*/ , "%s:%u", return_value_fmt_addr_impl_1, port);
  return buf;
}

// format_dec_number_sigsafe
// file ../src/common/util.h line 549
signed int format_dec_number_sigsafe(unsigned long int x, char *buf, signed int buf_len)
{
  signed int return_value_format_number_sigsafe_1;
  return_value_format_number_sigsafe_1=format_number_sigsafe(x, buf, buf_len, (unsigned int)10);
  return return_value_format_number_sigsafe_1;
}

// format_helper_exit_status
// file ../src/common/util.c line 3793
static signed int format_helper_exit_status(unsigned char child_state, signed int saved_errno, char *hex_errno)
{
  unsigned int unsigned_errno;
  signed int written;
  signed int left;
  char *cur;
  unsigned long int i;
  signed int res = -1;
  i = (unsigned long int)0;
  for( ; !(i >= 12ul); i = i + 1ul)
    hex_errno[(signed long int)i] = (char)32;
  hex_errno[(signed long int)((sizeof(char) /*1ul*/  * (unsigned long int)2 + (unsigned long int)1 + (unsigned long int)1 + sizeof(signed int) /*4ul*/  * (unsigned long int)2 + (unsigned long int)1) - (unsigned long int)1)] = (char)10;
  if(!(saved_errno >= 0))
    unsigned_errno = (unsigned int)-(saved_errno + 1) + (unsigned int)1;

  else
    unsigned_errno = (unsigned int)saved_errno;
  left = (signed int)(sizeof(char) /*1ul*/  * (unsigned long int)2 + (unsigned long int)1 + (unsigned long int)1 + sizeof(signed int) /*4ul*/  * (unsigned long int)2 + (unsigned long int)1 + (unsigned long int)1);
  cur = hex_errno;
  written=format_hex_number_sigsafe((unsigned long int)child_state, cur, left);
  char *tmp_post_1;
  char *tmp_post_2;
  if(written >= 1)
  {
    left = left - written;
    cur = cur + (signed long int)written;
    if(!(left >= 1))
      goto err;

    *cur = (char)47;
    cur = cur + 1l;
    left = left - 1;
    if(!(left >= 1))
      goto err;

    if(!(saved_errno >= 0))
    {
      *cur = (char)45;
      cur = cur + 1l;
      left = left - 1;
      if(!(left >= 1))
        goto err;

    }

    written=format_hex_number_sigsafe((unsigned long int)unsigned_errno, cur, left);
    if(!(written >= 1))
      goto err;

    left = left - written;
    cur = cur + (signed long int)written;
    if(!(left >= 2))
      goto err;

    tmp_post_1 = cur;
    cur = cur + 1l;
    *tmp_post_1 = (char)10;
    tmp_post_2 = cur;
    cur = cur + 1l;
    *tmp_post_2 = (char)0;
    res = (signed int)((cur - hex_errno) - (signed long int)1);
  }

  else
  {

  err:
    ;
    *hex_errno = (char)0;
  }

done:
  ;
  return res;
}

// format_hex_number_sigsafe
// file ../src/common/util.c line 3764
signed int format_hex_number_sigsafe(unsigned long int x, char *buf, signed int buf_len)
{
  signed int return_value_format_number_sigsafe_1;
  return_value_format_number_sigsafe_1=format_number_sigsafe(x, buf, buf_len, (unsigned int)16);
  return return_value_format_number_sigsafe_1;
}

// format_iso_time
// file ../src/common/util.c line 1703
void format_iso_time(char *buf, signed long int t)
{
  struct tm tm;
  struct tm *return_value_tor_gmtime_r_1;
  return_value_tor_gmtime_r_1=tor_gmtime_r(&t, &tm);
  strftime(buf, (unsigned long int)(19 + 1), "%Y-%m-%d %H:%M:%S", return_value_tor_gmtime_r_1);
}

// format_iso_time_nospace
// file ../src/common/util.c line 1712
void format_iso_time_nospace(char *buf, signed long int t)
{
  format_iso_time(buf, t);
  buf[(signed long int)10] = (char)84;
}

// format_iso_time_nospace_usec
// file ../src/common/util.c line 1722
void format_iso_time_nospace_usec(char *buf, struct timeval *tv)
{
  if(tv == ((struct timeval *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1724, "format_iso_time_nospace_usec", "tv");
    abort();
  }

  format_iso_time_nospace(buf, (signed long int)tv->tv_sec);
  tor_snprintf(buf + (signed long int)19, (unsigned long int)8, ".%06d", (signed int)tv->tv_usec);
}

// format_local_iso_time
// file ../src/common/util.c line 1693
void format_local_iso_time(char *buf, signed long int t)
{
  struct tm tm;
  struct tm *return_value_tor_localtime_r_1;
  return_value_tor_localtime_r_1=tor_localtime_r(&t, &tm);
  strftime(buf, (unsigned long int)(19 + 1), "%Y-%m-%d %H:%M:%S", return_value_tor_localtime_r_1);
}

// format_msg
// file ../src/common/log.c line 272
static inline char * format_msg(char *buf, unsigned long int buf_len, unsigned int domain, signed int severity, const char *funcname, const char *suffix, const char *format, void **ap, unsigned long int *msg_len_out)
{
  unsigned long int n;
  signed int r;
  char *end_of_prefix;
  char *buf_end;
  /* assertion buf_len >= 16 */
  assert(buf_len >= (unsigned long int)16);
  buf_len = buf_len - (unsigned long int)2;
  buf_end = buf + (signed long int)buf_len;
  n=log_prefix_(buf, buf_len, severity);
  end_of_prefix = buf + (signed long int)n;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  if(!(log_domains_are_logged == 0))
  {
    char *cp = buf + (signed long int)n;
    if(!(cp == buf_end))
    {
      tmp_post_1 = cp;
      cp = cp + 1l;
      *tmp_post_1 = (char)123;
      if(!(cp == buf_end))
      {
        cp=domain_to_string(domain, cp, (unsigned long int)((buf + (signed long int)buf_len) - cp));
        if(!(cp == buf_end))
        {
          tmp_post_2 = cp;
          cp = cp + 1l;
          *tmp_post_2 = (char)125;
          if(!(cp == buf_end))
          {
            tmp_post_3 = cp;
            cp = cp + 1l;
            *tmp_post_3 = (char)32;
            if(!(cp == buf_end))
            {
              end_of_prefix = cp;
              n = (unsigned long int)(cp - buf);
            }

          }

        }

      }

    }

  }


format_msg_no_room_for_domains:
  ;
  signed int return_value_should_log_function_name_4;
  if(!(funcname == ((const char *)NULL)))
  {
    return_value_should_log_function_name_4=should_log_function_name(domain, severity);
    if(!(return_value_should_log_function_name_4 == 0))
    {
      r=tor_snprintf(buf + (signed long int)n, buf_len - n, "%s(): ", funcname);
      if(!(r >= 0))
        n=strlen(buf);

      else
        n = n + (unsigned long int)r;
    }

  }

  if(domain == 4096u && buf_len + -n >= 7ul)
  {
    memcpy_link5((void *)(buf + (signed long int)n), (const void *)"Bug: ", (unsigned long int)6);
    n = n + (unsigned long int)5;
  }

  r=tor_vsnprintf(buf + (signed long int)n, buf_len - n, format, ap);
  if(!(r >= 0))
  {
    if(buf_len >= 14ul)
    {
      unsigned long int offset = buf_len - (unsigned long int)14;
      strlcpy(buf + (signed long int)offset, "[...truncated]", (buf_len - offset) + (unsigned long int)1);
    }

    n = buf_len;
  }

  else
  {
    n = n + (unsigned long int)r;
    if(!(suffix == ((const char *)NULL)))
    {
      unsigned long int suffix_len;
      suffix_len=strlen(suffix);
      if(buf_len + -n >= suffix_len)
      {
        memcpy_link5((void *)(buf + (signed long int)n), (const void *)suffix, suffix_len);
        n = n + suffix_len;
      }

    }

  }
  buf[(signed long int)n] = (char)10;
  buf[(signed long int)(n + (unsigned long int)1)] = (char)0;
  *msg_len_out = n + (unsigned long int)1;
  return end_of_prefix;
}

// format_number_sigsafe
// file ../src/common/util.c line 3700
static signed int format_number_sigsafe(unsigned long int x, char *buf, signed int buf_len, unsigned int radix)
{
  unsigned long int tmp;
  signed int len;
  char *cp;
  if(radix >= 17u || !(radix >= 2u))
    return 0;

  else
  {
    tmp = x;
    len = 1;
    for( ; tmp >= (unsigned long int)radix; len = len + 1)
      tmp = tmp / (unsigned long int)radix;
    if(buf == ((char *)NULL) || len >= buf_len)
      return 0;

    else
    {
      cp = buf + (signed long int)len;
      *cp = (char)0;
      do
      {
        unsigned int digit = (unsigned int)(x % (unsigned long int)radix);
        if(buf >= cp)
        {
          tor_assertion_failed_("../src/common/util.c", (unsigned int)3728, "format_number_sigsafe", "cp > buf");
          abort();
        }

        cp = cp - 1l;
        *cp = "0123456789ABCDEF"[(signed long int)digit];
        x = x / (unsigned long int)radix;
      }
      while(!(x == 0ul));
      if(!(cp == buf))
        abort();

      return len;
    }
  }
}

// format_rfc1123_time
// file ../src/common/util.c line 1595
void format_rfc1123_time(char *buf, signed long int t)
{
  struct tm tm;
  tor_gmtime_r(&t, &tm);
  strftime(buf, (unsigned long int)(29 + 1), "___, %d ___ %Y %H:%M:%S GMT", &tm);
  if(!(tm.tm_wday >= 0))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1602, "format_rfc1123_time", "tm.tm_wday >= 0");
    abort();
  }

  if(tm.tm_wday >= 7)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1603, "format_rfc1123_time", "tm.tm_wday <= 6");
    abort();
  }

  memcpy_link7((void *)buf, (const void *)WEEKDAY_NAMES[(signed long int)tm.tm_wday], (unsigned long int)3);
  if(!(tm.tm_mon >= 0))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1605, "format_rfc1123_time", "tm.tm_mon >= 0");
    abort();
  }

  if(tm.tm_mon >= 12)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1606, "format_rfc1123_time", "tm.tm_mon <= 11");
    abort();
  }

  memcpy_link7((void *)(buf + (signed long int)8), (const void *)MONTH_NAMES[(signed long int)tm.tm_mon], (unsigned long int)3);
}

// format_time_interval
// file ../src/common/util.c line 1855
signed int format_time_interval(char *out, unsigned long int out_len, signed long int interval)
{
  signed long int sec = (signed long int)0;
  signed long int min = (signed long int)0;
  signed long int hour = (signed long int)0;
  signed long int day = (signed long int)0;
  if(!(interval >= -9223372036854775807l))
    interval = 0x7fffffffffffffffL;

  else
    if(!(interval >= 0l))
      interval = -interval;

  if(interval >= 86400l)
  {
    day = interval / (signed long int)86400;
    interval = interval % (signed long int)86400;
  }

  if(interval >= 3600l)
  {
    hour = interval / (signed long int)3600;
    interval = interval % (signed long int)3600;
  }

  if(interval >= 60l)
  {
    min = interval / (signed long int)60;
    interval = interval % (signed long int)60;
  }

  sec = interval;
  if(!(day == 0l))
  {
    signed int return_value_tor_snprintf_1;
    return_value_tor_snprintf_1=tor_snprintf(out, out_len, "%ld days, %ld hours, %ld minutes", day, hour, min);
    return return_value_tor_snprintf_1;
  }

  else
    if(!(hour == 0l))
    {
      signed int return_value_tor_snprintf_2;
      return_value_tor_snprintf_2=tor_snprintf(out, out_len, "%ld hours, %ld minutes", hour, min);
      return return_value_tor_snprintf_2;
    }

    else
      if(!(min == 0l))
      {
        signed int return_value_tor_snprintf_3;
        return_value_tor_snprintf_3=tor_snprintf(out, out_len, "%ld minutes, %ld seconds", min, sec);
        return return_value_tor_snprintf_3;
      }

      else
      {
        signed int return_value_tor_snprintf_4;
        return_value_tor_snprintf_4=tor_snprintf(out, out_len, "%ld seconds", sec);
        return return_value_tor_snprintf_4;
      }
}

// format_win_cmdline_argument
// file ../src/common/util.c line 3600
static char * format_win_cmdline_argument(const char *arg)
{
  char *formatted_arg;
  char need_quotes;
  const char *format_win_cmdline_argument__1__c;
  signed int i;
  signed int bs_counter = 0;
  const char backslash = (const char)92;
  struct smartlist_t *arg_chars;
  arg_chars=smartlist_new();
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(arg, 32);
  _Bool tmp_if_expr_3;
  char *return_value___builtin_strchr_2;
  if(!(return_value___builtin_strchr_1 == ((char *)NULL)))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value___builtin_strchr_2=__builtin_strchr(arg, 9);
    tmp_if_expr_3 = return_value___builtin_strchr_2 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = 0 == (signed int)arg[(signed long int)0] ? (_Bool)1 : (_Bool)0;
  need_quotes = (char)tmp_if_expr_4;
  format_win_cmdline_argument__1__c = arg;
  for( ; !((signed int)*format_win_cmdline_argument__1__c == 0); format_win_cmdline_argument__1__c = format_win_cmdline_argument__1__c + 1l)
    if((signed int)*format_win_cmdline_argument__1__c == 34)
    {
      i = 0;
      for( ; !(i >= 2 * bs_counter); i = i + 1)
        smartlist_add(arg_chars, (void *)&backslash);
      bs_counter = 0;
      smartlist_add(arg_chars, (void *)&backslash);
      smartlist_add(arg_chars, (void *)format_win_cmdline_argument__1__c);
    }

    else
      if((signed int)*format_win_cmdline_argument__1__c == 92)
        bs_counter = bs_counter + 1;

      else
      {
        i = 0;
        for( ; !(i >= bs_counter); i = i + 1)
          smartlist_add(arg_chars, (void *)&backslash);
        bs_counter = 0;
        smartlist_add(arg_chars, (void *)format_win_cmdline_argument__1__c);
      }
  i = 0;
  for( ; !(i >= bs_counter); i = i + 1)
    smartlist_add(arg_chars, (void *)&backslash);
  const unsigned long int formatted_arg_len = (const unsigned long int)(arg_chars->num_used + (need_quotes != 0 ? 2 : 0) + 1);
  void *return_value_tor_malloc_zero__5;
  return_value_tor_malloc_zero__5=tor_malloc_zero_(formatted_arg_len);
  formatted_arg = (char *)return_value_tor_malloc_zero__5;
  i = 0;
  signed int tmp_post_6;
  if(!(need_quotes == 0))
  {
    tmp_post_6 = i;
    i = i + 1;
    formatted_arg[(signed long int)tmp_post_6] = (char)34;
  }

  signed int c_sl_idx;
  signed int c_sl_len = arg_chars->num_used;
  char *c;
  c_sl_idx = 0;
  signed int tmp_post_7;
  for( ; !(c_sl_idx >= c_sl_len); c_sl_idx = c_sl_idx + 1)
  {
    c = (char *)arg_chars->list[(signed long int)c_sl_idx];
    tmp_post_7 = i;
    i = i + 1;
    formatted_arg[(signed long int)tmp_post_7] = *c;
    c = (char *)(void *)0;
  }
  signed int tmp_post_8;
  if(!(need_quotes == 0))
  {
    tmp_post_8 = i;
    i = i + 1;
    formatted_arg[(signed long int)tmp_post_8] = (char)34;
  }

  formatted_arg[(signed long int)i] = (char)0;
  smartlist_free(arg_chars);
  return formatted_arg;
}

// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2;
  return_value___fprintf_chk_2=__fprintf_chk(__stream, 2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___fprintf_chk_2;
}

// fprintf_link1
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf_link1(struct _IO_FILE * restrict __stream_link1, const char * restrict __fmt_link1, ...)
{
  void *return_value___builtin_va_arg_pack_1_link1;
  return_value___builtin_va_arg_pack_1_link1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk_2_link1;
  return_value___fprintf_chk_2_link1=__fprintf_chk(__stream_link1, 2 - 1, __fmt_link1, return_value___builtin_va_arg_pack_1_link1);
  return return_value___fprintf_chk_2_link1;
}

// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat_1;
  return_value___fxstat_1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat_1;
}

// fstat_link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 467
static inline signed int fstat_link1(signed int __fd_link1, struct stat *__statbuf_link1)
{
  signed int return_value___fxstat_1_link1;
  return_value___fxstat_1_link1=__fxstat(1, __fd_link1, __statbuf_link1);
  return return_value___fxstat_1_link1;
}

// get_current_process_environment_variables
// file ../src/common/util.c line 4596
struct smartlist_t * get_current_process_environment_variables(void)
{
  struct smartlist_t *sl;
  sl=smartlist_new();
  char **environ_tmp;
  environ_tmp=get_environment();
  for( ; !(*environ_tmp == ((char *)NULL)); environ_tmp = environ_tmp + 1l)
  {
    char *return_value_tor_strdup__1;
    return_value_tor_strdup__1=tor_strdup_(*environ_tmp);
    smartlist_add(sl, (void *)return_value_tor_strdup__1);
  }
  return sl;
}

// get_environment
// file ../src/common/compat.c line 2188
char ** get_environment(void)
{
  return environ;
}

// get_interface_address
// file ../src/common/address.c line 1841
signed int get_interface_address(signed int severity, unsigned int *addr)
{
  struct tor_addr_t local_addr;
  signed int r;
  r=get_interface_address6(severity, (unsigned short int)2, &local_addr);
  if(r >= 0)
    *addr=tor_addr_to_ipv4h(&local_addr);

  return r;
}

// get_interface_address6
// file ../src/common/address.c line 1511
signed int get_interface_address6(signed int severity, unsigned short int family, struct tor_addr_t *addr)
{
  struct smartlist_t *addrs;
  signed int sock = -1;
  signed int r = -1;
  struct sockaddr_storage my_addr;
  struct sockaddr_storage target_addr;
  unsigned int addr_len;
  if(addr == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1519, "get_interface_address6", "addr");
    abort();
  }

  addrs=get_interface_addresses_raw(severity);
  unsigned short int return_value_tor_addr_family_1;
  _Bool tmp_if_expr_4;
  signed int return_value_tor_addr_is_multicast_3;
  if(!(addrs == ((struct smartlist_t *)NULL)))
  {
    signed int rv = -1;
    signed int a_sl_idx;
    signed int a_sl_len = addrs->num_used;
    struct tor_addr_t *a;
    a_sl_idx = 0;
    for( ; !(a_sl_idx >= a_sl_len); a_sl_idx = a_sl_idx + 1)
    {
      a = (struct tor_addr_t *)addrs->list[(signed long int)a_sl_idx];
      if(!((signed int)family == 0))
      {
        return_value_tor_addr_family_1=tor_addr_family_link1(a);
        if(!(family == return_value_tor_addr_family_1))
          goto __CPROVER_DUMP_L8;

      }

      signed int return_value_tor_addr_is_loopback_2;
      return_value_tor_addr_is_loopback_2=tor_addr_is_loopback(a);
      if(!(return_value_tor_addr_is_loopback_2 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_tor_addr_is_multicast_3=tor_addr_is_multicast(a);
        tmp_if_expr_4 = return_value_tor_addr_is_multicast_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_4)
      {
        tor_addr_copy(addr, a);
        rv = 0;
        signed int return_value_tor_addr_is_internal__5;
        return_value_tor_addr_is_internal__5=tor_addr_is_internal_(a, 0, "../src/common/address.c", 1536);
        if(return_value_tor_addr_is_internal__5 == 0)
          break;

        a = (struct tor_addr_t *)(void *)0;
      }


    __CPROVER_DUMP_L8:
      ;
    }
    signed int get_interface_address6__1__2__2__a_sl_idx;
    signed int get_interface_address6__1__2__2__a_sl_len = addrs->num_used;
    struct tor_addr_t *get_interface_address6__1__2__2__a;
    get_interface_address6__1__2__2__a_sl_idx = 0;
    for( ; !(get_interface_address6__1__2__2__a_sl_idx >= get_interface_address6__1__2__2__a_sl_len); get_interface_address6__1__2__2__a_sl_idx = get_interface_address6__1__2__2__a_sl_idx + 1)
    {
      get_interface_address6__1__2__2__a = (struct tor_addr_t *)addrs->list[(signed long int)get_interface_address6__1__2__2__a_sl_idx];
      if(!(get_interface_address6__1__2__2__a == ((struct tor_addr_t *)NULL)))
      {
        free((void *)get_interface_address6__1__2__2__a);
        get_interface_address6__1__2__2__a = (struct tor_addr_t *)(void *)0;
      }

      get_interface_address6__1__2__2__a = (struct tor_addr_t *)(void *)0;
    }
    smartlist_free(addrs);
    return rv;
  }

  memset_link1((void *)addr, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  memset_link1((void *)&target_addr, 0, sizeof(struct sockaddr_storage) /*128ul*/ );
  unsigned short int tmp_statement_expression_6;
  unsigned short int tmp_statement_expression_7;
  unsigned short int tmp_statement_expression_8;
  if((signed int)family == 10)
  {
    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&target_addr;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)9;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_6 = __v;
    sin6->sin6_port = tmp_statement_expression_6;
    sock=tor_open_socket(10, 2, 17);
    addr_len = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    sin6->sin6_family = (unsigned short int)10;
    unsigned short int get_interface_address6__1__3__2____v;
    unsigned short int get_interface_address6__1__3__2____x = (unsigned short int)0x2002;
    asm("rorw _8, %w0" : "=r"(get_interface_address6__1__3__2____v) : "0"(get_interface_address6__1__3__2____x) : "cc");
    tmp_statement_expression_7 = get_interface_address6__1__3__2____v;
    ((unsigned short int *)sin6->sin6_addr.__in6_u.__u6_addr16)[(signed long int)0] = tmp_statement_expression_7;
  }

  else
    if((signed int)family == 2)
    {
      struct sockaddr_in *sin = (struct sockaddr_in *)&target_addr;
      unsigned short int get_interface_address6__1__4__1____v;
      unsigned short int get_interface_address6__1__4__1____x = (unsigned short int)9;
      asm("rorw _8, %w0" : "=r"(get_interface_address6__1__4__1____v) : "0"(get_interface_address6__1__4__1____x) : "cc");
      tmp_statement_expression_8 = get_interface_address6__1__4__1____v;
      sin->sin_port = tmp_statement_expression_8;
      sock=tor_open_socket(2, 2, 17);
      addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      sin->sin_family = (unsigned short int)2;
      sin->sin_addr.s_addr=__bswap_32_link1((unsigned int)0x12000001);
    }

    else
      return -1;
  if(!(sock >= 0))
  {
    signed int e;
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    e = *return_value___errno_location_9;
    char *return_value_strerror_10;
    return_value_strerror_10=strerror(e);
    log_fn_(severity, 1u << 2, "get_interface_address6", "unable to create socket: %s", return_value_strerror_10);
    goto err;
  }

  signed int return_value_connect_13;
  return_value_connect_13=connect(sock, (struct sockaddr *)&target_addr, addr_len);
  if(!(return_value_connect_13 >= 0))
  {
    signed int get_interface_address6__1__7__e;
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    get_interface_address6__1__7__e = *return_value___errno_location_11;
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(get_interface_address6__1__7__e);
    log_fn_(severity, 1u << 2, "get_interface_address6", "connect() failed: %s", return_value_strerror_12);
    goto err;
  }

  signed int return_value_getsockname_16;
  return_value_getsockname_16=getsockname(sock, (struct sockaddr *)&my_addr, &addr_len);
  if(!(return_value_getsockname_16 == 0))
  {
    signed int get_interface_address6__1__8__e;
    signed int *return_value___errno_location_14;
    return_value___errno_location_14=__errno_location();
    get_interface_address6__1__8__e = *return_value___errno_location_14;
    char *return_value_strerror_15;
    return_value_strerror_15=strerror(get_interface_address6__1__8__e);
    log_fn_(severity, 1u << 2, "get_interface_address6", "getsockname() to determine interface failed: %s", return_value_strerror_15);
    goto err;
  }

  tor_addr_from_sockaddr(addr, (struct sockaddr *)&my_addr, (unsigned short int *)(void *)0);
  r = 0;

err:
  ;
  if(sock >= 0)
    tor_close_socket(sock);

  return r;
}

// get_interface_addresses_ifaddrs
// file ../src/common/address.c line 1263
static struct smartlist_t * get_interface_addresses_ifaddrs(signed int severity)
{
  struct ifaddrs *ifa = (struct ifaddrs *)(void *)0;
  struct smartlist_t *result;
  signed int return_value_getifaddrs_3;
  return_value_getifaddrs_3=getifaddrs(&ifa);
  if(!(return_value_getifaddrs_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(severity, 1u << 2, "get_interface_addresses_ifaddrs", "Unable to call getifaddrs(): %s", return_value_strerror_2);
    return (struct smartlist_t *)(void *)0;
  }

  result=ifaddrs_to_smartlist(ifa);
  freeifaddrs(ifa);
  return result;
}

// get_interface_addresses_ioctl
// file ../src/common/address.c line 1426
static struct smartlist_t * get_interface_addresses_ioctl(signed int severity)
{
  struct ifconf ifc;
  signed int fd;
  struct smartlist_t *result = (struct smartlist_t *)(void *)0;
  fd=socket(2, 2, 0);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    tor_log(severity, 1u << 2, "socket failed: %s", return_value_strerror_2);
    goto done;
  }

  signed int mult = 1;
  ifc.ifc_ifcu.ifcu_buf = (char *)(void *)0;
  do
  {
    mult = mult * 2;
    ifc.ifc_len = mult * 4096;
    void *return_value_tor_realloc__3;
    return_value_tor_realloc__3=tor_realloc_((void *)ifc.ifc_ifcu.ifcu_buf, (unsigned long int)ifc.ifc_len);
    ifc.ifc_ifcu.ifcu_buf = (char *)return_value_tor_realloc__3;
    if(ifc.ifc_ifcu.ifcu_buf == ((char *)NULL))
    {
      tor_assertion_failed_("../src/common/address.c", (unsigned int)1447, "get_interface_addresses_ioctl", "ifc.ifc_buf");
      abort();
    }

    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(fd, (unsigned long int)0x8912, &ifc);
    if(!(return_value_ioctl_6 >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      tor_log(severity, 1u << 2, "ioctl failed: %s", return_value_strerror_5);
      goto done;
    }

  }
  while(!(4096 * mult + -ifc.ifc_len >= 4097));
  result=ifreq_to_smartlist(ifc.ifc_ifcu.ifcu_buf, (unsigned long int)ifc.ifc_len);

done:
  ;
  if(fd >= 0)
    close(fd);

  if(!(ifc.ifc_ifcu.ifcu_buf == ((char *)NULL)))
  {
    free((void *)ifc.ifc_ifcu.ifcu_buf);
    ifc.ifc_ifcu.ifcu_buf = (char *)(void *)0;
  }

  return result;
}

// get_interface_addresses_raw
// file ../src/common/address.c line 1471
static struct smartlist_t * get_interface_addresses_raw(signed int severity)
{
  struct smartlist_t *result = (struct smartlist_t *)(void *)0;
  result=get_interface_addresses_ifaddrs(severity);
  if(!(result == ((struct smartlist_t *)NULL)))
    return result;

  else
  {
    result=get_interface_addresses_ioctl(severity);
    if(!(result == ((struct smartlist_t *)NULL)))
      return result;

    else
    {
      (void)severity;
      return (struct smartlist_t *)(void *)0;
    }
  }
}

// get_min_log_level
// file ../src/common/log.c line 1401
signed int get_min_log_level(void)
{
  struct logfile_t *lf;
  signed int i;
  signed int min = 3;
  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
  {
    i = 7;
    for( ; !(min >= i); i = i - 1)
      if(!(lf->severities->masks[(signed long int)(i + -3)] == 0u))
        min = i;

  }
  return min;
}

// get_n_open_sockets
// file ../src/common/compat.c line 1302
signed int get_n_open_sockets(void)
{
  signed int n;
  socket_accounting_lock();
  n = n_sockets_open;
  socket_accounting_unlock();
  return n;
}

// get_parent_directory
// file ../src/common/compat.c line 2063
signed int get_parent_directory(char *fname)
{
  char *cp;
  signed int at_end = 1;
  if(fname == ((char *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)2067, "get_parent_directory", "fname");
    abort();
  }

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(fname);
  cp = fname + (signed long int)return_value_strlen_1;
  at_end = 1;
  do
  {
    cp = cp - 1l;
    if(!(cp >= fname))
      break;

    signed int is_sep = (signed int)((signed int)*cp == 47);
    if(!(is_sep == 0))
    {
      if(cp == fname)
      {
        cp[(signed long int)1] = (char)0;
        return 0;
      }

      *cp = (char)0;
      if(at_end == 0)
        return 0;

    }

    else
      at_end = 0;
  }
  while((_Bool)1);
  return -1;
}

// get_string_from_pipe
// file ../src/common/util.c line 5047
enum stream_status get_string_from_pipe(struct _IO_FILE *stream, char *buf_out, unsigned long int count)
{
  char *retval;
  unsigned long int len;
  if(count >= 2147483648ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)5052, "get_string_from_pipe", "count <= INT_MAX");
    abort();
  }

  retval=fgets(buf_out, (signed int)count, stream);
  if(retval == ((char *)NULL))
  {
    signed int return_value_feof_2;
    return_value_feof_2=feof(stream);
    if(!(return_value_feof_2 == 0))
      return (enum stream_status)IO_STREAM_CLOSED;

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        return (enum stream_status)IO_STREAM_EAGAIN;

      else
        return (enum stream_status)IO_STREAM_TERM;
    }
  }

  else
  {
    len=strlen(buf_out);
    if(len == 0ul)
      return (enum stream_status)IO_STREAM_EAGAIN;

    if((signed int)buf_out[-1l + (signed long int)len] == 10)
      buf_out[(signed long int)(len - (unsigned long int)1)] = (char)0;

    else
    {
      signed int return_value_feof_3;
      return_value_feof_3=feof(stream);
      if(return_value_feof_3 == 0)
        log_fn_(6, 1u << 0, "get_string_from_pipe", "Line from stream was truncated: %s", buf_out);

    }
    return (enum stream_status)IO_STREAM_OKAY;
  }
  return (enum stream_status)IO_STREAM_TERM;
}

// get_syscall_name
// file ../src/common/sandbox.c line 1568
static const char * get_syscall_name(signed int syscall_num)
{
  signed int i = 0;
  for( ; !(SYSCALLS_BY_NUMBER[(signed long int)i].syscall_name == ((const char *)NULL)); i = i + 1)
    if(SYSCALLS_BY_NUMBER[(signed long int)i].syscall_num == syscall_num)
      return SYSCALLS_BY_NUMBER[(signed long int)i].syscall_name;

  static char syscall_name_buf[64l];
  format_dec_number_sigsafe((unsigned long int)syscall_num, syscall_name_buf, (signed int)sizeof(char [64l]) /*64ul*/ );
  return syscall_name_buf;
}

// get_total_system_memory
// file ../src/common/compat.c line 3179
signed int get_total_system_memory(unsigned long int *mem_out)
{
  unsigned long int m;
  m=get_total_system_memory_impl();
  static unsigned long int mem_cached = (unsigned long int)0;
  if(m == 0ul)
  {
    if(mem_cached == 0ul)
    {
      *mem_out = (unsigned long int)0;
      return -1;
    }

    *mem_out = mem_cached;
    return 0;
  }

  else
  {
    mem_cached = (unsigned long int)m;
    *mem_out = mem_cached;
    return 0;
  }
}

// get_total_system_memory_impl
// file ../src/common/compat.c line 3106
static unsigned long int get_total_system_memory_impl(void)
{
  unsigned long long int result = (unsigned long long int)0;
  signed int fd = -1;
  char *s = (char *)(void *)0;
  const char *cp;
  unsigned long int file_size = (unsigned long int)0;
  fd=tor_open_cloexec("/proc/meminfo", 00, (unsigned int)0);
  signed int return_value_sscanf_1;
  if(fd == -1)
    return (unsigned long int)0;

  else
  {
    s=read_file_to_str_until_eof(fd, (unsigned long int)65536, &file_size);
    if(!(s == ((char *)NULL)))
    {
      cp=strstr(s, "MemTotal:");
      if(cp == ((const char *)NULL))
        goto err;

      return_value_sscanf_1=sscanf(cp, "MemTotal: %llu kB\n", &result);
      if(!(return_value_sscanf_1 == 1))
        goto err;

      close(fd);
      if(!(s == ((char *)NULL)))
      {
        free((void *)s);
        s = (char *)(void *)0;
      }

      return result * (unsigned long int)1024;
    }

    else
    {

    err:
      ;
      if(!(s == ((char *)NULL)))
      {
        free((void *)s);
        s = (char *)(void *)0;
      }

      close(fd);
      return (unsigned long int)0;
    }
  }
}

// get_uint16
// file ../src/common/compat.h line 616
unsigned short int get_uint16(const void *cp)
{
  unsigned short int v;
  memcpy_link2((void *)&v, cp, (unsigned long int)2);
  return v;
}

// get_uint32
// file ../src/common/compat.h line 617
unsigned int get_uint32(const void *cp)
{
  unsigned int v;
  memcpy_link2((void *)&v, cp, (unsigned long int)4);
  return v;
}

// get_uint64
// file ../src/common/compat.c line 773
unsigned long int get_uint64(const void *cp)
{
  unsigned long int v;
  memcpy_link2((void *)&v, cp, (unsigned long int)8);
  return v;
}

// get_uname
// file ../src/common/compat.c line 2459
const char * get_uname(void)
{
  struct utsname u;
  if(uname_result_is_set == 0)
  {
    signed int return_value_uname_1;
    return_value_uname_1=uname(&u);
    if(!(return_value_uname_1 == -1))
      strlcpy(uname_result, u.sysname, sizeof(char [256l]) /*256ul*/ );

    else
      strlcpy(uname_result, "Unknown platform", sizeof(char [256l]) /*256ul*/ );
    uname_result_is_set = 1;
  }

  return uname_result;
}

// get_user_homedir
// file ../src/common/compat.c line 2035
char * get_user_homedir(const char *username)
{
  struct passwd *pw;
  if(username == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)2038, "get_user_homedir", "username");
    abort();
  }

  pw=tor_getpwnam(username);
  if(pw == ((struct passwd *)NULL))
  {
    log_fn_(3, 1u << 3, "get_user_homedir", "User \"%s\" not found.", username);
    return (char *)(void *)0;
  }

  else
  {
    char *return_value_tor_strdup__1;
    return_value_tor_strdup__1=tor_strdup_(pw->pw_dir);
    return return_value_tor_strdup__1;
  }
}

// getaddrinfo_cache_HT_CLEAR
// file ../src/common/sandbox.c line 1347
void getaddrinfo_cache_HT_CLEAR(struct getaddrinfo_cache *head)
{
  if(!(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL)))
    tor_free_((void *)head->hth_table);

  head->hth_table_length = (unsigned int)0;
  getaddrinfo_cache_HT_INIT(head);
}

// getaddrinfo_cache_HT_FIND
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t * getaddrinfo_cache_HT_FIND(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm)
{
  struct cached_getaddrinfo_item_t **p;
  struct getaddrinfo_cache *h = (struct getaddrinfo_cache *)head;
  do
    elm->node.hte_hash=cached_getaddrinfo_item_hash(elm);
  while((_Bool)0);
  p=getaddrinfo_cache_HT_FIND_P_(h, elm);
  struct cached_getaddrinfo_item_t *tmp_if_expr_1;
  if(!(p == ((struct cached_getaddrinfo_item_t **)NULL)))
    tmp_if_expr_1 = *p;

  else
    tmp_if_expr_1 = (struct cached_getaddrinfo_item_t *)(void *)0;
  return tmp_if_expr_1;
}

// getaddrinfo_cache_HT_FIND_P_
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_FIND_P_(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm)
{
  struct cached_getaddrinfo_item_t **p;
  if(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL))
    return (struct cached_getaddrinfo_item_t **)(void *)0;

  else
  {
    p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
    while(!(*p == ((struct cached_getaddrinfo_item_t *)NULL)))
    {
      unsigned int return_value_cached_getaddrinfo_items_eq_1;
      return_value_cached_getaddrinfo_items_eq_1=cached_getaddrinfo_items_eq(*p, elm);
      if(!(return_value_cached_getaddrinfo_items_eq_1 == 0u))
        return p;

      p = &(*p)->node.hte_next;
    }
    return p;
  }
}

// getaddrinfo_cache_HT_GROW
// file ../src/common/sandbox.c line 1347
signed int getaddrinfo_cache_HT_GROW(struct getaddrinfo_cache *head, unsigned int size)
{
  unsigned int new_len;
  unsigned int new_load_limit;
  signed int prime_idx;
  struct cached_getaddrinfo_item_t **new_table;
  if(head->hth_prime_idx == (signed int)getaddrinfo_cache_N_PRIMES + -1)
    return 0;

  else
    if(!(size >= head->hth_load_limit))
      return 0;

    else
    {
      prime_idx = head->hth_prime_idx;
      do
      {
        prime_idx = prime_idx + 1;
        new_len = getaddrinfo_cache_PRIMES[(signed long int)prime_idx];
        new_load_limit = (unsigned int)(0.6 * (double)new_len);
      }
      while(size >= new_load_limit && !(prime_idx >= (signed int)getaddrinfo_cache_N_PRIMES));
      void *return_value_tor_reallocarray__2;
      return_value_tor_reallocarray__2=tor_reallocarray_((void *)0, (unsigned long int)new_len, sizeof(struct cached_getaddrinfo_item_t *) /*8ul*/ );
      new_table = (struct cached_getaddrinfo_item_t **)return_value_tor_reallocarray__2;
      if(!(new_table == ((struct cached_getaddrinfo_item_t **)NULL)))
      {
        unsigned int b;
        memset_link9((void *)new_table, 0, (unsigned long int)new_len * sizeof(struct cached_getaddrinfo_item_t *) /*8ul*/ );
        b = (unsigned int)0;
        for( ; !(b >= head->hth_table_length); b = b + 1u)
        {
          struct cached_getaddrinfo_item_t *elm;
          struct cached_getaddrinfo_item_t *next;
          unsigned int getaddrinfo_cache_HT_GROW__1__2__1__b2;
          elm = head->hth_table[(signed long int)b];
          for( ; !(elm == ((struct cached_getaddrinfo_item_t *)NULL)); elm = next)
          {
            next = elm->node.hte_next;
            getaddrinfo_cache_HT_GROW__1__2__1__b2 = elm->node.hte_hash % new_len;
            elm->node.hte_next = new_table[(signed long int)getaddrinfo_cache_HT_GROW__1__2__1__b2];
            new_table[(signed long int)getaddrinfo_cache_HT_GROW__1__2__1__b2] = elm;
          }
        }
        if(!(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL)))
          tor_free_((void *)head->hth_table);

        head->hth_table = new_table;
      }

      else
      {
        unsigned int getaddrinfo_cache_HT_GROW__1__3__b;
        unsigned int b2;
        void *return_value_tor_reallocarray__1;
        return_value_tor_reallocarray__1=tor_reallocarray_((void *)head->hth_table, (unsigned long int)new_len, sizeof(struct cached_getaddrinfo_item_t *) /*8ul*/ );
        new_table = (struct cached_getaddrinfo_item_t **)return_value_tor_reallocarray__1;
        if(new_table == ((struct cached_getaddrinfo_item_t **)NULL))
          return -1;

        memset_link9((void *)(new_table + (signed long int)head->hth_table_length), 0, (unsigned long int)(new_len - head->hth_table_length) * sizeof(struct cached_getaddrinfo_item_t *) /*8ul*/ );
        getaddrinfo_cache_HT_GROW__1__3__b = (unsigned int)0;
        for( ; !(getaddrinfo_cache_HT_GROW__1__3__b >= head->hth_table_length); getaddrinfo_cache_HT_GROW__1__3__b = getaddrinfo_cache_HT_GROW__1__3__b + 1u)
        {
          struct cached_getaddrinfo_item_t *e;
          struct cached_getaddrinfo_item_t **pE = &new_table[(signed long int)getaddrinfo_cache_HT_GROW__1__3__b];
          e = *pE;
          for( ; !(e == ((struct cached_getaddrinfo_item_t *)NULL)); e = *pE)
          {
            b2 = e->node.hte_hash % new_len;
            if(b2 == getaddrinfo_cache_HT_GROW__1__3__b)
              pE = &e->node.hte_next;

            else
            {
              *pE = e->node.hte_next;
              e->node.hte_next = new_table[(signed long int)b2];
              new_table[(signed long int)b2] = e;
            }
          }
        }
        head->hth_table = new_table;
      }
      head->hth_table_length = new_len;
      head->hth_prime_idx = prime_idx;
      head->hth_load_limit = new_load_limit;
      return 0;
    }
}

// getaddrinfo_cache_HT_INIT
// file ../src/common/sandbox.c line 1344
static inline void getaddrinfo_cache_HT_INIT(struct getaddrinfo_cache *head)
{
  head->hth_table_length = (unsigned int)0;
  head->hth_table = (struct cached_getaddrinfo_item_t **)(void *)0;
  head->hth_n_entries = (unsigned int)0;
  head->hth_load_limit = (unsigned int)0;
  head->hth_prime_idx = -1;
}

// getaddrinfo_cache_HT_INSERT
// file ../src/common/sandbox.c line 1344
static inline void getaddrinfo_cache_HT_INSERT(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t *elm)
{
  struct cached_getaddrinfo_item_t **p;
  _Bool tmp_if_expr_1;
  if(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = head->hth_n_entries >= head->hth_load_limit ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    getaddrinfo_cache_HT_GROW(head, head->hth_n_entries + (unsigned int)1);

  head->hth_n_entries = head->hth_n_entries + 1u;
  do
    elm->node.hte_hash=cached_getaddrinfo_item_hash(elm);
  while((_Bool)0);
  p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
  elm->node.hte_next = *p;
  *p = elm;
}

// getaddrinfo_cache_HT_NEXT_RMV
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_NEXT_RMV(struct getaddrinfo_cache *head, struct cached_getaddrinfo_item_t **elm)
{
  unsigned int h = (*elm)->node.hte_hash;
  *elm = (*elm)->node.hte_next;
  head->hth_n_entries = head->hth_n_entries - 1u;
  if(!(*elm == ((struct cached_getaddrinfo_item_t *)NULL)))
    return elm;

  else
  {
    unsigned int b = h % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct cached_getaddrinfo_item_t *)NULL)))
        return &head->hth_table[(signed long int)b];

    return (struct cached_getaddrinfo_item_t **)(void *)0;
  }
}

// getaddrinfo_cache_HT_REP_IS_BAD_
// file ../src/common/sandbox.c line 1347
signed int getaddrinfo_cache_HT_REP_IS_BAD_(struct getaddrinfo_cache *head)
{
  unsigned int n;
  unsigned int i;
  struct cached_getaddrinfo_item_t *elm;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(head->hth_table_length == 0u)
  {
    if(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL))
      tmp_if_expr_1 = !(head->hth_n_entries != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = head->hth_prime_idx == -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return 0;

    return 1;
  }

  else
  {
    if(head->hth_table == ((struct cached_getaddrinfo_item_t **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = head->hth_prime_idx < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 2;

    else
      if(!(head->hth_load_limit >= head->hth_n_entries))
        return 3;

      else
        if(!(head->hth_table_length == getaddrinfo_cache_PRIMES[(signed long int)head->hth_prime_idx]))
          return 4;

        else
          if(!(head->hth_load_limit == (unsigned int)(0.6 * (double)head->hth_table_length)))
            return 5;

          else
          {
            i = (unsigned int)0;
            n = i;
            for( ; !(i >= head->hth_table_length); i = i + 1u)
            {
              elm = head->hth_table[(signed long int)i];
              for( ; !(elm == ((struct cached_getaddrinfo_item_t *)NULL)); elm = elm->node.hte_next)
              {
                unsigned int return_value_cached_getaddrinfo_item_hash_6;
                return_value_cached_getaddrinfo_item_hash_6=cached_getaddrinfo_item_hash(elm);
                if(!(elm->node.hte_hash == return_value_cached_getaddrinfo_item_hash_6))
                  return (signed int)((unsigned int)1000 + i);

                if(!(elm->node.hte_hash % head->hth_table_length == i))
                  return (signed int)((unsigned int)10000 + i);

                n = n + 1u;
              }
            }
            if(!(n == head->hth_n_entries))
              return 6;

            else
              return 0;
          }
  }
}

// getaddrinfo_cache_HT_START
// file ../src/common/sandbox.c line 1344
static inline struct cached_getaddrinfo_item_t ** getaddrinfo_cache_HT_START(struct getaddrinfo_cache *head)
{
  unsigned int b = (unsigned int)0;
  for( ; !(b >= head->hth_table_length); b = b + 1u)
    if(!(head->hth_table[(signed long int)b] == ((struct cached_getaddrinfo_item_t *)NULL)))
    {
      if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
      {
        tor_assertion_failed_("../src/common/sandbox.c", (unsigned int)1346, "getaddrinfo_cache_HT_START", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
        abort();
      }

      return &head->hth_table[(signed long int)b];
    }

  return (struct cached_getaddrinfo_item_t **)(void *)0;
}

// getcwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 200
static inline char * getcwd(char *__buf, unsigned long int __size)
{
  char *return_value___getcwd_chk_1;
  char *return_value___getcwd_chk_warn_2;
  char *return_value___getcwd_alias_3;
  return_value___getcwd_alias_3=__getcwd_alias(__buf, __size);
  return return_value___getcwd_alias_3;
}

// getgroups
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 265
static inline signed int getgroups(signed int __size, unsigned int *__list)
{
  signed int return_value___getgroups_chk_1;
  signed int return_value___getgroups_chk_warn_2;
  signed int return_value___getgroups_alias_3;
  return_value___getgroups_alias_3=__getgroups_alias(__size, __list);
  return return_value___getgroups_alias_3;
}

// gethostname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 344
static inline signed int gethostname(char *__buf, unsigned long int __buflen)
{
  signed int return_value___gethostname_chk_1;
  signed int return_value___gethostname_chk_warn_2;
  signed int return_value___gethostname_alias_3;
  return_value___gethostname_alias_3=__gethostname_alias(__buf, __buflen);
  return return_value___gethostname_alias_3;
}

// handle_fw_helper_line
// file ../src/common/util.c line 5098
static void handle_fw_helper_line(const char *executable, const char *line)
{
  struct smartlist_t *tokens;
  tokens=smartlist_new();
  char *message = (char *)(void *)0;
  char *message_for_log = (char *)(void *)0;
  const char *external_port = (const char *)(void *)0;
  const char *internal_port = (const char *)(void *)0;
  const char *result = (const char *)(void *)0;
  signed int port = 0;
  signed int success = 0;
  signed int return_value_strcmpstart_1;
  return_value_strcmpstart_1=strcmpstart(line, "ERR: Failed to spawn background process - code ");
  if(return_value_strcmpstart_1 == 0)
  {
    signed int child_status;
    log_portfw_spawn_error_message(line, executable, &child_status);
    goto done;
  }

  smartlist_split_string(tokens, line, (const char *)(void *)0, 0x01 | 0x02, -1);
  signed int tmp_statement_expression_2;
  _Bool tmp_if_expr_6;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_9;
  signed int tmp_statement_expression_7;
  if(tokens->num_used >= 5)
  {
    unsigned long int handle_fw_helper_line__1__2____s1_len;
    unsigned long int handle_fw_helper_line__1__2____s2_len;
    signed int return_value___builtin_strcmp_3;
    return_value___builtin_strcmp_3=__builtin_strcmp((const char *)tokens->list[(signed long int)0], "tor-fw-helper");
    tmp_statement_expression_2 = return_value___builtin_strcmp_3;
    if(!(tmp_statement_expression_2 == 0))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      unsigned long int handle_fw_helper_line__1__3____s1_len;
      unsigned long int handle_fw_helper_line__1__3____s2_len;
      signed int return_value___builtin_strcmp_5;
      return_value___builtin_strcmp_5=__builtin_strcmp((const char *)tokens->list[(signed long int)1], "tcp-forward");
      tmp_statement_expression_4 = return_value___builtin_strcmp_5;
      tmp_if_expr_6 = tmp_statement_expression_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      goto err;

    external_port = (const char *)tokens->list[(signed long int)2];
    internal_port = (const char *)tokens->list[(signed long int)3];
    result = (const char *)tokens->list[(signed long int)4];
    if(tokens->num_used >= 6)
    {
      signed int i;
      signed int message_words_n = tokens->num_used - 5;
      struct smartlist_t *message_sl;
      message_sl=smartlist_new();
      i = 0;
      for( ; !(i >= message_words_n); i = i + 1)
        smartlist_add(message_sl, tokens->list[(signed long int)(5 + i)]);
      if(!(message_sl->num_used >= 1))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)5146, "handle_fw_helper_line", "smartlist_len(message_sl) > 0");
        abort();
      }

      message=smartlist_join_strings(message_sl, " ", 0, (unsigned long int *)(void *)0);
      tor_asprintf(&message_for_log, " ('%s')", message);
      smartlist_free(message_sl);
    }

    port=atoi_link1(external_port);
    if(port >= 65536 || !(port >= 1))
      goto err;

    port=atoi_link1(internal_port);
    if(port >= 65536 || !(port >= 1))
      goto err;

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_10;
    return_value___builtin_strcmp_10=__builtin_strcmp(result, "SUCCESS");
    tmp_statement_expression_9 = return_value___builtin_strcmp_10;
    if(tmp_statement_expression_9 == 0)
      success = 1;

    else
    {
      unsigned long int handle_fw_helper_line__1__6____s1_len;
      unsigned long int handle_fw_helper_line__1__6____s2_len;
      signed int return_value___builtin_strcmp_8;
      return_value___builtin_strcmp_8=__builtin_strcmp(result, "FAIL");
      tmp_statement_expression_7 = return_value___builtin_strcmp_8;
      if(tmp_statement_expression_7 == 0)
        success = 0;

      else
        goto err;
    }
    if(success == 0)
      log_fn_(4, 1u << 0, "handle_fw_helper_line", "Tor was unable to forward TCP port '%s' to '%s'%s. Please make sure that your router supports port forwarding protocols (like NAT-PMP). Note that if '%s' is your ORPort, your relay will be unable to receive inbound traffic.", external_port, internal_port, message_for_log != ((char *)NULL) ? message_for_log : "", internal_port);

    else
      log_fn_(6, 1u << 0, "handle_fw_helper_line", "Tor successfully forwarded TCP port '%s' to '%s'%s.", external_port, internal_port, message_for_log != ((char *)NULL) ? message_for_log : "");
  }

  else
  {

  err:
    ;
    log_fn_(4, 1u << 0, "handle_fw_helper_line", "tor-fw-helper sent us a string we could not parse (%s).", line);
  }

done:
  ;
  signed int cp_sl_idx;
  signed int cp_sl_len = tokens->num_used;
  char *cp;
  cp_sl_idx = 0;
  for( ; !(cp_sl_idx >= cp_sl_len); cp_sl_idx = cp_sl_idx + 1)
  {
    cp = (char *)tokens->list[(signed long int)cp_sl_idx];
    if(!(cp == ((char *)NULL)))
    {
      free((void *)cp);
      cp = (char *)(void *)0;
    }

    cp = (char *)(void *)0;
  }
  smartlist_free(tokens);
  if(!(message == ((char *)NULL)))
  {
    free((void *)message);
    message = (char *)(void *)0;
  }

  if(!(message_for_log == ((char *)NULL)))
  {
    free((void *)message_for_log);
    message_for_log = (char *)(void *)0;
  }

}

// handle_fw_helper_output
// file ../src/common/util.c line 5201
static signed int handle_fw_helper_output(const char *executable, struct process_handle_t *process_handle)
{
  struct smartlist_t *fw_helper_output = (struct smartlist_t *)(void *)0;
  enum stream_status stream_status = (enum stream_status)0;
  struct _IO_FILE *return_value_tor_process_get_stdout_pipe_1;
  return_value_tor_process_get_stdout_pipe_1=tor_process_get_stdout_pipe(process_handle);
  fw_helper_output=tor_get_lines_from_handle(return_value_tor_process_get_stdout_pipe_1, &stream_status);
  if(fw_helper_output == ((struct smartlist_t *)NULL))
    return (signed int)stream_status == IO_STREAM_EAGAIN ? 0 : -1;

  else
  {
    signed int line_sl_idx;
    signed int line_sl_len = fw_helper_output->num_used;
    char *line;
    line_sl_idx = 0;
    for( ; !(line_sl_idx >= line_sl_len); line_sl_idx = line_sl_idx + 1)
    {
      line = (char *)fw_helper_output->list[(signed long int)line_sl_idx];
      handle_fw_helper_line(executable, line);
      if(!(line == ((char *)NULL)))
      {
        free((void *)line);
        line = (char *)(void *)0;
      }

      line = (char *)(void *)0;
    }
    smartlist_free(fw_helper_output);
    return 0;
  }
}

// hex_decode_digit
// file ../src/common/util.h line 260
signed int hex_decode_digit(char c)
{
  signed int return_value_hex_decode_digit__1;
  return_value_hex_decode_digit__1=hex_decode_digit_(c);
  return return_value_hex_decode_digit__1;
}

// hex_decode_digit_
// file ../src/common/util.c line 1237
static inline signed int hex_decode_digit_(char c)
{
  switch((signed int)c)
  {
    case 48:
      return 0;
    case 49:
      return 1;
    case 50:
      return 2;
    case 51:
      return 3;
    case 52:
      return 4;
    case 53:
      return 5;
    case 54:
      return 6;
    case 55:
      return 7;
    case 56:
      return 8;
    case 57:
      return 9;
    case 65:

    case 97:
      return 10;
    case 66:

    case 98:
      return 11;
    case 67:

    case 99:
      return 12;
    case 68:

    case 100:
      return 13;
    case 69:

    case 101:
      return 14;
    case 70:

    case 102:
      return 15;
    default:
      return -1;
  }
}

// hex_str
// file ../src/common/util.c line 623
const char * hex_str(const char *from, unsigned long int fromlen)
{
  if(fromlen >= 33ul)
    fromlen = (sizeof(char [65l]) /*65ul*/  - (unsigned long int)1) / (unsigned long int)2;

  static char buf[65l];
  base16_encode(buf, sizeof(char [65l]) /*65ul*/ , from, fromlen);
  return buf;
}

// ifaddrs_to_smartlist
// file ../src/common/address.c line 1236
static struct smartlist_t * ifaddrs_to_smartlist(struct ifaddrs *ifa)
{
  struct smartlist_t *result;
  result=smartlist_new();
  struct ifaddrs *i = ifa;
  for( ; !(i == ((struct ifaddrs *)NULL)); i = i->ifa_next)
  {
    struct tor_addr_t tmp;
    if((65u & i->ifa_flags) == 65u)
    {
      if(!(i->ifa_addr == ((struct sockaddr *)NULL)))
      {
        if(!((signed int)i->ifa_addr->sa_family == 2))
        {
          if((signed int)i->ifa_addr->sa_family == 10)
            goto __CPROVER_DUMP_L4;

        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          signed int return_value_tor_addr_from_sockaddr_1;
          return_value_tor_addr_from_sockaddr_1=tor_addr_from_sockaddr(&tmp, i->ifa_addr, (unsigned short int *)(void *)0);
          if(return_value_tor_addr_from_sockaddr_1 >= 0)
          {
            void *return_value_tor_memdup__2;
            return_value_tor_memdup__2=tor_memdup_((const void *)&tmp, sizeof(struct tor_addr_t) /*20ul*/ );
            smartlist_add(result, return_value_tor_memdup__2);
          }

        }
      }

    }

  }
  return result;
}

// ifreq_to_smartlist
// file ../src/common/address.c line 1390
static struct smartlist_t * ifreq_to_smartlist(char *buf, unsigned long int buflen)
{
  struct smartlist_t *result;
  result=smartlist_new();
  char *end = buf + (signed long int)buflen;
  struct ifreq *r;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_((unsigned long int)4096);
  r = (struct ifreq *)return_value_tor_malloc__1;
  _Bool tmp_if_expr_2;
  void *return_value_tor_memdup__4;
  while(!(buf >= end))
  {
    memcpy_link1((void *)r, (const void *)buf, (unsigned long int)(end - buf < (signed long int)4096 ? end - buf : (signed long int)4096));
    struct sockaddr *sa = &r->ifr_ifru.ifru_addr;
    struct tor_addr_t tmp;
    signed int valid_sa_family;
    if((signed int)sa->sa_family == 2)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)sa->sa_family == 10 ? (_Bool)1 : (_Bool)0;
    valid_sa_family = (signed int)tmp_if_expr_2;
    signed int conversion_success;
    signed int return_value_tor_addr_from_sockaddr_3;
    return_value_tor_addr_from_sockaddr_3=tor_addr_from_sockaddr(&tmp, sa, (unsigned short int *)(void *)0);
    conversion_success = (signed int)(return_value_tor_addr_from_sockaddr_3 == 0);
    if(!(conversion_success == 0) && !(valid_sa_family == 0))
    {
      return_value_tor_memdup__4=tor_memdup_((const void *)&tmp, sizeof(struct tor_addr_t) /*20ul*/ );
      smartlist_add(result, return_value_tor_memdup__4);
    }

    buf = buf + (signed long int)sizeof(struct ifreq) /*40ul*/ ;
  }
  if(!(r == ((struct ifreq *)NULL)))
  {
    free((void *)r);
    r = (struct ifreq *)(void *)0;
  }

  return result;
}

// in_main_thread
// file ../src/common/compat_threads.c line 85
signed int in_main_thread(void)
{
  unsigned long int return_value_tor_get_thread_id_1;
  return_value_tor_get_thread_id_1=tor_get_thread_id();
  return (signed int)(main_thread_id == return_value_tor_get_thread_id_1);
}

// init_logging
// file ../src/tools/../common/torlog.h line 126
void init_logging(signed int disable_startup_queue)
{
  if(log_mutex_initialized == 0)
  {
    tor_mutex_init(&log_mutex);
    log_mutex_initialized = 1;
  }

  if(pending_cb_messages == ((struct smartlist_t *)NULL))
    pending_cb_messages=smartlist_new();

  if(!(disable_startup_queue == 0))
    queue_startup_messages = 0;

  if(pending_startup_messages == ((struct smartlist_t *)NULL) && !(queue_startup_messages == 0))
    pending_startup_messages=smartlist_new();

}

// initialise_libseccomp_sandbox
// file ../src/common/sandbox.c line 1703
static signed int initialise_libseccomp_sandbox(struct sandbox_cfg_elem *cfg)
{
  setenv("LIBC_FATAL_STDERR_", "1", 1);
  signed int return_value_install_sigsys_debugging_1;
  return_value_install_sigsys_debugging_1=install_sigsys_debugging();
  if(!(return_value_install_sigsys_debugging_1 == 0))
    return -1;

  else
  {
    signed int return_value_install_syscall_filter_2;
    return_value_install_syscall_filter_2=install_syscall_filter(cfg);
    if(!(return_value_install_syscall_filter_2 == 0))
      return -2;

    else
    {
      signed int return_value_register_cfg_3;
      return_value_register_cfg_3=register_cfg(cfg);
      if(!(return_value_register_cfg_3 == 0))
        return -3;

      else
        return 0;
    }
  }
}

// install_bt_handler
// file ../src/common/backtrace.c line 150
static signed int install_bt_handler(void)
{
  signed int trap_signals[7l] = { 11, 4, 8, 7, 31, 29, -1 };
  signed int i;
  signed int rv = 0;
  struct sigaction sa;
  tor_mutex_init(&cb_buf_mutex);
  memset_link2((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_sigaction = crash_handler;
  sa.sa_flags = 4;
  sigfillset(&sa.sa_mask);
  i = 0;
  for( ; trap_signals[(signed long int)i] >= 0; i = i + 1)
  {
    signed int return_value_sigaction_3;
    return_value_sigaction_3=sigaction(trap_signals[(signed long int)i], &sa, (struct sigaction *)(void *)0);
    if(return_value_sigaction_3 == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 12, "install_bt_handler", "Sigaction failed: %s", return_value_strerror_2);
      rv = -1;
    }

  }
  char **symbols;
  signed int depth;
  depth=backtrace(cb_buf, 256);
  symbols=backtrace_symbols(cb_buf, depth);
  if(!(symbols == ((char **)NULL)))
    free((void *)symbols);

  return rv;
}

// install_sigsys_debugging
// file ../src/common/sandbox.c line 1648
static signed int install_sigsys_debugging(void)
{
  struct sigaction act;
  struct anonymous_27 mask;
  memset_link9((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  sigemptyset(&mask);
  sigaddset(&mask, 31);
  act.__sigaction_handler.sa_sigaction = sigsys_debugging;
  act.sa_flags = 4;
  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(31, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction_1 >= 0))
  {
    log_fn_(3, 1u << 12, "install_sigsys_debugging", "(Sandbox) Failed to register SIGSYS signal handler");
    return -1;
  }

  else
  {
    signed int return_value_sigprocmask_2;
    return_value_sigprocmask_2=sigprocmask(1, &mask, (struct anonymous_27 *)(void *)0);
    if(!(return_value_sigprocmask_2 == 0))
    {
      log_fn_(3, 1u << 12, "install_sigsys_debugging", "(Sandbox) Failed call to sigprocmask()");
      return -2;
    }

    else
      return 0;
  }
}

// install_syscall_filter
// file ../src/common/sandbox.c line 1522
static signed int install_syscall_filter(struct sandbox_cfg_elem *cfg)
{
  signed int rc = 0;
  void *ctx;
  ctx=seccomp_init(0x00030000U);
  if(ctx == NULL)
  {
    log_fn_(3, 1u << 12, "install_syscall_filter", "(Sandbox) failed to initialise libseccomp context");
    rc = -1;
  }

  else
  {
    rc=prot_strings(ctx, cfg);
    if(rc == 0)
    {
      rc=add_param_filter(ctx, cfg);
      if(!(rc == 0))
        log_fn_(3, 1u << 12, "install_syscall_filter", "(Sandbox) failed to add param filters!");

      else
      {
        rc=add_noparam_filter(ctx);
        if(!(rc == 0))
          log_fn_(3, 1u << 12, "install_syscall_filter", "(Sandbox) failed to add param filters!");

        else
        {
          rc=seccomp_load(ctx);
          if(!(rc == 0))
          {
            char *return_value_strerror_1;
            return_value_strerror_1=strerror(-rc);
            log_fn_(3, 1u << 12, "install_syscall_filter", "(Sandbox) failed to load: %d (%s)!", rc, return_value_strerror_1);
            goto end;
          }

          sandbox_active = 1;
        }
      }
    }

  }

end:
  ;
  seccomp_release(ctx);
  return rc < 0 ? -rc : rc;
}

// int_array_contains
// file ../src/common/log.c line 583
static signed int int_array_contains(const signed int *array, signed int n, signed int item)
{
  signed int j = 0;
  for( ; !(j >= n); j = j + 1)
    if(array[(signed long int)j] == item)
      return 1;

  return 0;
}

// libor_get_digests
// file ../src/common/util_codedigest.c line 7
const char * libor_get_digests(void)
{
  return "388282ad2a9be7209d64f18d05b1ba65fd254dc8  src/common/aes.c\n9d7b55647f26384dfbf524f043028571dadbec51  src/common/crypto.c\n0b74196174dd659e06d2acc2a9eeb3894d199b37  src/common/crypto_pwbox.c\n2c2f6be4d102cfa5809e0feccc965de328455e5f  src/common/crypto_s2k.c\nd32792de7933175ffd207b24ba7b403f53db1e8e  src/common/crypto_format.c\n9d7771d235460799b8c24cb99747eb7fba3d95fe  src/common/torgzip.c\n3c4b693454a857fd35c3c3746360380ca631030b  src/common/tortls.c\neff2f9dfcbb473377dd88cfbb2a12104c2169805  src/trunnel/pwbox.c\nee0b818a6399cd42d64308672662650b9fdef6ac  src/common/crypto_curve25519.c\na0bcdda60a6ae912f6e1b03587d50503f34f13dc  src/common/crypto_ed25519.c\n1d818d0f535e1cb108216899e8860d26531a05ec  src/common/address.h\n135a2ebae589253470274671d9dec108ae9618bd  src/common/backtrace.h\n4665d287a553f204c9e7be24ac28c432d9bb5aeb  src/common/aes.h\n2ad59cee80471c42536e66e24e73a8948e345dcf  src/common/ciphers.inc\na2e9d5bedb78b998138f9f13781e465aed579f56  src/common/compat.h\n6dcf8636aab7bfdee4921015a63ea9aba143575c  src/common/compat_libevent.h\nf1eddd7b993e741c205a9ce3bdd469f88a06d022  src/common/compat_threads.h\n6d1ad11427e20973b8f9d37cfb7d99f85359fe3d  src/common/container.h\n93b4e0962fb4339a3ba2c933600a8935e2d06df2  src/common/crypto.h\ne9e312f01e636ed724dff3c3eede7e70b78b6eff  src/common/crypto_curve25519.h\n3c655ccf14558907aea4e57a7a3ad424b86e2c04  src/common/crypto_ed25519.h\n60e9f5a3bb97c64067dda964c802658e5a7a9416  src/common/crypto_pwbox.h\n57ea08e5504eb9dc6676ba20e8e954ba99be182f  src/common/crypto_s2k.h\nf81aaf5dc65288d7e49605070c0562046b5e6f75  src/common/di_ops.h\nf3726fd6d7748867742430e8d9c0b365c3a8ddc3  src/common/memarea.h\n7262ee6ee9b7850f9da39e619b5abe05b1bcd1e9  src/common/linux_syscalls.inc\n8052af091fb82e9db23b806ea08c461476f6d13c  src/common/procmon.h\n9551f00348bf0f16c58b52499ffa5cf4d4228be1  src/common/sandbox.h\n178332c452087501b75263fd5c1beefdc0751a93  src/common/testsupport.h\n0e9e4821f6fea5f6f58f43107560b6e8c62fc09f  src/common/torgzip.h\n6127e49cfc2132809b86e5fc26fce3b012d85747  src/common/torint.h\n7e0227ad683c25ae3a9433a5df804566fee78c66  src/common/torlog.h\nc4398bece50081fc110e8c06f92a06d91c93dd72  src/common/tortls.h\n1c9b9425d7067bb7027fb1b1151cd4a935d3051d  src/common/util.h\n968169a4d83aa2fe84d0f158a63aa4ee1be818ca  src/common/util_process.h\n38240814cae15e52ebce675a0c54e30f3ebf8a23  src/common/workqueue.h\n";
}

// log_backtrace
// file ../src/common/backtrace.c line 90
void log_backtrace(signed int severity, signed int domain, const char *msg)
{
  signed int depth;
  char **symbols;
  signed int i;
  tor_mutex_acquire(&cb_buf_mutex);
  depth=backtrace(cb_buf, 256);
  symbols=backtrace_symbols(cb_buf, depth);
  tor_log(severity, (unsigned int)domain, "%s. Stack trace:", msg);
  if(symbols == ((char **)NULL))
    tor_log(severity, (unsigned int)domain, "    Unable to generate backtrace.");

  else
  {
    i = 0;
    for( ; !(i >= depth); i = i + 1)
      tor_log(severity, (unsigned int)domain, "    %s", symbols[(signed long int)i]);
    free((void *)symbols);
  }

done:
  ;
  tor_mutex_release(&cb_buf_mutex);
}

// log_credential_status
// file ../src/common/compat.c line 1643
static signed int log_credential_status(void)
{
  unsigned int ruid;
  unsigned int euid;
  unsigned int suid;
  unsigned int rgid;
  unsigned int egid;
  unsigned int sgid;
  unsigned int *sup_gids = (unsigned int *)(void *)0;
  signed int sup_gids_size;
  signed int ngids;
  signed int return_value_getresuid_3;
  return_value_getresuid_3=getresuid(&ruid, &euid, &suid);
  if(!(return_value_getresuid_3 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 0, "log_credential_status", "Error getting changed UIDs: %s", return_value_strerror_2);
    return -1;
  }

  else
    log_fn_(6, 1u << 0, "log_credential_status", "UID is %u (real), %u (effective), %u (saved)", (unsigned int)ruid, (unsigned int)euid, (unsigned int)suid);
  signed int return_value_getresgid_6;
  return_value_getresgid_6=getresgid(&rgid, &egid, &sgid);
  if(!(return_value_getresgid_6 == 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    log_fn_(4, 1u << 0, "log_credential_status", "Error getting changed GIDs: %s", return_value_strerror_5);
    return -1;
  }

  else
    log_fn_(6, 1u << 0, "log_credential_status", "GID is %u (real), %u (effective), %u (saved)", (unsigned int)rgid, (unsigned int)egid, (unsigned int)sgid);
  sup_gids_size = 64;
  void *return_value_tor_calloc__7;
  return_value_tor_calloc__7=tor_calloc_((unsigned long int)64, sizeof(unsigned int) /*4ul*/ );
  sup_gids = (unsigned int *)return_value_tor_calloc__7;
  signed int *return_value___errno_location_8;
  do
  {
    ngids=getgroups(sup_gids_size, sup_gids);
    if(ngids >= 0)
      break;

    return_value___errno_location_8=__errno_location();
    if(!(*return_value___errno_location_8 == 22))
      break;

    if(sup_gids_size >= 65536)
      break;

    sup_gids_size = sup_gids_size * 2;
    void *return_value_tor_reallocarray__9;
    return_value_tor_reallocarray__9=tor_reallocarray_((void *)sup_gids, sizeof(unsigned int) /*4ul*/ , (unsigned long int)sup_gids_size);
    sup_gids = (unsigned int *)return_value_tor_reallocarray__9;
  }
  while((_Bool)1);
  if(!(ngids >= 0))
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    char *return_value_strerror_11;
    return_value_strerror_11=strerror(*return_value___errno_location_10);
    log_fn_(4, 1u << 0, "log_credential_status", "Error getting supplementary GIDs: %s", return_value_strerror_11);
    if(!(sup_gids == ((unsigned int *)NULL)))
    {
      free((void *)sup_gids);
      sup_gids = (unsigned int *)(void *)0;
    }

    return -1;
  }

  else
  {
    signed int i;
    signed int retval = 0;
    char *s = (char *)(void *)0;
    struct smartlist_t *elts;
    elts=smartlist_new();
    i = 0;
    for( ; !(i >= ngids); i = i + 1)
      smartlist_add_asprintf(elts, "%u", (unsigned int)sup_gids[(signed long int)i]);
    s=smartlist_join_strings(elts, " ", 0, (unsigned long int *)(void *)0);
    log_fn_(6, 1u << 0, "log_credential_status", "Supplementary groups are: %s", s);
    if(!(s == ((char *)NULL)))
    {
      free((void *)s);
      s = (char *)(void *)0;
    }

    signed int cp_sl_idx;
    signed int cp_sl_len = elts->num_used;
    char *cp;
    cp_sl_idx = 0;
    for( ; !(cp_sl_idx >= cp_sl_len); cp_sl_idx = cp_sl_idx + 1)
    {
      cp = (char *)elts->list[(signed long int)cp_sl_idx];
      if(!(cp == ((char *)NULL)))
      {
        free((void *)cp);
        cp = (char *)(void *)0;
      }

      cp = (char *)(void *)0;
    }
    smartlist_free(elts);
    if(!(sup_gids == ((unsigned int *)NULL)))
    {
      free((void *)sup_gids);
      sup_gids = (unsigned int *)(void *)0;
    }

    return retval;
  }
  return 0;
}

// log_fn_
// file ../src/tools/../common/torlog.h line 170
void log_fn_(signed int severity, unsigned int domain, const char *fn, const char *format, ...)
{
  void **ap;
  if(log_global_min_severity_ >= severity)
  {
    ap = (void **)&format;
    logv(severity, domain, fn, (const char *)(void *)0, format, ap);
    ap = ((void **)NULL);
  }

}

// log_fn_ratelim_
// file ../src/common/log.c line 675
void log_fn_ratelim_(struct ratelim_t *ratelim, signed int severity, unsigned int domain, const char *fn, const char *format, ...)
{
  void **ap;
  char *m;
  if(log_global_min_severity_ >= severity)
  {
    signed long int return_value_approx_time_1;
    return_value_approx_time_1=approx_time();
    m=rate_limit_log(ratelim, return_value_approx_time_1);
    if(!(m == ((char *)NULL)))
    {
      ap = (void **)&format;
      logv(severity, domain, fn, m, format, ap);
      ap = ((void **)NULL);
      if(!(m == ((char *)NULL)))
      {
        free((void *)m);
        m = (char *)(void *)0;
      }

    }

  }

}

// log_free
// file ../src/common/log.c line 785
static void log_free(struct logfile_t *victim)
{
  if(!(victim == ((struct logfile_t *)NULL)))
  {
    if(!(victim->severities == ((struct log_severity_list_t *)NULL)))
    {
      free((void *)victim->severities);
      victim->severities = (struct log_severity_list_t *)(void *)0;
    }

    if(!(victim->filename == ((char *)NULL)))
    {
      free((void *)victim->filename);
      victim->filename = (char *)(void *)0;
    }

    if(!(victim == ((struct logfile_t *)NULL)))
    {
      free((void *)victim);
      victim = (struct logfile_t *)(void *)0;
    }

  }

}

// log_from_pipe
// file ../src/common/util.c line 4999
static signed int log_from_pipe(struct _IO_FILE *stream, signed int severity, const char *executable, signed int *child_status)
{
  char buf[256l];
  enum stream_status r;
  do
  {
    r=get_string_from_pipe(stream, buf, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1);
    if((signed int)r == IO_STREAM_CLOSED)
      return 1;

    else
      if((signed int)r == IO_STREAM_EAGAIN)
        return 0;

      else
        if((signed int)r == IO_STREAM_TERM)
          return -1;

    if(!((signed int)r == IO_STREAM_OKAY))
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)5016, "log_from_pipe", "r == IO_STREAM_OKAY");
      abort();
    }

    signed int return_value_strcmpstart_1;
    return_value_strcmpstart_1=strcmpstart(buf, "ERR: Failed to spawn background process - code ");
    if(return_value_strcmpstart_1 == 0)
      log_portfw_spawn_error_message(buf, executable, child_status);

    else
      log_fn_(severity, 1u << 0, "log_from_pipe", "Port forwarding helper says: %s", (const void *)buf);
  }
  while((_Bool)1);
  return -1;
}

// log_level_to_string
// file ../src/common/log.c line 1214
const char * log_level_to_string(signed int level)
{
  const char *return_value_sev_to_string_1;
  return_value_sev_to_string_1=sev_to_string(level);
  return return_value_sev_to_string_1;
}

// log_portfw_spawn_error_message
// file ../src/common/util.c line 4851
static void log_portfw_spawn_error_message(const char *buf, const char *executable, signed int *child_status)
{
  signed int retval;
  signed int child_state;
  signed int saved_errno;
  retval=tor_sscanf(buf, "ERR: Failed to spawn background process - code %x/%x", &child_state, &saved_errno);
  if(retval == 2)
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(saved_errno);
    log_fn_(4, 1u << 0, "log_portfw_spawn_error_message", "Failed to start child process \"%s\" in state %d: %s", executable, child_state, return_value_strerror_1);
    if(!(child_status == ((signed int *)NULL)))
      *child_status = 1;

  }

  else
    log_fn_(4, 1u << 0, "log_portfw_spawn_error_message", "Unexpected message from port forwarding helper \"%s\": %s", executable, buf);
}

// log_prefix_
// file ../src/common/log.c line 200
static inline unsigned long int log_prefix_(char *buf, unsigned long int buf_len, signed int severity)
{
  signed long int t;
  struct timeval now;
  struct tm tm;
  unsigned long int n;
  signed int r;
  signed int ms;
  tor_gettimeofday(&now);
  t = (signed long int)now.tv_sec;
  ms = (signed int)now.tv_usec / 1000;
  if(log_time_granularity >= 1000)
  {
    t = t - t % (signed long int)(log_time_granularity / 1000);
    ms = 0;
  }

  else
    ms = ms - ((signed int)now.tv_usec / 1000) % log_time_granularity;
  struct tm *return_value_tor_localtime_r_1;
  return_value_tor_localtime_r_1=tor_localtime_r(&t, &tm);
  n=strftime(buf, buf_len, "%b %d %H:%M:%S", return_value_tor_localtime_r_1);
  const char *return_value_sev_to_string_2;
  return_value_sev_to_string_2=sev_to_string(severity);
  r=tor_snprintf(buf + (signed long int)n, buf_len - n, ".%.3i [%s] ", ms, return_value_sev_to_string_2);
  if(!(r >= 0))
    return buf_len - (unsigned long int)1;

  else
    return n + (unsigned long int)r;
}

// log_set_application_name
// file ../src/common/log.c line 179
void log_set_application_name(const char *name)
{
  if(!(appname == ((char *)NULL)))
  {
    free((void *)appname);
    appname = (char *)(void *)0;
  }

  char *tmp_if_expr_2;
  char *return_value_tor_strdup__1;
  if(!(name == ((const char *)NULL)))
  {
    return_value_tor_strdup__1=tor_strdup_(name);
    tmp_if_expr_2 = return_value_tor_strdup__1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  appname = tmp_if_expr_2;
}

// log_tor_version
// file ../src/common/log.c line 234
static signed int log_tor_version(struct logfile_t *lf, signed int reset)
{
  char buf[256l];
  unsigned long int n;
  signed int is_new;
  _Bool tmp_if_expr_2;
  signed long int return_value_tor_fd_getpos_1;
  if(lf->needs_close == 0)
    return 0;

  else
    if(!(lf->is_temporary == 0))
      return 0;

    else
    {
      if(lf->fd >= 0)
      {
        return_value_tor_fd_getpos_1=tor_fd_getpos(lf->fd);
        tmp_if_expr_2 = return_value_tor_fd_getpos_1 == (signed long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      is_new = (signed int)tmp_if_expr_2;
      if(is_new == 0 && !(reset == 0))
        return 0;

      else
      {
        n=log_prefix_(buf, sizeof(char [256l]) /*256ul*/ , 5);
        if(!(appname == ((char *)NULL)))
          tor_snprintf(buf + (signed long int)n, sizeof(char [256l]) /*256ul*/  - n, "%s opening %slog file.\n", appname, is_new != 0 ? "new " : "");

        else
          tor_snprintf(buf + (signed long int)n, sizeof(char [256l]) /*256ul*/  - n, "Tor %s opening %slog file.\n", (const void *)"0.2.6.10", is_new != 0 ? "new " : "");
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(buf);
        signed long int return_value_write_all_4;
        return_value_write_all_4=write_all(lf->fd, buf, return_value_strlen_3, 0);
        if(!(return_value_write_all_4 >= 0l))
          return -1;

        else
          return 0;
      }
    }
}

// logfile_deliver
// file ../src/common/log.c line 401
static inline void logfile_deliver(struct logfile_t *lf, const char *buf, unsigned long int msg_len, const char *msg_after_prefix, unsigned int domain, signed int severity, signed int *callbacks_deferred)
{
  if(!(lf->is_syslog == 0))
    syslog(severity, "%s", msg_after_prefix);

  else
    if(!(lf->callback == ((void (*)(signed int, unsigned int, const char *))NULL)))
    {
      if(!((2147483648u & domain) == 0u))
      {
        if(*callbacks_deferred == 0)
        {
          if(!(pending_cb_messages == ((struct smartlist_t *)NULL)))
          {
            struct pending_log_message_t *return_value_pending_log_message_new_1;
            return_value_pending_log_message_new_1=pending_log_message_new(severity, domain, (const char *)(void *)0, msg_after_prefix);
            smartlist_add(pending_cb_messages, (void *)return_value_pending_log_message_new_1);
            *callbacks_deferred = 1;
          }

        }

      }

      else
        lf->callback(severity, domain, msg_after_prefix);
    }

    else
    {
      signed long int return_value_write_all_2;
      return_value_write_all_2=write_all(lf->fd, buf, msg_len, 0);
      if(!(return_value_write_all_2 >= 0l))
        lf->seems_dead = 1;

    }
}

// logfile_wants_message
// file ../src/common/log.c line 378
static inline signed int logfile_wants_message(const struct logfile_t *lf, signed int severity, unsigned int domain)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if((lf->severities->masks[(signed long int)(severity + -3)] & domain) == 0u)
    return 0;

  else
  {
    if(lf->fd >= 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = lf->is_syslog != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = lf->callback != ((void (*)(signed int, unsigned int, const char *))NULL) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
      return 0;

    else
      if(!(lf->seems_dead == 0))
        return 0;

      else
        return 1;
  }
}

// logs_free_all
// file ../src/common/log.c line 796
void logs_free_all(void)
{
  struct logfile_t *victim;
  struct logfile_t *next;
  struct smartlist_t *messages;
  struct smartlist_t *messages2;
  tor_mutex_acquire(&log_mutex);
  next = logfiles;
  logfiles = (struct logfile_t *)(void *)0;
  messages = pending_cb_messages;
  pending_cb_messages = (struct smartlist_t *)(void *)0;
  messages2 = pending_startup_messages;
  pending_startup_messages = (struct smartlist_t *)(void *)0;
  tor_mutex_release(&log_mutex);
  while(!(next == ((struct logfile_t *)NULL)))
  {
    victim = next;
    next = next->next;
    close_log(victim);
    log_free(victim);
  }
  if(!(appname == ((char *)NULL)))
  {
    free((void *)appname);
    appname = (char *)(void *)0;
  }

  signed int logs_free_all__1__5__msg_sl_idx;
  signed int logs_free_all__1__5__msg_sl_len = messages->num_used;
  struct pending_log_message_t *logs_free_all__1__5__msg;
  logs_free_all__1__5__msg_sl_idx = 0;
  for( ; !(logs_free_all__1__5__msg_sl_idx >= logs_free_all__1__5__msg_sl_len); logs_free_all__1__5__msg_sl_idx = logs_free_all__1__5__msg_sl_idx + 1)
  {
    logs_free_all__1__5__msg = (struct pending_log_message_t *)messages->list[(signed long int)logs_free_all__1__5__msg_sl_idx];
    pending_log_message_free(logs_free_all__1__5__msg);
    logs_free_all__1__5__msg = (struct pending_log_message_t *)(void *)0;
  }
  smartlist_free(messages);
  if(!(messages2 == ((struct smartlist_t *)NULL)))
  {
    signed int msg_sl_idx;
    signed int msg_sl_len = messages2->num_used;
    struct pending_log_message_t *msg;
    msg_sl_idx = 0;
    for( ; !(msg_sl_idx >= msg_sl_len); msg_sl_idx = msg_sl_idx + 1)
    {
      msg = (struct pending_log_message_t *)messages2->list[(signed long int)msg_sl_idx];
      pending_log_message_free(msg);
      msg = (struct pending_log_message_t *)(void *)0;
    }
    smartlist_free(messages2);
  }

}

// logs_set_domain_logging
// file ../src/common/log.c line 940
void logs_set_domain_logging(signed int enabled)
{
  tor_mutex_acquire(&log_mutex);
  log_domains_are_logged = enabled;
  tor_mutex_release(&log_mutex);
}

// logv
// file ../src/common/log.c line 450
static void logv(signed int severity, unsigned int domain, const char *funcname, const char *suffix, const char *format, void **ap)
{
  char buf[10240l];
  unsigned long int msg_len = (unsigned long int)0;
  signed int formatted = 0;
  struct logfile_t *lf;
  char *end_of_prefix = (char *)(void *)0;
  signed int callbacks_deferred = 0;
  /* assertion format */
  assert(format != ((const char *)NULL));
  /* assertion severity >= 3 && severity <= 7 */
  assert(severity >= 3 && severity <= 7);
  tor_mutex_acquire(&log_mutex);
  if((2147483648u & domain) == 0u)
  {
    if(!(pending_cb_messages->num_used == 0))
      flush_pending_log_callbacks();

  }

  if(!(queue_startup_messages == 0) && !(pending_startup_messages_len >= 65536ul))
  {
    end_of_prefix=format_msg(buf, sizeof(char [10240l]) /*10240ul*/ , domain, severity, funcname, suffix, format, ap, &msg_len);
    formatted = 1;
    struct pending_log_message_t *return_value_pending_log_message_new_1;
    return_value_pending_log_message_new_1=pending_log_message_new(severity, domain, buf, end_of_prefix);
    smartlist_add(pending_startup_messages, (void *)return_value_pending_log_message_new_1);
    pending_startup_messages_len = pending_startup_messages_len + msg_len;
  }

  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
  {
    signed int return_value_logfile_wants_message_2;
    return_value_logfile_wants_message_2=logfile_wants_message(lf, severity, domain);
    if(!(return_value_logfile_wants_message_2 == 0))
    {
      if(formatted == 0)
      {
        end_of_prefix=format_msg(buf, sizeof(char [10240l]) /*10240ul*/ , domain, severity, funcname, suffix, format, ap, &msg_len);
        formatted = 1;
      }

      logfile_deliver(lf, buf, msg_len, end_of_prefix, domain, severity, &callbacks_deferred);
    }

  }
  tor_mutex_release(&log_mutex);
}

// main
// file ../src/tools/tor-resolve.c line 341
signed int main(signed int argc, char **argv)
{
  unsigned int sockshost;
  unsigned short int socksport = (unsigned short int)0;
  unsigned short int port_option = (unsigned short int)0;
  signed int isSocks4 = 0;
  signed int isVerbose = 0;
  signed int isReverse = 0;
  char **arg;
  signed int n_args;
  struct tor_addr_t result;
  char *result_hostname = (char *)(void *)0;
  struct log_severity_list_t *s;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct log_severity_list_t) /*20ul*/ );
  s = (struct log_severity_list_t *)return_value_tor_malloc_zero__1;
  init_logging(1);
  sandbox_disable_getaddrinfo_cache();
  arg = &argv[(signed long int)1];
  n_args = argc - 1;
  if(n_args == 0)
    usage();

  signed int tmp_statement_expression_2;
  unsigned long int main__1__1____s1_len;
  unsigned long int main__1__1____s2_len;
  signed int return_value___builtin_strcmp_3;
  return_value___builtin_strcmp_3=__builtin_strcmp(arg[(signed long int)0], "--version");
  tmp_statement_expression_2 = return_value___builtin_strcmp_3;
  signed int tmp_statement_expression_12;
  signed int tmp_statement_expression_10;
  signed int tmp_statement_expression_8;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_4;
  if(tmp_statement_expression_2 == 0)
  {
    printf("Tor version %s.\n", (const void *)"0.2.6.10");
    return 0;
  }

  else
  {
    for( ; !(n_args == 0); n_args = n_args - 1)
    {
      if(!((signed int)*(*arg) == 45))
        break;

      unsigned long int main__1__3__1____s1_len;
      unsigned long int main__1__3__1____s2_len;
      signed int return_value___builtin_strcmp_13;
      return_value___builtin_strcmp_13=__builtin_strcmp("-v", arg[(signed long int)0]);
      tmp_statement_expression_12 = return_value___builtin_strcmp_13;
      if(tmp_statement_expression_12 == 0)
        isVerbose = 1;

      else
      {
        unsigned long int __s1_len;
        unsigned long int main__1__3__2____s2_len;
        signed int return_value___builtin_strcmp_11;
        return_value___builtin_strcmp_11=__builtin_strcmp("-4", arg[(signed long int)0]);
        tmp_statement_expression_10 = return_value___builtin_strcmp_11;
        if(tmp_statement_expression_10 == 0)
          isSocks4 = 1;

        else
        {
          unsigned long int main__1__3__3____s1_len;
          unsigned long int main__1__3__3____s2_len;
          signed int return_value___builtin_strcmp_9;
          return_value___builtin_strcmp_9=__builtin_strcmp("-5", arg[(signed long int)0]);
          tmp_statement_expression_8 = return_value___builtin_strcmp_9;
          if(tmp_statement_expression_8 == 0)
            isSocks4 = 0;

          else
          {
            unsigned long int main__1__3__4____s1_len;
            unsigned long int main__1__3__4____s2_len;
            signed int return_value___builtin_strcmp_7;
            return_value___builtin_strcmp_7=__builtin_strcmp("-x", arg[(signed long int)0]);
            tmp_statement_expression_6 = return_value___builtin_strcmp_7;
            if(tmp_statement_expression_6 == 0)
              isReverse = 1;

            else
            {
              unsigned long int main__1__3__5____s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp_5;
              return_value___builtin_strcmp_5=__builtin_strcmp("-p", arg[(signed long int)0]);
              tmp_statement_expression_4 = return_value___builtin_strcmp_5;
              if(tmp_statement_expression_4 == 0)
              {
                signed int p;
                if(!(n_args >= 2))
                {
                  fprintf(stderr, "No arguments given to -p\n");
                  usage();
                }

                p=atoi(arg[(signed long int)1]);
                if(p >= 65536 || !(p >= 1))
                {
                  fprintf(stderr, "-p requires a number between 1 and 65535\n");
                  usage();
                }

                port_option = (unsigned short int)p;
                arg = arg + 1l;
                n_args = n_args - 1;
              }

              else
              {
                fprintf(stderr, "Unrecognized flag '%s'\n", arg[(signed long int)0]);
                usage();
              }
            }
          }
        }
      }
      arg = arg + 1l;
    }
    if(!(isReverse == 0) && !(isSocks4 == 0))
    {
      fprintf(stderr, "Reverse lookups not supported with SOCKS4a\n");
      usage();
    }

    if(!(isVerbose == 0))
      set_log_severity_config(7, 3, s);

    else
      set_log_severity_config(4, 3, s);
    signed int return_value_fileno_14;
    return_value_fileno_14=fileno(stderr);
    add_stream_log(s, "<stderr>", return_value_fileno_14);
    if(n_args == 1)
    {
      if(log_global_min_severity_ == 7)
        log_fn_(7, 1u << 3, "main", "defaulting to localhost");

      sockshost = 0x7f000001u;
      if(!(port_option == 0))
      {
        if(log_global_min_severity_ == 7)
          log_fn_(7, 1u << 3, "main", "Using port %d", (signed int)port_option);

        socksport = port_option;
      }

      else
      {
        if(log_global_min_severity_ == 7)
          log_fn_(7, 1u << 3, "main", "defaulting to port 9050");

        socksport = (unsigned short int)9050;
      }
    }

    else
      if(n_args == 2)
      {
        signed int return_value_addr_port_lookup_15;
        return_value_addr_port_lookup_15=addr_port_lookup(4, arg[(signed long int)1], (char **)(void *)0, &sockshost, &socksport);
        if(!(return_value_addr_port_lookup_15 >= 0))
        {
          fprintf(stderr, "Couldn't parse/resolve address %s", arg[(signed long int)1]);
          return 1;
        }

        if(!(port_option == 0) && !(socksport == 0) && !(socksport == port_option))
          log_fn_(4, 1u << 3, "main", "Conflicting ports; using %d, not %d", (signed int)socksport, (signed int)port_option);

        else
          if(!(port_option == 0))
            socksport = port_option;

          else
            if(socksport == 0)
            {
              if(log_global_min_severity_ == 7)
                log_fn_(7, 1u << 3, "main", "defaulting to port 9050");

              socksport = (unsigned short int)9050;
            }

      }

      else
        usage();
    signed int return_value_network_init_16;
    return_value_network_init_16=network_init();
    if(!(return_value_network_init_16 >= 0))
    {
      log_fn_(3, 1u << 12, "main", "Error initializing network; exiting.");
      return 1;
    }

    else
    {
      signed int return_value_do_resolve_17;
      return_value_do_resolve_17=do_resolve(arg[(signed long int)0], sockshost, socksport, isReverse, isSocks4 != 0 ? 4 : 5, &result, &result_hostname);
      if(!(return_value_do_resolve_17 == 0))
        return 1;

      else
      {
        if(!(result_hostname == ((char *)NULL)))
          printf("%s\n", result_hostname);

        else
        {
          const char *return_value_fmt_addr_impl_18;
          return_value_fmt_addr_impl_18=fmt_addr_impl(&result, 0);
          printf("%s\n", return_value_fmt_addr_impl_18);
        }
        return 0;
      }
    }
  }
}

// make_path_absolute
// file ../src/common/compat.c line 2141
char * make_path_absolute(char *fname)
{
  char *absfname = (char *)(void *)0;
  char *path = (char *)(void *)0;
  if(fname == ((char *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)2155, "make_path_absolute", "fname");
    abort();
  }

  if((signed int)*fname == 47)
    absfname=tor_strdup_(fname);

  else
  {
    path=alloc_getcwd();
    if(!(path == ((char *)NULL)))
    {
      tor_asprintf(&absfname, "%s/%s", path, fname);
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

    }

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 0, "make_path_absolute", "Unable to find current working directory: %s", return_value_strerror_2);
      absfname=tor_strdup_(fname);
    }
  }
  return absfname;
}

// mark_logs_temp
// file ../src/common/log.c line 1122
void mark_logs_temp(void)
{
  struct logfile_t *lf;
  tor_mutex_acquire(&log_mutex);
  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
    lf->is_temporary = 1;
  tor_mutex_release(&log_mutex);
}

// memarea_alloc
// file ../src/common/memarea.c line 231
void * memarea_alloc(struct memarea_t *area, unsigned long int sz)
{
  struct memarea_chunk_t *chunk = area->first;
  char *result;
  if(chunk == ((struct memarea_chunk_t *)NULL))
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)235, "memarea_alloc", "chunk");
    abort();
  }

  unsigned int sent_val;
  sent_val=get_uint32((const void *)&chunk->mem[(signed long int)chunk->mem_size]);
  if(!(sent_val == 0x90806622u))
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)236, "memarea_alloc", "sent_val == SENTINEL_VAL");
    abort();
  }

  if(sz >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)237, "memarea_alloc", "sz < SIZE_T_CEILING");
    abort();
  }

  if(sz == 0ul)
    sz = (unsigned long int)1;

  if(!(chunk->mem + (signed long int)chunk->mem_size >= chunk->next_mem + (signed long int)sz))
  {
    if(24ul + sz >= 4096ul)
    {
      struct memarea_chunk_t *memarea_alloc__1__4__1__new_chunk;
      memarea_alloc__1__4__1__new_chunk=alloc_chunk(sz + 24ul, 0);
      memarea_alloc__1__4__1__new_chunk->next_chunk = chunk->next_chunk;
      chunk->next_chunk = memarea_alloc__1__4__1__new_chunk;
      chunk = memarea_alloc__1__4__1__new_chunk;
    }

    else
    {
      struct memarea_chunk_t *new_chunk;
      new_chunk=alloc_chunk((unsigned long int)4096, 1);
      new_chunk->next_chunk = chunk;
      chunk = new_chunk;
      area->first = chunk;
    }
    if(!(chunk->mem_size >= sz))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)253, "memarea_alloc", "chunk->mem_size >= sz");
      abort();
    }

  }

  result = chunk->next_mem;
  chunk->next_mem = chunk->next_mem + (signed long int)sz;
  void *return_value_realign_pointer_1;
  return_value_realign_pointer_1=realign_pointer((void *)chunk->next_mem);
  chunk->next_mem = (char *)return_value_realign_pointer_1;
  return (void *)result;
}

// memarea_alloc_zero
// file ../src/common/memarea.c line 267
void * memarea_alloc_zero(struct memarea_t *area, unsigned long int sz)
{
  void *result;
  result=memarea_alloc(area, sz);
  memset_link6(result, 0, sz);
  return result;
}

// memarea_assert_ok
// file ../src/common/memarea.c line 324
void memarea_assert_ok(struct memarea_t *area)
{
  struct memarea_chunk_t *chunk;
  if(area->first == ((struct memarea_chunk_t *)NULL))
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)327, "memarea_assert_ok", "area->first");
    abort();
  }

  chunk = area->first;
  for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = chunk->next_chunk)
  {
    unsigned int sent_val;
    sent_val=get_uint32((const void *)&chunk->mem[(signed long int)chunk->mem_size]);
    if(!(sent_val == 0x90806622u))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)330, "memarea_assert_ok", "sent_val == SENTINEL_VAL");
      abort();
    }

    if(!(chunk->next_mem >= chunk->mem))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)331, "memarea_assert_ok", "chunk->next_mem >= chunk->U_MEM");
      abort();
    }

    void *return_value_realign_pointer_1;
    return_value_realign_pointer_1=realign_pointer((void *)(chunk->mem + (signed long int)chunk->mem_size));
    if(!((char *)return_value_realign_pointer_1 >= chunk->next_mem))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)333, "memarea_assert_ok", "chunk->next_mem <= (char*) realign_pointer(chunk->U_MEM+chunk->mem_size)");
      abort();
    }

  }
}

// memarea_clear
// file ../src/common/memarea.c line 187
void memarea_clear(struct memarea_t *area)
{
  struct memarea_chunk_t *chunk;
  struct memarea_chunk_t *next;
  if(!(area->first->next_chunk == ((struct memarea_chunk_t *)NULL)))
  {
    chunk = area->first->next_chunk;
    for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = next)
    {
      next = chunk->next_chunk;
      chunk_free_unchecked(chunk);
    }
    area->first->next_chunk = (struct memarea_chunk_t *)(void *)0;
  }

  area->first->next_mem = area->first->mem;
}

// memarea_clear_freelist
// file ../src/common/memarea.c line 202
void memarea_clear_freelist(void)
{
  struct memarea_chunk_t *chunk;
  struct memarea_chunk_t *next;
  freelist_len = 0;
  chunk = freelist;
  for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = next)
  {
    next = chunk->next_chunk;
    if(!(chunk == ((struct memarea_chunk_t *)NULL)))
    {
      free((void *)chunk);
      chunk = (struct memarea_chunk_t *)(void *)0;
    }

  }
  freelist = (struct memarea_chunk_t *)(void *)0;
}

// memarea_drop_all
// file ../src/common/memarea.c line 172
void memarea_drop_all(struct memarea_t *area)
{
  struct memarea_chunk_t *chunk;
  struct memarea_chunk_t *next;
  chunk = area->first;
  for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = next)
  {
    next = chunk->next_chunk;
    chunk_free_unchecked(chunk);
  }
  area->first = (struct memarea_chunk_t *)(void *)0;
  if(!(area == ((struct memarea_t *)NULL)))
  {
    free((void *)area);
    area = (struct memarea_t *)(void *)0;
  }

}

// memarea_get_stats
// file ../src/common/memarea.c line 308
void memarea_get_stats(struct memarea_t *area, unsigned long int *allocated_out, unsigned long int *used_out)
{
  unsigned long int a = (unsigned long int)0;
  unsigned long int u = (unsigned long int)0;
  struct memarea_chunk_t *chunk = area->first;
  for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = chunk->next_chunk)
  {
    unsigned int sent_val;
    sent_val=get_uint32((const void *)&chunk->mem[(signed long int)chunk->mem_size]);
    if(!(sent_val == 0x90806622u))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)313, "memarea_get_stats", "sent_val == SENTINEL_VAL");
      abort();
    }

    a = a + 24ul + chunk->mem_size;
    if(!(chunk->next_mem >= chunk->mem))
    {
      tor_assertion_failed_("../src/common/memarea.c", (unsigned int)315, "memarea_get_stats", "chunk->next_mem >= chunk->U_MEM");
      abort();
    }

    u = u + 24ul + (unsigned long int)(chunk->next_mem - chunk->mem);
  }
  *allocated_out = a;
  *used_out = u;
}

// memarea_memdup
// file ../src/common/memarea.c line 276
void * memarea_memdup(struct memarea_t *area, const void *s, unsigned long int n)
{
  char *result;
  void *return_value_memarea_alloc_1;
  return_value_memarea_alloc_1=memarea_alloc(area, n);
  result = (char *)return_value_memarea_alloc_1;
  memcpy_link6((void *)result, s, n);
  return (void *)result;
}

// memarea_new
// file ../src/common/memarea.c line 162
struct memarea_t * memarea_new(void)
{
  struct memarea_t *head;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct memarea_t) /*8ul*/ );
  head = (struct memarea_t *)return_value_tor_malloc__1;
  head->first=alloc_chunk((unsigned long int)4096, 1);
  return head;
}

// memarea_owns_ptr
// file ../src/common/memarea.c line 216
signed int memarea_owns_ptr(const struct memarea_t *area, const void *p)
{
  struct memarea_chunk_t *chunk;
  const char *ptr = (const char *)p;
  chunk = area->first;
  for( ; !(chunk == ((struct memarea_chunk_t *)NULL)); chunk = chunk->next_chunk)
    if(ptr >= chunk->mem)
    {
      if(!(ptr >= chunk->next_mem))
        return 1;

    }

  return 0;
}

// memarea_strdup
// file ../src/common/memarea.c line 285
char * memarea_strdup(struct memarea_t *area, const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  void *return_value_memarea_memdup_2;
  return_value_memarea_memdup_2=memarea_memdup(area, (const void *)s, return_value_strlen_1 + (unsigned long int)1);
  return (char *)return_value_memarea_memdup_2;
}

// memarea_strndup
// file ../src/common/memarea.c line 292
char * memarea_strndup(struct memarea_t *area, const char *s, unsigned long int n)
{
  unsigned long int ln = (unsigned long int)0;
  char *result;
  if(n >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/memarea.c", (unsigned int)296, "memarea_strndup", "n < SIZE_T_CEILING");
    abort();
  }

  ln = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(ln >= n))
      tmp_if_expr_1 = s[(signed long int)ln] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    ln = ln + 1ul;
  }
  while((_Bool)1);
  void *return_value_memarea_alloc_2;
  return_value_memarea_alloc_2=memarea_alloc(area, ln + (unsigned long int)1);
  result = (char *)return_value_memarea_alloc_2;
  memcpy_link6((void *)result, (const void *)s, ln);
  result[(signed long int)ln] = (char)0;
  return result;
}

// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len)
{
  void *return_value___builtin___memcpy_chk_1;
  return_value___builtin___memcpy_chk_1=__builtin___memcpy_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1;
}

// memcpy_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link1(void * restrict __dest_link1, const void * restrict __src_link1, unsigned long int __len_link1)
{
  void *return_value___builtin___memcpy_chk_1_link1;
  return_value___builtin___memcpy_chk_1_link1=__builtin___memcpy_chk(__dest_link1, __src_link1, __len_link1, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link1;
}

// memcpy_link10
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link10(void * restrict __dest_link10, const void * restrict __src_link10, unsigned long int __len_link10)
{
  void *return_value___builtin___memcpy_chk_1_link10;
  return_value___builtin___memcpy_chk_1_link10=__builtin___memcpy_chk(__dest_link10, __src_link10, __len_link10, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link10;
}

// memcpy_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link2(void * restrict __dest_link2, const void * restrict __src_link2, unsigned long int __len_link2)
{
  void *return_value___builtin___memcpy_chk_1_link2;
  return_value___builtin___memcpy_chk_1_link2=__builtin___memcpy_chk(__dest_link2, __src_link2, __len_link2, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link2;
}

// memcpy_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link3(void * restrict __dest_link3, const void * restrict __src_link3, unsigned long int __len_link3)
{
  void *return_value___builtin___memcpy_chk_1_link3;
  return_value___builtin___memcpy_chk_1_link3=__builtin___memcpy_chk(__dest_link3, __src_link3, __len_link3, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link3;
}

// memcpy_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link4(void * restrict __dest_link4, const void * restrict __src_link4, unsigned long int __len_link4)
{
  void *return_value___builtin___memcpy_chk_1_link4;
  return_value___builtin___memcpy_chk_1_link4=__builtin___memcpy_chk(__dest_link4, __src_link4, __len_link4, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link4;
}

// memcpy_link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link5(void * restrict __dest_link5, const void * restrict __src_link5, unsigned long int __len_link5)
{
  void *return_value___builtin___memcpy_chk_1_link5;
  return_value___builtin___memcpy_chk_1_link5=__builtin___memcpy_chk(__dest_link5, __src_link5, __len_link5, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link5;
}

// memcpy_link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link6(void * restrict __dest_link6, const void * restrict __src_link6, unsigned long int __len_link6)
{
  void *return_value___builtin___memcpy_chk_1_link6;
  return_value___builtin___memcpy_chk_1_link6=__builtin___memcpy_chk(__dest_link6, __src_link6, __len_link6, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link6;
}

// memcpy_link7
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link7(void * restrict __dest_link7, const void * restrict __src_link7, unsigned long int __len_link7)
{
  void *return_value___builtin___memcpy_chk_1_link7;
  return_value___builtin___memcpy_chk_1_link7=__builtin___memcpy_chk(__dest_link7, __src_link7, __len_link7, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link7;
}

// memcpy_link8
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link8(void * restrict __dest_link8, const void * restrict __src_link8, unsigned long int __len_link8)
{
  void *return_value___builtin___memcpy_chk_1_link8;
  return_value___builtin___memcpy_chk_1_link8=__builtin___memcpy_chk(__dest_link8, __src_link8, __len_link8, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link8;
}

// memcpy_link9
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
static inline void * memcpy_link9(void * restrict __dest_link9, const void * restrict __src_link9, unsigned long int __len_link9)
{
  void *return_value___builtin___memcpy_chk_1_link9;
  return_value___builtin___memcpy_chk_1_link9=__builtin___memcpy_chk(__dest_link9, __src_link9, __len_link9, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk_1_link9;
}

// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len)
{
  char *return_value___builtin___memmove_chk_1;
  return_value___builtin___memmove_chk_1=__builtin___memmove_chk(__dest, __src, __len, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk_1;
}

// memmove_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
static inline void * memmove_link1(void *__dest_link1, const void *__src_link1, unsigned long int __len_link1)
{
  char *return_value___builtin___memmove_chk_1_link1;
  return_value___builtin___memmove_chk_1_link1=__builtin___memmove_chk(__dest_link1, __src_link1, __len_link1, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk_1_link1;
}

// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len)
{
  {
    void *return_value___builtin___memset_chk_1;
    return_value___builtin___memset_chk_1=__builtin___memset_chk(__dest, __ch, __len, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1;
  }
}

// memset_link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link1(void *__dest_link1, signed int __ch_link1, unsigned long int __len_link1)
{
  {
    void *return_value___builtin___memset_chk_1_link1;
    return_value___builtin___memset_chk_1_link1=__builtin___memset_chk(__dest_link1, __ch_link1, __len_link1, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link1;
  }
}

// memset_link10
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link10(void *__dest_link10, signed int __ch_link10, unsigned long int __len_link10)
{
  {
    void *return_value___builtin___memset_chk_1_link10;
    return_value___builtin___memset_chk_1_link10=__builtin___memset_chk(__dest_link10, __ch_link10, __len_link10, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link10;
  }
}

// memset_link11
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link11(void *__dest_link11, signed int __ch_link11, unsigned long int __len_link11)
{
  {
    void *return_value___builtin___memset_chk_1_link11;
    return_value___builtin___memset_chk_1_link11=__builtin___memset_chk(__dest_link11, __ch_link11, __len_link11, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link11;
  }
}

// memset_link12
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link12(void *__dest_link12, signed int __ch_link12, unsigned long int __len_link12)
{
  {
    void *return_value___builtin___memset_chk_1_link12;
    return_value___builtin___memset_chk_1_link12=__builtin___memset_chk(__dest_link12, __ch_link12, __len_link12, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link12;
  }
}

// memset_link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link2(void *__dest_link2, signed int __ch_link2, unsigned long int __len_link2)
{
  {
    void *return_value___builtin___memset_chk_1_link2;
    return_value___builtin___memset_chk_1_link2=__builtin___memset_chk(__dest_link2, __ch_link2, __len_link2, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link2;
  }
}

// memset_link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link3(void *__dest_link3, signed int __ch_link3, unsigned long int __len_link3)
{
  {
    void *return_value___builtin___memset_chk_1_link3;
    return_value___builtin___memset_chk_1_link3=__builtin___memset_chk(__dest_link3, __ch_link3, __len_link3, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link3;
  }
}

// memset_link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link4(void *__dest_link4, signed int __ch_link4, unsigned long int __len_link4)
{
  {
    void *return_value___builtin___memset_chk_1_link4;
    return_value___builtin___memset_chk_1_link4=__builtin___memset_chk(__dest_link4, __ch_link4, __len_link4, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link4;
  }
}

// memset_link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link5(void *__dest_link5, signed int __ch_link5, unsigned long int __len_link5)
{
  {
    void *return_value___builtin___memset_chk_1_link5;
    return_value___builtin___memset_chk_1_link5=__builtin___memset_chk(__dest_link5, __ch_link5, __len_link5, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link5;
  }
}

// memset_link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link6(void *__dest_link6, signed int __ch_link6, unsigned long int __len_link6)
{
  {
    void *return_value___builtin___memset_chk_1_link6;
    return_value___builtin___memset_chk_1_link6=__builtin___memset_chk(__dest_link6, __ch_link6, __len_link6, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link6;
  }
}

// memset_link7
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link7(void *__dest_link7, signed int __ch_link7, unsigned long int __len_link7)
{
  {
    void *return_value___builtin___memset_chk_1_link7;
    return_value___builtin___memset_chk_1_link7=__builtin___memset_chk(__dest_link7, __ch_link7, __len_link7, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link7;
  }
}

// memset_link8
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link8(void *__dest_link8, signed int __ch_link8, unsigned long int __len_link8)
{
  {
    void *return_value___builtin___memset_chk_1_link8;
    return_value___builtin___memset_chk_1_link8=__builtin___memset_chk(__dest_link8, __ch_link8, __len_link8, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link8;
  }
}

// memset_link9
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
static inline void * memset_link9(void *__dest_link9, signed int __ch_link9, unsigned long int __len_link9)
{
  {
    void *return_value___builtin___memset_chk_1_link9;
    return_value___builtin___memset_chk_1_link9=__builtin___memset_chk(__dest_link9, __ch_link9, __len_link9, 18446744073709551615ul);
    return return_value___builtin___memset_chk_1_link9;
  }
}

// n_bits_set_u8
// file ../src/common/util.c line 573
signed int n_bits_set_u8(unsigned char v)
{
  static const signed int nybble_table[16l] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
  return nybble_table[(signed long int)((signed int)v & 15)] + nybble_table[(signed long int)((signed int)v >> 4)];
}

// n_leapdays
// file ../src/common/util.c line 1514
static signed int n_leapdays(signed int y1, signed int y2)
{
  y1 = y1 - 1;
  y2 = y2 - 1;
  return ((y2 / 4 - y1 / 4) - (y2 / 100 - y1 / 100)) + (y2 / 400 - y1 / 400);
}

// network_init
// file ../src/common/compat.h line 551
signed int network_init(void)
{
  return 0;
}

// new_element
// file ../src/common/sandbox.c line 1199
static struct sandbox_cfg_elem * new_element(signed int syscall, char *value)
{
  struct sandbox_cfg_elem *return_value_new_element2_1;
  return_value_new_element2_1=new_element2(syscall, value, (char *)(void *)0);
  return return_value_new_element2_1;
}

// new_element2
// file ../src/common/sandbox.c line 1183
static struct sandbox_cfg_elem * new_element2(signed int syscall, char *value, char *value2)
{
  struct smp_param *param = (struct smp_param *)(void *)0;
  struct sandbox_cfg_elem *elem;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct sandbox_cfg_elem) /*24ul*/ );
  elem = (struct sandbox_cfg_elem *)return_value_tor_malloc_zero__1;
  void *return_value_tor_malloc_zero__2;
  return_value_tor_malloc_zero__2=tor_malloc_zero_(sizeof(struct smp_param) /*32ul*/ );
  elem->param = (struct smp_param *)return_value_tor_malloc_zero__2;
  param = elem->param;
  param->syscall = syscall;
  param->value = value;
  param->value2 = value2;
  param->prot = 0;
  return elem;
}

// notify_pending_waitpid_callbacks
// file ../src/common/util_process.c line 144
void notify_pending_waitpid_callbacks(void)
{
  signed int child;
  signed int status = 0;
  do
  {
    child=waitpid(-1, &status, 1);
    if(!(child >= 1))
      break;

    notify_waitpid_callback_by_pid(child, status);
    status = 0;
  }
  while((_Bool)1);
}

// notify_waitpid_callback_by_pid
// file ../src/common/util_process.c line 122
static void notify_waitpid_callback_by_pid(signed int pid, signed int status)
{
  struct waitpid_callback_t search;
  struct waitpid_callback_t *ent;
  search.pid = pid;
  ent=process_map_HT_REMOVE(&process_map, &search);
  _Bool tmp_if_expr_1;
  if(ent == ((struct waitpid_callback_t *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(ent->running != 0u) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    log_fn_(6, 1u << 0, "notify_waitpid_callback_by_pid", "Child process %u has exited; no callback was registered", (unsigned int)pid);

  else
  {
    log_fn_(6, 1u << 0, "notify_waitpid_callback_by_pid", "Child process %u has exited; running callback.", (unsigned int)pid);
    ent->running = (unsigned int)0;
    ent->userfn(status, ent->userdata);
  }
}

// onion_warning
// file ../src/tools/tor-resolve.c line 112
static void onion_warning(const char *hostname)
{
  log_fn_(4, 1u << 2, "onion_warning", "%s is a hidden service; those don't have IP addresses. You can use the AutomapHostsOnResolve option to have Tor return a fake address for hidden services.  Or you can have your application send the address to Tor directly; we recommend an application that uses SOCKS 5 with hostnames.", hostname);
}

// open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open(const char *__path, signed int __oflag, ...)
{
  signed int return_value___builtin_va_arg_pack_len_1;
  return_value___builtin_va_arg_pack_len_1=__builtin_va_arg_pack_len();
  if(return_value___builtin_va_arg_pack_len_1 >= 2)
    __open_too_many_args();

  signed int return_value___builtin_va_arg_pack_len_3;
  signed int return_value___builtin_va_arg_pack_len_7;
  return_value___builtin_va_arg_pack_len_7=__builtin_va_arg_pack_len();
  signed int return_value___open_2_6;
  if(!(return_value___builtin_va_arg_pack_len_7 >= 1))
  {
    return_value___open_2_6=__open_2(__path, __oflag);
    return return_value___open_2_6;
  }

  else
  {
    void *return_value___builtin_va_arg_pack_8;
    return_value___builtin_va_arg_pack_8=__builtin_va_arg_pack();
    signed int return_value___open_alias_9;
    return_value___open_alias_9=__open_alias(__path, __oflag, return_value___builtin_va_arg_pack_8);
    return return_value___open_alias_9;
  }
}

// open_link1
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open_link1(const char *__path_link1, signed int __oflag_link1, ...)
{
  signed int return_value___builtin_va_arg_pack_len_1_link1;
  return_value___builtin_va_arg_pack_len_1_link1=__builtin_va_arg_pack_len();
  if(return_value___builtin_va_arg_pack_len_1_link1 >= 2)
    __open_too_many_args();

  signed int return_value___builtin_va_arg_pack_len_3_link1;
  signed int return_value___builtin_va_arg_pack_len_7_link1;
  return_value___builtin_va_arg_pack_len_7_link1=__builtin_va_arg_pack_len();
  signed int return_value___open_2_6_link1;
  if(!(return_value___builtin_va_arg_pack_len_7_link1 >= 1))
  {
    return_value___open_2_6_link1=__open_2(__path_link1, __oflag_link1);
    return return_value___open_2_6_link1;
  }

  else
  {
    void *return_value___builtin_va_arg_pack_8_link1;
    return_value___builtin_va_arg_pack_8_link1=__builtin_va_arg_pack();
    signed int return_value___open_alias_9_link1;
    return_value___open_alias_9_link1=__open_alias(__path_link1, __oflag_link1, return_value___builtin_va_arg_pack_8_link1);
    return return_value___open_alias_9_link1;
  }
}

// parse_config_line_from_str_verbose
// file ../src/common/util.c line 2822
const char * parse_config_line_from_str_verbose(const char *line, char **key_out, char **value_out, const char **err_out)
{
  const char *key;
  const char *val;
  const char *cp;
  signed int continuation = 0;
  if(key_out == ((char **)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2861, "parse_config_line_from_str_verbose", "key_out");
    abort();
  }

  if(value_out == ((char **)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2862, "parse_config_line_from_str_verbose", "value_out");
    abort();
  }

  *value_out = (char *)(void *)0;
  *key_out = *value_out;
  val = (const char *)(void *)0;
  key = val;
  signed int return_value_TOR_ISSPACE_1;
  while((_Bool)1)
  {
    do
    {
      return_value_TOR_ISSPACE_1=TOR_ISSPACE_link1(*line);
      if(return_value_TOR_ISSPACE_1 == 0)
        break;

      line = line + 1l;
    }
    while((_Bool)1);
    if((signed int)*line == 35)
      for( ; !(*line == 0); line = line + 1l)
        if((signed int)*line == 10)
          break;


    else
      break;
  }
  signed int return_value_TOR_ISSPACE_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  const char *tmp_post_5;
  signed int return_value_TOR_ISSPACE_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_10;
  char *tmp_post_8;
  char *tmp_post_9;
  _Bool tmp_if_expr_11;
  signed int return_value_TOR_ISSPACE_12;
  if(*line == 0)
  {
    *value_out = (char *)(void *)0;
    *key_out = *value_out;
    return line;
  }

  else
  {
    key = line;
    for( ; !(*line == 0); line = line + 1l)
    {
      return_value_TOR_ISSPACE_2=TOR_ISSPACE_link1(*line);
      if(!(return_value_TOR_ISSPACE_2 == 0))
        break;

      if((signed int)*line == 35)
        break;

      if((signed int)*line == 92)
      {
        if((signed int)line[1l] == 10)
          break;

      }

    }
    *key_out=tor_strndup_(key, (unsigned long int)(line - key));
    for( ; (_Bool)1; line = line + 1l)
      if(!((signed int)*line == 32))
      {
        if(!((signed int)*line == 9))
          goto __CPROVER_DUMP_L17;

      }


  __CPROVER_DUMP_L17:
    ;
    val = line;
    if((signed int)*line == 34)
    {
      line=unescape_string(line, value_out, (unsigned long int *)(void *)0);
      if(line == ((const char *)NULL))
      {
        if(!(err_out == ((const char **)NULL)))
          *err_out = "Invalid escape sequence in quoted string";

        return (const char *)(void *)0;
      }

      for( ; (_Bool)1; line = line + 1l)
        if(!((signed int)*line == 32))
        {
          if(!((signed int)*line == 9))
            goto __CPROVER_DUMP_L21;

        }


    __CPROVER_DUMP_L21:
      ;
      if(!(*line == 0))
      {
        if(!((signed int)*line == 35))
        {
          if(!((signed int)*line == 10))
          {
            if(!(err_out == ((const char **)NULL)))
              *err_out = "Excess data after quoted string";

            return (const char *)(void *)0;
          }

        }

      }

    }

    else
    {
      while(!(*line == 0))
      {
        if((signed int)*line == 10)
          break;

        if((signed int)*line == 35)
        {
          if(continuation == 0)
            break;

        }

        if((signed int)*line == 92)
          tmp_if_expr_4 = (signed int)line[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          continuation = 1;
          line = line + (signed long int)2;
        }

        else
          if((signed int)*line == 35)
          {
            do
            {
              line = line + 1l;
              if(!(*line == 0))
                tmp_if_expr_3 = (signed int)*line != 10 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
            }
            while(tmp_if_expr_3);
            if((signed int)*line == 10)
              line = line + 1l;

          }

          else
            line = line + 1l;
      }
      if((signed int)*line == 10)
      {
        tmp_post_5 = line;
        line = line + 1l;
        cp = tmp_post_5;
      }

      else
        cp = line;
      for( ; !(val >= cp); cp = cp - 1l)
      {
        return_value_TOR_ISSPACE_6=TOR_ISSPACE_link1(*(cp - (signed long int)1));
        if(return_value_TOR_ISSPACE_6 == 0)
          break;

      }
      if(!(cp >= val))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)2936, "parse_config_line_from_str_verbose", "cp >= val");
        abort();
      }

      *value_out=tor_strndup_(val, (unsigned long int)(cp - val));
      if(!(continuation == 0))
      {
        char *v_out;
        char *v_in = *value_out;
        v_out = v_in;
        while(!(*v_in == 0))
          if((signed int)*v_in == 35)
          {
            do
            {
              v_in = v_in + 1l;
              if(!(*v_in == 0))
                tmp_if_expr_7 = (signed int)*v_in != 10 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_7 = (_Bool)0;
            }
            while(tmp_if_expr_7);
            if((signed int)*v_in == 10)
              v_in = v_in + 1l;

          }

          else
          {
            if((signed int)*v_in == 92)
              tmp_if_expr_10 = (signed int)v_in[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_10 = (_Bool)0;
            if(tmp_if_expr_10)
              v_in = v_in + (signed long int)2;

            else
            {
              tmp_post_8 = v_out;
              v_out = v_out + 1l;
              tmp_post_9 = v_in;
              v_in = v_in + 1l;
              *tmp_post_8 = *tmp_post_9;
            }
          }
        *v_out = (char)0;
      }

    }
    if((signed int)*line == 35)
      do
      {
        line = line + 1l;
        if(!(*line == 0))
          tmp_if_expr_11 = (signed int)*line != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
      }
      while(tmp_if_expr_11);

    do
    {
      return_value_TOR_ISSPACE_12=TOR_ISSPACE_link1(*line);
      if(return_value_TOR_ISSPACE_12 == 0)
        break;

      line = line + 1l;
    }
    while((_Bool)1);
    return line;
  }
}

// parse_http_time
// file ../src/common/util.c line 1784
signed int parse_http_time(const char *date, struct tm *tm)
{
  const char *cp;
  char month[4l];
  char wkday[4l];
  signed int i;
  unsigned int tm_mday;
  unsigned int tm_year;
  unsigned int tm_hour;
  unsigned int tm_min;
  unsigned int tm_sec;
  if(tm == ((struct tm *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1792, "parse_http_time", "tm");
    abort();
  }

  memset_link7((void *)tm, 0, sizeof(struct tm) /*56ul*/ );
  char *return_value___builtin_strchr_4;
  return_value___builtin_strchr_4=__builtin_strchr(date, 44);
  cp = return_value___builtin_strchr_4;
  signed int return_value_tor_sscanf_1;
  if(!(cp == ((const char *)NULL)))
  {
    cp = cp + 1l;
    if(!((signed int)*cp == 32))
      return -1;

    cp = cp + 1l;
    signed int return_value_tor_sscanf_2;
    return_value_tor_sscanf_2=tor_sscanf(cp, "%2u %3s %4u %2u:%2u:%2u GMT", &tm_mday, (const void *)month, &tm_year, &tm_hour, &tm_min, &tm_sec);
    if(return_value_tor_sscanf_2 == 6)
      tm_year = tm_year - (unsigned int)1900;

    else
    {
      return_value_tor_sscanf_1=tor_sscanf(cp, "%2u-%3s-%2u %2u:%2u:%2u GMT", &tm_mday, (const void *)month, &tm_year, &tm_hour, &tm_min, &tm_sec);
      if(!(return_value_tor_sscanf_1 == 6))
        return -1;

    }
  }

  else
  {
    signed int return_value_tor_sscanf_3;
    return_value_tor_sscanf_3=tor_sscanf(date, "%3s %3s %2u %2u:%2u:%2u %4u", (const void *)wkday, (const void *)month, &tm_mday, &tm_hour, &tm_min, &tm_sec, &tm_year);
    if(return_value_tor_sscanf_3 == 7)
      tm_year = tm_year - (unsigned int)1900;

    else
      return -1;
  }
  tm->tm_mday = (signed int)tm_mday;
  tm->tm_year = (signed int)tm_year;
  tm->tm_hour = (signed int)tm_hour;
  tm->tm_min = (signed int)tm_min;
  tm->tm_sec = (signed int)tm_sec;
  month[(signed long int)3] = (char)0;
  tm->tm_mon = -1;
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    signed int return_value_strcasecmp_5;
    return_value_strcasecmp_5=strcasecmp(MONTH_NAMES[(signed long int)i], month);
    if(return_value_strcasecmp_5 == 0)
      tm->tm_mon = i;

  }
  _Bool tmp_if_expr_6;
  if(!(tm->tm_year >= 0))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = tm->tm_mon < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = tm->tm_mon > 11 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = (_Bool)1;

  else
    tmp_if_expr_8 = tm->tm_mday < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_8)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = tm->tm_mday > 31 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  if(tmp_if_expr_9)
    tmp_if_expr_10 = (_Bool)1;

  else
    tmp_if_expr_10 = tm->tm_hour < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_11;
  if(tmp_if_expr_10)
    tmp_if_expr_11 = (_Bool)1;

  else
    tmp_if_expr_11 = tm->tm_hour > 23 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_11)
    tmp_if_expr_12 = (_Bool)1;

  else
    tmp_if_expr_12 = tm->tm_min < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_13;
  if(tmp_if_expr_12)
    tmp_if_expr_13 = (_Bool)1;

  else
    tmp_if_expr_13 = tm->tm_min > 59 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_14;
  if(tmp_if_expr_13)
    tmp_if_expr_14 = (_Bool)1;

  else
    tmp_if_expr_14 = tm->tm_sec < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_15;
  if(tmp_if_expr_14)
    tmp_if_expr_15 = (_Bool)1;

  else
    tmp_if_expr_15 = tm->tm_sec > 60 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_15)
    return -1;

  else
    return 0;
}

// parse_iso_time
// file ../src/common/util.c line 1776
signed int parse_iso_time(const char *cp, signed long int *t)
{
  signed int return_value_parse_iso_time__1;
  return_value_parse_iso_time__1=parse_iso_time_(cp, t, 1);
  return return_value_parse_iso_time__1;
}

// parse_iso_time_
// file ../src/common/util.c line 1734
signed int parse_iso_time_(const char *cp, signed long int *t, signed int strict)
{
  struct tm st_tm;
  unsigned int year = (unsigned int)0;
  unsigned int month = (unsigned int)0;
  unsigned int day = (unsigned int)0;
  unsigned int hour = (unsigned int)0;
  unsigned int minute = (unsigned int)0;
  unsigned int second = (unsigned int)0;
  signed int n_fields;
  char extra_char;
  n_fields=tor_sscanf(cp, "%u-%2u-%2u %2u:%2u:%2u%c", &year, &month, &day, &hour, &minute, &second, &extra_char);
  if(strict == 0 ? !(n_fields >= 6) : !(n_fields == 6))
  {
    char *esc;
    esc=esc_for_log(cp);
    log_fn_(4, 1u << 0, "parse_iso_time_", "ISO time %s was unparseable", esc);
    if(!(esc == ((char *)NULL)))
    {
      free((void *)esc);
      esc = (char *)(void *)0;
    }

    return -1;
  }

  if(day >= 32u || hour >= 24u || minute >= 60u || month >= 13u || second >= 61u || year >= 2147483647u || !(day >= 1u) || !(month >= 1u) || !(year >= 1970u))
  {
    char *parse_iso_time___1__2__esc;
    parse_iso_time___1__2__esc=esc_for_log(cp);
    log_fn_(4, 1u << 0, "parse_iso_time_", "ISO time %s was nonsensical", parse_iso_time___1__2__esc);
    if(!(parse_iso_time___1__2__esc == ((char *)NULL)))
    {
      free((void *)parse_iso_time___1__2__esc);
      parse_iso_time___1__2__esc = (char *)(void *)0;
    }

    return -1;
  }

  st_tm.tm_year = (signed int)year - 1900;
  st_tm.tm_mon = (signed int)(month - (unsigned int)1);
  st_tm.tm_mday = (signed int)day;
  st_tm.tm_hour = (signed int)hour;
  st_tm.tm_min = (signed int)minute;
  st_tm.tm_sec = (signed int)second;
  if(!(st_tm.tm_year >= 70))
  {
    char *parse_iso_time___1__3__esc;
    parse_iso_time___1__3__esc=esc_for_log(cp);
    log_fn_(4, 1u << 0, "parse_iso_time_", "Got invalid ISO time %s. (Before 1970)", parse_iso_time___1__3__esc);
    if(!(parse_iso_time___1__3__esc == ((char *)NULL)))
    {
      free((void *)parse_iso_time___1__3__esc);
      parse_iso_time___1__3__esc = (char *)(void *)0;
    }

    return -1;
  }

  signed int return_value_tor_timegm_1;
  return_value_tor_timegm_1=tor_timegm(&st_tm, t);
  return return_value_tor_timegm_1;
}

// parse_log_domain
// file ../src/common/log.c line 1231
static unsigned int parse_log_domain(const char *domain)
{
  signed int i = 0;
  for( ; !(domain_list[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(domain, domain_list[(signed long int)i]);
    if(return_value_strcasecmp_1 == 0)
      return 1u << i;

  }
  return (unsigned int)0;
}

// parse_log_level
// file ../src/common/log.c line 1197
signed int parse_log_level(const char *level)
{
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(level, "err");
  if(return_value_strcasecmp_1 == 0)
    return 3;

  else
  {
    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp(level, "warn");
    if(return_value_strcasecmp_2 == 0)
      return 4;

    else
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(level, "notice");
      if(return_value_strcasecmp_3 == 0)
        return 5;

      else
      {
        signed int return_value_strcasecmp_4;
        return_value_strcasecmp_4=strcasecmp(level, "info");
        if(return_value_strcasecmp_4 == 0)
          return 6;

        else
        {
          signed int return_value_strcasecmp_5;
          return_value_strcasecmp_5=strcasecmp(level, "debug");
          if(return_value_strcasecmp_5 == 0)
            return 7;

          else
            return -1;
        }
      }
    }
  }
}

// parse_log_severity_config
// file ../src/common/log.c line 1295
signed int parse_log_severity_config(const char **cfg_ptr, struct log_severity_list_t *severity_out)
{
  const char *cfg = *cfg_ptr;
  signed int got_anything = 0;
  signed int got_an_unqualified_range = 0;
  memset_link5((void *)severity_out, 0, sizeof(struct log_severity_list_t) /*20ul*/ );
  cfg=eat_whitespace(cfg);
  signed int tmp_statement_expression_3;
  _Bool tmp_if_expr_7;
  signed int return_value_strcasecmpstart_6;
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmpstart_8;
  _Bool tmp_if_expr_11;
  signed int return_value_strcasecmpstart_10;
  void *return_value___rawmemchr_14;
  while(!(*cfg == 0))
  {
    const char *dash;
    const char *space;
    char *sev_lo;
    char *sev_hi;
    signed int low;
    signed int high;
    signed int i;
    unsigned int domains = ~0u;
    if((signed int)*cfg == 91)
    {
      signed int err = 0;
      char *domains_str;
      struct smartlist_t *domains_list;
      unsigned int neg_domains = (unsigned int)0;
      const char *closebracket;
      char *return_value___builtin_strchr_1;
      return_value___builtin_strchr_1=__builtin_strchr(cfg, 93);
      closebracket = return_value___builtin_strchr_1;
      if(closebracket == ((const char *)NULL))
        return -1;

      domains = (unsigned int)0;
      domains_str=tor_strndup_(cfg + (signed long int)1, (unsigned long int)((closebracket - cfg) - (signed long int)1));
      domains_list=smartlist_new();
      smartlist_split_string(domains_list, domains_str, ",", 0x01, -1);
      if(!(domains_str == ((char *)NULL)))
      {
        free((void *)domains_str);
        domains_str = (char *)(void *)0;
      }

      signed int domain_sl_idx;
      signed int domain_sl_len = domains_list->num_used;
      const char *domain;
      domain_sl_idx = 0;
      for( ; !(domain_sl_idx >= domain_sl_len); domain_sl_idx = domain_sl_idx + 1)
      {
        domain = (const char *)domains_list->list[(signed long int)domain_sl_idx];
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_4;
        return_value___builtin_strcmp_4=__builtin_strcmp(domain, "*");
        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
        if(tmp_statement_expression_3 == 0)
          domains = ~0u;

        else
        {
          signed int parse_log_severity_config__1__1__1__2__1__1__3__d;
          signed int negate = 0;
          if((signed int)*domain == 126)
          {
            negate = 1;
            domain = domain + 1l;
          }

          unsigned int return_value_parse_log_domain_2;
          return_value_parse_log_domain_2=parse_log_domain(domain);
          parse_log_severity_config__1__1__1__2__1__1__3__d = (signed int)return_value_parse_log_domain_2;
          if(parse_log_severity_config__1__1__1__2__1__1__3__d == 0)
          {
            log_fn_(4, 1u << 3, "parse_log_severity_config", "No such logging domain as %s", domain);
            err = 1;
          }

          else
            if(!(negate == 0))
              neg_domains = neg_domains | (unsigned int)parse_log_severity_config__1__1__1__2__1__1__3__d;

            else
              domains = domains | (unsigned int)parse_log_severity_config__1__1__1__2__1__1__3__d;
        }
        domain = (const char *)(void *)0;
      }
      signed int d_sl_idx;
      signed int d_sl_len = domains_list->num_used;
      char *d;
      d_sl_idx = 0;
      for( ; !(d_sl_idx >= d_sl_len); d_sl_idx = d_sl_idx + 1)
      {
        d = (char *)domains_list->list[(signed long int)d_sl_idx];
        if(!(d == ((char *)NULL)))
        {
          free((void *)d);
          d = (char *)(void *)0;
        }

        d = (char *)(void *)0;
      }
      smartlist_free(domains_list);
      if(!(err == 0))
        return -1;

      if(domains == 0u && !(neg_domains == 0u))
        domains = ~neg_domains;

      else
        domains = domains & ~neg_domains;
      cfg=eat_whitespace(closebracket + (signed long int)1);
    }

    else
      got_an_unqualified_range = got_an_unqualified_range + 1;
    signed int return_value_strcasecmpstart_5;
    return_value_strcasecmpstart_5=strcasecmpstart(cfg, "file");
    if(return_value_strcasecmpstart_5 == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strcasecmpstart_6=strcasecmpstart(cfg, "stderr");
      tmp_if_expr_7 = !(return_value_strcasecmpstart_6 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcasecmpstart_8=strcasecmpstart(cfg, "stdout");
      tmp_if_expr_9 = !(return_value_strcasecmpstart_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcasecmpstart_10=strcasecmpstart(cfg, "syslog");
      tmp_if_expr_11 = !(return_value_strcasecmpstart_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      break;

    if(got_an_unqualified_range >= 2)
      return -1;

    char *return_value___builtin_strchr_12;
    return_value___builtin_strchr_12=__builtin_strchr(cfg, 32);
    space = return_value___builtin_strchr_12;
    char *return_value___builtin_strchr_13;
    return_value___builtin_strchr_13=__builtin_strchr(cfg, 45);
    dash = return_value___builtin_strchr_13;
    if(space == ((const char *)NULL))
    {
      return_value___rawmemchr_14=__rawmemchr((const void *)cfg, 0);
      space = (char *)return_value___rawmemchr_14;
    }

    if(!(dash == ((const char *)NULL)) && !(dash >= space))
    {
      sev_lo=tor_strndup_(cfg, (unsigned long int)(dash - cfg));
      sev_hi=tor_strndup_(dash + (signed long int)1, (unsigned long int)(space - (dash + (signed long int)1)));
    }

    else
    {
      sev_lo=tor_strndup_(cfg, (unsigned long int)(space - cfg));
      sev_hi=tor_strdup_("ERR");
    }
    low=parse_log_level(sev_lo);
    high=parse_log_level(sev_hi);
    if(!(sev_lo == ((char *)NULL)))
    {
      free((void *)sev_lo);
      sev_lo = (char *)(void *)0;
    }

    if(!(sev_hi == ((char *)NULL)))
    {
      free((void *)sev_hi);
      sev_hi = (char *)(void *)0;
    }

    if(low == -1)
      return -1;

    if(high == -1)
      return -1;

    got_anything = 1;
    i = low;
    for( ; i >= high; i = i - 1)
      severity_out->masks[(signed long int)(i - 3)] = severity_out->masks[(signed long int)(i - 3)] | domains;
    cfg=eat_whitespace(space);
  }

done:
  ;
  *cfg_ptr = cfg;
  return got_anything != 0 ? 0 : -1;
}

// parse_port_range
// file ../src/common/address.c line 1758
signed int parse_port_range(const char *port, unsigned short int *port_min_out, unsigned short int *port_max_out)
{
  signed int port_min;
  signed int port_max;
  signed int ok;
  if(port_min_out == ((unsigned short int *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1762, "parse_port_range", "port_min_out");
    abort();
  }

  if(port_max_out == ((unsigned short int *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1763, "parse_port_range", "port_max_out");
    abort();
  }

  _Bool tmp_if_expr_6;
  if(port == ((const char *)NULL))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)*port == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_9;
  signed int tmp_statement_expression_7;
  if(tmp_if_expr_6)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_8;
    return_value___builtin_strcmp_8=__builtin_strcmp(port, "*");
    tmp_statement_expression_7 = return_value___builtin_strcmp_8;
    tmp_if_expr_9 = tmp_statement_expression_7 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_9)
  {
    port_min = 1;
    port_max = 65535;
  }

  else
  {
    char *endptr = (char *)(void *)0;
    signed long int return_value_tor_parse_long_1;
    return_value_tor_parse_long_1=tor_parse_long(port, 10, (signed long int)0, (signed long int)65535, &ok, &endptr);
    port_min = (signed int)return_value_tor_parse_long_1;
    if(ok == 0)
    {
      const char *return_value_escaped_2;
      return_value_escaped_2=escaped(port);
      log_fn_(4, 1u << 0, "parse_port_range", "Malformed port %s on address range; rejecting.", return_value_escaped_2);
      return -1;
    }

    else
    {
      if(!(endptr == ((char *)NULL)))
        tmp_if_expr_5 = (signed int)*endptr == 45 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        port = endptr + (signed long int)1;
        endptr = (char *)(void *)0;
        signed long int return_value_tor_parse_long_3;
        return_value_tor_parse_long_3=tor_parse_long(port, 10, (signed long int)1, (signed long int)65535, &ok, &endptr);
        port_max = (signed int)return_value_tor_parse_long_3;
        if(ok == 0)
        {
          const char *return_value_escaped_4;
          return_value_escaped_4=escaped(port);
          log_fn_(4, 1u << 0, "parse_port_range", "Malformed port %s on address range; rejecting.", return_value_escaped_4);
          return -1;
        }

      }

      else
        port_max = port_min;
    }
    if(!(port_max >= port_min))
    {
      log_fn_(4, 1u << 0, "parse_port_range", "Insane port range on address policy; rejecting.");
      return -1;
    }

  }
  if(!(port_min >= 1))
    port_min = 1;

  if(port_max >= 65536)
    port_max = 65535;

  *port_min_out = (unsigned short int)port_min;
  *port_max_out = (unsigned short int)port_max;
  return 0;
}

// parse_rfc1123_time
// file ../src/common/util.c line 1619
signed int parse_rfc1123_time(const char *buf, signed long int *t)
{
  struct tm tm;
  char month[4l];
  char weekday[4l];
  signed int i;
  signed int m;
  signed int invalid_year;
  unsigned int tm_mday;
  unsigned int tm_year;
  unsigned int tm_hour;
  unsigned int tm_min;
  unsigned int tm_sec;
  unsigned int dpm;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  signed int tmp_statement_expression_3;
  if(!(return_value_strlen_1 == 29ul))
    return -1;

  else
  {
    memset_link7((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
    signed int return_value_tor_sscanf_2;
    return_value_tor_sscanf_2=tor_sscanf(buf, "%3s, %2u %3s %u %2u:%2u:%2u GMT", (const void *)weekday, &tm_mday, (const void *)month, &tm_year, &tm_hour, &tm_min, &tm_sec);
    if(!(return_value_tor_sscanf_2 >= 7))
    {
      char *parse_rfc1123_time__1__1__esc;
      parse_rfc1123_time__1__1__esc=esc_for_log(buf);
      log_fn_(4, 1u << 0, "parse_rfc1123_time", "Got invalid RFC1123 time %s", parse_rfc1123_time__1__1__esc);
      if(!(parse_rfc1123_time__1__1__esc == ((char *)NULL)))
      {
        free((void *)parse_rfc1123_time__1__1__esc);
        parse_rfc1123_time__1__1__esc = (char *)(void *)0;
      }

      return -1;
    }

    m = -1;
    i = 0;
    for( ; !(i >= 12); i = i + 1)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_4;
      return_value___builtin_strcmp_4=__builtin_strcmp(month, MONTH_NAMES[(signed long int)i]);
      tmp_statement_expression_3 = return_value___builtin_strcmp_4;
      if(tmp_statement_expression_3 == 0)
      {
        m = i;
        break;
      }

    }
    if(!(m >= 0))
    {
      char *esc;
      esc=esc_for_log(buf);
      log_fn_(4, 1u << 0, "parse_rfc1123_time", "Got invalid RFC1123 time %s: No such month", esc);
      if(!(esc == ((char *)NULL)))
      {
        free((void *)esc);
        esc = (char *)(void *)0;
      }

      return -1;
    }

    tm.tm_mon = m;
    invalid_year = (signed int)(tm_year >= (unsigned int)2147483647 || tm_year < (unsigned int)1970);
    if(!(m >= 0) || m >= 12)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)1656, "parse_rfc1123_time", "m >= 0 && m <= 11");
      abort();
    }

    dpm = (unsigned int)days_per_month[(signed long int)m];
    if(tm_year % 4u == 0u && invalid_year == 0 && m == 1 && (tm_year % 400u == 0u || !(tm_year % 100u == 0u)))
      dpm = (unsigned int)29;

    if(tm_hour >= 24u || tm_min >= 60u || tm_sec >= 61u || !(invalid_year == 0) || !(dpm >= tm_mday) || !(tm_mday >= 1u))
    {
      char *parse_rfc1123_time__1__6__esc;
      parse_rfc1123_time__1__6__esc=esc_for_log(buf);
      log_fn_(4, 1u << 0, "parse_rfc1123_time", "Got invalid RFC1123 time %s", parse_rfc1123_time__1__6__esc);
      if(!(parse_rfc1123_time__1__6__esc == ((char *)NULL)))
      {
        free((void *)parse_rfc1123_time__1__6__esc);
        parse_rfc1123_time__1__6__esc = (char *)(void *)0;
      }

      return -1;
    }

    tm.tm_mday = (signed int)tm_mday;
    tm.tm_year = (signed int)tm_year;
    tm.tm_hour = (signed int)tm_hour;
    tm.tm_min = (signed int)tm_min;
    tm.tm_sec = (signed int)tm_sec;
    if(!(tm.tm_year >= 1970))
    {
      char *parse_rfc1123_time__1__7__esc;
      parse_rfc1123_time__1__7__esc=esc_for_log(buf);
      log_fn_(4, 1u << 0, "parse_rfc1123_time", "Got invalid RFC1123 time %s. (Before 1970)", parse_rfc1123_time__1__7__esc);
      if(!(parse_rfc1123_time__1__7__esc == ((char *)NULL)))
      {
        free((void *)parse_rfc1123_time__1__7__esc);
        parse_rfc1123_time__1__7__esc = (char *)(void *)0;
      }

      return -1;
    }

    tm.tm_year = tm.tm_year - 1900;
    signed int return_value_tor_timegm_5;
    return_value_tor_timegm_5=tor_timegm(&tm, t);
    return return_value_tor_timegm_5;
  }
}

// parse_socks4a_resolve_response
// file ../src/tools/tor-resolve.c line 128
static signed int parse_socks4a_resolve_response(const char *hostname, const char *response, unsigned long int len, struct tor_addr_t *addr_out)
{
  unsigned char status;
  if(response == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)133, "parse_socks4a_resolve_response", "response");
    abort();
  }

  if(addr_out == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/tools/tor-resolve.c", (unsigned int)134, "parse_socks4a_resolve_response", "addr_out");
    abort();
  }

  if(!(len >= 8ul))
  {
    log_fn_(4, 1u << 5, "parse_socks4a_resolve_response", "Truncated socks response.");
    return -1;
  }

  else
    if(!((signed int)(unsigned char)*response == 0))
    {
      log_fn_(4, 1u << 5, "parse_socks4a_resolve_response", "Nonzero version in socks response: bad format.");
      return -1;
    }

    else
    {
      status = (unsigned char)response[(signed long int)1];
      unsigned short int return_value_get_uint16_1;
      return_value_get_uint16_1=get_uint16((const void *)(response + (signed long int)2));
      if(!((signed int)return_value_get_uint16_1 == 0))
      {
        log_fn_(4, 1u << 5, "parse_socks4a_resolve_response", "Nonzero port in socks response: bad format.");
        return -1;
      }

      else
      {
        if(!((signed int)status == 90))
        {
          log_fn_(4, 1u << 2, "parse_socks4a_resolve_response", "Got status response '%d': socks request failed.", status);
          signed int return_value_strcasecmpend_2;
          return_value_strcasecmpend_2=strcasecmpend(hostname, ".onion");
          if(return_value_strcasecmpend_2 == 0)
          {
            onion_warning(hostname);
            return -1;
          }

          return -1;
        }

        unsigned int return_value_get_uint32_3;
        return_value_get_uint32_3=get_uint32((const void *)(response + (signed long int)4));
        tor_addr_from_ipv4n(addr_out, return_value_get_uint32_3);
        return 0;
      }
    }
}

// path_is_relative
// file ../src/common/util.c line 3417
signed int path_is_relative(const char *filename)
{
  _Bool tmp_if_expr_1;
  if(!(filename == ((const char *)NULL)))
    tmp_if_expr_1 = (signed int)filename[(signed long int)0] == 47 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
    return 1;
}

// pending_log_message_free
// file ../src/common/log.c line 365
static void pending_log_message_free(struct pending_log_message_t *msg)
{
  if(!(msg == ((struct pending_log_message_t *)NULL)))
  {
    if(!(msg->msg == ((char *)NULL)))
    {
      free((void *)msg->msg);
      msg->msg = (char *)(void *)0;
    }

    if(!(msg->fullmsg == ((char *)NULL)))
    {
      free((void *)msg->fullmsg);
      msg->fullmsg = (char *)(void *)0;
    }

    if(!(msg == ((struct pending_log_message_t *)NULL)))
    {
      free((void *)msg);
      msg = (struct pending_log_message_t *)(void *)0;
    }

  }

}

// pending_log_message_new
// file ../src/common/log.c line 352
static struct pending_log_message_t * pending_log_message_new(signed int severity, unsigned int domain, const char *fullmsg, const char *shortmsg)
{
  struct pending_log_message_t *m;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct pending_log_message_t) /*24ul*/ );
  m = (struct pending_log_message_t *)return_value_tor_malloc__1;
  m->severity = severity;
  m->domain = domain;
  char *tmp_if_expr_3;
  char *return_value_tor_strdup__2;
  if(!(fullmsg == ((const char *)NULL)))
  {
    return_value_tor_strdup__2=tor_strdup_(fullmsg);
    tmp_if_expr_3 = return_value_tor_strdup__2;
  }

  else
    tmp_if_expr_3 = (char *)(void *)0;
  m->fullmsg = tmp_if_expr_3;
  m->msg=tor_strdup_(shortmsg);
  return m;
}

// pipe_alert
// file ../src/common/compat_threads.c line 161
static signed int pipe_alert(signed int fd)
{
  signed long int r;
  signed int return_value_write_ni_1;
  return_value_write_ni_1=write_ni(fd, (const void *)"x", (unsigned long int)1);
  r = (signed long int)return_value_write_ni_1;
  signed int *return_value___errno_location_2;
  if(!(r >= 0l))
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 11)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// pipe_drain
// file ../src/common/compat_threads.c line 170
static signed int pipe_drain(signed int fd)
{
  char buf[32l];
  signed long int r;
  do
  {
    signed int return_value_read_ni_1;
    return_value_read_ni_1=read_ni(fd, (void *)buf, sizeof(char [32l]) /*32ul*/ );
    r = (signed long int)return_value_read_ni_1;
  }
  while(r >= 1l);
  signed int *return_value___errno_location_2;
  if(!(r >= 0l))
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 11)
      goto __CPROVER_DUMP_L2;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return 0;
  }
}

// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  signed int return_value___printf_chk_2;
  return_value___printf_chk_2=__printf_chk(2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
  return return_value___printf_chk_2;
}

// process_environment_free
// file ../src/common/util.c line 4489
void process_environment_free(struct process_environment_t *env)
{
  if(!(env == ((struct process_environment_t *)NULL)))
  {
    if(!(env->unixoid_environment_block == ((char **)NULL)))
    {
      free((void *)env->unixoid_environment_block);
      env->unixoid_environment_block = (char **)(void *)0;
    }

    if(!(env->windows_environment_block == ((char *)NULL)))
    {
      free((void *)env->windows_environment_block);
      env->windows_environment_block = (char *)(void *)0;
    }

    if(!(env == ((struct process_environment_t *)NULL)))
    {
      free((void *)env);
      env = (struct process_environment_t *)(void *)0;
    }

  }

}

// process_environment_make
// file ../src/common/util.c line 4508
struct process_environment_t * process_environment_make(struct smartlist_t *env_vars)
{
  struct process_environment_t *env;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct process_environment_t) /*16ul*/ );
  env = (struct process_environment_t *)return_value_tor_malloc_zero__1;
  unsigned long int n_env_vars = (unsigned long int)env_vars->num_used;
  unsigned long int i;
  unsigned long int total_env_length;
  struct smartlist_t *env_vars_sorted;
  if(n_env_vars == 18446744073709551615ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)4516, "process_environment_make", "n_env_vars + 1 != 0");
    abort();
  }

  void *return_value_tor_calloc__2;
  return_value_tor_calloc__2=tor_calloc_(n_env_vars + (unsigned long int)1, sizeof(char *) /*8ul*/ );
  env->unixoid_environment_block = (char **)return_value_tor_calloc__2;
  total_env_length = (unsigned long int)1;
  i = (unsigned long int)0;
  for( ; !(i >= n_env_vars); i = i + 1ul)
  {
    const char *s = (const char *)env_vars->list[(signed long int)i];
    unsigned long int slen;
    slen=strlen(s);
    if(slen == 18446744073709551615ul)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)4526, "process_environment_make", "slen + 1 != 0");
      abort();
    }

    if(1ul + slen >= 18446744073709551615UL + -total_env_length)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)4527, "process_environment_make", "slen + 1 < SIZE_MAX - total_env_length");
      abort();
    }

    total_env_length = total_env_length + slen + (unsigned long int)1;
  }
  void *return_value_tor_malloc_zero__3;
  return_value_tor_malloc_zero__3=tor_malloc_zero_(total_env_length);
  env->windows_environment_block = (char *)return_value_tor_malloc_zero__3;
  env_vars_sorted=smartlist_new();
  smartlist_add_all(env_vars_sorted, env_vars);
  smartlist_sort_strings(env_vars_sorted);
  char *cp = env->windows_environment_block;
  const char *prev_env_var = (const char *)(void *)0;
  i = (unsigned long int)0;
  signed int return_value_environment_variable_names_equal_4;
  for( ; !(i >= n_env_vars); i = i + 1ul)
  {
    const char *process_environment_make__1__3__1__s = (const char *)env_vars_sorted->list[(signed long int)i];
    unsigned long int process_environment_make__1__3__1__slen;
    process_environment_make__1__3__1__slen=strlen(process_environment_make__1__3__1__s);
    unsigned long int s_name_len;
    s_name_len=str_num_before(process_environment_make__1__3__1__s, (char)61);
    if(s_name_len == process_environment_make__1__3__1__slen)
      log_fn_(4, 1u << 0, "process_environment_make", "Preparing an environment containing a variable without a value: %s", process_environment_make__1__3__1__s);

    if(!(prev_env_var == ((const char *)NULL)))
    {
      return_value_environment_variable_names_equal_4=environment_variable_names_equal(process_environment_make__1__3__1__s, prev_env_var);
      if(!(return_value_environment_variable_names_equal_4 == 0))
        log_fn_(4, 1u << 0, "process_environment_make", "Preparing an environment containing two variables with the same name: %s and %s", prev_env_var, process_environment_make__1__3__1__s);

    }

    prev_env_var = process_environment_make__1__3__1__s;
    memcpy_link7((void *)cp, (const void *)process_environment_make__1__3__1__s, process_environment_make__1__3__1__slen + (unsigned long int)1);
    env->unixoid_environment_block[(signed long int)i] = cp;
    cp = cp + (signed long int)(process_environment_make__1__3__1__slen + (unsigned long int)1);
  }
  if(!(cp == env->windows_environment_block + (signed long int)total_env_length + -1l))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)4579, "process_environment_make", "cp == env->windows_environment_block + total_env_length - 1");
    abort();
  }

  smartlist_free(env_vars_sorted);
  return env;
}

// process_handle_new
// file ../src/common/util.c line 3947
static struct process_handle_t * process_handle_new(void)
{
  struct process_handle_t *out;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct process_handle_t) /*56ul*/ );
  out = (struct process_handle_t *)return_value_tor_malloc_zero__1;
  out->stdout_pipe = -1;
  out->stderr_pipe = -1;
  return out;
}

// process_handle_waitpid_cb
// file ../src/common/util.c line 3967
static void process_handle_waitpid_cb(signed int status, void *arg)
{
  struct process_handle_t *process_handle = (struct process_handle_t *)arg;
  process_handle->waitpid_exit_status = status;
  clear_waitpid_callback(process_handle->waitpid_cb);
  if(process_handle->status == 1)
    process_handle->status = 0;

  process_handle->waitpid_cb = ((struct waitpid_callback_t *)NULL);
}

// process_map_HT_CLEAR
// file ../src/common/util_process.c line 65
void process_map_HT_CLEAR(struct process_map *head)
{
  if(!(head->hth_table == ((struct waitpid_callback_t **)NULL)))
    tor_free_((void *)head->hth_table);

  head->hth_table_length = (unsigned int)0;
  process_map_HT_INIT(head);
}

// process_map_HT_FIND_P_
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t ** process_map_HT_FIND_P_(struct process_map *head, struct waitpid_callback_t *elm)
{
  struct waitpid_callback_t **p;
  if(head->hth_table == ((struct waitpid_callback_t **)NULL))
    return (struct waitpid_callback_t **)(void *)0;

  else
  {
    p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
    while(!(*p == ((struct waitpid_callback_t *)NULL)))
    {
      unsigned int return_value_process_map_entries_eq__1;
      return_value_process_map_entries_eq__1=process_map_entries_eq_(*p, elm);
      if(!(return_value_process_map_entries_eq__1 == 0u))
        return p;

      p = &(*p)->node.hte_next;
    }
    return p;
  }
}

// process_map_HT_GROW
// file ../src/common/util_process.c line 65
signed int process_map_HT_GROW(struct process_map *head, unsigned int size)
{
  unsigned int new_len;
  unsigned int new_load_limit;
  signed int prime_idx;
  struct waitpid_callback_t **new_table;
  if(head->hth_prime_idx == (signed int)process_map_N_PRIMES + -1)
    return 0;

  else
    if(!(size >= head->hth_load_limit))
      return 0;

    else
    {
      prime_idx = head->hth_prime_idx;
      do
      {
        prime_idx = prime_idx + 1;
        new_len = process_map_PRIMES[(signed long int)prime_idx];
        new_load_limit = (unsigned int)(0.6 * (double)new_len);
      }
      while(size >= new_load_limit && !(prime_idx >= (signed int)process_map_N_PRIMES));
      void *return_value_tor_reallocarray__2;
      return_value_tor_reallocarray__2=tor_reallocarray_((void *)0, (unsigned long int)new_len, sizeof(struct waitpid_callback_t *) /*8ul*/ );
      new_table = (struct waitpid_callback_t **)return_value_tor_reallocarray__2;
      if(!(new_table == ((struct waitpid_callback_t **)NULL)))
      {
        unsigned int b;
        memset_link8((void *)new_table, 0, (unsigned long int)new_len * sizeof(struct waitpid_callback_t *) /*8ul*/ );
        b = (unsigned int)0;
        for( ; !(b >= head->hth_table_length); b = b + 1u)
        {
          struct waitpid_callback_t *elm;
          struct waitpid_callback_t *next;
          unsigned int b2;
          elm = head->hth_table[(signed long int)b];
          for( ; !(elm == ((struct waitpid_callback_t *)NULL)); elm = next)
          {
            next = elm->node.hte_next;
            b2 = elm->node.hte_hash % new_len;
            elm->node.hte_next = new_table[(signed long int)b2];
            new_table[(signed long int)b2] = elm;
          }
        }
        if(!(head->hth_table == ((struct waitpid_callback_t **)NULL)))
          tor_free_((void *)head->hth_table);

        head->hth_table = new_table;
      }

      else
      {
        unsigned int process_map_HT_GROW__1__3__b;
        unsigned int process_map_HT_GROW__1__3__b2;
        void *return_value_tor_reallocarray__1;
        return_value_tor_reallocarray__1=tor_reallocarray_((void *)head->hth_table, (unsigned long int)new_len, sizeof(struct waitpid_callback_t *) /*8ul*/ );
        new_table = (struct waitpid_callback_t **)return_value_tor_reallocarray__1;
        if(new_table == ((struct waitpid_callback_t **)NULL))
          return -1;

        memset_link8((void *)(new_table + (signed long int)head->hth_table_length), 0, (unsigned long int)(new_len - head->hth_table_length) * sizeof(struct waitpid_callback_t *) /*8ul*/ );
        process_map_HT_GROW__1__3__b = (unsigned int)0;
        for( ; !(process_map_HT_GROW__1__3__b >= head->hth_table_length); process_map_HT_GROW__1__3__b = process_map_HT_GROW__1__3__b + 1u)
        {
          struct waitpid_callback_t *e;
          struct waitpid_callback_t **pE = &new_table[(signed long int)process_map_HT_GROW__1__3__b];
          e = *pE;
          for( ; !(e == ((struct waitpid_callback_t *)NULL)); e = *pE)
          {
            process_map_HT_GROW__1__3__b2 = e->node.hte_hash % new_len;
            if(process_map_HT_GROW__1__3__b2 == process_map_HT_GROW__1__3__b)
              pE = &e->node.hte_next;

            else
            {
              *pE = e->node.hte_next;
              e->node.hte_next = new_table[(signed long int)process_map_HT_GROW__1__3__b2];
              new_table[(signed long int)process_map_HT_GROW__1__3__b2] = e;
            }
          }
        }
        head->hth_table = new_table;
      }
      head->hth_table_length = new_len;
      head->hth_prime_idx = prime_idx;
      head->hth_load_limit = new_load_limit;
      return 0;
    }
}

// process_map_HT_INIT
// file ../src/common/util_process.c line 63
static inline void process_map_HT_INIT(struct process_map *head)
{
  head->hth_table_length = (unsigned int)0;
  head->hth_table = (struct waitpid_callback_t **)(void *)0;
  head->hth_n_entries = (unsigned int)0;
  head->hth_load_limit = (unsigned int)0;
  head->hth_prime_idx = -1;
}

// process_map_HT_REMOVE
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t * process_map_HT_REMOVE(struct process_map *head, struct waitpid_callback_t *elm)
{
  struct waitpid_callback_t **p;
  struct waitpid_callback_t *r;
  do
    elm->node.hte_hash=process_map_entry_hash_(elm);
  while((_Bool)0);
  p=process_map_HT_FIND_P_(head, elm);
  _Bool tmp_if_expr_1;
  if(p == ((struct waitpid_callback_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*p != ((struct waitpid_callback_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct waitpid_callback_t *)(void *)0;

  else
  {
    r = *p;
    *p = r->node.hte_next;
    r->node.hte_next = (struct waitpid_callback_t *)(void *)0;
    head->hth_n_entries = head->hth_n_entries - 1u;
    return r;
  }
}

// process_map_HT_REPLACE
// file ../src/common/util_process.c line 63
static inline struct waitpid_callback_t * process_map_HT_REPLACE(struct process_map *head, struct waitpid_callback_t *elm)
{
  struct waitpid_callback_t **p;
  struct waitpid_callback_t *r;
  _Bool tmp_if_expr_1;
  if(head->hth_table == ((struct waitpid_callback_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = head->hth_n_entries >= head->hth_load_limit ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    process_map_HT_GROW(head, head->hth_n_entries + (unsigned int)1);

  do
    elm->node.hte_hash=process_map_entry_hash_(elm);
  while((_Bool)0);
  p=process_map_HT_FIND_P_(head, elm);
  r = *p;
  *p = elm;
  if(!(r == ((struct waitpid_callback_t *)NULL)) && !(r == elm))
  {
    elm->node.hte_next = r->node.hte_next;
    r->node.hte_next = (struct waitpid_callback_t *)(void *)0;
    return r;
  }

  else
  {
    head->hth_n_entries = head->hth_n_entries + 1u;
    return (struct waitpid_callback_t *)(void *)0;
  }
}

// process_map_HT_REP_IS_BAD_
// file ../src/common/util_process.c line 65
signed int process_map_HT_REP_IS_BAD_(struct process_map *head)
{
  unsigned int n;
  unsigned int i;
  struct waitpid_callback_t *elm;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(head->hth_table_length == 0u)
  {
    if(head->hth_table == ((struct waitpid_callback_t **)NULL))
      tmp_if_expr_1 = !(head->hth_n_entries != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = head->hth_prime_idx == -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return 0;

    return 1;
  }

  else
  {
    if(head->hth_table == ((struct waitpid_callback_t **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = head->hth_prime_idx < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 2;

    else
      if(!(head->hth_load_limit >= head->hth_n_entries))
        return 3;

      else
        if(!(head->hth_table_length == process_map_PRIMES[(signed long int)head->hth_prime_idx]))
          return 4;

        else
          if(!(head->hth_load_limit == (unsigned int)(0.6 * (double)head->hth_table_length)))
            return 5;

          else
          {
            i = (unsigned int)0;
            n = i;
            for( ; !(i >= head->hth_table_length); i = i + 1u)
            {
              elm = head->hth_table[(signed long int)i];
              for( ; !(elm == ((struct waitpid_callback_t *)NULL)); elm = elm->node.hte_next)
              {
                unsigned int return_value_process_map_entry_hash__6;
                return_value_process_map_entry_hash__6=process_map_entry_hash_(elm);
                if(!(elm->node.hte_hash == return_value_process_map_entry_hash__6))
                  return (signed int)((unsigned int)1000 + i);

                if(!(elm->node.hte_hash % head->hth_table_length == i))
                  return (signed int)((unsigned int)10000 + i);

                n = n + 1u;
              }
            }
            if(!(n == head->hth_n_entries))
              return 6;

            else
              return 0;
          }
  }
}

// process_map_entries_eq_
// file ../src/common/util_process.c line 55
static inline unsigned int process_map_entries_eq_(const struct waitpid_callback_t *a, const struct waitpid_callback_t *b)
{
  return (unsigned int)(a->pid == b->pid);
}

// process_map_entry_hash_
// file ../src/common/util_process.c line 49
static inline unsigned int process_map_entry_hash_(const struct waitpid_callback_t *ent)
{
  return (unsigned int)ent->pid;
}

// prot_strings
// file ../src/common/sandbox.c line 1070
static signed int prot_strings(void *ctx, struct sandbox_cfg_elem *cfg)
{
  signed int ret = 0;
  unsigned long int pr_mem_size = (unsigned long int)0;
  unsigned long int pr_mem_left = (unsigned long int)0;
  char *pr_mem_next = (char *)(void *)0;
  char *pr_mem_base;
  struct sandbox_cfg_elem *el = (struct sandbox_cfg_elem *)(void *)0;
  struct strmap_t *locations = (struct strmap_t *)(void *)0;
  el = cfg;
  unsigned long int return_value_strlen_2;
  for( ; !(el == ((struct sandbox_cfg_elem *)NULL)); el = el->next)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((char *)el->param->value);
    pr_mem_size = pr_mem_size + return_value_strlen_1 + (unsigned long int)1;
    if(!(el->param->value2 == ((char *)NULL)))
    {
      return_value_strlen_2=strlen((char *)el->param->value2);
      pr_mem_size = pr_mem_size + return_value_strlen_2 + (unsigned long int)1;
    }

  }
  void *return_value_mmap_3;
  return_value_mmap_3=mmap((void *)0, (unsigned long int)1048576 + pr_mem_size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
  pr_mem_base = (char *)return_value_mmap_3;
  if(pr_mem_base == (char *)-1)
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) failed allocate protected memory! mmap: %s", return_value_strerror_5);
    ret = -1;
    goto out;
  }

  pr_mem_next = pr_mem_base + (signed long int)1048576;
  pr_mem_left = pr_mem_size;
  locations=strmap_new();
  el = cfg;
  for( ; !(el == ((struct sandbox_cfg_elem *)NULL)); el = el->next)
  {
    signed int return_value_prot_strings_helper_6;
    return_value_prot_strings_helper_6=prot_strings_helper(locations, &pr_mem_next, &pr_mem_left, &el->param->value);
    if(!(return_value_prot_strings_helper_6 >= 0))
    {
      ret = -2;
      goto out;
    }

    signed int return_value_prot_strings_helper_7;
    return_value_prot_strings_helper_7=prot_strings_helper(locations, &pr_mem_next, &pr_mem_left, &el->param->value2);
    if(!(return_value_prot_strings_helper_7 >= 0))
    {
      ret = -2;
      goto out;
    }

    el->param->prot = 1;
  }
  signed int return_value_mprotect_10;
  return_value_mprotect_10=mprotect((void *)pr_mem_base, (unsigned long int)1048576 + pr_mem_size, 0x1);
  if(!(return_value_mprotect_10 == 0))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) failed to protect memory! mprotect: %s", return_value_strerror_9);
    ret = -3;
    goto out;
  }

  ret=seccomp_rule_add(ctx, 0x00000000U, 25, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)pr_mem_base,
    .datum_b=(unsigned long int)0 });
  if(!(ret == 0))
    log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) mremap protected memory filter fail!");

  else
  {
    ret=seccomp_rule_add(ctx, 0x00000000U, 11, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)pr_mem_base,
    .datum_b=(unsigned long int)0 });
    if(!(ret == 0))
      log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) munmap protected memory filter fail!");

    else
    {
      ret=seccomp_rule_add(ctx, 0x7fff0000U, 10, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_LT, .datum_a=(unsigned long int)(signed long int)pr_mem_base,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_LE, .datum_a=(unsigned long int)1048576,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 });
      if(!(ret == 0))
        log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) mprotect protected memory filter fail (LT)!");

      else
      {
        ret=seccomp_rule_add(ctx, 0x7fff0000U, 10, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_GT, .datum_a=(unsigned long int)(signed long int)pr_mem_base + pr_mem_size + (unsigned long int)1048576,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_LE, .datum_a=(unsigned long int)1048576,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 });
        if(!(ret == 0))
          log_fn_(3, 1u << 12, "prot_strings", "(Sandbox) mprotect protected memory filter fail (GT)!");

      }
    }
  }

out:
  ;
  strmap_free(locations, (void (*)(void *))(void *)0);
  return ret;
}

// prot_strings_helper
// file ../src/common/sandbox.c line 1021
static signed int prot_strings_helper(struct strmap_t *locations, char **pr_mem_next_p, unsigned long int *pr_mem_left_p, char **value_p)
{
  char *param_val;
  unsigned long int param_size;
  void *location;
  if(*value_p == ((char *)NULL))
    return 0;

  else
  {
    param_val = (char *)*value_p;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(param_val);
    param_size = return_value_strlen_1 + (unsigned long int)1;
    location=strmap_get(locations, param_val);
    if(!(location == NULL))
    {
      if(!(param_val == ((char *)NULL)))
      {
        free((void *)param_val);
        param_val = (char *)(void *)0;
      }

      *value_p = (char *)location;
      return 0;
    }

    else
      if(*pr_mem_left_p >= param_size)
      {
        location = (void *)*pr_mem_next_p;
        memcpy_link8(location, (const void *)param_val, param_size);
        if(!(param_val == ((char *)NULL)))
        {
          free((void *)param_val);
          param_val = (char *)(void *)0;
        }

        *value_p = (char *)location;
        strmap_set(locations, (const char *)location, location);
        *pr_mem_next_p = *pr_mem_next_p + (signed long int)param_size;
        *pr_mem_left_p = *pr_mem_left_p - param_size;
        return 0;
      }

      else
      {
        log_fn_(3, 1u << 12, "prot_strings_helper", "(Sandbox) insufficient protected memory!");
        return -1;
      }
  }
}

// queue_reply
// file ../src/common/workqueue.c line 231
static void queue_reply(struct replyqueue_s *queue, struct workqueue_entry_s *work)
{
  signed int was_empty;
  tor_mutex_acquire(&queue->lock);
  was_empty = (signed int)((&queue->answers)->tqh_first == (struct workqueue_entry_s *)(void *)0 ? (_Bool)1 : (0 != 0 ? (_Bool)1 : (_Bool)0));
  do
  {
    work->next_work.tqe_next = (struct workqueue_entry_s *)(void *)0;
    work->next_work.tqe_prev = (&queue->answers)->tqh_last;
    *(&queue->answers)->tqh_last = work;
    (&queue->answers)->tqh_last = &work->next_work.tqe_next;
  }
  while((_Bool)0);
  tor_mutex_release(&queue->lock);
  if(!(was_empty == 0))
  {
    signed int return_value;
    return_value=queue->alert.alert_fn(queue->alert.write_fd);
  }

}

// rate_limit_is_ready
// file ../src/common/util.c line 1931
static signed int rate_limit_is_ready(struct ratelim_t *lim, signed long int now)
{
  if(now >= lim->last_allowed + (signed long int)lim->rate)
  {
    signed int res = lim->n_calls_since_last_time + 1;
    lim->last_allowed = now;
    lim->n_calls_since_last_time = 0;
    return res;
  }

  else
  {
    lim->n_calls_since_last_time = lim->n_calls_since_last_time + 1;
    return 0;
  }
}

// rate_limit_log
// file ../src/common/util.h line 326
char * rate_limit_log(struct ratelim_t *lim, signed long int now)
{
  signed int n;
  n=rate_limit_is_ready(lim, now);
  if(!(n == 0))
  {
    if(n == 1)
    {
      char *return_value_tor_strdup__1;
      return_value_tor_strdup__1=tor_strdup_("");
      return return_value_tor_strdup__1;
    }

    else
    {
      char *cp = (char *)(void *)0;
      tor_asprintf(&cp, " [%d similar message(s) suppressed in last %d seconds]", n - 1, lim->rate);
      return cp;
    }
  }

  else
    return (char *)(void *)0;
}

// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes)
{
  signed long int return_value___read_chk_1;
  signed long int return_value___read_chk_warn_2;
  signed long int return_value___read_alias_3;
  return_value___read_alias_3=__read_alias(__fd, __buf, __nbytes);
  return return_value___read_alias_3;
}

// read_link1
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __nbytes_link1)
{
  signed long int return_value___read_chk_1_link1;
  signed long int return_value___read_chk_warn_2_link1;
  signed long int return_value___read_alias_3_link1;
  return_value___read_alias_3_link1=__read_alias(__fd_link1, __buf_link1, __nbytes_link1);
  return return_value___read_alias_3_link1;
}

// read_all
// file ../src/tools/../common/util.h line 330
signed long int read_all(signed int fd, char *buf, unsigned long int count, signed int isSocket)
{
  unsigned long int numread = (unsigned long int)0;
  signed long int result;
  if(count >= 9223372036854775792ul || count >= 9223372036854775808ul)
    return (signed long int)-1;

  else
  {
    for( ; !(numread == count); numread = numread + (unsigned long int)result)
    {
      if(!(isSocket == 0))
        result=recv_link1(fd, (void *)(buf + (signed long int)numread), count - numread, 0);

      else
        result=read_link1((signed int)fd, (void *)(buf + (signed long int)numread), count - numread);
      if(!(result >= 0l))
        return (signed long int)-1;

      else
        if(result == 0l)
          break;

    }
    return (signed long int)numread;
  }
}

// read_file_to_str
// file ../src/common/util.c line 2609
char * read_file_to_str(const char *filename, signed int flags, struct stat *stat_out)
{
  signed int fd;
  struct stat statbuf;
  char *string;
  signed long int r;
  signed int bin = flags & 1;
  if(filename == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2617, "read_file_to_str", "filename");
    abort();
  }

  fd=tor_open_cloexec(filename, 00 | (bin != 0 ? 0 : 0), (unsigned int)0);
  if(!(fd >= 0))
  {
    signed int severity = 4;
    signed int read_file_to_str__1__2__save_errno;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    read_file_to_str__1__2__save_errno = *return_value___errno_location_1;
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 2)
    {
      if(!((2 & flags) == 0))
        severity = 6;

    }

    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_fn_(severity, 1u << 4, "read_file_to_str", "Could not open \"%s\": %s", filename, return_value_strerror_4);
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5 = read_file_to_str__1__2__save_errno;
    return (char *)(void *)0;
  }

  signed int return_value_fstat_8;
  return_value_fstat_8=fstat_link1(fd, &statbuf);
  if(!(return_value_fstat_8 >= 0))
  {
    signed int save_errno;
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    save_errno = *return_value___errno_location_6;
    close(fd);
    log_fn_(4, 1u << 4, "read_file_to_str", "Could not fstat \"%s\".", filename);
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    *return_value___errno_location_7 = save_errno;
    return (char *)(void *)0;
  }

  if((61440u & statbuf.st_mode) == 4096u)
  {
    unsigned long int sz = (unsigned long int)0;
    string=read_file_to_str_until_eof(fd, (unsigned long int)(1024 * 1024), &sz);
    if(!(string == ((char *)NULL)) && !(stat_out == ((struct stat *)NULL)))
    {
      statbuf.st_size = (signed long int)sz;
      memcpy_link7((void *)stat_out, (const void *)&statbuf, sizeof(struct stat) /*144ul*/ );
    }

    close(fd);
    return string;
  }

  if(1ul + (unsigned long int)statbuf.st_size >= 9223372036854775791ul)
  {
    close(fd);
    return (char *)(void *)0;
  }

  else
  {
    void *return_value_tor_malloc__9;
    return_value_tor_malloc__9=tor_malloc_((unsigned long int)(statbuf.st_size + (signed long int)1));
    string = (char *)return_value_tor_malloc__9;
    r=read_all(fd, string, (unsigned long int)statbuf.st_size, 0);
    if(!(r >= 0l))
    {
      signed int read_file_to_str__1__6__save_errno;
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      read_file_to_str__1__6__save_errno = *return_value___errno_location_10;
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_fn_(4, 1u << 4, "read_file_to_str", "Error reading from file \"%s\": %s", filename, return_value_strerror_12);
      if(!(string == ((char *)NULL)))
      {
        free((void *)string);
        string = (char *)(void *)0;
      }

      close(fd);
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      *return_value___errno_location_13 = read_file_to_str__1__6__save_errno;
      return (char *)(void *)0;
    }

    string[r] = (char)0;
    if(!(r == statbuf.st_size))
    {
      signed int read_file_to_str__1__7__save_errno;
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      read_file_to_str__1__7__save_errno = *return_value___errno_location_14;
      log_fn_(4, 1u << 4, "read_file_to_str", "Could read only %d of %ld bytes of file \"%s\".", (signed int)r, (signed long int)statbuf.st_size, filename);
      if(!(string == ((char *)NULL)))
      {
        free((void *)string);
        string = (char *)(void *)0;
      }

      close(fd);
      signed int *return_value___errno_location_15;
      return_value___errno_location_15=__errno_location();
      *return_value___errno_location_15 = read_file_to_str__1__7__save_errno;
      return (char *)(void *)0;
    }

    close(fd);
    if(!(stat_out == ((struct stat *)NULL)))
      memcpy_link7((void *)stat_out, (const void *)&statbuf, sizeof(struct stat) /*144ul*/ );

    return string;
  }
}

// read_file_to_str_until_eof
// file ../src/common/util.h line 399
char * read_file_to_str_until_eof(signed int fd, unsigned long int max_bytes_to_read, unsigned long int *sz_out)
{
  signed long int r;
  unsigned long int pos = (unsigned long int)0;
  char *string = (char *)(void *)0;
  unsigned long int string_max = (unsigned long int)0;
  if(1ul + max_bytes_to_read >= 9223372036854775791ul)
    return (char *)(void *)0;

  else
  {
    do
    {
      string_max = pos + (unsigned long int)1024;
      if(!(max_bytes_to_read >= string_max))
        string_max = max_bytes_to_read + (unsigned long int)1;

      void *return_value_tor_realloc__1;
      return_value_tor_realloc__1=tor_realloc_((void *)string, string_max);
      string = (char *)return_value_tor_realloc__1;
      r=read_link1(fd, (void *)(string + (signed long int)pos), (string_max - pos) - (unsigned long int)1);
      if(!(r >= 0l))
      {
        if(!(string == ((char *)NULL)))
        {
          free((void *)string);
          string = (char *)(void *)0;
        }

        return (char *)(void *)0;
      }

      pos = pos + (unsigned long int)r;
    }
    while(r >= 1l && !(pos >= max_bytes_to_read));
    if(pos >= string_max)
    {
      tor_assertion_failed_("../src/common/util.c", (unsigned int)2585, "read_file_to_str_until_eof", "pos < string_max");
      abort();
    }

    *sz_out = pos;
    string[(signed long int)pos] = (char)0;
    return string;
  }
}

// read_ni
// file ../src/common/compat_threads.c line 103
static signed int read_ni(signed int fd, void *buf, unsigned long int n)
{
  signed int r;
  signed long int return_value_read_1;
  signed int *return_value___errno_location_2;
  do
  {

  again:
    ;
    return_value_read_1=read(fd, buf, n);
    r = (signed int)return_value_read_1;
    if(r >= 0)
      break;

    return_value___errno_location_2=__errno_location();
  }
  while(*return_value___errno_location_2 == 4);
  return r;
}

// realign_pointer
// file ../src/common/memarea.c line 65
static inline void * realign_pointer(void *ptr)
{
  unsigned long int x = (unsigned long int)ptr;
  x = x + 7lu & ~7lu;
  return (void *)x;
}

// recv
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 34
static inline signed long int recv(signed int __fd, void *__buf, unsigned long int __n, signed int __flags)
{
  signed long int return_value___recv_chk_1;
  signed long int return_value___recv_chk_warn_2;
  signed long int return_value___recv_alias_3;
  return_value___recv_alias_3=__recv_alias(__fd, __buf, __n, __flags);
  return return_value___recv_alias_3;
}

// recv_link1
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 34
static inline signed long int recv_link1(signed int __fd_link1, void *__buf_link1, unsigned long int __n_link1, signed int __flags_link1)
{
  signed long int return_value___recv_chk_1_link1;
  signed long int return_value___recv_chk_warn_2_link1;
  signed long int return_value___recv_alias_3_link1;
  return_value___recv_alias_3_link1=__recv_alias(__fd_link1, __buf_link1, __n_link1, __flags_link1);
  return return_value___recv_alias_3_link1;
}

// recv_ni
// file ../src/common/compat_threads.c line 127
static signed int recv_ni(signed int fd, void *buf, unsigned long int n, signed int flags)
{
  signed int r;
  signed long int return_value_recv_1;
  signed int *return_value___errno_location_2;
  do
  {

  again:
    ;
    return_value_recv_1=recv(fd, buf, n, flags);
    r = (signed int)return_value_recv_1;
    if(r >= 0)
      break;

    return_value___errno_location_2=__errno_location();
  }
  while(*return_value___errno_location_2 == 4);
  return r;
}

// register_cfg
// file ../src/common/sandbox.c line 1678
static signed int register_cfg(struct sandbox_cfg_elem *cfg)
{
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  if(filter_dynamic == ((struct sandbox_cfg_elem *)NULL))
  {
    filter_dynamic = cfg;
    return 0;
  }

  else
  {
    elem = filter_dynamic;
    for( ; !(elem->next == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
      ;
    elem->next = cfg;
    return 0;
  }
}

// remove_bt_handler
// file ../src/common/backtrace.c line 188
static void remove_bt_handler(void)
{
  tor_mutex_uninit(&cb_buf_mutex);
}

// replace_file
// file ../src/common/compat.c line 815
signed int replace_file(const char *from, const char *to)
{
  signed int return_value_tor_rename_1;
  return_value_tor_rename_1=tor_rename(from, to);
  return return_value_tor_rename_1;
}

// replyqueue_get_socket
// file ../src/common/workqueue.c line 460
signed int replyqueue_get_socket(struct replyqueue_s *rq)
{
  return rq->alert.read_fd;
}

// replyqueue_new
// file ../src/common/workqueue.c line 438
struct replyqueue_s * replyqueue_new(unsigned int alertsocks_flags)
{
  struct replyqueue_s *rq;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct replyqueue_s) /*80ul*/ );
  rq = (struct replyqueue_s *)return_value_tor_malloc_zero__1;
  signed int return_value_alert_sockets_create_2;
  return_value_alert_sockets_create_2=alert_sockets_create(&rq->alert, alertsocks_flags);
  if(!(return_value_alert_sockets_create_2 >= 0))
  {
    if(!(rq == ((struct replyqueue_s *)NULL)))
    {
      free((void *)rq);
      rq = (struct replyqueue_s *)(void *)0;
    }

    return (struct replyqueue_s *)(void *)0;
  }

  else
  {
    tor_mutex_init(&rq->lock);
    do
    {
      (&rq->answers)->tqh_first = (struct workqueue_entry_s *)(void *)0;
      (&rq->answers)->tqh_last = &(&rq->answers)->tqh_first;
    }
    while((_Bool)0);
    return rq;
  }
}

// replyqueue_process
// file ../src/common/workqueue.c line 471
void replyqueue_process(struct replyqueue_s *queue)
{
  signed int return_value;
  return_value=queue->alert.drain_fn(queue->alert.read_fd);
  static struct ratelim_t warn_limit = { .rate=7200, .last_allowed=(signed long int)0, .n_calls_since_last_time=0 };
  if(!(return_value >= 0))
    log_fn_ratelim_(&warn_limit, 4, 1u << 0, "replyqueue_process", "Failure from drain_fd");

  tor_mutex_acquire(&queue->lock);
  if(!(queue->answers.tqh_first == ((struct workqueue_entry_s *)NULL)))
  {
    struct workqueue_entry_s *work = (&queue->answers)->tqh_first;
    if(!(work->next_work.tqe_next == ((struct workqueue_entry_s *)NULL)))
      work->next_work.tqe_next->next_work.tqe_prev = work->next_work.tqe_prev;

    else
      (&queue->answers)->tqh_last = work->next_work.tqe_prev;
    *work->next_work.tqe_prev = work->next_work.tqe_next;
    tor_mutex_release(&queue->lock);
    work->on_pool = (struct threadpool_s *)(void *)0;
    work->reply_fn(work->arg);
    workqueue_entry_free(work);
    tor_mutex_acquire(&queue->lock);
  }

  tor_mutex_release(&queue->lock);
}

// rollback_log_changes
// file ../src/common/log.c line 1110
void rollback_log_changes(void)
{
  struct logfile_t *lf;
  tor_mutex_acquire(&log_mutex);
  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
    lf->is_temporary = (signed int)!(lf->is_temporary != 0);
  tor_mutex_release(&log_mutex);
  close_temp_logs();
}

// round_int64_to_next_multiple_of
// file ../src/common/util.c line 519
signed long int round_int64_to_next_multiple_of(signed long int number, signed long int divisor)
{
  if(!(divisor >= 1l))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)521, "round_int64_to_next_multiple_of", "divisor > 0");
    abort();
  }

  if(-9223372036854775808l + -divisor >= number && number >= 0l)
    number = number + (divisor - (signed long int)1);

  number = number - number % divisor;
  return number;
}

// round_to_next_multiple_of
// file ../src/common/util.c line 489
unsigned int round_to_next_multiple_of(unsigned int number, unsigned int divisor)
{
  number = number + (divisor - (unsigned int)1);
  number = number - number % divisor;
  return number;
}

// round_to_power_of_2
// file ../src/common/util.c line 465
unsigned long int round_to_power_of_2(unsigned long int u64)
{
  signed int lg2;
  unsigned long int low;
  unsigned long int high;
  if(u64 == 0ul)
    return (unsigned long int)1;

  else
  {
    lg2=tor_log2(u64);
    low = 1llu << lg2;
    if(lg2 == 63)
      return low;

    else
    {
      high = 1llu << lg2 + 1;
      if(!(high + -u64 >= u64 + -low))
        return high;

      else
        return low;
    }
  }
}

// round_uint32_to_next_multiple_of
// file ../src/common/util.c line 499
unsigned int round_uint32_to_next_multiple_of(unsigned int number, unsigned int divisor)
{
  number = number + (divisor - (unsigned int)1);
  number = number - number % divisor;
  return number;
}

// round_uint64_to_next_multiple_of
// file ../src/common/util.c line 509
unsigned long int round_uint64_to_next_multiple_of(unsigned long int number, unsigned long int divisor)
{
  number = number + (divisor - (unsigned long int)1);
  number = number - number % divisor;
  return number;
}

// safe_mem_is_zero
// file ../src/common/di_ops.c line 212
signed int safe_mem_is_zero(const void *mem, unsigned long int sz)
{
  unsigned int total = (unsigned int)0;
  const unsigned char *ptr = (const unsigned char *)mem;
  unsigned long int tmp_post_1;
  const unsigned char *tmp_post_2;
  do
  {
    tmp_post_1 = sz;
    sz = sz - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    tmp_post_2 = ptr;
    ptr = ptr + 1l;
    total = total | (unsigned int)*tmp_post_2;
  }
  while((_Bool)1);
  return (signed int)((unsigned int)1 & total - (unsigned int)1 >> 8);
}

// sample_laplace_distribution
// file ../src/common/util.c line 533
signed long int sample_laplace_distribution(double mu, double b, double p)
{
  double result;
  if(!(p < 1.0) || !(p >= 0.0))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)537, "sample_laplace_distribution", "p >= 0.0 && p < 1.0");
    abort();
  }

  double return_value_fabs_1;
  return_value_fabs_1=fabs(p - 0.5);
  double return_value_tor_mathlog_2;
  return_value_tor_mathlog_2=tor_mathlog(1.0 - 2.0 * return_value_fabs_1);
  result = mu - b * (p > 0.5 ? 1.0 : -1.0) * return_value_tor_mathlog_2;
  if(result >= 9.223372e+18)
    return 9223372036854775807L;

  else
    if(result <= -9.223372e+18)
      return -9223372036854775807L - (signed long int)1;

    else
      return (signed long int)result;
}

// sandbox_add_addrinfo
// file ../src/common/sandbox.c line 1435
signed int sandbox_add_addrinfo(const char *name)
{
  struct addrinfo *res;
  struct addrinfo hints;
  signed int i;
  memset_link9((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    static const signed int families[3l] = { 2, 10, 0 };
    hints.ai_family = families[(signed long int)i];
    res = (struct addrinfo *)(void *)0;
    sandbox_getaddrinfo(name, (const char *)(void *)0, &hints, &res);
    if(!(res == ((struct addrinfo *)NULL)))
      sandbox_freeaddrinfo(res);

  }
  return 0;
}

// sandbox_cfg_allow_open_filename
// file ../src/common/sandbox.c line 1228
signed int sandbox_cfg_allow_open_filename(struct sandbox_cfg_elem **cfg, char *file)
{
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem=new_element(2, file);
  if(elem == ((struct sandbox_cfg_elem *)NULL))
  {
    log_fn_(3, 1u << 12, "sandbox_cfg_allow_open_filename", "(Sandbox) failed to register parameter!");
    return -1;
  }

  else
  {
    elem->next = *cfg;
    *cfg = elem;
    return 0;
  }
}

// sandbox_cfg_allow_openat_filename
// file ../src/common/sandbox.c line 1263
signed int sandbox_cfg_allow_openat_filename(struct sandbox_cfg_elem **cfg, char *file)
{
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem=new_element(257, file);
  if(elem == ((struct sandbox_cfg_elem *)NULL))
  {
    log_fn_(3, 1u << 12, "sandbox_cfg_allow_openat_filename", "(Sandbox) failed to register parameter!");
    return -1;
  }

  else
  {
    elem->next = *cfg;
    *cfg = elem;
    return 0;
  }
}

// sandbox_cfg_allow_rename
// file ../src/common/sandbox.c line 1245
signed int sandbox_cfg_allow_rename(struct sandbox_cfg_elem **cfg, char *file1, char *file2)
{
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem=new_element2(82, file1, file2);
  if(elem == ((struct sandbox_cfg_elem *)NULL))
  {
    log_fn_(3, 1u << 12, "sandbox_cfg_allow_rename", "(Sandbox) failed to register parameter!");
    return -1;
  }

  else
  {
    elem->next = *cfg;
    *cfg = elem;
    return 0;
  }
}

// sandbox_cfg_allow_stat_filename
// file ../src/common/sandbox.c line 1211
signed int sandbox_cfg_allow_stat_filename(struct sandbox_cfg_elem **cfg, char *file)
{
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem=new_element(-10062, file);
  if(elem == ((struct sandbox_cfg_elem *)NULL))
  {
    log_fn_(3, 1u << 12, "sandbox_cfg_allow_stat_filename", "(Sandbox) failed to register parameter!");
    return -1;
  }

  else
  {
    elem->next = *cfg;
    *cfg = elem;
    return 0;
  }
}

// sandbox_cfg_new
// file ../src/common/sandbox.c line 1728
struct sandbox_cfg_elem * sandbox_cfg_new(void)
{
  return (struct sandbox_cfg_elem *)(void *)0;
}

// sandbox_disable_getaddrinfo_cache
// file ../src/common/sandbox.h line 179
void sandbox_disable_getaddrinfo_cache(void)
{
  sandbox_getaddrinfo_cache_disabled = 1;
}

// sandbox_free_getaddrinfo_cache
// file ../src/common/sandbox.c line 1457
void sandbox_free_getaddrinfo_cache(void)
{
  struct cached_getaddrinfo_item_t **next;
  struct cached_getaddrinfo_item_t **item;
  item=getaddrinfo_cache_HT_START(&getaddrinfo_cache);
  for( ; !(item == ((struct cached_getaddrinfo_item_t **)NULL)); item = next)
  {
    next=getaddrinfo_cache_HT_NEXT_RMV(&getaddrinfo_cache, item);
    cached_getaddrinfo_item_free(*item);
  }
  getaddrinfo_cache_HT_CLEAR(&getaddrinfo_cache);
}

// sandbox_freeaddrinfo
// file ../src/common/sandbox.h line 118
void sandbox_freeaddrinfo(struct addrinfo *ai)
{
  if(!(sandbox_getaddrinfo_cache_disabled == 0))
    freeaddrinfo(ai);

}

// sandbox_getaddrinfo
// file ../src/common/sandbox.h line 115
signed int sandbox_getaddrinfo(const char *name, const char *servname, struct addrinfo *hints, struct addrinfo **res)
{
  signed int err;
  struct cached_getaddrinfo_item_t search;
  struct cached_getaddrinfo_item_t *item;
  if(!(sandbox_getaddrinfo_cache_disabled == 0))
  {
    signed int return_value_getaddrinfo_1;
    return_value_getaddrinfo_1=getaddrinfo(name, (const char *)(void *)0, hints, res);
    return return_value_getaddrinfo_1;
  }

  signed int tmp_if_expr_2;
  signed int tmp_if_expr_4;
  if(!(servname == ((const char *)NULL)))
  {
    log_fn_(4, 1u << 12, "sandbox_getaddrinfo", "called with non-NULL servname");
    return -2;
  }

  else
    if(name == ((const char *)NULL))
    {
      log_fn_(4, 1u << 12, "sandbox_getaddrinfo", "called with NULL name");
      return -2;
    }

    else
    {
      *res = (struct addrinfo *)(void *)0;
      memset_link9((void *)&search, 0, sizeof(struct cached_getaddrinfo_item_t) /*48ul*/ );
      search.name = (char *)name;
      if(!(hints == ((struct addrinfo *)NULL)))
        tmp_if_expr_2 = hints->ai_family;

      else
        tmp_if_expr_2 = 0;
      search.family = tmp_if_expr_2;
      item=getaddrinfo_cache_HT_FIND(&getaddrinfo_cache, &search);
      signed int return_value_sandbox_is_active_5;
      return_value_sandbox_is_active_5=sandbox_is_active();
      if(return_value_sandbox_is_active_5 == 0)
      {
        err=getaddrinfo(name, (const char *)(void *)0, hints, res);
        log_fn_(6, 1u << 2, "sandbox_getaddrinfo", "(Sandbox) getaddrinfo %s.", err != 0 ? "failed" : "succeeded");
        if(item == ((struct cached_getaddrinfo_item_t *)NULL))
        {
          void *return_value_tor_malloc_zero__3;
          return_value_tor_malloc_zero__3=tor_malloc_zero_(sizeof(struct cached_getaddrinfo_item_t) /*48ul*/ );
          item = (struct cached_getaddrinfo_item_t *)return_value_tor_malloc_zero__3;
          item->name=tor_strdup_(name);
          if(!(hints == ((struct addrinfo *)NULL)))
            tmp_if_expr_4 = hints->ai_family;

          else
            tmp_if_expr_4 = 0;
          item->family = tmp_if_expr_4;
          getaddrinfo_cache_HT_INSERT(&getaddrinfo_cache, item);
        }

        if(!(item->res == ((struct addrinfo *)NULL)))
        {
          freeaddrinfo(item->res);
          item->res = (struct addrinfo *)(void *)0;
        }

        item->res = *res;
        item->err = err;
        return err;
      }

      else
        if(!(item == ((struct cached_getaddrinfo_item_t *)NULL)))
        {
          *res = item->res;
          return item->err;
        }

        else
        {
          log_fn_(3, 1u << 12, "sandbox_getaddrinfo", "(Sandbox) failed to get address %s!", name);
          return -2;
        }
    }
}

// sandbox_init
// file ../src/common/sandbox.c line 1734
signed int sandbox_init(struct sandbox_cfg_elem *cfg)
{
  signed int return_value_initialise_libseccomp_sandbox_1;
  return_value_initialise_libseccomp_sandbox_1=initialise_libseccomp_sandbox(cfg);
  return return_value_initialise_libseccomp_sandbox_1;
}

// sandbox_intern_string
// file ../src/common/sandbox.h line 134
const char * sandbox_intern_string(const char *str)
{
  struct sandbox_cfg_elem *elem;
  signed int tmp_statement_expression_1;
  signed int tmp_statement_expression_3;
  if(str == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    elem = filter_dynamic;
    for( ; !(elem == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
    {
      struct smp_param *param = elem->param;
      if(!(param->prot == 0))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_2;
        return_value___builtin_strcmp_2=__builtin_strcmp(str, (char *)param->value);
        tmp_statement_expression_1 = return_value___builtin_strcmp_2;
        if(tmp_statement_expression_1 == 0)
          return (char *)param->value;

        if(!(param->value2 == ((char *)NULL)))
        {
          unsigned long int sandbox_intern_string__1__1__1__3____s1_len;
          unsigned long int sandbox_intern_string__1__1__1__3____s2_len;
          signed int return_value___builtin_strcmp_4;
          return_value___builtin_strcmp_4=__builtin_strcmp(str, (char *)param->value2);
          tmp_statement_expression_3 = return_value___builtin_strcmp_4;
          if(tmp_statement_expression_3 == 0)
            return (char *)param->value2;

        }

      }

    }
    if(!(sandbox_active == 0))
      log_fn_(4, 1u << 12, "sandbox_intern_string", "No interned sandbox parameter found for %s", str);

    return str;
  }
}

// sandbox_is_active
// file ../src/common/sandbox.c line 1721
signed int sandbox_is_active(void)
{
  return (signed int)(sandbox_active != 0);
}

// sb__sysctl
// file ../src/common/sandbox.c line 437
static signed int sb__sysctl(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc;
  (void)filter;
  (void)ctx;
  rc=seccomp_rule_add(ctx, 0x00050000U | (unsigned int)1 & 0x0000ffffU, 156, (unsigned int)0);
  if(!(rc == 0))
  {
    log_fn_(3, 1u << 12, "sb__sysctl", "(Sandbox) failed to add _sysctl syscall, received libseccomp error %d", rc);
    return rc;
  }

  else
    return 0;
}

// sb_accept4
// file ../src/common/sandbox.c line 313
static signed int sb_accept4(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 288, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
    return 0;
}

// sb_epoll_ctl
// file ../src/common/sandbox.c line 736
static signed int sb_epoll_ctl(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 233, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 233, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)3,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 233, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)2,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
        return 0;
    }
  }
}

// sb_fcntl64
// file ../src/common/sandbox.c line 698
static signed int sb_fcntl64(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, -10009, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)3,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, -10009, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)4,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(02 | 04000),
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, -10009, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
      {
        rc=seccomp_rule_add(ctx, 0x7fff0000U, -10009, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)2,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 });
        if(!(rc == 0))
          return rc;

        else
          return 0;
      }
    }
  }
}

// sb_flock
// file ../src/common/sandbox.c line 836
static signed int sb_flock(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 73, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(2 | 4),
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 73, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)8,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
      return 0;
  }
}

// sb_futex
// file ../src/common/sandbox.c line 859
static signed int sb_futex(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 202, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(9 | 128 | 256),
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 202, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(1 | 128),
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 202, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0 | 128),
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
        return 0;
    }
  }
}

// sb_getsockopt
// file ../src/common/sandbox.c line 656
static signed int sb_getsockopt(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 55, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)4,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 55, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)80,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 55, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)41,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)80,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
        return 0;
    }
  }
}

// sb_mmap2
// file ../src/common/sandbox.c line 341
static signed int sb_mmap2(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0x1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0x02,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0x0,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x20 | 0x04000),
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x20),
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
      {
        rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x20 | 0x20000),
    .datum_b=(unsigned long int)0 });
        if(!(rc == 0))
          return rc;

        else
        {
          rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x10 | 0x00800),
    .datum_b=(unsigned long int)0 });
          if(!(rc == 0))
            return rc;

          else
          {
            rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x2),
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x10 | 0x20),
    .datum_b=(unsigned long int)0 });
            if(!(rc == 0))
              return rc;

            else
            {
              rc=seccomp_rule_add(ctx, 0x7fff0000U, -10029, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x1 | 0x4),
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(0x02 | 0x00800),
    .datum_b=(unsigned long int)0 });
              if(!(rc == 0))
                return rc;

              else
                return 0;
            }
          }
        }
      }
    }
  }
}

// sb_mprotect
// file ../src/common/sandbox.c line 788
static signed int sb_mprotect(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 10, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0x1,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 10, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0x0,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
      return 0;
  }
}

// sb_mremap
// file ../src/common/sandbox.c line 891
static signed int sb_mremap(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 25, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)3, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
    return 0;
}

// sb_open
// file ../src/common/sandbox.c line 404
static signed int sb_open(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc;
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem = filter;
  for( ; !(elem == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
  {
    struct smp_param *param = elem->param;
    if(!(param == ((struct smp_param *)NULL)))
    {
      if(param->prot == 1)
      {
        if(param->syscall == 2)
        {
          rc=seccomp_rule_add(ctx, 0x7fff0000U, 2, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)(void *)param->value,
    .datum_b=(unsigned long int)0 });
          if(!(rc == 0))
          {
            log_fn_(3, 1u << 12, "sb_open", "(Sandbox) failed to add open syscall, received libseccomp error %d", rc);
            return rc;
          }

        }

      }

    }

  }
  rc=seccomp_rule_add(ctx, 0x00050000U | (unsigned int)13 & 0x0000ffffU, 2, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(02000000 | 04000 | 0400)),
    .datum_b=(unsigned long int)00 });
  if(!(rc == 0))
  {
    log_fn_(3, 1u << 12, "sb_open", "(Sandbox) failed to add open syscall, received libseccomp error %d", rc);
    return rc;
  }

  else
    return 0;
}

// sb_openat
// file ../src/common/sandbox.c line 489
static signed int sb_openat(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc;
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem = filter;
  for( ; !(elem == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
  {
    struct smp_param *param = elem->param;
    if(!(param == ((struct smp_param *)NULL)))
    {
      if(param->prot == 1)
      {
        if(param->syscall == 257)
        {
          rc=seccomp_rule_add(ctx, 0x7fff0000U, 257, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)-100,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)(void *)param->value,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(00 | 04000 | 0 | 0200000 | 02000000),
    .datum_b=(unsigned long int)0 });
          if(!(rc == 0))
          {
            log_fn_(3, 1u << 12, "sb_openat", "(Sandbox) failed to add openat syscall, received libseccomp error %d", rc);
            return rc;
          }

        }

      }

    }

  }
  return 0;
}

// sb_poll
// file ../src/common/sandbox.c line 909
static signed int sb_poll(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 7, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)10,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
    return 0;
}

// sb_prctl
// file ../src/common/sandbox.c line 767
static signed int sb_prctl(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 157, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)4,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
    return 0;
}

// sb_rename
// file ../src/common/sandbox.c line 458
static signed int sb_rename(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc;
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem = filter;
  for( ; !(elem == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
  {
    struct smp_param *param = elem->param;
    if(!(param == ((struct smp_param *)NULL)))
    {
      if(param->prot == 1)
      {
        if(param->syscall == 82)
        {
          rc=seccomp_rule_add(ctx, 0x7fff0000U, 82, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)(void *)param->value,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)(void *)param->value2,
    .datum_b=(unsigned long int)0 });
          if(!(rc == 0))
          {
            log_fn_(3, 1u << 12, "sb_rename", "(Sandbox) failed to add rename syscall, received libseccomp error %d", rc);
            return rc;
          }

        }

      }

    }

  }
  return 0;
}

// sb_rt_sigaction
// file ../src/common/sandbox.c line 240
static signed int sb_rt_sigaction(void *ctx, struct sandbox_cfg_elem *filter)
{
  unsigned int i;
  signed int rc;
  signed int param[8l] = { 2, 15, 13, 10, 12, 1, 17, 25 };
  (void)filter;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= 8ul); i = i + 1u)
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 13, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)param[(signed long int)i],
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      break;

  }
  return rc;
}

// sb_rt_sigprocmask
// file ../src/common/sandbox.c line 811
static signed int sb_rt_sigprocmask(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 14, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 14, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)2,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
      return 0;
  }
}

// sb_setsockopt
// file ../src/common/sandbox.c line 611
static signed int sb_setsockopt(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 54, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)2,
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
  {
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 54, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)7,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 54, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)8,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
      {
        rc=seccomp_rule_add(ctx, 0x7fff0000U, 54, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)19,
    .datum_b=(unsigned long int)0 });
        if(!(rc == 0))
          return rc;

        else
          return 0;
      }
    }
  }
}

// sb_socket
// file ../src/common/sandbox.c line 521
static signed int sb_socket(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  signed int i;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)1 });
  if(!(rc == 0))
    return rc;

  else
  {
    i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      const signed int pf = i != 0 ? 2 : 10;
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)pf,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)1 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)6,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)pf,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)2 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

    }
    rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)1 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 });
    if(!(rc == 0))
      return rc;

    else
    {
      rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_MASKED_EQ, .datum_a=~((unsigned long int)(524288 | 2048)),
    .datum_b=(unsigned long int)2 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 });
      if(!(rc == 0))
        return rc;

      else
      {
        rc=seccomp_rule_add(ctx, 0x7fff0000U, 41, (unsigned int)3, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)16,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)3,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)2, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 });
        if(!(rc == 0))
          return rc;

        else
          return 0;
      }
    }
  }
}

// sb_socketpair
// file ../src/common/sandbox.c line 586
static signed int sb_socketpair(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  (void)filter;
  rc=seccomp_rule_add(ctx, 0x7fff0000U, 53, (unsigned int)2, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)1,
    .datum_b=(unsigned long int)0 }, (struct scmp_arg_cmp){ .arg=(unsigned int)1, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(1 | 524288),
    .datum_b=(unsigned long int)0 });
  if(!(rc == 0))
    return rc;

  else
    return 0;
}

// sb_stat64
// file ../src/common/sandbox.c line 929
static signed int sb_stat64(void *ctx, struct sandbox_cfg_elem *filter)
{
  signed int rc = 0;
  struct sandbox_cfg_elem *elem = (struct sandbox_cfg_elem *)(void *)0;
  elem = filter;
  _Bool tmp_if_expr_1;
  for( ; !(elem == ((struct sandbox_cfg_elem *)NULL)); elem = elem->next)
  {
    struct smp_param *param = elem->param;
    if(!(param == ((struct smp_param *)NULL)))
    {
      if(param->prot == 1)
      {
        if(param->syscall == 2)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = param->syscall == -10062 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          rc=seccomp_rule_add(ctx, 0x7fff0000U, -10062, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)(signed long int)(void *)param->value,
    .datum_b=(unsigned long int)0 });
          if(!(rc == 0))
          {
            log_fn_(3, 1u << 12, "sb_stat64", "(Sandbox) failed to add open syscall, received libseccomp  error %d", rc);
            return rc;
          }

        }

      }

    }

  }
  return 0;
}

// sb_time
// file ../src/common/sandbox.c line 297
static signed int sb_time(void *ctx, struct sandbox_cfg_elem *filter)
{
  (void)filter;
  signed int return_value_seccomp_rule_add_1;
  return_value_seccomp_rule_add_1=seccomp_rule_add(ctx, 0x7fff0000U, 201, (unsigned int)1, (struct scmp_arg_cmp){ .arg=(unsigned int)0, .op=(enum scmp_compare)SCMP_CMP_EQ, .datum_a=(unsigned long int)0,
    .datum_b=(unsigned long int)0 });
  return return_value_seccomp_rule_add_1;
}

// scan_double
// file ../src/common/util.c line 3125
static signed int scan_double(const char **bufp, double *out, signed int width)
{
  signed int neg = 0;
  double result = (double)0;
  signed int scanned_so_far = 0;
  _Bool tmp_if_expr_1;
  if(bufp == ((const char **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*bufp != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_TOR_ISDIGIT_2;
  const char *tmp_post_3;
  signed int return_value_TOR_ISDIGIT_4;
  const char *tmp_post_5;
  if(out == ((double *)NULL) || tmp_if_expr_1)
    return -1;

  else
  {
    if(!(width >= 0))
      width = 9999;

    if((signed int)*(*bufp) == 45)
    {
      neg = 1;
      *bufp = *bufp + 1l;
    }

    while(!(*(*bufp) == 0))
    {
      return_value_TOR_ISDIGIT_2=TOR_ISDIGIT_link1(*(*bufp));
      if(return_value_TOR_ISDIGIT_2 == 0)
        break;

      if(scanned_so_far >= width)
        break;

      signed int digit;
      tmp_post_3 = *bufp;
      *bufp = *bufp + 1l;
      digit=digit_to_num(*tmp_post_3);
      result = result * (double)10 + (double)digit;
      scanned_so_far = scanned_so_far + 1;
    }
    if((signed int)*(*bufp) == 46)
    {
      double fracval = (double)0;
      double denominator = (double)1;
      *bufp = *bufp + 1l;
      scanned_so_far = scanned_so_far + 1;
      while(!(*(*bufp) == 0))
      {
        return_value_TOR_ISDIGIT_4=TOR_ISDIGIT_link1(*(*bufp));
        if(return_value_TOR_ISDIGIT_4 == 0)
          break;

        if(scanned_so_far >= width)
          break;

        signed int scan_double__1__3__1__digit;
        tmp_post_5 = *bufp;
        *bufp = *bufp + 1l;
        scan_double__1__3__1__digit=digit_to_num(*tmp_post_5);
        fracval = fracval * (double)10 + (double)scan_double__1__3__1__digit;
        denominator = denominator * (double)10;
        scanned_so_far = scanned_so_far + 1;
      }
      result = result + fracval / denominator;
    }

    if(scanned_so_far == 0)
      return -1;

    else
    {
      *out = neg != 0 ? -result : result;
      return 0;
    }
  }
}

// scan_signed
// file ../src/common/util.c line 3081
static signed int scan_signed(const char **bufp, signed long int *out, signed int width)
{
  signed int neg = 0;
  unsigned long int result = (unsigned long int)0;
  _Bool tmp_if_expr_1;
  if(bufp == ((const char **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*bufp != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(out == ((signed long int *)NULL) || tmp_if_expr_1)
    return -1;

  else
  {
    if(!(width >= 0))
      width = 9999;

    if((signed int)*(*bufp) == 45)
    {
      neg = 1;
      *bufp = *bufp + 1l;
      width = width - 1;
    }

    signed int return_value_scan_unsigned_2;
    return_value_scan_unsigned_2=scan_unsigned(bufp, &result, width, 10);
    if(!(return_value_scan_unsigned_2 >= 0))
      return -1;

    else
    {
      if(result >= 1ul && !(neg == 0))
      {
        if(result >= 9223372036854775809ul)
          return -1;

        *out = -((signed long int)(result - (unsigned long int)1)) - (signed long int)1;
      }

      else
      {
        if(result >= 9223372036854775808ul)
          return -1;

        *out = (signed long int)result;
      }
      return 0;
    }
  }
}

// scan_string
// file ../src/common/util.c line 3170
static signed int scan_string(const char **bufp, char *out, signed int width)
{
  signed int scanned_so_far = 0;
  signed int return_value_TOR_ISSPACE_1;
  char *tmp_post_2;
  const char *tmp_post_3;
  if(bufp == ((const char **)NULL) || out == ((char *)NULL) || !(width >= 0))
    return -1;

  else
  {
    for( ; !(*(*bufp) == 0); scanned_so_far = scanned_so_far + 1)
    {
      return_value_TOR_ISSPACE_1=TOR_ISSPACE_link1(*(*bufp));
      if(!(return_value_TOR_ISSPACE_1 == 0))
        break;

      if(scanned_so_far >= width)
        break;

      tmp_post_2 = out;
      out = out + 1l;
      tmp_post_3 = *bufp;
      *bufp = *bufp + 1l;
      *tmp_post_2 = *tmp_post_3;
    }
    *out = (char)0;
    return 0;
  }
}

// scan_unsigned
// file ../src/common/util.c line 3044
static signed int scan_unsigned(const char **bufp, unsigned long int *out, signed int width, signed int base)
{
  unsigned long int result = (unsigned long int)0;
  signed int scanned_so_far = 0;
  const signed int hex = (const signed int)(base == 16);
  if(!(base == 10) && !(base == 16))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)3049, "scan_unsigned", "base == 10 || base == 16");
    abort();
  }

  _Bool tmp_if_expr_1;
  if(bufp == ((const char **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*bufp != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr_4;
  signed int return_value_TOR_ISXDIGIT_2;
  signed int return_value_TOR_ISDIGIT_3;
  signed int tmp_if_expr_9;
  const char *tmp_post_5;
  signed int return_value_hex_decode_digit_6;
  const char *tmp_post_7;
  signed int return_value_digit_to_num_8;
  if(out == ((unsigned long int *)NULL) || tmp_if_expr_1)
    return -1;

  else
  {
    if(!(width >= 0))
      width = 9999;

    while(!(*(*bufp) == 0))
    {
      if(!(hex == 0))
      {
        return_value_TOR_ISXDIGIT_2=TOR_ISXDIGIT_link1(*(*bufp));
        tmp_if_expr_4 = return_value_TOR_ISXDIGIT_2;
      }

      else
      {
        return_value_TOR_ISDIGIT_3=TOR_ISDIGIT_link1(*(*bufp));
        tmp_if_expr_4 = return_value_TOR_ISDIGIT_3;
      }
      if(tmp_if_expr_4 == 0)
        break;

      if(scanned_so_far >= width)
        break;

      signed int digit;
      if(!(hex == 0))
      {
        tmp_post_5 = *bufp;
        *bufp = *bufp + 1l;
        return_value_hex_decode_digit_6=hex_decode_digit(*tmp_post_5);
        tmp_if_expr_9 = return_value_hex_decode_digit_6;
      }

      else
      {
        tmp_post_7 = *bufp;
        *bufp = *bufp + 1l;
        return_value_digit_to_num_8=digit_to_num(*tmp_post_7);
        tmp_if_expr_9 = return_value_digit_to_num_8;
      }
      digit = tmp_if_expr_9;
      if(!((1UL + -((unsigned long int)digit)) / (unsigned long int)base >= result))
        return -1;

      result = result * (unsigned long int)base + (unsigned long int)digit;
      scanned_so_far = scanned_so_far + 1;
    }
    if(scanned_so_far == 0)
      return -1;

    else
    {
      *out = result;
      return 0;
    }
  }
}

// send_ni
// file ../src/common/compat_threads.c line 116
static signed int send_ni(signed int fd, const void *buf, unsigned long int n, signed int flags)
{
  signed int r;
  signed long int return_value_send_1;
  signed int *return_value___errno_location_2;
  do
  {

  again:
    ;
    return_value_send_1=send(fd, buf, n, flags);
    r = (signed int)return_value_send_1;
    if(r >= 0)
      break;

    return_value___errno_location_2=__errno_location();
  }
  while(*return_value___errno_location_2 == 4);
  return r;
}

// set_environment_variable_in_smartlist
// file ../src/common/util.c line 4613
void set_environment_variable_in_smartlist(struct smartlist_t *env_vars, const char *new_var, void (*free_old)(void *), signed int free_p)
{
  signed int s_sl_idx;
  signed int s_sl_len = env_vars->num_used;
  const char *s;
  s_sl_idx = 0;
  for( ; !(s_sl_idx >= s_sl_len); s_sl_idx = s_sl_idx + 1)
  {
    s = (const char *)env_vars->list[(signed long int)s_sl_idx];
    signed int return_value_environment_variable_names_equal_1;
    return_value_environment_variable_names_equal_1=environment_variable_names_equal(s, new_var);
    if(!(return_value_environment_variable_names_equal_1 == 0))
    {
      smartlist_del(env_vars, s_sl_idx);
      s_sl_idx = s_sl_idx - 1;
      s_sl_len = s_sl_len - 1;
      if(!(free_p == 0))
        free_old((void *)s);

    }

    s = (const char *)(void *)0;
  }
  char *return_value___builtin_strchr_2;
  return_value___builtin_strchr_2=__builtin_strchr(new_var, 61);
  if(!(return_value___builtin_strchr_2 == ((char *)NULL)))
    smartlist_add(env_vars, (void *)new_var);

}

// set_log_severity_config
// file ../src/tools/../common/torlog.h line 131
void set_log_severity_config(signed int loglevelMin, signed int loglevelMax, struct log_severity_list_t *severity_out)
{
  signed int i;
  if(!(loglevelMin >= loglevelMax))
  {
    tor_assertion_failed_("../src/common/log.c", (unsigned int)883, "set_log_severity_config", "loglevelMin >= loglevelMax");
    abort();
  }

  if(!(loglevelMin >= 3) || loglevelMin >= 8)
  {
    tor_assertion_failed_("../src/common/log.c", (unsigned int)884, "set_log_severity_config", "loglevelMin >= LOG_ERR && loglevelMin <= LOG_DEBUG");
    abort();
  }

  if(!(loglevelMax >= 3) || loglevelMax >= 8)
  {
    tor_assertion_failed_("../src/common/log.c", (unsigned int)885, "set_log_severity_config", "loglevelMax >= LOG_ERR && loglevelMax <= LOG_DEBUG");
    abort();
  }

  memset_link5((void *)severity_out, 0, sizeof(struct log_severity_list_t) /*20ul*/ );
  i = loglevelMin;
  for( ; i >= loglevelMax; i = i - 1)
    severity_out->masks[(signed long int)(i - 3)] = ~0u;
}

// set_log_time_granularity
// file ../src/common/log.c line 191
void set_log_time_granularity(signed int granularity_msec)
{
  log_time_granularity = granularity_msec;
}

// set_main_thread
// file ../src/common/compat_threads.c line 79
void set_main_thread(void)
{
  main_thread_id=tor_get_thread_id();
}

// set_max_file_descriptors
// file ../src/common/compat.c line 1538
signed int set_max_file_descriptors(unsigned long int limit, signed int *max_out)
{
  struct rlimit rlim;
  signed int return_value_getrlimit_3;
  return_value_getrlimit_3=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rlim);
  if(!(return_value_getrlimit_3 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 2, "set_max_file_descriptors", "Could not get maximum number of file descriptors: %s", return_value_strerror_2);
    return -1;
  }

  if(limit == 0ul)
  {
    limit = rlim.rlim_max;
    if(limit >= 2147483648ul)
      limit = (unsigned long int)0x7fffffff;

    *max_out = (signed int)limit - 32;
    return 0;
  }

  else
    if(!(rlim.rlim_max >= limit))
    {
      log_fn_(4, 1u << 3, "set_max_file_descriptors", "We need %lu file descriptors available, and we're limited to %lu. Please change your ulimit -n.", (unsigned long int)limit, (unsigned long int)rlim.rlim_max);
      return -1;
    }

    else
    {
      if(!(rlim.rlim_cur >= rlim.rlim_max))
        log_fn_(6, 1u << 2, "set_max_file_descriptors", "Raising max file descriptors from %lu to %lu.", (unsigned long int)rlim.rlim_cur, (unsigned long int)rlim.rlim_max);

      rlim.rlim_cur = rlim.rlim_max;
      signed int return_value_setrlimit_6;
      return_value_setrlimit_6=setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rlim);
      if(!(return_value_setrlimit_6 == 0))
      {
        signed int bad = 1;
        if(!(bad == 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          log_fn_(4, 1u << 3, "set_max_file_descriptors", "Couldn't set maximum number of file descriptors: %s", return_value_strerror_5);
          return -1;
        }

      }

      limit = rlim.rlim_cur;
      if(!(limit >= 32ul))
      {
        log_fn_(4, 1u << 3, "set_max_file_descriptors", "ConnLimit must be at least %d. Failing.", 32);
        return -1;
      }

      else
      {
        if(limit >= 2147483648ul)
          limit = (unsigned long int)0x7fffffff;

        if(max_out == ((signed int *)NULL))
        {
          tor_assertion_failed_("../src/common/compat.c", (unsigned int)1633, "set_max_file_descriptors", "max_out");
          abort();
        }

        *max_out = (signed int)limit - 32;
        return 0;
      }
    }
}

// set_socket_nonblocking
// file ../src/common/compat.c line 1315
signed int set_socket_nonblocking(signed int socket)
{
  signed int flags;
  flags=fcntl(socket, 3, 0);
  if(flags == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 2, "set_socket_nonblocking", "Couldn't get file status flags: %s", return_value_strerror_2);
    return -1;
  }

  flags = flags | 04000;
  signed int return_value_fcntl_5;
  return_value_fcntl_5=fcntl(socket, 4, flags);
  if(return_value_fcntl_5 == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_fn_(4, 1u << 2, "set_socket_nonblocking", "Couldn't set file status flags: %s", return_value_strerror_4);
    return -1;
  }

  return 0;
}

// set_uint16
// file ../src/common/compat.h line 619
void set_uint16(void *cp, unsigned short int v)
{
  memcpy_link2(cp, (const void *)&v, (unsigned long int)2);
}

// set_uint32
// file ../src/common/compat.h line 620
void set_uint32(void *cp, unsigned int v)
{
  memcpy_link2(cp, (const void *)&v, (unsigned long int)4);
}

// set_uint64
// file ../src/common/compat.c line 803
void set_uint64(void *cp, unsigned long int v)
{
  memcpy_link2(cp, (const void *)&v, (unsigned long int)8);
}

// set_waitpid_callback
// file ../src/common/util_process.h line 19
struct waitpid_callback_t * set_waitpid_callback(signed int pid, void (*fn)(signed int, void *), void *arg)
{
  struct waitpid_callback_t *old_ent;
  struct waitpid_callback_t *ent;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct waitpid_callback_t) /*48ul*/ );
  ent = (struct waitpid_callback_t *)return_value_tor_malloc_zero__1;
  ent->pid = pid;
  ent->userfn = fn;
  ent->userdata = arg;
  ent->running = (unsigned int)1;
  old_ent=process_map_HT_REPLACE(&process_map, ent);
  if(!(old_ent == ((struct waitpid_callback_t *)NULL)))
  {
    log_fn_(4, 1u << 12, "set_waitpid_callback", "Replaced a waitpid monitor on pid %u. That should be impossible.", (unsigned int)pid);
    old_ent->running = (unsigned int)0;
  }

  return ent;
}

// sev_to_string
// file ../src/common/log.c line 68
static inline const char * sev_to_string(signed int severity)
{
  switch(severity)
  {
    case 7:
      return "debug";
    case 6:
      return "info";
    case 5:
      return "notice";
    case 4:
      return "warn";
    case 3:
      return "err";
    default:
    {
      /* assertion 0 */
      assert(0 != 0);
      return "UNKNOWN";
    }
  }
}

// should_log_function_name
// file ../src/common/log.c line 84
static inline signed int should_log_function_name(unsigned int domain, signed int severity)
{
  switch(severity)
  {
    case 7:

    case 6:
      return (signed int)((domain & 1u << 30) == (unsigned int)0);
    case 5:

    case 4:

    case 3:
      return (signed int)((domain & (1u << 12 | 1u << 30)) == 1u << 12);
    default:
    {
      /* assertion 0 */
      assert(0 != 0);
      return 0;
    }
  }
}

// sigsys_debugging
// file ../src/common/sandbox.c line 1595
static void sigsys_debugging(signed int nr, struct anonymous_25 *info, void *void_context)
{
  struct ucontext *ctx = (struct ucontext *)void_context;
  const char *syscall_name;
  signed int syscall;
  signed int depth;
  signed int n_fds;
  signed int i;
  const signed int *fds = (const signed int *)(void *)0;
  (void)nr;
  if(info->si_code == 1)
  {
    if(!(ctx == ((struct ucontext *)NULL)))
    {
      syscall = (signed int)ctx->uc_mcontext.gregs[(signed long int)13];
      depth=backtrace(syscall_cb_buf, 256);
      clean_backtrace(syscall_cb_buf, depth, ctx);
      syscall_name=get_syscall_name(syscall);
      tor_log_err_sigsafe("(Sandbox) Caught a bad syscall attempt (syscall ", syscall_name, (const void *)")\n", (void *)0);
      n_fds=tor_log_get_sigsafe_err_fds(&fds);
      i = 0;
      for( ; !(i >= n_fds); i = i + 1)
        backtrace_symbols_fd(syscall_cb_buf, depth, fds[(signed long int)i]);
      _exit(1);
    }

  }

}

// siphash24
// file ../src/ext/csiphash.c line 99
unsigned long int siphash24(const void *src, unsigned long int src_sz, struct sipkey *key)
{
  unsigned long int k0 = key->k0;
  unsigned long int k1 = key->k1;
  unsigned long int b = (unsigned long int)src_sz << 56;
  const unsigned char *in = (unsigned char *)src;
  unsigned long int t;
  unsigned char *pt;
  unsigned char *m;
  unsigned long int v0 = k0 ^ 0x736f6d6570736575ULL;
  unsigned long int v1 = k1 ^ 0x646f72616e646f6dULL;
  unsigned long int v2 = k0 ^ 0x6c7967656e657261ULL;
  unsigned long int v3 = k1 ^ 0x7465646279746573ULL;
  while(src_sz >= 8ul)
  {
    unsigned long int mi;
    memcpy_link9((void *)&mi, (const void *)in, (unsigned long int)8);
    mi = (unsigned long int)mi;
    in = in + (signed long int)8;
    src_sz = src_sz - (unsigned long int)8;
    v3 = v3 ^ mi;
    v0 = v0 + v1;
    v2 = v2 + v3;
    v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
    v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
    v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
    v2 = v2 + v1;
    v0 = v0 + v3;
    v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
    v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
    v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
    v0 = v0 + v1;
    v2 = v2 + v3;
    v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
    v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
    v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
    v2 = v2 + v1;
    v0 = v0 + v3;
    v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
    v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
    v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
    v0 = v0 ^ mi;
  }
  t = (unsigned long int)0;
  pt = (unsigned char *)&t;
  m = (unsigned char *)in;
  switch(src_sz)
  {
    case (unsigned long int)7:
      pt[(signed long int)6] = m[(signed long int)6];
    case (unsigned long int)6:
      pt[(signed long int)5] = m[(signed long int)5];
    case (unsigned long int)5:
      pt[(signed long int)4] = m[(signed long int)4];
    case (unsigned long int)4:
      pt[(signed long int)3] = m[(signed long int)3];
    case (unsigned long int)3:
      pt[(signed long int)2] = m[(signed long int)2];
    case (unsigned long int)2:
      pt[(signed long int)1] = m[(signed long int)1];
    case (unsigned long int)1:
      pt[(signed long int)0] = m[(signed long int)0];
  }
  b = b | (unsigned long int)t;
  v3 = v3 ^ b;
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  v0 = v0 ^ b;
  v2 = v2 ^ (unsigned long int)0xff;
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  v0 = v0 + v1;
  v2 = v2 + v3;
  v1 = (unsigned long int)(v1 << 13 | v1 >> 64 - 13) ^ v0;
  v3 = (unsigned long int)(v3 << 16 | v3 >> 64 - 16) ^ v2;
  v0 = (unsigned long int)(v0 << 32 | v0 >> 64 - 32);
  v2 = v2 + v1;
  v0 = v0 + v3;
  v1 = (unsigned long int)(v1 << 17 | v1 >> 64 - 17) ^ v2;
  v3 = (unsigned long int)(v3 << 21 | v3 >> 64 - 21) ^ v0;
  v2 = (unsigned long int)(v2 << 32 | v2 >> 64 - 32);
  return v0 ^ v1 ^ v2 ^ v3;
}

// siphash24g
// file ../src/ext/siphash.h line 11
unsigned long int siphash24g(const void *src, unsigned long int src_sz)
{
  if(the_siphash_key_is_set == 0)
  {
    tor_assertion_failed_("../src/ext/csiphash.c", (unsigned int)166, "siphash24g", "the_siphash_key_is_set");
    abort();
  }

  unsigned long int return_value_siphash24_1;
  return_value_siphash24_1=siphash24(src, src_sz, &the_siphash_key);
  return return_value_siphash24_1;
}

// siphash_set_global_key
// file ../src/ext/csiphash.c line 170
void siphash_set_global_key(struct sipkey *key)
{
  if(!(the_siphash_key_is_set == 0))
  {
    tor_assertion_failed_("../src/ext/csiphash.c", (unsigned int)172, "siphash_set_global_key", "! the_siphash_key_is_set");
    abort();
  }

  the_siphash_key.k0 = key->k0;
  the_siphash_key.k1 = key->k1;
  the_siphash_key_is_set = 1;
}

// size_mul_check
// file ../src/common/util.c line 207
static inline signed int size_mul_check(const unsigned long int x, const unsigned long int y)
{
  return (signed int)((x | y) < (unsigned long int)1 << sizeof(unsigned long int) /*8ul*/  * (unsigned long int)4 || y == (unsigned long int)0 || x <= 18446744073709551615UL / y);
}

// smartlist_add
// file ../src/common/container.h line 33
void smartlist_add(struct smartlist_t *sl, void *element)
{
  smartlist_ensure_capacity(sl, sl->num_used + 1);
  signed int tmp_post_1 = sl->num_used;
  sl->num_used = sl->num_used + 1;
  sl->list[(signed long int)tmp_post_1] = element;
}

// smartlist_add_all
// file ../src/common/container.c line 103
void smartlist_add_all(struct smartlist_t *s1, const struct smartlist_t *s2)
{
  signed int new_size = s1->num_used + s2->num_used;
  if(!(new_size >= s1->num_used))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)106, "smartlist_add_all", "new_size >= s1->num_used");
    abort();
  }

  smartlist_ensure_capacity(s1, new_size);
  memcpy_link3((void *)(s1->list + (signed long int)s1->num_used), (const void *)s2->list, (unsigned long int)s2->num_used * sizeof(void *) /*8ul*/ );
  s1->num_used = new_size;
}

// smartlist_add_asprintf
// file ../src/common/util.h line 254
void smartlist_add_asprintf(struct smartlist_t *sl, const char *pattern, ...)
{
  void **ap = (void **)&pattern;
  smartlist_add_vasprintf(sl, pattern, ap);
  ap = ((void **)NULL);
}

// smartlist_add_vasprintf
// file ../src/common/util.c line 3338
void smartlist_add_vasprintf(struct smartlist_t *sl, const char *pattern, void **args)
{
  char *str = (char *)(void *)0;
  tor_vasprintf(&str, pattern, args);
  if(str == ((char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)3344, "smartlist_add_vasprintf", "str != NULL");
    abort();
  }

  smartlist_add(sl, (void *)str);
}

// smartlist_bsearch
// file ../src/common/container.c line 588
void * smartlist_bsearch(struct smartlist_t *sl, const void *key, signed int (*compare)(const void *, const void **))
{
  signed int found;
  signed int idx;
  idx=smartlist_bsearch_idx(sl, key, compare, &found);
  void *tmp_if_expr_1;
  if(!(found == 0))
    tmp_if_expr_1 = sl->list[(signed long int)idx];

  else
    tmp_if_expr_1 = (void *)0;
  return tmp_if_expr_1;
}

// smartlist_bsearch_idx
// file ../src/common/container.c line 605
signed int smartlist_bsearch_idx(const struct smartlist_t *sl, const void *key, signed int (*compare)(const void *, const void **), signed int *found_out)
{
  signed int hi;
  signed int lo;
  signed int cmp;
  signed int mid;
  signed int len;
  signed int diff;
  if(sl == ((const struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)611, "smartlist_bsearch_idx", "sl");
    abort();
  }

  if(compare == ((signed int (*)(const void *, const void **))NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)612, "smartlist_bsearch_idx", "compare");
    abort();
  }

  if(found_out == ((signed int *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)613, "smartlist_bsearch_idx", "found_out");
    abort();
  }

  len = sl->num_used;
  if(len == 0)
  {
    *found_out = 0;
    return 0;
  }

  else
  {
    if(!(len >= 1))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)625, "smartlist_bsearch_idx", "len > 0");
      abort();
    }

    lo = 0;
    hi = len - 1;
    if(hi >= lo)
    {
      diff = hi - lo;
      mid = lo + diff / 2;
      cmp=compare(key, (const void **)&sl->list[(signed long int)mid]);
      if(cmp == 0)
      {
        *found_out = 1;
        return mid;
      }

      else
        if(cmp >= 1)
        {
          if(mid >= len)
          {
            tor_assertion_failed_("../src/common/container.c", (unsigned int)665, "smartlist_bsearch_idx", "mid < len");
            abort();
          }

          lo = mid + 1;
        }

        else
        {
          if(cmp >= 0)
          {
            tor_assertion_failed_("../src/common/container.c", (unsigned int)670, "smartlist_bsearch_idx", "cmp < 0");
            abort();
          }

          if(mid >= 1)
            hi = mid - 1;

          else
          {
            if(!(mid == lo))
            {
              tor_assertion_failed_("../src/common/container.c", (unsigned int)682, "smartlist_bsearch_idx", "mid == lo");
              abort();
            }

            if(!(mid == 0))
            {
              tor_assertion_failed_("../src/common/container.c", (unsigned int)683, "smartlist_bsearch_idx", "mid == 0");
              abort();
            }

            *found_out = 0;
            return 0;
          }
        }
    }

    if(!(lo == 1 + hi))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)698, "smartlist_bsearch_idx", "lo == hi + 1");
      abort();
    }

    if(!(lo >= 0))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)699, "smartlist_bsearch_idx", "lo >= 0");
      abort();
    }

    if(!(len >= lo))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)700, "smartlist_bsearch_idx", "lo <= len");
      abort();
    }

    if(!(hi >= 0))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)701, "smartlist_bsearch_idx", "hi >= 0");
      abort();
    }

    if(!(len >= hi))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)702, "smartlist_bsearch_idx", "hi <= len");
      abort();
    }

    if(!(lo >= len))
    {
      cmp=compare(key, (const void **)&sl->list[(signed long int)lo]);
      if(cmp >= 0)
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)706, "smartlist_bsearch_idx", "cmp < 0");
        abort();
      }

    }

    else
    {
      cmp=compare(key, (const void **)&sl->list[(signed long int)(len - 1)]);
      if(!(cmp >= 1))
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)709, "smartlist_bsearch_idx", "cmp > 0");
        abort();
      }

    }
    *found_out = 0;
    return lo;
  }
}

// smartlist_clear
// file ../src/common/container.c line 56
void smartlist_clear(struct smartlist_t *sl)
{
  sl->num_used = 0;
}

// smartlist_contains
// file ../src/common/container.c line 175
signed int smartlist_contains(const struct smartlist_t *sl, const void *element)
{
  signed int i = 0;
  for( ; !(i >= sl->num_used); i = i + 1)
    if(sl->list[(signed long int)i] == element)
      return 1;

  return 0;
}

// smartlist_contains_digest
// file ../src/common/container.c line 278
signed int smartlist_contains_digest(const struct smartlist_t *sl, const char *element)
{
  signed int i;
  signed int return_value_tor_memeq_1;
  if(sl == ((const struct smartlist_t *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
    {
      return_value_tor_memeq_1=tor_memeq((const void *)(const char *)sl->list[(signed long int)i], (const void *)element, (unsigned long int)20);
      if(!(return_value_tor_memeq_1 == 0))
        return 1;

    }
    return 0;
  }
}

// smartlist_contains_int_as_string
// file ../src/common/container.c line 229
signed int smartlist_contains_int_as_string(const struct smartlist_t *sl, signed int num)
{
  char buf[32l];
  tor_snprintf(buf, sizeof(char [32l]) /*32ul*/ , "%d", num);
  signed int return_value_smartlist_contains_string_1;
  return_value_smartlist_contains_string_1=smartlist_contains_string(sl, buf);
  return return_value_smartlist_contains_string_1;
}

// smartlist_contains_string
// file ../src/common/container.c line 188
signed int smartlist_contains_string(const struct smartlist_t *sl, const char *element)
{
  signed int i;
  signed int tmp_statement_expression_1;
  if(sl == ((const struct smartlist_t *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp((const char *)sl->list[(signed long int)i], element);
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
        return 1;

    }
    return 0;
  }
}

// smartlist_contains_string_case
// file ../src/common/container.c line 215
signed int smartlist_contains_string_case(const struct smartlist_t *sl, const char *element)
{
  signed int i;
  signed int return_value_strcasecmp_1;
  if(sl == ((const struct smartlist_t *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
    {
      return_value_strcasecmp_1=strcasecmp((const char *)sl->list[(signed long int)i], element);
      if(return_value_strcasecmp_1 == 0)
        return 1;

    }
    return 0;
  }
}

// smartlist_del
// file ../src/common/container.c line 329
void smartlist_del(struct smartlist_t *sl, signed int idx)
{
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)331, "smartlist_del", "sl");
    abort();
  }

  if(!(idx >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)332, "smartlist_del", "idx>=0");
    abort();
  }

  if(idx >= sl->num_used)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)333, "smartlist_del", "idx < sl->num_used");
    abort();
  }

  sl->num_used = sl->num_used - 1;
  sl->list[(signed long int)idx] = sl->list[(signed long int)sl->num_used];
}

// smartlist_del_keeporder
// file ../src/common/container.c line 342
void smartlist_del_keeporder(struct smartlist_t *sl, signed int idx)
{
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)344, "smartlist_del_keeporder", "sl");
    abort();
  }

  if(!(idx >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)345, "smartlist_del_keeporder", "idx>=0");
    abort();
  }

  if(idx >= sl->num_used)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)346, "smartlist_del_keeporder", "idx < sl->num_used");
    abort();
  }

  sl->num_used = sl->num_used - 1;
  if(!(idx >= sl->num_used))
    memmove_link1((void *)(sl->list + (signed long int)idx), (const void *)(sl->list + (signed long int)idx + (signed long int)1), sizeof(void *) /*8ul*/  * (unsigned long int)(sl->num_used - idx));

}

// smartlist_ensure_capacity
// file ../src/common/container.c line 63
static inline void smartlist_ensure_capacity(struct smartlist_t *sl, signed int size)
{
  if(!(sl->capacity >= size))
  {
    signed int higher = sl->capacity;
    if(size >= 1073741824)
      higher = 0x7fffffff;

    else
      for( ; !(higher >= size); higher = higher * 2)
        ;
    sl->capacity = higher;
    void *return_value_tor_reallocarray__1;
    return_value_tor_reallocarray__1=tor_reallocarray_((void *)sl->list, sizeof(void *) /*8ul*/ , (unsigned long int)sl->capacity);
    sl->list = (void **)return_value_tor_reallocarray__1;
  }

}

// smartlist_free
// file ../src/common/container.h line 31
void smartlist_free(struct smartlist_t *sl)
{
  if(!(sl == ((struct smartlist_t *)NULL)))
  {
    if(!(sl->list == ((void **)NULL)))
    {
      free((void *)sl->list);
      sl->list = (void **)(void *)0;
    }

    if(!(sl == ((struct smartlist_t *)NULL)))
    {
      free((void *)sl);
      sl = (struct smartlist_t *)(void *)0;
    }

  }

}

// smartlist_get_most_frequent_
// file ../src/common/container.c line 525
void * smartlist_get_most_frequent_(const struct smartlist_t *sl, signed int (*compare)(const void **, const void **), signed int *count_out)
{
  const void *most_frequent = (void *)0;
  signed int most_frequent_count = 0;
  const void *cur = (void *)0;
  signed int i;
  signed int count = 0;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(sl->num_used == 0)
  {
    if(!(count_out == ((signed int *)NULL)))
      *count_out = 0;

    return (void *)0;
  }

  else
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
    {
      const void *item = sl->list[(signed long int)i];
      if(!(cur == NULL))
      {
        return_value=compare(&cur, &item);
        tmp_if_expr_1 = 0 == return_value ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        count = count + 1;

      else
      {
        if(count >= most_frequent_count && !(cur == NULL))
        {
          most_frequent = cur;
          most_frequent_count = count;
        }

        cur = item;
        count = 1;
      }
    }
    if(count >= most_frequent_count && !(cur == NULL))
    {
      most_frequent = cur;
      most_frequent_count = count;
    }

    if(!(count_out == ((signed int *)NULL)))
      *count_out = most_frequent_count;

    return (void *)most_frequent;
  }
}

// smartlist_get_most_frequent_digest256
// file ../src/common/container.c line 1011
char * smartlist_get_most_frequent_digest256(struct smartlist_t *sl)
{
  void *return_value_smartlist_get_most_frequent__1;
  return_value_smartlist_get_most_frequent__1=smartlist_get_most_frequent_(sl, compare_digests256_, (signed int *)(void *)0);
  return (char *)return_value_smartlist_get_most_frequent__1;
}

// smartlist_get_most_frequent_string
// file ../src/common/container.c line 733
char * smartlist_get_most_frequent_string(struct smartlist_t *sl)
{
  void *return_value_smartlist_get_most_frequent__1;
  return_value_smartlist_get_most_frequent__1=smartlist_get_most_frequent_(sl, compare_string_ptrs_, (signed int *)(void *)0);
  return (char *)return_value_smartlist_get_most_frequent__1;
}

// smartlist_get_most_frequent_string_
// file ../src/common/container.c line 743
char * smartlist_get_most_frequent_string_(struct smartlist_t *sl, signed int *count_out)
{
  void *return_value_smartlist_get_most_frequent__1;
  return_value_smartlist_get_most_frequent__1=smartlist_get_most_frequent_(sl, compare_string_ptrs_, count_out);
  return (char *)return_value_smartlist_get_most_frequent__1;
}

// smartlist_heapify
// file ../src/common/container.c line 848
static inline void smartlist_heapify(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, signed int idx)
{
  signed int return_value_1;
  {
    signed int left_idx = 2 * idx + 1;
    signed int best_idx;
    if(!(left_idx >= sl->num_used))
    {
      signed int return_value;
      return_value=compare(sl->list[(signed long int)idx], sl->list[(signed long int)left_idx]);
      if(!(return_value >= 0))
        best_idx = idx;

      else
        best_idx = left_idx;
      if(!(1 + left_idx >= sl->num_used))
      {
        return_value_1=compare(sl->list[(signed long int)(left_idx + 1)], sl->list[(signed long int)best_idx]);
        if(!(return_value_1 >= 0))
          best_idx = left_idx + 1;

      }

      if(!(best_idx == idx))
      {
        void *tmp = sl->list[(signed long int)idx];
        sl->list[(signed long int)idx] = sl->list[(signed long int)best_idx];
        sl->list[(signed long int)best_idx] = tmp;
        void *smartlist_heapify__1__1__2__1__updated = sl->list[(signed long int)idx];
        *((signed int *)(void *)((char *)smartlist_heapify__1__1__2__1__updated + (signed long int)idx_field_offset)) = idx;
        void *updated = sl->list[(signed long int)best_idx];
        *((signed int *)(void *)((char *)updated + (signed long int)idx_field_offset)) = best_idx;
        idx = best_idx;
      }

    }

  }
}

// smartlist_insert
// file ../src/common/container.c line 357
void smartlist_insert(struct smartlist_t *sl, signed int idx, void *val)
{
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)359, "smartlist_insert", "sl");
    abort();
  }

  if(!(idx >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)360, "smartlist_insert", "idx>=0");
    abort();
  }

  if(!(sl->num_used >= idx))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)361, "smartlist_insert", "idx <= sl->num_used");
    abort();
  }

  if(idx == sl->num_used)
    smartlist_add(sl, val);

  else
  {
    smartlist_ensure_capacity(sl, sl->num_used + 1);
    if(!(idx >= sl->num_used))
      memmove_link1((void *)(sl->list + (signed long int)idx + (signed long int)1), (const void *)(sl->list + (signed long int)idx), sizeof(void *) /*8ul*/  * (unsigned long int)(sl->num_used - idx));

    sl->num_used = sl->num_used + 1;
    sl->list[(signed long int)idx] = val;
  }
}

// smartlist_intersect
// file ../src/common/container.c line 304
void smartlist_intersect(struct smartlist_t *sl1, const struct smartlist_t *sl2)
{
  signed int i = 0;
  signed int return_value_smartlist_contains_1;
  for( ; !(i >= sl1->num_used); i = i + 1)
  {
    return_value_smartlist_contains_1=smartlist_contains(sl2, sl1->list[(signed long int)i]);
    if(return_value_smartlist_contains_1 == 0)
    {
      sl1->num_used = sl1->num_used - 1;
      sl1->list[(signed long int)i] = sl1->list[(signed long int)sl1->num_used];
      i = i - 1;
    }

  }
}

// smartlist_ints_eq
// file ../src/common/container.c line 258
signed int smartlist_ints_eq(const struct smartlist_t *sl1, const struct smartlist_t *sl2)
{
  if(sl1 == ((const struct smartlist_t *)NULL))
    return (signed int)(sl2 == (const struct smartlist_t *)(void *)0);

  else
    if(sl2 == ((const struct smartlist_t *)NULL))
      return 0;

    else
      if(!(sl1->num_used == sl2->num_used))
        return 0;

      else
      {
        signed int cp1_sl_idx;
        signed int cp1_sl_len = sl1->num_used;
        signed int *cp1;
        cp1_sl_idx = 0;
        for( ; !(cp1_sl_idx >= cp1_sl_len); cp1_sl_idx = cp1_sl_idx + 1)
        {
          cp1 = (signed int *)sl1->list[(signed long int)cp1_sl_idx];
          signed int *cp2 = (signed int *)sl2->list[(signed long int)cp1_sl_idx];
          if(!(*cp1 == *cp2))
            return 0;

          cp1 = (signed int *)(void *)0;
        }
        return 1;
      }
}

// smartlist_join_strings
// file ../src/common/container.h line 144
char * smartlist_join_strings(struct smartlist_t *sl, const char *join, signed int terminate, unsigned long int *len_out)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(join);
  char *return_value_smartlist_join_strings2_2;
  return_value_smartlist_join_strings2_2=smartlist_join_strings2(sl, join, return_value_strlen_1, terminate, len_out);
  return return_value_smartlist_join_strings2_2;
}

// smartlist_join_strings2
// file ../src/common/container.c line 468
char * smartlist_join_strings2(struct smartlist_t *sl, const char *join, unsigned long int join_len, signed int terminate, unsigned long int *len_out)
{
  signed int i;
  unsigned long int n = (unsigned long int)0;
  char *r = (char *)(void *)0;
  char *dst;
  char *src;
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)475, "smartlist_join_strings2", "sl");
    abort();
  }

  if(join == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)476, "smartlist_join_strings2", "join");
    abort();
  }

  if(!(terminate == 0))
    n = join_len;

  i = 0;
  for( ; !(i >= sl->num_used); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)sl->list[(signed long int)i]);
    n = n + return_value_strlen_1;
    if(!(1 + i >= sl->num_used))
      n = n + join_len;

  }
  void *return_value_tor_malloc__2;
  return_value_tor_malloc__2=tor_malloc_(n + (unsigned long int)1);
  r = (char *)return_value_tor_malloc__2;
  dst = r;
  i = 0;
  char *tmp_post_3;
  char *tmp_post_4;
  while(!(i >= sl->num_used))
  {
    src = (char *)sl->list[(signed long int)i];
    for( ; !(*src == 0); *tmp_post_3 = *tmp_post_4)
    {
      tmp_post_3 = dst;
      dst = dst + 1l;
      tmp_post_4 = src;
      src = src + 1l;
    }
    i = i + 1;
    if(!(i >= sl->num_used))
    {
      memcpy_link3((void *)dst, (const void *)join, join_len);
      dst = dst + (signed long int)join_len;
    }

  }
  if(!(terminate == 0))
  {
    memcpy_link3((void *)dst, (const void *)join, join_len);
    dst = dst + (signed long int)join_len;
  }

  *dst = (char)0;
  if(!(len_out == ((unsigned long int *)NULL)))
    *len_out = (unsigned long int)(dst - r);

  return r;
}

// smartlist_new
// file ../src/common/container.h line 30
struct smartlist_t * smartlist_new(void)
{
  struct smartlist_t *sl;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct smartlist_t) /*16ul*/ );
  sl = (struct smartlist_t *)return_value_tor_malloc__1;
  sl->num_used = 0;
  sl->capacity = 16;
  void *return_value_tor_calloc__2;
  return_value_tor_calloc__2=tor_calloc_(sizeof(void *) /*8ul*/ , (unsigned long int)sl->capacity);
  sl->list = (void **)return_value_tor_calloc__2;
  return sl;
}

// smartlist_overlap
// file ../src/common/container.c line 291
signed int smartlist_overlap(const struct smartlist_t *sl1, const struct smartlist_t *sl2)
{
  signed int i = 0;
  signed int return_value_smartlist_contains_1;
  for( ; !(i >= sl2->num_used); i = i + 1)
  {
    return_value_smartlist_contains_1=smartlist_contains(sl1, sl2->list[(signed long int)i]);
    if(!(return_value_smartlist_contains_1 == 0))
      return 1;

  }
  return 0;
}

// smartlist_pop_last
// file ../src/common/container.c line 132
void * smartlist_pop_last(struct smartlist_t *sl)
{
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)134, "smartlist_pop_last", "sl");
    abort();
  }

  if(!(sl->num_used == 0))
  {
    sl->num_used = sl->num_used - 1;
    return sl->list[(signed long int)sl->num_used];
  }

  else
    return (void *)0;
}

// smartlist_pqueue_add
// file ../src/common/container.c line 887
void smartlist_pqueue_add(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, void *item)
{
  signed int idx;
  smartlist_add(sl, item);
  do
  {
    void *updated = sl->list[(signed long int)(sl->num_used - 1)];
    *((signed int *)(void *)((char *)updated + (signed long int)idx_field_offset)) = sl->num_used - 1;
  }
  while((_Bool)0);
  idx = sl->num_used - 1;
  if(!(idx == 0))
  {
    signed int parent = (idx - 1) / 2;
    signed int return_value;
    return_value=compare(sl->list[(signed long int)idx], sl->list[(signed long int)parent]);
    if(!(return_value >= 0))
    {
      void *tmp = sl->list[(signed long int)parent];
      sl->list[(signed long int)parent] = sl->list[(signed long int)idx];
      sl->list[(signed long int)idx] = tmp;
      void *smartlist_pqueue_add__1__2__1__1__updated = sl->list[(signed long int)parent];
      *((signed int *)(void *)((char *)smartlist_pqueue_add__1__2__1__1__updated + (signed long int)idx_field_offset)) = parent;
      void *smartlist_pqueue_add__1__2__1__2__updated = sl->list[(signed long int)idx];
      *((signed int *)(void *)((char *)smartlist_pqueue_add__1__2__1__2__updated + (signed long int)idx_field_offset)) = idx;
      idx = parent;
    }

  }

}

// smartlist_pqueue_assert_ok
// file ../src/common/container.c line 960
void smartlist_pqueue_assert_ok(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset)
{
  signed int i = sl->num_used - 1;
  for( ; i >= 0; i = i - 1)
  {
    if(i >= 1)
    {
      signed int return_value;
      return_value=compare(sl->list[(signed long int)((i - 1) / 2)], sl->list[(signed long int)i]);
      if(return_value >= 1)
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)967, "smartlist_pqueue_assert_ok", "compare(sl->list[PARENT(i)], sl->list[i]) <= 0");
        abort();
      }

    }

    if(!(*((signed int *)((char *)sl->list[(signed long int)i] + (signed long int)idx_field_offset)) == i))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)968, "smartlist_pqueue_assert_ok", "IDX_OF_ITEM(sl->list[i]) == i");
      abort();
    }

  }
}

// smartlist_pqueue_pop
// file ../src/common/container.c line 916
void * smartlist_pqueue_pop(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset)
{
  void *top;
  if(sl->num_used == 0)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)921, "smartlist_pqueue_pop", "sl->num_used");
    abort();
  }

  top = sl->list[(signed long int)0];
  *((signed int *)(void *)((char *)top + (signed long int)idx_field_offset)) = -1;
  sl->num_used = sl->num_used - 1;
  if(!(sl->num_used == 0))
  {
    sl->list[(signed long int)0] = sl->list[(signed long int)sl->num_used];
    do
    {
      void *updated = sl->list[(signed long int)0];
      *((signed int *)(void *)((char *)updated + (signed long int)idx_field_offset)) = 0;
    }
    while((_Bool)0);
    smartlist_heapify(sl, compare, idx_field_offset, 0);
  }

  return top;
}

// smartlist_pqueue_remove
// file ../src/common/container.c line 938
void smartlist_pqueue_remove(struct smartlist_t *sl, signed int (*compare)(const void *, const void *), signed int idx_field_offset, void *item)
{
  signed int idx = *((signed int *)(void *)((char *)item + (signed long int)idx_field_offset));
  if(!(idx >= 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)944, "smartlist_pqueue_remove", "idx >= 0");
    abort();
  }

  if(!(sl->list[(signed long int)idx] == item))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)945, "smartlist_pqueue_remove", "sl->list[idx] == item");
    abort();
  }

  sl->num_used = sl->num_used - 1;
  *((signed int *)(void *)((char *)item + (signed long int)idx_field_offset)) = -1;
  if(idx == sl->num_used)
    goto __CPROVER_DUMP_L6;

  else
  {
    sl->list[(signed long int)idx] = sl->list[(signed long int)sl->num_used];
    do
    {
      void *updated = sl->list[(signed long int)idx];
      *((signed int *)(void *)((char *)updated + (signed long int)idx_field_offset)) = idx;
    }
    while((_Bool)0);
    smartlist_heapify(sl, compare, idx_field_offset, idx);
  }

__CPROVER_DUMP_L6:
  ;
}

// smartlist_remove
// file ../src/common/container.c line 117
void smartlist_remove(struct smartlist_t *sl, const void *element)
{
  signed int i;
  if(!(element == NULL))
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
      if(sl->list[(signed long int)i] == element)
      {
        sl->num_used = sl->num_used - 1;
        sl->list[(signed long int)i] = sl->list[(signed long int)sl->num_used];
        i = i - 1;
      }

  }

}

// smartlist_reverse
// file ../src/common/container.c line 143
void smartlist_reverse(struct smartlist_t *sl)
{
  signed int i;
  signed int j;
  void *tmp;
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)147, "smartlist_reverse", "sl");
    abort();
  }

  i = 0;
  j = sl->num_used - 1;
  for( ; !(i >= j); j = j - 1)
  {
    tmp = sl->list[(signed long int)i];
    sl->list[(signed long int)i] = sl->list[(signed long int)j];
    sl->list[(signed long int)j] = tmp;
    i = i + 1;
  }
}

// smartlist_sort
// file ../src/common/container.c line 511
void smartlist_sort(struct smartlist_t *sl, signed int (*compare)(const void **, const void **))
{
  if(!(sl->num_used == 0))
    qsort((void *)sl->list, (unsigned long int)sl->num_used, sizeof(void *) /*8ul*/ , (signed int (*)(const void *, const void *))compare);

}

// smartlist_sort_digests
// file ../src/common/container.c line 981
void smartlist_sort_digests(struct smartlist_t *sl)
{
  smartlist_sort(sl, compare_digests_);
}

// smartlist_sort_digests256
// file ../src/common/container.c line 1003
void smartlist_sort_digests256(struct smartlist_t *sl)
{
  smartlist_sort(sl, compare_digests256_);
}

// smartlist_sort_pointers
// file ../src/common/container.c line 771
void smartlist_sort_pointers(struct smartlist_t *sl)
{
  smartlist_sort(sl, compare_ptrs_);
}

// smartlist_sort_strings
// file ../src/common/container.c line 726
void smartlist_sort_strings(struct smartlist_t *sl)
{
  smartlist_sort(sl, compare_string_ptrs_);
}

// smartlist_split_string
// file ../src/common/container.c line 391
signed int smartlist_split_string(struct smartlist_t *sl, const char *str, const char *sep, signed int flags, signed int max)
{
  const char *cp;
  const char *end;
  const char *next;
  signed int n = 0;
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)397, "smartlist_split_string", "sl");
    abort();
  }

  if(str == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)398, "smartlist_split_string", "str");
    abort();
  }

  cp = str;
  signed int return_value_TOR_ISSPACE_1;
  void *return_value___rawmemchr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  signed int return_value_TOR_ISSPACE_7;
  for( ; (_Bool)1; cp = next)
  {
    if(!((0x01 & flags) == 0))
      do
      {
        return_value_TOR_ISSPACE_1=TOR_ISSPACE(*cp);
        if(return_value_TOR_ISSPACE_1 == 0)
          break;

        cp = cp + 1l;
      }
      while((_Bool)1);

    if(n == max + -1 && max >= 1)
    {
      void *return_value___rawmemchr_2;
      return_value___rawmemchr_2=__rawmemchr((const void *)cp, 0);
      end = (char *)return_value___rawmemchr_2;
    }

    else
      if(!(sep == ((const char *)NULL)))
      {
        end=strstr(cp, sep);
        if(end == ((const char *)NULL))
        {
          return_value___rawmemchr_3=__rawmemchr((const void *)cp, 0);
          end = (char *)return_value___rawmemchr_3;
        }

      }

      else
      {
        end = cp;
        do
        {
          if(!(*end == 0))
            tmp_if_expr_4 = (signed int)*end != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (signed int)*end != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_5 = (_Bool)0;
          if(!tmp_if_expr_5)
            break;

          end = end + 1l;
        }
        while((_Bool)1);
      }
    if(end == ((const char *)NULL))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)417, "smartlist_split_string", "end");
      abort();
    }

    if(*end == 0)
      next = (const char *)(void *)0;

    else
      if(!(sep == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(sep);
        next = end + (signed long int)return_value_strlen_6;
      }

      else
      {
        next = end + (signed long int)1;
        for( ; (_Bool)1; next = next + 1l)
          if(!((signed int)*next == 9))
          {
            if(!((signed int)*next == 32))
              goto __CPROVER_DUMP_L21;

          }

      }

  __CPROVER_DUMP_L21:
    ;
    if(!((0x01 & flags) == 0))
      for( ; !(cp >= end); end = end - 1l)
      {
        return_value_TOR_ISSPACE_7=TOR_ISSPACE(*(end - (signed long int)1));
        if(return_value_TOR_ISSPACE_7 == 0)
          break;

      }

    if((0x02 & flags) == 0 || !(end == cp))
    {
      char *string;
      string=tor_strndup_(cp, (unsigned long int)(end - cp));
      if(!((0x04 & flags) == 0))
        tor_strstrip(string, " ");

      smartlist_add(sl, (void *)string);
      n = n + 1;
    }

    if(next == ((const char *)NULL))
      break;

  }
  return n;
}

// smartlist_string_pos
// file ../src/common/container.c line 201
signed int smartlist_string_pos(const struct smartlist_t *sl, const char *element)
{
  signed int i;
  signed int tmp_statement_expression_1;
  if(sl == ((const struct smartlist_t *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= sl->num_used); i = i + 1)
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp((const char *)sl->list[(signed long int)i], element);
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
        return i;

    }
    return -1;
  }
}

// smartlist_string_remove
// file ../src/common/container.c line 158
void smartlist_string_remove(struct smartlist_t *sl, const char *element)
{
  signed int i;
  if(sl == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)161, "smartlist_string_remove", "sl");
    abort();
  }

  if(element == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)162, "smartlist_string_remove", "element");
    abort();
  }

  i = 0;
  signed int tmp_statement_expression_1;
  for( ; !(i >= sl->num_used); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(element, (const char *)sl->list[(signed long int)i]);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
    {
      if(!(sl->list[(signed long int)i] == NULL))
      {
        free(sl->list[(signed long int)i]);
        sl->list[(signed long int)i] = (void *)0;
      }

      sl->num_used = sl->num_used - 1;
      sl->list[(signed long int)i] = sl->list[(signed long int)sl->num_used];
      i = i - 1;
    }

  }
}

// smartlist_strings_eq
// file ../src/common/container.c line 239
signed int smartlist_strings_eq(const struct smartlist_t *sl1, const struct smartlist_t *sl2)
{
  signed int tmp_statement_expression_1;
  if(sl1 == ((const struct smartlist_t *)NULL))
    return (signed int)(sl2 == (const struct smartlist_t *)(void *)0);

  else
    if(sl2 == ((const struct smartlist_t *)NULL))
      return 0;

    else
      if(!(sl1->num_used == sl2->num_used))
        return 0;

      else
      {
        signed int cp1_sl_idx;
        signed int cp1_sl_len = sl1->num_used;
        const char *cp1;
        cp1_sl_idx = 0;
        for( ; !(cp1_sl_idx >= cp1_sl_len); cp1_sl_idx = cp1_sl_idx + 1)
        {
          cp1 = (const char *)sl1->list[(signed long int)cp1_sl_idx];
          const char *cp2 = (const char *)sl2->list[(signed long int)cp1_sl_idx];
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_2;
          return_value___builtin_strcmp_2=__builtin_strcmp(cp1, cp2);
          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
          if(!(tmp_statement_expression_1 == 0))
            return 0;

          cp1 = (const char *)(void *)0;
        }
        return 1;
      }
}

// smartlist_subtract
// file ../src/common/container.c line 318
void smartlist_subtract(struct smartlist_t *sl1, const struct smartlist_t *sl2)
{
  signed int i = 0;
  for( ; !(i >= sl2->num_used); i = i + 1)
    smartlist_remove(sl1, sl2->list[(signed long int)i]);
}

// smartlist_uniq
// file ../src/common/container.c line 567
void smartlist_uniq(struct smartlist_t *sl, signed int (*compare)(const void **, const void **), void (*free_fn)(void *))
{
  signed int i = 1;
  signed int tmp_post_1;
  if(!(i >= sl->num_used))
  {
    signed int return_value;
    return_value=compare((const void **)&sl->list[(signed long int)(i - 1)], (const void **)&sl->list[(signed long int)i]);
    if(return_value == 0)
    {
      if(!(free_fn == ((void (*)(void *))NULL)))
        free_fn(sl->list[(signed long int)i]);

      tmp_post_1 = i;
      i = i - 1;
      smartlist_del_keeporder(sl, tmp_post_1);
    }

    i = i + 1;
  }

}

// smartlist_uniq_digests
// file ../src/common/container.c line 989
void smartlist_uniq_digests(struct smartlist_t *sl)
{
  smartlist_uniq(sl, compare_digests_, tor_free_);
}

// smartlist_uniq_digests256
// file ../src/common/container.c line 1020
void smartlist_uniq_digests256(struct smartlist_t *sl)
{
  smartlist_uniq(sl, compare_digests256_, tor_free_);
}

// smartlist_uniq_strings
// file ../src/common/container.c line 751
void smartlist_uniq_strings(struct smartlist_t *sl)
{
  smartlist_uniq(sl, compare_string_ptrs_, tor_free_);
}

// sock_alert
// file ../src/common/compat_threads.c line 185
static signed int sock_alert(signed int fd)
{
  signed long int r;
  signed int return_value_send_ni_1;
  return_value_send_ni_1=send_ni(fd, (const void *)"x", (unsigned long int)1, 0);
  r = (signed long int)return_value_send_ni_1;
  signed int *return_value___errno_location_2;
  if(!(r >= 0l))
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 11)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// sock_drain
// file ../src/common/compat_threads.c line 194
static signed int sock_drain(signed int fd)
{
  char buf[32l];
  signed long int r;
  do
  {
    signed int return_value_recv_ni_1;
    return_value_recv_ni_1=recv_ni(fd, (void *)buf, sizeof(char [32l]) /*32ul*/ , 0);
    r = (signed long int)return_value_recv_ni_1;
  }
  while(r >= 1l);
  signed int *return_value___errno_location_2;
  if(!(r >= 0l))
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 11)
      goto __CPROVER_DUMP_L2;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return 0;
  }
}

// socket_accounting_lock
// file ../src/common/compat.c line 1049
static inline void socket_accounting_lock(void)
{
  if(socket_accounting_mutex == ((struct tor_mutex_t *)NULL))
    socket_accounting_mutex=tor_mutex_new();

  tor_mutex_acquire(socket_accounting_mutex);
}

// socket_accounting_unlock
// file ../src/common/compat.c line 1058
static inline void socket_accounting_unlock(void)
{
  tor_mutex_release(socket_accounting_mutex);
}

// socks5_reason_to_string
// file ../src/tools/tor-resolve.c line 164
static const char * socks5_reason_to_string(char reason)
{
  switch((signed int)reason)
  {
    case 0:
      return "succeeded";
    case 1:
      return "general error";
    case 2:
      return "not allowed";
    case 3:
      return "network is unreachable";
    case 4:
      return "host is unreachable";
    case 5:
      return "connection refused";
    case 6:
      return "ttl expired";
    case 7:
      return "command not supported";
    case 8:
      return "address type not supported";
    default:
      return "unknown SOCKS5 code";
  }
}

// spawn_exit
// file ../src/common/compat_pthreads.c line 79
void spawn_exit(void)
{
  pthread_exit((void *)0);
}

// spawn_func
// file ../src/common/compat_threads.h line 25
signed int spawn_func(void (*func)(void *), void *data)
{
  unsigned long int thread;
  struct tor_pthread_data_t *d;
  if(threads_initialized == 0)
    tor_threads_init();

  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct tor_pthread_data_t) /*16ul*/ );
  d = (struct tor_pthread_data_t *)return_value_tor_malloc__1;
  d->data = data;
  d->func = func;
  signed int return_value_pthread_create_2;
  return_value_pthread_create_2=pthread_create(&thread, &attr_detached, tor_pthread_helper_fn, (void *)d);
  if(!(return_value_pthread_create_2 == 0))
    return -1;

  else
    return 0;
}

// start_daemon
// file ../src/common/util.c line 3451
void start_daemon(void)
{
  signed int pid;
  signed long int return_value_read_4;
  if(start_daemon_called == 0)
  {
    start_daemon_called = 1;
    signed int return_value_pipe_3;
    return_value_pipe_3=pipe(daemon_filedes);
    if(!(return_value_pipe_3 == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(3, 1u << 0, "start_daemon", "pipe failed; exiting. Error was %s", return_value_strerror_2);
      exit(1);
    }

    pid=fork();
    if(!(pid >= 0))
    {
      log_fn_(3, 1u << 0, "start_daemon", "fork failed. Exiting.");
      exit(1);
    }

    if(!(pid == 0))
    {
      signed int ok;
      char c;
      close(daemon_filedes[(signed long int)1]);
      ok = -1;
      do
      {
        return_value_read_4=read_link1(daemon_filedes[(signed long int)0], (void *)&c, sizeof(char) /*1ul*/ );
        if(!(return_value_read_4 >= 1l))
          break;

        if((signed int)c == 46)
          ok = 1;

      }
      while((_Bool)1);
      fflush(stdout);
      if(ok == 1)
        exit(0);

      else
        exit(1);
    }

    else
    {
      close(daemon_filedes[(signed long int)0]);
      pid=setsid();
      signed int return_value_fork_5;
      return_value_fork_5=fork();
      if(!(return_value_fork_5 == 0))
        exit(0);

      set_main_thread();
      goto __CPROVER_DUMP_L12;
    }
  }


__CPROVER_DUMP_L12:
  ;
}

// start_writing_to_file
// file ../src/common/util.c line 2296
signed int start_writing_to_file(const char *fname, signed int open_flags, signed int mode, struct open_file_t **data_out)
{
  struct open_file_t *new_file;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct open_file_t) /*32ul*/ );
  new_file = (struct open_file_t *)return_value_tor_malloc_zero__1;
  const char *open_name;
  signed int append = 0;
  if(fname == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2303, "start_writing_to_file", "fname");
    abort();
  }

  if(data_out == ((struct open_file_t **)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)2304, "start_writing_to_file", "data_out");
    abort();
  }

  new_file->fd = -1;
  new_file->filename=tor_strdup_(fname);
  if(!((02000 & open_flags) == 0))
  {
    open_name = fname;
    new_file->rename_on_close = (unsigned int)0;
    append = 1;
    open_flags = open_flags & ~02000;
  }

  else
  {
    tor_asprintf(&new_file->tempname, "%s.tmp", fname);
    open_name = new_file->tempname;
    open_flags = open_flags | 0100 | 01000;
    open_flags = open_flags & ~0200;
    new_file->rename_on_close = (unsigned int)1;
  }
  new_file->fd=tor_open_cloexec(open_name, open_flags, (unsigned int)mode);
  if(!(new_file->fd >= 0))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    log_fn_(4, 1u << 4, "start_writing_to_file", "Couldn't open \"%s\" (%s) for writing: %s", open_name, fname, return_value_strerror_3);
    goto err;
  }

  if(!(append == 0))
  {
    signed int return_value_tor_fd_seekend_6;
    return_value_tor_fd_seekend_6=tor_fd_seekend(new_file->fd);
    if(!(return_value_tor_fd_seekend_6 >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_fn_(4, 1u << 4, "start_writing_to_file", "Couldn't seek to end of file \"%s\": %s", open_name, return_value_strerror_5);
      goto err;
    }

  }

  *data_out = new_file;
  return new_file->fd;

err:
  ;
  if(new_file->fd >= 0)
    close(new_file->fd);

  *data_out = (struct open_file_t *)(void *)0;
  if(!(new_file->filename == ((char *)NULL)))
  {
    free((void *)new_file->filename);
    new_file->filename = (char *)(void *)0;
  }

  if(!(new_file->tempname == ((char *)NULL)))
  {
    free((void *)new_file->tempname);
    new_file->tempname = (char *)(void *)0;
  }

  if(!(new_file == ((struct open_file_t *)NULL)))
  {
    free((void *)new_file);
    new_file = (struct open_file_t *)(void *)0;
  }

  return -1;
}

// start_writing_to_stdio_file
// file ../src/common/util.c line 2377
struct _IO_FILE * start_writing_to_stdio_file(const char *fname, signed int open_flags, signed int mode, struct open_file_t **data_out)
{
  struct _IO_FILE *res;
  signed int return_value_start_writing_to_file_1;
  return_value_start_writing_to_file_1=start_writing_to_file(fname, open_flags, mode, data_out);
  if(!(return_value_start_writing_to_file_1 >= 0))
    return (struct _IO_FILE *)(void *)0;

  else
  {
    res=fdopen_file(*data_out);
    if(res == ((struct _IO_FILE *)NULL))
    {
      abort_writing_to_file(*data_out);
      *data_out = (struct open_file_t *)(void *)0;
    }

    return res;
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// str_num_before
// file ../src/common/util.c line 4465
static inline unsigned long int str_num_before(const char *s, char ch)
{
  const char *cp;
  char *return_value___builtin_strchr_1;
  return_value___builtin_strchr_1=__builtin_strchr(s, (signed int)ch);
  cp = return_value___builtin_strchr_1;
  unsigned long int return_value_strlen_2;
  if(!(cp == ((const char *)NULL)))
    return (unsigned long int)(cp - s);

  else
  {
    return_value_strlen_2=strlen(s);
    return return_value_strlen_2;
  }
}

// strcasecmpend
// file ../src/tools/../common/util.h line 210
signed int strcasecmpend(const char *s1, const char *s2)
{
  unsigned long int n1;
  n1=strlen(s1);
  unsigned long int n2;
  n2=strlen(s2);
  signed int return_value_strcasecmp_1;
  signed int return_value_strncasecmp_2;
  if(!(n1 >= n2))
  {
    return_value_strcasecmp_1=strcasecmp(s1, s2);
    return return_value_strcasecmp_1;
  }

  else
  {
    return_value_strncasecmp_2=strncasecmp(s1 + (signed long int)(n1 - n2), s2, n2);
    return return_value_strncasecmp_2;
  }
}

// strcasecmpstart
// file ../src/common/util.h line 208
signed int strcasecmpstart(const char *s1, const char *s2)
{
  unsigned long int n;
  n=strlen(s2);
  signed int return_value_strncasecmp_1;
  return_value_strncasecmp_1=strncasecmp(s1, s2, n);
  return return_value_strncasecmp_1;
}

// strcmp_len
// file ../src/common/util.c line 712
signed int strcmp_len(const char *s1, const char *s2, unsigned long int s1_len)
{
  unsigned long int s2_len;
  s2_len=strlen(s2);
  if(!(s1_len >= s2_len))
    return -1;

  else
    if(!(s2_len >= s1_len))
      return 1;

    else
    {
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)s1, (const void *)s2, s2_len);
      return return_value_memcmp_1;
    }
}

// strcmp_opt
// file ../src/common/util.c line 683
signed int strcmp_opt(const char *s1, const char *s2)
{
  signed int tmp_statement_expression_1;
  if(s1 == ((const char *)NULL))
  {
    if(s2 == ((const char *)NULL))
      return 0;

    else
      return -1;
  }

  else
    if(s2 == ((const char *)NULL))
      return 1;

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(s1, s2);
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      return tmp_statement_expression_1;
    }
}

// strcmpend
// file ../src/common/util.c line 736
signed int strcmpend(const char *s1, const char *s2)
{
  unsigned long int n1;
  n1=strlen(s1);
  unsigned long int n2;
  n2=strlen(s2);
  signed int tmp_statement_expression_1;
  signed int return_value_strncmp_3;
  if(!(n1 >= n2))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(s1, s2);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    return tmp_statement_expression_1;
  }

  else
  {
    return_value_strncmp_3=strncmp(s1 + (signed long int)(n1 - n2), s2, n2);
    return return_value_strncmp_3;
  }
}

// strcmpstart
// file ../src/common/util.c line 701
signed int strcmpstart(const char *s1, const char *s2)
{
  unsigned long int n;
  n=strlen(s2);
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(s1, s2, n);
  return return_value_strncmp_1;
}

// stream_status_to_string
// file ../src/common/util.c line 4832
const char * stream_status_to_string(enum stream_status stream_status)
{
  switch((signed int)stream_status)
  {
    case IO_STREAM_OKAY:
      return "okay";
    case IO_STREAM_EAGAIN:
      return "temporarily unavailable";
    case IO_STREAM_TERM:
      return "terminated";
    case IO_STREAM_CLOSED:
      return "closed";
    default:
      return "unknown";
  }
}

// string_is_C_identifier
// file ../src/common/util.c line 934
signed int string_is_C_identifier(const char *string)
{
  unsigned long int iter;
  unsigned long int length;
  length=strlen(string);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  signed int return_value_TOR_ISDIGIT_4;
  _Bool tmp_if_expr_6;
  if(length == 0ul)
    return 0;

  else
  {
    iter = (unsigned long int)0;
    for( ; !(iter >= length); iter = iter + 1ul)
      if(iter == 0ul)
      {
        signed int return_value_TOR_ISALPHA_1;
        return_value_TOR_ISALPHA_1=TOR_ISALPHA(string[(signed long int)iter]);
        if(!(return_value_TOR_ISALPHA_1 == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)string[(signed long int)iter] == 95 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_2)
          return 0;

      }

      else
      {
        signed int return_value_TOR_ISALPHA_3;
        return_value_TOR_ISALPHA_3=TOR_ISALPHA(string[(signed long int)iter]);
        if(!(return_value_TOR_ISALPHA_3 == 0))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_TOR_ISDIGIT_4=TOR_ISDIGIT_link1(string[(signed long int)iter]);
          tmp_if_expr_5 = return_value_TOR_ISDIGIT_4 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)string[(signed long int)iter] == 95 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_6)
          return 0;

      }
    return 1;
  }
}

// string_is_key_value
// file ../src/common/util.c line 993
signed int string_is_key_value(signed int severity, const char *string)
{
  const char *equal_sign_pos = (const char *)(void *)0;
  if(string == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)998, "string_is_key_value", "string");
    abort();
  }

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(string);
  if(!(return_value_strlen_2 >= 2ul))
  {
    const char *return_value_escaped_1;
    return_value_escaped_1=escaped(string);
    tor_log(severity, 1u << 0, "'%s' is too short to be a k=v value.", return_value_escaped_1);
    return 0;
  }

  char *return_value___builtin_strchr_3;
  return_value___builtin_strchr_3=__builtin_strchr(string, 61);
  equal_sign_pos = return_value___builtin_strchr_3;
  if(equal_sign_pos == ((const char *)NULL))
  {
    const char *return_value_escaped_4;
    return_value_escaped_4=escaped(string);
    tor_log(severity, 1u << 0, "'%s' is not a k=v value.", return_value_escaped_4);
    return 0;
  }

  if(equal_sign_pos == string)
  {
    const char *return_value_escaped_5;
    return_value_escaped_5=escaped(string);
    tor_log(severity, 1u << 0, "'%s' is not a valid k=v value.", return_value_escaped_5);
    return 0;
  }

  return 1;
}

// string_is_valid_hostname
// file ../src/common/util.c line 1048
signed int string_is_valid_hostname(const char *string)
{
  signed int result = 1;
  struct smartlist_t *components;
  components=smartlist_new();
  smartlist_split_string(components, string, ".", 0, 0);
  signed int string_is_valid_hostname__1__1__c_sl_idx;
  signed int string_is_valid_hostname__1__1__c_sl_len = components->num_used;
  char *c;
  string_is_valid_hostname__1__1__c_sl_idx = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_1;
  for( ; !(string_is_valid_hostname__1__1__c_sl_idx >= string_is_valid_hostname__1__1__c_sl_len); string_is_valid_hostname__1__1__c_sl_idx = string_is_valid_hostname__1__1__c_sl_idx + 1)
  {
    c = (char *)components->list[(signed long int)string_is_valid_hostname__1__1__c_sl_idx];
    if((signed int)*c == 45)
    {
      result = 0;
      break;
    }

    do
    {
      if((signed int)*c >= 97)
        tmp_if_expr_2 = (signed int)*c <= 122 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        if((signed int)*c >= 65)
          tmp_if_expr_3 = (signed int)*c <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if((signed int)*c >= 48)
          tmp_if_expr_5 = (signed int)*c <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)*c == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
        c = c + 1l;

      else
        result = 0;
      if(!(result == 0))
        tmp_if_expr_1 = *c != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
    }
    while(tmp_if_expr_1);
    c = (char *)(void *)0;
  }
  signed int c_sl_idx;
  signed int c_sl_len = components->num_used;
  char *string_is_valid_hostname__1__2__c;
  c_sl_idx = 0;
  for( ; !(c_sl_idx >= c_sl_len); c_sl_idx = c_sl_idx + 1)
  {
    string_is_valid_hostname__1__2__c = (char *)components->list[(signed long int)c_sl_idx];
    if(!(string_is_valid_hostname__1__2__c == ((char *)NULL)))
    {
      free((void *)string_is_valid_hostname__1__2__c);
      string_is_valid_hostname__1__2__c = (char *)(void *)0;
    }

    string_is_valid_hostname__1__2__c = (char *)(void *)0;
  }
  smartlist_free(components);
  return result;
}

// string_is_valid_ipv4_address
// file ../src/common/util.c line 1026
signed int string_is_valid_ipv4_address(const char *string)
{
  struct in_addr addr;
  signed int return_value_tor_inet_pton_1;
  return_value_tor_inet_pton_1=tor_inet_pton(2, string, (void *)&addr);
  return (signed int)(return_value_tor_inet_pton_1 == 1);
}

// string_is_valid_ipv6_address
// file ../src/common/util.c line 1037
signed int string_is_valid_ipv6_address(const char *string)
{
  struct in6_addr addr;
  signed int return_value_tor_inet_pton_1;
  return_value_tor_inet_pton_1=tor_inet_pton(10, string, (void *)&addr);
  return (signed int)(return_value_tor_inet_pton_1 == 1);
}

// strlcat
// file ../src/ext/strlcat.c line 45
unsigned long int strlcat(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int dlen;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    if((signed int)*d == 0)
      break;

    d = d + 1l;
  }
  while((_Bool)1);
  dlen = (unsigned long int)(d - dst);
  n = siz - dlen;
  unsigned long int return_value_strlen_2;
  char *tmp_post_3;
  if(n == 0ul)
  {
    return_value_strlen_2=strlen(s);
    return dlen + return_value_strlen_2;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_3 = d;
        d = d + 1l;
        *tmp_post_3 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return dlen + (unsigned long int)(s - src);
  }
}

// strlcpy
// file ../src/ext/strlcpy.c line 42
unsigned long int strlcpy(char *dst, const char *src, unsigned long int siz)
{
  char *d = dst;
  const char *s = src;
  unsigned long int n = siz;
  unsigned long int return_value_strlen_1;
  char *tmp_post_2;
  if(n == 0ul)
  {
    return_value_strlen_1=strlen(s);
    return return_value_strlen_1;
  }

  else
  {
    for( ; !((signed int)*s == 0); s = s + 1l)
      if(!(n == 1ul))
      {
        tmp_post_2 = d;
        d = d + 1l;
        *tmp_post_2 = *s;
        n = n - 1ul;
      }

    *d = (char)0;
    return (unsigned long int)(s - src);
  }
}

// strmap_assert_ok
// file ../src/common/container.c line 1365
void strmap_assert_ok(const struct strmap_t *map)
{
  signed int return_value_strmap_impl_HT_REP_IS_BAD__1;
  return_value_strmap_impl_HT_REP_IS_BAD__1=strmap_impl_HT_REP_IS_BAD_(&map->head);
  if(!(return_value_strmap_impl_HT_REP_IS_BAD__1 == 0))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_assert_ok", "!strmap_impl_HT_REP_IS_BAD_(&map->head)");
    abort();
  }

}

// strmap_assign_key
// file ../src/common/container.c line 1136
static inline void strmap_assign_key(struct strmap_entry_t *ent, const char *key)
{
  ent->key=tor_strdup_(key);
}

// strmap_assign_tmp_key
// file ../src/common/container.c line 1121
static inline void strmap_assign_tmp_key(struct strmap_entry_t *ent, const char *key)
{
  ent->key = (char *)key;
}

// strmap_entries_eq
// file ../src/common/container.c line 1045
static inline signed int strmap_entries_eq(const struct strmap_entry_t *a, const struct strmap_entry_t *b)
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp(a->key, b->key);
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  return (signed int)!(tmp_statement_expression_1 != 0);
}

// strmap_entry_free
// file ../src/common/container.c line 1104
static inline void strmap_entry_free(struct strmap_entry_t *ent)
{
  if(!(ent->key == ((char *)NULL)))
  {
    free((void *)ent->key);
    ent->key = (char *)(void *)0;
  }

  if(!(ent == ((struct strmap_entry_t *)NULL)))
  {
    free((void *)ent);
    ent = (struct strmap_entry_t *)(void *)0;
  }

}

// strmap_entry_hash
// file ../src/common/container.c line 1052
static inline unsigned int strmap_entry_hash(const struct strmap_entry_t *a)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(a->key);
  unsigned long int return_value_siphash24g_2;
  return_value_siphash24g_2=siphash24g((const void *)a->key, return_value_strlen_1);
  return (unsigned int)return_value_siphash24g_2;
}

// strmap_free
// file ../src/common/container.c line 1365
void strmap_free(struct strmap_t *map, void (*free_val)(void *))
{
  struct strmap_entry_t **ent;
  struct strmap_entry_t **next;
  struct strmap_entry_t *this;
  if(!(map == ((struct strmap_t *)NULL)))
  {
    ent=strmap_impl_HT_START(&map->head);
    for( ; !(ent == ((struct strmap_entry_t **)NULL)); ent = next)
    {
      this = *ent;
      next=strmap_impl_HT_NEXT_RMV(&map->head, ent);
      if(!(free_val == ((void (*)(void *))NULL)))
        free_val(this->val);

      strmap_entry_free(this);
    }
    if(!(map->head.hth_n_entries == 0u))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_free", "HT_EMPTY(&map->head)");
      abort();
    }

    strmap_impl_HT_CLEAR(&map->head);
    if(!(map == ((struct strmap_t *)NULL)))
    {
      free((void *)map);
      map = (struct strmap_t *)(void *)0;
    }

  }

}

// strmap_get
// file ../src/common/container.c line 1365
void * strmap_get(const struct strmap_t *map, const char *key)
{
  struct strmap_entry_t *resolve;
  struct strmap_entry_t search;
  if(map == ((const struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_get", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_get", "key");
    abort();
  }

  strmap_assign_tmp_key(&search, key);
  resolve=strmap_impl_HT_FIND(&map->head, &search);
  if(!(resolve == ((struct strmap_entry_t *)NULL)))
    return resolve->val;

  else
    return (void *)0;
}

// strmap_get_lc
// file ../src/common/container.c line 1385
void * strmap_get_lc(const struct strmap_t *map, const char *key)
{
  void *v;
  char *lc_key;
  lc_key=tor_strdup_(key);
  tor_strlower(lc_key);
  v=strmap_get(map, lc_key);
  if(!(lc_key == ((char *)NULL)))
  {
    free((void *)lc_key);
    lc_key = (char *)(void *)0;
  }

  return v;
}

// strmap_impl_HT_CLEAR
// file ../src/common/container.c line 1088
void strmap_impl_HT_CLEAR(struct strmap_impl *head)
{
  if(!(head->hth_table == ((struct strmap_entry_t **)NULL)))
    tor_free_((void *)head->hth_table);

  head->hth_table_length = (unsigned int)0;
  strmap_impl_HT_INIT(head);
}

// strmap_impl_HT_FIND
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t * strmap_impl_HT_FIND(struct strmap_impl *head, struct strmap_entry_t *elm)
{
  struct strmap_entry_t **p;
  struct strmap_impl *h = (struct strmap_impl *)head;
  do
    elm->node.hte_hash=strmap_entry_hash(elm);
  while((_Bool)0);
  p=strmap_impl_HT_FIND_P_(h, elm);
  struct strmap_entry_t *tmp_if_expr_1;
  if(!(p == ((struct strmap_entry_t **)NULL)))
    tmp_if_expr_1 = *p;

  else
    tmp_if_expr_1 = (struct strmap_entry_t *)(void *)0;
  return tmp_if_expr_1;
}

// strmap_impl_HT_FIND_P_
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_FIND_P_(struct strmap_impl *head, struct strmap_entry_t *elm)
{
  struct strmap_entry_t **p;
  if(head->hth_table == ((struct strmap_entry_t **)NULL))
    return (struct strmap_entry_t **)(void *)0;

  else
  {
    p = &head->hth_table[(signed long int)(elm->node.hte_hash % head->hth_table_length)];
    while(!(*p == ((struct strmap_entry_t *)NULL)))
    {
      signed int return_value_strmap_entries_eq_1;
      return_value_strmap_entries_eq_1=strmap_entries_eq(*p, elm);
      if(!(return_value_strmap_entries_eq_1 == 0))
        return p;

      p = &(*p)->node.hte_next;
    }
    return p;
  }
}

// strmap_impl_HT_GROW
// file ../src/common/container.c line 1088
signed int strmap_impl_HT_GROW(struct strmap_impl *head, unsigned int size)
{
  unsigned int new_len;
  unsigned int new_load_limit;
  signed int prime_idx;
  struct strmap_entry_t **new_table;
  if(head->hth_prime_idx == (signed int)strmap_impl_N_PRIMES + -1)
    return 0;

  else
    if(!(size >= head->hth_load_limit))
      return 0;

    else
    {
      prime_idx = head->hth_prime_idx;
      do
      {
        prime_idx = prime_idx + 1;
        new_len = strmap_impl_PRIMES[(signed long int)prime_idx];
        new_load_limit = (unsigned int)(0.6 * (double)new_len);
      }
      while(size >= new_load_limit && !(prime_idx >= (signed int)strmap_impl_N_PRIMES));
      void *return_value_tor_reallocarray__2;
      return_value_tor_reallocarray__2=tor_reallocarray_((void *)0, (unsigned long int)new_len, sizeof(struct strmap_entry_t *) /*8ul*/ );
      new_table = (struct strmap_entry_t **)return_value_tor_reallocarray__2;
      if(!(new_table == ((struct strmap_entry_t **)NULL)))
      {
        unsigned int b;
        memset_link4((void *)new_table, 0, (unsigned long int)new_len * sizeof(struct strmap_entry_t *) /*8ul*/ );
        b = (unsigned int)0;
        for( ; !(b >= head->hth_table_length); b = b + 1u)
        {
          struct strmap_entry_t *elm;
          struct strmap_entry_t *next;
          unsigned int b2;
          elm = head->hth_table[(signed long int)b];
          for( ; !(elm == ((struct strmap_entry_t *)NULL)); elm = next)
          {
            next = elm->node.hte_next;
            b2 = elm->node.hte_hash % new_len;
            elm->node.hte_next = new_table[(signed long int)b2];
            new_table[(signed long int)b2] = elm;
          }
        }
        if(!(head->hth_table == ((struct strmap_entry_t **)NULL)))
          tor_free_((void *)head->hth_table);

        head->hth_table = new_table;
      }

      else
      {
        unsigned int strmap_impl_HT_GROW__1__3__b;
        unsigned int strmap_impl_HT_GROW__1__3__b2;
        void *return_value_tor_reallocarray__1;
        return_value_tor_reallocarray__1=tor_reallocarray_((void *)head->hth_table, (unsigned long int)new_len, sizeof(struct strmap_entry_t *) /*8ul*/ );
        new_table = (struct strmap_entry_t **)return_value_tor_reallocarray__1;
        if(new_table == ((struct strmap_entry_t **)NULL))
          return -1;

        memset_link4((void *)(new_table + (signed long int)head->hth_table_length), 0, (unsigned long int)(new_len - head->hth_table_length) * sizeof(struct strmap_entry_t *) /*8ul*/ );
        strmap_impl_HT_GROW__1__3__b = (unsigned int)0;
        for( ; !(strmap_impl_HT_GROW__1__3__b >= head->hth_table_length); strmap_impl_HT_GROW__1__3__b = strmap_impl_HT_GROW__1__3__b + 1u)
        {
          struct strmap_entry_t *e;
          struct strmap_entry_t **pE = &new_table[(signed long int)strmap_impl_HT_GROW__1__3__b];
          e = *pE;
          for( ; !(e == ((struct strmap_entry_t *)NULL)); e = *pE)
          {
            strmap_impl_HT_GROW__1__3__b2 = e->node.hte_hash % new_len;
            if(strmap_impl_HT_GROW__1__3__b2 == strmap_impl_HT_GROW__1__3__b)
              pE = &e->node.hte_next;

            else
            {
              *pE = e->node.hte_next;
              e->node.hte_next = new_table[(signed long int)strmap_impl_HT_GROW__1__3__b2];
              new_table[(signed long int)strmap_impl_HT_GROW__1__3__b2] = e;
            }
          }
        }
        head->hth_table = new_table;
      }
      head->hth_table_length = new_len;
      head->hth_prime_idx = prime_idx;
      head->hth_load_limit = new_load_limit;
      return 0;
    }
}

// strmap_impl_HT_INIT
// file ../src/common/container.c line 1086
static inline void strmap_impl_HT_INIT(struct strmap_impl *head)
{
  head->hth_table_length = (unsigned int)0;
  head->hth_table = (struct strmap_entry_t **)(void *)0;
  head->hth_n_entries = (unsigned int)0;
  head->hth_load_limit = (unsigned int)0;
  head->hth_prime_idx = -1;
}

// strmap_impl_HT_NEXT
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_NEXT(struct strmap_impl *head, struct strmap_entry_t **elm)
{
  if(!((*elm)->node.hte_next == ((struct strmap_entry_t *)NULL)))
  {
    if(!((*elm)->node.hte_hash % head->hth_table_length == (*elm)->node.hte_next->node.hte_hash % head->hth_table_length))
    {
      tor_assertion_failed_("../src/common/container.c", (unsigned int)1087, "strmap_impl_HT_NEXT", "(((*elm)->node.hte_hash) % head->hth_table_length) == ((((*elm)->node.hte_next)->node.hte_hash) % head->hth_table_length)");
      abort();
    }

    return &(*elm)->node.hte_next;
  }

  else
  {
    unsigned int b = (*elm)->node.hte_hash % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct strmap_entry_t *)NULL)))
      {
        if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
        {
          tor_assertion_failed_("../src/common/container.c", (unsigned int)1087, "strmap_impl_HT_NEXT", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
          abort();
        }

        return &head->hth_table[(signed long int)b];
      }

    return (struct strmap_entry_t **)(void *)0;
  }
}

// strmap_impl_HT_NEXT_RMV
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_NEXT_RMV(struct strmap_impl *head, struct strmap_entry_t **elm)
{
  unsigned int h = (*elm)->node.hte_hash;
  *elm = (*elm)->node.hte_next;
  head->hth_n_entries = head->hth_n_entries - 1u;
  if(!(*elm == ((struct strmap_entry_t *)NULL)))
    return elm;

  else
  {
    unsigned int b = h % head->hth_table_length + (unsigned int)1;
    for( ; !(b >= head->hth_table_length); b = b + 1u)
      if(!(head->hth_table[(signed long int)b] == ((struct strmap_entry_t *)NULL)))
        return &head->hth_table[(signed long int)b];

    return (struct strmap_entry_t **)(void *)0;
  }
}

// strmap_impl_HT_REMOVE
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t * strmap_impl_HT_REMOVE(struct strmap_impl *head, struct strmap_entry_t *elm)
{
  struct strmap_entry_t **p;
  struct strmap_entry_t *r;
  do
    elm->node.hte_hash=strmap_entry_hash(elm);
  while((_Bool)0);
  p=strmap_impl_HT_FIND_P_(head, elm);
  _Bool tmp_if_expr_1;
  if(p == ((struct strmap_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*p != ((struct strmap_entry_t *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct strmap_entry_t *)(void *)0;

  else
  {
    r = *p;
    *p = r->node.hte_next;
    r->node.hte_next = (struct strmap_entry_t *)(void *)0;
    head->hth_n_entries = head->hth_n_entries - 1u;
    return r;
  }
}

// strmap_impl_HT_REP_IS_BAD_
// file ../src/common/container.c line 1088
signed int strmap_impl_HT_REP_IS_BAD_(struct strmap_impl *head)
{
  unsigned int n;
  unsigned int i;
  struct strmap_entry_t *elm;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(head->hth_table_length == 0u)
  {
    if(head->hth_table == ((struct strmap_entry_t **)NULL))
      tmp_if_expr_1 = !(head->hth_n_entries != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = head->hth_prime_idx == -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      return 0;

    return 1;
  }

  else
  {
    if(head->hth_table == ((struct strmap_entry_t **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = head->hth_prime_idx < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(head->hth_load_limit != 0u) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 2;

    else
      if(!(head->hth_load_limit >= head->hth_n_entries))
        return 3;

      else
        if(!(head->hth_table_length == strmap_impl_PRIMES[(signed long int)head->hth_prime_idx]))
          return 4;

        else
          if(!(head->hth_load_limit == (unsigned int)(0.6 * (double)head->hth_table_length)))
            return 5;

          else
          {
            i = (unsigned int)0;
            n = i;
            for( ; !(i >= head->hth_table_length); i = i + 1u)
            {
              elm = head->hth_table[(signed long int)i];
              for( ; !(elm == ((struct strmap_entry_t *)NULL)); elm = elm->node.hte_next)
              {
                unsigned int return_value_strmap_entry_hash_6;
                return_value_strmap_entry_hash_6=strmap_entry_hash(elm);
                if(!(elm->node.hte_hash == return_value_strmap_entry_hash_6))
                  return (signed int)((unsigned int)1000 + i);

                if(!(elm->node.hte_hash % head->hth_table_length == i))
                  return (signed int)((unsigned int)10000 + i);

                n = n + 1u;
              }
            }
            if(!(n == head->hth_n_entries))
              return 6;

            else
              return 0;
          }
  }
}

// strmap_impl_HT_START
// file ../src/common/container.c line 1086
static inline struct strmap_entry_t ** strmap_impl_HT_START(struct strmap_impl *head)
{
  unsigned int b = (unsigned int)0;
  for( ; !(b >= head->hth_table_length); b = b + 1u)
    if(!(head->hth_table[(signed long int)b] == ((struct strmap_entry_t *)NULL)))
    {
      if(!(b == head->hth_table[(signed long int)b]->node.hte_hash % head->hth_table_length))
      {
        tor_assertion_failed_("../src/common/container.c", (unsigned int)1087, "strmap_impl_HT_START", "b == (((head->hth_table[b])->node.hte_hash) % head->hth_table_length)");
        abort();
      }

      return &head->hth_table[(signed long int)b];
    }

  return (struct strmap_entry_t **)(void *)0;
}

// strmap_isempty
// file ../src/common/container.c line 1365
signed int strmap_isempty(const struct strmap_t *map)
{
  return (signed int)((&map->head)->hth_n_entries == (unsigned int)0 ? (_Bool)1 : (0 != 0 ? (_Bool)1 : (_Bool)0));
}

// strmap_iter_done
// file ../src/common/container.c line 1365
signed int strmap_iter_done(struct strmap_entry_t **iter)
{
  return (signed int)(iter == (struct strmap_entry_t **)(void *)0);
}

// strmap_iter_get
// file ../src/common/container.c line 1365
void strmap_iter_get(struct strmap_entry_t **iter, const char **keyp, void **valp)
{
  if(iter == ((struct strmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_get", "iter");
    abort();
  }

  if(*iter == ((struct strmap_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_get", "*iter");
    abort();
  }

  if(keyp == ((const char **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_get", "keyp");
    abort();
  }

  if(valp == ((void **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_get", "valp");
    abort();
  }

  *keyp = (*iter)->key;
  *valp = (*iter)->val;
}

// strmap_iter_init
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_init(struct strmap_t *map)
{
  if(map == ((struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_init", "map");
    abort();
  }

  struct strmap_entry_t **return_value_strmap_impl_HT_START_1;
  return_value_strmap_impl_HT_START_1=strmap_impl_HT_START(&map->head);
  return return_value_strmap_impl_HT_START_1;
}

// strmap_iter_next
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_next(struct strmap_t *map, struct strmap_entry_t **iter)
{
  if(map == ((struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_next", "map");
    abort();
  }

  if(iter == ((struct strmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_next", "iter");
    abort();
  }

  struct strmap_entry_t **return_value_strmap_impl_HT_NEXT_1;
  return_value_strmap_impl_HT_NEXT_1=strmap_impl_HT_NEXT(&map->head, iter);
  return return_value_strmap_impl_HT_NEXT_1;
}

// strmap_iter_next_rmv
// file ../src/common/container.c line 1365
struct strmap_entry_t ** strmap_iter_next_rmv(struct strmap_t *map, struct strmap_entry_t **iter)
{
  struct strmap_entry_t *rmv;
  if(map == ((struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_next_rmv", "map");
    abort();
  }

  if(iter == ((struct strmap_entry_t **)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_next_rmv", "iter");
    abort();
  }

  if(*iter == ((struct strmap_entry_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_iter_next_rmv", "*iter");
    abort();
  }

  rmv = *iter;
  iter=strmap_impl_HT_NEXT_RMV(&map->head, iter);
  strmap_entry_free(rmv);
  return iter;
}

// strmap_new
// file ../src/common/container.c line 1365
struct strmap_t * strmap_new(void)
{
  struct strmap_t *result;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct strmap_t) /*24ul*/ );
  result = (struct strmap_t *)return_value_tor_malloc__1;
  strmap_impl_HT_INIT(&result->head);
  return result;
}

// strmap_remove
// file ../src/common/container.c line 1365
void * strmap_remove(struct strmap_t *map, const char *key)
{
  struct strmap_entry_t *resolve;
  struct strmap_entry_t search;
  void *oldval;
  if(map == ((struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_remove", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_remove", "key");
    abort();
  }

  strmap_assign_tmp_key(&search, key);
  resolve=strmap_impl_HT_REMOVE(&map->head, &search);
  if(!(resolve == ((struct strmap_entry_t *)NULL)))
  {
    oldval = resolve->val;
    strmap_entry_free(resolve);
    return oldval;
  }

  else
    return (void *)0;
}

// strmap_remove_lc
// file ../src/common/container.c line 1397
void * strmap_remove_lc(struct strmap_t *map, const char *key)
{
  void *v;
  char *lc_key;
  lc_key=tor_strdup_(key);
  tor_strlower(lc_key);
  v=strmap_remove(map, lc_key);
  if(!(lc_key == ((char *)NULL)))
  {
    free((void *)lc_key);
    lc_key = (char *)(void *)0;
  }

  return v;
}

// strmap_set
// file ../src/common/container.c line 1365
void * strmap_set(struct strmap_t *map, const char *key, void *val)
{
  struct strmap_entry_t search;
  void *oldval;
  if(map == ((struct strmap_t *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_set", "map");
    abort();
  }

  if(key == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_set", "key");
    abort();
  }

  if(val == NULL)
  {
    tor_assertion_failed_("../src/common/container.c", (unsigned int)1365, "strmap_set", "val");
    abort();
  }

  strmap_assign_tmp_key(&search, key);
  struct strmap_impl *ptr_head_ = &map->head;
  struct strmap_entry_t **ptr;
  _Bool tmp_if_expr_1;
  if(ptr_head_->hth_table == ((struct strmap_entry_t **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ptr_head_->hth_n_entries >= ptr_head_->hth_load_limit ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    strmap_impl_HT_GROW(ptr_head_, ptr_head_->hth_n_entries + (unsigned int)1);

  do
    (&search)->node.hte_hash=strmap_entry_hash(&search);
  while((_Bool)0);
  ptr=strmap_impl_HT_FIND_P_(ptr_head_, &search);
  if(!(*ptr == ((struct strmap_entry_t *)NULL)))
  {
    oldval = (*ptr)->val;
    (*ptr)->val = val;
    return oldval;
  }

  else
  {
    struct strmap_entry_t *newent;
    void *return_value_tor_malloc_zero__2;
    return_value_tor_malloc_zero__2=tor_malloc_zero_(sizeof(struct strmap_entry_t) /*32ul*/ );
    newent = (struct strmap_entry_t *)return_value_tor_malloc_zero__2;
    strmap_assign_key(newent, key);
    newent->val = val;
    do
      newent->node.hte_hash = (&search)->node.hte_hash;
    while((_Bool)0);
    newent->node.hte_next = (struct strmap_entry_t *)(void *)0;
    *ptr = newent;
    (&map->head)->hth_n_entries = (&map->head)->hth_n_entries + 1u;
    return (void *)0;
  }
}

// strmap_set_lc
// file ../src/common/container.c line 1371
void * strmap_set_lc(struct strmap_t *map, const char *key, void *val)
{
  void *v;
  char *lc_key;
  lc_key=tor_strdup_(key);
  tor_strlower(lc_key);
  v=strmap_set(map, lc_key, val);
  if(!(lc_key == ((char *)NULL)))
  {
    free((void *)lc_key);
    lc_key = (char *)(void *)0;
  }

  return v;
}

// strmap_size
// file ../src/common/container.c line 1365
signed int strmap_size(const struct strmap_t *map)
{
  return (signed int)(&map->head)->hth_n_entries;
}

// strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 117
static inline char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len)
{
  char *return_value___builtin___strncpy_chk_1;
  return_value___builtin___strncpy_chk_1=__builtin___strncpy_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___strncpy_chk_1;
}

// strtok_helper
// file ../src/common/compat.c line 671
static char * strtok_helper(char *cp, const char *sep)
{
  char *return_value___builtin_strchr_1;
  if(!(sep[1l] == 0))
    for( ; !(*cp == 0); cp = cp + 1l)
    {
      return_value___builtin_strchr_1=__builtin_strchr(sep, (signed int)*cp);
      if(return_value___builtin_strchr_1 == ((char *)NULL))
        break;

    }

  else
    for( ; !(*cp == 0); cp = cp + 1l)
      if(!(*cp == *sep))
        break;

  return cp;
}

// switch_id
// file ../src/common/compat.c line 1842
signed int switch_id(const char *user)
{
  struct passwd *pw = (struct passwd *)(void *)0;
  unsigned int old_uid;
  unsigned int old_gid;
  if(user == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)1850, "switch_id", "user");
    abort();
  }

  signed int return_value_setgid_17;
  _Bool tmp_if_expr_19;
  signed int return_value_setegid_18;
  signed int return_value_setuid_20;
  _Bool tmp_if_expr_22;
  signed int return_value_seteuid_21;
  static signed int have_already_switched_id = 0;
  if(!(have_already_switched_id == 0))
    return 0;

  else
  {
    signed int return_value_log_credential_status_1;
    return_value_log_credential_status_1=log_credential_status();
    if(!(return_value_log_credential_status_1 == 0))
      return -1;

    else
    {
      log_fn_(6, 1u << 0, "switch_id", "Changing user and groups");
      old_uid=getuid();
      old_gid=getgid();
      pw=tor_getpwnam(user);
      if(pw == ((struct passwd *)NULL))
      {
        log_fn_(4, 1u << 3, "switch_id", "Error setting configured user: %s not found", user);
        return -1;
      }

      else
      {
        signed int return_value_setgroups_4;
        return_value_setgroups_4=setgroups((unsigned long int)1, &pw->pw_gid);
        if(!(return_value_setgroups_4 == 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          log_fn_(4, 1u << 0, "switch_id", "Error setting groups to gid %d: \"%s\".", (signed int)pw->pw_gid, return_value_strerror_3);
          if(old_uid == pw->pw_uid)
            log_fn_(4, 1u << 0, "switch_id", "Tor is already running as %s.  You do not need the \"User\" option if you are already running as the user you want to be.  (If you did not set the User option in your torrc, check whether it was specified on the command line by a startup script.)", user);

          else
            log_fn_(4, 1u << 0, "switch_id", "If you set the \"User\" option, you must start Tor as root.");
          return -1;
        }

        signed int return_value_setegid_7;
        return_value_setegid_7=setegid(pw->pw_gid);
        if(!(return_value_setegid_7 == 0))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          log_fn_(4, 1u << 0, "switch_id", "Error setting egid to %d: %s", (signed int)pw->pw_gid, return_value_strerror_6);
          return -1;
        }

        signed int return_value_setgid_10;
        return_value_setgid_10=setgid(pw->pw_gid);
        if(!(return_value_setgid_10 == 0))
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(*return_value___errno_location_8);
          log_fn_(4, 1u << 0, "switch_id", "Error setting gid to %d: %s", (signed int)pw->pw_gid, return_value_strerror_9);
          return -1;
        }

        signed int return_value_setuid_13;
        return_value_setuid_13=setuid(pw->pw_uid);
        if(!(return_value_setuid_13 == 0))
        {
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          char *return_value_strerror_12;
          return_value_strerror_12=strerror(*return_value___errno_location_11);
          log_fn_(4, 1u << 0, "switch_id", "Error setting configured uid to %s (%d): %s", user, (signed int)pw->pw_uid, return_value_strerror_12);
          return -1;
        }

        signed int return_value_seteuid_16;
        return_value_seteuid_16=seteuid(pw->pw_uid);
        if(!(return_value_seteuid_16 == 0))
        {
          signed int *return_value___errno_location_14;
          return_value___errno_location_14=__errno_location();
          char *return_value_strerror_15;
          return_value_strerror_15=strerror(*return_value___errno_location_14);
          log_fn_(4, 1u << 0, "switch_id", "Error setting configured euid to %s (%d): %s", user, (signed int)pw->pw_uid, return_value_strerror_15);
          return -1;
        }

        if(!(pw->pw_uid == 0u))
        {
          if(!(pw->pw_gid == old_gid))
          {
            return_value_setgid_17=setgid(old_gid);
            if(!(return_value_setgid_17 == -1))
              tmp_if_expr_19 = (_Bool)1;

            else
            {
              return_value_setegid_18=setegid(old_gid);
              tmp_if_expr_19 = return_value_setegid_18 != -1 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_19)
            {
              log_fn_(4, 1u << 0, "switch_id", "Was able to restore group credentials even after switching GID: this means that the setgid code didn't work.");
              return -1;
            }

          }

          if(!(pw->pw_uid == old_uid))
          {
            return_value_setuid_20=setuid(old_uid);
            if(!(return_value_setuid_20 == -1))
              tmp_if_expr_22 = (_Bool)1;

            else
            {
              return_value_seteuid_21=seteuid(old_uid);
              tmp_if_expr_22 = return_value_seteuid_21 != -1 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_22)
            {
              log_fn_(4, 1u << 0, "switch_id", "Was able to restore user credentials even after switching UID: this means that the setuid code didn't work.");
              return -1;
            }

          }

        }

        signed int return_value_log_credential_status_23;
        return_value_log_credential_status_23=log_credential_status();
        if(!(return_value_log_credential_status_23 == 0))
          return -1;

        else
        {
          have_already_switched_id = 1;
          if(!(pw->pw_uid == 0u))
          {
            log_fn_(6, 1u << 3, "switch_id", "Re-enabling coredumps");
            signed int return_value_prctl_26;
            return_value_prctl_26=prctl(4, 1);
            if(!(return_value_prctl_26 == 0))
            {
              signed int *return_value___errno_location_24;
              return_value___errno_location_24=__errno_location();
              char *return_value_strerror_25;
              return_value_strerror_25=strerror(*return_value___errno_location_24);
              log_fn_(4, 1u << 3, "switch_id", "Unable to re-enable coredumps: %s", return_value_strerror_25);
            }

          }

          return 0;
        }
      }
    }
  }
}

// switch_logs_debug
// file ../src/common/log.c line 1416
void switch_logs_debug(void)
{
  struct logfile_t *lf;
  signed int i;
  tor_mutex_acquire(&log_mutex);
  lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
  {
    i = 7;
    for( ; i >= 3; i = i - 1)
      lf->severities->masks[(signed long int)(i - 3)] = ~0u;
  }
  log_global_min_severity_=get_min_log_level();
  tor_mutex_release(&log_mutex);
}

// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...)
{
  void *return_value___builtin_va_arg_pack_1;
  return_value___builtin_va_arg_pack_1=__builtin_va_arg_pack();
  __syslog_chk(__pri, 2 - 1, __fmt, return_value___builtin_va_arg_pack_1);
}

// threadpool_get_replyqueue
// file ../src/common/workqueue.c line 428
struct replyqueue_s * threadpool_get_replyqueue(struct threadpool_s *tp)
{
  return tp->reply_queue;
}

// threadpool_new
// file ../src/common/workqueue.c line 399
struct threadpool_s * threadpool_new(signed int n_threads, struct replyqueue_s *replyqueue, void * (*new_thread_state_fn)(void *), void (*free_thread_state_fn)(void *), void *arg)
{
  struct threadpool_s *pool;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct threadpool_s) /*184ul*/ );
  pool = (struct threadpool_s *)return_value_tor_malloc_zero__1;
  tor_mutex_init_nonrecursive(&pool->lock);
  tor_cond_init(&pool->condition);
  do
  {
    (&pool->work)->tqh_first = (struct workqueue_entry_s *)(void *)0;
    (&pool->work)->tqh_last = &(&pool->work)->tqh_first;
  }
  while((_Bool)0);
  pool->new_thread_state_fn = new_thread_state_fn;
  pool->new_thread_state_arg = arg;
  pool->free_thread_state_fn = free_thread_state_fn;
  pool->reply_queue = replyqueue;
  signed int return_value_threadpool_start_threads_2;
  return_value_threadpool_start_threads_2=threadpool_start_threads(pool, n_threads);
  if(!(return_value_threadpool_start_threads_2 >= 0))
  {
    tor_cond_uninit(&pool->condition);
    tor_mutex_uninit(&pool->lock);
    if(!(pool == ((struct threadpool_s *)NULL)))
    {
      free((void *)pool);
      pool = (struct threadpool_s *)(void *)0;
    }

    return (struct threadpool_s *)(void *)0;
  }

  else
    return pool;
}

// threadpool_queue_update
// file ../src/common/workqueue.c line 318
signed int threadpool_queue_update(struct threadpool_s *pool, void * (*dup_fn)(void *), signed int (*fn)(void *, void *), void (*free_fn)(void *), void *arg)
{
  signed int i;
  signed int n_threads;
  void (*old_args_free_fn)(void *);
  void **old_args;
  void **new_args;
  tor_mutex_acquire(&pool->lock);
  n_threads = pool->n_threads;
  old_args = pool->update_args;
  old_args_free_fn = pool->free_update_arg_fn;
  void *return_value_tor_calloc__1;
  return_value_tor_calloc__1=tor_calloc_((unsigned long int)n_threads, sizeof(void *) /*8ul*/ );
  new_args = (void **)return_value_tor_calloc__1;
  i = 0;
  for( ; !(i >= n_threads); i = i + 1)
    if(!(dup_fn == ((void * (*)(void *))NULL)))
      new_args[(signed long int)i]=dup_fn(arg);

    else
      new_args[(signed long int)i] = arg;
  pool->update_args = new_args;
  pool->free_update_arg_fn = free_fn;
  pool->update_fn = fn;
  pool->generation = pool->generation + 1u;
  tor_mutex_release(&pool->lock);
  tor_cond_signal_all(&pool->condition);
  if(!(old_args == ((void **)NULL)))
  {
    i = 0;
    for( ; !(i >= n_threads); i = i + 1)
      if(!(old_args[(signed long int)i] == NULL))
      {
        if(!(old_args_free_fn == ((void (*)(void *))NULL)))
          old_args_free_fn(old_args[(signed long int)i]);

      }

    if(!(old_args == ((void **)NULL)))
    {
      free((void *)old_args);
      old_args = (void **)(void *)0;
    }

  }

  return 0;
}

// threadpool_queue_work
// file ../src/common/workqueue.c line 282
struct workqueue_entry_s * threadpool_queue_work(struct threadpool_s *pool, signed int (*fn)(void *, void *), void (*reply_fn)(void *), void *arg)
{
  struct workqueue_entry_s *ent;
  ent=workqueue_entry_new(fn, reply_fn, arg);
  ent->on_pool = pool;
  ent->pending = (unsigned char)1;
  tor_mutex_acquire(&pool->lock);
  do
  {
    ent->next_work.tqe_next = (struct workqueue_entry_s *)(void *)0;
    ent->next_work.tqe_prev = (&pool->work)->tqh_last;
    *(&pool->work)->tqh_last = ent;
    (&pool->work)->tqh_last = &ent->next_work.tqe_next;
  }
  while((_Bool)0);
  tor_mutex_release(&pool->lock);
  tor_cond_signal_one(&pool->condition);
  return ent;
}

// threadpool_start_threads
// file ../src/common/workqueue.c line 364
static signed int threadpool_start_threads(struct threadpool_s *pool, signed int n)
{
  void *return_value_tor_reallocarray__1;
  signed int tmp_post_2;
  if(!(n >= 0))
    return -1;

  else
  {
    tor_mutex_acquire(&pool->lock);
    if(!(pool->n_threads >= n))
    {
      return_value_tor_reallocarray__1=tor_reallocarray_((void *)pool->threads, sizeof(struct workerthread_s *) /*8ul*/ , (unsigned long int)n);
      pool->threads = (struct workerthread_s **)return_value_tor_reallocarray__1;
    }

    if(!(pool->n_threads >= n))
    {
      void *state;
      state=pool->new_thread_state_fn(pool->new_thread_state_arg);
      struct workerthread_s *thr;
      thr=workerthread_new(state, pool, pool->reply_queue);
      if(thr == ((struct workerthread_s *)NULL))
      {
        tor_mutex_release(&pool->lock);
        return -1;
      }

      thr->index = pool->n_threads;
      tmp_post_2 = pool->n_threads;
      pool->n_threads = pool->n_threads + 1;
      pool->threads[(signed long int)tmp_post_2] = thr;
    }

    tor_mutex_release(&pool->lock);
    return 0;
  }
}

// tor_accept_socket
// file ../src/common/compat.c line 1230
signed int tor_accept_socket(signed int sockfd, struct sockaddr *addr, unsigned int *len)
{
  signed int return_value_tor_accept_socket_with_extensions_1;
  return_value_tor_accept_socket_with_extensions_1=tor_accept_socket_with_extensions(sockfd, addr, len, 1, 0);
  return return_value_tor_accept_socket_with_extensions_1;
}

// tor_accept_socket_nonblocking
// file ../src/common/compat.c line 1238
signed int tor_accept_socket_nonblocking(signed int sockfd, struct sockaddr *addr, unsigned int *len)
{
  signed int return_value_tor_accept_socket_with_extensions_1;
  return_value_tor_accept_socket_with_extensions_1=tor_accept_socket_with_extensions(sockfd, addr, len, 1, 1);
  return return_value_tor_accept_socket_with_extensions_1;
}

// tor_accept_socket_with_extensions
// file ../src/common/compat.c line 1249
signed int tor_accept_socket_with_extensions(signed int sockfd, struct sockaddr *addr, unsigned int *len, signed int cloexec, signed int nonblock)
{
  signed int s;
  signed int ext_flags = (cloexec != 0 ? 524288 : 0) | (nonblock != 0 ? 2048 : 0);
  s=accept4(sockfd, addr, len, ext_flags);
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_1;
  if(!(s >= 0))
  {
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 22))
    {
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 38))
        return s;

    }

    s=accept(sockfd, addr, len);
    if(!(s >= 0))
      return s;

    if(!(cloexec == 0))
    {
      signed int return_value_fcntl_5;
      return_value_fcntl_5=fcntl(s, 2, 1);
      if(return_value_fcntl_5 == -1)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        char *return_value_strerror_4;
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_fn_(4, 1u << 2, "tor_accept_socket_with_extensions", "Couldn't set FD_CLOEXEC: %s", return_value_strerror_4);
        tor_close_socket_simple(s);
        return -1;
      }

    }

    if(!(nonblock == 0))
    {
      signed int return_value_set_socket_nonblocking_6;
      return_value_set_socket_nonblocking_6=set_socket_nonblocking(s);
      if(return_value_set_socket_nonblocking_6 == -1)
      {
        tor_close_socket_simple(s);
        return -1;
      }

    }

  }


socket_ok:
  ;
  socket_accounting_lock();
  n_sockets_open = n_sockets_open + 1;
  socket_accounting_unlock();
  return s;
}

// tor_addr_compare
// file ../src/common/address.c line 949
signed int tor_addr_compare(const struct tor_addr_t *addr1, const struct tor_addr_t *addr2, enum anonymous_18 how)
{
  signed int return_value_tor_addr_compare_masked_1;
  return_value_tor_addr_compare_masked_1=tor_addr_compare_masked(addr1, addr2, (unsigned char)128, how);
  return return_value_tor_addr_compare_masked_1;
}

// tor_addr_compare_masked
// file ../src/common/address.c line 970
signed int tor_addr_compare_masked(const struct tor_addr_t *addr1, const struct tor_addr_t *addr2, unsigned char mbits, enum anonymous_18 how)
{
  unsigned short int family1;
  unsigned short int family2;
  unsigned short int v_family1;
  unsigned short int v_family2;
  if(addr1 == ((const struct tor_addr_t *)NULL) || addr2 == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)978, "tor_addr_compare_masked", "addr1 && addr2");
    abort();
  }

  family1=tor_addr_family_link1(addr1);
  v_family1 = family1;
  family2=tor_addr_family_link1(addr2);
  v_family2 = family2;
  unsigned int tor_addr_compare_masked__1__2__1__1__a1;
  unsigned int tor_addr_compare_masked__1__2__1__1__a2;
  const unsigned char *tor_addr_compare_masked__1__2__1__2__a1;
  struct in6_addr *return_value_tor_addr_to_in6_1;
  const unsigned char *tor_addr_compare_masked__1__2__1__2__a2;
  struct in6_addr *return_value_tor_addr_to_in6_2;
  signed int bytes;
  signed int leftover_bits;
  _Bool tmp_if_expr_3;
  if(family1 == family2)
  {
    signed int r;
    switch((signed int)family1)
    {
      case 0:
        return 0;
      case 2:
      {
        tor_addr_compare_masked__1__2__1__1__a1=tor_addr_to_ipv4h(addr1);
        tor_addr_compare_masked__1__2__1__1__a2=tor_addr_to_ipv4h(addr2);
        if(!((signed int)mbits >= 1))
          return 0;

        if((signed int)mbits >= 33)
          mbits = (unsigned char)32;

        tor_addr_compare_masked__1__2__1__1__a1 = tor_addr_compare_masked__1__2__1__1__a1 >> 32 - (signed int)mbits;
        tor_addr_compare_masked__1__2__1__1__a2 = tor_addr_compare_masked__1__2__1__1__a2 >> 32 - (signed int)mbits;
        r = tor_addr_compare_masked__1__2__1__1__a1 < tor_addr_compare_masked__1__2__1__1__a2 ? -1 : (tor_addr_compare_masked__1__2__1__1__a1 == tor_addr_compare_masked__1__2__1__1__a2 ? 0 : 1);
        return r;
      }
      case 10:
      {
        return_value_tor_addr_to_in6_1=tor_addr_to_in6_link1(addr1);
        tor_addr_compare_masked__1__2__1__2__a1 = return_value_tor_addr_to_in6_1->__in6_u.__u6_addr8;
        return_value_tor_addr_to_in6_2=tor_addr_to_in6_link1(addr2);
        tor_addr_compare_masked__1__2__1__2__a2 = return_value_tor_addr_to_in6_2->__in6_u.__u6_addr8;
        bytes = (signed int)mbits >> 3;
        leftover_bits = (signed int)mbits & 7;
        if(!(bytes == 0))
        {
          r=tor_memcmp((const void *)tor_addr_compare_masked__1__2__1__2__a1, (const void *)tor_addr_compare_masked__1__2__1__2__a2, (unsigned long int)bytes);
          tmp_if_expr_3 = r != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          return r;

        else
          if(!(leftover_bits == 0))
          {
            unsigned char b1 = (unsigned char)((signed int)tor_addr_compare_masked__1__2__1__2__a1[(signed long int)bytes] >> 8 - leftover_bits);
            unsigned char b2 = (unsigned char)((signed int)tor_addr_compare_masked__1__2__1__2__a2[(signed long int)bytes] >> 8 - leftover_bits);
            return (signed int)b1 < (signed int)b2 ? -1 : (b1 == b2 ? 0 : 1);
          }

          else
            return 0;
      }
      default:
        return 0;
    }
  }

  else
    if((signed int)how == CMP_EXACT)
      return (signed int)family1 < (signed int)family2 ? -1 : (family1 == family2 ? 0 : 1);

  signed int return_value_tor_addr_is_v4_4;
  signed int return_value_tor_addr_is_v4_5;
  if((signed int)mbits == 0)
    return 0;

  else
  {
    if((signed int)family1 == 10)
    {
      return_value_tor_addr_is_v4_4=tor_addr_is_v4(addr1);
      if(!(return_value_tor_addr_is_v4_4 == 0))
        v_family1 = (unsigned short int)2;

    }

    if((signed int)family2 == 10)
    {
      return_value_tor_addr_is_v4_5=tor_addr_is_v4(addr2);
      if(!(return_value_tor_addr_is_v4_5 == 0))
        v_family2 = (unsigned short int)2;

    }

    if(v_family1 == v_family2)
    {
      unsigned int a1;
      unsigned int a2;
      if((signed int)family1 == 10)
      {
        a1=tor_addr_to_mapped_ipv4h(addr1);
        if(!((signed int)mbits >= 97))
          return 0;

        mbits = mbits - (unsigned char)96;
      }

      else
        a1=tor_addr_to_ipv4h(addr1);
      if((signed int)family2 == 10)
        a2=tor_addr_to_mapped_ipv4h(addr2);

      else
        a2=tor_addr_to_ipv4h(addr2);
      if((signed int)mbits >= 33)
        mbits = (unsigned char)32;

      a1 = a1 >> 32 - (signed int)mbits;
      a2 = a2 >> 32 - (signed int)mbits;
      return a1 < a2 ? -1 : (a1 == a2 ? 0 : 1);
    }

    else
      return (signed int)family1 < (signed int)family2 ? -1 : (family1 == family2 ? 0 : 1);
  }
}

// tor_addr_copy
// file ../src/common/address.c line 905
void tor_addr_copy(struct tor_addr_t *dest, const struct tor_addr_t *src)
{
  if(!(src == dest))
  {
    if(src == ((const struct tor_addr_t *)NULL))
    {
      tor_assertion_failed_("../src/common/address.c", (unsigned int)909, "tor_addr_copy", "src");
      abort();
    }

    if(dest == ((struct tor_addr_t *)NULL))
    {
      tor_assertion_failed_("../src/common/address.c", (unsigned int)910, "tor_addr_copy", "dest");
      abort();
    }

    memcpy_link1((void *)dest, (const void *)src, sizeof(struct tor_addr_t) /*20ul*/ );
  }

}

// tor_addr_copy_tight
// file ../src/common/address.c line 919
void tor_addr_copy_tight(struct tor_addr_t *dest, const struct tor_addr_t *src)
{
  if(src == dest)
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)921, "tor_addr_copy_tight", "src != dest");
    abort();
  }

  if(src == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)922, "tor_addr_copy_tight", "src");
    abort();
  }

  if(dest == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)923, "tor_addr_copy_tight", "dest");
    abort();
  }

  memset_link1((void *)dest, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  dest->family = src->family;
  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(src);
  switch((signed int)return_value_tor_addr_family_1)
  {
    case 2:
    {
      dest->addr.in_addr.s_addr = src->addr.in_addr.s_addr;
      goto __CPROVER_DUMP_L6;
    }
    case 10:
      memcpy_link1((void *)dest->addr.in6_addr.__in6_u.__u6_addr8, (const void *)src->addr.in6_addr.__in6_u.__u6_addr8, (unsigned long int)16);
    case 0:

    default:

      __CPROVER_DUMP_L6:
        ;
  }
}

// tor_addr_family
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family(const struct tor_addr_t *a)
{
  return a->family;
}

// tor_addr_family_link1
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family_link1(const struct tor_addr_t *a_link1)
{
  return a_link1->family;
}

// tor_addr_family_link2
// file ../src/common/address.h line 153
static inline unsigned short int tor_addr_family_link2(const struct tor_addr_t *a_link2)
{
  return a_link2->family;
}

// tor_addr_from_in6
// file ../src/common/address.c line 897
void tor_addr_from_in6(struct tor_addr_t *dest, struct in6_addr *in6)
{
  tor_addr_from_ipv6_bytes(dest, (const char *)in6->__in6_u.__u6_addr8);
}

// tor_addr_from_ipv4n
// file ../src/common/address.h line 239
void tor_addr_from_ipv4n(struct tor_addr_t *dest, unsigned int v4addr)
{
  if(dest == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)877, "tor_addr_from_ipv4n", "dest");
    abort();
  }

  memset_link1((void *)dest, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  dest->family = (unsigned short int)2;
  dest->addr.in_addr.s_addr = v4addr;
}

// tor_addr_from_ipv6_bytes
// file ../src/common/address.h line 244
void tor_addr_from_ipv6_bytes(struct tor_addr_t *dest, const char *ipv6_bytes)
{
  if(dest == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)888, "tor_addr_from_ipv6_bytes", "dest");
    abort();
  }

  if(ipv6_bytes == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)889, "tor_addr_from_ipv6_bytes", "ipv6_bytes");
    abort();
  }

  memset_link1((void *)dest, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  dest->family = (unsigned short int)10;
  memcpy_link1((void *)dest->addr.in6_addr.__in6_u.__u6_addr8, (const void *)ipv6_bytes, (unsigned long int)16);
}

// tor_addr_from_sockaddr
// file ../src/common/address.c line 138
signed int tor_addr_from_sockaddr(struct tor_addr_t *a, struct sockaddr *sa, unsigned short int *port_out)
{
  if(a == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)141, "tor_addr_from_sockaddr", "a");
    abort();
  }

  if(sa == ((struct sockaddr *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)142, "tor_addr_from_sockaddr", "sa");
    abort();
  }

  memset_link1((void *)a, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  unsigned short int tmp_statement_expression_1;
  unsigned short int tmp_statement_expression_2;
  if((signed int)sa->sa_family == 2)
  {
    struct sockaddr_in *sin = (struct sockaddr_in *)sa;
    tor_addr_from_ipv4n(a, sin->sin_addr.s_addr);
    if(!(port_out == ((unsigned short int *)NULL)))
    {
      unsigned short int tor_addr_from_sockaddr__1__3__1____v;
      unsigned short int tor_addr_from_sockaddr__1__3__1____x = (unsigned short int)sin->sin_port;
      asm("rorw _8, %w0" : "=r"(tor_addr_from_sockaddr__1__3__1____v) : "0"(tor_addr_from_sockaddr__1__3__1____x) : "cc");
      tmp_statement_expression_1 = tor_addr_from_sockaddr__1__3__1____v;
      *port_out = tmp_statement_expression_1;
    }

  }

  else
    if((signed int)sa->sa_family == 10)
    {
      struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
      tor_addr_from_in6(a, &sin6->sin6_addr);
      if(!(port_out == ((unsigned short int *)NULL)))
      {
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)sin6->sin6_port;
        asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression_2 = __v;
        *port_out = tmp_statement_expression_2;
      }

    }

    else
      if((signed int)sa->sa_family == 1)
      {
        tor_addr_make_af_unix(a);
        return 0;
      }

      else
      {
        tor_addr_make_unspec(a);
        return -1;
      }
  return 0;
}

// tor_addr_hash
// file ../src/common/address.c line 1062
unsigned long int tor_addr_hash(const struct tor_addr_t *addr)
{
  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(addr);
  unsigned long int return_value_siphash24g_2;
  unsigned long int return_value_siphash24g_3;
  switch((signed int)return_value_tor_addr_family_1)
  {
    case 2:
    {
      return_value_siphash24g_2=siphash24g((const void *)&addr->addr.in_addr.s_addr, (unsigned long int)4);
      return return_value_siphash24g_2;
    }
    case 0:
      return (unsigned long int)0x4e4d5342;
    case 10:
    {
      return_value_siphash24g_3=siphash24g((const void *)&addr->addr.in6_addr.__in6_u.__u6_addr8, (unsigned long int)16);
      return return_value_siphash24g_3;
    }
    default:
      return (unsigned long int)0;
  }
}

// tor_addr_hostname_is_local
// file ../src/common/address.c line 1856
signed int tor_addr_hostname_is_local(const char *name)
{
  signed int return_value_strcasecmp_1;
  return_value_strcasecmp_1=strcasecmp(name, "localhost");
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  if(return_value_strcasecmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strcasecmp_2=strcasecmp(name, "local");
    tmp_if_expr_3 = !(return_value_strcasecmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmpend_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcasecmpend_4=strcasecmpend(name, ".local");
    tmp_if_expr_5 = !(return_value_strcasecmpend_4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_5;
}

// tor_addr_is_internal_
// file ../src/common/address.c line 338
signed int tor_addr_is_internal_(const struct tor_addr_t *addr, signed int for_listening, const char *filename, signed int lineno)
{
  unsigned int iph4 = (unsigned int)0;
  unsigned int iph6[4l];
  if(addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)344, "tor_addr_is_internal_", "addr");
    abort();
  }

  unsigned short int v_family;
  v_family=tor_addr_family_link1(addr);
  if((signed int)v_family == 2)
    iph4=tor_addr_to_ipv4h(addr);

  else
    if((signed int)v_family == 10)
    {
      signed int return_value_tor_addr_is_v4_2;
      return_value_tor_addr_is_v4_2=tor_addr_is_v4(addr);
      if(!(return_value_tor_addr_is_v4_2 == 0))
      {
        unsigned int *addr32 = (unsigned int *)(void *)0;
        v_family = (unsigned short int)2;
        struct in6_addr *return_value_tor_addr_to_in6_1;
        return_value_tor_addr_to_in6_1=tor_addr_to_in6_link1(addr);
        addr32 = (unsigned int *)return_value_tor_addr_to_in6_1->__in6_u.__u6_addr32;
        if(addr32 == ((unsigned int *)NULL))
        {
          tor_assertion_failed_("../src/common/address.c", (unsigned int)358, "tor_addr_is_internal_", "addr32");
          abort();
        }

        iph4=__bswap_32_link1(addr32[(signed long int)3]);
      }

    }

  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if((signed int)v_family == 10)
  {
    const unsigned int *a32;
    struct in6_addr *return_value_tor_addr_to_in6_3;
    return_value_tor_addr_to_in6_3=tor_addr_to_in6_link1(addr);
    a32 = (unsigned int *)return_value_tor_addr_to_in6_3->__in6_u.__u6_addr32;
    iph6[(signed long int)0]=__bswap_32_link1(a32[(signed long int)0]);
    iph6[(signed long int)1]=__bswap_32_link1(a32[(signed long int)1]);
    iph6[(signed long int)2]=__bswap_32_link1(a32[(signed long int)2]);
    iph6[(signed long int)3]=__bswap_32_link1(a32[(signed long int)3]);
    if(!(for_listening == 0))
    {
      if(iph6[0l] == 0u)
      {
        if(iph6[1l] == 0u)
        {
          if(iph6[2l] == 0u)
          {
            if(iph6[3l] == 0u)
              return 0;

          }

        }

      }

    }

    if((0xfe000000 & iph6[0l]) == 0xfc000000)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (iph6[(signed long int)0] & 0xffc00000) == 0xfe800000 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (iph6[(signed long int)0] & 0xffc00000) == 0xfec00000 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      return 1;

    if(iph6[0l] == 0u)
    {
      if(iph6[1l] == 0u)
      {
        if(iph6[2l] == 0u)
        {
          if((0xfffffffe & iph6[3l]) == 0u)
            return 1;

        }

      }

    }

    return 0;
  }

  else
    if((signed int)v_family == 2)
    {
      if(iph4 == 0u && !(for_listening == 0))
        return 0;

      if((0xff000000 & iph4) == 0u || (0xff000000 & iph4) == 167772160u || (0xff000000 & iph4) == 2130706432u || (0xfff00000 & iph4) == 0xac100000 || (0xffff0000 & iph4) == 0xa9fe0000 || (0xffff0000 & iph4) == 0xc0a80000)
        return 1;

      return 0;
    }

  log_fn_(4, 1u << 12, "tor_addr_is_internal_", "tor_addr_is_internal() called from %s:%d with a non-IP address of type %d", filename, lineno, (signed int)v_family);
  return 1;
}

// tor_addr_is_loopback
// file ../src/common/address.c line 851
signed int tor_addr_is_loopback(const struct tor_addr_t *addr)
{
  if(addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)853, "tor_addr_is_loopback", "addr");
    abort();
  }

  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(addr);
  unsigned int *a32;
  struct in6_addr *return_value_tor_addr_to_in6_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  unsigned int return_value___bswap_32_5;
  unsigned int return_value_tor_addr_to_ipv4h_7;
  switch((signed int)return_value_tor_addr_family_1)
  {
    case 10:
    {
      return_value_tor_addr_to_in6_2=tor_addr_to_in6_link1(addr);
      a32 = (unsigned int *)return_value_tor_addr_to_in6_2->__in6_u.__u6_addr32;
      if(*a32 == 0u)
        tmp_if_expr_3 = a32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = a32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value___bswap_32_5=__bswap_32_link1(a32[(signed long int)3]);
        tmp_if_expr_6 = return_value___bswap_32_5 == (unsigned int)1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      return (signed int)tmp_if_expr_6;
    }
    case 2:
    {
      return_value_tor_addr_to_ipv4h_7=tor_addr_to_ipv4h(addr);
      return (signed int)((return_value_tor_addr_to_ipv4h_7 & 0xff000000) == (unsigned int)0x7f000000);
    }
    case 0:
      return 0;
    default:
      return 0;
  }
}

// tor_addr_is_multicast
// file ../src/common/address.c line 1492
static signed int tor_addr_is_multicast(const struct tor_addr_t *a)
{
  unsigned short int family;
  family=tor_addr_family_link1(a);
  if((signed int)family == 2)
  {
    unsigned int ipv4h;
    ipv4h=tor_addr_to_ipv4h(a);
    if(ipv4h >> 24 == 224u)
      return 1;

  }

  else
    if((signed int)family == 10)
    {
      const unsigned char *a32;
      struct in6_addr *return_value_tor_addr_to_in6_1;
      return_value_tor_addr_to_in6_1=tor_addr_to_in6_link1(a);
      a32 = return_value_tor_addr_to_in6_1->__in6_u.__u6_addr8;
      if((signed int)*a32 == 0xff)
        return 1;

    }

  return 0;
}

// tor_addr_is_null
// file ../src/common/address.c line 826
signed int tor_addr_is_null(const struct tor_addr_t *addr)
{
  if(addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)828, "tor_addr_is_null", "addr");
    abort();
  }

  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(addr);
  unsigned int *a32;
  struct in6_addr *return_value_tor_addr_to_in6_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  unsigned int return_value_tor_addr_to_ipv4n_6;
  unsigned short int return_value_tor_addr_family_7;
  switch((signed int)return_value_tor_addr_family_1)
  {
    case 10:
    {
      return_value_tor_addr_to_in6_2=tor_addr_to_in6_link1(addr);
      a32 = (unsigned int *)return_value_tor_addr_to_in6_2->__in6_u.__u6_addr32;
      if(*a32 == 0u)
        tmp_if_expr_3 = a32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = a32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = a32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      return (signed int)tmp_if_expr_5;
    }
    case 2:
    {
      return_value_tor_addr_to_ipv4n_6=tor_addr_to_ipv4n_link1(addr);
      return (signed int)(return_value_tor_addr_to_ipv4n_6 == (unsigned int)0);
    }
    case 1:
      return 1;
    case 0:
      return 1;
    default:
    {
      return_value_tor_addr_family_7=tor_addr_family_link1(addr);
      log_fn_(4, 1u << 12, "tor_addr_is_null", "Called with unknown address family %d", (signed int)return_value_tor_addr_family_7);
      return 0;
    }
  }
}

// tor_addr_is_v4
// file ../src/common/address.c line 805
signed int tor_addr_is_v4(const struct tor_addr_t *addr)
{
  if(addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)807, "tor_addr_is_v4", "addr");
    abort();
  }

  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(addr);
  unsigned int return_value___bswap_32_3;
  if((signed int)return_value_tor_addr_family_1 == 2)
    return 1;

  else
  {
    unsigned short int return_value_tor_addr_family_4;
    return_value_tor_addr_family_4=tor_addr_family_link1(addr);
    if((signed int)return_value_tor_addr_family_4 == 10)
    {
      unsigned int *a32;
      struct in6_addr *return_value_tor_addr_to_in6_2;
      return_value_tor_addr_to_in6_2=tor_addr_to_in6_link1(addr);
      a32 = (unsigned int *)return_value_tor_addr_to_in6_2->__in6_u.__u6_addr32;
      if(*a32 == 0u)
      {
        if(a32[1l] == 0u)
        {
          return_value___bswap_32_3=__bswap_32_link1(a32[(signed long int)2]);
          if(return_value___bswap_32_3 == 0x0000ffffu)
            return 1;

        }

      }

    }

    return 0;
  }
}

// tor_addr_lookup
// file ../src/common/address.c line 221
signed int tor_addr_lookup(const char *name, unsigned short int family, struct tor_addr_t *addr)
{
  struct in_addr iaddr;
  struct in6_addr iaddr6;
  if(name == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)228, "tor_addr_lookup", "name");
    abort();
  }

  if(addr == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)229, "tor_addr_lookup", "addr");
    abort();
  }

  if(!((signed int)family == 0) && !((signed int)family == 2) && !((signed int)family == 10))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)230, "tor_addr_lookup", "family == AF_INET || family == AF_INET6 || family == AF_UNSPEC");
    abort();
  }

  signed int return_value_tor_inet_pton_2;
  signed int return_value_tor_inet_pton_1;
  if(*name == 0)
    return -1;

  else
  {
    return_value_tor_inet_pton_2=tor_inet_pton(2, name, (void *)&iaddr);
    if(!(return_value_tor_inet_pton_2 == 0))
    {
      if((signed int)family == 10)
        return -1;

      tor_addr_from_ipv4n(addr, (&iaddr)->s_addr);
      return 0;
    }

    else
    {
      return_value_tor_inet_pton_1=tor_inet_pton(10, name, (void *)&iaddr6);
      if(!(return_value_tor_inet_pton_1 == 0))
      {
        if((signed int)family == 2)
          return -1;

        tor_addr_from_in6(addr, &iaddr6);
        return 0;
      }

      else
      {
        signed int err;
        struct addrinfo *res = (struct addrinfo *)(void *)0;
        struct addrinfo *res_p;
        struct addrinfo *best = (struct addrinfo *)(void *)0;
        struct addrinfo hints;
        signed int result = -1;
        memset_link1((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
        hints.ai_family = (signed int)family;
        hints.ai_socktype = 1;
        err=sandbox_getaddrinfo(name, (const char *)(void *)0, &hints, &res);
        if(err == 0 && !(res == ((struct addrinfo *)NULL)))
        {
          best = (struct addrinfo *)(void *)0;
          res_p = res;
          for( ; !(res_p == ((struct addrinfo *)NULL)); res_p = res_p->ai_next)
            if((signed int)family == 0)
            {
              if(res_p->ai_family == 2)
              {
                best = res_p;
                break;
              }

              else
                if(res_p->ai_family == 10)
                {
                  if(best == ((struct addrinfo *)NULL))
                    best = res_p;

                }

            }

            else
              if((signed int)family == res_p->ai_family)
              {
                best = res_p;
                break;
              }

          if(best == ((struct addrinfo *)NULL))
            best = res;

          if(best->ai_family == 2)
          {
            tor_addr_from_ipv4n(addr, (&((struct sockaddr_in *)best->ai_addr)->sin_addr)->s_addr);
            result = 0;
          }

          else
            if(best->ai_family == 10)
            {
              tor_addr_from_in6(addr, &((struct sockaddr_in6 *)best->ai_addr)->sin6_addr);
              result = 0;
            }

          sandbox_freeaddrinfo(res);
          return result;
        }

        return err == -3 ? 1 : -1;
      }
    }
  }
}

// tor_addr_make_af_unix
// file ../src/common/address.c line 129
static void tor_addr_make_af_unix(struct tor_addr_t *a)
{
  memset_link1((void *)a, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  a->family = (unsigned short int)1;
}

// tor_addr_make_null
// file ../src/common/address.c line 206
void tor_addr_make_null(struct tor_addr_t *a, unsigned short int family)
{
  memset_link1((void *)a, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  a->family = family;
}

// tor_addr_make_unspec
// file ../src/common/address.h line 88
void tor_addr_make_unspec(struct tor_addr_t *a)
{
  memset_link1((void *)a, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  a->family = (unsigned short int)0;
}

// tor_addr_parse
// file ../src/common/address.h line 236
signed int tor_addr_parse(struct tor_addr_t *addr, const char *src)
{
  char *tmp = (char *)(void *)0;
  signed int result;
  struct in_addr in_tmp;
  struct in6_addr in6_tmp;
  if(src == ((const char *)NULL) || addr == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1149, "tor_addr_parse", "addr && src");
    abort();
  }

  unsigned long int return_value_strlen_1;
  if((signed int)*src == 91)
  {
    if(!(src[1l] == 0))
    {
      return_value_strlen_1=strlen(src);
      tmp=tor_strndup_(src + (signed long int)1, return_value_strlen_1 - (unsigned long int)2);
      src = tmp;
    }

  }

  signed int return_value_tor_inet_pton_3;
  return_value_tor_inet_pton_3=tor_inet_pton(10, src, (void *)&in6_tmp);
  signed int return_value_tor_inet_pton_2;
  if(return_value_tor_inet_pton_3 >= 1)
  {
    result = 10;
    tor_addr_from_in6(addr, &in6_tmp);
  }

  else
  {
    return_value_tor_inet_pton_2=tor_inet_pton(2, src, (void *)&in_tmp);
    if(return_value_tor_inet_pton_2 >= 1)
    {
      result = 2;
      tor_addr_from_ipv4n(addr, (&in_tmp)->s_addr);
    }

    else
      result = -1;
  }
  if(!(tmp == ((char *)NULL)))
  {
    free((void *)tmp);
    tmp = (char *)(void *)0;
  }

  return result;
}

// tor_addr_parse_PTR_name
// file ../src/common/address.c line 460
signed int tor_addr_parse_PTR_name(struct tor_addr_t *result, const char *address, signed int family, signed int accept_regular)
{
  signed int return_value_strcasecmpend_4;
  return_value_strcasecmpend_4=strcasecmpend(address, ".in-addr.arpa");
  if(return_value_strcasecmpend_4 == 0)
  {
    char buf[16l];
    unsigned long int len;
    struct in_addr inaddr;
    if(family == 10)
      return -1;

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(address);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(".in-addr.arpa");
    len = return_value_strlen_1 - return_value_strlen_2;
    if(len >= 16ul)
      return -1;

    memcpy_link1((void *)buf, (const void *)address, len);
    buf[(signed long int)len] = (char)0;
    signed int return_value_tor_inet_aton_3;
    return_value_tor_inet_aton_3=tor_inet_aton(buf, &inaddr);
    if(return_value_tor_inet_aton_3 == 0)
      return -1;

    inaddr.s_addr = (unsigned int)((inaddr.s_addr & (unsigned int)0x000000ff) << 24 | (inaddr.s_addr & (unsigned int)0x0000ff00) << 8 | (inaddr.s_addr & (unsigned int)0x00ff0000) >> 8 | (inaddr.s_addr & 0xff000000) >> 24);
    if(!(result == ((struct tor_addr_t *)NULL)))
      tor_addr_from_ipv4n(result, (&inaddr)->s_addr);

    return 1;
  }

  signed int return_value_strcasecmpend_10;
  return_value_strcasecmpend_10=strcasecmpend(address, ".ip6.arpa");
  const char *tmp_post_5;
  const char *tmp_post_6;
  const char *tmp_post_7;
  const char *tmp_post_8;
  if(return_value_strcasecmpend_10 == 0)
  {
    const char *cp;
    signed int n0;
    signed int n1;
    struct in6_addr in6;
    if(family == 2)
      return -1;

    cp = address;
    signed int i = 0;
    for( ; !(i >= 16); i = i + 1)
    {
      tmp_post_5 = cp;
      cp = cp + 1l;
      n0=hex_decode_digit(*tmp_post_5);
      tmp_post_6 = cp;
      cp = cp + 1l;
      if(!((signed int)*tmp_post_6 == 46))
        return -1;

      tmp_post_7 = cp;
      cp = cp + 1l;
      n1=hex_decode_digit(*tmp_post_7);
      tmp_post_8 = cp;
      cp = cp + 1l;
      if(!((signed int)*tmp_post_8 == 46))
        return -1;

      if(!(n0 >= 0) || !(n1 >= 0))
        return -1;

      in6.__in6_u.__u6_addr8[(signed long int)(15 - i)] = (unsigned char)(n0 | n1 << 4);
    }
    signed int return_value_strcasecmp_9;
    return_value_strcasecmp_9=strcasecmp(cp, "ip6.arpa");
    if(!(return_value_strcasecmp_9 == 0))
      return -1;

    if(!(result == ((struct tor_addr_t *)NULL)))
      tor_addr_from_in6(result, &in6);

    return 1;
  }

  if(!(accept_regular == 0))
  {
    struct tor_addr_t tmp;
    signed int r;
    r=tor_addr_parse(&tmp, address);
    if(!(r >= 0))
      return 0;

    if(!(r == family) && !(family == 0))
      return -1;

    if(!(result == ((struct tor_addr_t *)NULL)))
      memcpy_link1((void *)result, (const void *)&tmp, sizeof(struct tor_addr_t) /*20ul*/ );

    return 1;
  }

  return 0;
}

// tor_addr_parse_mask_ports
// file ../src/common/address.c line 616
signed int tor_addr_parse_mask_ports(const char *s, unsigned int flags, struct tor_addr_t *addr_out, unsigned char *maskbits_out, unsigned short int *port_min_out, unsigned short int *port_max_out)
{
  char *base = (char *)(void *)0;
  char *address;
  char *mask = (char *)(void *)0;
  char *port = (char *)(void *)0;
  char *rbracket = (char *)(void *)0;
  char *endptr;
  signed int any_flag = 0;
  signed int v4map = 0;
  unsigned short int family;
  struct in6_addr in6_tmp;
  struct in_addr in_tmp = { .s_addr=(unsigned int)0 };
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)629, "tor_addr_parse_mask_ports", "s");
    abort();
  }

  if(addr_out == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)630, "tor_addr_parse_mask_ports", "addr_out");
    abort();
  }

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(s);
  if(return_value_strlen_2 >= 81ul)
  {
    const char *return_value_escaped_1;
    return_value_escaped_1=escaped(s);
    log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Impossibly long IP %s; rejecting", return_value_escaped_1);
    goto err;
  }

  base=tor_strdup_(s);
  address = base;
  if((signed int)*address == 91)
  {
    address = address + 1l;
    char *return_value___builtin_strchr_3;
    return_value___builtin_strchr_3=__builtin_strchr(address, 93);
    rbracket = return_value___builtin_strchr_3;
    if(rbracket == ((char *)NULL))
    {
      log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "No closing IPv6 bracket in address pattern; rejecting.");
      goto err;
    }

  }

  char *return_value___builtin_strchr_4;
  return_value___builtin_strchr_4=__builtin_strchr(rbracket != ((char *)NULL) ? rbracket : address, 47);
  mask = return_value___builtin_strchr_4;
  char *return_value___builtin_strchr_5;
  return_value___builtin_strchr_5=__builtin_strchr(mask != ((char *)NULL) ? mask : (rbracket != ((char *)NULL) ? rbracket : address), 58);
  port = return_value___builtin_strchr_5;
  char *tmp_post_6;
  if(!(port == ((char *)NULL)))
  {
    tmp_post_6 = port;
    port = port + 1l;
    *tmp_post_6 = (char)0;
  }

  char *tmp_post_7;
  if(!(mask == ((char *)NULL)))
  {
    tmp_post_7 = mask;
    mask = mask + 1l;
    *tmp_post_7 = (char)0;
  }

  if(!(rbracket == ((char *)NULL)))
    *rbracket = (char)0;

  if(!(mask == ((char *)NULL)) && !(port == ((char *)NULL)))
  {
    if(mask >= port)
    {
      tor_assertion_failed_("../src/common/address.c", (unsigned int)662, "tor_addr_parse_mask_ports", "port > mask");
      abort();
    }

  }

  if(!(mask == ((char *)NULL)) && !(rbracket == ((char *)NULL)))
  {
    if(rbracket >= mask)
    {
      tor_assertion_failed_("../src/common/address.c", (unsigned int)664, "tor_addr_parse_mask_ports", "mask > rbracket");
      abort();
    }

  }

  memset_link1((void *)addr_out, 0, sizeof(struct tor_addr_t) /*20ul*/ );
  signed int tmp_statement_expression_17;
  unsigned long int tor_addr_parse_mask_ports__1__7____s1_len;
  unsigned long int tor_addr_parse_mask_ports__1__7____s2_len;
  signed int return_value___builtin_strcmp_18;
  return_value___builtin_strcmp_18=__builtin_strcmp(address, "*");
  tmp_statement_expression_17 = return_value___builtin_strcmp_18;
  signed int tmp_statement_expression_15;
  signed int tmp_statement_expression_13;
  signed int return_value_tor_inet_pton_12;
  signed int return_value_tor_inet_pton_11;
  if(tmp_statement_expression_17 == 0)
  {
    if(!((1u & flags) == 0u))
    {
      family = (unsigned short int)0;
      tor_addr_make_unspec(addr_out);
    }

    else
    {
      family = (unsigned short int)2;
      unsigned int return_value___bswap_32_8;
      return_value___bswap_32_8=__bswap_32_link1((unsigned int)0);
      tor_addr_from_ipv4n(addr_out, return_value___bswap_32_8);
    }
    any_flag = 1;
  }

  else
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_16;
    return_value___builtin_strcmp_16=__builtin_strcmp(address, "*4");
    tmp_statement_expression_15 = return_value___builtin_strcmp_16;
    if(tmp_statement_expression_15 == 0 && !((1u & flags) == 0u))
    {
      family = (unsigned short int)2;
      unsigned int return_value___bswap_32_9;
      return_value___bswap_32_9=__bswap_32_link1((unsigned int)0);
      tor_addr_from_ipv4n(addr_out, return_value___bswap_32_9);
      any_flag = 1;
    }

    else
    {
      unsigned long int tor_addr_parse_mask_ports__1__11____s1_len;
      unsigned long int tor_addr_parse_mask_ports__1__11____s2_len;
      signed int return_value___builtin_strcmp_14;
      return_value___builtin_strcmp_14=__builtin_strcmp(address, "*6");
      tmp_statement_expression_13 = return_value___builtin_strcmp_14;
      if(tmp_statement_expression_13 == 0 && !((1u & flags) == 0u))
      {
        family = (unsigned short int)10;
        static char nil_bytes[16l] = { (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0 };
        tor_addr_from_ipv6_bytes(addr_out, nil_bytes);
        any_flag = 1;
      }

      else
      {
        return_value_tor_inet_pton_12=tor_inet_pton(10, address, (void *)&in6_tmp);
        if(return_value_tor_inet_pton_12 >= 1)
        {
          family = (unsigned short int)10;
          tor_addr_from_in6(addr_out, &in6_tmp);
        }

        else
        {
          return_value_tor_inet_pton_11=tor_inet_pton(2, address, (void *)&in_tmp);
          if(return_value_tor_inet_pton_11 >= 1)
          {
            family = (unsigned short int)2;
            tor_addr_from_ipv4n(addr_out, (&in_tmp)->s_addr);
          }

          else
          {
            const char *return_value_escaped_10;
            return_value_escaped_10=escaped(address);
            log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Malformed IP %s in address pattern; rejecting.", return_value_escaped_10);
            goto err;
          }
        }
      }
    }
  }
  v4map=tor_addr_is_v4(addr_out);
  unsigned short int return_value_tor_addr_family_25;
  unsigned short int return_value_tor_addr_family_24;
  if(!(maskbits_out == ((unsigned char *)NULL)))
  {
    signed int bits = 0;
    struct in_addr v4mask;
    if(!(mask == ((char *)NULL)))
    {
      signed long int return_value_strtol_19;
      return_value_strtol_19=strtol(mask, &endptr, 10);
      bits = (signed int)return_value_strtol_19;
      if(*endptr == 0)
      {
        if(bits >= 129 || (signed int)family == 2 && bits >= 33 || !(bits >= 0))
        {
          log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Bad number of mask bits (%d) on address range; rejecting.", bits);
          goto err;
        }

      }

      else
      {
        signed int return_value_tor_inet_pton_23;
        return_value_tor_inet_pton_23=tor_inet_pton(2, mask, (void *)&v4mask);
        if(return_value_tor_inet_pton_23 >= 1)
        {
          unsigned int return_value___bswap_32_20;
          return_value___bswap_32_20=__bswap_32_link1(v4mask.s_addr);
          bits=addr_mask_get_bits(return_value___bswap_32_20);
          if(!(bits >= 0))
          {
            const char *return_value_escaped_21;
            return_value_escaped_21=escaped(mask);
            log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "IPv4-style mask %s is not a prefix address; rejecting.", return_value_escaped_21);
            goto err;
          }

        }

        else
        {
          const char *return_value_escaped_22;
          return_value_escaped_22=escaped(s);
          log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Malformed mask on address range %s; rejecting.", return_value_escaped_22);
          goto err;
        }
      }
      if((signed int)family == 10 && !(v4map == 0))
      {
        if(bits >= 33 && !(bits >= 96))
        {
          log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Bad mask bits %d for V4-mapped V6 address; rejecting.", bits);
          goto err;
        }

        bits = 96 + bits % 32;
      }

      if(!(any_flag == 0))
      {
        log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Found bit prefix with wildcard address; rejecting");
        goto err;
      }

    }

    else
      if(!(any_flag == 0))
        bits = 0;

      else
      {
        return_value_tor_addr_family_25=tor_addr_family_link1(addr_out);
        if((signed int)return_value_tor_addr_family_25 == 2)
          bits = 32;

        else
        {
          return_value_tor_addr_family_24=tor_addr_family_link1(addr_out);
          if((signed int)return_value_tor_addr_family_24 == 10)
            bits = 128;

        }
      }
    *maskbits_out = (unsigned char)bits;
  }

  else
    if(!(mask == ((char *)NULL)))
    {
      const char *return_value_escaped_26;
      return_value_escaped_26=escaped(s);
      log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Unexpected mask in address %s; rejecting", return_value_escaped_26);
      goto err;
    }

  if(!(port_min_out == ((unsigned short int *)NULL)))
  {
    unsigned short int port2;
    if(port_max_out == ((unsigned short int *)NULL))
      port_max_out = &port2;

    signed int return_value_parse_port_range_27;
    return_value_parse_port_range_27=parse_port_range(port, port_min_out, port_max_out);
    if(!(return_value_parse_port_range_27 >= 0))
      goto err;

    else
      if(!(*port_min_out == *port_max_out))
      {
        if(port_max_out == &port2)
        {
          log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Wanted one port from address range, but there are two.");
          port_max_out = (unsigned short int *)(void *)0;
          goto err;
        }

      }

  }

  else
    if(!(port == ((char *)NULL)))
    {
      const char *return_value_escaped_28;
      return_value_escaped_28=escaped(s);
      log_fn_(4, 1u << 0, "tor_addr_parse_mask_ports", "Unexpected ports in address %s; rejecting", return_value_escaped_28);
      goto err;
    }

  if(!(base == ((char *)NULL)))
  {
    free((void *)base);
    base = (char *)(void *)0;
  }

  unsigned short int return_value_tor_addr_family_29;
  return_value_tor_addr_family_29=tor_addr_family_link1(addr_out);
  return (signed int)return_value_tor_addr_family_29;

err:
  ;
  if(!(base == ((char *)NULL)))
  {
    free((void *)base);
    base = (char *)(void *)0;
  }

  return -1;
}

// tor_addr_port_lookup
// file ../src/common/address.c line 1171
signed int tor_addr_port_lookup(const char *s, struct tor_addr_t *addr_out, unsigned short int *port_out)
{
  const char *port;
  struct tor_addr_t addr;
  unsigned short int portval;
  char *tmp = (char *)(void *)0;
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1178, "tor_addr_port_lookup", "s");
    abort();
  }

  if(addr_out == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1179, "tor_addr_port_lookup", "addr_out");
    abort();
  }

  s=eat_whitespace(s);
  if((signed int)*s == 91)
  {
    port=strstr(s, "]");
    if(port == ((const char *)NULL))
      goto err;

    tmp=tor_strndup_(s + (signed long int)1, (unsigned long int)(port - (s + (signed long int)1)));
    port = port + (signed long int)1;
    if((signed int)*port == 58)
      port = port + 1l;

    else
      port = (const char *)(void *)0;
  }

  else
  {
    char *return_value___builtin_strchr_1;
    return_value___builtin_strchr_1=__builtin_strchr(s, 58);
    port = return_value___builtin_strchr_1;
    if(!(port == ((const char *)NULL)))
      tmp=tor_strndup_(s, (unsigned long int)(port - s));

    else
      tmp=tor_strdup_(s);
    if(!(port == ((const char *)NULL)))
      port = port + 1l;

  }
  signed int return_value_tor_addr_lookup_2;
  return_value_tor_addr_lookup_2=tor_addr_lookup(tmp, (unsigned short int)0, &addr);
  if(return_value_tor_addr_lookup_2 == 0)
  {
    if(!(tmp == ((char *)NULL)))
    {
      free((void *)tmp);
      tmp = (char *)(void *)0;
    }

    if(!(port == ((const char *)NULL)))
    {
      signed long int return_value_tor_parse_long_3;
      return_value_tor_parse_long_3=tor_parse_long(port, 10, (signed long int)1, (signed long int)65535, (signed int *)(void *)0, (char **)(void *)0);
      portval = (unsigned short int)(signed int)return_value_tor_parse_long_3;
      if(portval == 0)
        goto err;

    }

    else
      portval = (unsigned short int)0;
    if(!(port_out == ((unsigned short int *)NULL)))
      *port_out = portval;

    tor_addr_copy(addr_out, &addr);
    return 0;
  }

  else
  {

  err:
    ;
    if(!(tmp == ((char *)NULL)))
    {
      free((void *)tmp);
      tmp = (char *)(void *)0;
    }

    return -1;
  }
}

// tor_addr_port_new
// file ../src/common/address.c line 1866
struct tor_addr_port_t * tor_addr_port_new(const struct tor_addr_t *addr, unsigned short int port)
{
  struct tor_addr_port_t *ap;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct tor_addr_port_t) /*24ul*/ );
  ap = (struct tor_addr_port_t *)return_value_tor_malloc_zero__1;
  if(!(addr == ((const struct tor_addr_t *)NULL)))
    tor_addr_copy(&ap->addr, addr);

  ap->port = port;
  return ap;
}

// tor_addr_port_parse
// file ../src/common/address.c line 1615
signed int tor_addr_port_parse(signed int severity, const char *addrport, struct tor_addr_t *address_out, unsigned short int *port_out, signed int default_port)
{
  signed int retval = -1;
  signed int r;
  char *addr_tmp = (char *)(void *)0;
  if(addrport == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1623, "tor_addr_port_parse", "addrport");
    abort();
  }

  if(address_out == ((struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1624, "tor_addr_port_parse", "address_out");
    abort();
  }

  if(port_out == ((unsigned short int *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1625, "tor_addr_port_parse", "port_out");
    abort();
  }

  r=tor_addr_port_split(severity, addrport, &addr_tmp, port_out);
  signed int return_value_tor_addr_parse_1;
  if(r >= 0)
  {
    if(*port_out == 0)
    {
      if(default_port >= 0)
      {
        *port_out = (unsigned short int)default_port;
        goto __CPROVER_DUMP_L5;
      }

    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      return_value_tor_addr_parse_1=tor_addr_parse(address_out, addr_tmp);
      if(return_value_tor_addr_parse_1 >= 0)
        retval = 0;

    }
  }


done:
  ;
  if(!(addr_tmp == ((char *)NULL)))
  {
    free((void *)addr_tmp);
    addr_tmp = (char *)(void *)0;
  }

  return retval;
}

// tor_addr_port_split
// file ../src/common/address.c line 1654
signed int tor_addr_port_split(signed int severity, const char *addrport, char **address_out, unsigned short int *port_out)
{
  struct tor_addr_t a_tmp;
  if(addrport == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1658, "tor_addr_port_split", "addrport");
    abort();
  }

  if(address_out == ((char **)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1659, "tor_addr_port_split", "address_out");
    abort();
  }

  if(port_out == ((unsigned short int *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)1660, "tor_addr_port_split", "port_out");
    abort();
  }

  signed int return_value_tor_addr_parse_1;
  return_value_tor_addr_parse_1=tor_addr_parse(&a_tmp, addrport);
  if(return_value_tor_addr_parse_1 == 10)
  {
    *port_out = (unsigned short int)0;
    *address_out=tor_strdup_(addrport);
    return 0;
  }

  else
  {
    signed int return_value_addr_port_lookup_2;
    return_value_addr_port_lookup_2=addr_port_lookup(severity, addrport, address_out, (unsigned int *)(void *)0, port_out);
    return return_value_addr_port_lookup_2;
  }
}

// tor_addr_to_PTR_name
// file ../src/common/address.c line 550
signed int tor_addr_to_PTR_name(char *out, unsigned long int outlen, const struct tor_addr_t *addr)
{
  if(out == ((char *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)553, "tor_addr_to_PTR_name", "out");
    abort();
  }

  if(addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)554, "tor_addr_to_PTR_name", "addr");
    abort();
  }

  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  if((signed int)addr->family == 2)
  {
    unsigned int a;
    a=tor_addr_to_ipv4h(addr);
    signed int return_value_tor_snprintf_1;
    return_value_tor_snprintf_1=tor_snprintf(out, outlen, "%d.%d.%d.%d.in-addr.arpa", (signed int)(unsigned char)(a & (unsigned int)0xff), (signed int)(unsigned char)(a >> 8 & (unsigned int)0xff), (signed int)(unsigned char)(a >> 16 & (unsigned int)0xff), (signed int)(unsigned char)(a >> 24 & (unsigned int)0xff));
    return return_value_tor_snprintf_1;
  }

  else
    if((signed int)addr->family == 10)
    {
      signed int i;
      char *cp = out;
      const unsigned char *bytes;
      struct in6_addr *return_value_tor_addr_to_in6_2;
      return_value_tor_addr_to_in6_2=tor_addr_to_in6_link1(addr);
      bytes = return_value_tor_addr_to_in6_2->__in6_u.__u6_addr8;
      if(!(outlen >= 73ul))
        return -1;

      i = 15;
      for( ; i >= 0; i = i - 1)
      {
        unsigned char byte = bytes[(signed long int)i];
        tmp_post_3 = cp;
        cp = cp + 1l;
        *tmp_post_3 = "0123456789abcdef"[(signed long int)((signed int)byte & 0x0f)];
        tmp_post_4 = cp;
        cp = cp + 1l;
        *tmp_post_4 = (char)46;
        tmp_post_5 = cp;
        cp = cp + 1l;
        *tmp_post_5 = "0123456789abcdef"[(signed long int)((signed int)byte >> 4)];
        tmp_post_6 = cp;
        cp = cp + 1l;
        *tmp_post_6 = (char)46;
      }
      memcpy_link1((void *)cp, (const void *)"ip6.arpa", (unsigned long int)9);
      return 32 * 2 + 8;
    }

  return -1;
}

// tor_addr_to_in6
// file ../src/common/address.h line 95
static inline struct in6_addr * tor_addr_to_in6(const struct tor_addr_t *a)
{
  struct in6_addr *tmp_if_expr_1;
  if((signed int)a->family == 10)
    tmp_if_expr_1 = &a->addr.in6_addr;

  else
    tmp_if_expr_1 = (struct in6_addr *)(void *)0;
  return tmp_if_expr_1;
}

// tor_addr_to_in6_link1
// file ../src/common/address.h line 95
static inline struct in6_addr * tor_addr_to_in6_link1(const struct tor_addr_t *a_link1)
{
  struct in6_addr *tmp_if_expr_1_link1;
  if((signed int)a_link1->family == 10)
    tmp_if_expr_1_link1 = &a_link1->addr.in6_addr;

  else
    tmp_if_expr_1_link1 = (struct in6_addr *)(void *)0;
  return tmp_if_expr_1_link1;
}

// tor_addr_to_ipv4h
// file ../src/common/address.h line 126
static inline unsigned int tor_addr_to_ipv4h(const struct tor_addr_t *a)
{
  unsigned int return_value_tor_addr_to_ipv4n_1;
  return_value_tor_addr_to_ipv4n_1=tor_addr_to_ipv4n_link1(a);
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32_link1(return_value_tor_addr_to_ipv4n_1);
  return return_value___bswap_32_2;
}

// tor_addr_to_ipv4h_link1
// file ../src/common/address.h line 126
static inline unsigned int tor_addr_to_ipv4h_link1(const struct tor_addr_t *a_link1)
{
  unsigned int return_value_tor_addr_to_ipv4n_1_link1;
  return_value_tor_addr_to_ipv4n_1_link1=tor_addr_to_ipv4n_link2(a_link1);
  unsigned int return_value___bswap_32_2_link1;
  return_value___bswap_32_2_link1=__bswap_32_link2(return_value_tor_addr_to_ipv4n_1_link1);
  return return_value___bswap_32_2_link1;
}

// tor_addr_to_ipv4n
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n(const struct tor_addr_t *a)
{
  unsigned int tmp_if_expr_1;
  if((signed int)a->family == 2)
    tmp_if_expr_1 = a->addr.in_addr.s_addr;

  else
    tmp_if_expr_1 = (unsigned int)0;
  return tmp_if_expr_1;
}

// tor_addr_to_ipv4n_link1
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n_link1(const struct tor_addr_t *a_link1)
{
  unsigned int tmp_if_expr_1_link1;
  if((signed int)a_link1->family == 2)
    tmp_if_expr_1_link1 = a_link1->addr.in_addr.s_addr;

  else
    tmp_if_expr_1_link1 = (unsigned int)0;
  return tmp_if_expr_1_link1;
}

// tor_addr_to_ipv4n_link2
// file ../src/common/address.h line 119
static inline unsigned int tor_addr_to_ipv4n_link2(const struct tor_addr_t *a_link2)
{
  unsigned int tmp_if_expr_1_link2;
  if((signed int)a_link2->family == 2)
    tmp_if_expr_1_link2 = a_link2->addr.in_addr.s_addr;

  else
    tmp_if_expr_1_link2 = (unsigned int)0;
  return tmp_if_expr_1_link2;
}

// tor_addr_to_mapped_ipv4h
// file ../src/common/address.h line 135
static inline unsigned int tor_addr_to_mapped_ipv4h(const struct tor_addr_t *a)
{
  if((signed int)a->family == 10)
  {
    unsigned int *addr32 = (unsigned int *)(void *)0;
    struct in6_addr *return_value_tor_addr_to_in6_1;
    return_value_tor_addr_to_in6_1=tor_addr_to_in6_link1(a);
    addr32 = (unsigned int *)return_value_tor_addr_to_in6_1->__in6_u.__u6_addr32;
    if(addr32 == ((unsigned int *)NULL))
    {
      tor_assertion_failed_("../src/common/address.h", (unsigned int)144, "tor_addr_to_mapped_ipv4h", "addr32");
      abort();
    }

    unsigned int return_value___bswap_32_2;
    return_value___bswap_32_2=__bswap_32_link1(addr32[(signed long int)3]);
    return return_value___bswap_32_2;
  }

  else
    return (unsigned int)0;
}

// tor_addr_to_sockaddr
// file ../src/common/address.c line 89
unsigned int tor_addr_to_sockaddr(const struct tor_addr_t *a, unsigned short int port, struct sockaddr *sa_out, unsigned int len)
{
  memset_link1((void *)sa_out, 0, (unsigned long int)len);
  unsigned short int family;
  family=tor_addr_family_link1(a);
  unsigned short int tmp_statement_expression_1;
  unsigned short int tmp_statement_expression_2;
  if((signed int)family == 2)
  {
    struct sockaddr_in *sin;
    if(!(len >= (unsigned int)sizeof(struct sockaddr_in) /*16u*/ ))
      return (unsigned int)0;

    sin = (struct sockaddr_in *)sa_out;
    sin->sin_family = (unsigned short int)2;
    unsigned short int __v;
    unsigned short int tor_addr_to_sockaddr__1__1__1____x = (unsigned short int)port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(tor_addr_to_sockaddr__1__1__1____x) : "cc");
    tmp_statement_expression_1 = __v;
    sin->sin_port = tmp_statement_expression_1;
    sin->sin_addr.s_addr=tor_addr_to_ipv4n_link1(a);
    return (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  }

  else
    if((signed int)family == 10)
    {
      struct sockaddr_in6 *sin6;
      if(!(len >= (unsigned int)sizeof(struct sockaddr_in6) /*28u*/ ))
        return (unsigned int)0;

      sin6 = (struct sockaddr_in6 *)sa_out;
      sin6->sin6_family = (unsigned short int)10;
      unsigned short int tor_addr_to_sockaddr__1__2__1____v;
      unsigned short int __x = (unsigned short int)port;
      asm("rorw _8, %w0" : "=r"(tor_addr_to_sockaddr__1__2__1____v) : "0"(__x) : "cc");
      tmp_statement_expression_2 = tor_addr_to_sockaddr__1__2__1____v;
      sin6->sin6_port = tmp_statement_expression_2;
      struct in6_addr *return_value_tor_addr_to_in6_3;
      return_value_tor_addr_to_in6_3=tor_addr_to_in6_link1(a);
      memcpy_link1((void *)&sin6->sin6_addr, (const void *)return_value_tor_addr_to_in6_3, sizeof(struct in6_addr) /*16ul*/ );
      return (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    }

    else
      return (unsigned int)0;
}

// tor_addr_to_str
// file ../src/common/address.c line 409
const char * tor_addr_to_str(char *dest, const struct tor_addr_t *addr, unsigned long int len, signed int decorate)
{
  const char *ptr;
  if(dest == ((char *)NULL) || addr == ((const struct tor_addr_t *)NULL))
  {
    tor_assertion_failed_("../src/common/address.c", (unsigned int)412, "tor_addr_to_str", "addr && dest");
    abort();
  }

  unsigned short int return_value_tor_addr_family_1;
  return_value_tor_addr_family_1=tor_addr_family_link1(addr);
  switch((signed int)return_value_tor_addr_family_1)
  {
    case 2:
    {
      if(!(len >= 8ul))
        return (const char *)(void *)0;

      ptr=tor_inet_ntop(2, (const void *)&addr->addr.in_addr, dest, len);
      break;
    }
    case 10:
    {
      if(!(len >= (unsigned long int)(3 + (decorate == 0 ? 0 : 2))))
        return (const char *)(void *)0;

      if(!(decorate == 0))
        ptr=tor_inet_ntop(10, (const void *)&addr->addr.in6_addr, dest + (signed long int)1, len - (unsigned long int)2);

      else
        ptr=tor_inet_ntop(10, (const void *)&addr->addr.in6_addr, dest, len);
      if(!(ptr == ((const char *)NULL)) && !(decorate == 0))
      {
        *dest = (char)91;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(dest);
        memcpy_link1((void *)(dest + (signed long int)return_value_strlen_2), (const void *)"]", (unsigned long int)2);
        if(!(ptr == dest + 1l))
        {
          tor_assertion_failed_("../src/common/address.c", (unsigned int)434, "tor_addr_to_str", "ptr == dest+1");
          abort();
        }

        ptr = dest;
      }

      break;
    }
    case 1:
    {
      tor_snprintf(dest, len, "AF_UNIX");
      ptr = dest;
      break;
    }
    default:
      return (const char *)(void *)0;
  }
  return ptr;
}

// tor_asprintf
// file ../src/common/compat.h line 305
signed int tor_asprintf(char **strp, const char *fmt, ...)
{
  signed int r;
  void **args = (void **)&fmt;
  r=tor_vasprintf(strp, fmt, args);
  args = ((void **)NULL);
  if(*strp == ((char *)NULL) || !(r >= 0))
  {
    log_fn_(3, 1u << 12, "tor_asprintf", "Internal error in asprintf");
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)493, "tor_asprintf", "0");
    abort();
  }

  return r;
}

// tor_assertion_failed_
// file ../src/tools/../common/util.h line 56
void tor_assertion_failed_(const char *fname, unsigned int line, const char *func, const char *expr)
{
  char buf[256l];
  log_fn_(3, 1u << 12, "tor_assertion_failed_", "%s:%u: %s: Assertion %s failed; aborting.", fname, line, func, expr);
  tor_snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Assertion %s failed in %s at %s:%u", expr, func, fname, line);
  log_backtrace(3, (signed int)(1u << 12), buf);
}

// tor_calloc_
// file ../src/common/util.h line 80
void * tor_calloc_(unsigned long int nmemb, unsigned long int size)
{
  signed int return_value_size_mul_check_1;
  return_value_size_mul_check_1=size_mul_check(nmemb, size);
  if(return_value_size_mul_check_1 == 0)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)230, "tor_calloc_", "size_mul_check(nmemb, size)");
    abort();
  }

  void *return_value_tor_malloc_zero__2;
  return_value_tor_malloc_zero__2=tor_malloc_zero_(nmemb * size);
  return return_value_tor_malloc_zero__2;
}

// tor_check_port_forwarding
// file ../src/common/util.c line 5231
void tor_check_port_forwarding(const char *filename, struct smartlist_t *ports_to_forward, signed long int now)
{
  signed int stderr_status;
  signed int retval;
  signed int stdout_status = 0;
  if(filename == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)5249, "tor_check_port_forwarding", "filename");
    abort();
  }

  _Bool tmp_if_expr_6;
  static struct process_handle_t *child_handle = (struct process_handle_t *)(void *)0;
  if(child_handle == ((struct process_handle_t *)NULL))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = child_handle->status != 1 ? (_Bool)1 : (_Bool)0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  static signed long int time_to_run_helper = (signed long int)0;
  if(tmp_if_expr_6)
  {
    if(!(time_to_run_helper >= now))
    {
      const char **argv;
      signed int args_n;
      signed int status;
      signed int argv_index = 0;
      if(!(ports_to_forward->num_used >= 1))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)5259, "tor_check_port_forwarding", "smartlist_len(ports_to_forward) > 0");
        abort();
      }

      if((unsigned long int)ports_to_forward->num_used >= 1152921504606846975ul)
      {
        log_fn_(4, 1u << 0, "tor_check_port_forwarding", "Overflow during argv allocation. This shouldn't happen.");
        goto __CPROVER_DUMP_L20;
      }

      if(ports_to_forward->num_used >= 1073741823)
      {
        log_fn_(4, 1u << 0, "tor_check_port_forwarding", "Overflow during argv_index increase. This shouldn't happen.");
        goto __CPROVER_DUMP_L20;
      }

      args_n = 1 + 2 * ports_to_forward->num_used + 1;
      void *return_value_tor_calloc__1;
      return_value_tor_calloc__1=tor_calloc_((unsigned long int)args_n, sizeof(char *) /*8ul*/ );
      argv = (const char **)return_value_tor_calloc__1;
      tmp_post_2 = argv_index;
      argv_index = argv_index + 1;
      argv[(signed long int)tmp_post_2] = filename;
      signed int port_sl_idx;
      signed int port_sl_len = ports_to_forward->num_used;
      const char *port;
      port_sl_idx = 0;
      for( ; !(port_sl_idx >= port_sl_len); port_sl_idx = port_sl_idx + 1)
      {
        port = (const char *)ports_to_forward->list[(signed long int)port_sl_idx];
        tmp_post_3 = argv_index;
        argv_index = argv_index + 1;
        argv[(signed long int)tmp_post_3] = "-p";
        tmp_post_4 = argv_index;
        argv_index = argv_index + 1;
        argv[(signed long int)tmp_post_4] = port;
        port = (const char *)(void *)0;
      }
      argv[(signed long int)argv_index] = (const char *)(void *)0;
      time_to_run_helper = now + (signed long int)300;
      if(!(child_handle == ((struct process_handle_t *)NULL)))
      {
        tor_process_handle_destroy(child_handle, 1);
        child_handle = (struct process_handle_t *)(void *)0;
      }

      status=tor_spawn_background(filename, argv, (struct process_environment_t *)(void *)0, &child_handle);
      tor_free_((void *)argv);
      argv = (const char **)(void *)0;
      if(status == -1)
      {
        log_fn_(4, 1u << 0, "tor_check_port_forwarding", "Failed to start port forwarding helper %s", filename);
        time_to_run_helper = now + (signed long int)60;
        goto __CPROVER_DUMP_L20;
      }

      signed int return_value_tor_process_get_pid_5;
      return_value_tor_process_get_pid_5=tor_process_get_pid(child_handle);
      log_fn_(6, 1u << 0, "tor_check_port_forwarding", "Started port forwarding helper (%s) with pid '%d'", filename, return_value_tor_process_get_pid_5);
    }

  }

  if(!(child_handle == ((struct process_handle_t *)NULL)))
  {
    if(child_handle->status == 1)
    {
      retval = 0;
      stderr_status=log_from_pipe(child_handle->stderr_handle, 6, filename, &retval);
      signed int return_value_handle_fw_helper_output_7;
      return_value_handle_fw_helper_output_7=handle_fw_helper_output(filename, child_handle);
      if(!(return_value_handle_fw_helper_output_7 >= 0))
      {
        log_fn_(4, 1u << 0, "tor_check_port_forwarding", "Failed to handle fw helper output.");
        stdout_status = -1;
        retval = -1;
      }

      if(!(retval == 0))
        time_to_run_helper = now + (signed long int)60;

      if(stderr_status == -1 || stdout_status == -1)
        retval = -1;

      else
        if(stderr_status == 1 || stdout_status == 1)
          retval = 1;

        else
          retval = 0;
      if(!(retval == 0))
      {
        if(retval == 1)
        {
          log_fn_(6, 1u << 0, "tor_check_port_forwarding", "Port forwarding helper terminated");
          child_handle->status = 0;
        }

        else
        {
          log_fn_(4, 1u << 0, "tor_check_port_forwarding", "Failed to read from port forwarding helper");
          child_handle->status = -1;
        }
      }

    }

  }


__CPROVER_DUMP_L20:
  ;
}

// tor_close_socket
// file ../src/common/compat.h line 462
signed int tor_close_socket(signed int s)
{
  signed int r;
  r=tor_close_socket_simple(s);
  socket_accounting_lock();
  if(r == 0)
    n_sockets_open = n_sockets_open - 1;

  else
  {
    if(!(r == 9))
      n_sockets_open = n_sockets_open - 1;

    r = -1;
  }
  if(!(n_sockets_open >= 0))
    log_fn_(4, 1u << 12, "tor_close_socket", "Our socket count is below zero: %d. Please submit a bug report.", n_sockets_open);

  socket_accounting_unlock();
  return r;
}

// tor_close_socket_simple
// file ../src/common/compat.c line 1067
signed int tor_close_socket_simple(signed int s)
{
  signed int r = 0;
  r=close(s);
  if(!(r == 0))
  {
    signed int err;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    err = *return_value___errno_location_1;
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(err);
    log_fn_(6, 1u << 2, "tor_close_socket_simple", "Close returned an error: %s", return_value_strerror_2);
    return err;
  }

  return r;
}

// tor_cond_free
// file ../src/common/compat_threads.c line 65
void tor_cond_free(struct tor_cond_t *c)
{
  if(!(c == ((struct tor_cond_t *)NULL)))
  {
    tor_cond_uninit(c);
    if(!(c == ((struct tor_cond_t *)NULL)))
    {
      free((void *)c);
      c = (struct tor_cond_t *)(void *)0;
    }

  }

}

// tor_cond_init
// file ../src/common/compat_threads.h line 81
signed int tor_cond_init(struct tor_cond_t *cond)
{
  union anonymous_7 condattr;
  memset_link12((void *)cond, 0, sizeof(struct tor_cond_t) /*48ul*/ );
  signed int return_value_pthread_condattr_init_1;
  return_value_pthread_condattr_init_1=pthread_condattr_init(&condattr);
  if(!(return_value_pthread_condattr_init_1 == 0))
    return -1;

  else
  {
    signed int return_value_pthread_condattr_setclock_2;
    return_value_pthread_condattr_setclock_2=pthread_condattr_setclock(&condattr, 1);
    if(!(return_value_pthread_condattr_setclock_2 == 0))
      return -1;

    else
    {
      signed int return_value_pthread_cond_init_3;
      return_value_pthread_cond_init_3=pthread_cond_init(&cond->cond, &condattr);
      if(!(return_value_pthread_cond_init_3 == 0))
        return -1;

      else
        return 0;
    }
  }
}

// tor_cond_new
// file ../src/common/compat_threads.c line 55
struct tor_cond_t * tor_cond_new(void)
{
  struct tor_cond_t *cond;
  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(sizeof(struct tor_cond_t) /*48ul*/ );
  cond = (struct tor_cond_t *)return_value_tor_malloc__1;
  signed int return_value_tor_cond_init_2;
  return_value_tor_cond_init_2=tor_cond_init(cond);
  if(!(return_value_tor_cond_init_2 >= 0))
  {
    if(!(cond == ((struct tor_cond_t *)NULL)))
    {
      free((void *)cond);
      cond = (struct tor_cond_t *)(void *)0;
    }

  }

  return cond;
}

// tor_cond_signal_all
// file ../src/common/compat_threads.h line 86
void tor_cond_signal_all(struct tor_cond_t *cond)
{
  pthread_cond_broadcast(&cond->cond);
}

// tor_cond_signal_one
// file ../src/common/compat_threads.h line 85
void tor_cond_signal_one(struct tor_cond_t *cond)
{
  pthread_cond_signal(&cond->cond);
}

// tor_cond_uninit
// file ../src/common/compat_threads.h line 82
void tor_cond_uninit(struct tor_cond_t *cond)
{
  signed int return_value_pthread_cond_destroy_3;
  return_value_pthread_cond_destroy_3=pthread_cond_destroy(&cond->cond);
  if(!(return_value_pthread_cond_destroy_3 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 0, "tor_cond_uninit", "Error freeing condition: %s", return_value_strerror_2);
    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// tor_cond_wait
// file ../src/common/compat_threads.h line 83
signed int tor_cond_wait(struct tor_cond_t *cond, struct tor_mutex_t *mutex, struct timeval *tv)
{
  signed int r;
  if(tv == ((struct timeval *)NULL))
    while((_Bool)1)
    {
      r=pthread_cond_wait(&cond->cond, &mutex->mutex);
      if(!(r == 4))
        return r != 0 ? -1 : 0;

    }

  else
  {
    struct timeval tvnow;
    struct timeval tvsum;
    struct timespec ts;
    while((_Bool)1)
    {
      signed int return_value_clock_gettime_1;
      return_value_clock_gettime_1=clock_gettime(1, &ts);
      if(!(return_value_clock_gettime_1 >= 0))
        return -1;

      tvnow.tv_sec = ts.tv_sec;
      tvnow.tv_usec = ts.tv_nsec / (signed long int)1000;
      do
      {
        (&tvsum)->tv_sec = tv->tv_sec + (&tvnow)->tv_sec;
        (&tvsum)->tv_usec = tv->tv_usec + (&tvnow)->tv_usec;
        if(tvsum.tv_usec >= 1000000l)
        {
          (&tvsum)->tv_sec = (&tvsum)->tv_sec + 1l;
          (&tvsum)->tv_usec = (&tvsum)->tv_usec - (signed long int)1000000;
        }

      }
      while((_Bool)0);
      ts.tv_sec = tvsum.tv_sec;
      ts.tv_nsec = tvsum.tv_usec * (signed long int)1000;
      r=pthread_cond_timedwait(&cond->cond, &mutex->mutex, &ts);
      if(r == 0)
        return 0;

      else
        if(r == 110)
          return 1;

        else
          if(r == 4)
            continue;

          else
            return -1;
    }
  }
}

// tor_digest256_is_zero
// file ../src/common/util.c line 1086
signed int tor_digest256_is_zero(const char *digest)
{
  signed int return_value_tor_mem_is_zero_1;
  return_value_tor_mem_is_zero_1=tor_mem_is_zero(digest, (unsigned long int)32);
  return return_value_tor_mem_is_zero_1;
}

// tor_digest_is_zero
// file ../src/common/util.c line 981
signed int tor_digest_is_zero(const char *digest)
{
  signed int return_value_tor_memeq_1;
  static const unsigned char ZERO_DIGEST[20l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  return_value_tor_memeq_1=tor_memeq((const void *)digest, (const void *)ZERO_DIGEST, (unsigned long int)20);
  return return_value_tor_memeq_1;
}

// tor_disable_debugger_attach
// file ../src/common/compat.c line 1997
signed int tor_disable_debugger_attach(void)
{
  signed int r;
  signed int attempted;
  r = -1;
  attempted = 0;
  if(log_global_min_severity_ == 7)
    log_fn_(7, 1u << 3, "tor_disable_debugger_attach", "Attemping to disable debugger attachment to Tor for unprivileged users.");

  attempted = 1;
  r=prctl(4, 0);
  if(r == 0 && !(attempted == 0))
  {
    if(log_global_min_severity_ == 7)
      log_fn_(7, 1u << 3, "tor_disable_debugger_attach", "Debugger attachment disabled for unprivileged users.");

    return 1;
  }

  else
    if(!(attempted == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 3, "tor_disable_debugger_attach", "Unable to disable debugger attaching: %s", return_value_strerror_2);
    }

  return r;
}

// tor_dup_addr
// file ../src/common/address.c line 1079
char * tor_dup_addr(const struct tor_addr_t *addr)
{
  char buf[48l];
  const char *return_value_tor_addr_to_str_3;
  return_value_tor_addr_to_str_3=tor_addr_to_str(buf, addr, sizeof(char [48l]) /*48ul*/ , 0);
  if(!(return_value_tor_addr_to_str_3 == ((const char *)NULL)))
  {
    char *return_value_tor_strdup__1;
    return_value_tor_strdup__1=tor_strdup_(buf);
    return return_value_tor_strdup__1;
  }

  else
  {
    char *return_value_tor_strdup__2;
    return_value_tor_strdup__2=tor_strdup_("<unknown address type>");
    return return_value_tor_strdup__2;
  }
}

// tor_dup_ip
// file ../src/common/address.c line 1825
char * tor_dup_ip(unsigned int addr)
{
  char buf[48l];
  struct in_addr in;
  in.s_addr=__bswap_32_link1(addr);
  tor_inet_ntop(2, (const void *)&in, buf, sizeof(char [48l]) /*48ul*/ );
  char *return_value_tor_strdup__1;
  return_value_tor_strdup__1=tor_strdup_(buf);
  return return_value_tor_strdup__1;
}

// tor_escape_str_for_pt_args
// file ../src/common/util.c line 1422
char * tor_escape_str_for_pt_args(const char *string, const char *chars_to_escape)
{
  char *new_string = (char *)(void *)0;
  char *new_cp = (char *)(void *)0;
  unsigned long int length;
  unsigned long int new_length;
  if(string == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1428, "tor_escape_str_for_pt_args", "string");
    abort();
  }

  length=strlen(string);
  char *return_value_tor_strdup__1;
  char *tmp_post_3;
  char *tmp_post_5;
  const char *tmp_post_6;
  if(length == 0ul)
  {
    return_value_tor_strdup__1=tor_strdup_("");
    return return_value_tor_strdup__1;
  }

  else
    if(length >= 9223372036854775808ul)
      return (char *)(void *)0;

    else
    {
      new_length = length * (unsigned long int)2 + (unsigned long int)1;
      void *return_value_tor_malloc__2;
      return_value_tor_malloc__2=tor_malloc_(new_length);
      new_cp = (char *)return_value_tor_malloc__2;
      new_string = new_cp;
      while(!(*string == 0))
      {
        char *return_value___builtin_strchr_4;
        return_value___builtin_strchr_4=__builtin_strchr(chars_to_escape, (signed int)*string);
        if(!(return_value___builtin_strchr_4 == ((char *)NULL)))
        {
          tmp_post_3 = new_cp;
          new_cp = new_cp + 1l;
          *tmp_post_3 = (char)92;
        }

        tmp_post_5 = new_cp;
        new_cp = new_cp + 1l;
        tmp_post_6 = string;
        string = string + 1l;
        *tmp_post_5 = *tmp_post_6;
      }
      *new_cp = (char)0;
      return new_string;
    }
}

// tor_fd_getpos
// file ../src/common/compat.c line 973
signed long int tor_fd_getpos(signed int fd)
{
  signed long int return_value_lseek_1;
  return_value_lseek_1=lseek(fd, (signed long int)0, 1);
  return (signed long int)return_value_lseek_1;
}

// tor_fd_seekend
// file ../src/common/compat.c line 986
signed int tor_fd_seekend(signed int fd)
{
  signed long int rc;
  signed long int return_value_lseek_1;
  return_value_lseek_1=lseek(fd, (signed long int)0, 2);
  rc = (signed long int)(return_value_lseek_1 < (signed long int)0 ? -1 : 0);
  signed int *return_value___errno_location_2;
  if(!(rc >= 0l))
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 29)
      rc = (signed long int)0;

  }

  return rc < (signed long int)0 ? -1 : 0;
}

// tor_fd_setpos
// file ../src/common/compat.c line 1005
signed int tor_fd_setpos(signed int fd, signed long int pos)
{
  signed long int return_value_lseek_1;
  return_value_lseek_1=lseek(fd, pos, 0);
  return return_value_lseek_1 < (signed long int)0 ? -1 : 0;
}

// tor_fopen_cloexec
// file ../src/common/compat.c line 170
struct _IO_FILE * tor_fopen_cloexec(const char *path, const char *mode)
{
  struct _IO_FILE *result;
  result=fopen(path, mode);
  if(!(result == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fileno_3;
    return_value_fileno_3=fileno(result);
    signed int return_value_fcntl_4;
    return_value_fcntl_4=fcntl(return_value_fileno_3, 2, 1);
    if(return_value_fcntl_4 == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 4, "tor_fopen_cloexec", "Couldn't set FD_CLOEXEC: %s", return_value_strerror_2);
      fclose(result);
      return (struct _IO_FILE *)(void *)0;
    }

  }

  return result;
}

// tor_free_
// file ../src/common/util.h line 90
void tor_free_(void *mem)
{
  if(!(mem == NULL))
  {
    free(mem);
    mem = (void *)0;
  }

}

// tor_ftruncate
// file ../src/common/compat.c line 1017
signed int tor_ftruncate(signed int fd)
{
  signed int return_value_tor_fd_setpos_1;
  return_value_tor_fd_setpos_1=tor_fd_setpos(fd, (signed long int)0);
  if(!(return_value_tor_fd_setpos_1 >= 0))
    return -1;

  else
  {
    signed int return_value_ftruncate_2;
    return_value_ftruncate_2=ftruncate(fd, (signed long int)0);
    return return_value_ftruncate_2;
  }
}

// tor_get_exit_code
// file ../src/common/util.c line 4385
signed int tor_get_exit_code(struct process_handle_t *process_handle, signed int block, signed int *exit_code)
{
  signed int stat_loc;
  signed int retval;
  if(!(process_handle->waitpid_cb == ((struct waitpid_callback_t *)NULL)))
  {
    retval=waitpid(process_handle->pid, &stat_loc, block != 0 ? 0 : 1);
    if(retval == process_handle->pid)
    {
      clear_waitpid_callback(process_handle->waitpid_cb);
      process_handle->waitpid_cb = (struct waitpid_callback_t *)(void *)0;
      process_handle->waitpid_exit_status = stat_loc;
    }

  }

  else
  {
    retval = process_handle->pid;
    stat_loc = process_handle->waitpid_exit_status;
  }
  if(retval == 0 && block == 0)
    return 1;

  else
    if(!(retval == process_handle->pid))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 0, "tor_get_exit_code", "waitpid() failed for PID %d: %s", process_handle->pid, return_value_strerror_2);
      return -1;
    }

  if(!((0x7f & stat_loc) == 0))
  {
    log_fn_(4, 1u << 0, "tor_get_exit_code", "Process %d did not exit normally", process_handle->pid);
    return -1;
  }

  else
  {
    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_16
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if(!(exit_code == ((signed int *)NULL)))
      *exit_code = (((union anonymous_16){ .__in=stat_loc }).__i & 0xff00) >> 8;

    return 0;
  }
}

// tor_get_lines_from_handle
// file ../src/common/util.c line 4968
struct smartlist_t * tor_get_lines_from_handle(struct _IO_FILE *handle, enum stream_status *stream_status_out)
{
  enum stream_status stream_status;
  char stdout_buf[400l];
  struct smartlist_t *lines = (struct smartlist_t *)(void *)0;
  while((_Bool)1)
  {
    memset_link7((void *)stdout_buf, 0, sizeof(char [400l]) /*400ul*/ );
    stream_status=get_string_from_pipe(handle, stdout_buf, sizeof(char [400l]) /*400ul*/  - (unsigned long int)1);
    if(!((signed int)stream_status == IO_STREAM_OKAY))
      break;

    if(lines == ((struct smartlist_t *)NULL))
      lines=smartlist_new();

    char *return_value_tor_strdup__1;
    return_value_tor_strdup__1=tor_strdup_(stdout_buf);
    smartlist_add(lines, (void *)return_value_tor_strdup__1);
  }

done:
  ;
  *stream_status_out = stream_status;
  return lines;
}

// tor_get_thread_id
// file ../src/common/compat_threads.h line 55
unsigned long int tor_get_thread_id(void)
{
  /* tag-#anon#lUN[U64'thr'||U64'id'|] */
union anonymous_10
{
  // thr
  unsigned long int thr;
  // id
  unsigned long int id;
};

/* */
  ;
  union anonymous_10 r;
  r.thr=pthread_self();
  return r.id;
}

// tor_gethostname
// file ../src/common/compat.c line 2205
signed int tor_gethostname(char *name, unsigned long int namelen)
{
  signed int return_value_gethostname_1;
  return_value_gethostname_1=gethostname(name, namelen);
  return return_value_gethostname_1;
}

// tor_getpwnam
// file ../src/common/compat.c line 1783
struct passwd * tor_getpwnam(const char *username)
{
  struct passwd *pw;
  _Bool tmp_if_expr_1;
  signed int tmp_statement_expression_2;
  if(username == ((const char *)NULL))
  {
    tor_passwd_free(passwd_cached);
    passwd_cached = (struct passwd *)(void *)0;
    return (struct passwd *)(void *)0;
  }

  else
  {
    pw=getpwnam(username);
    if(!(pw == ((struct passwd *)NULL)))
    {
      tor_passwd_free(passwd_cached);
      passwd_cached=tor_passwd_dup(pw);
      log_fn_(6, 1u << 0, "tor_getpwnam", "Caching new entry %s for %s", passwd_cached->pw_name, username);
      return pw;
    }

    else
    {
      if(passwd_cached == ((struct passwd *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(passwd_cached->pw_name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        return (struct passwd *)(void *)0;

      else
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_3;
        return_value___builtin_strcmp_3=__builtin_strcmp(username, passwd_cached->pw_name);
        tmp_statement_expression_2 = return_value___builtin_strcmp_3;
        if(tmp_statement_expression_2 == 0)
          return passwd_cached;

        else
          return (struct passwd *)(void *)0;
      }
    }
  }
}

// tor_getpwuid
// file ../src/common/compat.c line 1819
struct passwd * tor_getpwuid(unsigned int uid)
{
  struct passwd *pw;
  pw=getpwuid(uid);
  if(!(pw == ((struct passwd *)NULL)))
    return pw;

  else
    if(passwd_cached == ((struct passwd *)NULL))
      return (struct passwd *)(void *)0;

    else
      if(uid == passwd_cached->pw_uid)
        return passwd_cached;

      else
        return (struct passwd *)(void *)0;
}

// tor_gettimeofday
// file ../src/common/compat.c line 2621
void tor_gettimeofday(struct timeval *timeval)
{
  signed int return_value_gettimeofday_1;
  return_value_gettimeofday_1=gettimeofday(timeval, (struct timezone *)(void *)0);
  if(!(return_value_gettimeofday_1 == 0))
  {
    log_fn_(3, 1u << 0, "tor_gettimeofday", "gettimeofday failed.");
    exit(1);
  }

  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// tor_gmtime_r
// file ../src/common/compat.c line 2800
struct tm * tor_gmtime_r(const signed long int *timep, struct tm *result)
{
  struct tm *r;
  r=gmtime_r(timep, result);
  struct tm *return_value_correct_tm_1;
  return_value_correct_tm_1=correct_tm(0, timep, result, r);
  return return_value_correct_tm_1;
}

// tor_inet_aton
// file ../src/common/compat.h line 545
signed int tor_inet_aton(const char *str, struct in_addr *addr)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  char more;
  signed int return_value_tor_sscanf_1;
  return_value_tor_sscanf_1=tor_sscanf(str, "%3u.%3u.%3u.%3u%c", &a, &b, &c, &d, &more);
  if(!(return_value_tor_sscanf_1 == 4))
    return 0;

  else
    if(a >= 256u)
      return 0;

    else
      if(b >= 256u)
        return 0;

      else
        if(c >= 256u)
          return 0;

        else
          if(d >= 256u)
            return 0;

          else
          {
            addr->s_addr=__bswap_32_link2(a << 24 | b << 16 | c << 8 | d);
            return 1;
          }
}

// tor_inet_ntoa
// file ../src/common/address.c line 1811
signed int tor_inet_ntoa(struct in_addr *in, char *buf, unsigned long int buf_len)
{
  unsigned int a;
  a=__bswap_32_link1(in->s_addr);
  signed int return_value_tor_snprintf_1;
  return_value_tor_snprintf_1=tor_snprintf(buf, buf_len, "%d.%d.%d.%d", (signed int)(unsigned char)(a >> 24 & (unsigned int)0xff), (signed int)(unsigned char)(a >> 16 & (unsigned int)0xff), (signed int)(unsigned char)(a >> 8 & (unsigned int)0xff), (signed int)(unsigned char)(a & (unsigned int)0xff));
  return return_value_tor_snprintf_1;
}

// tor_inet_ntop
// file ../src/common/compat.h line 546
const char * tor_inet_ntop(signed int af, const void *src, char *dst, unsigned long int len)
{
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  signed int tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_10;
  if(af == 2)
  {
    signed int return_value_tor_inet_ntoa_1;
    return_value_tor_inet_ntoa_1=tor_inet_ntoa((struct in_addr *)src, dst, len);
    if(!(return_value_tor_inet_ntoa_1 >= 0))
      return (const char *)(void *)0;

    else
      return dst;
  }

  else
    if(af == 10)
    {
      struct in6_addr *addr = (struct in6_addr *)src;
      char buf[64l];
      char *cp;
      signed int longestGapLen = 0;
      signed int longestGapPos = -1;
      signed int i;
      signed int curGapPos = -1;
      signed int curGapLen = 0;
      unsigned short int words[8l];
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        words[(signed long int)i] = (unsigned short int)(((signed int)(unsigned short int)addr->__in6_u.__u6_addr8[(signed long int)(2 * i)] << 8) + (signed int)addr->__in6_u.__u6_addr8[(signed long int)(2 * i + 1)]);
      if((signed int)words[0l] == 0)
      {
        if((signed int)words[1l] == 0)
        {
          if((signed int)words[2l] == 0)
          {
            if((signed int)words[3l] == 0)
            {
              if((signed int)words[4l] == 0)
              {
                if((signed int)words[5l] == 0)
                  tmp_if_expr_3 = words[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_3 = (_Bool)0;
                if(tmp_if_expr_3)
                  tmp_if_expr_4 = words[(signed long int)7] != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_4 = (_Bool)0;
                if(tmp_if_expr_4)
                  tmp_if_expr_5 = (_Bool)1;

                else
                  tmp_if_expr_5 = (signed int)words[(signed long int)5] == 0xffff ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_5)
                {
                  if((signed int)words[5l] == 0)
                    tor_snprintf(buf, sizeof(char [64l]) /*64ul*/ , "::%d.%d.%d.%d", addr->__in6_u.__u6_addr8[(signed long int)12], addr->__in6_u.__u6_addr8[(signed long int)13], addr->__in6_u.__u6_addr8[(signed long int)14], addr->__in6_u.__u6_addr8[(signed long int)15]);

                  else
                    tor_snprintf(buf, sizeof(char [64l]) /*64ul*/ , "::%x:%d.%d.%d.%d", words[(signed long int)5], addr->__in6_u.__u6_addr8[(signed long int)12], addr->__in6_u.__u6_addr8[(signed long int)13], addr->__in6_u.__u6_addr8[(signed long int)14], addr->__in6_u.__u6_addr8[(signed long int)15]);
                  unsigned long int return_value_strlen_2;
                  return_value_strlen_2=strlen(buf);
                  if(!(len >= 1ul + return_value_strlen_2))
                    return (const char *)(void *)0;

                  strlcpy(dst, buf, len);
                  return dst;
                }

              }

            }

          }

        }

      }

      i = 0;
      while(!(i >= 8))
        if((signed int)words[(signed long int)i] == 0)
        {
          tmp_post_6 = i;
          i = i + 1;
          curGapPos = tmp_post_6;
          curGapLen = 1;
          for( ; !(i >= 8); curGapLen = curGapLen + 1)
          {
            if(!((signed int)words[(signed long int)i] == 0))
              break;

            i = i + 1;
          }
          if(!(longestGapLen >= curGapLen))
          {
            longestGapPos = curGapPos;
            longestGapLen = curGapLen;
          }

        }

        else
          i = i + 1;
      if(!(longestGapLen >= 2))
        longestGapPos = -1;

      cp = buf;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(longestGapPos == i && (signed int)words[(signed long int)i] == 0)
        {
          if(i == 0)
          {
            tmp_post_7 = cp;
            cp = cp + 1l;
            *tmp_post_7 = (char)58;
          }

          tmp_post_8 = cp;
          cp = cp + 1l;
          *tmp_post_8 = (char)58;
          for( ; !(i >= 8); i = i + 1)
            if(!((signed int)words[(signed long int)i] == 0))
              break;

          i = i - 1;
        }

        else
        {
          tor_snprintf(cp, sizeof(char [64l]) /*64ul*/  - (unsigned long int)(cp - buf), "%x", (unsigned int)words[(signed long int)i]);
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(cp);
          cp = cp + (signed long int)return_value_strlen_9;
          if(!(i == 7))
          {
            tmp_post_10 = cp;
            cp = cp + 1l;
            *tmp_post_10 = (char)58;
          }

        }
      *cp = (char)0;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(buf);
      if(!(len >= 1ul + return_value_strlen_11))
        return (const char *)(void *)0;

      strlcpy(dst, buf, len);
      return dst;
    }

    else
      return (const char *)(void *)0;
}

// tor_inet_pton
// file ../src/common/compat.h line 547
signed int tor_inet_pton(signed int af, const char *src, void *dst)
{
  unsigned long int return_value_strlen_3;
  _Bool tmp_if_expr_5;
  signed int return_value_TOR_ISDIGIT_4;
  signed int return_value_TOR_ISXDIGIT_7;
  signed int tmp_post_8;
  _Bool tmp_if_expr_9;
  if(af == 2)
  {
    signed int return_value_tor_inet_aton_1;
    return_value_tor_inet_aton_1=tor_inet_aton(src, (struct in_addr *)dst);
    return return_value_tor_inet_aton_1;
  }

  else
    if(af == 10)
    {
      struct in6_addr *out = (struct in6_addr *)dst;
      unsigned short int words[8l];
      signed int gapPos = -1;
      signed int i;
      signed int setWords = 0;
      const char *dot;
      char *return_value___builtin_strchr_2;
      return_value___builtin_strchr_2=__builtin_strchr(src, 46);
      dot = return_value___builtin_strchr_2;
      const char *eow;
      if(dot == src)
        return 0;

      else
        if(dot == ((const char *)NULL))
        {
          return_value_strlen_3=strlen(src);
          eow = src + (signed long int)return_value_strlen_3;
        }

        else
        {
          unsigned int byte1;
          unsigned int byte2;
          unsigned int byte3;
          unsigned int byte4;
          char more;
          eow = dot - (signed long int)1;
          do
          {
            if(!(src >= eow))
            {
              return_value_TOR_ISDIGIT_4=TOR_ISDIGIT(*eow);
              tmp_if_expr_5 = return_value_TOR_ISDIGIT_4 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(!tmp_if_expr_5)
              break;

            eow = eow - 1l;
          }
          while((_Bool)1);
          if(!((signed int)*eow == 58))
            return 0;

          eow = eow + 1l;
          signed int return_value_tor_sscanf_6;
          return_value_tor_sscanf_6=tor_sscanf(eow, "%3u.%3u.%3u.%3u%c", &byte1, &byte2, &byte3, &byte4, &more);
          if(!(return_value_tor_sscanf_6 == 4))
            return 0;

          if(byte1 >= 256u || byte2 >= 256u || byte3 >= 256u || byte4 >= 256u)
            return 0;

          words[(signed long int)6] = (unsigned short int)(byte1 << 8 | byte2);
          words[(signed long int)7] = (unsigned short int)(byte3 << 8 | byte4);
          setWords = setWords + 2;
        }
      i = 0;
      while(!(src >= eow))
      {
        if(i >= 8)
          return 0;

        signed int return_value_TOR_ISXDIGIT_10;
        return_value_TOR_ISXDIGIT_10=TOR_ISXDIGIT(*src);
        if(!(return_value_TOR_ISXDIGIT_10 == 0))
        {
          char *next;
          signed long int len;
          signed long int r;
          r=strtol(src, &next, 16);
          if(next == ((char *)NULL))
          {
            tor_assertion_failed_("../src/common/compat.c", (unsigned int)2373, "tor_inet_pton", "next != NULL");
            abort();
          }

          if(next == src)
          {
            tor_assertion_failed_("../src/common/compat.c", (unsigned int)2374, "tor_inet_pton", "next != src");
            abort();
          }

          len = (signed int)*next == 0 ? eow - src : next - src;
          if(len >= 5l)
            return 0;

          if(len >= 2l)
          {
            return_value_TOR_ISXDIGIT_7=TOR_ISXDIGIT(src[(signed long int)1]);
            if(return_value_TOR_ISXDIGIT_7 == 0)
              return 0;

          }

          if(!(r >= 0l))
          {
            tor_assertion_failed_("../src/common/compat.c", (unsigned int)2382, "tor_inet_pton", "r >= 0");
            abort();
          }

          if(r >= 65536l)
          {
            tor_assertion_failed_("../src/common/compat.c", (unsigned int)2383, "tor_inet_pton", "r < 65536");
            abort();
          }

          tmp_post_8 = i;
          i = i + 1;
          words[(signed long int)tmp_post_8] = (unsigned short int)r;
          setWords = setWords + 1;
          src = next;
          if(!((signed int)*src == 58))
          {
            if(!(src == eow))
              return 0;

          }

          src = src + 1l;
        }

        else
          if(gapPos == -1 && (signed int)*src == 58 && i >= 1)
          {
            gapPos = i;
            src = src + 1l;
          }

          else
          {
            if(i == 0 && (signed int)*src == 58 && !(src + 1l >= eow))
              tmp_if_expr_9 = (signed int)src[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_9 = (_Bool)0;
            if(gapPos == -1 && tmp_if_expr_9)
            {
              gapPos = i;
              src = src + (signed long int)2;
            }

            else
              return 0;
          }
      }
      if(setWords >= 9 || gapPos == -1 && !(setWords >= 8) || setWords == 8 && !(gapPos == -1))
        return 0;

      if(gapPos >= 0)
      {
        signed int nToMove = (setWords - (dot != ((const char *)NULL) ? 2 : 0)) - gapPos;
        signed int gapLen = 8 - setWords;
        if(!(nToMove >= 0))
        {
          tor_assertion_failed_("../src/common/compat.c", (unsigned int)2410, "tor_inet_pton", "nToMove >= 0");
          abort();
        }

        memmove((void *)&words[(signed long int)(gapPos + gapLen)], (const void *)&words[(signed long int)gapPos], sizeof(unsigned short int) /*2ul*/  * (unsigned long int)nToMove);
        memset_link3((void *)&words[(signed long int)gapPos], 0, sizeof(unsigned short int) /*2ul*/  * (unsigned long int)gapLen);
      }

      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        out->__in6_u.__u6_addr8[(signed long int)(2 * i)] = (unsigned char)((signed int)words[(signed long int)i] >> 8);
        out->__in6_u.__u6_addr8[(signed long int)(2 * i + 1)] = (unsigned char)((signed int)words[(signed long int)i] & 0xff);
      }
      return 1;
    }

    else
      return -1;
}

// tor_init_weak_random
// file ../src/common/util.c line 5385
void tor_init_weak_random(struct tor_weak_rng_t *rng, unsigned int seed)
{
  rng->state = (unsigned int)(seed & (unsigned int)0x7fffffff);
}

// tor_join_win_cmdline
// file ../src/common/util.c line 3672
char * tor_join_win_cmdline(const char **argv)
{
  struct smartlist_t *argv_list;
  char *joined_argv;
  signed int i;
  argv_list=smartlist_new();
  i = 0;
  for( ; !(argv[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    char *return_value_format_win_cmdline_argument_1;
    return_value_format_win_cmdline_argument_1=format_win_cmdline_argument(argv[(signed long int)i]);
    smartlist_add(argv_list, (void *)return_value_format_win_cmdline_argument_1);
  }
  joined_argv=smartlist_join_strings(argv_list, " ", 0, (unsigned long int *)(void *)0);
  signed int arg_sl_idx;
  signed int arg_sl_len = argv_list->num_used;
  char *arg;
  arg_sl_idx = 0;
  for( ; !(arg_sl_idx >= arg_sl_len); arg_sl_idx = arg_sl_idx + 1)
  {
    arg = (char *)argv_list->list[(signed long int)arg_sl_idx];
    if(!(arg == ((char *)NULL)))
    {
      free((void *)arg);
      arg = (char *)(void *)0;
    }

    arg = (char *)(void *)0;
  }
  smartlist_free(argv_list);
  return joined_argv;
}

// tor_listdir
// file ../src/common/util.c line 3353
struct smartlist_t * tor_listdir(const char *dirname)
{
  struct smartlist_t *result;
  const char *prot_dname;
  prot_dname=sandbox_intern_string(dirname);
  struct __dirstream *d;
  struct dirent *de;
  d=opendir(prot_dname);
  signed int tmp_statement_expression_1;
  _Bool tmp_if_expr_5;
  signed int tmp_statement_expression_3;
  if(d == ((struct __dirstream *)NULL))
    return (struct smartlist_t *)(void *)0;

  else
  {
    result=smartlist_new();
    do
    {
      de=readdir(d);
      if(de == ((struct dirent *)NULL))
        break;

      unsigned long int tor_listdir__1__1__1____s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp_2;
      return_value___builtin_strcmp_2=__builtin_strcmp(de->d_name, ".");
      tmp_statement_expression_1 = return_value___builtin_strcmp_2;
      if(tmp_statement_expression_1 == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        unsigned long int __s1_len;
        unsigned long int tor_listdir__1__1__2____s2_len;
        signed int return_value___builtin_strcmp_4;
        return_value___builtin_strcmp_4=__builtin_strcmp(de->d_name, "..");
        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
        tmp_if_expr_5 = !(tmp_statement_expression_3 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_5)
      {
        char *return_value_tor_strdup__6;
        return_value_tor_strdup__6=tor_strdup_(de->d_name);
        smartlist_add(result, (void *)return_value_tor_strdup__6);
      }

    }
    while((_Bool)1);
    closedir(d);
    return result;
  }
}

// tor_llround
// file ../src/common/util.c line 419
signed long int tor_llround(double d)
{
  double tmp_if_expr_2;
  double return_value_ceil_1;
  if(d > 0.000000)
    tmp_if_expr_2 = d + 0.5;

  else
  {
    return_value_ceil_1=ceil(d - 0.5);
    tmp_if_expr_2 = return_value_ceil_1;
  }
  return (signed long int)tmp_if_expr_2;
}

// tor_localtime_r
// file ../src/common/compat.c line 2757
struct tm * tor_localtime_r(const signed long int *timep, struct tm *result)
{
  struct tm *r;
  r=localtime_r(timep, result);
  struct tm *return_value_correct_tm_1;
  return_value_correct_tm_1=correct_tm(1, timep, result, r);
  return return_value_correct_tm_1;
}

// tor_lockfile_lock
// file ../src/common/compat.c line 873
struct tor_lockfile_t * tor_lockfile_lock(const char *filename, signed int blocking, signed int *locked_out)
{
  struct tor_lockfile_t *result;
  signed int fd;
  *locked_out = 0;
  log_fn_(6, 1u << 4, "tor_lockfile_lock", "Locking \"%s\"", filename);
  fd=tor_open_cloexec(filename, 02 | 0100 | 01000, (unsigned int)0600);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 4, "tor_lockfile_lock", "Couldn't open \"%s\" for locking: %s", filename, return_value_strerror_2);
    return (struct tor_lockfile_t *)(void *)0;
  }

  signed int return_value_flock_6;
  return_value_flock_6=flock(fd, 2 | (blocking != 0 ? 0 : 4));
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  if(!(return_value_flock_6 >= 0))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    if(!(*return_value___errno_location_5 == 11))
    {
      return_value___errno_location_3=__errno_location();
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_fn_(4, 1u << 4, "tor_lockfile_lock", "Couldn't lock \"%s\": %s", filename, return_value_strerror_4);
    }

    else
      *locked_out = 1;
    close(fd);
    return (struct tor_lockfile_t *)(void *)0;
  }

  void *return_value_tor_malloc__7;
  return_value_tor_malloc__7=tor_malloc_(sizeof(struct tor_lockfile_t) /*16ul*/ );
  result = (struct tor_lockfile_t *)return_value_tor_malloc__7;
  result->filename=tor_strdup_(filename);
  result->fd = fd;
  return result;
}

// tor_lockfile_unlock
// file ../src/common/compat.c line 931
void tor_lockfile_unlock(struct tor_lockfile_t *lockfile)
{
  if(lockfile == ((struct tor_lockfile_t *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)933, "tor_lockfile_unlock", "lockfile");
    abort();
  }

  log_fn_(6, 1u << 4, "tor_lockfile_unlock", "Unlocking \"%s\"", lockfile->filename);
  signed int return_value_flock_3;
  return_value_flock_3=flock(lockfile->fd, 8);
  if(!(return_value_flock_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 4, "tor_lockfile_unlock", "Error unlocking \"%s\": %s", lockfile->filename, return_value_strerror_2);
  }

  close(lockfile->fd);
  lockfile->fd = -1;
  if(!(lockfile->filename == ((char *)NULL)))
  {
    free((void *)lockfile->filename);
    lockfile->filename = (char *)(void *)0;
  }

  if(!(lockfile == ((struct tor_lockfile_t *)NULL)))
  {
    free((void *)lockfile);
    lockfile = (struct tor_lockfile_t *)(void *)0;
  }

}

// tor_log
// file ../src/common/torlog.h line 157
void tor_log(signed int severity, unsigned int domain, const char *format, ...)
{
  void **ap;
  if(log_global_min_severity_ >= severity)
  {
    ap = (void **)&format;
    logv(severity, domain, (const char *)(void *)0, (const char *)(void *)0, format, ap);
    ap = ((void **)NULL);
  }

}

// tor_log2
// file ../src/common/util.h line 170
signed int tor_log2(unsigned long int u64)
{
  signed int r = 0;
  if(u64 >= 4294967296ull)
  {
    u64 = u64 >> 32;
    r = 32;
  }

  if(u64 >= 65536ull)
  {
    u64 = u64 >> 16;
    r = r + 16;
  }

  if(u64 >= 256ull)
  {
    u64 = u64 >> 8;
    r = r + 8;
  }

  if(u64 >= 16ull)
  {
    u64 = u64 >> 4;
    r = r + 4;
  }

  if(u64 >= 4ull)
  {
    u64 = u64 >> 2;
    r = r + 2;
  }

  if(u64 >= 2ull)
  {
    u64 = u64 >> 1;
    r = r + 1;
  }

  return r;
}

// tor_log_err_sigsafe
// file ../src/common/torlog.h line 160
void tor_log_err_sigsafe(const char *m, ...)
{
  __builtin_va_list ap;
  const char *x;
  char timebuf[33l];
  signed long int now;
  now=time((signed long int *)(void *)0);
  if(!(m == ((const char *)NULL)))
  {
    if(log_time_granularity >= 2000)
    {
      signed int g = log_time_granularity / 1000;
      now = now - now % (signed long int)g;
    }

    timebuf[(signed long int)0] = (char)(now < (signed long int)0 ? 45 : 32);
    if(!(now >= 0l))
      now = -now;

    timebuf[(signed long int)1] = (char)0;
    format_dec_number_sigsafe((unsigned long int)now, timebuf + (signed long int)1, (signed int)(sizeof(char [33l]) /*33ul*/  - (unsigned long int)1));
    tor_log_err_sigsafe_write("\n============================================================ T=");
    tor_log_err_sigsafe_write(timebuf);
    tor_log_err_sigsafe_write("\n");
    tor_log_err_sigsafe_write(m);
    va_start(ap, m);
    do
    {
      x=va_arg(ap, __typeof__(x));
      if(x == ((const char *)NULL))
        break;

      tor_log_err_sigsafe_write(x);
    }
    while((_Bool)1);
    va_end(ap);
  }

}

// tor_log_err_sigsafe_write
// file ../src/common/log.c line 525
static signed int tor_log_err_sigsafe_write(const char *s)
{
  signed int i;
  signed long int r;
  unsigned long int len;
  len=strlen(s);
  signed int err = 0;
  i = 0;
  for( ; !(i >= n_sigsafe_log_fds); i = i + 1)
  {
    r=write(sigsafe_log_fds[(signed long int)i], (const void *)s, len);
    err = err + (signed int)(r != (signed long int)len);
  }
  return err != 0 ? -1 : 0;
}

// tor_log_get_logfile_names
// file ../src/common/log.c line 640
void tor_log_get_logfile_names(struct smartlist_t *out)
{
  struct logfile_t *lf;
  if(out == ((struct smartlist_t *)NULL))
  {
    tor_assertion_failed_("../src/common/log.c", (unsigned int)643, "tor_log_get_logfile_names", "out");
    abort();
  }

  tor_mutex_acquire(&log_mutex);
  lf = logfiles;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
  {
    if(!(lf->is_temporary == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = lf->is_syslog != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = lf->callback != ((void (*)(signed int, unsigned int, const char *))NULL) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      if(!(lf->filename == ((char *)NULL)))
      {
        char *return_value_tor_strdup__3;
        return_value_tor_strdup__3=tor_strdup_(lf->filename);
        smartlist_add(out, (void *)return_value_tor_strdup__3);
      }

    }

  }
  tor_mutex_release(&log_mutex);
}

// tor_log_get_sigsafe_err_fds
// file ../src/common/torlog.h line 161
signed int tor_log_get_sigsafe_err_fds(const signed int **out)
{
  *out = sigsafe_log_fds;
  return n_sigsafe_log_fds;
}

// tor_log_mallinfo
// file ../src/common/util.c line 361
void tor_log_mallinfo(signed int severity)
{
  struct mallinfo mi;
  memset_link7((void *)&mi, 0, sizeof(struct mallinfo) /*40ul*/ );
  mi=mallinfo();
  tor_log(severity, 1u << 6, "mallinfo() said: arena=%d, ordblks=%d, smblks=%d, hblks=%d, hblkhd=%d, usmblks=%d, fsmblks=%d, uordblks=%d, fordblks=%d, keepcost=%d", mi.arena, mi.ordblks, mi.smblks, mi.hblks, mi.hblkhd, mi.usmblks, mi.fsmblks, mi.uordblks, mi.fordblks, mi.keepcost);
}

// tor_log_update_sigsafe_err_fds
// file ../src/common/log.c line 596
void tor_log_update_sigsafe_err_fds(void)
{
  const struct logfile_t *lf;
  signed int found_real_stderr = 0;
  tor_mutex_acquire(&log_mutex);
  sigsafe_log_fds[(signed long int)0] = 2;
  n_sigsafe_log_fds = 1;
  lf = logfiles;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int tmp_post_6;
  for( ; !(lf == ((const struct logfile_t *)NULL)); lf = lf->next)
  {
    if(!(lf->is_temporary == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = lf->is_syslog != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = lf->callback != ((void (*)(signed int, unsigned int, const char *))NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = lf->seems_dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = lf->fd < 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_4)
    {
      if(!((4097u & lf->severities->masks[0l]) == 0u))
      {
        if(lf->fd == 2)
          found_real_stderr = 1;

        signed int return_value_int_array_contains_5;
        return_value_int_array_contains_5=int_array_contains(sigsafe_log_fds, n_sigsafe_log_fds, lf->fd);
        if(return_value_int_array_contains_5 == 0)
        {
          tmp_post_6 = n_sigsafe_log_fds;
          n_sigsafe_log_fds = n_sigsafe_log_fds + 1;
          sigsafe_log_fds[(signed long int)tmp_post_6] = lf->fd;
          if(n_sigsafe_log_fds == 8)
            break;

        }

      }

    }

  }
  signed int return_value_int_array_contains_7;
  if(found_real_stderr == 0)
  {
    return_value_int_array_contains_7=int_array_contains(sigsafe_log_fds, n_sigsafe_log_fds, 1);
    if(!(return_value_int_array_contains_7 == 0))
    {
      /* assertion n_sigsafe_log_fds >= 2 */
      assert(n_sigsafe_log_fds >= 2);
      n_sigsafe_log_fds = n_sigsafe_log_fds - 1;
      sigsafe_log_fds[(signed long int)0] = sigsafe_log_fds[(signed long int)n_sigsafe_log_fds];
    }

  }

  tor_mutex_release(&log_mutex);
}

// tor_lookup_hostname
// file ../src/common/compat.h line 548
signed int tor_lookup_hostname(const char *name, unsigned int *addr)
{
  struct tor_addr_t myaddr;
  signed int ret;
  ret=tor_addr_lookup(name, (unsigned short int)2, &myaddr);
  if(!(ret == 0))
    return ret;

  else
  {
    unsigned short int return_value_tor_addr_family_1;
    return_value_tor_addr_family_1=tor_addr_family_link2(&myaddr);
    if((signed int)return_value_tor_addr_family_1 == 2)
    {
      *addr=tor_addr_to_ipv4h_link1(&myaddr);
      return ret;
    }

    else
      return -1;
  }
}

// tor_lround
// file ../src/common/util.c line 404
signed long int tor_lround(double d)
{
  double tmp_if_expr_2;
  double return_value_ceil_1;
  if(d > 0.000000)
    tmp_if_expr_2 = d + 0.5;

  else
  {
    return_value_ceil_1=ceil(d - 0.5);
    tmp_if_expr_2 = return_value_ceil_1;
  }
  return (signed long int)tmp_if_expr_2;
}

// tor_malloc_
// file ../src/tools/../common/util.h line 78
void * tor_malloc_(unsigned long int size)
{
  void *result;
  if(size >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)155, "tor_malloc_", "size < SIZE_T_CEILING");
    abort();
  }

  result=malloc(size);
  if(result == NULL)
  {
    log_fn_(3, 1u << 6, "tor_malloc_", "Out of memory on malloc(). Dying.");
    exit(1);
  }

  return result;
}

// tor_malloc_zero_
// file ../src/tools/../common/util.h line 79
void * tor_malloc_zero_(unsigned long int size)
{
  void *result;
  result=tor_malloc_(size);
  memset_link7(result, 0, size);
  return result;
}

// tor_mathlog
// file ../src/common/util.c line 395
double tor_mathlog(double d)
{
  double return_value_log_1;
  return_value_log_1=log(d);
  return return_value_log_1;
}

// tor_mem_is_zero
// file ../src/common/util.c line 959
signed int tor_mem_is_zero(const char *mem, unsigned long int len)
{
  static const char ZERO[32l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
  while(len >= sizeof(const char [32l]) /*32ul*/ )
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)mem, (const void *)ZERO, sizeof(const char [32l]) /*32ul*/ );
    if(!(return_value_memcmp_1 == 0))
      return 0;

    len = len - sizeof(const char [32l]) /*32ul*/ ;
    mem = mem + (signed long int)sizeof(const char [32l]) /*32ul*/ ;
  }
  signed int return_value_memcmp_2;
  if(!(len == 0ul))
  {
    return_value_memcmp_2=memcmp((const void *)mem, (const void *)ZERO, len);
    return (signed int)(0 == return_value_memcmp_2);
  }

  else
    return 1;
}

// tor_memcmp
// file ../src/common/di_ops.h line 17
signed int tor_memcmp(const void *a, const void *b, unsigned long int len)
{
  const unsigned char *x = (const unsigned char *)a;
  const unsigned char *y = (const unsigned char *)b;
  unsigned long int i = len;
  signed int retval = 0;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = i;
    i = i - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    signed int v1 = (signed int)x[(signed long int)i];
    signed int v2 = (signed int)y[(signed long int)i];
    signed int equal_p = v1 ^ v2;
    equal_p = equal_p - 1;
    equal_p = equal_p >> 8;
    retval = retval & equal_p;
    retval = retval + (v1 - v2);
  }
  while((_Bool)1);
  return retval;
}

// tor_memdup_
// file ../src/common/util.h line 86
void * tor_memdup_(const void *mem, unsigned long int len)
{
  char *dup;
  if(len >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)329, "tor_memdup_", "len < SIZE_T_CEILING");
    abort();
  }

  if(mem == NULL)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)330, "tor_memdup_", "mem");
    abort();
  }

  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(len);
  dup = (char *)return_value_tor_malloc__1;
  memcpy_link7((void *)dup, mem, len);
  return (void *)dup;
}

// tor_memdup_nulterm_
// file ../src/common/util.c line 339
void * tor_memdup_nulterm_(const void *mem, unsigned long int len)
{
  char *dup;
  if(len >= 9223372036854775792ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)342, "tor_memdup_nulterm_", "len < SIZE_T_CEILING+1");
    abort();
  }

  if(mem == NULL)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)343, "tor_memdup_nulterm_", "mem");
    abort();
  }

  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(len + (unsigned long int)1);
  dup = (char *)return_value_tor_malloc__1;
  memcpy_link7((void *)dup, mem, len);
  dup[(signed long int)len] = (char)0;
  return (void *)dup;
}

// tor_memeq
// file ../src/common/di_ops.h line 18
signed int tor_memeq(const void *a, const void *b, unsigned long int sz)
{
  const unsigned char *ba = (const unsigned char *)a;
  const unsigned char *bb = (const unsigned char *)b;
  unsigned int any_difference = (unsigned int)0;
  unsigned long int tmp_post_1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  do
  {
    tmp_post_1 = sz;
    sz = sz - 1ul;
    if(tmp_post_1 == 0ul)
      break;

    unsigned char byte_diff;
    tmp_post_2 = ba;
    ba = ba + 1l;
    tmp_post_3 = bb;
    bb = bb + 1l;
    byte_diff = (const unsigned char)((signed int)*tmp_post_2 ^ (signed int)*tmp_post_3);
    any_difference = any_difference | (unsigned int)byte_diff;
  }
  while((_Bool)1);
  return (signed int)((unsigned int)1 & any_difference - (unsigned int)1 >> 8);
}

// tor_memmem
// file ../src/common/compat.c line 570
const void * tor_memmem(const void *_haystack, unsigned long int hlen, const void *_needle, unsigned long int nlen)
{
  if(nlen == 0ul)
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)574, "tor_memmem", "nlen");
    abort();
  }

  void *return_value_memmem_1;
  return_value_memmem_1=memmem(_haystack, hlen, _needle, nlen);
  return return_value_memmem_1;
}

// tor_mlockall
// file ../src/common/compat.c line 2873
signed int tor_mlockall(void)
{
  signed int *return_value___errno_location_2;
  static signed int memory_lock_attempted = 0;
  if(!(memory_lock_attempted == 0))
    return 1;

  else
  {
    memory_lock_attempted = 1;
    signed int return_value_tor_set_max_memlock_1;
    return_value_tor_set_max_memlock_1=tor_set_max_memlock();
    if(return_value_tor_set_max_memlock_1 == 0)
    {
      if(log_global_min_severity_ == 7)
        log_fn_(7, 1u << 0, "tor_mlockall", "RLIMIT_MEMLOCK is now set to RLIM_INFINITY.");

    }

    signed int return_value_mlockall_6;
    return_value_mlockall_6=mlockall(1 | 2);
    if(return_value_mlockall_6 == 0)
    {
      log_fn_(6, 1u << 0, "tor_mlockall", "Insecure OS paging is effectively disabled.");
      return 0;
    }

    else
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      if(*return_value___errno_location_3 == 38)
        log_fn_(5, 1u << 0, "tor_mlockall", "It appears that mlockall() is not available on your platform.");

      else
      {
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 1)
          log_fn_(5, 1u << 0, "tor_mlockall", "It appears that you lack the permissions to lock memory. Are you root?");

      }
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_fn_(5, 1u << 0, "tor_mlockall", "Unable to lock all current and future memory pages: %s", return_value_strerror_5);
      return -1;
    }
  }
}

// tor_mmap_file
// file ../src/common/compat.c line 199
struct tor_mmap_t * tor_mmap_file(const char *filename)
{
  signed int fd;
  char *string;
  signed int page_size;
  signed int result;
  struct tor_mmap_t *res;
  unsigned long int size;
  unsigned long int filesize;
  struct stat st;
  if(filename == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)208, "tor_mmap_file", "filename");
    abort();
  }

  fd=tor_open_cloexec(filename, 00, (unsigned int)0);
  if(!(fd >= 0))
  {
    signed int save_errno;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    save_errno = *return_value___errno_location_1;
    signed int severity;
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    severity = *return_value___errno_location_2 == 2 ? 6 : 4;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_fn_(severity, 1u << 4, "tor_mmap_file", "Could not open \"%s\" for mmap(): %s", filename, return_value_strerror_4);
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5 = save_errno;
    return (struct tor_mmap_t *)(void *)0;
  }

  result=fstat(fd, &st);
  if(!(result == 0))
  {
    signed int tor_mmap_file__1__3__save_errno;
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    tor_mmap_file__1__3__save_errno = *return_value___errno_location_6;
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    log_fn_(4, 1u << 4, "tor_mmap_file", "Couldn't fstat opened descriptor for \"%s\" during mmap: %s", filename, return_value_strerror_8);
    close(fd);
    signed int *return_value___errno_location_9;
    return_value___errno_location_9=__errno_location();
    *return_value___errno_location_9 = tor_mmap_file__1__3__save_errno;
    return (struct tor_mmap_t *)(void *)0;
  }

  filesize = (unsigned long int)st.st_size;
  size = filesize;
  page_size=getpagesize();
  size = size + (size % (unsigned long int)page_size != 0ul ? (unsigned long int)page_size - size % (unsigned long int)page_size : (unsigned long int)0);
  if(size == 0ul)
  {
    log_fn_(6, 1u << 4, "tor_mmap_file", "File \"%s\" is empty. Ignoring.", filename);
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    *return_value___errno_location_10 = 34;
    close(fd);
    return (struct tor_mmap_t *)(void *)0;
  }

  void *return_value_mmap_11;
  return_value_mmap_11=mmap(NULL, size, 0x1, 0x02, fd, (signed long int)0);
  string = (char *)return_value_mmap_11;
  close(fd);
  if(string == (char *)-1)
  {
    signed int tor_mmap_file__1__5__save_errno;
    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    tor_mmap_file__1__5__save_errno = *return_value___errno_location_12;
    signed int *return_value___errno_location_13;
    return_value___errno_location_13=__errno_location();
    char *return_value_strerror_14;
    return_value_strerror_14=strerror(*return_value___errno_location_13);
    log_fn_(4, 1u << 4, "tor_mmap_file", "Could not mmap file \"%s\": %s", filename, return_value_strerror_14);
    signed int *return_value___errno_location_15;
    return_value___errno_location_15=__errno_location();
    *return_value___errno_location_15 = tor_mmap_file__1__5__save_errno;
    return (struct tor_mmap_t *)(void *)0;
  }

  void *return_value_tor_malloc_zero__16;
  return_value_tor_malloc_zero__16=tor_malloc_zero_(sizeof(struct tor_mmap_t) /*24ul*/ );
  res = (struct tor_mmap_t *)return_value_tor_malloc_zero__16;
  res->data = string;
  res->size = filesize;
  res->mapping_size = size;
  return res;
}

// tor_munmap_file
// file ../src/common/compat.c line 269
signed int tor_munmap_file(struct tor_mmap_t *handle)
{
  signed int res;
  if(handle == ((struct tor_mmap_t *)NULL))
    return 0;

  else
  {
    res=munmap((void *)(char *)handle->data, handle->mapping_size);
    if(res == 0)
    {
      if(!(handle == ((struct tor_mmap_t *)NULL)))
      {
        free((void *)handle);
        handle = (struct tor_mmap_t *)(void *)0;
      }

    }

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_fn_(4, 1u << 4, "tor_munmap_file", "Failed to munmap() in tor_munmap_file(): %s", return_value_strerror_2);
      res = -1;
    }
    return res;
  }
}

// tor_mutex_acquire
// file ../src/common/compat_threads.h line 51
void tor_mutex_acquire(struct tor_mutex_t *m)
{
  signed int err;
  if(m == ((struct tor_mutex_t *)NULL))
  {
    tor_assertion_failed_("../src/common/compat_pthreads.c", (unsigned int)124, "tor_mutex_acquire", "m");
    abort();
  }

  err=pthread_mutex_lock(&m->mutex);
  if(!(err == 0))
    log_fn_(3, 1u << 0, "tor_mutex_acquire", "Error %d locking a mutex.", err);

}

// tor_mutex_free
// file ../src/common/compat_threads.c line 45
void tor_mutex_free(struct tor_mutex_t *m)
{
  if(!(m == ((struct tor_mutex_t *)NULL)))
  {
    tor_mutex_uninit(m);
    if(!(m == ((struct tor_mutex_t *)NULL)))
    {
      free((void *)m);
      m = (struct tor_mutex_t *)(void *)0;
    }

  }

}

// tor_mutex_init
// file ../src/common/compat_threads.h line 49
void tor_mutex_init(struct tor_mutex_t *mutex)
{
  signed int err;
  if(threads_initialized == 0)
    tor_threads_init();

  err=pthread_mutex_init(&mutex->mutex, &attr_recursive);
  if(!(err == 0))
    log_fn_(3, 1u << 0, "tor_mutex_init", "Error %d creating a mutex.", err);

}

// tor_mutex_init_nonrecursive
// file ../src/common/compat_threads.h line 50
void tor_mutex_init_nonrecursive(struct tor_mutex_t *mutex)
{
  signed int err;
  if(threads_initialized == 0)
    tor_threads_init();

  err=pthread_mutex_init(&mutex->mutex, (const union anonymous_7 *)(void *)0);
  if(!(err == 0))
    log_fn_(3, 1u << 0, "tor_mutex_init_nonrecursive", "Error %d creating a mutex.", err);

}

// tor_mutex_new
// file ../src/common/compat_threads.h line 47
struct tor_mutex_t * tor_mutex_new(void)
{
  struct tor_mutex_t *m;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct tor_mutex_t) /*40ul*/ );
  m = (struct tor_mutex_t *)return_value_tor_malloc_zero__1;
  tor_mutex_init(m);
  return m;
}

// tor_mutex_new_nonrecursive
// file ../src/common/compat_threads.c line 37
struct tor_mutex_t * tor_mutex_new_nonrecursive(void)
{
  struct tor_mutex_t *m;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct tor_mutex_t) /*40ul*/ );
  m = (struct tor_mutex_t *)return_value_tor_malloc_zero__1;
  tor_mutex_init_nonrecursive(m);
  return m;
}

// tor_mutex_release
// file ../src/common/compat_threads.h line 52
void tor_mutex_release(struct tor_mutex_t *m)
{
  signed int err;
  if(m == ((struct tor_mutex_t *)NULL))
  {
    tor_assertion_failed_("../src/common/compat_pthreads.c", (unsigned int)136, "tor_mutex_release", "m");
    abort();
  }

  err=pthread_mutex_unlock(&m->mutex);
  if(!(err == 0))
    log_fn_(3, 1u << 0, "tor_mutex_release", "Error %d unlocking a mutex.", err);

}

// tor_mutex_uninit
// file ../src/common/compat_threads.h line 54
void tor_mutex_uninit(struct tor_mutex_t *m)
{
  signed int err;
  if(m == ((struct tor_mutex_t *)NULL))
  {
    tor_assertion_failed_("../src/common/compat_pthreads.c", (unsigned int)150, "tor_mutex_uninit", "m");
    abort();
  }

  err=pthread_mutex_destroy(&m->mutex);
  if(!(err == 0))
    log_fn_(3, 1u << 0, "tor_mutex_uninit", "Error %d destroying a mutex.", err);

}

// tor_open_cloexec
// file ../src/common/compat.c line 137
signed int tor_open_cloexec(const char *path, signed int flags, unsigned int mode)
{
  signed int fd;
  const char *p = path;
  p=sandbox_intern_string(path);
  fd=open(p, flags | 02000000, mode);
  if(fd >= 0)
    return fd;

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 22))
      return -1;

    else
    {
      if(log_global_min_severity_ == 7)
        log_fn_(7, 1u << 4, "tor_open_cloexec", "Opening %s with flags %x", p, flags);

      fd=open(p, flags, mode);
      if(fd >= 0)
      {
        signed int return_value_fcntl_4;
        return_value_fcntl_4=fcntl(fd, 2, 1);
        if(return_value_fcntl_4 == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          log_fn_(4, 1u << 4, "tor_open_cloexec", "Couldn't set FD_CLOEXEC: %s", return_value_strerror_3);
          close(fd);
          return -1;
        }

      }

      return fd;
    }
  }
}

// tor_open_socket
// file ../src/common/compat.h line 466
signed int tor_open_socket(signed int domain, signed int type, signed int protocol)
{
  signed int return_value_tor_open_socket_with_extensions_1;
  return_value_tor_open_socket_with_extensions_1=tor_open_socket_with_extensions(domain, type, protocol, 1, 0);
  return return_value_tor_open_socket_with_extensions_1;
}

// tor_open_socket_nonblocking
// file ../src/common/compat.c line 1168
signed int tor_open_socket_nonblocking(signed int domain, signed int type, signed int protocol)
{
  signed int return_value_tor_open_socket_with_extensions_1;
  return_value_tor_open_socket_with_extensions_1=tor_open_socket_with_extensions(domain, type, protocol, 1, 1);
  return return_value_tor_open_socket_with_extensions_1;
}

// tor_open_socket_with_extensions
// file ../src/common/compat.c line 1178
signed int tor_open_socket_with_extensions(signed int domain, signed int type, signed int protocol, signed int cloexec, signed int nonblock)
{
  signed int s;
  signed int ext_flags = (cloexec != 0 ? 524288 : 0) | (nonblock != 0 ? 2048 : 0);
  s=socket(domain, type | ext_flags, protocol);
  signed int *return_value___errno_location_1;
  if(!(s >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 22))
      return s;

    s=socket(domain, type, protocol);
    if(!(s >= 0))
      return s;

    if(!(cloexec == 0))
    {
      signed int return_value_fcntl_4;
      return_value_fcntl_4=fcntl(s, 2, 1);
      if(return_value_fcntl_4 == -1)
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(*return_value___errno_location_2);
        log_fn_(4, 1u << 4, "tor_open_socket_with_extensions", "Couldn't set FD_CLOEXEC: %s", return_value_strerror_3);
        tor_close_socket_simple(s);
        return -1;
      }

    }

    if(!(nonblock == 0))
    {
      signed int return_value_set_socket_nonblocking_5;
      return_value_set_socket_nonblocking_5=set_socket_nonblocking(s);
      if(return_value_set_socket_nonblocking_5 == -1)
      {
        tor_close_socket_simple(s);
        return -1;
      }

    }

  }


socket_ok:
  ;
  socket_accounting_lock();
  n_sockets_open = n_sockets_open + 1;
  socket_accounting_unlock();
  return s;
}

// tor_parse_double
// file ../src/common/util.c line 1165
double tor_parse_double(const char *s, double min, double max, signed int *ok, char **next)
{
  char *endptr;
  double r;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  r=strtod(s, &endptr);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  if(!(*return_value___errno_location_2 == 34))
  {
    if(endptr == s)
      goto err;

    if(next == ((char **)NULL))
    {
      if(!(*endptr == 0))
        goto err;

    }

    if(r < min || r > max)
      goto err;

    if(!(ok == ((signed int *)NULL)))
      *ok = 1;

    if(!(next == ((char **)NULL)))
      *next = endptr;

    return r;
  }

  else
  {

  err:
    ;
    if(!(ok == ((signed int *)NULL)))
      *ok = 0;

    if(!(next == ((char **)NULL)))
      *next = endptr;

    return (double)0;
  }
}

// tor_parse_long
// file ../src/common/util.h line 215
signed long int tor_parse_long(const char *s, signed int base, signed long int min, signed long int max, signed int *ok, char **next)
{
  char *endptr;
  signed long int r;
  if(!(base >= 0))
  {
    if(!(ok == ((signed int *)NULL)))
      *ok = 0;

    return (signed long int)0;
  }

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    r=strtol(s, &endptr, base);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 34))
    {
      if(endptr == s)
        goto err;

      if(next == ((char **)NULL))
      {
        if(!(*endptr == 0))
          goto err;

      }

      if(!(r >= min) || !(max >= r))
        goto err;

      if(!(ok == ((signed int *)NULL)))
        *ok = 1;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return r;
    }

    else
    {

    err:
      ;
      if(!(ok == ((signed int *)NULL)))
        *ok = 0;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return (signed long int)0;
    }
  }
}

// tor_parse_uint64
// file ../src/common/util.c line 1178
unsigned long int tor_parse_uint64(const char *s, signed int base, unsigned long int min, unsigned long int max, signed int *ok, char **next)
{
  char *endptr;
  unsigned long int r;
  if(!(base >= 0))
  {
    if(!(ok == ((signed int *)NULL)))
      *ok = 0;

    return (unsigned long int)0;
  }

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    unsigned long long int return_value_strtoull_2;
    return_value_strtoull_2=strtoull(s, &endptr, base);
    r = (unsigned long int)return_value_strtoull_2;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 34))
    {
      if(endptr == s)
        goto err;

      if(next == ((char **)NULL))
      {
        if(!(*endptr == 0))
          goto err;

      }

      if(!(r >= min) || !(max >= r))
        goto err;

      if(!(ok == ((signed int *)NULL)))
        *ok = 1;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return r;
    }

    else
    {

    err:
      ;
      if(!(ok == ((signed int *)NULL)))
        *ok = 0;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return (unsigned long int)0;
    }
  }
}

// tor_parse_ulong
// file ../src/common/util.c line 1146
unsigned long int tor_parse_ulong(const char *s, signed int base, unsigned long int min, unsigned long int max, signed int *ok, char **next)
{
  char *endptr;
  unsigned long int r;
  if(!(base >= 0))
  {
    if(!(ok == ((signed int *)NULL)))
      *ok = 0;

    return (unsigned long int)0;
  }

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    r=strtoul(s, &endptr, base);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 34))
    {
      if(endptr == s)
        goto err;

      if(next == ((char **)NULL))
      {
        if(!(*endptr == 0))
          goto err;

      }

      if(!(r >= min) || !(max >= r))
        goto err;

      if(!(ok == ((signed int *)NULL)))
        *ok = 1;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return r;
    }

    else
    {

    err:
      ;
      if(!(ok == ((signed int *)NULL)))
        *ok = 0;

      if(!(next == ((char **)NULL)))
        *next = endptr;

      return (unsigned long int)0;
    }
  }
}

// tor_passwd_dup
// file ../src/common/compat.c line 1748
static struct passwd * tor_passwd_dup(struct passwd *pw)
{
  struct passwd *new_pw;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct passwd) /*48ul*/ );
  new_pw = (struct passwd *)return_value_tor_malloc_zero__1;
  if(!(pw->pw_name == ((char *)NULL)))
    new_pw->pw_name=tor_strdup_(pw->pw_name);

  if(!(pw->pw_dir == ((char *)NULL)))
    new_pw->pw_dir=tor_strdup_(pw->pw_dir);

  new_pw->pw_uid = pw->pw_uid;
  new_pw->pw_gid = pw->pw_gid;
  return new_pw;
}

// tor_passwd_free
// file ../src/common/compat.c line 1763
static void tor_passwd_free(struct passwd *pw)
{
  if(!(pw == ((struct passwd *)NULL)))
  {
    if(!(pw->pw_name == ((char *)NULL)))
    {
      free((void *)pw->pw_name);
      pw->pw_name = (char *)(void *)0;
    }

    if(!(pw->pw_dir == ((char *)NULL)))
    {
      free((void *)pw->pw_dir);
      pw->pw_dir = (char *)(void *)0;
    }

    if(!(pw == ((struct passwd *)NULL)))
    {
      free((void *)pw);
      pw = (struct passwd *)(void *)0;
    }

  }

}

// tor_process_get_pid
// file ../src/common/util.c line 3921
signed int tor_process_get_pid(struct process_handle_t *process_handle)
{
  return (signed int)process_handle->pid;
}

// tor_process_get_stdout_pipe
// file ../src/common/util.c line 3939
struct _IO_FILE * tor_process_get_stdout_pipe(struct process_handle_t *process_handle)
{
  return process_handle->stdout_handle;
}

// tor_process_handle_destroy
// file ../src/common/util.c line 4328
void tor_process_handle_destroy(struct process_handle_t *process_handle, signed int also_terminate_process)
{
  if(!(process_handle == ((struct process_handle_t *)NULL)))
  {
    if(!(also_terminate_process == 0))
    {
      signed int return_value_tor_terminate_process_4;
      return_value_tor_terminate_process_4=tor_terminate_process(process_handle);
      if(!(return_value_tor_terminate_process_4 >= 0))
      {
        const char *errstr;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        errstr=strerror(*return_value___errno_location_1);
        signed int return_value_tor_process_get_pid_2;
        return_value_tor_process_get_pid_2=tor_process_get_pid(process_handle);
        log_fn_(5, 1u << 0, "tor_process_handle_destroy", "Failed to terminate process with PID '%d' ('%s').", return_value_tor_process_get_pid_2, errstr);
      }

      else
      {
        signed int return_value_tor_process_get_pid_3;
        return_value_tor_process_get_pid_3=tor_process_get_pid(process_handle);
        log_fn_(6, 1u << 0, "tor_process_handle_destroy", "Terminated process with PID '%d'.", return_value_tor_process_get_pid_3);
      }
    }

    process_handle->status = 0;
    if(!(process_handle->stdout_handle == ((struct _IO_FILE *)NULL)))
      fclose(process_handle->stdout_handle);

    if(!(process_handle->stderr_handle == ((struct _IO_FILE *)NULL)))
      fclose(process_handle->stderr_handle);

    clear_waitpid_callback(process_handle->waitpid_cb);
    memset_link7((void *)process_handle, 0x0f, sizeof(struct process_handle_t) /*56ul*/ );
    if(!(process_handle == ((struct process_handle_t *)NULL)))
    {
      free((void *)process_handle);
      process_handle = (struct process_handle_t *)(void *)0;
    }

  }

}

// tor_pthread_helper_fn
// file ../src/common/compat_pthreads.c line 28
static void * tor_pthread_helper_fn(void *_data)
{
  struct tor_pthread_data_t *data = (struct tor_pthread_data_t *)_data;
  void (*func)(void *);
  void *arg;
  struct anonymous_27 sigs;
  sigfillset(&sigs);
  pthread_sigmask(2, &sigs, (struct anonymous_27 *)(void *)0);
  func = data->func;
  arg = data->data;
  if(!(_data == NULL))
  {
    free(_data);
    _data = (void *)0;
  }

  func(arg);
  return (void *)0;
}

// tor_read_all_from_process_stderr
// file ../src/common/util.c line 4765
signed long int tor_read_all_from_process_stderr(const struct process_handle_t *process_handle, char *buf, unsigned long int count)
{
  signed long int return_value_tor_read_all_handle_1;
  return_value_tor_read_all_handle_1=tor_read_all_handle(process_handle->stderr_handle, buf, count, process_handle, (signed int *)(void *)0);
  return return_value_tor_read_all_handle_1;
}

// tor_read_all_from_process_stdout
// file ../src/common/util.c line 4751
signed long int tor_read_all_from_process_stdout(const struct process_handle_t *process_handle, char *buf, unsigned long int count)
{
  signed long int return_value_tor_read_all_handle_1;
  return_value_tor_read_all_handle_1=tor_read_all_handle(process_handle->stdout_handle, buf, count, process_handle, (signed int *)(void *)0);
  return return_value_tor_read_all_handle_1;
}

// tor_read_all_handle
// file ../src/common/util.c line 4704
signed long int tor_read_all_handle(struct _IO_FILE *h, char *buf, unsigned long int count, const struct process_handle_t *process, signed int *eof)
{
  unsigned long int numread = (unsigned long int)0;
  char *retval;
  if(!(eof == ((signed int *)NULL)))
    *eof = 0;

  if(count >= 9223372036854775792ul || count >= 9223372036854775808ul)
    return (signed long int)-1;

  else
  {
    while(!(numread == count))
    {
      retval=fgets(buf + (signed long int)numread, (signed int)(count - numread), h);
      if(retval == ((char *)NULL))
      {
        signed int return_value_feof_4;
        return_value_feof_4=feof(h);
        if(!(return_value_feof_4 == 0))
        {
          if(log_global_min_severity_ == 7)
            log_fn_(7, 1u << 0, "tor_read_all_handle", "fgets() reached end of file");

          if(!(eof == ((signed int *)NULL)))
            *eof = 1;

          break;
        }

        else
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          if(*return_value___errno_location_3 == 11)
          {
            if(!(process == ((const struct process_handle_t *)NULL)))
              continue;

            else
              break;
          }

          else
          {
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            char *return_value_strerror_2;
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            log_fn_(4, 1u << 0, "tor_read_all_handle", "fgets() from handle failed: %s", return_value_strerror_2);
            return (signed long int)-1;
          }
        }
      }

      if(retval == ((char *)NULL))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)4739, "tor_read_all_handle", "retval != NULL");
        abort();
      }

      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(retval);
      if(!(count >= return_value_strlen_5 + numread))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)4740, "tor_read_all_handle", "strlen(retval) + numread <= count");
        abort();
      }

      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(retval);
      numread = numread + return_value_strlen_6;
    }
    if(log_global_min_severity_ == 7)
      log_fn_(7, 1u << 0, "tor_read_all_handle", "fgets() read %d bytes from handle", (signed int)numread);

    return (signed long int)numread;
  }
}

// tor_realloc_
// file ../src/common/util.h line 81
void * tor_realloc_(void *ptr, unsigned long int size)
{
  void *result;
  if(size >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)243, "tor_realloc_", "size < SIZE_T_CEILING");
    abort();
  }

  result=realloc(ptr, size);
  if(result == NULL)
  {
    log_fn_(3, 1u << 6, "tor_realloc_", "Out of memory on realloc(). Dying.");
    exit(1);
  }

  return result;
}

// tor_reallocarray_
// file ../src/common/util.h line 82
void * tor_reallocarray_(void *ptr, unsigned long int sz1, unsigned long int sz2)
{
  signed int return_value_size_mul_check_1;
  return_value_size_mul_check_1=size_mul_check(sz1, sz2);
  if(return_value_size_mul_check_1 == 0)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)274, "tor_reallocarray_", "size_mul_check(sz1, sz2)");
    abort();
  }

  void *return_value_tor_realloc__2;
  return_value_tor_realloc__2=tor_realloc_(ptr, sz1 * sz2);
  return return_value_tor_realloc__2;
}

// tor_rename
// file ../src/common/compat.c line 187
signed int tor_rename(const char *path_old, const char *path_new)
{
  if(log_global_min_severity_ == 7)
    log_fn_(7, 1u << 4, "tor_rename", "Renaming %s to %s", path_old, path_new);

  const char *return_value_sandbox_intern_string_1;
  return_value_sandbox_intern_string_1=sandbox_intern_string(path_old);
  const char *return_value_sandbox_intern_string_2;
  return_value_sandbox_intern_string_2=sandbox_intern_string(path_new);
  signed int return_value_rename_3;
  return_value_rename_3=rename(return_value_sandbox_intern_string_1, return_value_sandbox_intern_string_2);
  return return_value_rename_3;
}

// tor_set_max_memlock
// file ../src/common/compat.c line 2840
static signed int tor_set_max_memlock(void)
{
  struct rlimit limit;
  limit.rlim_cur = (unsigned long int)-1;
  limit.rlim_max = (unsigned long int)-1;
  signed int return_value_setrlimit_4;
  return_value_setrlimit_4=setrlimit((enum __rlimit_resource)__RLIMIT_MEMLOCK, &limit);
  if(return_value_setrlimit_4 == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 1)
      log_fn_(4, 1u << 0, "tor_set_max_memlock", "You appear to lack permissions to change memory limits. Are you root?");

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    log_fn_(4, 1u << 0, "tor_set_max_memlock", "Unable to raise RLIMIT_MEMLOCK: %s", return_value_strerror_3);
    return -1;
  }

  return 0;
}

// tor_snprintf
// file ../src/common/compat.h line 300
signed int tor_snprintf(char *str, unsigned long int size, const char *format, ...)
{
  void **ap;
  signed int r;
  ap = (void **)&format;
  r=tor_vsnprintf(str, size, format, ap);
  ap = ((void **)NULL);
  return r;
}

// tor_sockaddr_to_str
// file ../src/common/address.c line 169
char * tor_sockaddr_to_str(struct sockaddr *sa)
{
  char address[48l];
  char *result;
  struct tor_addr_t addr;
  unsigned short int port;
  if((signed int)sa->sa_family == 1)
  {
    struct sockaddr_un *s_un = (struct sockaddr_un *)sa;
    tor_asprintf(&result, "unix:%s", (const void *)s_un->sun_path);
    return result;
  }

  char *return_value_tor_strdup__1;
  if((signed int)sa->sa_family == 0)
  {
    return_value_tor_strdup__1=tor_strdup_("unspec");
    return return_value_tor_strdup__1;
  }

  else
  {
    signed int return_value_tor_addr_from_sockaddr_2;
    return_value_tor_addr_from_sockaddr_2=tor_addr_from_sockaddr(&addr, sa, &port);
    if(!(return_value_tor_addr_from_sockaddr_2 >= 0))
      return (char *)(void *)0;

    else
    {
      const char *return_value_tor_addr_to_str_3;
      return_value_tor_addr_to_str_3=tor_addr_to_str(address, &addr, sizeof(char [48l]) /*48ul*/ , 1);
      if(return_value_tor_addr_to_str_3 == ((const char *)NULL))
        return (char *)(void *)0;

      else
      {
        tor_asprintf(&result, "%s:%d", (const void *)address, (signed int)port);
        return result;
      }
    }
  }
}

// tor_socketpair
// file ../src/common/compat.c line 1356
signed int tor_socketpair(signed int family, signed int type, signed int protocol, signed int *fd)
{
  signed int r;
  r=socketpair(family, type | 524288, protocol, fd);
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_3;
  if(!(r == 0))
  {
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 22))
    {
      return_value___errno_location_1=__errno_location();
      return -(*return_value___errno_location_1);
    }

    r=socketpair(family, type, protocol, fd);
    if(!(r >= 0))
    {
      return_value___errno_location_3=__errno_location();
      return -(*return_value___errno_location_3);
    }

    if(*fd >= 0)
    {
      r=fcntl(fd[(signed long int)0], 2, 1);
      if(r == -1)
      {
        close(fd[(signed long int)0]);
        close(fd[(signed long int)1]);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        return -(*return_value___errno_location_4);
      }

    }

    if(fd[1l] >= 0)
    {
      r=fcntl(fd[(signed long int)1], 2, 1);
      if(r == -1)
      {
        close(fd[(signed long int)0]);
        close(fd[(signed long int)1]);
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        return -(*return_value___errno_location_5);
      }

    }

  }


sockets_ok:
  ;
  socket_accounting_lock();
  if(*fd >= 0)
    n_sockets_open = n_sockets_open + 1;

  if(fd[1l] >= 0)
    n_sockets_open = n_sockets_open + 1;

  socket_accounting_unlock();
  return 0;
}

// tor_spawn_background
// file ../src/common/util.c line 4019
signed int tor_spawn_background(const char * const filename, const char **argv, struct process_environment_t *env, struct process_handle_t **process_handle_out)
{
  signed int pid;
  signed int stdout_pipe[2l];
  signed int stderr_pipe[2l];
  signed int fd;
  signed int retval;
  signed long int nbytes;
  struct process_handle_t *process_handle;
  signed int status;
  const char *error_message = "ERR: Failed to spawn background process - code ";
  unsigned long int error_message_length;
  unsigned char child_state = (unsigned char)0;
  char hex_errno[15l];
  status = -1;
  error_message_length=strlen(error_message);
  child_state = (unsigned char)1;
  retval=pipe(stdout_pipe);
  if(retval == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to set up pipe for stdout communication with child process: %s", return_value_strerror_2);
    return status;
  }

  retval=pipe(stderr_pipe);
  if(retval == -1)
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to set up pipe for stderr communication with child process: %s", return_value_strerror_4);
    close(stdout_pipe[(signed long int)0]);
    close(stdout_pipe[(signed long int)1]);
    return status;
  }

  child_state = (unsigned char)2;
  static signed int max_fd = -1;
  if(max_fd == -1)
  {
    signed long int return_value_sysconf_5;
    return_value_sysconf_5=sysconf(4);
    max_fd = (signed int)return_value_sysconf_5;
    if(max_fd == -1)
    {
      max_fd = 256;
      log_fn_(4, 1u << 0, "tor_spawn_background", "Cannot find maximum file descriptor, assuming %d", max_fd);
    }

  }

  child_state = (unsigned char)3;
  pid=fork();
  _Bool tmp_if_expr_17;
  signed int return_value_fcntl_16;
  if(pid == 0)
  {
    child_state = (unsigned char)4;
    retval=dup2(stdout_pipe[(signed long int)1], 1);
    if(!(retval == -1))
    {
      child_state = (unsigned char)5;
      retval=dup2(stderr_pipe[(signed long int)1], 2);
      if(!(retval == -1))
      {
        child_state = (unsigned char)6;
        fd=open_link1("/dev/null", 00);
        if(!(fd == -1))
          dup2(fd, 0);

        else
          goto error;
        child_state = (unsigned char)7;
        close(stderr_pipe[(signed long int)0]);
        close(stderr_pipe[(signed long int)1]);
        close(stdout_pipe[(signed long int)0]);
        close(stdout_pipe[(signed long int)1]);
        close(fd);
        fd = 2 + 1;
        for( ; !(fd >= max_fd); fd = fd + 1)
          close(fd);
        child_state = (unsigned char)8;
        if(!(env == ((struct process_environment_t *)NULL)))
          execve(filename, (char * const *)argv, env->unixoid_environment_block);

        else
          execvp(filename, (char * const *)argv);
        child_state = (unsigned char)9;
      }

    }


  error:
    ;
    signed int n;
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    n=format_helper_exit_status(child_state, *return_value___errno_location_6, hex_errno);
    if(n >= 0)
    {
      nbytes=write(1, (const void *)error_message, error_message_length);
      nbytes=write(1, (const void *)hex_errno, (unsigned long int)n);
    }

    (void)nbytes;
    _exit(255);
    return status;
  }

  else
  {
    if(pid == -1)
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to fork child process: %s", return_value_strerror_8);
      close(stdout_pipe[(signed long int)0]);
      close(stdout_pipe[(signed long int)1]);
      close(stderr_pipe[(signed long int)0]);
      close(stderr_pipe[(signed long int)1]);
      return status;
    }

    process_handle=process_handle_new();
    process_handle->status = status;
    process_handle->pid = pid;
    process_handle->stdout_pipe = stdout_pipe[(signed long int)0];
    retval=close(stdout_pipe[(signed long int)1]);
    if(retval == -1)
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(*return_value___errno_location_9);
      log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to close write end of stdout pipe in parent process: %s", return_value_strerror_10);
    }

    process_handle->waitpid_cb=set_waitpid_callback(pid, process_handle_waitpid_cb, (void *)process_handle);
    process_handle->stderr_pipe = stderr_pipe[(signed long int)0];
    retval=close(stderr_pipe[(signed long int)1]);
    if(retval == -1)
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to close write end of stderr pipe in parent process: %s", return_value_strerror_12);
    }

    process_handle->status = 1;
    status = process_handle->status;
    signed int return_value_fcntl_15;
    return_value_fcntl_15=fcntl(process_handle->stdout_pipe, 4, 04000);
    if(!(return_value_fcntl_15 >= 0))
      tmp_if_expr_17 = (_Bool)1;

    else
    {
      return_value_fcntl_16=fcntl(process_handle->stderr_pipe, 4, 04000);
      tmp_if_expr_17 = return_value_fcntl_16 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_17)
    {
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      char *return_value_strerror_14;
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      log_fn_(4, 1u << 0, "tor_spawn_background", "Failed to set stderror/stdout pipes nonblocking in parent process: %s", return_value_strerror_14);
    }

    process_handle->stdout_handle=fdopen(process_handle->stdout_pipe, "r");
    process_handle->stderr_handle=fdopen(process_handle->stderr_pipe, "r");
    *process_handle_out = process_handle;
    return process_handle->status;
  }
}

// tor_split_lines
// file ../src/common/util.c line 4783
signed int tor_split_lines(struct smartlist_t *sl, char *buf, signed int len)
{
  signed int start = 0;
  signed int cur = 0;
  char in_line = (char)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  for( ; !(cur >= len); in_line = (char)0)
  {
    for( ; !(cur >= len); cur = cur + 1)
      if(!(in_line == 0))
      {
        if((signed int)buf[(signed long int)cur] == 13)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = 10 == (signed int)buf[(signed long int)cur] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          buf[(signed long int)cur] = (char)0;
          cur = cur + 1;
          break;
        }

        else
        {
          signed int return_value_TOR_ISPRINT_1;
          return_value_TOR_ISPRINT_1=TOR_ISPRINT(buf[(signed long int)cur]);
          if(return_value_TOR_ISPRINT_1 == 0)
            buf[(signed long int)cur] = (char)46;

        }
      }

      else
      {
        if((signed int)buf[(signed long int)cur] == 13)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = 10 == (signed int)buf[(signed long int)cur] ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_4)
        {
          in_line = (char)1;
          start = cur;
          signed int return_value_TOR_ISPRINT_3;
          return_value_TOR_ISPRINT_3=TOR_ISPRINT(buf[(signed long int)cur]);
          if(return_value_TOR_ISPRINT_3 == 0)
            buf[(signed long int)cur] = (char)46;

        }

      }
    if(!(in_line == 0))
      smartlist_add(sl, (void *)(buf + (signed long int)start));

  }
  return sl->num_used;
}

// tor_sscanf
// file ../src/common/util.h line 251
signed int tor_sscanf(const char *buf, const char *pattern, ...)
{
  signed int r;
  void **ap = (void **)&pattern;
  r=tor_vsscanf(buf, pattern, ap);
  ap = ((void **)NULL);
  return r;
}

// tor_strclear
// file ../src/common/util.c line 777
void tor_strclear(char *s)
{
  char *tmp_post_1;
  for( ; !(*s == 0); *tmp_post_1 = (char)0)
  {
    tmp_post_1 = s;
    s = s + 1l;
  }
}

// tor_strdup_
// file ../src/common/util.h line 83
char * tor_strdup_(const char *s)
{
  char *dup;
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)287, "tor_strdup_", "s");
    abort();
  }

  char *return_value___strdup_1;
  return_value___strdup_1=__strdup(s);
  dup = return_value___strdup_1;
  if(dup == ((char *)NULL))
  {
    log_fn_(3, 1u << 6, "tor_strdup_", "Out of memory on strdup(). Dying.");
    exit(1);
  }

  return dup;
}

// tor_strisnonupper
// file ../src/common/util.c line 670
signed int tor_strisnonupper(const char *s)
{
  while(!(*s == 0))
  {
    signed int return_value_TOR_ISUPPER_1;
    return_value_TOR_ISUPPER_1=TOR_ISUPPER(*s);
    if(!(return_value_TOR_ISUPPER_1 == 0))
      return 0;

    s = s + 1l;
  }
  return 1;
}

// tor_strisprint
// file ../src/common/util.c line 657
signed int tor_strisprint(const char *s)
{
  while(!(*s == 0))
  {
    signed int return_value_TOR_ISPRINT_1;
    return_value_TOR_ISPRINT_1=TOR_ISPRINT(*s);
    if(return_value_TOR_ISPRINT_1 == 0)
      return 0;

    s = s + 1l;
  }
  return 1;
}

// tor_strlower
// file ../src/common/util.h line 201
void tor_strlower(char *s)
{
  for( ; !(*s == 0); s = s + 1l)
    *s = TOR_TOLOWER_TABLE[(signed long int)(unsigned char)*s];
}

// tor_strndup_
// file ../src/common/util.h line 84
char * tor_strndup_(const char *s, unsigned long int n)
{
  char *dup;
  if(s == ((const char *)NULL))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)311, "tor_strndup_", "s");
    abort();
  }

  if(n >= 9223372036854775791ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)312, "tor_strndup_", "n < SIZE_T_CEILING");
    abort();
  }

  void *return_value_tor_malloc__1;
  return_value_tor_malloc__1=tor_malloc_(n + (unsigned long int)1);
  dup = (char *)return_value_tor_malloc__1;
  strncpy(dup, s, n);
  dup[(signed long int)n] = (char)0;
  return dup;
}

// tor_strstrip
// file ../src/common/util.h line 214
void tor_strstrip(char *s, const char *strip)
{
  char *tor_strstrip__1__read = s;
  char *tmp_post_1;
  char *tmp_post_2;
  while(!(*tor_strstrip__1__read == 0))
  {
    char *return_value___builtin_strchr_3;
    return_value___builtin_strchr_3=__builtin_strchr(strip, (signed int)*tor_strstrip__1__read);
    if(!(return_value___builtin_strchr_3 == ((char *)NULL)))
      tor_strstrip__1__read = tor_strstrip__1__read + 1l;

    else
    {
      tmp_post_1 = s;
      s = s + 1l;
      tmp_post_2 = tor_strstrip__1__read;
      tor_strstrip__1__read = tor_strstrip__1__read + 1l;
      *tmp_post_1 = *tmp_post_2;
    }
  }
  *s = (char)0;
}

// tor_strtok_r_impl
// file ../src/common/compat.c line 686
char * tor_strtok_r_impl(char *str, const char *sep, char **lasts)
{
  char *cp;
  char *start;
  if(*sep == 0)
  {
    tor_assertion_failed_("../src/common/compat.c", (unsigned int)689, "tor_strtok_r_impl", "*sep");
    abort();
  }

  _Bool tmp_if_expr_1;
  if(!(str == ((char *)NULL)))
  {
    str=strtok_helper(str, sep);
    if(*str == 0)
      return (char *)(void *)0;

    *lasts = str;
    cp = *lasts;
    start = cp;
  }

  else
  {
    if(*lasts == ((char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(*(*lasts) != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return (char *)(void *)0;

    else
    {
      cp = *lasts;
      start = cp;
    }
  }
  char *return_value___builtin_strchr_2;
  if(!(sep[1l] == 0))
    for( ; !(*cp == 0); cp = cp + 1l)
    {
      return_value___builtin_strchr_2=__builtin_strchr(sep, (signed int)*cp);
      if(!(return_value___builtin_strchr_2 == ((char *)NULL)))
        break;

    }

  else
  {
    char *return_value___builtin_strchr_3;
    return_value___builtin_strchr_3=__builtin_strchr(cp, (signed int)*sep);
    cp = return_value___builtin_strchr_3;
  }
  _Bool tmp_if_expr_5;
  if(cp == ((char *)NULL))
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = !(*cp != 0) ? (_Bool)1 : (_Bool)0;
  char *tmp_post_4;
  if(tmp_if_expr_5)
    *lasts = (char *)(void *)0;

  else
  {
    tmp_post_4 = cp;
    cp = cp + 1l;
    *tmp_post_4 = (char)0;
    *lasts=strtok_helper(cp, sep);
  }
  return start;
}

// tor_strupper
// file ../src/common/util.c line 646
void tor_strupper(char *s)
{
  for( ; !(*s == 0); s = s + 1l)
    *s = TOR_TOUPPER_TABLE[(signed long int)(unsigned char)*s];
}

// tor_terminate_process
// file ../src/common/util.c line 3898
signed int tor_terminate_process(struct process_handle_t *process_handle)
{
  if(!(process_handle->waitpid_cb == ((struct waitpid_callback_t *)NULL)))
  {
    signed int return_value_kill_1;
    return_value_kill_1=kill(process_handle->pid, 15);
    return return_value_kill_1;
  }

  return -1;
}

// tor_threads_init
// file ../src/common/compat_pthreads.c line 276
void tor_threads_init(void)
{
  if(threads_initialized == 0)
  {
    pthread_mutexattr_init(&attr_recursive);
    pthread_mutexattr_settype(&attr_recursive, 1);
    signed int return_value_pthread_attr_init_1;
    return_value_pthread_attr_init_1=pthread_attr_init(&attr_detached);
    if(!(return_value_pthread_attr_init_1 == 0))
    {
      tor_assertion_failed_("../src/common/compat_pthreads.c", (unsigned int)281, "tor_threads_init", "0==pthread_attr_init(&attr_detached)");
      abort();
    }

    signed int return_value_pthread_attr_setdetachstate_2;
    return_value_pthread_attr_setdetachstate_2=pthread_attr_setdetachstate(&attr_detached, 1);
    if(!(return_value_pthread_attr_setdetachstate_2 == 0))
    {
      tor_assertion_failed_("../src/common/compat_pthreads.c", (unsigned int)286, "tor_threads_init", "0==pthread_attr_setdetachstate(&attr_detached, PTHREAD_CREATE_DETACHED)");
      abort();
    }

    threads_initialized = 1;
    set_main_thread();
  }

}

// tor_timegm
// file ../src/common/util.c line 1529
signed int tor_timegm(struct tm *tm, signed long int *time_out)
{
  signed long int year;
  signed long int days;
  signed long int hours;
  signed long int minutes;
  signed long int seconds;
  signed int i;
  signed int invalid_year;
  signed int dpm;
  if(!(tm->tm_year >= 2147483647))
    year = (signed long int)(tm->tm_year + 1900);

  else
    year = (signed long int)2147483647;
  _Bool tmp_if_expr_1;
  if(!(year >= 1970l))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = tm->tm_year >= 2147483647 - 1900 ? (_Bool)1 : (_Bool)0;
  invalid_year = (signed int)tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  if(tm->tm_mon >= 0)
    tmp_if_expr_3 = tm->tm_mon <= 11 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_3)
  {
    dpm = days_per_month[(signed long int)tm->tm_mon];
    if(tm->tm_mon == 1)
    {
      if(invalid_year == 0)
      {
        if(tm->tm_year % 4 == 0)
        {
          if(!(tm->tm_year % 100 == 0))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = !(tm->tm_year % 400 != 0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
            dpm = 29;

        }

      }

    }

  }

  else
    dpm = 0;
  _Bool tmp_if_expr_4;
  if(!(invalid_year == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = tm->tm_mon < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = tm->tm_mon > 11 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = tm->tm_mday < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = tm->tm_mday > dpm ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = (_Bool)1;

  else
    tmp_if_expr_8 = tm->tm_hour < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_8)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = tm->tm_hour > 23 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  if(tmp_if_expr_9)
    tmp_if_expr_10 = (_Bool)1;

  else
    tmp_if_expr_10 = tm->tm_min < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_11;
  if(tmp_if_expr_10)
    tmp_if_expr_11 = (_Bool)1;

  else
    tmp_if_expr_11 = tm->tm_min > 59 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_11)
    tmp_if_expr_12 = (_Bool)1;

  else
    tmp_if_expr_12 = tm->tm_sec < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_13;
  if(tmp_if_expr_12)
    tmp_if_expr_13 = (_Bool)1;

  else
    tmp_if_expr_13 = tm->tm_sec > 60 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_13)
  {
    log_fn_(4, 1u << 12, "tor_timegm", "Out-of-range argument to tor_timegm");
    return -1;
  }

  else
  {
    signed int return_value_n_leapdays_14;
    return_value_n_leapdays_14=n_leapdays(1970, (signed int)year);
    days = (signed long int)365 * (year - (signed long int)1970) + (signed long int)return_value_n_leapdays_14;
    i = 0;
    for( ; !(i >= tm->tm_mon); i = i + 1)
      days = days + (signed long int)days_per_month[(signed long int)i];
    if(tm->tm_mon >= 2)
    {
      if(year % 4l == 0l && (year % 400l == 0l || !(year % 100l == 0l)))
        days = days + 1l;

    }

    days = days + (signed long int)(tm->tm_mday - 1);
    hours = days * (signed long int)24 + (signed long int)tm->tm_hour;
    minutes = hours * (signed long int)60 + (signed long int)tm->tm_min;
    seconds = minutes * (signed long int)60 + (signed long int)tm->tm_sec;
    *time_out = seconds;
    return 0;
  }
}

// tor_vasprintf
// file ../src/common/compat.c line 504
signed int tor_vasprintf(char **strp, const char *fmt, void **args)
{
  char *strp_tmp = (char *)(void *)0;
  signed int r;
  r=vasprintf(&strp_tmp, fmt, args);
  if(!(r >= 0))
    *strp = (char *)(void *)0;

  else
    *strp = strp_tmp;
  return r;
}

// tor_vsnprintf
// file ../src/common/compat.c line 450
signed int tor_vsnprintf(char *str, unsigned long int size, const char *format, void **args)
{
  signed int r;
  if(size == 0ul)
    return -1;

  else
    if(size >= 9223372036854775792ul)
      return -1;

    else
    {
      r=vsnprintf(str, size, format, args);
      str[(signed long int)(size - (unsigned long int)1)] = (char)0;
      if((signed long int)r >= (signed long int)size || !(r >= 0))
        return -1;

      else
        return r;
    }
}

// tor_vsscanf
// file ../src/common/util.c line 3187
signed int tor_vsscanf(const char *buf, const char *pattern, __builtin_va_list ap)
{
  signed int n_matched = 0;
  const char *tmp_post_1;
  signed int return_value_TOR_ISDIGIT_2;
  const char *tmp_post_3;
  _Bool tmp_if_expr_11;
  const char *tmp_post_10;
  while(!(*pattern == 0))
    if(!((signed int)*pattern == 37))
    {
      if(*buf == *pattern)
      {
        buf = buf + 1l;
        pattern = pattern + 1l;
        continue;
      }

      else
        return n_matched;
    }

    else
    {
      signed int width = -1;
      signed int longmod = 0;
      pattern = pattern + 1l;
      signed int return_value_TOR_ISDIGIT_5;
      return_value_TOR_ISDIGIT_5=TOR_ISDIGIT_link1(*pattern);
      if(!(return_value_TOR_ISDIGIT_5 == 0))
      {
        tmp_post_1 = pattern;
        pattern = pattern + 1l;
        width=digit_to_num(*tmp_post_1);
        do
        {
          return_value_TOR_ISDIGIT_2=TOR_ISDIGIT_link1(*pattern);
          if(return_value_TOR_ISDIGIT_2 == 0)
            break;

          width = width * 10;
          tmp_post_3 = pattern;
          pattern = pattern + 1l;
          signed int return_value_digit_to_num_4;
          return_value_digit_to_num_4=digit_to_num(*tmp_post_3);
          width = width + return_value_digit_to_num_4;
          if(width >= 10000)
            return -1;

        }
        while((_Bool)1);
        if(width == 0)
          return -1;

      }

      if((signed int)*pattern == 108)
      {
        longmod = 1;
        pattern = pattern + 1l;
      }

      if((signed int)*pattern == 117)
        tmp_if_expr_11 = (_Bool)1;

      else
        tmp_if_expr_11 = (signed int)*pattern == 120 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_11)
      {
        unsigned long int u;
        const signed int base = (signed int)*pattern == 117 ? 10 : 16;
        if(*buf == 0)
          return n_matched;

        signed int return_value_scan_unsigned_6;
        return_value_scan_unsigned_6=scan_unsigned(&buf, &u, width, base);
        if(!(return_value_scan_unsigned_6 >= 0))
          return n_matched;

        if(!(longmod == 0))
        {
          unsigned long int *out;
          out=va_arg(ap, __typeof__(out));
          *out = u;
        }

        else
        {
          unsigned int *tor_vsscanf__1__1__2__3__2__out;
          tor_vsscanf__1__1__2__3__2__out=va_arg(ap, __typeof__(tor_vsscanf__1__1__2__3__2__out));
          if(u >= 4294967296ul)
            return n_matched;

          *tor_vsscanf__1__1__2__3__2__out = (unsigned int)u;
        }
        pattern = pattern + 1l;
        n_matched = n_matched + 1;
      }

      else
        if((signed int)*pattern == 102)
        {
          double *d;
          d=va_arg(ap, __typeof__(d));
          if(longmod == 0)
            return -1;

          if(*buf == 0)
            return n_matched;

          signed int return_value_scan_double_7;
          return_value_scan_double_7=scan_double(&buf, d, width);
          if(!(return_value_scan_double_7 >= 0))
            return n_matched;

          pattern = pattern + 1l;
          n_matched = n_matched + 1;
        }

        else
          if((signed int)*pattern == 100)
          {
            signed long int lng = (signed long int)0;
            signed int return_value_scan_signed_8;
            return_value_scan_signed_8=scan_signed(&buf, &lng, width);
            if(!(return_value_scan_signed_8 >= 0))
              return n_matched;

            if(!(longmod == 0))
            {
              signed long int *tor_vsscanf__1__1__2__5__1__out;
              tor_vsscanf__1__1__2__5__1__out=va_arg(ap, __typeof__(tor_vsscanf__1__1__2__5__1__out));
              *tor_vsscanf__1__1__2__5__1__out = lng;
            }

            else
            {
              signed int *tor_vsscanf__1__1__2__5__2__out;
              tor_vsscanf__1__1__2__5__2__out=va_arg(ap, __typeof__(tor_vsscanf__1__1__2__5__2__out));
              if(lng >= 2147483648l || !(lng >= -2147483648l))
                return n_matched;

              *tor_vsscanf__1__1__2__5__2__out = (signed int)lng;
            }
            pattern = pattern + 1l;
            n_matched = n_matched + 1;
          }

          else
            if((signed int)*pattern == 115)
            {
              char *s;
              s=va_arg(ap, __typeof__(s));
              if(!(longmod == 0))
                return -1;

              if(!(width >= 0))
                return -1;

              signed int return_value_scan_string_9;
              return_value_scan_string_9=scan_string(&buf, s, width);
              if(!(return_value_scan_string_9 >= 0))
                return n_matched;

              pattern = pattern + 1l;
              n_matched = n_matched + 1;
            }

            else
              if((signed int)*pattern == 99)
              {
                char *ch;
                ch=va_arg(ap, __typeof__(ch));
                if(!(longmod == 0))
                  return -1;

                if(!(width == -1))
                  return -1;

                if(*buf == 0)
                  return n_matched;

                tmp_post_10 = buf;
                buf = buf + 1l;
                *ch = *tmp_post_10;
                pattern = pattern + 1l;
                n_matched = n_matched + 1;
              }

              else
                if((signed int)*pattern == 37)
                {
                  if(!((signed int)*buf == 37))
                    return n_matched;

                  if(!(longmod == 0))
                    return -1;

                  buf = buf + 1l;
                  pattern = pattern + 1l;
                }

                else
                  return -1;
    }
  return n_matched;
}

// tor_weak_random
// file ../src/common/util.c line 5395
signed int tor_weak_random(struct tor_weak_rng_t *rng)
{
  rng->state = rng->state * (unsigned int)1103515245 + (unsigned int)12345 & (unsigned int)0x7fffffff;
  return (signed int)rng->state;
}

// tor_weak_random_range
// file ../src/common/util.c line 5411
signed int tor_weak_random_range(struct tor_weak_rng_t *rng, signed int top)
{
  signed int divisor;
  signed int result;
  if(!(top >= 1))
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)5417, "tor_weak_random_range", "top > 0");
    abort();
  }

  divisor = 0x7fffffff / top;
  do
  {
    signed int return_value_tor_weak_random_1;
    return_value_tor_weak_random_1=tor_weak_random(rng);
    result = (signed int)(return_value_tor_weak_random_1 / divisor);
  }
  while(result >= top);
  return result;
}

// touch_file
// file ../src/common/compat.c line 840
signed int touch_file(const char *fname)
{
  signed int return_value_utime_1;
  return_value_utime_1=utime(fname, (struct utimbuf *)(void *)0);
  if(!(return_value_utime_1 == 0))
    return -1;

  else
    return 0;
}

// truncate_logs
// file ../src/common/log.c line 1431
void truncate_logs(void)
{
  struct logfile_t *lf = logfiles;
  for( ; !(lf == ((struct logfile_t *)NULL)); lf = lf->next)
    if(lf->fd >= 0)
      tor_ftruncate(lf->fd);

}

// trunnel_dynarray_expand
// file ../src/ext/trunnel/trunnel.c line 99
void * trunnel_dynarray_expand(unsigned long int *allocated_p, void *ptr, unsigned long int howmanymore, unsigned long int eltsize)
{
  unsigned long int newsize = howmanymore + *allocated_p;
  void *newarray = (void *)0;
  if(!(newsize >= 8ul))
    newsize = (unsigned long int)8;

  if(!(newsize >= 2ul * *allocated_p))
    newsize = *allocated_p * (unsigned long int)2;

  if(*allocated_p >= newsize || !(newsize >= howmanymore))
    return (void *)0;

  else
  {
    newarray=trunnel_reallocarray(ptr, newsize, eltsize);
    if(newarray == NULL)
      return (void *)0;

    else
    {
      *allocated_p = newsize;
      return newarray;
    }
  }
}

// trunnel_dynarray_setlen
// file ../src/ext/trunnel/trunnel.c line 187
void * trunnel_dynarray_setlen(unsigned long int *allocated_p, unsigned long int *len_p, void *ptr, unsigned long int newlen, unsigned long int eltsize, void (*free_fn)(void *), unsigned char *errcode_ptr)
{
  if(!(*allocated_p >= newlen))
  {
    void *newptr;
    newptr=trunnel_dynarray_expand(allocated_p, ptr, newlen - *allocated_p, eltsize);
    if(newptr == NULL)
      goto trunnel_alloc_failed;

    ptr = newptr;
  }

  if(!(free_fn == ((void (*)(void *))NULL)))
  {
    if(!(newlen >= *len_p))
    {
      unsigned long int i;
      void **elts = (void **)ptr;
      i = newlen;
      if(!(i >= *len_p))
      {
        free_fn(elts[(signed long int)i]);
        elts[(signed long int)i] = (void *)0;
        i = i + 1ul;
      }

    }

  }

  if(!(*len_p >= newlen))
    memset_link11((void *)((char *)ptr + (signed long int)(eltsize * *len_p)), 0, (newlen - *len_p) * eltsize);

  *len_p = newlen;
  return ptr;

trunnel_alloc_failed:
  ;
  *errcode_ptr = (unsigned char)1;
  return (void *)0;
}

// trunnel_htonll
// file ../src/ext/trunnel/trunnel.c line 75
unsigned long int trunnel_htonll(unsigned long int a)
{
  unsigned int return_value___bswap_32_1;
  return_value___bswap_32_1=__bswap_32_link3((unsigned int)(a >> 32));
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32_link3((unsigned int)a);
  return (unsigned long int)return_value___bswap_32_1 | (unsigned long int)return_value___bswap_32_2 << 32;
}

// trunnel_ntohll
// file ../src/ext/trunnel/trunnel.c line 86
unsigned long int trunnel_ntohll(unsigned long int a)
{
  unsigned long int return_value_trunnel_htonll_1;
  return_value_trunnel_htonll_1=trunnel_htonll(a);
  return return_value_trunnel_htonll_1;
}

// trunnel_reallocarray
// file ../src/ext/trunnel/trunnel.c line 120
void * trunnel_reallocarray(void *a, unsigned long int x, unsigned long int y)
{
  if(!(18446744073709551615UL / y >= x))
    return (void *)0;

  else
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc(a, x * y);
    return return_value_realloc_1;
  }
}

// trunnel_string_getstr
// file ../src/ext/trunnel/trunnel.c line 135
const char * trunnel_string_getstr(struct trunnel_string_st *str)
{
  /* assertion str->allocated_ >= str->n_ */
  assert(str->allocated_ >= str->n_);
  if(str->allocated_ == str->n_)
    do
    {
      char *newarray;
      void *return_value_trunnel_dynarray_expand_1;
      return_value_trunnel_dynarray_expand_1=trunnel_dynarray_expand(&str->allocated_, (void *)str->elts_, (unsigned long int)1, sizeof(char) /*1ul*/ );
      newarray = (char *)return_value_trunnel_dynarray_expand_1;
      if(newarray == ((char *)NULL))
        goto trunnel_alloc_failed;

      str->elts_ = newarray;
    }
    while((_Bool)0);

  str->elts_[(signed long int)str->n_] = (char)0;
  return str->elts_;

trunnel_alloc_failed:
  ;
  return (const char *)(void *)0;
}

// trunnel_string_setlen
// file ../src/ext/trunnel/trunnel.c line 166
signed int trunnel_string_setlen(struct trunnel_string_st *str, unsigned long int newlen, unsigned char *errcode_ptr)
{
  if(!(newlen == 18446744073709551615UL))
  {
    if(!(str->allocated_ >= 1ul + newlen))
      do
      {
        char *newarray;
        void *return_value_trunnel_dynarray_expand_1;
        return_value_trunnel_dynarray_expand_1=trunnel_dynarray_expand(&str->allocated_, (void *)str->elts_, (newlen + (unsigned long int)1) - str->allocated_, sizeof(char) /*1ul*/ );
        newarray = (char *)return_value_trunnel_dynarray_expand_1;
        if(newarray == ((char *)NULL))
          goto trunnel_alloc_failed;

        str->elts_ = newarray;
      }
      while((_Bool)0);

    if(!(str->n_ >= newlen))
      memset_link11((void *)&str->elts_[(signed long int)str->n_], 0, newlen - str->n_);

    str->n_ = newlen;
    str->elts_[(signed long int)newlen] = (char)0;
    return 0;
  }

  else
  {

  trunnel_alloc_failed:
    ;
    *errcode_ptr = (unsigned char)1;
    return -1;
  }
}

// trunnel_string_setstr0
// file ../src/ext/trunnel/trunnel.c line 148
signed int trunnel_string_setstr0(struct trunnel_string_st *str, const char *val, unsigned long int len, unsigned char *errcode_ptr)
{
  if(!(len == 18446744073709551615UL))
  {
    if(len >= str->allocated_)
      do
      {
        char *newarray;
        void *return_value_trunnel_dynarray_expand_1;
        return_value_trunnel_dynarray_expand_1=trunnel_dynarray_expand(&str->allocated_, (void *)str->elts_, (len + (unsigned long int)1) - str->allocated_, sizeof(char) /*1ul*/ );
        newarray = (char *)return_value_trunnel_dynarray_expand_1;
        if(newarray == ((char *)NULL))
          goto trunnel_alloc_failed;

        str->elts_ = newarray;
      }
      while((_Bool)0);

    memcpy_link10((void *)str->elts_, (const void *)val, len);
    str->n_ = len;
    str->elts_[(signed long int)len] = (char)0;
    return 0;
  }

  else
  {

  trunnel_alloc_failed:
    ;
    *errcode_ptr = (unsigned char)1;
    return -1;
  }
}

// tv_mdiff
// file ../src/common/util.c line 1481
signed long int tv_mdiff(struct timeval *start, struct timeval *end)
{
  signed long int mdiff;
  signed long int secdiff = end->tv_sec - start->tv_sec;
  signed long int return_value_labs_1;
  return_value_labs_1=labs(secdiff + (signed long int)1);
  if(return_value_labs_1 >= 9223372036854776l)
  {
    log_fn_(4, 1u << 0, "tv_mdiff", "comparing times on millisecond detail too far apart: %ld seconds", secdiff);
    return 0x7fffffffffffffffL;
  }

  else
  {
    mdiff = secdiff * 1000L + (((signed long int)end->tv_usec - (signed long int)start->tv_usec) + 500L) / 1000L;
    return mdiff;
  }
}

// tv_to_msec
// file ../src/common/util.c line 1502
signed long int tv_to_msec(struct timeval *tv)
{
  signed long int conv = (signed long int)tv->tv_sec * 1000L;
  conv = conv + ((signed long int)tv->tv_usec + (signed long int)500) / 1000L;
  return conv;
}

// tv_udiff
// file ../src/common/util.c line 1463
signed long int tv_udiff(struct timeval *start, struct timeval *end)
{
  signed long int udiff;
  signed long int secdiff = end->tv_sec - start->tv_sec;
  signed long int return_value_labs_1;
  return_value_labs_1=labs(secdiff + (signed long int)1);
  if(return_value_labs_1 >= 9223372036855l)
  {
    log_fn_(4, 1u << 0, "tv_udiff", "comparing times on microsecond detail too far apart: %ld seconds", secdiff);
    return 0x7fffffffffffffffL;
  }

  else
  {
    udiff = secdiff * 1000000L + (end->tv_usec - start->tv_usec);
    return udiff;
  }
}

// unescape_string
// file ../src/common/util.c line 2714
static const char * unescape_string(const char *s, char **result, unsigned long int *size_out)
{
  const char *cp;
  char *out;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_3;
  signed int return_value_TOR_ISXDIGIT_2;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  char *tmp_post_15;
  char *tmp_post_16;
  char *tmp_post_17;
  char *tmp_post_18;
  const char *tmp_post_19;
  if(!((signed int)*s == 34))
    return (const char *)(void *)0;

  else
  {
    cp = s + (signed long int)1;
    while((_Bool)1)
      switch((signed int)*cp)
      {
        case 0:

        case 10:
          return (const char *)(void *)0;
        case 34:
          goto end_of_loop;
        case 92:
        {
          if((signed int)cp[1l] == 120)
            tmp_if_expr_10 = (_Bool)1;

          else
            tmp_if_expr_10 = (signed int)cp[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_10)
          {
            signed int return_value_TOR_ISXDIGIT_1;
            return_value_TOR_ISXDIGIT_1=TOR_ISXDIGIT_link1(cp[(signed long int)2]);
            if(!(return_value_TOR_ISXDIGIT_1 == 0))
            {
              return_value_TOR_ISXDIGIT_2=TOR_ISXDIGIT_link1(cp[(signed long int)3]);
              tmp_if_expr_3 = return_value_TOR_ISXDIGIT_2 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            if(!tmp_if_expr_3)
              return (const char *)(void *)0;

            cp = cp + (signed long int)4;
          }

          else
          {
            if((signed int)cp[1l] >= 48)
              tmp_if_expr_9 = (signed int)cp[(signed long int)1] <= 55 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_9 = (_Bool)0;
            if(tmp_if_expr_9)
            {
              cp = cp + (signed long int)2;
              if((signed int)*cp >= 48)
              {
                if(!((signed int)*cp >= 56))
                  cp = cp + 1l;

              }

              if((signed int)*cp >= 48)
              {
                if(!((signed int)*cp >= 56))
                  cp = cp + 1l;

              }

            }

            else
            {
              if((signed int)cp[1l] == 110)
                tmp_if_expr_4 = (_Bool)1;

              else
                tmp_if_expr_4 = (signed int)cp[(signed long int)1] == 114 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_4)
                tmp_if_expr_5 = (_Bool)1;

              else
                tmp_if_expr_5 = (signed int)cp[(signed long int)1] == 116 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_5)
                tmp_if_expr_6 = (_Bool)1;

              else
                tmp_if_expr_6 = (signed int)cp[(signed long int)1] == 34 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_6)
                tmp_if_expr_7 = (_Bool)1;

              else
                tmp_if_expr_7 = (signed int)cp[(signed long int)1] == 92 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_7)
                tmp_if_expr_8 = (_Bool)1;

              else
                tmp_if_expr_8 = (signed int)cp[(signed long int)1] == 39 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_8)
                cp = cp + (signed long int)2;

              else
                return (const char *)(void *)0;
            }
          }
          break;
        }
        default:
          cp = cp + 1l;
      }

  end_of_loop:
    ;
    void *return_value_tor_malloc__11;
    return_value_tor_malloc__11=tor_malloc_((unsigned long int)((cp - s) + (signed long int)1));
    *result = (char *)return_value_tor_malloc__11;
    out = *result;
    cp = s + (signed long int)1;
    while((_Bool)1)
      switch((signed int)*cp)
      {
        case 34:
        {
          *out = (char)0;
          if(!(size_out == ((unsigned long int *)NULL)))
            *size_out = (unsigned long int)(out - *result);

          return cp + (signed long int)1;
        }
        case 0:
        {
          if(!(*result == ((char *)NULL)))
          {
            free((void *)*result);
            *result = (char *)(void *)0;
          }

          return (const char *)(void *)0;
        }
        case 92:
        {
          switch((signed int)cp[(signed long int)1])
          {
            case 110:
            {
              tmp_post_12 = out;
              out = out + 1l;
              *tmp_post_12 = (char)10;
              cp = cp + (signed long int)2;
              break;
            }
            case 114:
            {
              tmp_post_13 = out;
              out = out + 1l;
              *tmp_post_13 = (char)13;
              cp = cp + (signed long int)2;
              break;
            }
            case 116:
            {
              tmp_post_14 = out;
              out = out + 1l;
              *tmp_post_14 = (char)9;
              cp = cp + (signed long int)2;
              break;
            }
            case 120:

            case 88:
            {
              signed int x1;
              signed int x2;
              x1=hex_decode_digit(cp[(signed long int)2]);
              x2=hex_decode_digit(cp[(signed long int)3]);
              if(x1 == -1 || x2 == -1)
              {
                if(!(*result == ((char *)NULL)))
                {
                  free((void *)*result);
                  *result = (char *)(void *)0;
                }

                return (const char *)(void *)0;
              }

              tmp_post_15 = out;
              out = out + 1l;
              *tmp_post_15 = (char)((x1 << 4) + x2);
              cp = cp + (signed long int)4;
              break;
            }
            case 48:

            case 49:

            case 50:

            case 51:

            case 52:

            case 53:

            case 54:

            case 55:
            {
              signed int n = (signed int)cp[(signed long int)1] - 48;
              cp = cp + (signed long int)2;
              if((signed int)*cp >= 48)
              {
                if(!((signed int)*cp >= 56))
                {
                  n = (n * 8 + (signed int)*cp) - 48;
                  cp = cp + 1l;
                }

              }

              if((signed int)*cp >= 48)
              {
                if(!((signed int)*cp >= 56))
                {
                  n = (n * 8 + (signed int)*cp) - 48;
                  cp = cp + 1l;
                }

              }

              if(n >= 256)
              {
                if(!(*result == ((char *)NULL)))
                {
                  free((void *)*result);
                  *result = (char *)(void *)0;
                }

                return (const char *)(void *)0;
              }

              tmp_post_16 = out;
              out = out + 1l;
              *tmp_post_16 = (char)n;
              break;
            }
            case 39:

            case 34:

            case 92:

            case 63:
            {
              tmp_post_17 = out;
              out = out + 1l;
              *tmp_post_17 = cp[(signed long int)1];
              cp = cp + (signed long int)2;
              break;
            }
            default:
            {
              if(!(*result == ((char *)NULL)))
              {
                free((void *)*result);
                *result = (char *)(void *)0;
              }

              return (const char *)(void *)0;
            }
          }
          break;
        }
        default:
        {
          tmp_post_18 = out;
          out = out + 1l;
          tmp_post_19 = cp;
          cp = cp + 1l;
          *tmp_post_18 = *tmp_post_19;
        }
      }
  }
}

// update_approx_time
// file ../src/common/util.c line 1917
void update_approx_time(signed long int now)
{
  cached_approx_time = now;
}

// usage
// file ../src/tools/tor-resolve.c line 332
static void usage(void)
{
  puts("Syntax: tor-resolve [-4] [-5] [-v] [-x] [-F] [-p port] hostname [sockshost[:socksport]]");
  exit(1);
}

// vasprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 207
static inline signed int vasprintf(char ** restrict __ptr, const char * restrict __fmt, void **__ap)
{
  signed int return_value___vasprintf_chk_1;
  return_value___vasprintf_chk_1=__vasprintf_chk(__ptr, 2 - 1, __fmt, __ap);
  return return_value___vasprintf_chk_1;
}

// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsnprintf_chk_1;
  return_value___builtin___vsnprintf_chk_1=__builtin___vsnprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsnprintf_chk_1;
}

// worker_thread_has_work
// file ../src/common/workqueue.c line 160
static signed int worker_thread_has_work(struct workerthread_s *thread)
{
  _Bool tmp_if_expr_1;
  if(!(thread->in_pool->work.tqh_first == ((struct workqueue_entry_s *)NULL)))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = thread->generation != thread->in_pool->generation ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// worker_thread_main
// file ../src/common/workqueue.c line 170
static void worker_thread_main(void *thread_)
{
  struct workerthread_s *thread = (struct workerthread_s *)thread_;
  struct threadpool_s *pool = thread->in_pool;
  struct workqueue_entry_s *work;
  signed int result;
  tor_mutex_acquire(&pool->lock);
  while((_Bool)1)
  {
    signed int return_value_worker_thread_has_work_1;
    return_value_worker_thread_has_work_1=worker_thread_has_work(thread);
    if(!(return_value_worker_thread_has_work_1 == 0))
    {
      if(!(thread->in_pool->generation == thread->generation))
      {
        void *arg = thread->in_pool->update_args[(signed long int)thread->index];
        thread->in_pool->update_args[(signed long int)thread->index] = (void *)0;
        signed int (*update_fn)(void *, void *) = thread->in_pool->update_fn;
        thread->generation = thread->in_pool->generation;
        tor_mutex_release(&pool->lock);
        signed int r;
        r=update_fn(thread->state, arg);
        tor_mutex_acquire(&pool->lock);
      }

      work = (&pool->work)->tqh_first;
      do
      {
        if(!(work->next_work.tqe_next == ((struct workqueue_entry_s *)NULL)))
          work->next_work.tqe_next->next_work.tqe_prev = work->next_work.tqe_prev;

        else
          (&pool->work)->tqh_last = work->next_work.tqe_prev;
        *work->next_work.tqe_prev = work->next_work.tqe_next;
      }
      while((_Bool)0);
      work->pending = (unsigned char)0;
      tor_mutex_release(&pool->lock);
      result=work->fn(thread->state, work->arg);
      queue_reply(thread->reply_queue, work);
      tor_mutex_acquire(&pool->lock);
    }

    signed int return_value_tor_cond_wait_2;
    return_value_tor_cond_wait_2=tor_cond_wait(&pool->condition, &pool->lock, (struct timeval *)(void *)0);
    if(!(return_value_tor_cond_wait_2 >= 0))
      log_fn_(4, 1u << 0, "worker_thread_main", "Fail tor_cond_wait.");

  }
}

// workerthread_new
// file ../src/common/workqueue.c line 249
static struct workerthread_s * workerthread_new(void *state, struct threadpool_s *pool, struct replyqueue_s *replyqueue)
{
  struct workerthread_s *thr;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct workerthread_s) /*40ul*/ );
  thr = (struct workerthread_s *)return_value_tor_malloc_zero__1;
  thr->state = state;
  thr->reply_queue = replyqueue;
  thr->in_pool = pool;
  signed int return_value_spawn_func_2;
  return_value_spawn_func_2=spawn_func(worker_thread_main, (void *)thr);
  if(!(return_value_spawn_func_2 >= 0))
  {
    log_fn_(3, 1u << 0, "workerthread_new", "Can't launch worker thread.");
    return (struct workerthread_s *)(void *)0;
  }

  else
    return thr;
}

// workqueue_entry_cancel
// file ../src/common/workqueue.c line 138
void * workqueue_entry_cancel(struct workqueue_entry_s *ent)
{
  signed int cancelled = 0;
  void *result = (void *)0;
  tor_mutex_acquire(&ent->on_pool->lock);
  if(!(ent->pending == 0))
  {
    do
    {
      if(!(ent->next_work.tqe_next == ((struct workqueue_entry_s *)NULL)))
        ent->next_work.tqe_next->next_work.tqe_prev = ent->next_work.tqe_prev;

      else
        (&ent->on_pool->work)->tqh_last = ent->next_work.tqe_prev;
      *ent->next_work.tqe_prev = ent->next_work.tqe_next;
    }
    while((_Bool)0);
    cancelled = 1;
    result = ent->arg;
  }

  tor_mutex_release(&ent->on_pool->lock);
  if(!(cancelled == 0))
    workqueue_entry_free(ent);

  return result;
}

// workqueue_entry_free
// file ../src/common/workqueue.c line 115
static void workqueue_entry_free(struct workqueue_entry_s *ent)
{
  if(!(ent == ((struct workqueue_entry_s *)NULL)))
  {
    memset_link10((void *)ent, 0xf0, sizeof(struct workqueue_entry_s) /*56ul*/ );
    if(!(ent == ((struct workqueue_entry_s *)NULL)))
    {
      free((void *)ent);
      ent = (struct workqueue_entry_s *)(void *)0;
    }

  }

}

// workqueue_entry_new
// file ../src/common/workqueue.c line 99
static struct workqueue_entry_s * workqueue_entry_new(signed int (*fn)(void *, void *), void (*reply_fn)(void *), void *arg)
{
  struct workqueue_entry_s *ent;
  void *return_value_tor_malloc_zero__1;
  return_value_tor_malloc_zero__1=tor_malloc_zero_(sizeof(struct workqueue_entry_s) /*56ul*/ );
  ent = (struct workqueue_entry_s *)return_value_tor_malloc_zero__1;
  ent->fn = fn;
  ent->reply_fn = reply_fn;
  ent->arg = arg;
  return ent;
}

// write_all
// file ../src/tools/../common/util.h line 329
signed long int write_all(signed int fd, const char *buf, unsigned long int count, signed int isSocket)
{
  unsigned long int written = (unsigned long int)0;
  signed long int result;
  if(count >= 9223372036854775807ul)
  {
    tor_assertion_failed_("../src/common/util.c", (unsigned int)1979, "write_all", "count < SSIZE_MAX");
    abort();
  }

  for( ; !(written == count); written = written + (unsigned long int)result)
  {
    if(!(isSocket == 0))
      result=send(fd, (const void *)(buf + (signed long int)written), count - written, 0);

    else
      result=write((signed int)fd, (const void *)(buf + (signed long int)written), count - written);
    if(!(result >= 0l))
      return (signed long int)-1;

  }
  return (signed long int)count;
}

// write_bytes_to_file
// file ../src/common/util.c line 2521
signed int write_bytes_to_file(const char *fname, const char *str, unsigned long int len, signed int bin)
{
  signed int return_value_write_bytes_to_file_impl_1;
  return_value_write_bytes_to_file_impl_1=write_bytes_to_file_impl(fname, str, len, 01 | 0100 | 01000 | (bin != 0 ? 0 : 0));
  return return_value_write_bytes_to_file_impl_1;
}

// write_bytes_to_file_impl
// file ../src/common/util.c line 2507
static signed int write_bytes_to_file_impl(const char *fname, const char *str, unsigned long int len, signed int flags)
{
  signed int r;
  struct sized_chunk_t c = { .bytes=str, .len=len };
  struct smartlist_t *chunks;
  chunks=smartlist_new();
  smartlist_add(chunks, (void *)&c);
  r=write_chunks_to_file_impl(fname, chunks, flags);
  smartlist_free(chunks);
  return r;
}

// write_bytes_to_new_file
// file ../src/common/util.c line 2542
signed int write_bytes_to_new_file(const char *fname, const char *str, unsigned long int len, signed int bin)
{
  signed int return_value_write_bytes_to_file_impl_1;
  return_value_write_bytes_to_file_impl_1=write_bytes_to_file_impl(fname, str, len, 0100 | 0200 | 02000 | 01 | (bin != 0 ? 0 : 0));
  return return_value_write_bytes_to_file_impl_1;
}

// write_chunks_to_file
// file ../src/common/util.c line 2492
signed int write_chunks_to_file(const char *fname, const struct smartlist_t *chunks, signed int bin, signed int no_tempfile)
{
  signed int flags = 01 | 0100 | 01000 | (bin != 0 ? 0 : 0);
  if(!(no_tempfile == 0))
    flags = flags | 02000;

  signed int return_value_write_chunks_to_file_impl_1;
  return_value_write_chunks_to_file_impl_1=write_chunks_to_file_impl(fname, chunks, flags);
  return return_value_write_chunks_to_file_impl_1;
}

// write_chunks_to_file_impl
// file ../src/common/util.c line 2461
static signed int write_chunks_to_file_impl(const char *fname, const struct smartlist_t *chunks, signed int open_flags)
{
  struct open_file_t *file = (struct open_file_t *)(void *)0;
  signed int fd;
  signed long int result;
  fd=start_writing_to_file(fname, open_flags, 0600, &file);
  if(!(fd >= 0))
    return -1;

  else
  {
    signed int chunk_sl_idx;
    signed int chunk_sl_len = chunks->num_used;
    struct sized_chunk_t *chunk;
    chunk_sl_idx = 0;
    for( ; !(chunk_sl_idx >= chunk_sl_len); chunk_sl_idx = chunk_sl_idx + 1)
    {
      chunk = (struct sized_chunk_t *)chunks->list[(signed long int)chunk_sl_idx];
      result=write_all(fd, chunk->bytes, chunk->len, 0);
      if(!(result >= 0l))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        log_fn_(4, 1u << 4, "write_chunks_to_file_impl", "Error writing to \"%s\": %s", fname, return_value_strerror_2);
        goto err;
      }

      if(!((unsigned long int)result == chunk->len))
      {
        tor_assertion_failed_("../src/common/util.c", (unsigned int)2479, "write_chunks_to_file_impl", "(size_t)result == chunk->len");
        abort();
      }

      chunk = (struct sized_chunk_t *)(void *)0;
    }
    signed int return_value_finish_writing_to_file_3;
    return_value_finish_writing_to_file_3=finish_writing_to_file(file);
    return return_value_finish_writing_to_file_3;

  err:
    ;
    abort_writing_to_file(file);
    return -1;
  }
}

// write_ni
// file ../src/common/compat_threads.c line 93
static signed int write_ni(signed int fd, const void *buf, unsigned long int n)
{
  signed int r;
  signed long int return_value_write_1;
  signed int *return_value___errno_location_2;
  do
  {

  again:
    ;
    return_value_write_1=write(fd, buf, n);
    r = (signed int)return_value_write_1;
    if(r >= 0)
      break;

    return_value___errno_location_2=__errno_location();
  }
  while(*return_value___errno_location_2 == 4);
  return r;
}

// write_pidfile
// file ../src/common/util.c line 3565
void write_pidfile(char *filename)
{
  struct _IO_FILE *pidfile;
  pidfile=fopen(filename, "w");
  if(pidfile == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_fn_(4, 1u << 4, "write_pidfile", "Unable to open \"%s\" for writing: %s", filename, return_value_strerror_2);
  }

  else
  {
    signed int return_value_getpid_3;
    return_value_getpid_3=getpid();
    fprintf_link1(pidfile, "%d\n", (signed int)return_value_getpid_3);
    fclose(pidfile);
  }
}

// write_str_to_file
// file ../src/common/util.c line 2253
signed int write_str_to_file(const char *fname, const char *str, signed int bin)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  signed int return_value_write_bytes_to_file_2;
  return_value_write_bytes_to_file_2=write_bytes_to_file(fname, str, return_value_strlen_1, bin);
  return return_value_write_bytes_to_file_2;
}

