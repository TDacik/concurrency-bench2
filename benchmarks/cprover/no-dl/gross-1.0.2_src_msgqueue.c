// tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]
// file ../include/bloom.h line 56
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]
// file ../include/bloom.h line 62
struct anonymous_7;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'filter'||S32'update_q'||U32'_pad0'||*{SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#}_SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#_'sync_guard'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'bloom_guard'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'update_guard'||*{S64}_S64_'last_rotate'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnsbl'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'dnswl'||*{SYM#tag-dnsbl_s#}_SYM#tag-dnsbl_s#_'rhsbl'||SYM#tag-#anon#ST[SYM#tag-sockaddr_in#'gross_host'||SYM#tag-sockaddr_in#'sync_host'||SYM#tag-sockaddr_in#'status_host'||SYM#tag-peer_s#'peer'||S32'max_connq'||U32'_pad0'||S64'rotate_interval'||S64'stat_interval'||U32'filter_size'||U32'num_bufs'||*{S8}_S8_'statefile'||S32'loglevel'||S32'syslogfacility'||S32'statlevel'||S32'flags'||S32'checks'||S32'grey_mask'||S32'protocols'||S32'greylist_delay'||SYM#tag-postfix_config_s#'postfix'||SYM#tag-sjsms_config_s#'sjsms'||SYM#tag-blocker_config_s#'blocker'||S32'query_timelimit'||S32'grey_threshold'||S32'block_threshold'||S32'pool_maxthreads'||U32'_pad1'||*{S8}_S8_'grey_reason'||*{S8}_S8_'block_reason'||*{S8}_S8_'pidfile'|]#'config'||*{SYM#tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]#}_SYM#tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]#_'mmap_info'||*{SYM#tag-statefile_info_s#}_SYM#tag-statefile_info_s#_'statefile_info'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'bloommgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'syncmgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'postfix_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'sjsms_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'milter_server'|]#'process_parts'||SYM#tag-#anon#ST[S64'startup'||S64'begin'||S64'end'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mx'||U64'block'||U64'greylist'||U64'match'||U64'trust'||U64'all_block'||U64'all_greylist'||U64'all_match'||U64'all_trust'||F64'block_avg_delay'||F64'greylist_avg_delay'||F64'match_avg_delay'||F64'trust_avg_delay'||F64'block_max_delay'||F64'greylist_max_delay'||F64'match_max_delay'||F64'trust_max_delay'||*{SYM#tag-dnsbl_stat#}_SYM#tag-dnsbl_stat#_'dnsbl_match'|]#'stats'||ARR128{*{SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#}_SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#_}_*{SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#}_SYM#tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]#__'checklist'||S32'syslog_open'||U32'_pad1'|]
// file ../include/common.h line 270
struct anonymous_17;

// tag-#anon#ST[*{SYM#tag-msgqueue_s#}_SYM#tag-msgqueue_s#_'inq'||*{SYM#tag-msgqueue_s#}_SYM#tag-msgqueue_s#_'outq'|]
// file ../include/msgqueue.h line 45
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-thread_pool_s#}_SYM#tag-thread_pool_s#_'pool'||S32'definitive'||U32'_pad0'||*{S8}_S8_'name'||*{V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V}_V(*{V}_V_|*{SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#}_SYM#tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]#_)->V_'init_routine'||*{V}_V_'check_arg'|]
// file ../include/common.h line 256
struct anonymous_12;

// tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]
// file ../include/bloom.h line 48
struct anonymous_4;

// tag-#anon#ST[*{U64}_U64_'thread'|]
// file ../include/common.h line 239
struct anonymous_5;

// tag-#anon#ST[ARR8{S8}_S8_'magic'||*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_}_*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#__'filter_group'||U32'group_size'||U32'_pad0'|]#_'group'||*{SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{U32}_U32_'filter'||U32'bitsize'||U32'mask'||U32'size'||U32'_pad0'|]#_'aggregate'||U32'current_index'||U32'_pad0'|]#_'brq'||U64'lumpsize'||S64'last_rotate'|]
// file ../include/bloom.h line 69
struct anonymous_14;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_0;

// tag-#anon#ST[S32'max_thread'||S32'watchdog_time'||S32'watchdog'|]
// file ../include/thread_pool.h line 77
struct anonymous_11;

// tag-#anon#ST[S64'startup'||S64'begin'||S64'end'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mx'||U64'block'||U64'greylist'||U64'match'||U64'trust'||U64'all_block'||U64'all_greylist'||U64'all_match'||U64'all_trust'||F64'block_avg_delay'||F64'greylist_avg_delay'||F64'match_avg_delay'||F64'trust_avg_delay'||F64'block_max_delay'||F64'greylist_max_delay'||F64'match_max_delay'||F64'trust_max_delay'||*{SYM#tag-dnsbl_stat#}_SYM#tag-dnsbl_stat#_'dnsbl_match'|]
// file ../include/stats.h line 33
struct anonymous_15;

// tag-#anon#ST[SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'bloommgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'syncmgr'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'postfix_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'sjsms_server'||SYM#tag-#anon#ST[*{U64}_U64_'thread'|]#'milter_server'|]
// file ../include/common.h line 245
struct anonymous_8;

// tag-#anon#ST[SYM#tag-sockaddr_in#'gross_host'||SYM#tag-sockaddr_in#'sync_host'||SYM#tag-sockaddr_in#'status_host'||SYM#tag-peer_s#'peer'||S32'max_connq'||U32'_pad0'||S64'rotate_interval'||S64'stat_interval'||U32'filter_size'||U32'num_bufs'||*{S8}_S8_'statefile'||S32'loglevel'||S32'syslogfacility'||S32'statlevel'||S32'flags'||S32'checks'||S32'grey_mask'||S32'protocols'||S32'greylist_delay'||SYM#tag-postfix_config_s#'postfix'||SYM#tag-sjsms_config_s#'sjsms'||SYM#tag-blocker_config_s#'blocker'||S32'query_timelimit'||S32'grey_threshold'||S32'block_threshold'||S32'pool_maxthreads'||U32'_pad1'||*{S8}_S8_'grey_reason'||*{S8}_S8_'block_reason'||*{S8}_S8_'pidfile'|]
// file ../include/common.h line 183
struct anonymous_16;

// tag-#anon#ST[U32'array_index'||U32'intra_index'|]
// file ../include/bloom.h line 42
struct anonymous_10;

// tag-#anon#ST[U32'h0'||U32'h1'||U32'h2'||U32'h3'||U32'h4'||U32'h5'||U32'h6'||U32'h7'|]
// file ../include/sha256.h line 38
struct anonymous_9;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_13;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-blocker_config_s
// file ../include/common.h line 170
struct blocker_config_s;

// tag-dnsbl_s
// file ../include/common.h line 219
struct dnsbl_s;

// tag-dnsbl_stat
// file ../include/stats.h line 24
struct dnsbl_stat;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-msg_s
// file ../include/msgqueue.h line 23
struct msg_s;

// tag-msgqueue_s
// file ../include/msgqueue.h line 31
struct msgqueue_s;

// tag-peer_s
// file ../include/common.h line 147
struct peer_s;

// tag-postfix_config_s
// file ../include/common.h line 164
struct postfix_config_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-queuepair_s
// file msgqueue-test.c line 32
struct queuepair_s;

// tag-sjsms_config_s
// file ../include/common.h line 156
struct sjsms_config_s;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statefile_info_s
// file ../include/common.h line 265
struct statefile_info_s;

// tag-test_message_s
// file msgqueue-test.c line 37
struct test_message_s;

// tag-thread_pool_s
// file ../include/thread_pool.h line 27
struct thread_pool_s;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// Malloc
// file ../include/srvutils.h line 113
void * Malloc(unsigned long int size);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// add_filter
// file bloom.c line 309
struct anonymous_4 * add_filter(struct anonymous_4 *lvalue, const struct anonymous_4 *rvalue);
// add_mask
// file bloom.c line 92
unsigned int add_mask(unsigned int intra_index);
// advance_bloom_ring_queue
// file bloom.c line 366
struct anonymous_7 * advance_bloom_ring_queue(struct anonymous_7 *brq);
// array_index
// file bloom.c line 27
struct anonymous_10 array_index(unsigned int bit_index);
// bloom_error_rate
// file bloom.c line 278
double bloom_error_rate(unsigned int n, unsigned int k, unsigned int m);
// bloom_required_size
// file bloom.c line 284
unsigned int bloom_required_size(double c, unsigned int k, unsigned int n);
// bloom_ring_queue_next_index
// file bloom.c line 356
unsigned int bloom_ring_queue_next_index(struct anonymous_7 *brq);
// build_bloom_ring
// file srvutils.c line 224
struct anonymous_7 * build_bloom_ring(unsigned int num, unsigned int num_bits);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_pidfile
// file srvutils.c line 421
void check_pidfile(void);
// chomp
// file ../include/utils.h line 48
signed int chomp(char *buffer);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// connected
// file srvutils.c line 145
signed int connected(struct peer_s *peer);
// copy_bloom_filter
// file bloom.c line 218
struct anonymous_4 * copy_bloom_filter(struct anonymous_4 *filter, signed int empty);
// create_bloom_filter
// file bloom.c line 179
struct anonymous_4 * create_bloom_filter(unsigned int num_bits);
// create_bloom_filter_group
// file bloom.c line 241
struct anonymous_6 * create_bloom_filter_group(unsigned int num, unsigned int num_bits);
// create_bloom_ring_queue
// file bloom.c line 327
struct anonymous_7 * create_bloom_ring_queue(unsigned int num, unsigned int num_bits);
// create_pidfile
// file srvutils.c line 399
void create_pidfile(void);
// create_queue
// file msgqueue.c line 187
struct msgqueue_s * create_queue(void);
// create_statefile
// file srvutils.c line 186
void create_statefile(void);
// create_thread
// file ../include/srvutils.h line 114
void * create_thread(struct anonymous_5 *tinfo, signed int detach, void * (*routine)(void *), void *arg);
// create_thread::routine_object
//
void * routine_object(void *);
// ctime_r
// file /usr/include/time.h line 276
extern char * ctime_r(const signed long int *, char *);
// daemon_fatal
// file srvutils.c line 124
void daemon_fatal(const char *reason);
// daemon_shutdown
// file srvutils.c line 97
void daemon_shutdown(signed int return_code, const char *fmt, ...);
// daemonize
// file srvutils.c line 440
void daemonize(void);
// date_fmt
// file srvutils.c line 552
unsigned long int date_fmt(char *msg, unsigned long int len);
// debug_print_array_index
// file bloom.c line 69
void debug_print_array_index(struct anonymous_10 index, signed int with_newline);
// debug_print_bit_up
// file bloom.c line 77
void debug_print_bit_up(unsigned int *array, unsigned int bit_index, signed int with_newline);
// debug_print_bits
// file bloom.c line 53
void debug_print_bits(signed int value, signed int with_newline);
// debug_print_filter
// file bloom.c line 38
void debug_print_filter(struct anonymous_4 *filter, signed int with_newline);
// debug_print_ring_queue
// file bloom.c line 409
void debug_print_ring_queue(struct anonymous_7 *brq, signed int with_newline);
// delay
// file msgqueue.c line 142
void * delay(void *arg);
// disable_delay
// file msgqueue.c line 253
signed int disable_delay(signed int msqid);
// enable_delay
// file msgqueue.c line 259
signed int enable_delay(signed int msqid);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_bit
// file bloom.c line 99
unsigned int get_bit(unsigned int *array, unsigned int bit_index);
// get_delay_queue
// file msgqueue.c line 104
signed int get_delay_queue(struct timespec *ts);
// get_msg
// file msgqueue.c line 645
unsigned long int get_msg(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag);
// get_msg_raw
// file msgqueue.c line 582
struct msg_s * get_msg_raw(struct msgqueue_s *mq, signed int timeout);
// get_msg_timed
// file ../include/msgqueue.h line 60
unsigned long int get_msg_timed(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag, signed int timeout);
// get_queue
// file ../include/msgqueue.h line 51
signed int get_queue(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// in_queue_len
// file msgqueue.c line 683
unsigned long int in_queue_len(signed int msgid);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_bit_array
// file bloom.c line 121
void init_bit_array(unsigned int *array, unsigned int size);
// insert_absolute_bloom_ring_queue
// file bloom.c line 427
void insert_absolute_bloom_ring_queue(struct anonymous_7 *brq, unsigned int *buffer, signed int size, signed int index, unsigned int buf_index);
// insert_bit
// file bloom.c line 110
void insert_bit(unsigned int *array, unsigned int bit_index);
// insert_digest
// file bloom.c line 139
void insert_digest(struct anonymous_4 *filter, struct anonymous_9 digest);
// insert_digest_bloom_ring_queue
// file bloom.c line 341
void insert_digest_bloom_ring_queue(struct anonymous_7 *brq, struct anonymous_9 digest);
// insert_digest_to_group_member
// file bloom.c line 169
void insert_digest_to_group_member(struct anonymous_6 *filter_group, unsigned int member_index, struct anonymous_9 digest);
// instant_msg
// file msgqueue.c line 448
signed int instant_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg);
// int_to_index
// file bloom.c line 133
unsigned int int_to_index(unsigned int value, unsigned int mask);
// ipstr
// file srvutils.c line 589
char * ipstr(struct sockaddr_in *saddr);
// is_in_array
// file bloom.c line 154
signed int is_in_array(struct anonymous_4 *filter, struct anonymous_9 digest);
// is_in_ring_queue
// file bloom.c line 349
signed int is_in_ring_queue(struct anonymous_7 *brq, struct anonymous_9 digest);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_close
// file srvutils.c line 618
signed int log_close(void);
// log_open
// file srvutils.c line 603
signed int log_open(void);
// log_put
// file srvutils.c line 538
signed int log_put(const char *msg);
// logstr
// file ../include/srvutils.h line 102
signed int logstr(signed int level, const char *fmt, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// ms_diff
// file utils.c line 206
signed int ms_diff(struct timespec *t1, struct timespec *t2);
// msgqueueping
// file msgqueue-test.c line 47
static void * msgqueueping(void *arg);
// mstotimespec
// file ../include/utils.h line 52
void mstotimespec(signed int mseconds, struct timespec *ts);
// msync
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 89
extern signed int msync(void *, unsigned long int, signed int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// new_address
// file srvutils.c line 151
void * new_address(void *val1, unsigned long int val2);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// optimal_size
// file bloom.c line 292
unsigned int optimal_size(unsigned int n, double c);
// out_queue_len
// file msgqueue.c line 695
unsigned long int out_queue_len(signed int msgid);
// peek_msg_timestamp
// file msgqueue.c line 550
struct timespec * peek_msg_timestamp(struct msgqueue_s *mq);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_2 *, const union anonymous *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_2 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_2 *, union anonymous_3 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_2 *, union anonymous_3 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// put_msg
// file ../include/msgqueue.h line 56
signed int put_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg);
// put_msg_raw
// file msgqueue.c line 378
signed int put_msg_raw(struct msgqueue_s *mq, struct msg_s *msg);
// queue_freeze
// file msgqueue.c line 321
signed int queue_freeze(signed int msqid);
// queue_realloc
// file msgqueue.c line 60
void queue_realloc(void);
// queue_thaw
// file msgqueue.c line 294
signed int queue_thaw(signed int msqid);
// queuebyid
// file msgqueue.c line 82
struct msgqueue_s * queuebyid(signed int msqid);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readline
// file utils.c line 33
signed int readline(signed int fd, void *vptr, unsigned long int maxlen);
// readn
// file utils.c line 67
signed long int readn(signed int fd, void *vptr, unsigned long int n);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// register_check
// file srvutils.c line 570
void register_check(struct thread_pool_s *pool, signed int definitive);
// release_bloom_filter
// file bloom.c line 202
void release_bloom_filter(struct anonymous_4 *filter);
// release_bloom_filter_group
// file bloom.c line 263
void release_bloom_filter_group(struct anonymous_6 *filter_group);
// release_bloom_ring_queue
// file srvutils.c line 380
void release_bloom_ring_queue(struct anonymous_7 *brq);
// release_queue
// file msgqueue.c line 490
signed int release_queue(signed int msqid);
// respond
// file utils.c line 154
signed long int respond(signed int fd, const char *response);
// rotate_bloom_ring_queue
// file bloom.c line 375
struct anonymous_7 * rotate_bloom_ring_queue(struct anonymous_7 *brq);
// set_delay
// file msgqueue.c line 347
signed int set_delay(signed int msqid, struct timespec *ts);
// set_delay_status
// file msgqueue.c line 265
signed int set_delay_status(signed int msqid, signed int state);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// statstr
// file srvutils.c line 67
signed int statstr(signed int level, const char *fmt, ...);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// sync_aggregate
// file bloom.c line 445
void sync_aggregate(struct anonymous_7 *brq);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// trim
// file utils.c line 186
signed int trim(char **buf);
// try_available
// file msgqueue.c line 530
struct msgqueue_s * try_available(void);
// ts_diff
// file ../include/utils.h line 51
signed int ts_diff(struct timespec *diff, struct timespec *t1, struct timespec *t2);
// ts_sum
// file ../include/utils.h line 50
signed int ts_sum(struct timespec *sum, struct timespec *t1, struct timespec *t2);
// tstotv
// file utils.c line 263
void tstotv(struct timespec *ts, struct timeval *tv);
// tvtots
// file utils.c line 256
void tvtots(struct timeval *tv, struct timespec *ts);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// walk_mmap_info
// file srvutils.c line 162
signed int walk_mmap_info(void);
// walk_queue
// file msgqueue.c line 709
signed int walk_queue(signed int msgid, signed int (*callback)(void *));
// walk_queue::callback_object
//
signed int callback_object(void *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writeline
// file utils.c line 143
signed long int writeline(signed int fd, const char *line);
// writen
// file utils.c line 96
signed long int writen(signed int fd, const void *vptr, unsigned long int n);
// writet
// file utils.c line 121
signed long int writet(signed int fd, const char *line, const char *terminator);
// zero_bloom_filter
// file ../include/bloom.h line 109
void zero_bloom_filter(struct anonymous_4 *filter);
// zero_bloom_ring_queue
// file bloom.c line 395
void zero_bloom_ring_queue(struct anonymous_7 *brq);

struct anonymous_6
{
  // filter_group
  struct anonymous_4 **filter_group;
  // group_size
  unsigned int group_size;
};

struct anonymous_7
{
  // group
  struct anonymous_6 *group;
  // aggregate
  struct anonymous_4 *aggregate;
  // current_index
  unsigned int current_index;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct peer_s
{
  // peer_addr
  struct sockaddr_in peer_addr;
  // peer_in_mutex
  union anonymous_3 peer_in_mutex;
  // peerfd_in
  signed int peerfd_in;
  // peerfd_out
  signed int peerfd_out;
  // connected
  signed int connected;
};

struct postfix_config_s
{
  // responsegrey
  char *responsegrey;
  // responseblock
  char *responseblock;
};

struct sjsms_config_s
{
  // responsegrey
  char *responsegrey;
  // responsematch
  char *responsematch;
  // responsetrust
  char *responsetrust;
  // responseblock
  char *responseblock;
};

struct blocker_config_s
{
  // server
  struct sockaddr_in server;
  // weight
  signed int weight;
};

struct anonymous_16
{
  // gross_host
  struct sockaddr_in gross_host;
  // sync_host
  struct sockaddr_in sync_host;
  // status_host
  struct sockaddr_in status_host;
  // peer
  struct peer_s peer;
  // max_connq
  signed int max_connq;
  // rotate_interval
  signed long int rotate_interval;
  // stat_interval
  signed long int stat_interval;
  // filter_size
  unsigned int filter_size;
  // num_bufs
  unsigned int num_bufs;
  // statefile
  char *statefile;
  // loglevel
  signed int loglevel;
  // syslogfacility
  signed int syslogfacility;
  // statlevel
  signed int statlevel;
  // flags
  signed int flags;
  // checks
  signed int checks;
  // grey_mask
  signed int grey_mask;
  // protocols
  signed int protocols;
  // greylist_delay
  signed int greylist_delay;
  // postfix
  struct postfix_config_s postfix;
  // sjsms
  struct sjsms_config_s sjsms;
  // blocker
  struct blocker_config_s blocker;
  // query_timelimit
  signed int query_timelimit;
  // grey_threshold
  signed int grey_threshold;
  // block_threshold
  signed int block_threshold;
  // pool_maxthreads
  signed int pool_maxthreads;
  // grey_reason
  char *grey_reason;
  // block_reason
  char *block_reason;
  // pidfile
  char *pidfile;
};

struct anonymous_5
{
  // thread
  unsigned long int *thread;
};

struct anonymous_8
{
  // bloommgr
  struct anonymous_5 bloommgr;
  // syncmgr
  struct anonymous_5 syncmgr;
  // postfix_server
  struct anonymous_5 postfix_server;
  // sjsms_server
  struct anonymous_5 sjsms_server;
  // milter_server
  struct anonymous_5 milter_server;
};

struct anonymous_15
{
  // startup
  signed long int startup;
  // begin
  signed long int begin;
  // end
  signed long int end;
  // mx
  union anonymous_3 mx;
  // block
  unsigned long int block;
  // greylist
  unsigned long int greylist;
  // match
  unsigned long int match;
  // trust
  unsigned long int trust;
  // all_block
  unsigned long int all_block;
  // all_greylist
  unsigned long int all_greylist;
  // all_match
  unsigned long int all_match;
  // all_trust
  unsigned long int all_trust;
  // block_avg_delay
  double block_avg_delay;
  // greylist_avg_delay
  double greylist_avg_delay;
  // match_avg_delay
  double match_avg_delay;
  // trust_avg_delay
  double trust_avg_delay;
  // block_max_delay
  double block_max_delay;
  // greylist_max_delay
  double greylist_max_delay;
  // match_max_delay
  double match_max_delay;
  // trust_max_delay
  double trust_max_delay;
  // dnsbl_match
  struct dnsbl_stat *dnsbl_match;
};

struct anonymous_12
{
  // pool
  struct thread_pool_s *pool;
  // definitive
  signed int definitive;
  // name
  char *name;
  // init_routine
  void (*init_routine)(void *, struct anonymous_11 *);
  // check_arg
  void *check_arg;
};

struct anonymous_17
{
  // filter
  struct anonymous_7 *filter;
  // update_q
  signed int update_q;
  // sync_guard
  union anonymous_13 *sync_guard;
  // bloom_guard
  union anonymous_3 bloom_guard;
  // update_guard
  union anonymous_3 update_guard;
  // last_rotate
  signed long int *last_rotate;
  // dnsbl
  struct dnsbl_s *dnsbl;
  // dnswl
  struct dnsbl_s *dnswl;
  // rhsbl
  struct dnsbl_s *rhsbl;
  // config
  struct anonymous_16 config;
  // mmap_info
  struct anonymous_14 *mmap_info;
  // statefile_info
  struct statefile_info_s *statefile_info;
  // process_parts
  struct anonymous_8 process_parts;
  // stats
  struct anonymous_15 stats;
  // checklist
  struct anonymous_12 *checklist[128l];
  // syslog_open
  signed int syslog_open;
};

struct anonymous_1
{
  // inq
  struct msgqueue_s *inq;
  // outq
  struct msgqueue_s *outq;
};

struct anonymous_4
{
  // filter
  unsigned int *filter;
  // bitsize
  unsigned int bitsize;
  // mask
  unsigned int mask;
  // size
  unsigned int size;
};

struct anonymous_14
{
  // magic
  char magic[8l];
  // brq
  struct anonymous_7 *brq;
  // lumpsize
  unsigned long int lumpsize;
  // last_rotate
  signed long int last_rotate;
};

struct anonymous_0
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_11
{
  // max_thread
  signed int max_thread;
  // watchdog_time
  signed int watchdog_time;
  // watchdog
  signed int watchdog;
};

struct anonymous_10
{
  // array_index
  unsigned int array_index;
  // intra_index
  unsigned int intra_index;
};

struct anonymous_9
{
  // h0
  unsigned int h0;
  // h1
  unsigned int h1;
  // h2
  unsigned int h2;
  // h3
  unsigned int h3;
  // h4
  unsigned int h4;
  // h5
  unsigned int h5;
  // h6
  unsigned int h6;
  // h7
  unsigned int h7;
};

union anonymous_13
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // __data
  struct anonymous_0 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct dnsbl_s
{
  // name
  const char *name;
  // weight
  signed int weight;
  // tolerancecounter
  signed int tolerancecounter;
  // next
  struct dnsbl_s *next;
};

struct dnsbl_stat
{
  // dnsbl_name
  char *dnsbl_name;
  // matches_startup
  unsigned long int matches_startup;
  // next
  struct dnsbl_stat *next;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct msg_s
{
  // msgp
  void *msgp;
  // msgsz
  unsigned long int msgsz;
  // next
  struct msg_s *next;
  // timestamp
  struct timespec timestamp;
};

struct msgqueue_s
{
  // cv
  union anonymous_2 cv;
  // mx
  union anonymous_3 mx;
  // head
  struct msg_s *head;
  // tail
  struct msg_s *tail;
  // msgcount
  signed int msgcount;
  // delaypair
  struct msgqueue_s *delaypair;
  // delay_ts
  struct timespec *delay_ts;
  // impose_delay
  signed int *impose_delay;
  // active
  signed int active;
  // id
  signed int id;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct queuepair_s
{
  // inq
  signed int inq;
  // outq
  signed int outq;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statefile_info_s
{
  // fd
  signed int fd;
};

struct test_message_s
{
  // mtype
  signed long int mtype;
  // counter
  signed int *counter;
};

struct thread_pool_s
{
  // work_queue_id
  signed int work_queue_id;
  // name
  const char *name;
  // arg
  void *arg;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// BITARRAY_BASE_SIZE
// file bloom.c line 24
unsigned int BITARRAY_BASE_SIZE = (unsigned int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)8);
// ctx
// file srvutils.c line 29
struct anonymous_17 *ctx;
// global_queue_lk
// file msgqueue.c line 53
union anonymous_3 global_queue_lk = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// initialized
// file msgqueue.c line 51
signed int initialized = 0;
// metaqueue
// file msgqueue.c line 48
struct msgqueue_s *metaqueue;
// numqueues
// file msgqueue.c line 50
signed int numqueues = 0;
// queues
// file msgqueue.c line 47
struct msgqueue_s **queues;
// queuespace
// file msgqueue.c line 49
signed int queuespace = 1;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// Malloc
// file ../include/srvutils.h line 113
void * Malloc(unsigned long int size)
{
  void *chunk;
  /* assertion size */
  assert(size != 0ul);
  chunk=malloc(size);
  if(chunk == NULL)
    daemon_fatal("malloc");

  return chunk;
}

// add_filter
// file bloom.c line 309
struct anonymous_4 * add_filter(struct anonymous_4 *lvalue, const struct anonymous_4 *rvalue)
{
  signed int i;
  /* assertion lvalue */
  assert(lvalue != ((struct anonymous_4 *)NULL));
  /* assertion rvalue */
  assert(rvalue != ((const struct anonymous_4 *)NULL));
  /* assertion lvalue->size == rvalue->size */
  assert(lvalue->size == rvalue->size);
  /* assertion lvalue->mask == rvalue->mask */
  assert(lvalue->mask == rvalue->mask);
  i = 0;
  for( ; !((unsigned int)i >= lvalue->size); i = i + 1)
    lvalue->filter[(signed long int)i] = lvalue->filter[(signed long int)i] | rvalue->filter[(signed long int)i];
  return lvalue;
}

// add_mask
// file bloom.c line 92
unsigned int add_mask(unsigned int intra_index)
{
  /* assertion intra_index <= 32 */
  assert(intra_index <= (unsigned int)32);
  return (unsigned int)(1 << intra_index);
}

// advance_bloom_ring_queue
// file bloom.c line 366
struct anonymous_7 * advance_bloom_ring_queue(struct anonymous_7 *brq)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  brq->current_index=bloom_ring_queue_next_index(brq);
  return brq;
}

// array_index
// file bloom.c line 27
struct anonymous_10 array_index(unsigned int bit_index)
{
  struct anonymous_10 index;
  index.array_index = bit_index / BITARRAY_BASE_SIZE;
  index.intra_index = bit_index % BITARRAY_BASE_SIZE;
  return index;
}

// bloom_error_rate
// file bloom.c line 278
double bloom_error_rate(unsigned int n, unsigned int k, unsigned int m)
{
  double return_value_exp_1;
  return_value_exp_1=exp(-((double)n * (double)k) / (double)m);
  return 1.0 - return_value_exp_1 * (double)k;
}

// bloom_required_size
// file bloom.c line 284
unsigned int bloom_required_size(double c, unsigned int k, unsigned int n)
{
  double return_value_pow_1;
  return_value_pow_1=pow(c, 1.0 / (double)k);
  double return_value_log_2;
  return_value_log_2=log(1.0 - return_value_pow_1);
  return (unsigned int)((-((double)k) * (double)n) / return_value_log_2);
}

// bloom_ring_queue_next_index
// file bloom.c line 356
unsigned int bloom_ring_queue_next_index(struct anonymous_7 *brq)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  if(1u + brq->current_index >= brq->group->group_size)
    return (unsigned int)0;

  else
    return brq->current_index + (unsigned int)1;
}

// build_bloom_ring
// file srvutils.c line 224
struct anonymous_7 * build_bloom_ring(unsigned int num, unsigned int num_bits)
{
  struct anonymous_7 *brq;
  char *ptr;
  signed int i;
  signed int ret;
  unsigned long int lumpsize;
  struct stat statbuf;
  char *magic = "mmbrq2\n";
  signed int use_mmap = 0;
  /* assertion num_bits > 3 */
  assert(num_bits > (unsigned int)3);
  lumpsize = sizeof(struct anonymous_7) /*24ul*/  + sizeof(struct anonymous_6) /*16ul*/  + (unsigned long int)num * sizeof(struct anonymous_4 *) /*8ul*/  + (unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_4) /*24ul*/  + (unsigned long int)((num + (unsigned int)1) * ((unsigned int)(1 << num_bits) / (unsigned int)8));
  if(!(ctx->config.statefile == ((char *)NULL)))
    use_mmap = 1;

  if(!(use_mmap == 0))
  {
    if(!(ctx->statefile_info == ((struct statefile_info_s *)NULL)))
      daemon_shutdown(2, "statefile already open");

    lumpsize = lumpsize + sizeof(struct anonymous_14) /*32ul*/ ;
    ret=stat(ctx->config.statefile, &statbuf);
    if(!(ret >= 0))
      daemon_fatal("stat(): statefile opening failed");

    else
      if(!((unsigned long int)statbuf.st_size == lumpsize))
      {
        printf("statefile size (%d) differs from the calculated size (%d)\n", (signed int)statbuf.st_size, lumpsize);
        daemon_shutdown(2, "statefile size differs from the calculated size");
      }

    void *return_value_Malloc_1;
    return_value_Malloc_1=Malloc(sizeof(struct statefile_info_s) /*4ul*/ );
    ctx->statefile_info = (struct statefile_info_s *)return_value_Malloc_1;
    ctx->statefile_info->fd=open(ctx->config.statefile, 02);
    if(!(ctx->statefile_info->fd >= 0))
      daemon_fatal("open() statefile:");

    void *return_value_mmap_2;
    return_value_mmap_2=mmap((void *)0, lumpsize, 0x1 | 0x2, 0x01, ctx->statefile_info->fd, (signed long int)0);
    ptr = (char *)return_value_mmap_2;
    /* assertion ptr */
    assert(ptr != ((char *)NULL));
    ctx->mmap_info = (struct anonymous_14 *)ptr;
    ctx->last_rotate = &ctx->mmap_info->last_rotate;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(magic);
    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp(ctx->mmap_info->magic, magic, return_value_strlen_3);
    if(return_value_strncmp_4 == 0)
    {
      logstr(65543, "Found the correct state file magic string.");
      ctx->mmap_info->brq = (struct anonymous_7 *)&ctx->mmap_info[(signed long int)1];
      walk_mmap_info();
      return ctx->mmap_info->brq;
    }

    logstr(65543, "Unable to find the state file magic string. Initializing.");
    strncpy(ctx->mmap_info->magic, magic, (unsigned long int)8);
    ctx->mmap_info->last_rotate=time((signed long int *)(void *)0);
    ptr = ptr + (signed long int)sizeof(struct anonymous_14) /*32ul*/ ;
  }

  else
  {
    void *return_value_Malloc_5;
    return_value_Malloc_5=Malloc(lumpsize);
    ptr = (char *)return_value_Malloc_5;
  }
  brq = (struct anonymous_7 *)ptr;
  if(!(use_mmap == 0))
    ctx->mmap_info->brq = brq;

  brq->current_index = (unsigned int)0;
  ptr = ptr + (signed long int)sizeof(struct anonymous_7) /*24ul*/ ;
  brq->group = (struct anonymous_6 *)ptr;
  brq->group->group_size = num;
  ptr = ptr + (signed long int)sizeof(struct anonymous_6) /*16ul*/ ;
  brq->group->filter_group = (struct anonymous_4 **)ptr;
  ptr = ptr + (signed long int)((unsigned long int)num * sizeof(struct anonymous_4 *) /*8ul*/ );
  brq->aggregate = (struct anonymous_4 *)ptr;
  brq->aggregate->bitsize = (unsigned int)(1 << num_bits);
  brq->aggregate->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
  brq->aggregate->size = brq->aggregate->bitsize / BITARRAY_BASE_SIZE;
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
  {
    brq->group->filter_group[(signed long int)i] = (struct anonymous_4 *)(ptr + (signed long int)(sizeof(struct anonymous_4) /*24ul*/  * (unsigned long int)(i + 1)));
    brq->group->filter_group[(signed long int)i]->bitsize = (unsigned int)(1 << num_bits);
    brq->group->filter_group[(signed long int)i]->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
    brq->group->filter_group[(signed long int)i]->size = brq->group->filter_group[(signed long int)i]->bitsize / BITARRAY_BASE_SIZE;
  }
  ptr = ptr + (signed long int)((unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_4) /*24ul*/ );
  brq->aggregate->filter = (unsigned int *)ptr;
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
    brq->group->filter_group[(signed long int)i]->filter = (unsigned int *)(ptr + (signed long int)((unsigned long int)(i + 1) * sizeof(unsigned int) /*4ul*/  * (unsigned long int)brq->group->filter_group[(signed long int)i]->size));
  zero_bloom_filter(brq->aggregate);
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
    zero_bloom_filter(brq->group->filter_group[(signed long int)i]);
  if(!(use_mmap == 0))
  {
    ret=msync((void *)ctx->mmap_info, lumpsize, 4);
    if(!(ret >= 0))
      daemon_fatal("msync");

  }

  return brq;
}

// check_pidfile
// file srvutils.c line 421
void check_pidfile(void)
{
  signed int ret;
  struct stat statinfo;
  ret=stat(ctx->config.pidfile, &statinfo);
  signed int *return_value___errno_location_1;
  if(!(ret >= 0))
  {
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      daemon_fatal("stat");

    else
      goto __CPROVER_DUMP_L5;
  }

  else
    daemon_shutdown(3, "pidfile already exists");

__CPROVER_DUMP_L5:
  ;
}

// chomp
// file ../include/utils.h line 48
signed int chomp(char *buffer)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buffer);
  len = (signed int)return_value_strlen_1;
  if(!(len >= 2))
    return -1;

  else
  {
    if((signed int)buffer[(signed long int)(len + -1)] == 10)
      buffer[(signed long int)(len - 1)] = (char)0;

    if((signed int)buffer[(signed long int)(len + -2)] == 13)
      buffer[(signed long int)(len - 2)] = (char)0;

    return 0;
  }
}

// connected
// file srvutils.c line 145
signed int connected(struct peer_s *peer)
{
  return peer->connected;
}

// copy_bloom_filter
// file bloom.c line 218
struct anonymous_4 * copy_bloom_filter(struct anonymous_4 *filter, signed int empty)
{
  struct anonymous_4 *tmp;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_4) /*24ul*/ );
  tmp = (struct anonymous_4 *)return_value_Malloc_1;
  /* assertion tmp */
  assert(tmp != ((struct anonymous_4 *)NULL));
  tmp->bitsize = filter->bitsize;
  tmp->mask = filter->mask;
  tmp->size = filter->size;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc((unsigned long int)(tmp->bitsize / (unsigned int)8));
  tmp->filter = (unsigned int *)return_value_Malloc_2;
  /* assertion tmp->filter */
  assert(tmp->filter != ((unsigned int *)NULL));
  if(!(empty == 0))
    zero_bloom_filter(tmp);

  else
    memcpy((void *)tmp->filter, (const void *)filter->filter, (unsigned long int)(tmp->bitsize / (unsigned int)8));
  return tmp;
}

// create_bloom_filter
// file bloom.c line 179
struct anonymous_4 * create_bloom_filter(unsigned int num_bits)
{
  struct anonymous_4 *result;
  /* assertion num_bits < sizeof(num_bits) * ((uint32_t)8) */
  assert((unsigned long int)num_bits < sizeof(unsigned int) /*4ul*/  * (unsigned long int)(unsigned int)8);
  /* assertion num_bits >= 4 */
  assert(num_bits >= (unsigned int)4);
  /* assertion num_bits <= 32 */
  assert(num_bits <= (unsigned int)32);
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_4) /*24ul*/ );
  result = (struct anonymous_4 *)return_value_Malloc_1;
  /* assertion result */
  assert(result != ((struct anonymous_4 *)NULL));
  result->bitsize = (unsigned int)(1 << num_bits);
  result->mask = (unsigned int)-1 >> BITARRAY_BASE_SIZE - num_bits;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc((unsigned long int)(result->bitsize / (unsigned int)8));
  result->filter = (unsigned int *)return_value_Malloc_2;
  result->size = result->bitsize / BITARRAY_BASE_SIZE;
  zero_bloom_filter(result);
  return result;
}

// create_bloom_filter_group
// file bloom.c line 241
struct anonymous_6 * create_bloom_filter_group(unsigned int num, unsigned int num_bits)
{
  struct anonymous_6 *result;
  unsigned int i;
  /* assertion num > 0 */
  assert(num > (unsigned int)0);
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_6) /*16ul*/ );
  result = (struct anonymous_6 *)return_value_Malloc_1;
  result->group_size = num;
  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(struct anonymous_6 *) /*8ul*/  * (unsigned long int)num);
  result->filter_group = (struct anonymous_4 **)return_value_Malloc_2;
  /* assertion result->filter_group */
  assert(result->filter_group != ((struct anonymous_4 **)NULL));
  i = (unsigned int)0;
  for( ; !(i >= result->group_size); i = i + 1u)
  {
    result->filter_group[(signed long int)i]=create_bloom_filter(num_bits);
    /* assertion result->filter_group[i] */
    assert(result->filter_group[(signed long int)i] != ((struct anonymous_4 *)NULL));
  }
  return result;
}

// create_bloom_ring_queue
// file bloom.c line 327
struct anonymous_7 * create_bloom_ring_queue(unsigned int num, unsigned int num_bits)
{
  struct anonymous_7 *result;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_7) /*24ul*/ );
  result = (struct anonymous_7 *)return_value_Malloc_1;
  result->group=create_bloom_filter_group(num, num_bits);
  result->current_index = (unsigned int)0;
  result->aggregate=create_bloom_filter(num_bits);
  return result;
}

// create_pidfile
// file srvutils.c line 399
void create_pidfile(void)
{
  struct _IO_FILE *pf;
  signed int ret;
  /* assertion ctx->config.pidfile */
  assert(ctx->config.pidfile != ((char *)NULL));
  logstr(65542, "creating pidfile %s", ctx->config.pidfile);
  pf=fopen(ctx->config.pidfile, "w");
  if(!(pf == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    ret=fprintf(pf, "%d", return_value_getpid_1);
    if(!(ret >= 0))
      daemon_fatal("writing pidfile");

  }

  else
    daemon_fatal("opening pidfile: fdopen");
  fclose(pf);
}

// create_queue
// file msgqueue.c line 187
struct msgqueue_s * create_queue(void)
{
  struct msgqueue_s *mq;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msgqueue_s) /*144ul*/ );
  mq = (struct msgqueue_s *)return_value_Malloc_1;
  memset((void *)mq, 0, sizeof(struct msgqueue_s) /*144ul*/ );
  pthread_cond_init(&mq->cv, (const union anonymous *)(void *)0);
  pthread_mutex_init(&mq->mx, (const union anonymous *)(void *)0);
  return mq;
}

// create_statefile
// file srvutils.c line 186
void create_statefile(void)
{
  signed int ret;
  unsigned long int lumpsize;
  signed int i;
  struct stat statbuf;
  struct _IO_FILE *statefile;
  unsigned int num = ctx->config.num_bufs;
  unsigned int num_bits = ctx->config.filter_size;
  lumpsize = sizeof(struct anonymous_7) /*24ul*/  + sizeof(struct anonymous_6) /*16ul*/  + (unsigned long int)num * sizeof(struct anonymous_4 *) /*8ul*/  + (unsigned long int)(num + (unsigned int)1) * sizeof(struct anonymous_4) /*24ul*/  + (unsigned long int)((num + (unsigned int)1) * ((unsigned int)(1 << num_bits) / (unsigned int)8)) + sizeof(struct anonymous_14) /*32ul*/ ;
  ret=stat(ctx->config.statefile, &statbuf);
  signed int *return_value___errno_location_2;
  signed int return_value_fputc_1;
  if(ret == 0)
    daemon_shutdown(2, "statefile already exists");

  else
  {
    return_value___errno_location_2=__errno_location();
    if(*return_value___errno_location_2 == 2)
    {
      statefile=fopen(ctx->config.statefile, "w");
      if(statefile == ((struct _IO_FILE *)NULL))
        daemon_fatal("stat(): statefile creation failed");

      i = 0;
      for( ; !((unsigned long int)i >= lumpsize); i = i + 1)
      {
        return_value_fputc_1=fputc(0, statefile);
        if(!(return_value_fputc_1 == 0))
          daemon_fatal("fputc()");

      }
      fclose(statefile);
      goto __CPROVER_DUMP_L8;
    }

    else
      daemon_fatal("statefile opening failed: stat:");
  }

__CPROVER_DUMP_L8:
  ;
}

// create_thread
// file ../include/srvutils.h line 114
void * create_thread(struct anonymous_5 *tinfo, signed int detach, void * (*routine)(void *), void *arg)
{
  unsigned long int *tid;
  union pthread_attr_t tattr;
  signed int ret;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(unsigned long int) /*8ul*/ );
  tid = (unsigned long int *)return_value_Malloc_1;
  ret=pthread_attr_init(&tattr);
  if(!(ret == 0))
    daemon_fatal("pthread_attr_init");

  if(detach == 1)
  {
    ret=pthread_attr_setdetachstate(&tattr, 1);
    if(!(ret == 0))
      daemon_fatal("pthread_attr_setdetachstate");

  }

  ret=pthread_attr_setstacksize(&tattr, (unsigned long int)(1024 * 1024));
  if(!(ret == 0))
    daemon_fatal("pthread_attr_setstacksize");

  ret=pthread_create(tid, &tattr, routine, arg);
  if(!(ret == 0))
    daemon_fatal("pthread_create");

  if(!(tinfo == ((struct anonymous_5 *)NULL)))
    tinfo->thread = tid;

  else
  {
    /* assertion tid */
    assert(tid != ((unsigned long int *)NULL));
    free((void *)tid);
    tid = (unsigned long int *)(void *)0;
  }
  pthread_attr_destroy(&tattr);
  return (void *)tid;
}

// daemon_fatal
// file srvutils.c line 124
void daemon_fatal(const char *reason)
{
  char *combo;
  char *errstr;
  signed int errnum;
  unsigned long int combolen;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  errnum = *return_value___errno_location_1;
  errstr=strerror(errnum);
  /* assertion errstr */
  assert(errstr != ((char *)NULL));
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(reason);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(errstr);
  combolen = return_value_strlen_2 + (unsigned long int)1 + return_value_strlen_3 + (unsigned long int)1;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(combolen);
  combo = (char *)return_value_malloc_4;
  /* assertion combo */
  assert(combo != ((char *)NULL));
  snprintf(combo, combolen, "%s %s\n", reason, errstr);
  daemon_shutdown(2, combo);
}

// daemon_shutdown
// file srvutils.c line 97
void daemon_shutdown(signed int return_code, const char *fmt, ...)
{
  char logfmt[1024l];
  char out[1024l];
  void **vap;
  if(!(fmt == ((const char *)NULL)))
  {
    snprintf(logfmt, (unsigned long int)1024, "Grossd shutdown with exit code %d: %s", return_code, fmt);
    vap = (void **)&fmt;
    vsnprintf(out, (unsigned long int)1024, logfmt, vap);
    vap = ((void **)NULL);
    fprintf(stderr, "%s\n", (const void *)out);
    if(!(ctx->syslog_open == 0))
      logstr(65539, "%s", (const void *)out);

  }

  if(return_code == 0)
  {
    if(!((0x80 & ctx->config.flags) == 0))
    {
      if(!(ctx->config.pidfile == ((char *)NULL)))
        unlink(ctx->config.pidfile);

    }

  }

  exit(return_code);
}

// daemonize
// file srvutils.c line 440
void daemonize(void)
{
  signed int i;
  signed int pid;
  log_close();
  pid=fork();
  if(pid >= 1)
  {
    log_open();
    exit(0);
  }

  else
    if(!(pid >= 0))
    {
      log_open();
      daemon_fatal("fork(): ");
    }

  pid=setsid();
  if(!(pid >= 0))
  {
    log_open();
    daemon_fatal("setsid(): ");
  }

  pid=fork();
  if(pid >= 1)
  {
    log_open();
    exit(0);
  }

  else
    if(!(pid >= 0))
    {
      log_open();
      daemon_fatal("fork: ");
    }

  close(0);
  open("/dev/null", 00, 0);
  close(1);
  open("/dev/null", 01, 0);
  close(2);
  open("/dev/null", 01, 0);
  i = 3;
  for( ; !(i >= 64); i = i + 1)
    close(i);
  log_open();
}

// date_fmt
// file srvutils.c line 552
unsigned long int date_fmt(char *msg, unsigned long int len)
{
  signed long int tt;
  char timestr[26l];
  char buf[1024l];
  tt=time((signed long int *)(void *)0);
  ctime_r(&tt, timestr);
  chomp(timestr);
  snprintf(buf, (unsigned long int)(1024 - 1), "%s %s\n", (const void *)timestr, msg);
  strncpy(msg, buf, len - (unsigned long int)1);
  msg[(signed long int)(len - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(msg);
  return return_value_strlen_1;
}

// debug_print_array_index
// file bloom.c line 69
void debug_print_array_index(struct anonymous_10 index, signed int with_newline)
{
  printf("array index=%d intra index=%d", index.array_index, index.intra_index);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_bit_up
// file bloom.c line 77
void debug_print_bit_up(unsigned int *array, unsigned int bit_index, signed int with_newline)
{
  struct anonymous_10 index;
  index=array_index(bit_index);
  unsigned int bit;
  bit=get_bit(array, bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  printf("bit %d at (", bit_index);
  debug_print_array_index(index, 0);
  printf(") is %d", bit);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_bits
// file bloom.c line 53
void debug_print_bits(signed int value, signed int with_newline)
{
  signed int i = 31;
  for( ; i >= 0; i = i - 1)
    if(!((value >> i & 0x01) == 0))
      printf("1");

    else
      printf("0");
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_filter
// file bloom.c line 38
void debug_print_filter(struct anonymous_4 *filter, signed int with_newline)
{
  signed int i;
  /* assertion filter */
  assert(filter != ((struct anonymous_4 *)NULL));
  i = 0;
  for( ; !((unsigned int)i >= filter->size); i = i + 1)
    debug_print_bits((signed int)filter->filter[(signed long int)i], 0);
  if(!(with_newline == 0))
    printf("\n");

}

// debug_print_ring_queue
// file bloom.c line 409
void debug_print_ring_queue(struct anonymous_7 *brq, signed int with_newline)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  printf("Aggregate: ");
  debug_print_filter(brq->aggregate, 1);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
  {
    printf("Filter %d: ", i);
    debug_print_filter(brq->group->filter_group[(signed long int)i], 1);
  }
  if(!(with_newline == 0))
    printf("\n");

}

// delay
// file msgqueue.c line 142
void * delay(void *arg)
{
  struct anonymous_1 *queue_info;
  struct msg_s *msg;
  struct timespec sleeptime;
  struct timespec reftime;
  struct timespec sleepleft;
  struct timespec now;
  struct timespec *msgtimestamp;
  signed int ret;
  logstr(65543, "delay queue manager thread starting");
  queue_info = (struct anonymous_1 *)arg;
  _Bool tmp_if_expr_1;
  do
  {
    logstr(65544, "waiting for messages");
    msgtimestamp=peek_msg_timestamp(queue_info->inq);
    if(!(msgtimestamp == ((struct timespec *)NULL)))
    {
      if(!(*queue_info->inq->impose_delay == 0))
      {
        if(!(queue_info->inq->delay_ts == ((struct timespec *)NULL)))
        {
          if(!(queue_info->inq->delay_ts->tv_sec == 0l))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = queue_info->inq->delay_ts->tv_nsec != 0l ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
          {
            clock_gettime(1, &now);
            ts_sum(&reftime, msgtimestamp, queue_info->inq->delay_ts);
            ret=ts_diff(&sleeptime, &reftime, &now);
            if(ret == 0)
              do
              {
                logstr(65544, "reftime in future, sleeping for %d.%d seconds", sleeptime.tv_sec, sleeptime.tv_nsec);
                ret=nanosleep(&sleeptime, &sleepleft);
                if(!(ret == 0))
                {
                  sleeptime.tv_sec = sleepleft.tv_sec;
                  sleeptime.tv_nsec = sleepleft.tv_nsec;
                }

              }
              while(!(ret == 0));

          }

        }

      }

    }

    msg=get_msg_raw(queue_info->inq, 0);
    /* assertion msg->next == ((void *)0) */
    assert(msg->next == (struct msg_s *)(void *)0);
    logstr(65544, "passing message from inq to outq");
    put_msg_raw(queue_info->outq, msg);
  }
  while((_Bool)1);
}

// disable_delay
// file msgqueue.c line 253
signed int disable_delay(signed int msqid)
{
  signed int return_value_set_delay_status_1;
  return_value_set_delay_status_1=set_delay_status(msqid, 0);
  return return_value_set_delay_status_1;
}

// enable_delay
// file msgqueue.c line 259
signed int enable_delay(signed int msqid)
{
  signed int return_value_set_delay_status_1;
  return_value_set_delay_status_1=set_delay_status(msqid, 1);
  return return_value_set_delay_status_1;
}

// get_bit
// file bloom.c line 99
unsigned int get_bit(unsigned int *array, unsigned int bit_index)
{
  struct anonymous_10 index;
  index=array_index(bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  /* assertion index.intra_index <= 32 */
  assert(index.intra_index <= (unsigned int)32);
  return array[(signed long int)index.array_index] >> index.intra_index & (unsigned int)1;
}

// get_delay_queue
// file msgqueue.c line 104
signed int get_delay_queue(struct timespec *ts)
{
  signed int putqid;
  signed int getqid;
  struct anonymous_1 *queue_info;
  signed int *impose_delay;
  if(ts == ((struct timespec *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  void *return_value_Malloc_2;
  return_value_Malloc_2=Malloc(sizeof(struct anonymous_1) /*16ul*/ );
  queue_info = (struct anonymous_1 *)return_value_Malloc_2;
  putqid=get_queue();
  getqid=get_queue();
  void *return_value_Malloc_3;
  return_value_Malloc_3=Malloc(sizeof(signed int) /*4ul*/ );
  impose_delay = (signed int *)return_value_Malloc_3;
  *impose_delay = 1;
  queue_info->inq=queuebyid(putqid);
  /* assertion queue_info->inq != ((void *)0) */
  assert(queue_info->inq != (struct msgqueue_s *)(void *)0);
  queue_info->inq->delay_ts = ts;
  queue_info->inq->impose_delay = impose_delay;
  queue_info->outq=queuebyid(getqid);
  /* assertion queue_info->outq != ((void *)0) */
  assert(queue_info->outq != (struct msgqueue_s *)(void *)0);
  queue_info->outq->delay_ts = ts;
  queue_info->outq->impose_delay = impose_delay;
  queue_info->inq->delaypair = queue_info->outq;
  queue_info->outq->delaypair = queue_info->inq;
  create_thread((struct anonymous_5 *)(void *)0, 1, delay, (void *)queue_info);
  return putqid;
}

// get_msg
// file msgqueue.c line 645
unsigned long int get_msg(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag)
{
  unsigned long int return_value_get_msg_timed_1;
  return_value_get_msg_timed_1=get_msg_timed(msqid, msgp, maxsize, msgflag, 0);
  return return_value_get_msg_timed_1;
}

// get_msg_raw
// file msgqueue.c line 582
struct msg_s * get_msg_raw(struct msgqueue_s *mq, signed int timeout)
{
  struct msg_s *msg;
  signed int ret;
  struct timespec to;
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return (struct msg_s *)(void *)0;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    msg = (struct msg_s *)(void *)0;
    mstotimespec(timeout, &to);
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    to.tv_sec = to.tv_sec + return_value_time_1;
    if(timeout >= 0)
      while(mq->head == ((struct msg_s *)NULL))
        if(timeout == 0)
          ret=pthread_cond_wait(&mq->cv, &mq->mx);

        else
        {
          ret=pthread_cond_timedwait(&mq->cv, &mq->mx, &to);
          if(ret == 110)
            break;

        }

    else
      if(mq->head == ((struct msg_s *)NULL))
        ret = -1;

    if(ret == 0)
    {
      /* assertion mq->head */
      assert(mq->head != ((struct msg_s *)NULL));
      /* assertion mq->tail */
      assert(mq->tail != ((struct msg_s *)NULL));
      msg = mq->head;
      mq->head = msg->next;
      msg->next = (struct msg_s *)(void *)0;
      mq->msgcount = mq->msgcount - 1;
      if(mq->head == ((struct msg_s *)NULL))
      {
        /* assertion mq->tail == msg */
        assert(mq->tail == msg);
        /* assertion mq->msgcount == 0 */
        assert(mq->msgcount == 0);
        mq->tail = (struct msg_s *)(void *)0;
      }

    }

    pthread_mutex_unlock(&mq->mx);
    return msg;
  }
}

// get_msg_timed
// file ../include/msgqueue.h line 60
unsigned long int get_msg_timed(signed int msqid, void *msgp, unsigned long int maxsize, signed int msgflag, signed int timeout)
{
  struct msgqueue_s *mq;
  struct msg_s *msg;
  unsigned long int msglen;
  unsigned long int msgsize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    msg=get_msg_raw(mq->delaypair, timeout);

  else
    msg=get_msg_raw(mq, timeout);
  if(msg == ((struct msg_s *)NULL))
    msglen = (unsigned long int)0;

  else
  {
    msgsize = msg->msgsz - sizeof(signed long int) /*8ul*/ ;
    msglen = maxsize < msgsize ? maxsize : msgsize;
    memcpy(msgp, msg->msgp, msglen + sizeof(signed long int) /*8ul*/ );
    /* assertion msg->msgp */
    assert(msg->msgp != NULL);
    free(msg->msgp);
    msg->msgp = (void *)0;
    /* assertion msg */
    assert(msg != ((struct msg_s *)NULL));
    free((void *)msg);
    msg = (struct msg_s *)(void *)0;
  }
  return msglen;
}

// get_queue
// file ../include/msgqueue.h line 51
signed int get_queue(void)
{
  signed int i;
  struct msgqueue_s *mq;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&global_queue_lk);
  /* assertion pthread_mutex_lock(&global_queue_lk) == 0 */
  assert(return_value_pthread_mutex_lock_1 == 0);
  if(initialized == 0)
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)queuespace, sizeof(struct msgqueue_s *) /*8ul*/ );
    queues = (struct msgqueue_s **)return_value_calloc_2;
    metaqueue=create_queue();
    metaqueue->active = 1;
    initialized = 1;
  }

  mq=try_available();
  if(!(mq == ((struct msgqueue_s *)NULL)))
    i = mq->id;

  else
  {
    i = numqueues;
    numqueues = numqueues + 1;
    mq=create_queue();
    mq->id = i;
    mq->active = 1;
    if(!(queuespace >= numqueues))
      queue_realloc();

    queues[(signed long int)i] = mq;
  }
  pthread_mutex_unlock(&global_queue_lk);
  return i;
}

// in_queue_len
// file msgqueue.c line 683
unsigned long int in_queue_len(signed int msgid)
{
  struct msgqueue_s *mq;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  return (unsigned long int)mq->msgcount;
}

// init_bit_array
// file bloom.c line 121
void init_bit_array(unsigned int *array, unsigned int size)
{
  unsigned int i;
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  i = (unsigned int)0;
  for( ; !(i >= size); i = i + 1u)
    array[(signed long int)i] = (unsigned int)0;
}

// insert_absolute_bloom_ring_queue
// file bloom.c line 427
void insert_absolute_bloom_ring_queue(struct anonymous_7 *brq, unsigned int *buffer, signed int size, signed int index, unsigned int buf_index)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  /* assertion buf_index < brq->group->group_size */
  assert(buf_index < brq->group->group_size);
  if(!(brq->group->filter_group[(signed long int)buf_index]->size >= (unsigned int)size))
    size = (signed int)brq->group->filter_group[(signed long int)buf_index]->size;

  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)size); i = i + 1u)
  {
    /* assertion index + i < brq->group->filter_group[buf_index]->size */
    assert((unsigned int)index + i < brq->group->filter_group[(signed long int)buf_index]->size);
    brq->group->filter_group[(signed long int)buf_index]->filter[(signed long int)((unsigned int)(index * size) + i)] = brq->group->filter_group[(signed long int)buf_index]->filter[(signed long int)((unsigned int)(index * size) + i)] | buffer[(signed long int)i];
  }
}

// insert_bit
// file bloom.c line 110
void insert_bit(unsigned int *array, unsigned int bit_index)
{
  struct anonymous_10 index;
  index=array_index(bit_index);
  /* assertion array */
  assert(array != ((unsigned int *)NULL));
  /* assertion index.intra_index <= 32 */
  assert(index.intra_index <= (unsigned int)32);
  unsigned int return_value_add_mask_1;
  return_value_add_mask_1=add_mask(index.intra_index);
  array[(signed long int)index.array_index] = array[(signed long int)index.array_index] | return_value_add_mask_1;
}

// insert_digest
// file bloom.c line 139
void insert_digest(struct anonymous_4 *filter, struct anonymous_9 digest)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_4 *)NULL));
  unsigned int return_value_int_to_index_1;
  return_value_int_to_index_1=int_to_index(digest.h0, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_1);
  unsigned int return_value_int_to_index_2;
  return_value_int_to_index_2=int_to_index(digest.h1, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_2);
  unsigned int return_value_int_to_index_3;
  return_value_int_to_index_3=int_to_index(digest.h2, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_3);
  unsigned int return_value_int_to_index_4;
  return_value_int_to_index_4=int_to_index(digest.h3, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_4);
  unsigned int return_value_int_to_index_5;
  return_value_int_to_index_5=int_to_index(digest.h4, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_5);
  unsigned int return_value_int_to_index_6;
  return_value_int_to_index_6=int_to_index(digest.h5, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_6);
  unsigned int return_value_int_to_index_7;
  return_value_int_to_index_7=int_to_index(digest.h6, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_7);
  unsigned int return_value_int_to_index_8;
  return_value_int_to_index_8=int_to_index(digest.h7, filter->mask);
  insert_bit(filter->filter, return_value_int_to_index_8);
}

// insert_digest_bloom_ring_queue
// file bloom.c line 341
void insert_digest_bloom_ring_queue(struct anonymous_7 *brq, struct anonymous_9 digest)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  insert_digest(brq->aggregate, digest);
  insert_digest_to_group_member(brq->group, brq->current_index, digest);
}

// insert_digest_to_group_member
// file bloom.c line 169
void insert_digest_to_group_member(struct anonymous_6 *filter_group, unsigned int member_index, struct anonymous_9 digest)
{
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_6 *)NULL));
  /* assertion member_index < filter_group->group_size */
  assert(member_index < filter_group->group_size);
  insert_digest(filter_group->filter_group[(signed long int)member_index], digest);
}

// instant_msg
// file msgqueue.c line 448
signed int instant_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg)
{
  struct msgqueue_s *mq;
  struct msg_s *new;
  void *msgp;
  signed int ret;
  unsigned long int truesize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    mq = mq->delaypair;

  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
  new = (struct msg_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct msg_s) /*40ul*/ );
  clock_gettime(1, &new->timestamp);
  truesize = msgsz + sizeof(signed long int) /*8ul*/ ;
  msgp=Malloc(truesize);
  memcpy(msgp, omsgp, truesize);
  new->msgp = msgp;
  new->msgsz = truesize;
  ret=put_msg_raw(mq, new);
  return ret;
}

// int_to_index
// file bloom.c line 133
unsigned int int_to_index(unsigned int value, unsigned int mask)
{
  return (unsigned int)(value & mask);
}

// ipstr
// file srvutils.c line 589
char * ipstr(struct sockaddr_in *saddr)
{
  char ipstr__1__ipstr[16l];
  const char *return_value_inet_ntop_1;
  return_value_inet_ntop_1=inet_ntop(2, (const void *)&saddr->sin_addr, ipstr__1__ipstr, (unsigned int)16);
  if(return_value_inet_ntop_1 == ((const char *)NULL))
    strncpy(ipstr__1__ipstr, "UNKNOWN\0", (unsigned long int)16);

  char *return_value_strdup_2;
  return_value_strdup_2=strdup(ipstr__1__ipstr);
  return return_value_strdup_2;
}

// is_in_array
// file bloom.c line 154
signed int is_in_array(struct anonymous_4 *filter, struct anonymous_9 digest)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_4 *)NULL));
  unsigned int return_value_int_to_index_1;
  return_value_int_to_index_1=int_to_index(digest.h0, filter->mask);
  unsigned int return_value_get_bit_2;
  return_value_get_bit_2=get_bit(filter->filter, return_value_int_to_index_1);
  _Bool tmp_if_expr_5;
  unsigned int return_value_int_to_index_3;
  unsigned int return_value_get_bit_4;
  if(!(return_value_get_bit_2 == 0u))
  {
    return_value_int_to_index_3=int_to_index(digest.h1, filter->mask);
    return_value_get_bit_4=get_bit(filter->filter, return_value_int_to_index_3);
    tmp_if_expr_5 = return_value_get_bit_4 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_8;
  unsigned int return_value_int_to_index_6;
  unsigned int return_value_get_bit_7;
  if(tmp_if_expr_5)
  {
    return_value_int_to_index_6=int_to_index(digest.h2, filter->mask);
    return_value_get_bit_7=get_bit(filter->filter, return_value_int_to_index_6);
    tmp_if_expr_8 = return_value_get_bit_7 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_8 = (_Bool)0;
  _Bool tmp_if_expr_11;
  unsigned int return_value_int_to_index_9;
  unsigned int return_value_get_bit_10;
  if(tmp_if_expr_8)
  {
    return_value_int_to_index_9=int_to_index(digest.h3, filter->mask);
    return_value_get_bit_10=get_bit(filter->filter, return_value_int_to_index_9);
    tmp_if_expr_11 = return_value_get_bit_10 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  _Bool tmp_if_expr_14;
  unsigned int return_value_int_to_index_12;
  unsigned int return_value_get_bit_13;
  if(tmp_if_expr_11)
  {
    return_value_int_to_index_12=int_to_index(digest.h4, filter->mask);
    return_value_get_bit_13=get_bit(filter->filter, return_value_int_to_index_12);
    tmp_if_expr_14 = return_value_get_bit_13 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_14 = (_Bool)0;
  _Bool tmp_if_expr_17;
  unsigned int return_value_int_to_index_15;
  unsigned int return_value_get_bit_16;
  if(tmp_if_expr_14)
  {
    return_value_int_to_index_15=int_to_index(digest.h5, filter->mask);
    return_value_get_bit_16=get_bit(filter->filter, return_value_int_to_index_15);
    tmp_if_expr_17 = return_value_get_bit_16 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_17 = (_Bool)0;
  _Bool tmp_if_expr_20;
  unsigned int return_value_int_to_index_18;
  unsigned int return_value_get_bit_19;
  if(tmp_if_expr_17)
  {
    return_value_int_to_index_18=int_to_index(digest.h6, filter->mask);
    return_value_get_bit_19=get_bit(filter->filter, return_value_int_to_index_18);
    tmp_if_expr_20 = return_value_get_bit_19 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_20 = (_Bool)0;
  _Bool tmp_if_expr_23;
  unsigned int return_value_int_to_index_21;
  unsigned int return_value_get_bit_22;
  if(tmp_if_expr_20)
  {
    return_value_int_to_index_21=int_to_index(digest.h7, filter->mask);
    return_value_get_bit_22=get_bit(filter->filter, return_value_int_to_index_21);
    tmp_if_expr_23 = return_value_get_bit_22 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_23 = (_Bool)0;
  return (signed int)tmp_if_expr_23;
}

// is_in_ring_queue
// file bloom.c line 349
signed int is_in_ring_queue(struct anonymous_7 *brq, struct anonymous_9 digest)
{
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  signed int return_value_is_in_array_1;
  return_value_is_in_array_1=is_in_array(brq->aggregate, digest);
  return return_value_is_in_array_1;
}

// log_close
// file srvutils.c line 618
signed int log_close(void)
{
  if((33 & ctx->config.flags) == 0x20)
  {
    if(ctx->syslog_open == 0)
      return -1;

    closelog();
    ctx->syslog_open = 0;
  }

  return 0;
}

// log_open
// file srvutils.c line 603
signed int log_open(void)
{
  if((33 & ctx->config.flags) == 0x20)
  {
    if(!(ctx->syslog_open == 0))
      return -1;

    openlog("grossd", 0x04, ctx->config.syslogfacility);
    ctx->syslog_open = 1;
  }

  return 0;
}

// log_put
// file srvutils.c line 538
signed int log_put(const char *msg)
{
  char *final;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc((unsigned long int)1024);
  final = (char *)return_value_Malloc_1;
  snprintf(final, (unsigned long int)(1024 - 1), "%s", msg);
  date_fmt(final, (unsigned long int)1024);
  printf("%s", final);
  /* assertion final */
  assert(final != ((char *)NULL));
  free((void *)final);
  final = (char *)(void *)0;
  fflush(stdout);
  return 0;
}

// logstr
// file ../include/srvutils.h line 102
signed int logstr(signed int level, const char *fmt, ...)
{
  char logfmt[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char mbuf[1024l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  void **vap;
  signed int return_value_log_put_2;
  if(!(ctx->config.loglevel >= level))
    return 0;

  else
  {
    unsigned long int return_value_pthread_self_1;
    return_value_pthread_self_1=pthread_self();
    snprintf(logfmt, (unsigned long int)1024, "#%x: %s", (unsigned int)return_value_pthread_self_1, fmt);
    vap = (void **)&fmt;
    vsnprintf(mbuf, (unsigned long int)1024, logfmt, vap);
    vap = ((void **)NULL);
    if(ctx->syslog_open == 0)
    {
      return_value_log_put_2=log_put(mbuf);
      return return_value_log_put_2;
    }

    else
    {
      if(level >= 65544)
        level = 65543;

      level = level ^ 65536;
      syslog(level, "%s", (const void *)mbuf);
      return 0;
    }
  }
}

// main
// file msgqueue-test.c line 79
signed int main(signed int argc, char **argv)
{
  struct anonymous_5 threads[512l];
  signed int balls[128l];
  signed int main__1__queues[8l];
  struct queuepair_s qpairs[64l];
  struct test_message_s message;
  signed int ret;
  signed int i;
  signed int *exitvalue;
  signed int sum = 0;
  struct anonymous_17 myctx = { .filter=((struct anonymous_7 *)NULL), .update_q=0, .sync_guard=((union anonymous_13 *)NULL),
    .bloom_guard={ .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    .update_guard={ .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    .last_rotate=((signed long int *)NULL),
    .dnsbl=((struct dnsbl_s *)NULL),
    .dnswl=((struct dnsbl_s *)NULL), .rhsbl=((struct dnsbl_s *)NULL),
    .config={ .gross_host={ .sin_family=0, .sin_port=0, .sin_addr={ .s_addr=0u }, .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } }, .sync_host={ .sin_family=0, .sin_port=0, .sin_addr={ .s_addr=0u }, .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } },
    .status_host={ .sin_family=0, .sin_port=0, .sin_addr={ .s_addr=0u }, .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } },
    .peer={ .peer_addr={ .sin_family=0, .sin_port=0, .sin_addr={ .s_addr=0u }, .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } }, .peer_in_mutex={ .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    .peerfd_in=0,
    .peerfd_out=0, .connected=0 },
    .max_connq=0,
    .rotate_interval=0l, .stat_interval=0l, .filter_size=0u,
    .num_bufs=0u, .statefile=((char *)NULL), .loglevel=0,
    .syslogfacility=0, .statlevel=0, .flags=0,
    .checks=0, .grey_mask=0, .protocols=0, .greylist_delay=0,
    .postfix={ .responsegrey=((char *)NULL), .responseblock=((char *)NULL) }, .sjsms={ .responsegrey=((char *)NULL), .responsematch=((char *)NULL), .responsetrust=((char *)NULL),
    .responseblock=((char *)NULL) },
    .blocker={ .server={ .sin_family=0, .sin_port=0, .sin_addr={ .s_addr=0u }, .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } }, .weight=0 },
    .query_timelimit=0,
    .grey_threshold=0, .block_threshold=0,
    .pool_maxthreads=0, .grey_reason=((char *)NULL),
    .block_reason=((char *)NULL), .pidfile=((char *)NULL) }, .mmap_info=((struct anonymous_14 *)NULL),
    .statefile_info=((struct statefile_info_s *)NULL),
    .process_parts={ .bloommgr={ .thread=((unsigned long int *)NULL) }, .syncmgr={ .thread=((unsigned long int *)NULL) },
    .postfix_server={ .thread=((unsigned long int *)NULL) },
    .sjsms_server={ .thread=((unsigned long int *)NULL) },
    .milter_server={ .thread=((unsigned long int *)NULL) } },
    .stats={ .startup=0l, .begin=0l, .end=0l, .mx={ .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .block=0ul,
    .greylist=0ul, .match=0ul, .trust=0ul,
    .all_block=0ul, .all_greylist=0ul, .all_match=0ul,
    .all_trust=0ul, .block_avg_delay=0.000000, .greylist_avg_delay=0.000000,
    .match_avg_delay=0.000000, .trust_avg_delay=0.000000,
    .block_max_delay=0.000000, .greylist_max_delay=0.000000,
    .match_max_delay=0.000000, .trust_max_delay=0.000000,
    .dnsbl_match=((struct dnsbl_stat *)NULL) },
    .checklist={ ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL), ((struct anonymous_12 *)NULL) },
    .syslog_open=0 };
  ctx = &myctx;
  printf("Check: msgqueue\n");
  printf("  Creating %d message queues...", 8);
  fflush(stdout);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    main__1__queues[(signed long int)i]=get_queue();
  printf("  Done.\n");
  printf("  Making %d circular queue pairs...", 8 * 8);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    qpairs[(signed long int)i].inq = main__1__queues[(signed long int)(i % 8)];
    qpairs[(signed long int)i].outq = main__1__queues[(signed long int)((i + 1) % 8)];
  }
  printf("  Done.\n");
  printf("  Creating %d threads to test the message queues...", 8 * 8 * 8);
  fflush(stdout);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    create_thread(&threads[(signed long int)i], 0, msgqueueping, (void *)&qpairs[(signed long int)(i % (8 * 8))]);
  printf("  Done.\n");
  printf("  Sending out %d chain letters...", 16 * 8);
  fflush(stdout);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    balls[(signed long int)i] = 0;
    message.mtype = (signed long int)0;
    message.counter = &balls[(signed long int)i];
    put_msg(main__1__queues[(signed long int)(i % 8)], (void *)&message, sizeof(signed int *) /*8ul*/ , 0);
  }
  printf("  Done.\n");
  printf("  Waiting for the results...");
  fflush(stdout);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    ret=pthread_join(*threads[(signed long int)i].thread, (void **)&exitvalue);
    if(ret == 0)
    {
      if(!(*exitvalue == 0))
      {
        printf(" Thread returned %d (!= 0)\n", *exitvalue);
        return 1;
      }

    }

    else
    {
      perror("pthread_join:");
      return 2;
    }
    /* assertion threads[i].thread */
    assert(threads[(signed long int)i].thread != ((unsigned long int *)NULL));
    free((void *)threads[(signed long int)i].thread);
    threads[(signed long int)i].thread = (unsigned long int *)(void *)0;
    /* assertion exitvalue */
    assert(exitvalue != ((signed int *)NULL));
    free((void *)exitvalue);
    exitvalue = (signed int *)(void *)0;
  }
  printf("  Done.\n");
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    sum = sum + balls[(signed long int)i];
  if(!(sum == 100))
    return 3;

  else
    return 0;
}

// ms_diff
// file utils.c line 206
signed int ms_diff(struct timespec *t1, struct timespec *t2)
{
  return (signed int)((t1->tv_sec - t2->tv_sec) * (signed long int)1000 + (t1->tv_nsec - t2->tv_nsec) / (signed long int)(1000 * 1000));
}

// msgqueueping
// file msgqueue-test.c line 47
static void * msgqueueping(void *arg)
{
  struct queuepair_s *qpair;
  unsigned long int size;
  signed int *ret;
  signed int i;
  signed int tmp;
  struct test_message_s message;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(signed int) /*4ul*/ );
  ret = (signed int *)return_value_Malloc_1;
  *ret = 0;
  qpair = (struct queuepair_s *)arg;
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    size=get_msg_timed(qpair->inq, (void *)&message, sizeof(signed int *) /*8ul*/ , 0, 10000);
    if(size == 0ul)
    {
      printf("  timeout\n");
      break;
    }

    else
    {
      tmp = *message.counter + 1;
      usleep((unsigned int)1000);
      *message.counter = tmp;
      put_msg(qpair->outq, (void *)&message, sizeof(signed int *) /*8ul*/ , 0);
    }
  }

OUT:
  ;
  pthread_exit((void *)ret);
}

// mstotimespec
// file ../include/utils.h line 52
void mstotimespec(signed int mseconds, struct timespec *ts)
{
  ts->tv_sec = (signed long int)(mseconds / 1000);
  signed int return_value_abs_1;
  return_value_abs_1=abs(mseconds % 1000);
  ts->tv_nsec = (signed long int)(return_value_abs_1 * 1000 * 1000);
}

// new_address
// file srvutils.c line 151
void * new_address(void *val1, unsigned long int val2)
{
  return (void *)((unsigned long int)val1 + val2);
}

// optimal_size
// file bloom.c line 292
unsigned int optimal_size(unsigned int n, double c)
{
  unsigned int result;
  unsigned int native_size;
  native_size=bloom_required_size(c, (unsigned int)8, n);
  result = (unsigned int)1;
  for( ; !(result >= BITARRAY_BASE_SIZE); result = result + 1u)
  {
    unsigned int return_value_bloom_required_size_1;
    return_value_bloom_required_size_1=bloom_required_size(c, (unsigned int)8, (unsigned int)(1 << result));
    if(return_value_bloom_required_size_1 >= native_size)
      return result;

  }
  /* assertion 0 */
  assert(0 != 0);
  return (unsigned int)0;
}

// out_queue_len
// file msgqueue.c line 695
unsigned long int out_queue_len(signed int msgid)
{
  struct msgqueue_s *mq;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    return (unsigned long int)mq->delaypair->msgcount;

  else
  {
    unsigned long int return_value_in_queue_len_1;
    return_value_in_queue_len_1=in_queue_len(msgid);
    return return_value_in_queue_len_1;
  }
}

// peek_msg_timestamp
// file msgqueue.c line 550
struct timespec * peek_msg_timestamp(struct msgqueue_s *mq)
{
  struct timespec *timestamp;
  signed int ret;
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return (struct timespec *)(void *)0;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    while(mq->head == ((struct msg_s *)NULL))
      pthread_cond_wait(&mq->cv, &mq->mx);
    /* assertion mq->head */
    assert(mq->head != ((struct msg_s *)NULL));
    /* assertion mq->tail */
    assert(mq->tail != ((struct msg_s *)NULL));
    timestamp = &mq->head->timestamp;
    pthread_mutex_unlock(&mq->mx);
    return timestamp;
  }
}

// put_msg
// file ../include/msgqueue.h line 56
signed int put_msg(signed int msqid, void *omsgp, unsigned long int msgsz, signed int msgflg)
{
  struct msgqueue_s *mq;
  struct msg_s *new;
  void *msgp;
  signed int ret;
  unsigned long int truesize;
  mq=queuebyid(msqid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
  new = (struct msg_s *)return_value_Malloc_1;
  memset((void *)new, 0, sizeof(struct msg_s) /*40ul*/ );
  clock_gettime(1, &new->timestamp);
  truesize = msgsz + sizeof(signed long int) /*8ul*/ ;
  msgp=Malloc(truesize);
  memcpy(msgp, omsgp, truesize);
  new->msgp = msgp;
  new->msgsz = truesize;
  ret=put_msg_raw(mq, new);
  return ret;
}

// put_msg_raw
// file msgqueue.c line 378
signed int put_msg_raw(struct msgqueue_s *mq, struct msg_s *msg)
{
  signed int ret;
  struct msg_s *tail;
  if(mq->active == 0)
  {
    logstr(65539, "message queue is marked inactive");
    return -1;
  }

  else
  {
    ret=pthread_mutex_lock(&mq->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
    if(!(mq->tail == ((struct msg_s *)NULL)))
    {
      /* assertion mq->head */
      assert(mq->head != ((struct msg_s *)NULL));
      tail = mq->tail;
      tail->next = msg;
    }

    else
    {
      /* assertion mq->head == ((void *)0) */
      assert(mq->head == (struct msg_s *)(void *)0);
      mq->head = msg;
    }
    mq->tail = msg;
    /* assertion mq->tail->next == ((void *)0) */
    assert(mq->tail->next == (struct msg_s *)(void *)0);
    mq->msgcount = mq->msgcount + 1;
    pthread_cond_signal(&mq->cv);
    pthread_mutex_unlock(&mq->mx);
    return 0;
  }
}

// queue_freeze
// file msgqueue.c line 321
signed int queue_freeze(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  logstr(65539, "freeze queue %d", msqid);
  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    ret=pthread_mutex_lock(&mq->delaypair->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  return 0;
}

// queue_realloc
// file msgqueue.c line 60
void queue_realloc(void)
{
  unsigned long int queuesize;
  if(queuespace == 0)
    queuespace = 1;

  logstr(65543, "doubling the space for message queues from %d to %d", queuespace, queuespace * 2);
  queuesize = (unsigned long int)queuespace * sizeof(struct msgqueue_s *) /*8ul*/ ;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)queues, queuesize * (unsigned long int)2);
  queues = (struct msgqueue_s **)return_value_realloc_1;
  queuespace = queuespace * 2;
}

// queue_thaw
// file msgqueue.c line 294
signed int queue_thaw(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  logstr(65539, "thaw queue %d", msqid);
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    ret=pthread_mutex_unlock(&mq->delaypair->mx);
    /* assertion ret == 0 */
    assert(ret == 0);
  }

  return 0;
}

// queuebyid
// file msgqueue.c line 82
struct msgqueue_s * queuebyid(signed int msqid)
{
  struct msgqueue_s *mq;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&global_queue_lk);
  /* assertion pthread_mutex_lock(&global_queue_lk) == 0 */
  assert(return_value_pthread_mutex_lock_1 == 0);
  mq = queues[(signed long int)msqid];
  pthread_mutex_unlock(&global_queue_lk);
  return mq;
}

// readline
// file utils.c line 33
signed int readline(signed int fd, void *vptr, unsigned long int maxlen)
{
  signed long int n;
  signed long int rc;
  char c;
  char *ptr = (char *)vptr;
  n = (signed long int)1;
  char *tmp_post_1;
  signed int *return_value___errno_location_2;
  for( ; !((unsigned long int)n >= maxlen); n = n + 1l)
  {
    do
    {

    again:
      ;
      rc=read(fd, (void *)&c, (unsigned long int)1);
      if(rc == 1l)
      {
        if((signed int)c == 10)
          goto __CPROVER_DUMP_L9;

        if(!((signed int)c == 13))
        {
          tmp_post_1 = ptr;
          ptr = ptr + 1l;
          *tmp_post_1 = c;
        }

        goto __CPROVER_DUMP_L8;
      }

      if(rc == 0l)
      {
        if(n == 1l)
          return 0;

        else
          goto __CPROVER_DUMP_L9;
      }

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    return -1;

  __CPROVER_DUMP_L8:
    ;
  }

__CPROVER_DUMP_L9:
  ;
  *ptr = (char)0;
  return 1;
}

// readn
// file utils.c line 67
signed long int readn(signed int fd, void *vptr, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nread;
  char *ptr = (char *)vptr;
  nleft = n;
  for( ; nleft >= 1ul; ptr = ptr + nread)
  {
    nread=read(fd, (void *)ptr, nleft);
    if(!(nread >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        nread = (signed long int)0;

      else
        return (signed long int)-1;
    }

    else
      if(nread == 0l)
        break;

    nleft = nleft - (unsigned long int)nread;
  }
  return (signed long int)(n - nleft);
}

// register_check
// file srvutils.c line 570
void register_check(struct thread_pool_s *pool, signed int definitive)
{
  signed int i;
  struct anonymous_12 *check;
  void *return_value_Malloc_1;
  return_value_Malloc_1=Malloc(sizeof(struct anonymous_12) /*40ul*/ );
  check = (struct anonymous_12 *)return_value_Malloc_1;
  check->pool = pool;
  check->definitive = definitive;
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    if(ctx->checklist[(signed long int)i] == ((struct anonymous_12 *)NULL))
    {
      ctx->checklist[(signed long int)i] = check;
      break;
    }

  if(i == 128)
    logstr(65539, "unable to register pool %s", pool->name);

}

// release_bloom_filter
// file bloom.c line 202
void release_bloom_filter(struct anonymous_4 *filter)
{
  /* assertion filter->filter */
  assert(filter->filter != ((unsigned int *)NULL));
  free((void *)(unsigned int *)filter->filter);
  filter->filter = (unsigned int *)(void *)0;
  /* assertion filter */
  assert(filter != ((struct anonymous_4 *)NULL));
  free((void *)filter);
  filter = (struct anonymous_4 *)(void *)0;
}

// release_bloom_filter_group
// file bloom.c line 263
void release_bloom_filter_group(struct anonymous_6 *filter_group)
{
  unsigned int i;
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_6 *)NULL));
  i = (unsigned int)0;
  for( ; !(i >= filter_group->group_size); i = i + 1u)
  {
    release_bloom_filter(filter_group->filter_group[(signed long int)i]);
    filter_group->filter_group[(signed long int)i] = ((struct anonymous_4 *)NULL);
  }
  /* assertion filter_group */
  assert(filter_group != ((struct anonymous_6 *)NULL));
  free((void *)filter_group);
  filter_group = (struct anonymous_6 *)(void *)0;
}

// release_bloom_ring_queue
// file srvutils.c line 380
void release_bloom_ring_queue(struct anonymous_7 *brq)
{
  _Bool tmp_if_expr_1;
  if(!(ctx->statefile_info == ((struct statefile_info_s *)NULL)))
    tmp_if_expr_1 = brq == ctx->mmap_info->brq ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    munmap((void *)ctx->mmap_info->brq, ctx->mmap_info->lumpsize);
    close(ctx->statefile_info->fd);
    /* assertion ctx->statefile_info */
    assert(ctx->statefile_info != ((struct statefile_info_s *)NULL));
    free((void *)ctx->statefile_info);
    ctx->statefile_info = (struct statefile_info_s *)(void *)0;
    ctx->statefile_info = (struct statefile_info_s *)(void *)0;
    ctx->filter = (struct anonymous_7 *)(void *)0;
    ctx->mmap_info = (struct anonymous_14 *)(void *)0;
  }

  else
  {
    /* assertion brq */
    assert(brq != ((struct anonymous_7 *)NULL));
    free((void *)brq);
    brq = (struct anonymous_7 *)(void *)0;
  }
}

// release_queue
// file msgqueue.c line 490
signed int release_queue(signed int msqid)
{
  struct msg_s *msg;
  signed int ret;
  struct msgqueue_s *mq;
  mq=queuebyid(msqid);
  if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
  {
    logstr(65539, "release_queue: attempt to free a delay queue");
    return -1;
  }

  else
    if(!(mq->head == ((struct msg_s *)NULL)))
    {
      logstr(65544, "release_queue: queue not empty");
      return -1;
    }

    else
    {
      ret=pthread_mutex_lock(&mq->mx);
      /* assertion ret == 0 */
      assert(ret == 0);
      mq->active = 0;
      ret=pthread_mutex_unlock(&mq->mx);
      /* assertion ret == 0 */
      assert(ret == 0);
      void *return_value_Malloc_1;
      return_value_Malloc_1=Malloc(sizeof(struct msg_s) /*40ul*/ );
      msg = (struct msg_s *)return_value_Malloc_1;
      memset((void *)msg, 0, sizeof(struct msg_s) /*40ul*/ );
      msg->msgp = (void *)mq;
      ret=put_msg_raw(metaqueue, msg);
      /* assertion ret == 0 */
      assert(ret == 0);
      return 0;
    }
}

// respond
// file utils.c line 154
signed long int respond(signed int fd, const char *response)
{
  const char terminator[3l] = { '\n', '\n', 0 };
  signed long int return_value_writet_1;
  return_value_writet_1=writet(fd, response, terminator);
  return return_value_writet_1;
}

// rotate_bloom_ring_queue
// file bloom.c line 375
struct anonymous_7 * rotate_bloom_ring_queue(struct anonymous_7 *brq)
{
  unsigned int i;
  struct anonymous_4 *tmp;
  tmp=copy_bloom_filter(brq->aggregate, 1);
  unsigned int return_value_bloom_ring_queue_next_index_1;
  return_value_bloom_ring_queue_next_index_1=bloom_ring_queue_next_index(brq);
  zero_bloom_filter(brq->group->filter_group[(signed long int)return_value_bloom_ring_queue_next_index_1]);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
    tmp=add_filter(tmp, brq->group->filter_group[(signed long int)i]);
  advance_bloom_ring_queue(brq);
  memcpy((void *)brq->aggregate->filter, (const void *)tmp->filter, (unsigned long int)(tmp->bitsize / (unsigned int)8));
  release_bloom_filter(tmp);
  return brq;
}

// set_delay
// file msgqueue.c line 347
signed int set_delay(signed int msqid, struct timespec *ts)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(mq->delaypair == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  if(mq->delay_ts == ((struct timespec *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 22;
    return -1;
  }

  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  memcpy((void *)mq->delay_ts, (const void *)ts, sizeof(struct timespec) /*16ul*/ );
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  return 0;
}

// set_delay_status
// file msgqueue.c line 265
signed int set_delay_status(signed int msqid, signed int state)
{
  struct msgqueue_s *mq;
  signed int ret;
  mq=queuebyid(msqid);
  if(mq == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  if(mq->delaypair == ((struct msgqueue_s *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 22;
    return -1;
  }

  ret=pthread_mutex_lock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  *mq->impose_delay = state;
  ret=pthread_mutex_unlock(&mq->mx);
  /* assertion ret == 0 */
  assert(ret == 0);
  return 0;
}

// statstr
// file srvutils.c line 67
signed int statstr(signed int level, const char *fmt, ...)
{
  char mbuf[1024l] = { (char)0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  void **vap;
  signed int return_value_log_put_1;
  if((ctx->config.statlevel & level) == 262144)
    return 0;

  else
    if(!(ctx->config.loglevel >= 65541))
      return 0;

    else
    {
      vap = (void **)&fmt;
      vsnprintf(mbuf, (unsigned long int)1024, fmt, vap);
      vap = ((void **)NULL);
      if(!((0x01 & ctx->config.flags) == 0))
      {
        return_value_log_put_1=log_put(mbuf);
        return return_value_log_put_1;
      }

      else
      {
        level = 65541;
        level = level ^ 65536;
        syslog(level, "%s", (const void *)mbuf);
        return 0;
      }
    }
}

// sync_aggregate
// file bloom.c line 445
void sync_aggregate(struct anonymous_7 *brq)
{
  signed int i;
  unsigned int index = brq->current_index;
  zero_bloom_filter(brq->aggregate);
  i = 0;
  for( ; !((unsigned int)i >= brq->group->group_size); i = i + 1)
  {
    brq->aggregate=add_filter(brq->aggregate, brq->group->filter_group[(signed long int)index]);
    index = index + 1u;
    if(index >= brq->group->group_size)
      index = (unsigned int)0;

  }
}

// trim
// file utils.c line 186
signed int trim(char **buf)
{
  char *end;
  unsigned long int return_value_strspn_1;
  return_value_strspn_1=strspn(*buf, " \t");
  *buf = *buf + (signed long int)return_value_strspn_1;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(*buf);
  end = (*buf + (signed long int)return_value_strlen_2) - (signed long int)1;
  char *tmp_post_3;
  for( ; (_Bool)1; *tmp_post_3 = (char)0)
  {
    if(!((signed int)*end == 32))
    {
      if(!((signed int)*end == 9))
        goto __CPROVER_DUMP_L3;

    }

    tmp_post_3 = end;
    end = end - 1l;
  }

__CPROVER_DUMP_L3:
  ;
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(*buf);
  return (signed int)return_value_strlen_4;
}

// try_available
// file msgqueue.c line 530
struct msgqueue_s * try_available(void)
{
  struct msg_s *msg;
  struct msgqueue_s *mq = (struct msgqueue_s *)(void *)0;
  msg=get_msg_raw(metaqueue, -1);
  if(!(msg == ((struct msg_s *)NULL)))
  {
    mq = (struct msgqueue_s *)msg->msgp;
    mq->active = 1;
    /* assertion msg */
    assert(msg != ((struct msg_s *)NULL));
    free((void *)msg);
    msg = (struct msg_s *)(void *)0;
  }

  return mq;
}

// ts_diff
// file ../include/utils.h line 51
signed int ts_diff(struct timespec *diff, struct timespec *t1, struct timespec *t2)
{
  diff->tv_sec = t1->tv_sec - t2->tv_sec;
  diff->tv_nsec = t1->tv_nsec - t2->tv_nsec;
  if(!(diff->tv_nsec >= 0l))
  {
    diff->tv_nsec = diff->tv_nsec + (signed long int)(1000 * 1000 * 1000);
    diff->tv_sec = diff->tv_sec - 1l;
  }

  if(!(diff->tv_sec >= 0l))
    return -1;

  else
    return 0;
}

// ts_sum
// file ../include/utils.h line 50
signed int ts_sum(struct timespec *sum, struct timespec *t1, struct timespec *t2)
{
  sum->tv_sec = t1->tv_sec + t2->tv_sec;
  sum->tv_nsec = (t1->tv_nsec + t2->tv_nsec) % (signed long int)(1000 * 1000 * 1000);
  if((t1->tv_nsec + t2->tv_nsec) / 1000000000l >= 1l)
    sum->tv_sec = sum->tv_sec + 1l;

  return 0;
}

// tstotv
// file utils.c line 263
void tstotv(struct timespec *ts, struct timeval *tv)
{
  tv->tv_sec = ts->tv_sec;
  tv->tv_usec = ts->tv_nsec / (signed long int)1000;
}

// tvtots
// file utils.c line 256
void tvtots(struct timeval *tv, struct timespec *ts)
{
  ts->tv_sec = tv->tv_sec;
  ts->tv_nsec = tv->tv_usec * (signed long int)1000;
}

// walk_mmap_info
// file srvutils.c line 162
signed int walk_mmap_info(void)
{
  signed int i;
  unsigned long int offset = (unsigned long int)&ctx->mmap_info->brq[(signed long int)1] - (unsigned long int)ctx->mmap_info->brq->group;
  logstr(65543, "fixing bloom ring queue memory pointers, offset=%x", offset);
  void *return_value_new_address_1;
  return_value_new_address_1=new_address((void *)ctx->mmap_info->brq->group, offset);
  ctx->mmap_info->brq->group = (struct anonymous_6 *)return_value_new_address_1;
  void *return_value_new_address_2;
  return_value_new_address_2=new_address((void *)ctx->mmap_info->brq->aggregate, offset);
  ctx->mmap_info->brq->aggregate = (struct anonymous_4 *)return_value_new_address_2;
  void *return_value_new_address_3;
  return_value_new_address_3=new_address((void *)ctx->mmap_info->brq->aggregate->filter, offset);
  ctx->mmap_info->brq->aggregate->filter = (unsigned int *)return_value_new_address_3;
  void *return_value_new_address_4;
  return_value_new_address_4=new_address((void *)ctx->mmap_info->brq->group->filter_group, offset);
  ctx->mmap_info->brq->group->filter_group = (struct anonymous_4 **)return_value_new_address_4;
  i = 0;
  for( ; !((unsigned int)i >= ctx->mmap_info->brq->group->group_size); i = i + 1)
  {
    void *return_value_new_address_5;
    return_value_new_address_5=new_address((void *)ctx->mmap_info->brq->group->filter_group[(signed long int)i], offset);
    ctx->mmap_info->brq->group->filter_group[(signed long int)i] = (struct anonymous_4 *)return_value_new_address_5;
    void *return_value_new_address_6;
    return_value_new_address_6=new_address((void *)ctx->mmap_info->brq->group->filter_group[(signed long int)i]->filter, offset);
    ctx->mmap_info->brq->group->filter_group[(signed long int)i]->filter = (unsigned int *)return_value_new_address_6;
  }
  return 1;
}

// walk_queue
// file msgqueue.c line 709
signed int walk_queue(signed int msgid, signed int (*callback)(void *))
{
  struct msgqueue_s *mq;
  struct msg_s *msg;
  signed int ret;
  mq=queuebyid(msgid);
  /* assertion mq */
  assert(mq != ((struct msgqueue_s *)NULL));
  if(mq->active == 0)
  {
    logstr(65539, "get_msg_raw: message queue is marked inactive");
    return -1;
  }

  else
  {
    if(!(mq->head == ((struct msg_s *)NULL)))
    {
      msg = mq->head;
      if(!(msg == ((struct msg_s *)NULL)))
      {
        logstr(65543, "walk_queue: calling callback function");
        ret=callback(msg->msgp);
        if(!(ret >= 0))
        {
          logstr(65539, "walk_queue: callback returned FAILURE");
          return -1;
        }

        msg = msg->next;
      }

    }

    if(!(mq->delaypair == ((struct msgqueue_s *)NULL)))
    {
      if(!(mq->delaypair->head == ((struct msg_s *)NULL)))
      {
        msg = mq->head;
        if(!(msg == ((struct msg_s *)NULL)))
        {
          logstr(65543, "walk_queue: calling callback function");
          ret=callback(msg->msgp);
          if(!(ret >= 0))
          {
            logstr(65539, "walk_queue: callback returned FAILURE");
            return -1;
          }

          msg = msg->next;
        }

      }

    }

    return 0;
  }
}

// writeline
// file utils.c line 143
signed long int writeline(signed int fd, const char *line)
{
  const char terminator[3l] = { '\r', '\n', 0 };
  signed long int return_value_writet_1;
  return_value_writet_1=writet(fd, line, terminator);
  return return_value_writet_1;
}

// writen
// file utils.c line 96
signed long int writen(signed int fd, const void *vptr, unsigned long int n)
{
  unsigned long int nleft;
  signed long int nwritten;
  const char *ptr = (const char *)vptr;
  nleft = n;
  for( ; nleft >= 1ul; ptr = ptr + nwritten)
  {
    nwritten=write(fd, (const void *)ptr, nleft);
    if(!(nwritten >= 1l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        nwritten = (signed long int)0;

      else
        return (signed long int)-1;
    }

    nleft = nleft - (unsigned long int)nwritten;
  }
  return (signed long int)n;
}

// writet
// file utils.c line 121
signed long int writet(signed int fd, const char *line, const char *terminator)
{
  char *str;
  unsigned long int linelen;
  unsigned long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(line);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(terminator);
  linelen = return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(linelen);
  str = (char *)return_value_malloc_3;
  if(str == ((char *)NULL))
  {
    perror("malloc");
    return (signed long int)-1;
  }

  else
  {
    snprintf(str, linelen, "%s%s", line, terminator);
    signed long int return_value_writen_4;
    return_value_writen_4=writen(fd, (const void *)str, linelen - (unsigned long int)1);
    len = (unsigned long int)return_value_writen_4;
    /* assertion str */
    assert(str != ((char *)NULL));
    free((void *)str);
    str = (char *)(void *)0;
    return (signed long int)len;
  }
}

// zero_bloom_filter
// file ../include/bloom.h line 109
void zero_bloom_filter(struct anonymous_4 *filter)
{
  /* assertion filter */
  assert(filter != ((struct anonymous_4 *)NULL));
  init_bit_array(filter->filter, filter->size);
}

// zero_bloom_ring_queue
// file bloom.c line 395
void zero_bloom_ring_queue(struct anonymous_7 *brq)
{
  unsigned int i;
  /* assertion brq */
  assert(brq != ((struct anonymous_7 *)NULL));
  zero_bloom_filter(brq->aggregate);
  i = (unsigned int)0;
  for( ; !(i >= brq->group->group_size); i = i + 1u)
    zero_bloom_filter(brq->group->filter_group[(signed long int)i]);
  brq->current_index = (unsigned int)0;
}

