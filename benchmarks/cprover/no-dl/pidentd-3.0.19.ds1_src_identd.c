// tag-#anon#ST[*{*{V}_V_}_*{V}_V__'buf'||S32'bsize'||S32'occupied'||S32'nextin'||S32'nextout'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mtx'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'more'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'less'|]
// file buffer.h line 18
struct anonymous_5;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_7;

// tag-#anon#ST[S32'avail'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'mtx'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'cv'|]
// file avail.h line 18
struct anonymous_6;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[ARR8{U8}_U8_'cblock'||ARR2{U32}_U32_'deslong'|]
// file /usr/include/openssl/des.h line 86
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_2;

// tag-DES_ks
// file /usr/include/openssl/des.h line 85
struct DES_ks;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-data
// file pdes.h line 31
union data;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-inet_diag_msg
// file /usr/include/linux/inet_diag.h line 86
struct inet_diag_msg;

// tag-inet_diag_req
// file /usr/include/linux/inet_diag.h line 25
struct inet_diag_req;

// tag-inet_diag_sockid
// file /usr/include/linux/inet_diag.h line 13
struct inet_diag_sockid;

// tag-info
// file pdes.h line 18
struct info;

// tag-kainfo
// file k_linux.c line 35
struct kainfo;

// tag-kernel
// file kernel.h line 25
struct kernel;

// tag-logfacname
// file support.c line 359
struct logfacname;

// tag-loglevname
// file support.c line 419
struct loglevname;

// tag-nlmsghdr
// file /usr/include/linux/netlink.h line 42
struct nlmsghdr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-request
// file request.h line 21
struct request;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-servent
// file /usr/include/netdb.h line 257
struct servent;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_nl
// file /usr/include/linux/netlink.h line 35
struct sockaddr_nl;

// tag-timeout
// file timeout.h line 21
struct timeout;

// tag-timeout_cb
// file timeout.c line 26
struct timeout_cb;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// DES_ecb_encrypt
// file /usr/include/openssl/des.h line 152
void DES_ecb_encrypt(unsigned char (*)[8l], unsigned char (*)[8l], struct DES_ks *, signed int);
// DES_set_key
// file /usr/include/openssl/des.h line 230
signed int DES_set_key(unsigned char (*)[8l], struct DES_ks *);
// DES_string_to_key
// file /usr/include/openssl/des.h line 238
void DES_string_to_key(const char *, unsigned char (*)[8l]);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// __strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1023
static inline unsigned long int __strspn_c1(const char *__s, signed int __accept);
// __strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1035
static inline unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1047
static inline unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr);
// avail_init
// file avail.h line 25
extern signed int avail_init(struct anonymous_6 *ap);
// avail_signal
// file avail.h line 27
extern signed int avail_signal(struct anonymous_6 *ap);
// avail_wait
// file avail.h line 26
extern signed int avail_wait(struct anonymous_6 *ap);
// become_daemon
// file daemon.h line 18
extern void become_daemon(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// buffer_destroy
// file buffer.c line 83
extern void buffer_destroy(struct anonymous_5 *bp);
// buffer_get
// file buffer.h line 35
extern void * buffer_get(struct anonymous_5 *bp);
// buffer_init
// file buffer.h line 31
extern signed int buffer_init(struct anonymous_5 *bp, signed int bsize);
// buffer_put
// file buffer.h line 34
extern void buffer_put(struct anonymous_5 *bp, void *item);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_noident
// file send.c line 40
static signed int check_noident(char *dir);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// conf_parse
// file conf.h line 18
extern signed int conf_parse(const char *path, signed int silent);
// drop_root_privs
// file main.c line 94
void drop_root_privs(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getpwnam_r
// file /usr/include/pwd.h line 149
extern signed int getpwnam_r(const char *, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(signed int, struct rlimit *);
// getservbyname
// file /usr/include/netdb.h line 290
extern struct servent * getservbyname(const char *, const char *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// handle_request
// file request.c line 40
static signed int handle_request(signed int fd, char *buf, struct sockaddr_in *remote_addr);
// is_int
// file str2.c line 31
extern signed int is_int(const char *p);
// ka_init
// file kernel.h line 57
extern signed int ka_init(void);
// ka_lookup
// file kernel.h line 59
extern signed int ka_lookup(void *vp, struct kernel *kp);
// ka_open
// file kernel.h line 58
extern signed int ka_open(void **misc);
// kernel_alloc
// file kernel.h line 47
extern struct kernel * kernel_alloc(void);
// kernel_free
// file kernel.h line 48
extern void kernel_free(struct kernel *kp);
// kernel_init
// file kernel.h line 50
extern signed int kernel_init(void);
// kernel_query
// file kernel.h line 51
extern void kernel_query(struct kernel *kp);
// kernel_thread
// file kernel.c line 80
static void * kernel_thread(void *vp);
// kvm_dummy
// file pkvm.c line 160
signed int kvm_dummy(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file k_linux.c line 92 function netlink_lookup
void * memset(void *, signed int, unsigned long int);
// netlink_lookup
// file k_linux.c line 80
static signed int netlink_lookup(struct kainfo *kip, struct kernel *kp);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// osinfo_get
// file support.c line 39
extern char * osinfo_get(char *buf);
// pdes_encrypt
// file pdes.h line 41
extern signed int pdes_encrypt(struct kernel *kp, char *result);
// pdes_init
// file pdes.h line 40
extern signed int pdes_init(char *keyfile);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pidfile_create
// file daemon.h line 19
extern void pidfile_create(const char *path);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// program_header
// file main.c line 86
static void program_header(struct _IO_FILE *fp);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_0 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_0 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_0 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_0 *, union anonymous_2 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_0 *, union anonymous_2 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_2 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_2 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_2 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// random_lock_init
// file safeio.c line 233
static void random_lock_init(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// request_init
// file request.h line 34
extern signed int request_init(void);
// request_run
// file request.h line 35
extern signed int request_run(signed int fd, signed int nofork);
// request_thread
// file request.c line 167
extern void * request_thread(void *vp);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// s_abort
// file safeio.c line 33
extern void s_abort(void);
// s_accept
// file safeio.h line 28
extern signed int s_accept(signed int fd, struct sockaddr *sin, unsigned int *len);
// s_close
// file safeio.h line 26
extern signed int s_close(signed int fd);
// s_free
// file safeio.h line 33
extern void s_free(void *p);
// s_getpeername
// file safeio.h line 30
extern signed int s_getpeername(signed int fd, struct sockaddr *sin, unsigned int *len);
// s_getpwnam_r
// file support.c line 176
extern signed int s_getpwnam_r(const char *name, struct passwd *pwd, char *buffer, unsigned long int bufsize, struct passwd **result);
// s_getpwuid_r
// file support.h line 38
extern signed int s_getpwuid_r(unsigned int uid, struct passwd *pwd, char *buffer, unsigned long int bufsize, struct passwd **result);
// s_getsockname
// file safeio.h line 29
extern signed int s_getsockname(signed int fd, struct sockaddr *sin, unsigned int *len);
// s_inet_ntox
// file support.h line 48
extern const char * s_inet_ntox(struct sockaddr_in *ia, char *buf, unsigned long int bufsize);
// s_malloc
// file safeio.h line 32
extern void * s_malloc(unsigned long int size);
// s_open
// file safeio.h line 22
extern signed int s_open(const char *path, signed int oflag, ...);
// s_openlog
// file support.h line 43
extern void s_openlog(const char *ident, signed int logopt, signed int facility);
// s_poll
// file safeio.h line 42
extern signed int s_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout);
// s_random
// file safeio.c line 249
extern signed long int s_random(void);
// s_read
// file safeio.h line 25
extern signed long int s_read(signed int fd, char *buf, unsigned long int len);
// s_snprintf
// file safeio.h line 38
extern signed int s_snprintf(char *buf, unsigned long int bufsize, const char *format, ...);
// s_strcasecmp
// file support.c line 332
extern signed int s_strcasecmp(const char *s1, const char *s2);
// s_strdup
// file safeio.h line 34
extern char * s_strdup(const char *s);
// s_strtok_r
// file support.h line 28
extern char * s_strtok_r(char *s, const char *d, char **bp);
// s_write
// file safeio.h line 24
extern signed long int s_write(signed int fd, const char *buf, unsigned long int len);
// send_error
// file send.h line 24
extern void send_error(signed int fd, signed int l_port, signed int r_port, const char *what, struct sockaddr_in *remote_addr);
// send_result
// file send.h line 30
extern void send_result(signed int fd, struct kernel *kp);
// send_version
// file send.h line 33
extern void send_version(signed int fd, struct sockaddr_in *remote_addr);
// server_init
// file server.h line 24
extern signed int server_init(void);
// server_run
// file server.h line 25
extern signed int server_run(void);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file main.c line 105 function drop_root_privs
signed int setgroups(void);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(signed int, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socktype
// file support.h line 26
extern signed int socktype(signed int fd);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// str2bool
// file str2.h line 22
extern signed int str2bool(const char *buf, signed int *out);
// str2gid
// file str2.h line 24
extern signed int str2gid(const char *str, unsigned int *out);
// str2int
// file str2.h line 20
extern signed int str2int(const char *buf, signed int *out);
// str2port
// file str2.h line 23
extern signed int str2port(const char *str, signed int *out);
// str2str
// file str2.h line 21
extern signed int str2str(char *buf, char **out);
// str2uid
// file str2.h line 25
extern signed int str2uid(const char *str, unsigned int *uid, unsigned int *gid);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_str2fac
// file support.h line 45
extern signed int syslog_str2fac(const char *name);
// syslog_str2lev
// file support.c line 439
extern signed int syslog_str2lev(const char *name);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_cancel
// file timeout.h line 36
extern signed int timeout_cancel(struct timeout *tp);
// timeout_create
// file timeout.h line 34
extern struct timeout * timeout_create(signed int timeout, void (*fun)(void *), void *arg);
// timeout_create::fun_object
//
void fun_object(void *);
// timeout_handler
// file request.c line 153
static void timeout_handler(void *arg);
// timeout_init
// file timeout.h line 33
extern signed int timeout_init(void);
// timeout_reset
// file timeout.h line 35
extern signed int timeout_reset(struct timeout *tp, signed int timeout);
// timeout_thread
// file timeout.c line 40
static void * timeout_thread(void *misc);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlimit_nofile
// file server.c line 38
static signed int unlimit_nofile(void);
// usage
// file main.c line 51
static void usage(struct _IO_FILE *fp);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_7
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_0
{
  // __data
  struct anonymous_7 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous_5
{
  // buf
  void **buf;
  // bsize
  signed int bsize;
  // occupied
  signed int occupied;
  // nextin
  signed int nextin;
  // nextout
  signed int nextout;
  // mtx
  union anonymous_2 mtx;
  // more
  union anonymous_0 more;
  // less
  union anonymous_0 less;
};

struct anonymous_6
{
  // avail
  signed int avail;
  // mtx
  union anonymous_2 mtx;
  // cv
  union anonymous_0 cv;
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous
{
  // cblock
  unsigned char cblock[8l];
  // deslong
  unsigned int deslong[2l];
};

struct DES_ks
{
  // ks
  union anonymous ks[16l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct info
{
  // checksum
  unsigned int checksum;
  // random
  unsigned short int random;
  // uid
  unsigned short int uid;
  // date
  unsigned int date;
  // ip_local
  unsigned int ip_local;
  // ip_remote
  unsigned int ip_remote;
  // port_local
  unsigned short int port_local;
  // port_remote
  unsigned short int port_remote;
};

union data
{
  // fields
  struct info fields;
  // longs
  unsigned int longs[6l];
  // chars
  unsigned char chars[24l];
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct inet_diag_sockid
{
  // idiag_sport
  unsigned short int idiag_sport;
  // idiag_dport
  unsigned short int idiag_dport;
  // idiag_src
  unsigned int idiag_src[4l];
  // idiag_dst
  unsigned int idiag_dst[4l];
  // idiag_if
  unsigned int idiag_if;
  // idiag_cookie
  unsigned int idiag_cookie[2l];
};

struct inet_diag_msg
{
  // idiag_family
  unsigned char idiag_family;
  // idiag_state
  unsigned char idiag_state;
  // idiag_timer
  unsigned char idiag_timer;
  // idiag_retrans
  unsigned char idiag_retrans;
  // id
  struct inet_diag_sockid id;
  // idiag_expires
  unsigned int idiag_expires;
  // idiag_rqueue
  unsigned int idiag_rqueue;
  // idiag_wqueue
  unsigned int idiag_wqueue;
  // idiag_uid
  unsigned int idiag_uid;
  // idiag_inode
  unsigned int idiag_inode;
};

struct inet_diag_req
{
  // idiag_family
  unsigned char idiag_family;
  // idiag_src_len
  unsigned char idiag_src_len;
  // idiag_dst_len
  unsigned char idiag_dst_len;
  // idiag_ext
  unsigned char idiag_ext;
  // id
  struct inet_diag_sockid id;
  // idiag_states
  unsigned int idiag_states;
  // idiag_dbs
  unsigned int idiag_dbs;
};

struct kainfo
{
  // nlfd
  signed int nlfd;
  // seq
  unsigned int seq;
  // proc_net_tcp
  struct _IO_FILE *proc_net_tcp;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct kernel
{
  // local
  struct sockaddr_in local;
  // remote
  struct sockaddr_in remote;
  // av
  struct anonymous_6 av;
  // status
  signed int status;
  // euid
  unsigned int euid;
  // ruid
  unsigned int ruid;
  // pid
  signed int pid;
  // cmd
  char *cmd;
  // argv
  char *argv;
};

struct logfacname
{
  // name
  const char *name;
  // code
  signed int code;
};

struct loglevname
{
  // name
  const char *name;
  // level
  signed int level;
};

struct nlmsghdr
{
  // nlmsg_len
  unsigned int nlmsg_len;
  // nlmsg_type
  unsigned short int nlmsg_type;
  // nlmsg_flags
  unsigned short int nlmsg_flags;
  // nlmsg_seq
  unsigned int nlmsg_seq;
  // nlmsg_pid
  unsigned int nlmsg_pid;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct request
{
  // fd
  signed int fd;
  // addr
  struct sockaddr_in addr;
  // addr_len
  unsigned int addr_len;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct servent
{
  // s_name
  char *s_name;
  // s_aliases
  char **s_aliases;
  // s_port
  signed int s_port;
  // s_proto
  char *s_proto;
};

struct sockaddr_nl
{
  // nl_family
  unsigned short int nl_family;
  // nl_pad
  unsigned short int nl_pad;
  // nl_pid
  unsigned int nl_pid;
  // nl_groups
  unsigned int nl_groups;
};

struct timeout
{
  // next
  struct timeout *next;
  // when
  signed long int when;
  // fun
  void (*fun)(void *);
  // arg
  void *arg;
};

struct timeout_cb
{
  // mtx
  union anonymous_2 mtx;
  // cv
  union anonymous_0 cv;
  // tid
  unsigned long int tid;
  // running
  signed int running;
  // top
  struct timeout *top;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // __domainname
  char __domainname[65l];
};


// argv0
// file main.c line 35
char *argv0 = "identd";
// cattr_detached
// file main.c line 47
union pthread_attr_t cattr_detached;
// charset
// file send.c line 35
char *charset = (char *)(void *)0;
// debug
// file main.c line 37
signed int debug = 0;
// encrypt_flag
// file main.c line 43
signed int encrypt_flag = 0;
// encrypt_keyfile
// file main.c line 44
char *encrypt_keyfile = "/etc/identd.key";
// extensions_enabled
// file request.c line 29
signed int extensions_enabled = 0;
// facility
// file support.c line 363
static struct logfacname facility[19l] = { { .name="kern", .code=0 << 3 }, { .name="user", .code=1 << 3 }, { .name="mail", .code=2 << 3 }, { .name="daemon", .code=3 << 3 }, { .name="auth", .code=4 << 3 }, { .name="syslog", .code=5 << 3 }, { .name="lpr", .code=6 << 3 }, { .name="news", .code=7 << 3 }, { .name="uucp", .code=8 << 3 }, { .name="cron", .code=9 << 3 }, { .name="local0", .code=16 << 3 }, { .name="local1", .code=17 << 3 }, { .name="local2", .code=18 << 3 }, { .name="local3", .code=19 << 3 }, { .name="local4", .code=20 << 3 }, { .name="local5", .code=21 << 3 }, { .name="local6", .code=22 << 3 }, { .name="local7", .code=23 << 3 }, { .name=(const char *)(void *)0, .code=-1 } };
// kbuf_free
// file kernel.c line 40
static struct anonymous_5 kbuf_free;
// kbuf_request
// file kernel.c line 39
static struct anonymous_5 kbuf_request;
// kernel_attempts
// file kernel.c line 36
signed int kernel_attempts = 5;
// kernel_buffers
// file kernel.c line 35
signed int kernel_buffers = 16;
// kernel_threads
// file kernel.c line 34
signed int kernel_threads = 4;
// level
// file support.c line 423
static struct loglevname level[9l] = { { .name="emerg", .level=0 }, { .name="alert", .level=1 }, { .name="crit", .level=2 }, { .name="err", .level=3 }, { .name="warning", .level=4 }, { .name="notice", .level=5 }, { .name="info", .level=6 }, { .name="debug", .level=7 }, { .name=(const char *)(void *)0, .level=-1 } };
// listen_addr
// file server.c line 33
signed int listen_addr = (signed int)(unsigned int)0x00000000;
// listen_backlog
// file server.c line 34
signed int listen_backlog = 256;
// listen_port
// file server.c line 32
signed int listen_port = 113;
// listen_sock
// file server.c line 31
signed int listen_sock = -1;
// multiquery_enabled
// file request.c line 30
signed int multiquery_enabled = 0;
// noident_flag
// file send.c line 32
signed int noident_flag = 0;
// opsys
// file send.c line 36
char *opsys = "UNIX";
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// osinfo_build
// file c_osinfo.c line 1
char osinfo_build[21l] = { 'L', 'i', 'n', 'u', 'x', ' ', '3', '.', '1', '6', '.', '0', '-', '4', '-', 'a', 'm', 'd', '6', '4', 0 };
// pidfile_path
// file main.c line 40
char *pidfile_path = "/var/run/identd/identd.pid";
// random_lock
// file safeio.c line 229
static union anonymous_2 random_lock;
// random_once
// file safeio.c line 230
static signed int random_once = 0;
// request_timeout
// file request.c line 31
signed int request_timeout = 120;
// requests_cur
// file request.c line 34
signed int requests_cur;
// requests_cv
// file request.c line 36
union anonymous_0 requests_cv;
// requests_max
// file request.c line 33
signed int requests_max = 0;
// requests_mtx
// file request.c line 35
union anonymous_2 requests_mtx;
// result_syslog_level
// file send.c line 33
signed int result_syslog_level = -1;
// sched
// file pdes.c line 49
static struct DES_ks sched;
// server_gid
// file main.c line 39
unsigned int server_gid = (unsigned int)0;
// server_uid
// file main.c line 38
unsigned int server_uid = (unsigned int)-1;
// server_version
// file version.c line 1
char server_version[7l] = { '3', '.', '0', '.', '1', '9', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tcb
// file timeout.c line 35
static struct timeout_cb tcb;
// to_asc
// file pdes.c line 44
static const char to_asc[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// uidonly_flag
// file send.c line 31
signed int uidonly_flag = 0;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

    if((signed int)*__s == __accept3)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1023
static inline unsigned long int __strspn_c1(const char *__s, signed int __accept)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (signed int)__s[(signed long int)__result] == __accept; __result = __result + 1ul)
    ;
  return __result;
}

// __strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1035
static inline unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (_Bool)1; __result = __result + 1ul)
    if(!((signed int)__s[(signed long int)__result] == __accept1))
    {
      if(!((signed int)__s[(signed long int)__result] == __accept2))
        goto __CPROVER_DUMP_L3;

    }


__CPROVER_DUMP_L3:
  ;
  return __result;
}

// __strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1047
static inline unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  unsigned long int __result = (unsigned long int)0;
  for( ; (_Bool)1; __result = __result + 1ul)
    if(!((signed int)__s[(signed long int)__result] == __accept1))
    {
      if(!((signed int)__s[(signed long int)__result] == __accept2))
      {
        if(!((signed int)__s[(signed long int)__result] == __accept3))
          goto __CPROVER_DUMP_L3;

      }

    }


__CPROVER_DUMP_L3:
  ;
  return __result;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return return_value_strtol_1;
}

// avail_init
// file avail.h line 25
extern signed int avail_init(struct anonymous_6 *ap)
{
  pthread_mutex_init(&ap->mtx, (const union anonymous_1 *)(void *)0);
  pthread_cond_init(&ap->cv, (const union anonymous_1 *)(void *)0);
  ap->avail = 0;
  return 0;
}

// avail_signal
// file avail.h line 27
extern signed int avail_signal(struct anonymous_6 *ap)
{
  pthread_mutex_lock(&ap->mtx);
  if(!(ap->avail == 0))
    pthread_mutex_unlock(&ap->mtx);

  else
  {
    ap->avail = 1;
    pthread_mutex_unlock(&ap->mtx);
    pthread_cond_broadcast(&ap->cv);
  }
  return 0;
}

// avail_wait
// file avail.h line 26
extern signed int avail_wait(struct anonymous_6 *ap)
{
  pthread_mutex_lock(&ap->mtx);
  while(ap->avail == 0)
    pthread_cond_wait(&ap->cv, &ap->mtx);
  pthread_mutex_unlock(&ap->mtx);
  return 0;
}

// become_daemon
// file daemon.h line 18
extern void become_daemon(void)
{
  signed int pid;
  signed int i;
  signed int fd;
  pid=fork();
  if(!(pid >= 0))
  {
    syslog(3, "fork() failed: %m");
    exit(1);
  }

  else
    if(pid >= 1)
      exit(0);

  signal(22, (void (*)(signed int))1);
  signal(21, (void (*)(signed int))1);
  setsid();
  chdir("/");
  umask((unsigned int)0);
  i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    close(i);
    fd=s_open("/dev/null", 02);
    if(!(fd == i))
    {
      dup2(fd, i);
      close(fd);
    }

  }
}

// buffer_destroy
// file buffer.c line 83
extern void buffer_destroy(struct anonymous_5 *bp)
{
  pthread_mutex_destroy(&bp->mtx);
  pthread_cond_destroy(&bp->more);
  pthread_cond_destroy(&bp->less);
  s_free((void *)bp->buf);
}

// buffer_get
// file buffer.h line 35
extern void * buffer_get(struct anonymous_5 *bp)
{
  void *item;
  pthread_mutex_lock(&bp->mtx);
  while(!(bp->occupied >= 1))
    pthread_cond_wait(&bp->more, &bp->mtx);
  signed int tmp_post_1 = bp->nextout;
  bp->nextout = bp->nextout + 1;
  item = bp->buf[(signed long int)tmp_post_1];
  bp->nextout = bp->nextout % bp->bsize;
  bp->occupied = bp->occupied - 1;
  pthread_mutex_unlock(&bp->mtx);
  pthread_cond_signal(&bp->less);
  return item;
}

// buffer_init
// file buffer.h line 31
extern signed int buffer_init(struct anonymous_5 *bp, signed int bsize)
{
  void *return_value_s_malloc_1;
  return_value_s_malloc_1=s_malloc(sizeof(void *) /*8ul*/  * (unsigned long int)bsize);
  bp->buf = (void **)return_value_s_malloc_1;
  bp->bsize = bsize;
  bp->occupied = 0;
  bp->nextin = 0;
  bp->nextout = 0;
  pthread_mutex_init(&bp->mtx, (const union anonymous_1 *)(void *)0);
  pthread_cond_init(&bp->more, (const union anonymous_1 *)(void *)0);
  pthread_cond_init(&bp->less, (const union anonymous_1 *)(void *)0);
  return 0;
}

// buffer_put
// file buffer.h line 34
extern void buffer_put(struct anonymous_5 *bp, void *item)
{
  pthread_mutex_lock(&bp->mtx);
  while(bp->occupied >= bp->bsize)
    pthread_cond_wait(&bp->less, &bp->mtx);
  signed int tmp_post_1 = bp->nextin;
  bp->nextin = bp->nextin + 1;
  bp->buf[(signed long int)tmp_post_1] = item;
  bp->nextin = bp->nextin % bp->bsize;
  bp->occupied = bp->occupied + 1;
  pthread_mutex_unlock(&bp->mtx);
  pthread_cond_signal(&bp->more);
}

// check_noident
// file send.c line 40
static signed int check_noident(char *dir)
{
  char buf[2048l];
  unsigned long int len;
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(dir == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(dir);
    tmp_if_expr_2 = return_value_strlen_1 > (unsigned long int)1024 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int tmp_post_3;
  if(tmp_if_expr_2)
    return -1;

  else
  {
    len=strlen(dir);
    memcpy((void *)buf, (const void *)dir, len);
    if(len >= 1ul)
    {
      if(!((signed int)buf[-1l + (signed long int)len] == 47))
      {
        tmp_post_3 = len;
        len = len + 1ul;
        buf[(signed long int)tmp_post_3] = (char)47;
      }

    }

    strcpy(buf + (signed long int)len, ".noident");
    signed int return_value_access_4;
    return_value_access_4=access(buf, 0);
    if(return_value_access_4 == 0)
      return 1;

    else
      return 0;
  }
}

// conf_parse
// file conf.h line 18
extern signed int conf_parse(const char *path, signed int silent)
{
  struct _IO_FILE *fp;
  char buf[1024l];
  char *cp;
  char *sp;
  char *arg;
  signed int line;
  fp=fopen(path, "r");
  char *return_value_fgets_1;
  _Bool tmp_if_expr_5;
  signed int tmp_statement_expression_3;
  signed int return_value_strcasecmp_45;
  signed int return_value_strcasecmp_44;
  signed int return_value_strcasecmp_43;
  signed int return_value_strcasecmp_42;
  signed int return_value_strcasecmp_41;
  signed int return_value_strcasecmp_40;
  signed int return_value_strcasecmp_39;
  signed int return_value_strcasecmp_38;
  signed int return_value_strcasecmp_37;
  signed int return_value_strcasecmp_36;
  signed int return_value_strcasecmp_35;
  signed int return_value_strcasecmp_34;
  signed int return_value_strcasecmp_33;
  signed int return_value_strcasecmp_32;
  signed int return_value_strcasecmp_31;
  signed int return_value_strcasecmp_30;
  _Bool tmp_if_expr_21;
  signed int return_value_strcasecmp_20;
  signed int return_value_strcasecmp_29;
  signed int return_value_strcasecmp_28;
  signed int return_value_strcasecmp_27;
  signed int return_value_strcasecmp_26;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    if(silent == 0)
      syslog(3, "fopen(\"%s\"): %m", path);

    return -1;
  }

  else
  {
    line = 0;
    do
    {
      return_value_fgets_1=fgets(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , fp);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      line = line + 1;
      char *return_value___builtin_strchr_2;
      return_value___builtin_strchr_2=__builtin_strchr(buf, 35);
      cp = return_value___builtin_strchr_2;
      if(!(cp == ((char *)NULL)))
        *cp = (char)0;

      cp=s_strtok_r(buf, " \t\r\n", &sp);
      if(!(cp == ((char *)NULL)))
      {
        arg=s_strtok_r((char *)(void *)0, " \t\r\n", &sp);
        if(arg == ((char *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_4;
          return_value___builtin_strcmp_4=__builtin_strcmp(arg, "=");
          tmp_statement_expression_3 = return_value___builtin_strcmp_4;
          tmp_if_expr_5 = tmp_statement_expression_3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          syslog(3, "%s: %d: missing '='", path, line);

        else
        {
          arg=s_strtok_r((char *)(void *)0, "\r\n", &sp);
          if(arg == ((char *)NULL))
            syslog(3, "%s: %d: missing argument", path, line);

          else
          {
            if(!(debug == 0))
              fprintf(stderr, "conf_parse(\"%s\"), line #%d: %s = %s\n", path, line, cp, arg != ((char *)NULL) ? arg : "");

            signed int return_value_strcasecmp_46;
            return_value_strcasecmp_46=strcasecmp(cp, "include");
            if(return_value_strcasecmp_46 == 0)
              conf_parse(arg, silent);

            else
            {
              return_value_strcasecmp_45=strcasecmp(cp, "syslog:facility");
              if(return_value_strcasecmp_45 == 0)
              {
                signed int code;
                code=syslog_str2fac(arg);
                if(!(code >= 0))
                  syslog(3, "%s: %d: invalid syslog facility: %s", path, line, arg);

                else
                {
                  closelog();
                  s_openlog(argv0, 0x01 | 0x04, code);
                }
              }

              else
              {
                return_value_strcasecmp_44=strcasecmp(cp, "server:port");
                if(return_value_strcasecmp_44 == 0)
                {
                  signed int return_value_str2port_6;
                  return_value_str2port_6=str2port(arg, &listen_port);
                  if(!(return_value_str2port_6 >= 0))
                    syslog(3, "%s: %d: invalid port: %s", path, line, arg);

                }

                else
                {
                  return_value_strcasecmp_43=strcasecmp(cp, "server:backlog");
                  if(return_value_strcasecmp_43 == 0)
                  {
                    signed int return_value_str2int_7;
                    return_value_str2int_7=str2int(arg, &listen_backlog);
                    if(!(return_value_str2int_7 >= 0))
                      syslog(3, "%s: %d: invalid number: %s", path, line, arg);

                  }

                  else
                  {
                    return_value_strcasecmp_42=strcasecmp(cp, "server:user");
                    if(return_value_strcasecmp_42 == 0)
                    {
                      signed int return_value_str2uid_8;
                      return_value_str2uid_8=str2uid(arg, &server_uid, &server_gid);
                      if(!(return_value_str2uid_8 >= 0))
                        syslog(3, "%s: %d: invalid user: %s", path, line, arg);

                    }

                    else
                    {
                      return_value_strcasecmp_41=strcasecmp(cp, "server:group");
                      if(return_value_strcasecmp_41 == 0)
                      {
                        signed int return_value_str2gid_9;
                        return_value_str2gid_9=str2gid(arg, &server_gid);
                        if(!(return_value_str2gid_9 >= 0))
                          syslog(3, "%s: %d: invalid group: %s", path, line, arg);

                      }

                      else
                      {
                        return_value_strcasecmp_40=strcasecmp(cp, "server:pid-file");
                        if(return_value_strcasecmp_40 == 0)
                        {
                          signed int return_value_str2str_10;
                          return_value_str2str_10=str2str(arg, &pidfile_path);
                          if(!(return_value_str2str_10 >= 0))
                            syslog(3, "%s: %d: invalid string: %s", path, line, arg);

                        }

                        else
                        {
                          return_value_strcasecmp_39=strcasecmp(cp, "server:max-requests");
                          if(return_value_strcasecmp_39 == 0)
                          {
                            signed int return_value_str2int_11;
                            return_value_str2int_11=str2int(arg, &requests_max);
                            if(!(return_value_str2int_11 >= 0))
                              syslog(3, "%s: %d: invalid integer: %s", path, line, arg);

                          }

                          else
                          {
                            return_value_strcasecmp_38=strcasecmp(cp, "protocol:extensions");
                            if(return_value_strcasecmp_38 == 0)
                            {
                              signed int return_value_str2bool_12;
                              return_value_str2bool_12=str2bool(arg, &extensions_enabled);
                              if(!(return_value_str2bool_12 >= 0))
                                syslog(3, "%s: %d: invalid bool: %s", path, line, arg);

                            }

                            else
                            {
                              return_value_strcasecmp_37=strcasecmp(cp, "protocol:multiquery");
                              if(return_value_strcasecmp_37 == 0)
                              {
                                signed int return_value_str2bool_13;
                                return_value_str2bool_13=str2bool(arg, &multiquery_enabled);
                                if(!(return_value_str2bool_13 >= 0))
                                  syslog(3, "%s: %d: invalid bool: %s", path, line, arg);

                              }

                              else
                              {
                                return_value_strcasecmp_36=strcasecmp(cp, "protocol:timeout");
                                if(return_value_strcasecmp_36 == 0)
                                {
                                  signed int return_value_str2int_14;
                                  return_value_str2int_14=str2int(arg, &request_timeout);
                                  if(!(return_value_str2int_14 >= 0))
                                    syslog(3, "%s: %d: invalid integer: %s", path, line, arg);

                                }

                                else
                                {
                                  return_value_strcasecmp_35=strcasecmp(cp, "result:noident");
                                  if(return_value_strcasecmp_35 == 0)
                                  {
                                    signed int return_value_str2bool_15;
                                    return_value_str2bool_15=str2bool(arg, &noident_flag);
                                    if(!(return_value_str2bool_15 >= 0))
                                      syslog(3, "%s: %d: invalid bool: %s", path, line, arg);

                                  }

                                  else
                                  {
                                    return_value_strcasecmp_34=strcasecmp(cp, "result:uid-only");
                                    if(return_value_strcasecmp_34 == 0)
                                    {
                                      signed int return_value_str2bool_16;
                                      return_value_str2bool_16=str2bool(arg, &uidonly_flag);
                                      if(!(return_value_str2bool_16 >= 0))
                                        syslog(3, "%s: %d: invalid bool: %s", path, line, arg);

                                    }

                                    else
                                    {
                                      return_value_strcasecmp_33=strcasecmp(cp, "result:encrypt");
                                      if(return_value_strcasecmp_33 == 0)
                                      {
                                        signed int return_value_str2bool_17;
                                        return_value_str2bool_17=str2bool(arg, &encrypt_flag);
                                        if(!(return_value_str2bool_17 >= 0))
                                          syslog(3, "%s: %d: invalid bool: %s", path, line, arg);

                                      }

                                      else
                                      {
                                        return_value_strcasecmp_32=strcasecmp(cp, "result:charset");
                                        if(return_value_strcasecmp_32 == 0)
                                        {
                                          signed int return_value_str2str_18;
                                          return_value_str2str_18=str2str(arg, &charset);
                                          if(!(return_value_str2str_18 >= 0))
                                            syslog(3, "%s: %d: invalid string: %s", path, line, arg);

                                        }

                                        else
                                        {
                                          return_value_strcasecmp_31=strcasecmp(cp, "result:opsys");
                                          if(return_value_strcasecmp_31 == 0)
                                          {
                                            signed int return_value_str2str_19;
                                            return_value_str2str_19=str2str(arg, &opsys);
                                            if(!(return_value_str2str_19 >= 0))
                                              syslog(3, "%s: %d: invalid string: %s", path, line, arg);

                                          }

                                          else
                                          {
                                            return_value_strcasecmp_30=strcasecmp(cp, "result:syslog-level");
                                            if(return_value_strcasecmp_30 == 0)
                                            {
                                              if(!(arg == ((char *)NULL)))
                                              {
                                                return_value_strcasecmp_20=strcasecmp(arg, "none");
                                                tmp_if_expr_21 = return_value_strcasecmp_20 == 0 ? (_Bool)1 : (_Bool)0;
                                              }

                                              else
                                                tmp_if_expr_21 = (_Bool)0;
                                              if(tmp_if_expr_21)
                                                result_syslog_level = -1;

                                              else
                                              {
                                                signed int conf_parse__1__2__20__1__code;
                                                conf_parse__1__2__20__1__code=syslog_str2lev(arg);
                                                if(!(conf_parse__1__2__20__1__code >= 0))
                                                  syslog(3, "%s: %d: invalid syslog level: %s", path, line, arg);

                                                else
                                                  result_syslog_level = conf_parse__1__2__20__1__code;
                                              }
                                            }

                                            else
                                            {
                                              return_value_strcasecmp_29=strcasecmp(cp, "kernel:threads");
                                              if(return_value_strcasecmp_29 == 0)
                                              {
                                                signed int return_value_str2int_22;
                                                return_value_str2int_22=str2int(arg, &kernel_threads);
                                                if(!(return_value_str2int_22 >= 0))
                                                  syslog(3, "%s: %d: invalid integer: %s", path, line, arg);

                                              }

                                              else
                                              {
                                                return_value_strcasecmp_28=strcasecmp(cp, "kernel:attempts");
                                                if(return_value_strcasecmp_28 == 0)
                                                {
                                                  signed int return_value_str2int_23;
                                                  return_value_str2int_23=str2int(arg, &kernel_attempts);
                                                  if(!(return_value_str2int_23 >= 0))
                                                    syslog(3, "%s: %d: invalid integer: %s", path, line, arg);

                                                }

                                                else
                                                {
                                                  return_value_strcasecmp_27=strcasecmp(cp, "kernel:buffers");
                                                  if(return_value_strcasecmp_27 == 0)
                                                  {
                                                    signed int return_value_str2int_24;
                                                    return_value_str2int_24=str2int(arg, &kernel_buffers);
                                                    if(!(return_value_str2int_24 >= 0))
                                                      syslog(3, "%s: %d: invalid integer: %s", path, line, arg);

                                                  }

                                                  else
                                                  {
                                                    return_value_strcasecmp_26=strcasecmp(cp, "encrypt:key-file");
                                                    if(return_value_strcasecmp_26 == 0)
                                                    {
                                                      signed int return_value_str2str_25;
                                                      return_value_str2str_25=str2str(arg, &encrypt_keyfile);
                                                      if(!(return_value_str2str_25 >= 0))
                                                        syslog(3, "%s: %d: invalid string: %s", path, line, arg);

                                                    }

                                                    else
                                                      syslog(3, "%s: %d: unknown option: %s", path, line, cp);
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// drop_root_privs
// file main.c line 94
void drop_root_privs(void)
{
  unsigned int return_value_geteuid_1;
  return_value_geteuid_1=geteuid();
  signed int return_value_setgid_4;
  signed int return_value_setuid_5;
  if(return_value_geteuid_1 == 0u)
  {
    if(server_uid == 4294967295u)
    {
      signed int return_value_str2uid_2;
      return_value_str2uid_2=str2uid("nobody", &server_uid, &server_gid);
      if(!(return_value_str2uid_2 >= 0))
        server_uid = (unsigned int)0;

    }

    signed int return_value_setgroups_3;
    return_value_setgroups_3=setgroups(1, &server_gid);
    if(return_value_setgroups_3 >= 0)
    {
      if(!(server_gid == 0u))
      {
        return_value_setgid_4=setgid(server_gid);
        if(!(return_value_setgid_4 >= 0))
          goto Error;

      }

      if(!(server_uid == 0u))
      {
        return_value_setuid_5=setuid(server_uid);
        if(!(return_value_setuid_5 >= 0))
          goto Error;

      }

    }

    else
    {

    Error:
      ;
      syslog(3, "Error while changing user/group privileges");
      exit(1);
    }
  }

}

// handle_request
// file request.c line 40
static signed int handle_request(signed int fd, char *buf, struct sockaddr_in *remote_addr)
{
  struct kernel *kp;
  signed int local_port;
  signed int remote_port;
  unsigned int len;
  char *cmd;
  char *bp;
  if(!(debug == 0))
    fprintf(stderr, "handle_request: fd#%d: '%s'\n", fd, buf);

  signed int return_value_sscanf_4;
  return_value_sscanf_4=sscanf(buf, " %d , %d", &local_port, &remote_port);
  unsigned short int tmp_statement_expression_1;
  unsigned short int tmp_statement_expression_3;
  if(return_value_sscanf_4 == 2)
  {
    if(local_port >= 65536 || remote_port >= 65536 || !(local_port >= 1) || !(remote_port >= 1))
    {
      send_error(fd, local_port, remote_port, "INVALID-PORT", remote_addr);
      return 0;
    }

    kp=kernel_alloc();
    kp->remote = *remote_addr;
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)remote_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_1 = __v;
    kp->remote.sin_port = tmp_statement_expression_1;
    len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    signed int return_value_s_getsockname_2;
    return_value_s_getsockname_2=s_getsockname(fd, (struct sockaddr *)&kp->local, &len);
    if(!(return_value_s_getsockname_2 >= 0))
    {
      syslog(3, "s_getsockname(%d): %m", fd);
      kernel_free(kp);
      return -1;
    }

    unsigned short int handle_request__1__1__4____v;
    unsigned short int handle_request__1__1__4____x = (unsigned short int)local_port;
    asm("rorw _8, %w0" : "=r"(handle_request__1__1__4____v) : "0"(handle_request__1__1__4____x) : "cc");
    tmp_statement_expression_3 = handle_request__1__1__4____v;
    kp->local.sin_port = tmp_statement_expression_3;
    kernel_query(kp);
    if(!(debug == 0))
    {
      fprintf(stderr, "kernel_query, status = %d\n", kp->status);
      if(kp->status == 1)
      {
        if(!(kp->ruid == 4294967295u))
          fprintf(stderr, "\truid = %ld\n", (signed long int)kp->ruid);

        if(!(kp->euid == 4294967295u))
          fprintf(stderr, "\teuid = %ld\n", (signed long int)kp->euid);

        if(!(kp->pid == -1))
          fprintf(stderr, "\tpid  = %ld\n", (signed long int)kp->pid);

        if(!(kp->cmd == ((char *)NULL)))
          fprintf(stderr, "\tcmd  = %s\n", kp->cmd);

        if(!(kp->argv == ((char *)NULL)))
          fprintf(stderr, "\targv = %s\n", kp->argv);

      }

    }

    switch(kp->status)
    {
      case 2:
      {
        send_error(fd, local_port, remote_port, "HIDDEN-USER", remote_addr);
        break;
      }
      case 1:
      {
        send_result(fd, kp);
        break;
      }
      case 0:
      {
        send_error(fd, local_port, remote_port, "NO-USER", remote_addr);
        break;
      }
      default:
        send_error(fd, local_port, remote_port, "UNKNOWN-ERROR", remote_addr);
    }
    kernel_free(kp);
    return 0;
  }

  if(!(extensions_enabled == 0))
  {
    cmd=s_strtok_r(buf, " ", &bp);
    if(!(cmd == ((char *)NULL)))
    {
      signed int return_value_strcasecmp_5;
      return_value_strcasecmp_5=strcasecmp("version", cmd);
      if(return_value_strcasecmp_5 == 0)
      {
        send_version(fd, remote_addr);
        return 0;
      }

      signed int return_value_strcasecmp_6;
      return_value_strcasecmp_6=strcasecmp("quit", cmd);
      if(return_value_strcasecmp_6 == 0)
        return -1;

    }

  }


Fail:
  ;
  send_error(fd, 0, 0, "UNKNOWN-ERROR", remote_addr);
  return -1;
}

// is_int
// file str2.c line 31
extern signed int is_int(const char *p)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  if((signed int)*p == 45)
    p = p + 1l;

  const unsigned short int **return_value___ctype_b_loc_2;
  do
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc_3;
  do
  {
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  return (signed int)((signed int)*p == 0);
}

// ka_init
// file kernel.h line 57
extern signed int ka_init(void)
{
  return 0;
}

// ka_lookup
// file kernel.h line 59
extern signed int ka_lookup(void *vp, struct kernel *kp)
{
  struct _IO_FILE *fp;
  signed long int dummy;
  char buf[512l];
  signed long int r_laddr;
  signed long int r_raddr;
  signed long int myladdr;
  signed long int myraddr;
  signed int r_lport;
  signed int r_rport;
  signed int mylport;
  signed int myrport;
  signed int euid;
  signed int nra;
  signed int status;
  unsigned long int ino;
  struct kainfo *kip = (struct kainfo *)vp;
  kp->ruid = (unsigned int)-1;
  signed int return_value_netlink_lookup_1;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_3;
  char *return_value_fgets_5;
  if(kip->nlfd >= 0)
  {
    return_value_netlink_lookup_1=netlink_lookup(kip, kp);
    return return_value_netlink_lookup_1;
  }

  else
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)kp->remote.sin_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_2 = __v;
    r_rport = (signed int)tmp_statement_expression_2;
    unsigned short int ka_lookup__1__2____v;
    unsigned short int ka_lookup__1__2____x = (unsigned short int)kp->local.sin_port;
    asm("rorw _8, %w0" : "=r"(ka_lookup__1__2____v) : "0"(ka_lookup__1__2____x) : "cc");
    tmp_statement_expression_3 = ka_lookup__1__2____v;
    r_lport = (signed int)tmp_statement_expression_3;
    r_raddr = (signed long int)kp->remote.sin_addr.s_addr;
    r_laddr = (signed long int)kp->local.sin_addr.s_addr;
    fp = kip->proc_net_tcp;
    rewind(fp);
    char *return_value_fgets_4;
    return_value_fgets_4=fgets(buf, (signed int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1), fp);
    if(return_value_fgets_4 == ((char *)NULL))
      return -1;

    else
    {
      status = 0;
      do
      {
        return_value_fgets_5=fgets(buf, (signed int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1), fp);
        if(return_value_fgets_5 == ((char *)NULL))
          break;

        nra=sscanf(buf, "%d: %lX:%x %lX:%x %x %lX:%lX %x:%lX %lx %d %ld %lu", &dummy, &myladdr, &mylport, &myraddr, &myrport, &dummy, &dummy, &dummy, &dummy, &dummy, &dummy, &euid, &dummy, &ino);
        if(nra >= 12)
        {
          if(mylport == r_lport && myladdr == r_laddr)
          {
            if(!(ino == 0ul) && myrport == r_rport && myraddr == r_raddr)
            {
              if(!(euid == 0) || !(ino == 0ul) || !(nra >= 14))
              {
                kp->euid = (unsigned int)euid;
                status = 1;
              }

            }

          }

        }

      }
      while((_Bool)1);
      return status;
    }
  }
}

// ka_open
// file kernel.h line 58
extern signed int ka_open(void **misc)
{
  struct kainfo *kp;
  void *return_value_s_malloc_1;
  return_value_s_malloc_1=s_malloc(sizeof(struct kainfo) /*16ul*/ );
  kp = (struct kainfo *)return_value_s_malloc_1;
  kp->seq = (unsigned int)0;
  kp->nlfd=socket(16, 2, 4);
  if(!(kp->nlfd >= 0))
  {
    syslog(6, "netlink failed, fallback to /proc/net/tcp: %m");
    kp->proc_net_tcp=fopen("/proc/net/tcp", "r");
    if(!(kp->proc_net_tcp == ((struct _IO_FILE *)NULL)))
      goto out;

    syslog(3, "fopen(\"/proc/net/tcp\", \"r\"): %m");
    return -1;
  }

  else
  {

  out:
    ;
    *misc = (void *)kp;
    return 0;
  }
}

// kernel_alloc
// file kernel.h line 47
extern struct kernel * kernel_alloc(void)
{
  struct kernel *kp;
  void *return_value_buffer_get_1;
  return_value_buffer_get_1=buffer_get(&kbuf_free);
  kp = (struct kernel *)return_value_buffer_get_1;
  avail_init(&kp->av);
  kp->status = -1;
  kp->euid = (unsigned int)-1;
  kp->ruid = (unsigned int)-1;
  kp->pid = (signed int)-1;
  kp->cmd = (char *)(void *)0;
  kp->argv = (char *)(void *)0;
  return kp;
}

// kernel_free
// file kernel.h line 48
extern void kernel_free(struct kernel *kp)
{
  s_free((void *)kp->cmd);
  s_free((void *)kp->argv);
  buffer_put(&kbuf_free, (void *)kp);
}

// kernel_init
// file kernel.h line 50
extern signed int kernel_init(void)
{
  signed int i;
  unsigned long int tid;
  struct kernel *kp;
  signed int return_value_buffer_init_1;
  return_value_buffer_init_1=buffer_init(&kbuf_request, kernel_buffers);
  if(!(return_value_buffer_init_1 >= 0))
  {
    syslog(3, "buffer_create(%d) failed: %m", kernel_buffers);
    return -1;
  }

  else
  {
    signed int return_value_buffer_init_2;
    return_value_buffer_init_2=buffer_init(&kbuf_free, kernel_buffers * 2);
    if(!(return_value_buffer_init_2 >= 0))
    {
      syslog(3, "buffer_create(%d) failed: %m", kernel_buffers * 2);
      return -1;
    }

    else
    {
      i = 0;
      for( ; !(i >= 2 * kernel_buffers); i = i + 1)
      {
        void *return_value_s_malloc_3;
        return_value_s_malloc_3=s_malloc(sizeof(struct kernel) /*160ul*/ );
        kp = (struct kernel *)return_value_s_malloc_3;
        buffer_put(&kbuf_free, (void *)kp);
      }
      i = 0;
      for( ; !(i >= kernel_threads); i = i + 1)
      {
        void *key = (void *)0;
        signed int return_value_ka_open_4;
        return_value_ka_open_4=ka_open(&key);
        if(!(return_value_ka_open_4 >= 0))
          return -1;

        pthread_create(&tid, (const union pthread_attr_t *)(void *)0, kernel_thread, key);
      }
      return 0;
    }
  }
}

// kernel_query
// file kernel.h line 51
extern void kernel_query(struct kernel *kp)
{
  buffer_put(&kbuf_request, (void *)kp);
  avail_wait(&kp->av);
}

// kernel_thread
// file kernel.c line 80
static void * kernel_thread(void *vp)
{
  struct kernel *kp;
  signed int attempt;
  char buf1[32l];
  if(!(debug == 0))
    fprintf(stderr, "kernel_thread() started\n");

  void *return_value_buffer_get_1;
  unsigned short int tmp_statement_expression_3;
  unsigned short int tmp_statement_expression_5;
  signed int tmp_post_6;
  do
  {
    return_value_buffer_get_1=buffer_get(&kbuf_request);
    kp = (struct kernel *)return_value_buffer_get_1;
    if(kp == ((struct kernel *)NULL))
      break;

    if(!(debug == 0))
    {
      const char *return_value_s_inet_ntox_2;
      return_value_s_inet_ntox_2=s_inet_ntox(&kp->remote, buf1, sizeof(char [32l]) /*32ul*/ );
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)kp->remote.sin_port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_3 = __v;
      fprintf(stderr, "remote = %s:%d\n", return_value_s_inet_ntox_2, tmp_statement_expression_3);
      const char *return_value_s_inet_ntox_4;
      return_value_s_inet_ntox_4=s_inet_ntox(&kp->local, buf1, sizeof(char [32l]) /*32ul*/ );
      unsigned short int kernel_thread__1__1__1__2____v;
      unsigned short int kernel_thread__1__1__1__2____x = (unsigned short int)kp->local.sin_port;
      asm("rorw _8, %w0" : "=r"(kernel_thread__1__1__1__2____v) : "0"(kernel_thread__1__1__1__2____x) : "cc");
      tmp_statement_expression_5 = kernel_thread__1__1__1__2____v;
      fprintf(stderr, "local = %s:%d\n", return_value_s_inet_ntox_4, tmp_statement_expression_5);
    }

    attempt = 0;
    do
    {
      tmp_post_6 = attempt;
      attempt = attempt + 1;
      if(tmp_post_6 >= kernel_attempts)
        break;

      kp->status=ka_lookup(vp, kp);
      if(!(debug == 0))
        fprintf(stderr, "ka_lookup(), attempt = %d, status = %d\n", attempt, kp->status);

      if(kp->status >= 0)
        break;

      if((1 & attempt) == 1 && attempt >= 3)
        sleep((unsigned int)1);

    }
    while((_Bool)1);
    avail_signal(&kp->av);
  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "kernel_thread() terminating\n");

  return (void *)0;
}

// kvm_dummy
// file pkvm.c line 160
signed int kvm_dummy(void)
{
  return -1;
}

// main
// file main.c line 123
signed int main(signed int argc, char **argv)
{
  signed int c;
  signed int code = 3 << 3;
  signed int socket_type = -1;
  signed int init_mode = 0;
  signed int log_header = 0;
  if(!(*argv == ((char *)NULL)))
  {
    char *cp;
    cp=strrchr(argv[(signed long int)0], 47);
    if(!(cp == ((char *)NULL)))
      argv0=s_strdup(cp + (signed long int)1);

    else
      argv0=s_strdup(argv[(signed long int)0]);
  }

  signal(22, (void (*)(signed int))1);
  signal(13, (void (*)(signed int))1);
  s_openlog(argv0, 0x01 | 0x04, code);
  socket_type=socktype(0);
  if(!(debug == 0))
    fprintf(stderr, "socktype = %d\n", socket_type);

  if(socket_type == 1 || socket_type == 2)
    listen_sock = 0;

  conf_parse("/etc/identd.conf", 1);
  signed int return_value_str2port_1;
  signed int return_value_str2int_2;
  signed int return_value_str2gid_3;
  signed int return_value_str2uid_4;
  signed int return_value_conf_parse_5;
  signed int return_value_str2int_6;
  do
  {
    c=getopt(argc, argv, "lNVEdhbwiIemnop:u:g:t:C:P:K:L:");
    if(c == -1)
      break;

    switch(c)
    {
      case 69:
      {
        encrypt_flag = 1;
        break;
      }
      case 110:
      {
        uidonly_flag = 1;
        break;
      }
      case 100:
      {
        debug = debug + 1;
        break;
      }
      case 104:
      {
        usage(stdout);
        return 0;
      }
      case 101:
      {
        extensions_enabled = 1;
        break;
      }
      case 109:
      {
        multiquery_enabled = 1;
        break;
      }
      case 119:
      {
        listen_sock = 0;
        socket_type = 1;
        break;
      }
      case 105:
      {
        listen_sock = 0;
        socket_type = 2;
        break;
      }
      case 73:
      {
        listen_sock = -1;
        socket_type = 0;
        init_mode = 1;
        break;
      }
      case 98:
      {
        listen_sock = -1;
        socket_type = 0;
        break;
      }
      case 108:
      {
        log_header = 1;
        break;
      }
      case 112:
      {
        return_value_str2port_1=str2port(optarg, &listen_port);
        if(!(return_value_str2port_1 >= 0))
        {
          syslog(3, "invalid argument to '-p': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-p': %s", argv0, optarg);

          return 1;
        }

        break;
      }
      case 116:
      {
        return_value_str2int_2=str2int(optarg, &request_timeout);
        if(!(return_value_str2int_2 >= 0))
        {
          syslog(3, "invalid argument to '-t': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-t': %s", argv0, optarg);

          return 1;
        }

        break;
      }
      case 103:
      {
        return_value_str2gid_3=str2gid(optarg, &server_gid);
        if(!(return_value_str2gid_3 >= 0))
        {
          syslog(3, "invalid argument to '-g': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-g': %s", argv0, optarg);

          return 1;
        }

        break;
      }
      case 117:
      {
        return_value_str2uid_4=str2uid(optarg, &server_uid, &server_gid);
        if(!(return_value_str2uid_4 >= 0))
        {
          syslog(3, "invalid argument to '-u': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-u': %s", argv0, optarg);

          return 1;
        }

        break;
      }
      case 76:
      {
        code=syslog_str2fac(optarg);
        if(!(code >= 0))
        {
          syslog(3, "invalid argument to '-L': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-L': %s", argv0, optarg);

          return 1;
        }

        closelog();
        s_openlog(argv0, 0x01 | 0x04, code);
        break;
      }
      case 67:
      {
        return_value_conf_parse_5=conf_parse(optarg, 0);
        if(!(return_value_conf_parse_5 >= 0))
        {
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: error parsing config file: %s\n", argv[(signed long int)0], optarg);

          return 1;
        }

        break;
      }
      case 80:
      {
        pidfile_path=s_strdup(optarg);
        break;
      }
      case 75:
      {
        return_value_str2int_6=str2int(optarg, &kernel_threads);
        if(!(return_value_str2int_6 >= 0))
        {
          syslog(3, "invalid argument to '-K': %s", optarg);
          if(socket_type == 0 || socket_type == -1)
            fprintf(stderr, "%s: invalid argument to '-K': %s", argv0, optarg);

          return 1;
        }

        break;
      }
      case 111:
      {
        opsys = "OTHER";
        break;
      }
      case 78:
      {
        noident_flag = 1;
        break;
      }
      case 86:
      {
        program_header(stdout);
        exit(0);
      }
      default:
      {
        if(socket_type == 0 || socket_type == -1)
          usage(stderr);

        else
          syslog(3, "invalid command line option: %s", argv[(signed long int)optind]);
        return 1;
      }
    }
  }
  while((_Bool)1);
  if(!(debug == 0))
    program_header(stderr);

  signed int return_value_getppid_8;
  signed int return_value_request_run_12;
  if(socket_type == -1)
  {
    syslog(3, "unable to autodetect socket type");
    fprintf(stderr, "%s: unable to autodetect socket type\n", argv0);
    return 1;
  }

  else
  {
    signed int return_value_ka_init_7;
    return_value_ka_init_7=ka_init();
    if(!(return_value_ka_init_7 == 0))
    {
      syslog(3, "OS version mismatch - compiled for %s", (const void *)osinfo_build);
      if(socket_type == 0)
        fprintf(stderr, "%s: OS version mismatch - compiled for: %s\n", argv[(signed long int)0], (const void *)osinfo_build);

      return 1;
    }

    else
    {
      if(debug == 0)
      {
        return_value_getppid_8=getppid();
        if(!(return_value_getppid_8 == 1))
        {
          if(init_mode == 0)
          {
            if(!(socket_type == 2))
            {
              if(!(listen_sock >= 0))
                become_daemon();

            }

          }

        }

      }

      if(!(log_header == 0))
        syslog(6, "started");

      else
        syslog(7, "started");
      pthread_attr_init(&cattr_detached);
      pthread_attr_setdetachstate(&cattr_detached, 1);
      if(!(socket_type == 2))
      {
        if(debug == 0 && !(pidfile_path == ((char *)NULL)))
          pidfile_create(pidfile_path);

        if(!(listen_sock >= 0))
          request_timeout = 0;

        signed int return_value_server_init_9;
        return_value_server_init_9=server_init();
        if(!(return_value_server_init_9 >= 0))
        {
          if(!(debug == 0))
            fprintf(stderr, "%s: failed binding to the TCP/IP socket\n", argv[(signed long int)0]);

          goto Exit;
        }

      }

      if(!(encrypt_flag == 0))
      {
        signed int return_value_pdes_init_10;
        return_value_pdes_init_10=pdes_init(encrypt_keyfile);
        if(!(return_value_pdes_init_10 >= 0))
        {
          syslog(3, "encryption could not be initalized: %m");
          if(!(debug == 0))
          {
            fprintf(stderr, "%s: encryption could not be initialized: ", argv[(signed long int)0]);
            perror("");
          }

          goto Exit;
        }

      }

      drop_root_privs();
      signed int return_value_kernel_init_11;
      return_value_kernel_init_11=kernel_init();
      if(!(return_value_kernel_init_11 >= 0))
      {
        if(!(debug == 0))
          fprintf(stderr, "%s: failed opening kernel devices\n", argv[(signed long int)0]);

      }

      else
      {
        timeout_init();
        request_init();
        if(!(socket_type == 2))
        {
          if(!(debug == 0))
            fprintf(stderr, "entering server main loop\n");

          server_run();
        }

        else
        {
          return_value_request_run_12=request_run(listen_sock, 1);
          return return_value_request_run_12;
        }
      }

    Exit:
      ;
      syslog(7, "terminating");
      return 1;
    }
  }
}

// netlink_lookup
// file k_linux.c line 80
static signed int netlink_lookup(struct kainfo *kip, struct kernel *kp)
{
  signed int status;
  /* tag-#anon#lUN[lSYM#tag-inet_diag_req#'req'||lSYM#tag-inet_diag_msg#'rsp'|] */
union anonymous_3
{
  // req
  struct inet_diag_req req;
  // rsp
  struct inet_diag_msg rsp;
};

/* */
  ;
  /* tag-#anon#lST[lSYM#tag-nlmsghdr#'nlh'||lSYM#tag-#anon#lUN[lSYM#tag-inet_diag_req#'req'||lSYM#tag-inet_diag_msg#'rsp'|]#'u'|] */
struct anonymous_4
{
  // nlh
  struct nlmsghdr nlh;
  // u
  union anonymous_3 u;
};

/* */
  ;
  struct anonymous_4 buf;
  struct sockaddr_nl addr;
  memset(&buf, 0, sizeof(struct anonymous_4) /*88ul*/ );
  buf.nlh.nlmsg_len = (unsigned int)((sizeof(struct inet_diag_req) /*60ul*/  + (unsigned long int)(signed int)((sizeof(struct nlmsghdr) /*16ul*/  + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1)) + (unsigned long int)4U) - (unsigned long int)1 & (unsigned long int)~(4U - (unsigned int)1));
  buf.nlh.nlmsg_type = (unsigned short int)18;
  buf.nlh.nlmsg_flags = (unsigned short int)1;
  kip->seq = kip->seq + 1u;
  buf.nlh.nlmsg_seq = kip->seq;
  buf.u.req.idiag_family = (unsigned char)2;
  buf.u.req.id.idiag_dport = kp->remote.sin_port;
  buf.u.req.id.idiag_sport = kp->local.sin_port;
  buf.u.req.id.idiag_dst[(signed long int)0] = kp->remote.sin_addr.s_addr;
  buf.u.req.id.idiag_src[(signed long int)0] = kp->local.sin_addr.s_addr;
  buf.u.req.id.idiag_cookie[(signed long int)0] = ~0U;
  buf.u.req.id.idiag_cookie[(signed long int)1] = ~0U;
  signed long int return_value_write_1;
  return_value_write_1=write(kip->nlfd, (const void *)&buf, (unsigned long int)buf.nlh.nlmsg_len);
  status = (signed int)return_value_write_1;
  _Bool tmp_if_expr_2;
  if(!(status >= 0))
  {
    syslog(3, "netlink_lookup: write failed: %m");
    return 3;
  }

  else
  {
    do
    {
      unsigned int alen = (unsigned int)sizeof(struct sockaddr_nl) /*12ul*/ ;
      signed long int return_value_recvfrom_3;
      return_value_recvfrom_3=recvfrom(kip->nlfd, (void *)&buf, sizeof(struct anonymous_4) /*88ul*/ , 0, (struct sockaddr *)(void *)&addr, &alen);
      status = (signed int)return_value_recvfrom_3;
      if(!(status >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 105)
          return -1;

        syslog(3, "netlink_lookup: recvfrom failed: %m");
        return 3;
      }

      if(!(addr.nl_pid == 0u))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = buf.nlh.nlmsg_seq != kip->seq ? (_Bool)1 : (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(!((signed int)buf.nlh.nlmsg_type == 18))
      return 0;

    else
      if(!((signed int)buf.u.rsp.idiag_state == 1))
        return 0;

      else
      {
        kp->euid = buf.u.rsp.idiag_uid;
        return 1;
      }
  }
}

// osinfo_get
// file support.c line 39
extern char * osinfo_get(char *buf)
{
  struct utsname ub;
  signed int return_value_uname_1;
  return_value_uname_1=uname(&ub);
  if(!(return_value_uname_1 >= 0))
    return (char *)(void *)0;

  else
  {
    sprintf(buf, "%s %s", (const void *)ub.sysname, (const void *)ub.release);
    return buf;
  }
}

// pdes_encrypt
// file pdes.h line 41
extern signed int pdes_encrypt(struct kernel *kp, char *result)
{
  union data r;
  signed int i;
  signed int j;
  signed long int bt;
  signed long int return_value_s_random_1;
  return_value_s_random_1=s_random();
  r.fields.random = (unsigned short int)return_value_s_random_1;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_3;
  if(kp->ruid == 4294967295u)
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)kp->euid;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_2 = __v;
    r.fields.uid = tmp_statement_expression_2;
  }

  else
  {
    unsigned short int pdes_encrypt__1__2____v;
    unsigned short int pdes_encrypt__1__2____x = (unsigned short int)kp->ruid;
    asm("rorw _8, %w0" : "=r"(pdes_encrypt__1__2____v) : "0"(pdes_encrypt__1__2____x) : "cc");
    tmp_statement_expression_3 = pdes_encrypt__1__2____v;
    r.fields.uid = tmp_statement_expression_3;
  }
  time(&bt);
  r.fields.date=__bswap_32_link1((unsigned int)bt);
  r.fields.ip_local = kp->local.sin_addr.s_addr;
  r.fields.ip_remote = kp->remote.sin_addr.s_addr;
  r.fields.port_local = kp->local.sin_port;
  r.fields.port_remote = kp->remote.sin_port;
  r.fields.checksum = (unsigned int)0;
  i = 1;
  for( ; !(i >= 6); i = i + 1)
    r.longs[(signed long int)0] = r.longs[(signed long int)0] ^ r.longs[(signed long int)i];
  DES_ecb_encrypt((unsigned char (*)[8l])&r.longs[(signed long int)0], (unsigned char (*)[8l])&r.longs[(signed long int)0], &sched, 1);
  r.longs[(signed long int)2] = r.longs[(signed long int)2] ^ r.longs[(signed long int)0];
  r.longs[(signed long int)3] = r.longs[(signed long int)3] ^ r.longs[(signed long int)1];
  DES_ecb_encrypt((unsigned char (*)[8l])&r.longs[(signed long int)2], (unsigned char (*)[8l])&r.longs[(signed long int)2], &sched, 1);
  r.longs[(signed long int)4] = r.longs[(signed long int)4] ^ r.longs[(signed long int)2];
  r.longs[(signed long int)5] = r.longs[(signed long int)5] ^ r.longs[(signed long int)3];
  DES_ecb_encrypt((unsigned char (*)[8l])&r.longs[(signed long int)4], (unsigned char (*)[8l])&r.longs[(signed long int)4], &sched, 1);
  i = 0;
  j = 0;
  for( ; !(i >= 24); j = j + 4)
  {
    result[(signed long int)j] = to_asc[(signed long int)(63 & (signed int)r.chars[(signed long int)i] >> 2)];
    result[(signed long int)(j + 1)] = to_asc[(signed long int)(63 & ((signed int)r.chars[(signed long int)i] << 4) + ((signed int)r.chars[(signed long int)(i + 1)] >> 4))];
    result[(signed long int)(j + 2)] = to_asc[(signed long int)(63 & ((signed int)r.chars[(signed long int)(i + 1)] << 2) + ((signed int)r.chars[(signed long int)(i + 2)] >> 6))];
    result[(signed long int)(j + 3)] = to_asc[(signed long int)(63 & (signed int)r.chars[(signed long int)(i + 2)])];
    i = i + 3;
  }
  result[(signed long int)32] = (char)0;
  return 0;
}

// pdes_init
// file pdes.h line 40
extern signed int pdes_init(char *keyfile)
{
  char keybuf[1025l];
  signed int fd;
  signed int res;
  unsigned char key_bin[8l];
  if(keyfile == ((char *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  fd=s_open(keyfile, 00);
  signed long int return_value_s_read_4;
  if(!(fd >= 0))
    return -1;

  else
  {
    signed long int return_value_s_read_2;
    return_value_s_read_2=s_read(fd, keybuf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1);
    res = (signed int)return_value_s_read_2;
    if(!((unsigned long int)res == 1024ul))
    {
      if(!(debug == 0))
        fprintf(stderr, "pdes: First key was not complete (%d bytes)\n", res);

      s_close(fd);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 22;
      return -1;
    }

    do
    {
      return_value_s_read_4=s_read(fd, keybuf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1);
      res = (signed int)return_value_s_read_4;
      if(!((unsigned long int)res == 1024ul))
        break;

    }
    while((_Bool)1);
    s_close(fd);
    if(res >= 1 && !((unsigned long int)res == 1024ul))
    {
      if(!(debug == 0))
        fprintf(stderr, "pdes: Last key was not complete (%d bytes)\n", res);

      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 22;
      return -1;
    }

    keybuf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0;
    DES_string_to_key(keybuf, &key_bin);
    DES_set_key(&key_bin, &sched);
    return 0;
  }
}

// pidfile_create
// file daemon.h line 19
extern void pidfile_create(const char *path)
{
  signed int fd;
  char buf[64l];
  fd=s_open(path, 01 | 0100 | 01000, 0644);
  unsigned long int return_value_strlen_2;
  if(!(fd >= 0))
    syslog(3, "s_open(\"%s\", O_WRONLY): %m", path);

  else
  {
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    s_snprintf(buf, sizeof(char [64l]) /*64ul*/ , "%ld\n", (signed long int)return_value_getpid_1);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(buf);
    signed long int return_value_s_write_4;
    return_value_s_write_4=s_write(fd, buf, return_value_strlen_3);
    if(!(return_value_s_write_4 >= 0l))
    {
      return_value_strlen_2=strlen(buf);
      syslog(3, "s_write(fd, ..., %d): %m", fd, return_value_strlen_2);
    }

    s_close(fd);
  }
}

// program_header
// file main.c line 86
static void program_header(struct _IO_FILE *fp)
{
  fprintf(fp, "[Pidentd, version %s (compiled for %s) - %s %s]\n", (const void *)server_version, (const void *)osinfo_build, (const void *)"Jan 26 2016", (const void *)"02:19:43");
}

// random_lock_init
// file safeio.c line 233
static void random_lock_init(void)
{
  unsigned int seed;
  pthread_mutex_init(&random_lock, (const union anonymous_1 *)(void *)0);
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  seed = (unsigned int)return_value_time_1;
  srandom(seed);
}

// request_init
// file request.h line 34
extern signed int request_init(void)
{
  pthread_mutex_init(&requests_mtx, (const union anonymous_1 *)(void *)0);
  pthread_cond_init(&requests_cv, (const union anonymous_1 *)(void *)0);
  requests_cur = 0;
  return 0;
}

// request_run
// file request.h line 35
extern signed int request_run(signed int fd, signed int nofork)
{
  struct request *rip;
  unsigned long int tid;
  void *return_value_s_malloc_1;
  return_value_s_malloc_1=s_malloc(sizeof(struct request) /*24ul*/ );
  rip = (struct request *)return_value_s_malloc_1;
  rip->fd = fd;
  rip->addr_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int return_value_s_getpeername_2;
  return_value_s_getpeername_2=s_getpeername(fd, (struct sockaddr *)&rip->addr, &rip->addr_len);
  if(!(return_value_s_getpeername_2 >= 0))
  {
    syslog(3, "s_getpeername(%d): %m", fd);
    s_free((void *)rip);
    close(fd);
    return 1;
  }

  else
  {
    if(!(nofork == 0))
    {
      request_thread((void *)rip);
      return 0;
    }

    else
    {
      if(requests_max >= 1)
      {
        pthread_mutex_lock(&requests_mtx);
        while(requests_cur >= requests_max)
          pthread_cond_wait(&requests_cv, &requests_mtx);
        requests_cur = requests_cur + 1;
        pthread_mutex_unlock(&requests_mtx);
      }

      signed int return_value_pthread_create_3;
      return_value_pthread_create_3=pthread_create(&tid, &cattr_detached, request_thread, (void *)rip);
      if(!(return_value_pthread_create_3 >= 0))
      {
        syslog(3, "pthread_create(request_thread) failed: %m");
        return 1;
      }

    }
    return 0;
  }
}

// request_thread
// file request.c line 167
extern void * request_thread(void *vp)
{
  struct request *rp = (struct request *)vp;
  struct timeout *tp = (struct timeout *)(void *)0;
  char buf[1024l];
  unsigned long int len;
  signed long int got;
  signed long int pos;
  if(!(debug == 0))
    fprintf(stderr, "request_thread: fd#%d: start\n", rp->fd);

  len = (unsigned long int)0;
  pos = (signed long int)0;
  if(request_timeout >= 1)
    tp=timeout_create(request_timeout, timeout_handler, (void *)rp);

  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  while((_Bool)1)
  {
    if(len >= 1023ul)
    {
      syslog(5, "request_thread: fd #%d: input buffer full: closing down", rp->fd);
      goto Exit;
    }

    got=s_read(rp->fd, buf + (signed long int)len, (sizeof(char [1024l]) /*1024ul*/  - len) - (unsigned long int)1);
    if(!(got >= 0l))
    {
      if(!(debug == 0))
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fprintf(stderr, "request_thread: read(%d, ..., %d) failed: %s", rp->fd, (sizeof(char [1024l]) /*1024ul*/  - len) - (unsigned long int)1, return_value_strerror_2);
      }

      break;
    }

    if(got == 0l)
    {
      if(!(debug == 0))
        fprintf(stderr, "s_read(%d, ...): returned 0\n", rp->fd);

      break;
    }

    len = len + (unsigned long int)got;
    for( ; !((unsigned long int)pos >= len); pos = pos + 1l)
    {
      if((signed int)buf[pos] == 10)
        break;

      if((signed int)buf[pos] == 13)
        break;

    }
    if(got == 0l || !((unsigned long int)pos >= len))
    {
      if(got >= 1l || pos >= 1l)
      {
        buf[pos] = (char)0;
        signed int return_value_handle_request_3;
        return_value_handle_request_3=handle_request(rp->fd, buf, &rp->addr);
        if(!(return_value_handle_request_3 == 0))
          break;

        if(multiquery_enabled == 0)
          break;

        if(!(tp == ((struct timeout *)NULL)))
          timeout_reset(tp, request_timeout);

        pos = pos + 1l;
      }

      for( ; !((unsigned long int)pos >= len); pos = pos + 1l)
      {
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)buf[pos]]) == 0)
          break;

      }
      if(!((unsigned long int)pos >= len))
        memcpy((void *)buf, (const void *)(buf + pos), len - (unsigned long int)pos);

      pos = (signed long int)(len - (unsigned long int)pos);
      len = (unsigned long int)pos;
    }

    if(!(got >= 1l))
      break;

  }

Exit:
  ;
  if(!(tp == ((struct timeout *)NULL)))
    timeout_cancel(tp);

  if(!(debug == 0))
    fprintf(stderr, "request_thread: fd#%d: terminating\n", rp->fd);

  s_close(rp->fd);
  s_free((void *)rp);
  if(requests_max >= 1)
  {
    pthread_mutex_lock(&requests_mtx);
    if(requests_cur == requests_max)
      pthread_cond_signal(&requests_cv);

    requests_cur = requests_cur - 1;
    pthread_mutex_unlock(&requests_mtx);
  }

  return (void *)0;
}

// s_abort
// file safeio.c line 33
extern void s_abort(void)
{
  signed int *p = (signed int *)(void *)0;
  *p = 4711;
  abort();
}

// s_accept
// file safeio.h line 28
extern signed int s_accept(signed int fd, struct sockaddr *sin, unsigned int *len)
{
  signed int new_fd;
  signed int *return_value___errno_location_1;
  do
  {
    new_fd=accept(fd, sin, len);
    if(new_fd >= 0)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return new_fd;
}

// s_close
// file safeio.h line 26
extern signed int s_close(signed int fd)
{
  signed int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=close(fd);
    if(code >= 0)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_free
// file safeio.h line 33
extern void s_free(void *p)
{
  if(!(p == NULL))
    free(p);

}

// s_getpeername
// file safeio.h line 30
extern signed int s_getpeername(signed int fd, struct sockaddr *sin, unsigned int *len)
{
  signed int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=getpeername(fd, sin, len);
    if(code >= 0)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_getpwnam_r
// file support.c line 176
extern signed int s_getpwnam_r(const char *name, struct passwd *pwd, char *buffer, unsigned long int bufsize, struct passwd **result)
{
  signed int code;
  memset((void *)pwd, 0, sizeof(struct passwd) /*48ul*/ );
  memset((void *)buffer, 0, bufsize);
  do
  {
    code=getpwnam_r(name, pwd, buffer, bufsize, result);
    if(!(code == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_getpwuid_r
// file support.h line 38
extern signed int s_getpwuid_r(unsigned int uid, struct passwd *pwd, char *buffer, unsigned long int bufsize, struct passwd **result)
{
  signed int code;
  memset((void *)pwd, 0, sizeof(struct passwd) /*48ul*/ );
  memset((void *)buffer, 0, bufsize);
  do
  {
    code=getpwuid_r(uid, pwd, buffer, bufsize, result);
    if(!(code == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_getsockname
// file safeio.h line 29
extern signed int s_getsockname(signed int fd, struct sockaddr *sin, unsigned int *len)
{
  signed int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=getsockname(fd, sin, len);
    if(code >= 0)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_inet_ntox
// file support.h line 48
extern const char * s_inet_ntox(struct sockaddr_in *ia, char *buf, unsigned long int bufsize)
{
  unsigned char *bp = (unsigned char *)(char *)&ia->sin_addr;
  signed int return_value_s_snprintf_1;
  return_value_s_snprintf_1=s_snprintf(buf, bufsize, "%u.%u.%u.%u", bp[(signed long int)0], bp[(signed long int)1], bp[(signed long int)2], bp[(signed long int)3]);
  if(!(return_value_s_snprintf_1 >= 0))
    return (const char *)(void *)0;

  else
    return buf;
}

// s_malloc
// file safeio.h line 32
extern void * s_malloc(unsigned long int size)
{
  void *p;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  p = (void *)return_value_malloc_1;
  if(p == NULL)
  {
    if(!(debug == 0))
      fprintf(stderr, "s_malloc(%lu) failed - aborting\n", (unsigned long int)size);

    syslog(3, "malloc(%lu): %m", (unsigned long int)size);
    s_abort();
  }

  memset(p, 0, size);
  return p;
}

// s_open
// file safeio.h line 22
extern signed int s_open(const char *path, signed int oflag, ...)
{
  signed int s;
  unsigned int mode = (unsigned int)0;
  if(!((0100 & oflag) == 0))
  {
    __builtin_va_list ap;
    va_start(ap, oflag);
    signed int return_value_gcc_builtin_va_arg_1;
    return_value_gcc_builtin_va_arg_1=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg_1));
    mode = (unsigned int)return_value_gcc_builtin_va_arg_1;
    va_end(ap);
  }

  signed int *return_value___errno_location_2;
  do
  {
    s=open(path, oflag, mode);
    if(s >= 0)
      break;

    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 4))
      break;

  }
  while((_Bool)1);
  signed int *return_value___errno_location_3;
  _Bool tmp_if_expr_5;
  signed int *return_value___errno_location_4;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  _Bool tmp_if_expr_9;
  signed int *return_value___errno_location_8;
  if(!(s >= 0))
  {
    return_value___errno_location_3=__errno_location();
    if(*return_value___errno_location_3 == 24)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 23 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value___errno_location_6=__errno_location();
      tmp_if_expr_7 = *return_value___errno_location_6 == 12 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value___errno_location_8=__errno_location();
      tmp_if_expr_9 = *return_value___errno_location_8 == 63 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      syslog(4, "s_open(\"%s\", 0%o): %m", path, oflag);

  }

  return s;
}

// s_openlog
// file support.h line 43
extern void s_openlog(const char *ident, signed int logopt, signed int facility)
{
  openlog(ident, logopt, facility);
}

// s_poll
// file safeio.h line 42
extern signed int s_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout)
{
  signed int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=poll(ufds, (unsigned long int)nfds, timeout);
    if(!(code == -1))
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_random
// file safeio.c line 249
extern signed long int s_random(void)
{
  signed long int res;
  pthread_once(&random_once, random_lock_init);
  pthread_mutex_lock(&random_lock);
  res=random();
  pthread_mutex_unlock(&random_lock);
  return res;
}

// s_read
// file safeio.h line 25
extern signed long int s_read(signed int fd, char *buf, unsigned long int len)
{
  signed long int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=read(fd, (void *)buf, len);
    if(code >= 0l)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// s_snprintf
// file safeio.h line 38
extern signed int s_snprintf(char *buf, unsigned long int bufsize, const char *format, ...)
{
  void **ap;
  signed int retcode;
  ap = (void **)&format;
  if(!(bufsize >= 1ul))
  {
    if(!(debug == 0))
      fprintf(stderr, "s_snprintf(..., %d, ...): illegal bufsize\n", bufsize);

    syslog(3, "s_snprintf(..., %d, ...): illegal bufsize", bufsize);
    s_abort();
  }

  buf[(signed long int)(bufsize - (unsigned long int)1)] = (char)0;
  retcode=vsnprintf(buf, bufsize, format, ap);
  if(debug >= 4)
    fprintf(stderr, "s_snprintf(%08lx, %d, \"%s\", ...) = %d\n", (unsigned long int)buf, bufsize, format, retcode);

  if(retcode >= 1)
  {
    if(!((signed int)buf[-1l + (signed long int)bufsize] == 0) || !(bufsize + 18446744073709551615ul >= (unsigned long int)retcode))
    {
      if(!(debug == 0))
        fprintf(stderr, "s_snprintf(..., %d, ...) = %d: buffer overrun\n", bufsize, retcode);

      syslog(3, "s_snprintf(..., %d, ...) = %d: buffer overrun\n", bufsize, retcode);
      s_abort();
    }

  }

  ap = ((void **)NULL);
  return retcode;
}

// s_strcasecmp
// file support.c line 332
extern signed int s_strcasecmp(const char *s1, const char *s2)
{
  signed int i;
  do
  {
    i = (signed int)*s1 - (signed int)*s2;
    if(!(i == 0))
      break;

    if(*s1 == 0)
      break;

    s1 = s1 + 1l;
    s2 = s2 + 1l;
  }
  while((_Bool)1);
  return i;
}

// s_strdup
// file safeio.h line 34
extern char * s_strdup(const char *s)
{
  char *ns;
  unsigned long int len;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    len = return_value_strlen_1 + (unsigned long int)1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(len);
    ns = (char *)return_value_malloc_2;
    if(ns == ((char *)NULL))
    {
      syslog(3, "strdup(): malloc(%lu): %m", (unsigned long int)len);
      s_abort();
    }

    memcpy((void *)ns, (const void *)s, len);
    return ns;
  }
}

// s_strtok_r
// file support.h line 28
extern char * s_strtok_r(char *s, const char *d, char **bp)
{
  char *cp;
  unsigned long int tmp_statement_expression_1;
  char *tmp_statement_expression_3;
  void *return_value___rawmemchr_5;
  char *tmp_post_6;
  if(bp == ((char **)NULL) || d == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(s == ((char *)NULL))
      s = *bp;

    if(s == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      char __a0;
      char s_strtok_r__1__1____a1;
      char s_strtok_r__1__1____a2;
      unsigned long int return_value___builtin_strspn_2;
      return_value___builtin_strspn_2=__builtin_strspn(s, d);
      tmp_statement_expression_1 = return_value___builtin_strspn_2;
      s = s + (signed long int)tmp_statement_expression_1;
      if((signed int)*s == 0)
        return (char *)(void *)0;

      else
      {
        cp = s;
        char s_strtok_r__1__2____a0;
        char __a1;
        char __a2;
        char *return_value___builtin_strpbrk_4;
        return_value___builtin_strpbrk_4=__builtin_strpbrk(cp, d);
        tmp_statement_expression_3 = return_value___builtin_strpbrk_4;
        s = tmp_statement_expression_3;
        if(s == ((char *)NULL))
        {
          return_value___rawmemchr_5=__rawmemchr((const void *)cp, 0);
          *bp = (char *)return_value___rawmemchr_5;
        }

        else
        {
          tmp_post_6 = s;
          s = s + 1l;
          *tmp_post_6 = (char)0;
          *bp = s;
        }
        return cp;
      }
    }
  }
}

// s_write
// file safeio.h line 24
extern signed long int s_write(signed int fd, const char *buf, unsigned long int len)
{
  signed long int code;
  signed int *return_value___errno_location_1;
  do
  {
    code=write(fd, (const void *)buf, len);
    if(code >= 0l)
      break;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 4))
      break;

  }
  while((_Bool)1);
  return code;
}

// send_error
// file send.h line 24
extern void send_error(signed int fd, signed int l_port, signed int r_port, const char *what, struct sockaddr_in *remote_addr)
{
  char buf[1024l];
  char buf2[32l];
  s_snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d , %d : ERROR : %s\r\n", l_port, r_port, what);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  s_write(fd, buf, return_value_strlen_1);
  const char *return_value_s_inet_ntox_2;
  if(result_syslog_level >= 0)
  {
    return_value_s_inet_ntox_2=s_inet_ntox(remote_addr, buf2, sizeof(char [32l]) /*32ul*/ );
    syslog(result_syslog_level, "reply to %s: %d , %d : ERROR: %s", return_value_s_inet_ntox_2, l_port, r_port, what);
  }

}

// send_result
// file send.h line 30
extern void send_result(signed int fd, struct kernel *kp)
{
  char buf[2048l];
  char pbuf[2048l];
  char buf2[32l];
  struct passwd pwb;
  struct passwd *pp = (struct passwd *)(void *)0;
  unsigned int uid;
  if(!(debug == 0))
    fprintf(stderr, "send_result(%d) - ruid = %ld, euid = %ld\n", fd, (signed long int)kp->ruid, (signed long int)kp->euid);

  if(kp->ruid == 4294967295u)
    uid = kp->euid;

  else
    uid = kp->ruid;
  if(uidonly_flag == 0 || !(noident_flag == 0))
    s_getpwuid_r(uid, &pwb, pbuf, sizeof(char [2048l]) /*2048ul*/ , &pp);

  signed int return_value_check_noident_3;
  unsigned short int tmp_statement_expression_1;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_4;
  unsigned short int tmp_statement_expression_5;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_strlen_10;
  unsigned short int tmp_statement_expression_6;
  unsigned short int tmp_statement_expression_7;
  unsigned short int tmp_statement_expression_8;
  unsigned short int tmp_statement_expression_9;
  const char *return_value_s_inet_ntox_13;
  unsigned long int return_value_strlen_14;
  if(!(pp == ((struct passwd *)NULL)) && !(noident_flag == 0))
  {
    return_value_check_noident_3=check_noident(pp->pw_dir);
    if(!(return_value_check_noident_3 == 1))
      goto __CPROVER_DUMP_L9;

    syslog(6, "User %s elected to use .noident", pp->pw_name);
    unsigned short int send_result__1__1__1____v;
    unsigned short int send_result__1__1__1____x = (unsigned short int)kp->local.sin_port;
    asm("rorw _8, %w0" : "=r"(send_result__1__1__1____v) : "0"(send_result__1__1__1____x) : "cc");
    tmp_statement_expression_1 = send_result__1__1__1____v;
    unsigned short int send_result__1__1__2____v;
    unsigned short int send_result__1__1__2____x = (unsigned short int)kp->remote.sin_port;
    asm("rorw _8, %w0" : "=r"(send_result__1__1__2____v) : "0"(send_result__1__1__2____x) : "cc");
    tmp_statement_expression_2 = send_result__1__1__2____v;
    send_error(fd, (signed int)tmp_statement_expression_1, (signed int)tmp_statement_expression_2, "HIDDEN-USER", &kp->remote);
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    if(!(encrypt_flag == 0))
    {
      char buffer[33l];
      pdes_encrypt(kp, buffer);
      unsigned short int send_result__1__2__1____v;
      unsigned short int send_result__1__2__1____x = (unsigned short int)kp->local.sin_port;
      asm("rorw _8, %w0" : "=r"(send_result__1__2__1____v) : "0"(send_result__1__2__1____x) : "cc");
      tmp_statement_expression_4 = send_result__1__2__1____v;
      unsigned short int send_result__1__2__2____v;
      unsigned short int send_result__1__2__2____x = (unsigned short int)kp->remote.sin_port;
      asm("rorw _8, %w0" : "=r"(send_result__1__2__2____v) : "0"(send_result__1__2__2____x) : "cc");
      tmp_statement_expression_5 = send_result__1__2__2____v;
      s_snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%d , %d : USERID : OTHER%s%s :[%s]\r\n", tmp_statement_expression_4, tmp_statement_expression_5, charset != (char *)(void *)0 ? " , " : "", charset != (char *)(void *)0 ? charset : "", (const void *)buffer);
    }

    else
    {
      if(uidonly_flag == 0 && !(pp == ((struct passwd *)NULL)))
      {
        return_value_strlen_10=strlen(pp->pw_name);
        tmp_if_expr_11 = return_value_strlen_10 < sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)128 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
      {
        unsigned short int send_result__1__3__1____v;
        unsigned short int send_result__1__3__1____x = (unsigned short int)kp->local.sin_port;
        asm("rorw _8, %w0" : "=r"(send_result__1__3__1____v) : "0"(send_result__1__3__1____x) : "cc");
        tmp_statement_expression_6 = send_result__1__3__1____v;
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)kp->remote.sin_port;
        asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression_7 = __v;
        s_snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%d , %d : USERID : %s%s%s :%s\r\n", tmp_statement_expression_6, tmp_statement_expression_7, opsys, charset != (char *)(void *)0 ? " , " : "", charset != (char *)(void *)0 ? charset : "", pp->pw_name);
      }

      else
      {
        unsigned short int send_result__1__4__1____v;
        unsigned short int send_result__1__4__1____x = (unsigned short int)kp->local.sin_port;
        asm("rorw _8, %w0" : "=r"(send_result__1__4__1____v) : "0"(send_result__1__4__1____x) : "cc");
        tmp_statement_expression_8 = send_result__1__4__1____v;
        unsigned short int send_result__1__4__2____v;
        unsigned short int send_result__1__4__2____x = (unsigned short int)kp->remote.sin_port;
        asm("rorw _8, %w0" : "=r"(send_result__1__4__2____v) : "0"(send_result__1__4__2____x) : "cc");
        tmp_statement_expression_9 = send_result__1__4__2____v;
        s_snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%d , %d : USERID : OTHER :%ld\r\n", tmp_statement_expression_8, tmp_statement_expression_9, (signed long int)uid);
      }
    }
    unsigned long int return_value_strlen_12;
    return_value_strlen_12=strlen(buf);
    s_write(fd, buf, return_value_strlen_12);
    if(result_syslog_level >= 0)
    {
      return_value_s_inet_ntox_13=s_inet_ntox(&kp->remote, buf2, sizeof(char [32l]) /*32ul*/ );
      return_value_strlen_14=strlen(buf);
      syslog(result_syslog_level, "reply to %s: %.*s", return_value_s_inet_ntox_13, return_value_strlen_14 - (unsigned long int)2, (const void *)buf);
    }

  }
}

// send_version
// file send.h line 33
extern void send_version(signed int fd, struct sockaddr_in *remote_addr)
{
  char buf[1024l];
  char buf2[32l];
  s_snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "0 , 0 : X-VERSION : pidentd %s for %s (%s %s)\r\n", (const void *)server_version, (const void *)osinfo_build, (const void *)"Jan 26 2016", (const void *)"02:19:47");
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  s_write(fd, buf, return_value_strlen_1);
  const char *return_value_s_inet_ntox_2;
  unsigned long int return_value_strlen_3;
  if(result_syslog_level >= 0)
  {
    return_value_s_inet_ntox_2=s_inet_ntox(remote_addr, buf2, sizeof(char [32l]) /*32ul*/ );
    return_value_strlen_3=strlen(buf);
    syslog(result_syslog_level, "reply to %s: %.*s", return_value_s_inet_ntox_2, return_value_strlen_3 - (unsigned long int)2, (const void *)buf);
  }

}

// server_init
// file server.h line 24
extern signed int server_init(void)
{
  signed int nofile;
  struct sockaddr_in sin;
  nofile=unlimit_nofile();
  unsigned short int tmp_statement_expression_1;
  if(!(nofile >= 0))
    return -1;

  else
  {
    if(!(listen_sock >= 0))
    {
      listen_sock=socket(2, 1, 0);
      if(!(listen_sock >= 0))
      {
        syslog(3, "socket(AF_INET, SOCK_STREAM) failed: %m");
        return -1;
      }

      static signed int one = 1;
      setsockopt(listen_sock, 1, 2, (void *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
      memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      sin.sin_family = (unsigned short int)2;
      sin.sin_addr.s_addr=__bswap_32((unsigned int)listen_addr);
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)listen_port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_1 = __v;
      sin.sin_port = tmp_statement_expression_1;
      signed int return_value_bind_2;
      return_value_bind_2=bind(listen_sock, (struct sockaddr *)&sin, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_2 >= 0))
      {
        syslog(3, "bind(port=%d) failed: %m", listen_port);
        return -1;
      }

    }

    signed int return_value_listen_3;
    return_value_listen_3=listen(listen_sock, listen_backlog);
    if(!(return_value_listen_3 >= 0))
    {
      syslog(3, "listen(backlog=%d) failed: %m", listen_backlog);
      return -1;
    }

    else
      return 0;
  }
}

// server_run
// file server.h line 25
extern signed int server_run(void)
{
  struct pollfd ufds[1l];
  signed int fd;
  signed int timeout = request_timeout <= 0 ? -1 : request_timeout * 1000;
  signed int retval;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(listen_sock, 4, 04000);
  if(return_value_fcntl_1 == -1)
  {
    syslog(3, "fcntl() failed: %m");
    return -1;
  }

  else
  {
    ufds[(signed long int)0].fd = listen_sock;
    ufds[(signed long int)0].events = (signed short int)0x001;
    while((_Bool)1)
    {
      retval=s_poll(ufds, (unsigned int)1, timeout);
      if(retval == -1)
      {
        syslog(3, "poll() failed: %m");
        return -1;
      }

      else
        if(retval == 0)
          break;

      fd=s_accept(listen_sock, (struct sockaddr *)(void *)0, (unsigned int *)(void *)0);
      if(!(fd >= 0))
      {
        syslog(3, "accept() failed: %m");
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 9 || *return_value___errno_location_2 == 11 || *return_value___errno_location_2 == 12 || *return_value___errno_location_2 == 19 || *return_value___errno_location_2 == 24 || *return_value___errno_location_2 == 88 || *return_value___errno_location_2 == 95)
          return -1;

      }

      request_run(fd, 0);
    }
    if(!(debug == 0))
      fprintf(stderr, "accept() timed out\n");

    exit(0);
  }
}

// socktype
// file support.h line 26
extern signed int socktype(signed int fd)
{
  struct sockaddr_in remote_sin;
  struct sockaddr_in local_sin;
  unsigned int len;
  signed int code;
  len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  code=getsockname(fd, (struct sockaddr *)&local_sin, &len);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(!(code >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 88)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 22 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return 0;

    else
      return -1;
  }

  len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  code=getpeername(fd, (struct sockaddr *)&remote_sin, &len);
  if(!(code >= 0))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 107)
      return 1;

    else
      return -1;
  }

  return 2;
}

// str2bool
// file str2.h line 22
extern signed int str2bool(const char *buf, signed int *out)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*buf]) == 0)
      break;

    buf = buf + 1l;
  }
  while((_Bool)1);
  signed int return_value_strcasecmp_2;
  return_value_strcasecmp_2=strcasecmp(buf, "true");
  _Bool tmp_if_expr_4;
  signed int return_value_strcasecmp_3;
  if(return_value_strcasecmp_2 == 0)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strcasecmp_3=strcasecmp(buf, "on");
    tmp_if_expr_4 = return_value_strcasecmp_3 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_strcasecmp_5;
  if(tmp_if_expr_4)
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strcasecmp_5=strcasecmp(buf, "enable");
    tmp_if_expr_6 = return_value_strcasecmp_5 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_8;
  signed int return_value_strcasecmp_7;
  if(tmp_if_expr_6)
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_strcasecmp_7=strcasecmp(buf, "enabled");
    tmp_if_expr_8 = return_value_strcasecmp_7 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_10;
  signed int return_value_strcasecmp_9;
  if(tmp_if_expr_8)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    return_value_strcasecmp_9=strcasecmp(buf, "yes");
    tmp_if_expr_10 = return_value_strcasecmp_9 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_13;
  signed int return_value_strcasecmp_12;
  _Bool tmp_if_expr_15;
  signed int return_value_strcasecmp_14;
  _Bool tmp_if_expr_17;
  signed int return_value_strcasecmp_16;
  _Bool tmp_if_expr_19;
  signed int return_value_strcasecmp_18;
  if(tmp_if_expr_10)
  {
    *out = 1;
    return *out;
  }

  else
  {
    signed int return_value_strcasecmp_11;
    return_value_strcasecmp_11=strcasecmp(buf, "false");
    if(return_value_strcasecmp_11 == 0)
      tmp_if_expr_13 = (_Bool)1;

    else
    {
      return_value_strcasecmp_12=strcasecmp(buf, "off");
      tmp_if_expr_13 = return_value_strcasecmp_12 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_13)
      tmp_if_expr_15 = (_Bool)1;

    else
    {
      return_value_strcasecmp_14=strcasecmp(buf, "disable");
      tmp_if_expr_15 = return_value_strcasecmp_14 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_15)
      tmp_if_expr_17 = (_Bool)1;

    else
    {
      return_value_strcasecmp_16=strcasecmp(buf, "disabled");
      tmp_if_expr_17 = return_value_strcasecmp_16 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_17)
      tmp_if_expr_19 = (_Bool)1;

    else
    {
      return_value_strcasecmp_18=strcasecmp(buf, "no");
      tmp_if_expr_19 = return_value_strcasecmp_18 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_19)
    {
      *out = 0;
      return *out;
    }

    else
      return -1;
  }
}

// str2gid
// file str2.h line 24
extern signed int str2gid(const char *str, unsigned int *out)
{
  struct group *gp;
  signed int return_value_is_int_2;
  return_value_is_int_2=is_int(str);
  if(!(return_value_is_int_2 == 0))
  {
    signed int return_value_atoi_1;
    return_value_atoi_1=atoi(str);
    *out = (unsigned int)return_value_atoi_1;
    return 0;
  }

  gp=getgrnam(str);
  if(gp == ((struct group *)NULL))
    return -1;

  else
  {
    *out = gp->gr_gid;
    return 0;
  }
}

// str2int
// file str2.h line 20
extern signed int str2int(const char *buf, signed int *out)
{
  signed int return_value_is_int_1;
  return_value_is_int_1=is_int(buf);
  if(return_value_is_int_1 == 0)
    return -1;

  else
  {
    signed int return_value_sscanf_2;
    return_value_sscanf_2=sscanf(buf, " %d ", out);
    if(!(return_value_sscanf_2 == 1))
      return -1;

    else
      return 0;
  }
}

// str2port
// file str2.h line 23
extern signed int str2port(const char *str, signed int *out)
{
  struct servent *sp;
  signed int return_value_is_int_1;
  return_value_is_int_1=is_int(str);
  unsigned short int tmp_statement_expression_2;
  if(!(return_value_is_int_1 == 0))
  {
    *out=atoi(str);
    return 0;
  }

  else
  {
    sp=getservbyname(str, "tcp");
    if(sp == ((struct servent *)NULL))
      return -1;

    else
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)sp->s_port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_2 = __v;
      *out = (signed int)tmp_statement_expression_2;
      return 0;
    }
  }
}

// str2str
// file str2.h line 21
extern signed int str2str(char *buf, char **out)
{
  signed int sep;
  char *start;
  char *cp;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*buf]) == 0)
      break;

    buf = buf + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc_2;
  switch((signed int)*buf)
  {
    case 0:
    {
      *out = (char *)(void *)0;
      return 0;
    }
    case 39:

    case 34:
    {
      sep = (signed int)*buf;
      buf = buf + 1l;
      start = buf;
      for( ; !((signed int)*buf == 0); buf = buf + 1l)
        if((signed int)*buf == sep)
          break;

      if((signed int)*buf == 0)
        return -1;

      *buf = (char)0;
      *out=s_strdup(start);
      return 0;
    }
    default:
    {
      cp = buf;
      for( ; !((signed int)*cp == 0); cp = cp + 1l)
        ;
      cp = cp - 1l;
      for( ; !(buf >= cp); cp = cp - 1l)
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*cp]) == 0)
          break;

      }
      cp = cp + 1l;
      *cp = (char)0;
      *out=s_strdup(buf);
      return 0;
    }
  }
}

// str2uid
// file str2.h line 25
extern signed int str2uid(const char *str, unsigned int *uid, unsigned int *gid)
{
  struct passwd pb;
  struct passwd *pp;
  char buf[1024l];
  signed int return_value_is_int_2;
  return_value_is_int_2=is_int(str);
  if(!(return_value_is_int_2 == 0))
  {
    signed long int return_value_atol_1;
    return_value_atol_1=atol(str);
    *uid = (unsigned int)return_value_atol_1;
    pp = (struct passwd *)(void *)0;
    s_getpwuid_r(*uid, &pb, buf, sizeof(char [1024l]) /*1024ul*/ , &pp);
    if(!(pp == ((struct passwd *)NULL)))
      *gid = pp->pw_gid;

    return 0;
  }

  pp = (struct passwd *)(void *)0;
  s_getpwnam_r(str, &pb, buf, sizeof(char [1024l]) /*1024ul*/ , &pp);
  if(pp == ((struct passwd *)NULL))
    return -1;

  else
  {
    *uid = pp->pw_uid;
    *gid = pp->pw_gid;
    return 0;
  }
}

// syslog_str2fac
// file support.h line 45
extern signed int syslog_str2fac(const char *name)
{
  signed int i;
  _Bool tmp_if_expr_2;
  signed int return_value_s_strcasecmp_1;
  if(name == ((const char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(facility[(signed long int)i].name == ((const char *)NULL)))
      {
        return_value_s_strcasecmp_1=s_strcasecmp(facility[(signed long int)i].name, name);
        tmp_if_expr_2 = return_value_s_strcasecmp_1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    return facility[(signed long int)i].code;
  }
}

// syslog_str2lev
// file support.c line 439
extern signed int syslog_str2lev(const char *name)
{
  signed int i;
  _Bool tmp_if_expr_2;
  signed int return_value_s_strcasecmp_1;
  if(name == ((const char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(level[(signed long int)i].name == ((const char *)NULL)))
      {
        return_value_s_strcasecmp_1=s_strcasecmp(level[(signed long int)i].name, name);
        tmp_if_expr_2 = return_value_s_strcasecmp_1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    return level[(signed long int)i].level;
  }
}

// timeout_cancel
// file timeout.h line 36
extern signed int timeout_cancel(struct timeout *tp)
{
  struct timeout **prev;
  struct timeout *cur;
  if(!(debug == 0))
    fprintf(stderr, "timeout_cancel(%08lx)\n", (signed long int)tp);

  pthread_mutex_lock(&tcb.mtx);
  prev = &tcb.top;
  cur = tcb.top;
  for( ; !(cur == ((struct timeout *)NULL)) && !(cur == tp); cur = cur->next)
    prev = &cur->next;
  if(cur == tp)
  {
    *prev = cur->next;
    pthread_mutex_unlock(&tcb.mtx);
    pthread_cond_signal(&tcb.cv);
  }

  else
    pthread_mutex_unlock(&tcb.mtx);
  s_free((void *)tp);
  return 0;
}

// timeout_create
// file timeout.h line 34
extern struct timeout * timeout_create(signed int timeout, void (*fun)(void *), void *arg)
{
  struct timeout *tp;
  struct timeout **prev;
  struct timeout *cur;
  void *return_value_s_malloc_1;
  return_value_s_malloc_1=s_malloc(sizeof(struct timeout) /*32ul*/ );
  tp = (struct timeout *)return_value_s_malloc_1;
  if(!(debug == 0))
    fprintf(stderr, "timeout_create(%d, ...) -> %08lx\n", timeout, (signed long int)tp);

  tp->next = (struct timeout *)(void *)0;
  signed long int return_value_time_2;
  return_value_time_2=time((signed long int *)(void *)0);
  tp->when = return_value_time_2 + (signed long int)timeout;
  tp->fun = fun;
  tp->arg = arg;
  pthread_mutex_lock(&tcb.mtx);
  prev = &tcb.top;
  cur = tcb.top;
  for( ; !(cur == ((struct timeout *)NULL)); cur = cur->next)
  {
    if(cur->when >= tp->when)
      break;

    prev = &cur->next;
  }
  *prev = tp;
  tp->next = cur;
  pthread_mutex_unlock(&tcb.mtx);
  pthread_cond_signal(&tcb.cv);
  return tp;
}

// timeout_handler
// file request.c line 153
static void timeout_handler(void *arg)
{
  struct request *rp = (struct request *)arg;
  if(!(debug == 0))
    fprintf(stderr, "timeout_handler(%08lx)\n", (unsigned long int)arg);

  if(!(rp == ((struct request *)NULL)))
    shutdown(rp->fd, 2);

}

// timeout_init
// file timeout.h line 33
extern signed int timeout_init(void)
{
  pthread_mutex_init(&tcb.mtx, (const union anonymous_1 *)(void *)0);
  pthread_cond_init(&tcb.cv, (const union anonymous_1 *)(void *)0);
  tcb.top = (struct timeout *)(void *)0;
  tcb.running = 1;
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&tcb.tid, (const union pthread_attr_t *)(void *)0, timeout_thread, (void *)&tcb);
  if(!(return_value_pthread_create_1 == 0))
  {
    syslog(3, "pthread_create(timeout_thread) failed: %m");
    tcb.running = 0;
    return -1;
  }

  else
    return 0;
}

// timeout_reset
// file timeout.h line 35
extern signed int timeout_reset(struct timeout *tp, signed int timeout)
{
  struct timeout **prev;
  struct timeout *cur;
  if(!(debug == 0))
    fprintf(stderr, "timeout_reset(%08lx, %d)\n", (signed long int)tp, timeout);

  pthread_mutex_lock(&tcb.mtx);
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  tp->when = return_value_time_1 + (signed long int)timeout;
  prev = &tcb.top;
  cur = tcb.top;
  for( ; !(cur == ((struct timeout *)NULL)) && !(cur == tp); cur = cur->next)
    prev = &cur->next;
  if(cur == tp)
    *prev = cur->next;

  prev = &tcb.top;
  cur = tcb.top;
  for( ; !(cur == ((struct timeout *)NULL)); cur = cur->next)
  {
    if(cur->when >= tp->when)
      break;

    prev = &cur->next;
  }
  *prev = tp;
  tp->next = cur;
  pthread_mutex_unlock(&tcb.mtx);
  pthread_cond_signal(&tcb.cv);
  return 0;
}

// timeout_thread
// file timeout.c line 40
static void * timeout_thread(void *misc)
{
  struct timeout_cb *timeout_thread__1__tcb = (struct timeout_cb *)misc;
  struct timeout *tp;
  signed long int now;
  if(!(debug == 0))
    fprintf(stderr, "timeout_thread() started\n");

  pthread_mutex_lock(&timeout_thread__1__tcb->mtx);
  while(!(timeout_thread__1__tcb->running == 0))
  {
    time(&now);
    tp = timeout_thread__1__tcb->top;
    for( ; !(tp == ((struct timeout *)NULL)); tp = timeout_thread__1__tcb->top)
    {
      if(!(now >= tp->when))
        break;

      timeout_thread__1__tcb->top = tp->next;
      pthread_mutex_unlock(&timeout_thread__1__tcb->mtx);
      if(!(tp->fun == ((void (*)(void *))NULL)))
        tp->fun(tp->arg);

      pthread_mutex_lock(&timeout_thread__1__tcb->mtx);
    }
    if(tp == ((struct timeout *)NULL))
      pthread_cond_wait(&timeout_thread__1__tcb->cv, &timeout_thread__1__tcb->mtx);

    else
    {
      struct timespec when;
      when.tv_sec = tp->when;
      when.tv_nsec = (signed long int)0;
      pthread_cond_timedwait(&timeout_thread__1__tcb->cv, &timeout_thread__1__tcb->mtx, &when);
    }
  }
  if(!(debug == 0))
    fprintf(stderr, "timeout_thread() terminating\n");

  return (void *)0;
}

// unlimit_nofile
// file server.c line 38
static signed int unlimit_nofile(void)
{
  struct rlimit rlb;
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit(7, &rlb);
  if(!(return_value_getrlimit_1 >= 0))
  {
    syslog(3, "getrlimit() failed: %m");
    return -1;
  }

  else
  {
    rlb.rlim_cur = rlb.rlim_max;
    signed int return_value_setrlimit_2;
    return_value_setrlimit_2=setrlimit(7, &rlb);
    if(!(return_value_setrlimit_2 >= 0))
    {
      syslog(3, "getrlimit() failed: %m");
      return -1;
    }

    else
      return (signed int)rlb.rlim_cur;
  }
}

// usage
// file main.c line 51
static void usage(struct _IO_FILE *fp)
{
  fprintf(fp, "Usage: %s [options]\n", argv0);
  fputs("\n", fp);
  fputs("Options:\n", fp);
  fputs("  -d           Enable debug mode\n", fp);
  fputs("  -h           Print this information\n", fp);
  fputs("  -V           Print version and OS information\n", fp);
  fputs("\n", fp);
  fputs("  -w           Start in Inetd 'wait' mode\n", fp);
  fputs("  -i           Start in Inetd 'nowait' mode\n", fp);
  fputs("  -I           Start in Init mode\n", fp);
  fputs("  -b           Start in Standalone mode\n", fp);
  fputs("\n", fp);
  fputs("  -e           Enable protocol extensions\n", fp);
  fputs("  -m           Enable multiquery mode\n", fp);
  fputs("  -E           Enable DES encrypted replies\n", fp);
  fputs("  -n           Send uid numbers instead of usernames\n", fp);
  fputs("  -o           Return OTHER instead of UNIX\n", fp);
  fputs("  -N           Check for .noident files\n", fp);
  fputs("\n", fp);
  fputs("  -l           Log a message to syslog at startup\n", fp);
  fputs("  -t<time>     Request timeout limit in seconds\n", fp);
  fputs("  -p<port>     Port to listen for connections on\n", fp);
  fputs("  -g<group>    Group name/number to run as\n", fp);
  fputs("  -u<user>     User name/number to run as\n", fp);
  fputs("  -C<file>     Config file to include\n", fp);
  fputs("  -P<file>     Where to write the process id number\n", fp);
  fputs("  -K<threads>  Number of kernel lookup threads\n", fp);
}

