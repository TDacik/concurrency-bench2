// #anon_enum_CARRY_FL=0_ZERO_FL=1_INTERRUPT_FL=2_DECIMAL_FL=3_BREAK_FL=4_FUTURE_FL=5_OVERFLOW_FL=6_NEGATIVE_FL=7
// file asm6502.c line 62
enum anonymous_18 { CARRY_FL=0, ZERO_FL=1, INTERRUPT_FL=2, DECIMAL_FL=3, BREAK_FL=4, FUTURE_FL=5, OVERFLOW_FL=6, NEGATIVE_FL=7 };

// #anon_enum_LEFT=0_RIGHT=1
// file asm6502.c line 48
enum anonymous_17 { LEFT=0, RIGHT=1 };

// #anon_enum_SINGLE=0_IMMEDIATE_VALUE=1_IMMEDIATE_GREAT=2_IMMEDIATE_LESS=3_INDIRECT_X=4_INDIRECT_Y=5_ZERO=6_ZERO_X=7_ZERO_Y=8_ABS_VALUE=9_ABS_OR_BRANCH=10_ABS_X=11_ABS_Y=12_ABS_LABEL_X=13_ABS_LABEL_Y=14_DCB_PARAM=15
// file asm6502.h line 53
enum anonymous_60 { SINGLE=0, IMMEDIATE_VALUE=1, IMMEDIATE_GREAT=2, IMMEDIATE_LESS=3, INDIRECT_X=4, INDIRECT_Y=5, ZERO=6, ZERO_X=7, ZERO_Y=8, ABS_VALUE=9, ABS_OR_BRANCH=10, ABS_X=11, ABS_Y=12, ABS_LABEL_X=13, ABS_LABEL_Y=14, DCB_PARAM=15 };

// #anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous_64 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// #anon_enum_XtGeometryYes=0_XtGeometryNo=1_XtGeometryAlmost=2_XtGeometryDone=3
// file /usr/include/X11/Intrinsic.h line 340
enum anonymous_69 { XtGeometryYes=0, XtGeometryNo=1, XtGeometryAlmost=2, XtGeometryDone=3 };

// #anon_enum_XtGrabNone=0_XtGrabNonexclusive=1_XtGrabExclusive=2
// file /usr/include/X11/Intrinsic.h line 347
enum anonymous_70 { XtGrabNone=0, XtGrabNonexclusive=1, XtGrabExclusive=2 };

// tag-#anon#ST[*{S8}_S8_'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous_68;

// tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous_65;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'visualid'|S32'screen'|S32'depth'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'colormap_size'|S32'bits_per_rgb']
// file /usr/include/X11/Xutil.h line 287
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous_25;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'|S32'fd'|S32'private2'|S32'proto_major_version'|S32'proto_minor_version'|*{S8}_S8_'vendor'|U64'private3'|U64'private4'|U64'private5'|S32'private6'|U32'_pad0'|*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'|S32'byte_order'|S32'bitmap_unit'|S32'bitmap_pad'|S32'bitmap_bit_order'|S32'nformats'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#_'pixmap_format'|S32'private8'|S32'release'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'|S32'qlen'|U32'_pad2'|U64'last_request_read'|U64'request'|*{S8}_S8_'private11'|*{S8}_S8_'private12'|*{S8}_S8_'private13'|*{S8}_S8_'private14'|U32'max_request_size'|U32'_pad3'|*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'|*{S8}_S8_'display_name'|S32'default_screen'|S32'nscreens'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screens'|U64'motion_buffer'|U64'private16'|S32'min_keycode'|S32'max_keycode'|*{S8}_S8_'private17'|*{S8}_S8_'private18'|S32'private19'|U32'_pad4'|*{S8}_S8_'xdefaults']
// file /usr/include/X11/Xlib.h line 493
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']
// file /usr/include/X11/Xlib.h line 280
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}_SYM#tag-#anon#ST[U64'name'|U64'card32']#_'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}_SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#_'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous_13;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_20;

// tag-#anon#ST[ARR4{S8}_S8_'name'|U8'Imm'|U8'ZP'|U8'ZPX'|U8'ZPY'|U8'ABS'|U8'ABSX'|U8'ABSY'|U8'INDX'|U8'INDY'|U8'SNGL'|U8'BRA'|U8'_pad0'|*{V(*{SYM#tag-machine_6502#}_SYM#tag-machine_6502#_|SYM##anon_enum_SINGLE=0_IMMEDIATE_VALUE=1_IMMEDIATE_GREAT=2_IMMEDIATE_LESS=3_INDIRECT_X=4_INDIRECT_Y=5_ZERO=6_ZERO_X=7_ZERO_Y=8_ABS_VALUE=9_ABS_OR_BRANCH=10_ABS_X=11_ABS_Y=12_ABS_LABEL_X=13_ABS_LABEL_Y=14_DCB_PARAM=15#)->V}_V(*{SYM#tag-machine_6502#}_SYM#tag-machine_6502#_|SYM##anon_enum_SINGLE=0_IMMEDIATE_VALUE=1_IMMEDIATE_GREAT=2_IMMEDIATE_LESS=3_INDIRECT_X=4_INDIRECT_Y=5_ZERO=6_ZERO_X=7_ZERO_Y=8_ABS_VALUE=9_ABS_OR_BRANCH=10_ABS_X=11_ABS_Y=12_ABS_LABEL_X=13_ABS_LABEL_Y=14_DCB_PARAM=15#)->V_'func']
// file asm6502.h line 63
struct anonymous_61;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_6;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous;

// tag-#anon#ST[S32'depth'|S32'bits_per_pixel'|S32'scanline_pad']
// file /usr/include/X11/Xlib.h line 171
struct anonymous_16;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous_23;

// tag-#anon#ST[S32'function'|U32'_pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'_pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'_pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous_4;

// tag-#anon#ST[S32'index'|U32'_pad0'|F64'value']
// file analogtv.h line 222
struct anonymous_21;

// tag-#anon#ST[S32'type'|U32'_pad0'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'_pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous_56;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous_58;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'_pad2'|*{V}_V_'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous_59;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous_34;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous_33;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous_37;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'from_configure'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous_38;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous_39;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous_46;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous_43;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'override_redirect'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous_42;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous_41;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous_50;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous_40;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous_47;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous_36;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'detail'|U32'_pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous_45;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous_51;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous_26;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|ARR32{S8}_S8_'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous_57;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous_31;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous_55;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous_35;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous_44;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous_32;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous_48;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous_52;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'message_type'|S32'format'|U32'_pad2'|SYM#tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous_54;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous_30;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'_pad2'|S32'same_screen'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous_29;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous_28;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous_27;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous_49;

// tag-#anon#ST[S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'depth'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'root'|S32'class'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad0'|U64'colormap'|S32'map_installed'|S32'map_state'|S64'all_event_masks'|S64'your_event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen']
// file /usr/include/X11/Xlib.h line 308
struct anonymous_7;

// tag-#anon#ST[SYM##anon_enum_SINGLE=0_IMMEDIATE_VALUE=1_IMMEDIATE_GREAT=2_IMMEDIATE_LESS=3_INDIRECT_X=4_INDIRECT_Y=5_ZERO=6_ZERO_X=7_ZERO_Y=8_ABS_VALUE=9_ABS_OR_BRANCH=10_ABS_X=11_ABS_Y=12_ABS_LABEL_X=13_ABS_LABEL_Y=14_DCB_PARAM=15#'type'|ARR25{U32}_U32_'value'|U32'vp'|U32'_pad0'|*{S8}_S8_'label'|U32'lbladdr'|U32'_pad1']
// file asm6502.c line 75
struct anonymous_8;

// tag-#anon#ST[U16'addr'|U16'value']
// file asm6502.c line 97
struct anonymous_15;

// tag-#anon#ST[U32'addr'|U32'_pad0'|*{S8}_S8_'label']
// file asm6502.c line 83
struct anonymous_12;

// tag-#anon#ST[U32'request_mode'|S16'x'|S16'y'|U16'width'|U16'height'|U16'border_width'|U16'_pad0'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'sibling'|S32'stack_mode'|U32'_pad1']
// file /usr/include/X11/Intrinsic.h line 212
struct anonymous_67;

// tag-#anon#ST[U32'size'|U32'_pad0'|*{S8}_S8_'addr']
// file /usr/include/X11/Xresource.h line 160
struct anonymous_10;

// tag-#anon#ST[U64'background_pixmap'|U64'background_pixel'|U64'border_pixmap'|U64'border_pixel'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U32'_pad0'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad1'|S64'event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad2'|U64'colormap'|U64'cursor']
// file /usr/include/X11/Xlib.h line 290
struct anonymous_0;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous_5;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous_9;

// tag-#anon#ST[U64'shmseg'|S32'shmid'|U32'_pad0'|*{S8}_S8_'shmaddr'|S32'readOnly'|U32'_pad1']
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_14;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous_24;

// tag-#anon#ST[U8'index'|U24'_pad0'|SYM##anon_enum_SINGLE=0_IMMEDIATE_VALUE=1_IMMEDIATE_GREAT=2_IMMEDIATE_LESS=3_INDIRECT_X=4_INDIRECT_Y=5_ZERO=6_ZERO_X=7_ZERO_Y=8_ABS_VALUE=9_ABS_OR_BRANCH=10_ABS_X=11_ABS_Y=12_ABS_LABEL_X=13_ABS_LABEL_Y=14_DCB_PARAM=15#'adm']
// file asm6502.h line 80
struct anonymous_62;

// tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous_53;

// tag-#anon#UN[F32'f'|S32'i']
// file analogtv.c line 159
union anonymous_22;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_66;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_63;

// tag-AsmLine
// file asm6502.c line 88
struct AsmLine;

// tag-_CoreClassPart
// file /usr/include/X11/CoreP.h line 125
struct _CoreClassPart;

// tag-_CorePart
// file /usr/include/X11/CoreP.h line 72
struct _CorePart;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-_TranslationData
// file /usr/include/X11/Intrinsic.h line 170
struct _TranslationData;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRegion
// file /usr/include/X11/Xutil.h line 273
struct _XRegion;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtCallbackRec
// file /usr/include/X11/Intrinsic.h line 329
struct _XtCallbackRec;

// tag-_XtEventRec
// file /usr/include/X11/Intrinsic.h line 112
struct _XtEventRec;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-_XtStateRec
// file /usr/include/X11/IntrinsicP.h line 187
struct _XtStateRec;

// tag-_XtTMRec
// file /usr/include/X11/IntrinsicP.h line 189
struct _XtTMRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_io_thread_status
// file thread_util.h line 360
enum _io_thread_status { _io_thread_working=0, _io_thread_done=1, _io_thread_cancelled=2 };

// tag-_parallel_startup_type
// file thread_util.c line 534
struct _parallel_startup_type;

// tag-analogtv_font_s
// file analogtv.h line 89
struct analogtv_font_s;

// tag-analogtv_input_s
// file analogtv.h line 77
struct analogtv_input_s;

// tag-analogtv_reception_s
// file analogtv.h line 95
struct analogtv_reception_s;

// tag-analogtv_s
// file analogtv.h line 119
struct analogtv_s;

// tag-analogtv_thread_s
// file analogtv.c line 430
struct analogtv_thread_s;

// tag-analogtv_yiq_s
// file analogtv.h line 115
struct analogtv_yiq_s;

// tag-fps_state
// file fps.h line 20
struct fps_state;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-io_thread
// file thread_util.h line 365
struct io_thread;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-machine_6502
// file asm6502.h line 61
struct machine_6502;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-state
// file m6502.c line 44
struct state;

// tag-threadpool
// file ./../utils/thread_util.h line 227
struct threadpool;

// tag-threadpool_class
// file ./../utils/thread_util.h line 277
struct threadpool_class;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-xscreensaver_function_table
// file screenhackI.h line 114
struct xscreensaver_function_table;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window);
// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_25 *screen);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous_9 *);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_24 *in, signed int *length_ret);
// XClearArea
// file /usr/include/X11/Xlib.h line 2145
extern signed int XClearArea(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, signed int);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_13 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_4 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_13 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreatePixmapFromBitmapData
// file /usr/include/X11/Xlib.h line 1611
extern unsigned long int XCreatePixmapFromBitmapData(struct _XDisplay *, unsigned long int, char *, unsigned int, unsigned int, unsigned long int, unsigned long int, unsigned int);
// XDrawString
// file /usr/include/X11/Xlib.h line 2404
extern signed int XDrawString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeColors
// file /usr/include/X11/Xlib.h line 2525
extern signed int XFreeColors(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, unsigned long int);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous_3 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XGetImage
// file /usr/include/X11/Xlib.h line 1456
extern struct _XImage * XGetImage(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned long int, signed int);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_19 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_19 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous_7 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XIfEvent
// file /usr/include/X11/Xlib.h line 2753
extern signed int XIfEvent(struct _XDisplay *, union _XEvent *, signed int (*)(struct _XDisplay *, union _XEvent *, char *), char *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XListDepths
// file /usr/include/X11/Xlib.h line 1866
extern signed int * XListDepths(struct _XDisplay *, signed int, signed int *);
// XListPixmapFormats
// file /usr/include/X11/Xlib.h line 1862
extern struct anonymous_16 * XListPixmapFormats(struct _XDisplay *, signed int *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous_3 * XLoadQueryFont(struct _XDisplay *, const char *);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous_27 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_9 *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XPutImage
// file /usr/include/X11/Xlib.h line 2903
extern signed int XPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int);
// XQueryColors
// file /usr/include/X11/Xlib.h line 2963
extern signed int XQueryColors(struct _XDisplay *, unsigned long int, struct anonymous_9 *, signed int);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_56 *)))(struct _XDisplay *, struct anonymous_56 *);
// XSetForeground
// file /usr/include/X11/Xlib.h line 3227
extern signed int XSetForeground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetWindowBackground
// file /usr/include/X11/Xlib.h line 3333
extern signed int XSetWindowBackground(struct _XDisplay *, unsigned long int, unsigned long int);
// XSetWindowColormap
// file /usr/include/X11/Xlib.h line 3363
extern signed int XSetWindowColormap(struct _XDisplay *, unsigned long int, unsigned long int);
// XShmAttach
// file /usr/include/X11/extensions/XShm.h line 78
signed int XShmAttach(struct _XDisplay *, struct anonymous_14 *);
// XShmCreateImage
// file /usr/include/X11/extensions/XShm.h line 111
struct _XImage * XShmCreateImage(struct _XDisplay *, struct anonymous_13 *, unsigned int, signed int, char *, struct anonymous_14 *, unsigned int, unsigned int);
// XShmDetach
// file /usr/include/X11/extensions/XShm.h line 83
signed int XShmDetach(struct _XDisplay *, struct anonymous_14 *);
// XShmPutImage
// file /usr/include/X11/extensions/XShm.h line 88
signed int XShmPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int, signed int);
// XShmQueryExtension
// file /usr/include/X11/extensions/XShm.h line 59
signed int XShmQueryExtension(struct _XDisplay *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous_13 *);
// XmuPrintDefaultErrorMessage
// file ./../utils/xmu.h line 12
signed int XmuPrintDefaultErrorMessage(struct _XDisplay *, struct anonymous_56 *, struct _IO_FILE *);
// XrmGetResource
// file /usr/include/X11/Xresource.h line 223
extern signed int XrmGetResource(struct _XrmHashBucketRec *, const char *, const char *, char **, struct anonymous_10 *);
// XtAppInitialize
// file /usr/include/X11/Intrinsic.h line 1468
extern struct _WidgetRec * XtAppInitialize(struct _XtAppStruct **, const char *, struct anonymous_65 *, unsigned int, signed int *, char **, char **, struct anonymous_68 *, unsigned int);
// XtAppPending
// file /usr/include/X11/Intrinsic.h line 1045
extern unsigned long int XtAppPending(struct _XtAppStruct *);
// XtAppProcessEvent
// file /usr/include/X11/Intrinsic.h line 931
extern void XtAppProcessEvent(struct _XtAppStruct *, unsigned long int);
// XtDatabase
// file resources.c line 27
extern struct _XrmHashBucketRec * XtDatabase(struct _XDisplay *);
// XtDestroyApplicationContext
// file /usr/include/X11/Intrinsic.h line 1520
extern void XtDestroyApplicationContext(struct _XtAppStruct *);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDisplayToApplicationContext
// file /usr/include/X11/Intrinsic.h line 1532
extern struct _XtAppStruct * XtDisplayToApplicationContext(struct _XDisplay *);
// XtGetApplicationNameAndClass
// file /usr/include/X11/Intrinsic.h line 2176
extern void XtGetApplicationNameAndClass(struct _XDisplay *, char **, char **);
// XtPopup
// file /usr/include/X11/Intrinsic.h line 1318
extern void XtPopup(struct _WidgetRec *, enum anonymous_70);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// _IO_getc
// file /usr/include/libio.h line 430
extern signed int _IO_getc(struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_exchange_n
// file thread_util.c line 993 function io_thread_return
signed int __atomic_exchange_n();
// __atomic_load_n
// file thread_util.c line 1006 function io_thread_is_done
signed int __atomic_load_n();
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __isoc99_sscanf
// file /usr/include/stdio.h line 448
extern signed int __isoc99_sscanf(const char *, const char *, ...);
// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self);
// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void);
// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void);
// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self);
// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self);
// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw);
// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread);
// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread);
// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self);
// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self);
// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// addend
// file asm6502.c line 1185
static struct AsmLine * addend(struct AsmLine *listp, struct AsmLine *newp);
// addvalue
// file asm6502.c line 1229
static unsigned char addvalue(struct anonymous_8 *param, unsigned int value);
// aligned_free
// file aligned_malloc.c line 42
void aligned_free(void *ptr);
// aligned_malloc
// file aligned_malloc.c line 26
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size);
// analogtv_add_signal
// file analogtv.c line 1231
static void analogtv_add_signal(const struct analogtv_s *it, const struct analogtv_reception_s *rec, unsigned int start, unsigned int end, signed int ec);
// analogtv_alloc_image
// file analogtv.c line 279
static void analogtv_alloc_image(struct analogtv_s *it);
// analogtv_allocate
// file analogtv.h line 239
struct analogtv_s * analogtv_allocate(struct _XDisplay *dpy, unsigned long int window);
// analogtv_blast_imagerow
// file analogtv.c line 1390
static void analogtv_blast_imagerow(const struct analogtv_s *it, float *rgbf, float *rgbf_end, signed int ytop, signed int ybot);
// analogtv_configure
// file analogtv.c line 319
static void analogtv_configure(struct analogtv_s *it);
// analogtv_draw
// file analogtv.h line 250
void analogtv_draw(struct analogtv_s *it, double noiselevel, const struct analogtv_reception_s * const *recs, unsigned int rec_count);
// analogtv_draw_char
// file analogtv.c line 2364
void analogtv_draw_char(struct analogtv_input_s *input, struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_solid
// file analogtv.h line 271
void analogtv_draw_solid(struct analogtv_input_s *input, signed int left, signed int right, signed int top, signed int bot, signed int *ntsc);
// analogtv_draw_solid_rel_lcp
// file analogtv.c line 2347
void analogtv_draw_solid_rel_lcp(struct analogtv_input_s *input, double left, double right, double top, double bot, double luma, double chroma, double phase);
// analogtv_draw_string
// file analogtv.c line 2388
void analogtv_draw_string(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_string_centered
// file analogtv.c line 2399
void analogtv_draw_string_centered(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_xpm
// file analogtv.c line 2422
void analogtv_draw_xpm(struct analogtv_s *tv, struct analogtv_input_s *input, const char * const *xpm, signed int left, signed int top);
// analogtv_font_pixel
// file analogtv.c line 2280
signed int analogtv_font_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y);
// analogtv_font_set_char
// file analogtv.c line 2299
void analogtv_font_set_char(struct analogtv_font_s *f, signed int c, char *s);
// analogtv_font_set_pixel
// file analogtv.c line 2289
void analogtv_font_set_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int value);
// analogtv_free_image
// file analogtv.c line 262
static void analogtv_free_image(struct analogtv_s *it);
// analogtv_get_line
// file analogtv.c line 1365
static signed int analogtv_get_line(const struct analogtv_s *it, signed int lineno, signed int *slineno, signed int *ytop, signed int *ybot, unsigned int *signal_offset);
// analogtv_init
// file analogtv.c line 165
static void analogtv_init(void);
// analogtv_init_signal
// file analogtv.c line 1210
static void analogtv_init_signal(const struct analogtv_s *it, double noiselevel, unsigned int start, unsigned int end);
// analogtv_input_allocate
// file analogtv.h line 240
struct analogtv_input_s * analogtv_input_allocate(void);
// analogtv_lcp_to_ntsc
// file analogtv.h line 267
void analogtv_lcp_to_ntsc(double luma, double chroma, double phase, signed int *ntsc);
// analogtv_level
// file analogtv.c line 1122
static signed int analogtv_level(const struct analogtv_s *it, signed int y, signed int ytop, signed int ybot);
// analogtv_levelmult
// file analogtv.c line 1115
static double analogtv_levelmult(const struct analogtv_s *it, signed int level);
// analogtv_load_ximage
// file analogtv.c line 2015
signed int analogtv_load_ximage(struct analogtv_s *it, struct analogtv_input_s *input, struct _XImage *pic_im);
// analogtv_make_font
// file analogtv.c line 2209
void analogtv_make_font(struct _XDisplay *dpy, unsigned long int window, struct analogtv_font_s *f, signed int w, signed int h, char *fontname);
// analogtv_ntsc_to_yiq
// file analogtv.c line 776
static void analogtv_ntsc_to_yiq(const struct analogtv_s *it, signed int lineno, const float *signal, signed int start, signed int end, struct analogtv_yiq_s *it_yiq);
// analogtv_reception_update
// file analogtv.h line 255
void analogtv_reception_update(struct analogtv_reception_s *rec);
// analogtv_reconfigure
// file analogtv.h line 243
void analogtv_reconfigure(struct analogtv_s *it);
// analogtv_release
// file analogtv.h line 246
void analogtv_release(struct analogtv_s *it);
// analogtv_set_defaults
// file analogtv.h line 245
void analogtv_set_defaults(struct analogtv_s *it, char *prefix);
// analogtv_set_demod
// file analogtv.c line 647
signed int analogtv_set_demod(struct analogtv_s *it);
// analogtv_setup_frame
// file analogtv.c line 911
void analogtv_setup_frame(struct analogtv_s *it);
// analogtv_setup_levels
// file analogtv.c line 1154
static void analogtv_setup_levels(struct analogtv_s *it, double avgheight);
// analogtv_setup_sync
// file analogtv.h line 249
void analogtv_setup_sync(struct analogtv_input_s *input, signed int do_cb, signed int do_ssavi);
// analogtv_setup_teletext
// file analogtv.c line 892
void analogtv_setup_teletext(struct analogtv_input_s *input);
// analogtv_sync
// file analogtv.c line 1028
static void analogtv_sync(struct analogtv_s *it);
// analogtv_thread_add_signals
// file analogtv.c line 1323
static void analogtv_thread_add_signals(void *thread_raw);
// analogtv_thread_create
// file analogtv.c line 440
static signed int analogtv_thread_create(void *thread_raw, struct threadpool *threads, unsigned int thread_id);
// analogtv_thread_destroy
// file analogtv.c line 463
static void analogtv_thread_destroy(void *thread_raw);
// analogtv_thread_draw_lines
// file analogtv.c line 1519
static void analogtv_thread_draw_lines(void *thread_raw);
// apply
// file asm6502.c line 1196
static unsigned char apply(struct AsmLine *listp, unsigned char (*fn)(struct AsmLine *, void *), void *arg);
// apply::fn_object
//
unsigned char fn_object(struct AsmLine *, void *);
// assignOpCodes
// file asm6502.c line 1005
static void assignOpCodes(struct anonymous_61 *opcodes);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bitOff
// file asm6502.c line 243
static unsigned char bitOff(unsigned char value, enum anonymous_18 bit);
// bitOn
// file asm6502.c line 237
static unsigned char bitOn(unsigned char value, enum anonymous_18 bit);
// buildIndexCache
// file asm6502.c line 1074
static void buildIndexCache(struct machine_6502 *machine);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// changeParamLabelAddr
// file asm6502.c line 2001
static unsigned char changeParamLabelAddr(struct AsmLine *asmline, void *label);
// checkAddress
// file asm6502.c line 123
static void checkAddress(unsigned int address);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// command
// file asm6502.c line 1315
static unsigned char command(struct machine_6502 *machine, char **s, char **cmd);
// comment
// file asm6502.c line 1589
static void comment(char **s);
// compileCode
// file asm6502.c line 2020
static unsigned char compileCode(struct machine_6502 *machine, const char *code);
// compileLine
// file asm6502.c line 1939
static unsigned char compileLine(struct AsmLine *asmline, void *args);
// copyParam
// file asm6502.c line 1151
static void copyParam(struct anonymous_8 *p1, struct anonymous_8 *p2);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// cosf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern float cosf(float);
// create_xshm_image
// file ./../utils/xshm.h line 27
extern struct _XImage * create_xshm_image(struct _XDisplay *dpy, struct anonymous_13 *visual, unsigned int depth, signed int format, char *data, struct anonymous_14 *shm_info, unsigned int width, unsigned int height);
// dcbValue
// file asm6502.c line 1489
static unsigned char dcbValue(char **s, struct anonymous_8 *param);
// declareLabel
// file asm6502.c line 1328
static unsigned char declareLabel(char **s, char **label);
// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_25 *screen, struct anonymous_13 *visual, signed int private_cmap_p);
// destroy_xshm_image
// file ./../utils/xshm.h line 32
extern void destroy_xshm_image(struct _XDisplay *dpy, struct _XImage *image, struct anonymous_14 *shm_info);
// doCompare
// file asm6502.c line 626
static void doCompare(struct machine_6502 *machine, unsigned short int reg, struct anonymous_15 *ptr);
// ecalloc
// file asm6502.c line 109
static void * ecalloc(unsigned int nelm, unsigned long int nsize);
// estrdup
// file asm6502.c line 116
static char * estrdup(const char *source);
// execute
// file asm6502.c line 2081
static void execute(struct machine_6502 *machine);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern float expf(float);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fileToBuffer
// file asm6502.c line 1677
static char * fileToBuffer(const char *filename);
// find_similar_visual
// file visual.c line 503
extern struct anonymous_13 * find_similar_visual(struct anonymous_25 *screen, struct anonymous_13 *old_visual);
// fix_fds
// file screenhack.c line 403
static void fix_fds(void);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth);
// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st);
// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st);
// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window);
// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeLabel
// file asm6502.c line 1212
static void freeLabel(struct anonymous_12 *label);
// freeParam
// file asm6502.c line 1207
static void freeParam(struct anonymous_8 *param);
// freeallAsmLine
// file asm6502.c line 1217
static void freeallAsmLine(struct AsmLine *listp);
// getDirection
// file asm6502.c line 1436
static unsigned char getDirection(char **s, char *direction);
// getValue
// file asm6502.c line 332
static unsigned char getValue(struct machine_6502 *machine, enum anonymous_60 adm, struct anonymous_15 *pointer);
// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth);
// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_float_resource
// file resources.c line 122
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class);
// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_time
// file m6502.c line 92
static double get_time(struct state *st);
// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p);
// get_visual
// file visual.c line 50
extern struct anonymous_13 * get_visual(struct anonymous_25 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p);
// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_13 * get_visual_resource(struct anonymous_25 *screen, char *name, char *class, signed int prefer_writable_cells);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hardware_concurrency
// file ./../utils/thread_util.h line 101
unsigned int hardware_concurrency(struct _XDisplay *dpy);
// hasChar
// file asm6502.c line 1289
static unsigned char hasChar(char *s, char c);
// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_25 *screen, struct anonymous_13 *visual);
// id_to_visual
// file visual.c line 340
extern struct anonymous_13 * id_to_visual(struct anonymous_25 *screen, signed int id);
// immediate
// file asm6502.c line 1401
static unsigned char immediate(char **s, struct anonymous_8 *param);
// indexLabels
// file asm6502.c line 1970
static unsigned char indexLabels(struct AsmLine *asmline, void *arg);
// indirect
// file asm6502.c line 1450
static unsigned char indirect(char **s, struct anonymous_8 *param);
// initParam
// file asm6502.c line 1596
static void initParam(struct anonymous_8 *param);
// init_time
// file m6502.c line 110
static void init_time(struct state *st);
// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title);
// io_thread_cancel
// file thread_util.c line 1013
signed int io_thread_cancel(struct io_thread *self);
// io_thread_create
// file thread_util.c line 950
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize);
// io_thread_create::start_routine_object
//
void * start_routine_object(void *);
// io_thread_finish
// file thread_util.c line 1029
void io_thread_finish(struct io_thread *self);
// io_thread_is_done
// file thread_util.c line 1002
signed int io_thread_is_done(struct io_thread *self);
// io_thread_return
// file thread_util.c line 989
signed int io_thread_return(struct io_thread *self);
// isBlank
// file asm6502.c line 1270
static unsigned char isBlank(const char *token);
// isCmdChar
// file asm6502.c line 1308
static unsigned char isCmdChar(char c);
// isCommand
// file asm6502.c line 1274
static unsigned char isCommand(struct machine_6502 *machine, const char *token);
// isDirection
// file asm6502.c line 1432
static unsigned char isDirection(char c);
// isWhite
// file asm6502.c line 1254
static unsigned char isWhite(char c);
// ishexdigit
// file asm6502.c line 1297
static unsigned char ishexdigit(char c);
// jmpADC
// file asm6502.c line 465
static void jmpADC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpAND
// file asm6502.c line 516
static void jmpAND(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpASL
// file asm6502.c line 524
static void jmpASL(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBCC
// file asm6502.c line 594
static void jmpBCC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBCS
// file asm6502.c line 602
static void jmpBCS(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBEQ
// file asm6502.c line 618
static void jmpBEQ(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBIT
// file asm6502.c line 543
static void jmpBIT(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBMI
// file asm6502.c line 569
static void jmpBMI(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBNE
// file asm6502.c line 610
static void jmpBNE(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBPL
// file asm6502.c line 560
static void jmpBPL(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBVC
// file asm6502.c line 578
static void jmpBVC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpBVS
// file asm6502.c line 586
static void jmpBVS(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCLC
// file asm6502.c line 672
static void jmpCLC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCLD
// file asm6502.c line 692
static void jmpCLD(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCLI
// file asm6502.c line 680
static void jmpCLI(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCLV
// file asm6502.c line 688
static void jmpCLV(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCMP
// file asm6502.c line 631
static void jmpCMP(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCPX
// file asm6502.c line 638
static void jmpCPX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpCPY
// file asm6502.c line 645
static void jmpCPY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpDEC
// file asm6502.c line 652
static void jmpDEC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpDEX
// file asm6502.c line 796
static void jmpDEX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpDEY
// file asm6502.c line 820
static void jmpDEY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpEOR
// file asm6502.c line 664
static void jmpEOR(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpINC
// file asm6502.c line 700
static void jmpINC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpINX
// file asm6502.c line 804
static void jmpINX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpINY
// file asm6502.c line 828
static void jmpINY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpJMP
// file asm6502.c line 709
static void jmpJMP(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpJSR
// file asm6502.c line 716
static void jmpJSR(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpLDA
// file asm6502.c line 728
static void jmpLDA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpLDX
// file asm6502.c line 736
static void jmpLDX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpLDY
// file asm6502.c line 744
static void jmpLDY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpLSR
// file asm6502.c line 752
static void jmpLSR(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpNOP
// file asm6502.c line 774
static void jmpNOP(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpORA
// file asm6502.c line 778
static void jmpORA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpPHA
// file asm6502.c line 970
static void jmpPHA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpPHP
// file asm6502.c line 979
static void jmpPHP(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpPLA
// file asm6502.c line 974
static void jmpPLA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpPLP
// file asm6502.c line 983
static void jmpPLP(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpROL
// file asm6502.c line 859
static void jmpROL(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpROR
// file asm6502.c line 834
static void jmpROR(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpRTI
// file asm6502.c line 884
static void jmpRTI(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpRTS
// file asm6502.c line 889
static void jmpRTS(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSBC
// file asm6502.c line 898
static void jmpSBC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSEC
// file asm6502.c line 676
static void jmpSEC(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSED
// file asm6502.c line 696
static void jmpSED(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSEI
// file asm6502.c line 684
static void jmpSEI(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSTA
// file asm6502.c line 954
static void jmpSTA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSTX
// file asm6502.c line 988
static void jmpSTX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpSTY
// file asm6502.c line 995
static void jmpSTY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTAX
// file asm6502.c line 786
static void jmpTAX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTAY
// file asm6502.c line 810
static void jmpTAY(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTSX
// file asm6502.c line 965
static void jmpTSX(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTXA
// file asm6502.c line 791
static void jmpTXA(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTXS
// file asm6502.c line 961
static void jmpTXS(struct machine_6502 *machine, enum anonymous_60 adm);
// jmpTYA
// file asm6502.c line 815
static void jmpTYA(struct machine_6502 *machine, enum anonymous_60 adm);
// jumpBranch
// file asm6502.c line 553
static void jumpBranch(struct machine_6502 *machine, unsigned short int offset);
// label
// file asm6502.c line 1548
static unsigned char label(char **s, struct anonymous_8 *param);
// linkLabels
// file asm6502.c line 2015
static void linkLabels(struct AsmLine *asmlist);
// linkit
// file asm6502.c line 2008
static unsigned char linkit(struct AsmLine *asmline, void *asmlist);
// m6502_build
// file asm6502.h line 136
struct machine_6502 * m6502_build(void);
// m6502_destroy6502
// file asm6502.c line 2113
void m6502_destroy6502(struct machine_6502 *machine);
// m6502_draw
// file m6502.c line 221
static unsigned long int m6502_draw(struct _XDisplay *dpy, unsigned long int window, void *closure);
// m6502_eval_file
// file asm6502.c line 2180
void m6502_eval_file(struct machine_6502 *machine, const char *filename, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState);
// m6502_eval_file::plot_object
//
void plot_object(unsigned char, unsigned char, unsigned char, void *);
// m6502_event
// file m6502.c line 282
static signed int m6502_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event);
// m6502_free
// file m6502.c line 294
static void m6502_free(struct _XDisplay *dpy, unsigned long int window, void *closure);
// m6502_hexDump
// file asm6502.c line 1738
void m6502_hexDump(struct machine_6502 *machine, unsigned short int start, unsigned short int numbytes, struct _IO_FILE *output);
// m6502_init
// file m6502.c line 119
static void * m6502_init(struct _XDisplay *dpy, unsigned long int window);
// m6502_next_eval
// file asm6502.h line 162
void m6502_next_eval(struct machine_6502 *machine, signed int insno);
// m6502_reshape
// file m6502.c line 274
static void m6502_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h);
// m6502_start_eval_file
// file asm6502.h line 149
void m6502_start_eval_file(struct machine_6502 *machine, const char *filename, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState);
// m6502_start_eval_file::plot_object
//
void plot_object(unsigned char, unsigned char, unsigned char, void *);
// m6502_start_eval_string
// file asm6502.h line 158
void m6502_start_eval_string(struct machine_6502 *machine, const char *code, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState);
// m6502_start_eval_string::plot_object
//
void plot_object(unsigned char, unsigned char, unsigned char, void *);
// m6502_trace
// file asm6502.c line 2118
void m6502_trace(struct machine_6502 *machine, struct _IO_FILE *output);
// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_25 *screen, struct _WidgetRec *toplevel, signed int width, signed int height);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// manZeroNeg
// file asm6502.c line 454
static void manZeroNeg(struct machine_6502 *machine, unsigned char value);
// memReadByte
// file asm6502.c line 206
static signed int memReadByte(struct machine_6502 *machine, signed int addr);
// memStoreByte
// file asm6502.c line 227
static void memStoreByte(struct machine_6502 *machine, signed int addr, signed int value);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// merge_options
// file screenhack.c line 182
static void merge_options(void);
// newAsmLine
// file asm6502.c line 1170
static struct AsmLine * newAsmLine(char *cmd, char *label, unsigned char decl, struct anonymous_8 *param, signed int lc);
// newLabel
// file asm6502.c line 1160
static struct anonymous_12 * newLabel(void);
// newParam
// file asm6502.c line 1136
static struct anonymous_8 * newParam(void);
// nibble
// file asm6502.c line 255
static unsigned char nibble(unsigned char value, enum anonymous_17 side);
// nullify
// file asm6502.c line 1264
static void nullify(char *token, unsigned int sourceLength);
// old_handler_object
//
signed int old_handler_object(struct _XDisplay *, struct anonymous_56 *);
// opIndex
// file asm6502.c line 1127
static signed int opIndex(struct machine_6502 *machine, unsigned char opcode, enum anonymous_60 *adm);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// paint_pixel
// file m6502.c line 174
static void paint_pixel(struct state *st, signed int x, signed int y, signed int idx);
// paramLabel
// file asm6502.c line 1390
static unsigned char paramLabel(char **s, char **label);
// parameter
// file asm6502.c line 1569
static unsigned char parameter(const char *cmd, char **s, struct anonymous_8 *param);
// parseAssembly
// file asm6502.c line 1606
static struct AsmLine * parseAssembly(struct machine_6502 *machine, unsigned char *codeOk, const char *code);
// parseDec
// file asm6502.c line 1364
static unsigned char parseDec(char **s, unsigned int *value);
// parseError
// file asm6502.c line 1241
static void parseError(char *s);
// parseHex
// file asm6502.c line 1346
static unsigned char parseHex(char **s, unsigned int *value);
// parseValue
// file asm6502.c line 1382
static unsigned char parseValue(char **s, unsigned int *value);
// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p);
// peekValue
// file asm6502.c line 267
static unsigned char peekValue(struct machine_6502 *machine, enum anonymous_60 adm, struct anonymous_15 *pointer, unsigned short int PC);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_13 * pick_best_gl_visual(struct anonymous_25 *screen);
// pick_best_visual
// file visual.c line 174
static struct anonymous_13 * pick_best_visual(struct anonymous_25 *screen, signed int prefer_writable_cells, signed int color_only);
// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_13 * pick_best_visual_of_class(struct anonymous_25 *screen, signed int visual_class);
// pick_mono_visual
// file visual.c line 218
static struct anonymous_13 * pick_mono_visual(struct anonymous_25 *screen);
// pick_visual
// file screenhack.c line 321
static struct anonymous_13 * pick_visual(struct anonymous_25 *screen);
// plot6502
// file m6502.c line 67
static void plot6502(unsigned char x, unsigned char y, unsigned char color, void *closure);
// popByte
// file asm6502.c line 185
static unsigned char popByte(struct machine_6502 *machine);
// popWord
// file asm6502.c line 196
static signed int popWord(struct machine_6502 *machine);
// posix_memalign
// file /usr/include/stdlib.h line 503
extern signed int posix_memalign(void **, unsigned long int, unsigned long int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// powf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern float powf(float, float);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 375
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_66 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous_66 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_66 *, union anonymous_63 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_63 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_63 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_63 *);
// puramp
// file analogtv.c line 119
static float puramp(const struct analogtv_s *it, float tc, float start, float over);
// pushByte
// file asm6502.c line 162
static void pushByte(struct machine_6502 *machine, unsigned int value);
// pushWord
// file asm6502.c line 175
static void pushWord(struct machine_6502 *machine, unsigned short int value);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset
// file asm6502.c line 1714
static void reset(struct machine_6502 *machine);
// rnd_combine
// file analogtv.c line 1184
static void rnd_combine(unsigned int *a0, unsigned int *c0, unsigned int a1, unsigned int c1);
// rnd_seek
// file analogtv.c line 1204
static unsigned int rnd_seek(unsigned int a, unsigned int c, unsigned int rnd, unsigned int dist);
// rnd_seek_ac
// file analogtv.c line 1190
static void rnd_seek_ac(unsigned int *a, unsigned int *c, unsigned int dist);
// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft);
// run_screenhack_table::1::fps_cb_object
//
void fps_cb_object(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
// run_screenhack_table::1::init_cb_object
//
void * init_cb_object(struct _XDisplay *, unsigned long int, void *);
// screen_number
// file visual.c line 475
extern signed int screen_number(struct anonymous_25 *screen);
// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_56 *error);
// screenhack_event_helper
// file ./../utils/resources.h line 39
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event);
// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event);
// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2);
// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_20 *, struct anonymous_20 *, struct anonymous_20 *, struct timeval *);
// setBit
// file asm6502.c line 247
static unsigned char setBit(unsigned char value, enum anonymous_18 bit, signed int on);
// shm_ehandler
// file xshm.c line 62
static signed int shm_ehandler(struct _XDisplay *dpy, struct anonymous_56 *error);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// skipSpace
// file asm6502.c line 1258
static void skipSpace(char **s);
// sleep
// file /usr/include/unistd.h line 447
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// sqrtf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern float sqrtf(float);
// stackPop
// file asm6502.c line 150
static unsigned char stackPop(struct machine_6502 *machine);
// stackPush
// file asm6502.c line 134
static void stackPush(struct machine_6502 *machine, unsigned char value);
// start_rand_bin_prog
// file m6502.c line 78
static void start_rand_bin_prog(struct machine_6502 *machine, struct state *st);
// stoupper
// file asm6502.c line 1246
static void stoupper(char **s);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_3 *f, const char *c, signed int *height_ret);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 533
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 622
extern signed long int sysconf(signed int);
// thread_memory_alignment
// file ./../utils/thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy);
// threadpool_create
// file ./../utils/thread_util.h line 303
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count);
// threadpool_destroy
// file ./../utils/thread_util.h line 304
void threadpool_destroy(struct threadpool *self);
// threadpool_run
// file ./../utils/thread_util.h line 306
void threadpool_run(struct threadpool *self, void (*func)(void *));
// threadpool_run::func_object
//
void func_object(void *);
// threadpool_wait
// file ./../utils/thread_util.h line 307
void threadpool_wait(struct threadpool *self);
// threads_available
// file thread_util.c line 291
signed int threads_available(struct _XDisplay *dpy);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// translate
// file asm6502.c line 1770
static unsigned char translate(struct anonymous_61 *op, struct anonymous_8 *param, struct machine_6502 *machine);
// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc);
// updateDisplayPixel
// file asm6502.c line 211
static void updateDisplayPixel(struct machine_6502 *machine, unsigned short int addr);
// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2);
// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret);
// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length);
// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret);
// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_24 * utf8_to_XChar2b(const char *string, signed int *length_ret);
// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p);
// value
// file asm6502.c line 1511
static unsigned char value(char **s, struct anonymous_8 *param);
// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_25 *screen, struct anonymous_13 *visual);
// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_25 *screen, struct anonymous_13 *visual);
// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_25 *screen, struct anonymous_13 *visual);
// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_25 *screen, unsigned long int window, struct anonymous_13 *visual, unsigned long int cmap, signed int window_p);
// warnValue
// file asm6502.c line 459
static void warnValue(unsigned char isValue);
// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed);
// ya_random
// file ./../utils/yarandom.h line 36
extern unsigned int ya_random(void);

struct anonymous_68
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous_65
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous_64 argKind;
  // value
  char *value;
};

struct anonymous_19
{
  // visual
  struct anonymous_13 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_25
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_23 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_13 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_2
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_1 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_25 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_1
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_6
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_3
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous_5 *properties;
  // min_bounds
  struct anonymous_6 min_bounds;
  // max_bounds
  struct anonymous_6 max_bounds;
  // per_char
  struct anonymous_6 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_13
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_20
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_61
{
  // name
  char name[4l];
  // Imm
  unsigned char Imm;
  // ZP
  unsigned char ZP;
  // ZPX
  unsigned char ZPX;
  // ZPY
  unsigned char ZPY;
  // ABS
  unsigned char ABS;
  // ABSX
  unsigned char ABSX;
  // ABSY
  unsigned char ABSY;
  // INDX
  unsigned char INDX;
  // INDY
  unsigned char INDY;
  // SNGL
  unsigned char SNGL;
  // BRA
  unsigned char BRA;
  // func
  void (*func)(struct machine_6502 *, enum anonymous_60);
};

struct anonymous
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_16
{
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_23
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_13 *visuals;
};

struct anonymous_4
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_21
{
  // index
  signed int index;
  // value
  double value;
};

struct anonymous_56
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_58
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_59
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_51
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_57
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_53
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_53 data;
};

struct anonymous_30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_7
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_13 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_25 *screen;
};

struct anonymous_8
{
  // type
  enum anonymous_60 type;
  // value
  unsigned int value[25l];
  // vp
  unsigned int vp;
  // label
  char *label;
  // lbladdr
  unsigned int lbladdr;
};

struct anonymous_15
{
  // addr
  unsigned short int addr;
  // value
  unsigned short int value;
};

struct anonymous_12
{
  // addr
  unsigned int addr;
  // label
  char *label;
};

struct anonymous_67
{
  // request_mode
  unsigned int request_mode;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // sibling
  struct _WidgetRec *sibling;
  // stack_mode
  signed int stack_mode;
};

struct anonymous_10
{
  // size
  unsigned int size;
  // addr
  char *addr;
};

struct anonymous_0
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_5
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_9
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_14
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_24
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

struct anonymous_62
{
  // index
  unsigned char index;
  // adm
  enum anonymous_60 adm;
};

union anonymous_22
{
  // f
  float f;
  // i
  signed int i;
};

union anonymous_66
{
  // __data
  struct anonymous __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_63
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AsmLine
{
  // labelDecl
  unsigned char labelDecl;
  // label
  struct anonymous_12 *label;
  // command
  char *command;
  // param
  struct anonymous_8 *param;
  // next
  struct AsmLine *next;
};

struct _CoreClassPart
{
  // superclass
  struct _WidgetClassRec *superclass;
  // class_name
  char *class_name;
  // widget_size
  unsigned int widget_size;
  // class_initialize
  void (*class_initialize)(void);
  // class_part_initialize
  void (*class_part_initialize)(struct _WidgetClassRec *);
  // class_inited
  unsigned char class_inited;
  // initialize
  void (*initialize)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_68 *, unsigned int *);
  // initialize_hook
  void (*initialize_hook)(struct _WidgetRec *, struct anonymous_68 *, unsigned int *);
  // realize
  void (*realize)(struct _WidgetRec *, unsigned long int *, struct anonymous_0 *);
  // actions
  struct _XtActionsRec *actions;
  // num_actions
  unsigned int num_actions;
  // resources
  struct _XtResource *resources;
  // num_resources
  unsigned int num_resources;
  // xrm_class
  signed int xrm_class;
  // compress_motion
  char compress_motion;
  // compress_exposure
  unsigned char compress_exposure;
  // compress_enterleave
  char compress_enterleave;
  // visible_interest
  char visible_interest;
  // destroy
  void (*destroy)(struct _WidgetRec *);
  // resize
  void (*resize)(struct _WidgetRec *);
  // expose
  void (*expose)(struct _WidgetRec *, union _XEvent *, struct _XRegion *);
  // set_values
  char (*set_values)(struct _WidgetRec *, struct _WidgetRec *, struct _WidgetRec *, struct anonymous_68 *, unsigned int *);
  // set_values_hook
  char (*set_values_hook)(struct _WidgetRec *, struct anonymous_68 *, unsigned int *);
  // set_values_almost
  void (*set_values_almost)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_67 *, struct anonymous_67 *);
  // get_values_hook
  void (*get_values_hook)(struct _WidgetRec *, struct anonymous_68 *, unsigned int *);
  // accept_focus
  char (*accept_focus)(struct _WidgetRec *, unsigned long int *);
  // version
  unsigned long int version;
  // callback_private
  void *callback_private;
  // tm_table
  char *tm_table;
  // query_geometry
  enum anonymous_69 (*query_geometry)(struct _WidgetRec *, struct anonymous_67 *, struct anonymous_67 *);
  // display_accelerator
  void (*display_accelerator)(struct _WidgetRec *, char *);
  // extension
  void *extension;
};

struct _XtTMRec
{
  // translations
  struct _TranslationData *translations;
  // proc_table
  void (**proc_table)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
  // current_state
  struct _XtStateRec *current_state;
  // lastEventTime
  unsigned long int lastEventTime;
};

struct _CorePart
{
  // self
  struct _WidgetRec *self;
  // widget_class
  struct _WidgetClassRec *widget_class;
  // parent
  struct _WidgetRec *parent;
  // xrm_name
  signed int xrm_name;
  // being_destroyed
  char being_destroyed;
  // destroy_callbacks
  struct _XtCallbackRec *destroy_callbacks;
  // constraints
  void *constraints;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // managed
  char managed;
  // sensitive
  char sensitive;
  // ancestor_sensitive
  char ancestor_sensitive;
  // event_table
  struct _XtEventRec *event_table;
  // tm
  struct _XtTMRec tm;
  // accelerators
  struct _TranslationData *accelerators;
  // border_pixel
  unsigned long int border_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // popup_list
  struct _WidgetRec **popup_list;
  // num_popups
  unsigned int num_popups;
  // name
  char *name;
  // screen
  struct anonymous_25 *screen;
  // colormap
  unsigned long int colormap;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // background_pixel
  unsigned long int background_pixel;
  // background_pixmap
  unsigned long int background_pixmap;
  // visible
  char visible;
  // mapped_when_managed
  char mapped_when_managed;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _WidgetClassRec
{
  // core_class
  struct _CoreClassPart core_class;
};

struct _WidgetRec
{
  // core
  struct _CorePart core;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_26 xany;
  // xkey
  struct anonymous_27 xkey;
  // xbutton
  struct anonymous_28 xbutton;
  // xmotion
  struct anonymous_29 xmotion;
  // xcrossing
  struct anonymous_30 xcrossing;
  // xfocus
  struct anonymous_31 xfocus;
  // xexpose
  struct anonymous_32 xexpose;
  // xgraphicsexpose
  struct anonymous_33 xgraphicsexpose;
  // xnoexpose
  struct anonymous_34 xnoexpose;
  // xvisibility
  struct anonymous_35 xvisibility;
  // xcreatewindow
  struct anonymous_36 xcreatewindow;
  // xdestroywindow
  struct anonymous_37 xdestroywindow;
  // xunmap
  struct anonymous_38 xunmap;
  // xmap
  struct anonymous_39 xmap;
  // xmaprequest
  struct anonymous_40 xmaprequest;
  // xreparent
  struct anonymous_41 xreparent;
  // xconfigure
  struct anonymous_42 xconfigure;
  // xgravity
  struct anonymous_43 xgravity;
  // xresizerequest
  struct anonymous_44 xresizerequest;
  // xconfigurerequest
  struct anonymous_45 xconfigurerequest;
  // xcirculate
  struct anonymous_46 xcirculate;
  // xcirculaterequest
  struct anonymous_47 xcirculaterequest;
  // xproperty
  struct anonymous_48 xproperty;
  // xselectionclear
  struct anonymous_49 xselectionclear;
  // xselectionrequest
  struct anonymous_50 xselectionrequest;
  // xselection
  struct anonymous_51 xselection;
  // xcolormap
  struct anonymous_52 xcolormap;
  // xclient
  struct anonymous_54 xclient;
  // xmapping
  struct anonymous_55 xmapping;
  // xerror
  struct anonymous_56 xerror;
  // xkeymap
  struct anonymous_57 xkeymap;
  // xgeneric
  struct anonymous_58 xgeneric;
  // xcookie
  struct anonymous_59 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_13 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtCallbackRec
{
  // callback
  void (*callback)(struct _WidgetRec *, void *, void *);
  // closure
  void *closure;
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct _parallel_startup_type
{
  // parent
  struct threadpool *parent;
  // thread_create
  signed int (*thread_create)(void *, struct threadpool *, unsigned int);
  // last_errno
  signed int last_errno;
};

struct analogtv_font_s
{
  // text_im
  struct _XImage *text_im;
  // char_w
  signed int char_w;
  // char_h
  signed int char_h;
  // x_mult
  signed int x_mult;
  // y_mult
  signed int y_mult;
};

struct analogtv_input_s
{
  // signal
  signed char signal[263l][912l];
  // do_teletext
  signed int do_teletext;
  // updater
  void (*updater)(struct analogtv_input_s *);
  // client_data
  void *client_data;
  // next_update_time
  double next_update_time;
};

struct analogtv_reception_s
{
  // input
  struct analogtv_input_s *input;
  // ofs
  double ofs;
  // level
  double level;
  // multipath
  double multipath;
  // freqerr
  double freqerr;
  // ghostfir
  double ghostfir[4l];
  // ghostfir2
  double ghostfir2[4l];
  // hfloss
  double hfloss;
  // hfloss2
  double hfloss2;
};

struct threadpool
{
  // count
  unsigned int count;
  // thread_size
  unsigned long int thread_size;
  // thread_run
  void (*thread_run)(void *);
  // thread_destroy
  void (*thread_destroy)(void *);
  // serial_threads
  void *serial_threads;
  // mutex
  union anonymous_63 mutex;
  // cond
  union anonymous_66 cond;
  // parallel_pending
  unsigned int parallel_pending;
  // parallel_unfinished
  unsigned int parallel_unfinished;
  // parallel_threads
  unsigned long int *parallel_threads;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct analogtv_s
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // screen
  struct anonymous_25 *screen;
  // xgwa
  struct anonymous_7 xgwa;
  // threads
  struct threadpool threads;
  // n_colors
  signed int n_colors;
  // interlace
  signed int interlace;
  // interlace_counter
  signed int interlace_counter;
  // agclevel
  float agclevel;
  // tint_control
  float tint_control;
  // color_control
  float color_control;
  // brightness_control
  float brightness_control;
  // contrast_control
  float contrast_control;
  // height_control
  float height_control;
  // width_control
  float width_control;
  // squish_control
  float squish_control;
  // horiz_desync
  float horiz_desync;
  // squeezebottom
  float squeezebottom;
  // powerup
  float powerup;
  // blur_mult
  signed int blur_mult;
  // fakeit_top
  signed int fakeit_top;
  // fakeit_bot
  signed int fakeit_bot;
  // fakeit_scroll
  signed int fakeit_scroll;
  // redraw_all
  signed int redraw_all;
  // use_shm
  signed int use_shm;
  // use_cmap
  signed int use_cmap;
  // use_color
  signed int use_color;
  // bilevel_signal
  signed int bilevel_signal;
  // shm_info
  struct anonymous_14 shm_info;
  // visdepth
  signed int visdepth;
  // visclass
  signed int visclass;
  // visbits
  signed int visbits;
  // red_invprec
  signed int red_invprec;
  // red_shift
  signed int red_shift;
  // green_invprec
  signed int green_invprec;
  // green_shift
  signed int green_shift;
  // blue_invprec
  signed int blue_invprec;
  // blue_shift
  signed int blue_shift;
  // red_mask
  unsigned int red_mask;
  // green_mask
  unsigned int green_mask;
  // blue_mask
  unsigned int blue_mask;
  // colormap
  unsigned long int colormap;
  // usewidth
  signed int usewidth;
  // useheight
  signed int useheight;
  // xrepl
  signed int xrepl;
  // subwidth
  signed int subwidth;
  // image
  struct _XImage *image;
  // gc
  struct _XGC *gc;
  // screen_xo
  signed int screen_xo;
  // screen_yo
  signed int screen_yo;
  // flutter_horiz_desync
  signed int flutter_horiz_desync;
  // flutter_tint
  signed int flutter_tint;
  // last_display_time
  struct timeval last_display_time;
  // need_clear
  signed int need_clear;
  // hashnoise_rpm
  double hashnoise_rpm;
  // hashnoise_counter
  signed int hashnoise_counter;
  // hashnoise_times
  signed int hashnoise_times[262l];
  // hashnoise_signal
  signed int hashnoise_signal[262l];
  // hashnoise_on
  signed int hashnoise_on;
  // hashnoise_enable
  signed int hashnoise_enable;
  // shrinkpulse
  signed int shrinkpulse;
  // crtload
  float crtload[262l];
  // red_values
  unsigned int red_values[1024l];
  // green_values
  unsigned int green_values[1024l];
  // blue_values
  unsigned int blue_values[1024l];
  // colors
  unsigned long int colors[256l];
  // cmap_y_levels
  signed int cmap_y_levels;
  // cmap_i_levels
  signed int cmap_i_levels;
  // cmap_q_levels
  signed int cmap_q_levels;
  // tint_i
  float tint_i;
  // tint_q
  float tint_q;
  // cur_hsync
  signed int cur_hsync;
  // line_hsync
  signed int line_hsync[262l];
  // cur_vsync
  signed int cur_vsync;
  // cb_phase
  double cb_phase[4l];
  // line_cb_phase
  double line_cb_phase[262l][4l];
  // channel_change_cycles
  signed int channel_change_cycles;
  // rx_signal_level
  double rx_signal_level;
  // rx_signal
  float *rx_signal;
  // leveltable
  struct anonymous_21 leveltable[13l][13l];
  // random0
  unsigned int random0;
  // random1
  unsigned int random1;
  // noiselevel
  double noiselevel;
  // recs
  const struct analogtv_reception_s * const *recs;
  // rec_count
  unsigned int rec_count;
  // signal_subtotals
  float *signal_subtotals;
  // puheight
  float puheight;
};

struct analogtv_thread_s
{
  // it
  struct analogtv_s *it;
  // thread_id
  unsigned int thread_id;
  // signal_start
  unsigned long int signal_start;
  // signal_end
  unsigned long int signal_end;
};

struct analogtv_yiq_s
{
  // y
  float y;
  // i
  float i;
  // q
  float q;
};

struct fps_state
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // font
  struct anonymous_3 *font;
  // clear_p
  signed int clear_p;
  // string
  char string[1024l];
  // gl_fps_data
  void *gl_fps_data;
  // draw_gc
  struct _XGC *draw_gc;
  // erase_gc
  struct _XGC *erase_gc;
  // last_ifps
  signed int last_ifps;
  // last_fps
  double last_fps;
  // frame_count
  signed int frame_count;
  // slept
  unsigned long int slept;
  // prev_frame_end
  struct timeval prev_frame_end;
  // this_frame_end
  struct timeval this_frame_end;
};

struct io_thread
{
  // status
  enum _io_thread_status status;
  // thread
  unsigned long int thread;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct machine_6502
{
  // codeCompiledOK
  unsigned char codeCompiledOK;
  // regA
  unsigned char regA;
  // regX
  unsigned char regX;
  // regY
  unsigned char regY;
  // regP
  unsigned char regP;
  // regPC
  unsigned short int regPC;
  // regSP
  unsigned short int regSP;
  // defaultCodePC
  unsigned short int defaultCodePC;
  // memory
  unsigned char memory[65536l];
  // runForever
  unsigned char runForever;
  // labelPtr
  signed int labelPtr;
  // codeRunning
  unsigned char codeRunning;
  // myInterval
  signed int myInterval;
  // opcodes
  struct anonymous_61 opcodes[56l];
  // screen
  signed int screen[32l][32l];
  // codeLen
  signed int codeLen;
  // opcache
  struct anonymous_62 opcache[255l];
  // plot
  void (*plot)(unsigned char, unsigned char, unsigned char, void *);
  // plotterState
  void *plotterState;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct state
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // pixels
  unsigned char pixels[32l][32l];
  // machine
  struct machine_6502 *machine;
  // tv
  struct analogtv_s *tv;
  // inp
  struct analogtv_input_s *inp;
  // reception
  struct analogtv_reception_s reception;
  // pixw
  signed int pixw;
  // pixh
  signed int pixh;
  // topb
  signed int topb;
  // field_ntsc
  signed int field_ntsc[4l];
  // dt
  signed int dt;
  // which
  signed int which;
  // demos
  signed int demos;
  // start_time
  struct timeval start_time;
  // reset_p
  signed int reset_p;
};

struct threadpool_class
{
  // size
  unsigned long int size;
  // create
  signed int (*create)(void *, struct threadpool *, unsigned int);
  // destroy
  void (*destroy)(void *);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct xscreensaver_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char * const *defaults;
  // options
  const struct anonymous_65 *options;
  // setup_cb
  void (*setup_cb)(struct xscreensaver_function_table *, void *);
  // setup_arg
  void *setup_arg;
  // init_cb
  void * (*init_cb)(struct _XDisplay *, unsigned long int);
  // draw_cb
  unsigned long int (*draw_cb)(struct _XDisplay *, unsigned long int, void *);
  // reshape_cb
  void (*reshape_cb)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int);
  // event_cb
  signed int (*event_cb)(struct _XDisplay *, unsigned long int, void *, union _XEvent *);
  // free_cb
  void (*free_cb)(struct _XDisplay *, unsigned long int, void *);
  // fps_cb
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
  // pick_visual_hook
  struct anonymous_13 * (*pick_visual_hook)(struct anonymous_25 *);
  // validate_visual_hook
  signed int (*validate_visual_hook)(struct anonymous_25 *, const char *, struct anonymous_13 *);
};


// XA_WM_DELETE_WINDOW
// file screenhack.c line 263
static unsigned long int XA_WM_DELETE_WINDOW;
// XA_WM_PROTOCOLS
// file screenhack.c line 263
static unsigned long int XA_WM_PROTOCOLS;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _cache_line_size
// file thread_util.c line 288
static signed int _cache_line_size = (signed int)sizeof(void *) /*8ul*/ ;
// _has_pthread
// file thread_util.c line 287
static signed int _has_pthread = 0;
// a
// file yarandom.c line 73
static unsigned int a[55l] = { 035340171546, (unsigned int)010401501101, 022364657325, 024130436022, (unsigned int)002167303062, 037570375137, 037210607110, (unsigned int)016272055420, 023011770546, (unsigned int)017143426366, (unsigned int)014753657433, 021657231332, 023553406142, (unsigned int)004236526362, (unsigned int)010365611275, (unsigned int)007117336710, (unsigned int)011051276551, (unsigned int)002362132524, (unsigned int)001011540233, (unsigned int)012162531646, (unsigned int)007056762337, (unsigned int)006631245521, (unsigned int)014164542224, 032633236305, 023342700176, (unsigned int)002433062234, (unsigned int)015257225043, 026762051606, (unsigned int)000742573230, (unsigned int)005366042132, (unsigned int)012126416411, (unsigned int)000520471171, (unsigned int)000725646277, 020116577576, 025765742604, (unsigned int)007633473735, (unsigned int)015674255275, (unsigned int)017555634041, (unsigned int)006503154145, 021576344247, (unsigned int)014577627653, (unsigned int)002707523333, 034146376720, 030060227734, (unsigned int)013765414060, 036072251540, (unsigned int)007255221037, 024364674123, (unsigned int)006200353166, (unsigned int)010126373326, (unsigned int)015664104320, (unsigned int)016401041535, (unsigned int)016215305520, 033115351014, (unsigned int)017411670323 };
// cond_initializer
// file thread_util.c line 285
const union anonymous_66 cond_initializer = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// default_defaults
// file screenhack.c line 163
static char *default_defaults[10l] = { ".root:\t\tfalse", "*geometry:\t\t1280x720", "*mono:\t\tfalse", "*installColormap:\tfalse", "*doFPS:\t\tfalse", "*multiSample:\tfalse", "*visualID:\t\tdefault", "*windowID:\t\t", "*desktopGrabber:\txscreensaver-getimage %s",
    ((char *)NULL) };
// default_options
// file screenhack.c line 141
static struct anonymous_65 default_options[11l] = { { .option="-root", .specifier=".root", .argKind=(enum anonymous_64)XrmoptionNoArg, .value="True" },
    { .option="-window", .specifier=".root", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="False" },
    { .option="-mono", .specifier=".mono", .argKind=(enum anonymous_64)XrmoptionNoArg, .value="True" },
    { .option="-install", .specifier=".installColormap", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="True" },
    { .option="-noinstall", .specifier=".installColormap", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="False" },
    { .option="-visual", .specifier=".visualID", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-window-id", .specifier=".windowID", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-fps", .specifier=".doFPS", .argKind=(enum anonymous_64)XrmoptionNoArg, .value="True" },
    { .option="-no-fps", .specifier=".doFPS", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="False" },
    { .option="-pair", .specifier=".pair", .argKind=(enum anonymous_64)XrmoptionNoArg, .value="True" },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_64)0,
    .value=((char *)NULL) } };
// demo_files
// file m6502.c line 26
static const char * const demo_files[27l] = { "start:\n  lda #_b\n  jsr setcol\n  jsr delay\n  lda #_f\n  jsr setcol\n  jsr delay\n  lda #_1\n  jsr setcol\n  jsr delay\n  ldx #0\ncp:\n  lda pic,x\n  sta _200,x\n  lda pic2,x\n  sta _300,x\n  lda pic3,x\n  sta _400,x\n  lda pic4,x\n  sta _500,x\n  dex\n  bne cp\n  rts\nsetcol:\n  ldx #0\ns:sta _200,x\n  sta _300,x\n  sta _400,x\n  sta _500,x\n  dex\n  bne s\n  rts\ndelay:\n  ldy #29\nd1:\n  ldx #0\nd2:\n  dex\n  bne d2\n  dey\n  bne d1\n  rts\npic:\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0\n        dcb 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,0,_f,_f,_f\n        dcb _f,_f,_f,_f,0,0,0,_f,0,_e,_e,0,1,1,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,0,_f,_f,_f\n        dcb _f,_f,_f,_f,0,_e,0,_f,0,_e,_e,_e,0,1,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,0,_f,_f,_f\n        dcb _f,_f,_f,_f,0,_e,0,_f,0,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,0,_f,_f,_f\n        dcb _f,_f,_f,_f,0,0,0,_f,0,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,0,0,0,0\n        dcb 0,0,0,0,0,0,0,0,0,_e,_e,_e,_e,0,1,1\n \npic2:\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,_e,_e,_e,_e\n        dcb _e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,_e,_e,_e,_e\n        dcb _e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,_e,_e,_e,_e\n        dcb _e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,_e,_e,_e,_e,_e,_e,_e\n        dcb _e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,1,0,_e,0,0,0,0,0,0,0\n        dcb 0,0,0,0,0,0,0,0,0,0,0,_e,_e,0,1,1\n        dcb 1,1,1,1,1,1,0,0,_e,0,0,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,0,_e,_e,0,1,1\n        dcb 1,1,1,1,1,0,1,0,_e,0,0,0,0,1,1,_e\n        dcb _e,_e,1,_e,1,_e,1,_e,1,1,0,_e,_e,0,1,1\n        dcb 1,1,1,0,0,1,1,0,0,1,0,1,1,0,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,0,_e,_e,0,1,1\npic3:\n        dcb 1,1,0,1,1,1,0,1,1,1,1,0,0,1,1,1\n        dcb _e,1,_e,1,_e,1,_e,1,1,1,0,_e,_e,0,1,1\n        dcb 1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0\n        dcb 1,1,1,1,1,1,1,1,1,1,0,_e,_e,0,1,1\n        dcb 1,0,1,0,1,1,1,1,1,1,0,0,1,1,0,_f\n        dcb 0,1,0,1,1,1,0,0,0,1,0,_e,_e,0,1,1\n        dcb 1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0\n        dcb 0,_f,1,0,1,_f,1,0,1,1,0,_e,_e,0,1,1\n        dcb 1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0\n        dcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1\n        dcb 1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0\n        dcb 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1\n        dcb 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1\n        dcb 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\npic4:\n        dcb 1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0\n        dcb 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,0\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n        dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n\t\n",
    "init:\n lda #_fe\n sta _2\n lda #_ee\n sta _3\ndrawbox:\n lda #0\n sta _0\n lda #2\n sta _1\n ldx #_20\nboxloop:\n lda #2\n sta _1ff,x\n sta _5df,x\n ldy #0\n sta (_0),y\n ldy #_1f\n sta (_0),y\n cpx #_1\n beq noblocks\n lda #3\n ldy #_17\n sta (_0),y\n lda #4\n iny\n sta (_0),y\n lda #5\n iny\n sta (_0),y\n lda #6\n iny\n sta (_0),y\nnoblocks:\n clc\n lda _0\n adc #_20\n sta _0\n lda _1\n adc #0\n sta _1\n dex\n bne boxloop\n ldx _2\n ldy _3\n lda #_44\n sta _0\n lda #_02\n sta _1\ndrawball:\n txa\n pha\n lda #1\n ldx #0\n sta (_0,x)\n pla\n tax\ndecloop:\n dex\n beq updatexpos\n dey\n bne decloop\nupdateypos:\n txa\n pha\n jsr clearball\nupdateyposnoclear:\n lda _3\n and #1\n bne moveup\nmovedown:\n clc\n lda _0\n adc #_20\n sta _0\n bcc ycollision\n inc _1\n bne ycollision\nmoveup:\n sec\n lda _0\n sbc #_20\n sta _0\n lda _1\n sbc #_0\n sta _1\nycollision:\n ldx #0\n lda (_0,x)\n bne ycollided\n ldy _3\n pla\n tax\n jmp drawball\nycollided:\n cmp #_2\n beq ycollided2\n lda #0\n sta (_0,x)\nycollided2:\n lda #1\n eor _3\n sta _3\n jmp updateyposnoclear\nupdatexpos:\n jsr clearball\nupdatexposnoclear:\n lda _2\n and #1\n bne moveleft\nmoveright:\n inc _0\n bne xcollision\nmoveleft:\n dec _0\nxcollision:\n ldx #0\n lda (_0,x)\n bne xcollided\n ldx _2\n jmp drawball\nxcollided:\n cmp #_2\n beq xcollided2\n lda #0\n sta (_0,x)\nxcollided2:\n lda #1\n eor _2\n sta _2\n jmp updatexposnoclear\nclearball:\n lda #0\n tax\n sta (_0,x)\n rts\n",
    " \nstart:\n  lda #<logo\n  sta _0\n  lda #>logo\n  sta _1\n  lda #_00\n  sta _2\n  lda #_02\n  sta _3\ndecrunchLoop:\n  lda _3\n  cmp #_6\n  bne moreWork \n  rts\nmoreWork:\n  ldy #0\n  lda (_0),y\n  cmp #_ff\n  bne notCrunched\n  iny\n  lda (_0),y\n  sta _4\n  iny\n  lda (_0),y\n  ldy _4\ndrawLoop:\n  ldx #0\n  sta (_2,x)\n  jsr nextPixel\n  dey\n  bne drawLoop\n  jsr getNextByte\n  jsr getNextByte\n  jmp decrunchLoop\nnotCrunched:\n  ldx #0\n  sta (_2,x)\n  jsr nextPixel\n  jsr getNextByte\n  jmp decrunchLoop\ngetNextByte:\n  inc _0\n  lda _0\n  cmp #_00\n  bne notHi\n  inc _1\nnotHi:\n  rts\nnextPixel:\n  inc _2\n  ldx _2\n  cpx #_00\n  bne notNextLine\n  inc _3\nnotNextLine:\n  rts\nlogo:\n dcb _ff,43,1,_f,_f,_f,_c,_f,_f,_f,_ff,24,1,_c,_f,_c,0\n dcb _c,_f,_c,_ff,24,1,0,_f,_c,0,_c,_f,_c,_ff,24,1\n dcb _c,_f,_c,0,_c,_f,_c,_ff,24,1,0,_f,_c,0,_c,_f,_c\n dcb _ff,24,1,_c,_f,0,0,_c,_f,_c,_ff,24,1,0,_f,_c,0\n dcb _c,_f,_c,_ff,24,1,0,_f,_c,0,_c,_f,0,_ff,24,1\n dcb 0,_f,_c,0,_c,_f,0,_ff,23,1,_f,0,_f,_c,0,_c,_f,0,_f\n dcb _ff,22,1,_c,0,1,_c,0,_c,_f,0,_c,_ff,21,1\n dcb _f,0,0,1,0,0,_c,1,0,0,_ff,21,1,_c,0,_c,1,_c,0\n dcb _c,1,_c,0,_c,_ff,19,1,_f,0,0,_f,1,_c,0\n dcb _c,1,_f,0,0,_f,_ff,17,1,_f,0,0,0,1,1,_c,0\n dcb _c,1,1,0,0,0,_ff,16,1,_f,0,0,0,_f,1,1,0,0\n dcb _c,1,1,_f,0,0,0,_f,_ff,13,1\n dcb _c,0,0,0,_c,1,1,1,_c,0,_c,1,1,1,_c,0,0,0,_c\n dcb _ff,10,1,_c,0,0,0,0,_c,1,1,1,1,0,0\n dcb _c,1,1,1,1,0,0,0,0,0,_c,_ff,8,1\n dcb 0,0,0,0,_c,1,1,1,1,1,0,0\n dcb _c,1,1,1,1,1,_c,0,0,0,0,1,1,1,1,1\n dcb 1,1,1,1,0,0,_c,1,1,1,1,1,1,1,_c,0\n dcb _c,1,1,1,1,1,1,_f,_c,0,0,_ff,18,1,_f\n dcb _ff,53,1,0,_f,1,0,0,0,0,0,_f,1,_c\n dcb _c,1,1,1,_c,0,0,0,1,1,0,_f,_f,1,1,1\n dcb 1,1,1,1,_c,0,0,1,1,1,0,_f,1,1,_f,0\n dcb 0,_f,1,1,0,_f,1,_c,_c,1,0,_f,1,1,1,1\n dcb 1,1,1,1,0,_f,0,_f,1,1,0,_f,1,1,_f,_c\n dcb _c,_c,1,1,0,1,1,_f,0,1,0,_f,1,1,1,1\n dcb 1,1,1,1,0,1,_c,_f,1,1,_c,_f,1,1,0,_f\n dcb _f,0,1,1,0,_f,_f,0,_f,1,0,_f,1,1,1,1\n dcb 1,1,1,_c,0,_c,0,0,1,1,0,_f,1,1,0,_c\n dcb _c,0,_f,1,0,_f,0,_f,1,1,0,_f,1,1,1,1\n dcb 1,1,1,0,_c,_f,_f,0,_f,1,_c,_f,1,_c,_c,_f\n dcb _f,_c,_c,1,0,1,_f,_c,1,1,0,_f,1,1,1,1\n dcb 1,1,_f,0,1,1,1,_c,_c,1,0,_f,1,0,_f,1\n dcb 1,_f,0,1,0,_f,1,0,_f,1,0,_f,_ff,16,1\n dcb _f,_ff,5,1,_f,1,1,1,_f,_ff,38,1\n",
    " lda #1\n sta _20f\nl3:\n lda #2\n sta 3\n sta 5\n sta 7\n lda #1\n sta 9\n sta 6\n lda #255\n sta 8\n lda #0\n sta 2\n lda #32\n sta 4\n ldx #30\nl1:\n ldy #31\nl2:\n lda (_2),y\n ora (_6),y\n eor (_8),y\n sta (_4),y\n dey\n bpl l2\n lda _2\n adc #32\n sta _2\n lda _3\n adc #0\n sta _3\n lda _4\n adc #32\n sta _4\n lda _5\n adc #0\n sta _5\n lda _6\n adc #32\n sta _6\n lda _7\n adc #0\n sta _7\n lda _8\n adc #32\n sta _8\n lda _9\n adc #0\n sta _9\n dex\n bpl l1\n ldy #31\nl4:\n lda (_2),y\n sta _200,y\n dey\n bpl l4\n jmp l3\n",
    " lda #1\n sta _22f\nl3:\n ldy #29\nl2:\n lda  _220,y\n adc _221,y\n adc _222,y\n tax\n lda rule,x\n sta  _201,y\n dey\n bpl l2\n ldy #_c0\n sec\nll2:\n lda _503,y\n sta _523,y\n sta _53b,y\n lda _504,y\n sta _524,y\n sta _53a,y\n lda _505,y\n sta _525,y\n sta _539,y\n lda _506,y\n sta _526,y\n sta _538,y\n lda _507,y\n sta _527,y\n sta _537,y\n lda _508,y\n sta _528,y\n sta _536,y\n lda _509,y\n sta _529,y\n sta _535,y\n lda _50a,y\n sta _52a,y\n sta _534,y\n lda _50b,y\n sta _52b,y\n sta _533,y\n lda _50c,y\n sta _52c,y\n sta _532,y\n lda _50d,y\n sta _52d,y\n sta _531,y\n lda _50e,y\n sta _52e,y\n sta _530,y\n lda _50f,y\n sta _52f,y\n tya\n adc #_df\n tay\n bcs ll2\n ldy #_e0\n sec\nll3:\n lda _403,y\n sta _423,y\n sta _43b,y\n lda _404,y\n sta _424,y\n sta _43a,y\n lda _405,y\n sta _425,y\n sta _439,y\n lda _406,y\n sta _426,y\n sta _438,y\n lda _407,y\n sta _427,y\n sta _437,y\n lda _408,y\n sta _428,y\n sta _436,y\n lda _409,y\n sta _429,y\n sta _435,y\n lda _40a,y\n sta _42a,y\n sta _434,y\n lda _40b,y\n sta _42b,y\n sta _433,y\n lda _40c,y\n sta _42c,y\n sta _432,y\n lda _40d,y\n sta _42d,y\n sta _431,y\n lda _40e,y\n sta _42e,y\n sta _430,y\n lda _40f,y\n sta _42f,y\n tya\n adc #_df\n tay\n bcs ll3\n ldy #_e0\n sec\nll4:\n lda _303,y\n sta _323,y\n sta _33b,y\n lda _304,y\n sta _324,y\n sta _33a,y\n lda _305,y\n sta _325,y\n sta _339,y\n lda _306,y\n sta _326,y\n sta _338,y\n lda _307,y\n sta _327,y\n sta _337,y\n lda _308,y\n sta _328,y\n sta _336,y\n lda _309,y\n sta _329,y\n sta _335,y\n lda _30a,y\n sta _32a,y\n sta _334,y\n lda _30b,y\n sta _32b,y\n sta _333,y\n lda _30c,y\n sta _32c,y\n sta _332,y\n lda _30d,y\n sta _32d,y\n sta _331,y\n lda _30e,y\n sta _32e,y\n sta _330,y\n lda _30f,y\n sta _32f,y\n tya\n adc #_df\n tay\n bcs ll4\n ldy #_e0\n sec\nll1:\n lda _203,y\n sta _223,y\n sta _23b,y\n lda _204,y\n sta _224,y\n sta _23a,y\n lda _205,y\n sta _225,y\n sta _239,y\n lda _206,y\n sta _226,y\n sta _238,y\n lda _207,y\n sta _227,y\n sta _237,y\n lda _208,y\n sta _228,y\n sta _236,y\n lda _209,y\n sta _229,y\n sta _235,y\n lda _20a,y\n sta _22a,y\n sta _234,y\n lda _20b,y\n sta _22b,y\n sta _233,y\n lda _20c,y\n sta _22c,y\n sta _232,y\n lda _20d,y\n sta _22d,y\n sta _231,y\n lda _20e,y\n sta _22e,y\n sta _230,y\n lda _20f,y\n sta _22f,y\n tya\n adc #_df\n tay\n bcs ll1\n jmp l3\nrule:\n dcb 0,2,0,1,1,2,0\n",
    " jmp _700\n *=_700\n ldx #0\t\t\n ldy #0\n lda #0\n sta _0\n sta _3\n lda #2\n sta _1\nloop:\n lda colors,x\n bpl ok\n inc _0\n ldx #0\n lda colors,x\nok:\n inx\n sta (_0),y\n iny\n bne ok2\n inc _1\n lda _1\n cmp #6\n beq end\nok2:\n jmp loop\nend:\n inc _3\n lda _3\n and #_3f\n tax\n ldy #0\n lda #2\n sta _1\n sty _0\n jmp loop\ncolors:\ndcb 0,2,0,2,2,8,2,8,8,7,8,7,7,1,7,1,1,7,1,7,7,8,7,8\ndcb 8,2,8,2,2,0,2,0,2,2,8,2,8,8,7,8,7,7,1,7,1,1,1,1\ndcb 1,1,1,1,7,1,7,7,8,7,8,8,2,8,2,2,255\n",
    "jmp init_font_table\nstart:\nlda #<y_start_pos1\nsta _b\nlda #>y_start_pos1\nsta _c\nlda #<y_start_pos2\nsta _d\nlda #>y_start_pos2\nsta _e\nlda #<y_start_pos3\nsta _f\nlda #>y_start_pos3\nsta _10\nlda #<y_start_pos4\nsta _11\nlda #>y_start_pos4\nsta _12\nlda #<y_start_pos5\nsta _13\nlda #>y_start_pos5\nsta _14\nlda #<y_start_pos4\nsta _15\nlda #>y_start_pos4\nsta _16\nlda #<y_start_pos3\nsta _17\nlda #>y_start_pos3\nsta _18\nlda #<y_start_pos2\nsta _19\nlda #>y_start_pos2\nsta _1a\nlda #0\nsta _8\nmain_loop:\ninc _1c\ninc _1d\nldy _8\nldx _b,y\ntxa\nsta _9\niny\nldx _b,y\ntxa\nsta _a\niny\ntya\ncmp #_10\nbne store_idx\nlda #0\nstore_idx:\nsta _8\nldy #0\nlda #_ff\nsta _4\ndisplay_loop:\n  inc _4\n  ldx _d0,y\n  stx _2\n  iny\n  ldx _d0,y\n  stx _3\n  sty _7\n  jsr dis_pat\n  inc _4\n  jsr dis_pat\n  ldy _7\n  iny\n  tya\n  cmp #_20\n  bne display_loop\njmp main_loop\nrts\ninit_font_table:\n  lda #<pattern_a\n  sta _d0\n  lda #>pattern_a\n  sta _d1\n  lda #<pattern_b\n  sta _d2\n  lda #>pattern_b\n  sta _d3\n  lda #<pattern_c\n  sta _d4\n  lda #>pattern_c\n  sta _d5\n  lda #<pattern_null\n  sta _d6\n  lda #>pattern_null\n  sta _d7\n  lda #<pattern_d\n  sta _d8\n  lda #>pattern_d\n  sta _d9\n  lda #<pattern_b\n  sta _da\n  lda #>pattern_b\n  sta _db\n  lda #<pattern_c\n  sta _dc\n  lda #>pattern_c\n  sta _dd\n  lda #<pattern_null\n  sta _de\n  lda #>pattern_null\n  sta _df\n  lda #<pattern_a\n  sta _e0\n  lda #>pattern_a\n  sta _e1\n  lda #<pattern_e\n  sta _e2\n  lda #>pattern_e\n  sta _e3\n  lda #<pattern_a\n  sta _e4\n  lda #>pattern_a\n  sta _e5\n  lda #<pattern_null\n  sta _e6\n  lda #>pattern_null\n  sta _e7\n  lda #<pattern_c\n  sta _e8\n  lda #>pattern_c\n  sta _e9\n  lda #<pattern_b\n  sta _ea\n  lda #>pattern_b\n  sta _eb\n  lda #<pattern_d\n  sta _ec\n  lda #>pattern_d\n  sta _ed\n  lda #<pattern_null\n  sta _ee\n  lda #>pattern_null\n  sta _ef\n  jmp start\ndis_pat:\n  ldy _4\n  lda (_9),y\n  tay\n  sty _5\n  ldy #0\ndis_pat_loop:\n  lda (_2),y\n  pha\n  tya\n  clc\n  adc _5\n  sty _6\n  tay\n  ldx _4\n  pla\n  beq go_paint\n  clc\n  sty _1b\n  tya\n  clc\n  adc _1c\n  and #_7\n  tay\n  lda color_row,y\n  ldy _1b\ngo_paint:\n  jsr paint\n  ldy _6\n  iny\n  tya\n  cmp #12\n  bne dis_pat_loop\n  rts\npaint:\n   pha\n   lda yl,y\n   sta _0\n   lda yh,y\n   sta _1\n   txa\n   tay\n   pla\n   sta (_0),y\n   rts\nyh:\n       dcb _02, _02, _02, _02, _02, _02, _02, _02\n       dcb _03, _03, _03, _03, _03, _03, _03, _03\n       dcb _04, _04, _04, _04, _04, _04, _04, _04\n       dcb _05, _05, _05, _05, _05, _05, _05, _05\nyl:\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0 \npattern_a:\n  dcb 0,1,1,1,1,1,1,1,1,1,1,0\npattern_b:\n  dcb 0,1,1,0,0,1,1,0,0,1,1,0\npattern_c:\n  dcb 0,1,1,0,0,1,1,1,1,1,1,0\npattern_d:\n  dcb 0,1,1,1,1,1,1,0,0,1,1,0\npattern_e:\n  dcb 0,1,1,0,0,0,0,0,0,1,1,0\npattern_null:\n  dcb 0,0,0,0,0,0,0,0,0,0,0,0\ny_start_pos1:\n  dcb 10,10,9,9,8,8,7,7,6,6,7,7,8,8,9,9,10,10,9,9,8,8,7,7\n  dcb 6,6,7,7,8,8\ny_start_pos2:\n  dcb 9,9,8,8,8,8,8,8,7,7,8,8,8,8,8,8,9,9,8,8,8,8,8,8\n  dcb 7,7,8,8,8,8\ny_start_pos3:\n  dcb 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8\n  dcb 8,8,8,8,8,8\ny_start_pos4:\n  dcb 7,7,8,8,8,8,8,8,9,9,8,8,8,8,8,8,7,7,8,8,8,8,8,8\n  dcb 9,9,8,8,8,8\ny_start_pos5:\n  dcb  6, 6,7,7,8,8,9,9,10,10,9,9,8,8,7,7, 6, 6,7,7,8,8,9,9\n  dcb 10,10,9,9,8,8\ncolor_row:\n  dcb _7,_8,_9,_2,_4,_6,_e,_3,_d,_5\n",
    "start:\n  ldx #0\nc:lda bottombar,x\n  cmp #_ff\n  beq init\n  sta _4e0,x\n  sta _5e0,x\n  inx\n  jmp c\ninit:\n  jsr initDraw\n  lda #0\n  sta _10\n  sta _11\nloop:\n  jsr drawMain\n  jsr putfont\n  jsr scrollarea\n  jmp loop\nscrollarea:\n  ldx #0\ng:lda _521,x\n  sta _520,x\n  lda _541,x\n  sta _540,x\n  lda _561,x\n  sta _560,x\n  lda _581,x\n  sta _580,x\n  lda _5a1,x\n  sta _5a0,x\n  inx\n  cpx #31\n  bne g\n  rts\nputfont:\n  lda _10\n  cmp #0\n  bne noNext\n  inc _11\n  ldx _11\n  lda scrolltext,x\n  tax\n  lda fontSize,x\n  sta _10\nnoNext:\n  dec _10\n  ldx _11\n  lda scrolltext,x\n  cmp #_ff\n  bne notResetText\n  lda #0\n  sta _10\n  sta _11\n  rts\nnotResetText:\n  asl\n  tax\n  lda fontlookup,x\n  sta _2\n  inx\n  lda fontlookup,x\n  sta _3\n  lda #<fonts\n  clc\n  adc _2\n  sta _0\n  lda #>fonts\n  adc _3\n  sta _1\n  ldy _10\n  lda (_00),y\n  sta _53f\n  tya\n  clc\n  adc #6\n  tay\n  lda (_00),y\n  sta _55f\n  tya\n  clc\n  adc #6\n  tay\n  lda (_00),y\n  sta _57f\n  tya\n  clc\n  adc #6\n  tay\n  lda (_00),y\n  sta _59f\n  tya\n  clc\n  adc #6\n  tay\n  lda (_00),y\n  sta _5bf\n  rts\ninitDraw:\n  lda #<picture\n  sta _20\n  lda #>picture\n  sta _21\n  lda #_00\n  sta _22\n  lda #_02\n  sta _23\n  ldx #_0\n  rts\ndrawMain:\n  ldx #0\n  lda (_20,x)\n  cmp #_ff\n  beq done\n  sta (_22,x)\n  inc _20\n  lda _20\n  cmp #_00\n  bne n1\n  inc _21\nn1:\n  inc _22\n  lda _22 \n  cmp #_00\n  bne done\n  lda _23\n  cmp #_05\n  beq done\n  inc _23\ndone:\n  rts\npicture:\n  dcb 0,0,0,0,0,0,0,0,0,_b,_b,_c,_f,_f,_f,_f\n  dcb _f,_b,0,0,0,_b,_b,_c,_c,_f,_f,_b,0,0,0,0\n  dcb 0,0,0,0,0,0,0,0,0,_b,_c,_c,_f,_c,_f,_f\n  dcb _b,_b,_b,_b,_b,0,_b,_b,_c,_f,_f,_c,0,0,0,0\n  dcb 0,0,0,0,0,0,0,_b,0,_c,_b,_f,_c,_f,_f,_c\n  dcb _c,_b,0,_b,_c,_c,_c,_f,_f,1,_f,_c,_b,0,0,0\n  dcb 0,0,0,0,0,0,0,0,_b,_b,_c,_c,_c,_f,_f,_f\n  dcb _c,_c,_c,_c,_c,_c,_f,_c,_f,_f,_f,_f,_b,0,0,0\n  dcb 0,0,0,0,0,0,0,_b,0,0,_b,_c,_c,_f,_f,_f\n  dcb _f,_c,_f,_f,_f,_f,_f,_f,_f,1,_f,_f,_c,0,0,0\n  dcb 0,0,0,0,0,0,0,0,0,_b,_b,_b,_c,_f,_f,1\n  dcb _f,_f,_c,_f,_f,_f,1,_f,_f,_f,_f,_f,_f,0,0,0\n  dcb 0,0,0,0,0,0,0,0,0,_b,_b,_b,_b,_c,_f,1\n  dcb _f,_f,_f,_f,_f,_f,_f,_f,1,_f,_f,_f,_f,_b,0,0\n  dcb 0,0,0,0,0,0,0,0,_b,0,_b,_c,_b,_c,_c,1\n  dcb 1,_f,1,_f,1,_f,1,_f,_f,1,_f,_f,1,_b,0,0\n  dcb 0,0,0,0,0,0,0,_b,_b,_b,_c,_c,_b,_c,_f,1\n  dcb 1,1,_f,_f,1,_f,_f,1,_f,_f,_f,_f,1,_c,0,0\n  dcb 0,0,0,0,0,0,0,_b,_b,_c,_c,_c,_b,_c,_c,_f\n  dcb 1,1,1,_f,_f,1,_f,1,_f,1,_f,_f,1,_c,0,0\n  dcb 0,0,0,0,0,_b,_b,_b,_c,_c,_c,_f,_c,_c,_f,_f\n  dcb 1,1,1,1,_f,_f,_f,1,_f,1,_f,_f,_f,_f,0,0\n  dcb 0,0,0,0,0,0,_b,_c,_c,_c,_f,_c,_f,_c,_f,_f\n  dcb 1,1,1,1,1,_f,_f,1,_f,_f,_f,_f,1,_f,_b,0\n  dcb 0,0,0,0,_b,_b,_b,_c,_c,_f,_c,_f,_f,_c,_f,_f\n  dcb 1,1,1,1,1,_f,_f,_f,1,_f,_f,_f,1,_c,_b,_b\n  dcb 0,0,0,0,_b,_b,_c,_f,_c,_f,_f,_f,_f,_f,_c,_f\n  dcb 1,1,1,1,1,_f,_f,_f,1,_f,_f,_f,_f,_f,_b,_b\n  dcb 0,0,0,0,_b,_c,_c,_c,_f,_f,_f,_f,_f,_f,_f,_f\n  dcb _f,1,1,1,_f,_b,_f,_f,_f,1,_f,_f,_f,_f,_b,_b\n  dcb 0,0,0,0,_b,_c,_c,_f,_c,_f,_f,_f,_f,_f,_f,_f\n  dcb _f,_f,_f,_c,_b,_f,_f,1,_f,_f,_f,_f,_f,_f,_c,_b\n  dcb 0,0,0,0,_b,_b,_c,_c,_f,_c,_f,_f,_f,_f,_f,_f\n  dcb _c,_c,_b,_c,_c,_f,_f,1,_c,_c,_f,_f,_f,_f,_c,_b\n  dcb 0,0,0,0,_b,_b,_c,_c,_c,_f,_f,_f,_f,_f,_f,_f\n  dcb _f,_f,_f,_f,_f,1,_f,_c,_b,_f,_c,_f,_c,_f,_c,_b\n  dcb 0,0,0,0,0,_b,_c,_c,_c,_c,_f,_f,_f,_f,_f,_f\n  dcb _f,_f,_f,_f,_f,_c,_b,_c,_c,_c,_f,_f,_c,_f,_c,_c\n  dcb 0,0,0,0,0,_b,_b,_c,_c,_c,_c,_c,_f,_f,_f,_f\n  dcb _f,_f,_f,_c,_b,_b,_c,_c,_c,_f,_c,_f,_f,_f,_c,_b\n  dcb 0,0,0,0,0,_b,_b,_b,_b,_c,_c,_f,_c,_f,_f,_f\n  dcb _c,_c,_b,_b,_b,_c,_b,_b,_c,_c,_f,_c,_c,_f,_c,_c\n  dcb 0,0,0,0,0,0,_b,_b,_c,_b,_c,_c,_c,_c,_c,_c\n  dcb _b,_b,_b,_b,_c,_b,_b,_c,_c,_f,_f,_f,_c,_c,_c,_b\n  dcb 0,0,0,0,0,0,0,0,_b,_b,_b,_c,_c,_c,_c,_c\n  dcb _c,_c,_b,_b,_b,_b,_c,_c,_f,_f,_f,_c,_c,_c,_c,_c\n  dcb _ff\nfontSize:\n  dcb 5,5,5,5,5,5,5,5\n  dcb 2,5,5,5,6,6,5,5\n  dcb 6,5,5,4,5,6,6,6\n  dcb 6,5,2,3\nscrolltext:\n  dcb 0\n  dcb 14,13,11,24,27\n  dcb 03,04,15,19,07,27\n  dcb 12,0,10,4,18,27\n  dcb 8,19,27\n  dcb 15,14,18,18,8,1,11,4\n  dcb 26,26,26\n  dcb 19,7,8,18,27\n  dcb 8,18,27\n  dcb 19,7,4,27\n  dcb 5,8,17,18,19,27\n  dcb 3,4,12,14,27\n  dcb 12,0,3,4,27\n  dcb 8,13,27\n  dcb 19,7,8,18,27\n  dcb 4,13,21,26,26,26,26,27\n  dcb 7,14,15,4,27\n  dcb 24,14,20,27\n  dcb 11,8,10,4,27\n  dcb 8,19,26,26,26,27,27\n  dcb 22,22,22,26\n  dcb 3,4,15,19,7,26\n  dcb 14,17,6,27,27,27,27,27\n  dcb _ff\nfontlookup:\n  dcb _00,_00\n  dcb _20,_00\n  dcb _40,_00\n  dcb _60,_00\n  dcb _80,_00\n  dcb _a0,_00\n  dcb _c0,_00\n  dcb _e0,_00\n  dcb _00,_01\n  dcb _20,_01\n  dcb _40,_01\n  dcb _60,_01\n  dcb _80,_01\n  dcb _a0,_01\n  dcb _c0,_01\n  dcb _e0,_01\n  dcb _00,_02\n  dcb _20,_02\n  dcb _40,_02\n  dcb _60,_02\n  dcb _80,_02\n  dcb _a0,_02\n  dcb _c0,_02\n  dcb _e0,_02\n  dcb _00,_03\n  dcb _20,_03\n  dcb _40,_03\n  dcb _60,_03\nfonts:\n  dcb 0,1,1,0,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,0\n  dcb 0,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0\n  dcb 0,1,1,0,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,0,0,0\n  dcb 0,0\n  dcb 0,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0\n  dcb 1,1,1,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 1,1,1,1,0,0\n  dcb 0,0\n  dcb 1,1,1,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0\n  dcb 1,1,1,0,0,0\n  dcb 0,0,0,1,0,0\n  dcb 1,1,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,1,1,0,0,0\n  dcb 0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,0,0,0\n  dcb 0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,0,1,0,0\n  dcb 0,0,1,1,0,0\n  dcb 0,1,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 1,1,1,1,0,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 1,1,0,1,1,0\n  dcb 1,0,1,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,0,1,1,0\n  dcb 1,0,1,0,1,0\n  dcb 1,1,0,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 0,0\n  dcb 0,1,1,0,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,0,0,0\n  dcb 0,0\n  dcb 0,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,0\n  dcb 0,1,1,0,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,0,1,0,0\n  dcb 1,0,1,0,0,0\n  dcb 0,0\n  dcb 0,1,1,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,1,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 0,0\n  dcb 1,1,1,0,0,0\n  dcb 0,0,0,1,0,0\n  dcb 0,1,1,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 0,1,1,1,0,0\n  dcb 0,0\n  dcb 1,1,1,0,0,0\n  dcb 0,1,0,0,0,0\n  dcb 0,1,0,0,0,0\n  dcb 0,1,0,0,0,0\n  dcb 0,1,0,0,0,0\n  dcb 0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,0,0,1,0,0\n  dcb 1,1,1,0,0,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 0,1,0,1,0,0\n  dcb 0,0,1,0,0,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,0,0,1,0\n  dcb 1,0,1,0,1,0\n  dcb 1,1,0,1,1,0\n  dcb 1,0,0,0,1,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 0,1,0,1,0,0\n  dcb 0,0,1,0,0,0\n  dcb 0,1,0,1,0,0\n  dcb 1,0,0,0,1,0\n  dcb 0,0\n  dcb 1,0,0,0,1,0\n  dcb 0,1,0,1,0,0\n  dcb 0,0,1,0,0,0\n  dcb 0,0,1,0,0,0\n  dcb 0,0,1,0,0,0\n  dcb 0,0\n  dcb 1,1,1,1,0,0\n  dcb 1,0,0,0,0,0\n  dcb 0,1,1,0,0,0\n  dcb 0,0,0,1,0,0\n  dcb 1,1,1,1,0,0\n  dcb 0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 1,0,0,0,0,0\n  dcb 0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0,0,0,0,0\n  dcb 0,0\nbottombar:\n  dcb _b,_9,_b,9,8,9,8,_a,8,_a,7,_a,7,1,7,1,1\n  dcb 7,1,7,_a,7,_a,8,_a,8,9,8,9,_b,9,_b\n  dcb _ff\n",
    " \nstart:\n inx\n txa\n sta _200, y\n sta _300, y\n sta _400, y\n sta _500, y\n iny\n tya\n cmp 16\n bne do\n iny\n jmp start\ndo:\n iny\n iny\n iny\n iny\njmp start\n",
    " dcb  76, 94, 11,133, 32,162,  8,160,  8,145, 16,136,208,251,165, 16\n dcb  24,105, 32,133, 16,165, 17,105,  0,133, 17,165, 32,202,208,231\n dcb  96,230, 48,165, 48, 41, 63,133, 48,170,189,106,  6,170,189,  8\n dcb   3,105,  1, 41,  3,157,  8,  3,138, 73,231,170,189,  0,  2,105\n dcb   1, 41,  3,157,  0,  2,165, 48, 73, 63,170,189,106,  6, 73,224\n dcb 170,189,  8,  2,105,  1, 41,  3,157,  8,  2,138, 73,231,170,189\n dcb   0,  3,105,  1, 41,  3,157,  0,  3, 96,224,192,160,128, 96,225\n dcb  64,193,161,226,129, 32,194, 97,162,227,195,130,228, 65,163,196\n dcb  98,229,131,164,197,230,231,132,165,198, 99, 66, 33,  0,199,166\n dcb 133,100,167, 67,134,101,135, 34, 68,102,103, 69, 35, 70, 71, 36\n dcb   1, 37, 38, 39,  2,  3,  4,  5,  6,  7,166, 48,189,198,  6,170\n dcb 254, 24,  3, 73,  7,170,254, 16,  3, 73,231,170,254, 24,  2, 73\n dcb   7,170,254, 16,  2, 96,  0, 32,  1, 33, 64,  2, 65, 34, 96, 66\n dcb   3, 97, 35, 98, 67,128,  4,129, 36, 99,130, 68,160,  5,161,131\n dcb 100, 37,162, 69,132,192,163,101,  6,193, 38,194, 70,164,133,195\n dcb 102,224,  7,225, 39,165,226,196,134, 71,227,103,197,166,228,135\n dcb 198,229,167,230,199,231,166, 49,189, 21,  7,170,189,  0,160,157\n dcb   0,  5,230, 49, 96,195,227,194,162,228, 97,226,128,129,130,225\n dcb  64,161,163,224, 96,160,193,196, 32, 98,192, 65,  0,131,229,164\n dcb  33, 99,197, 66,132,  1,230, 34,165, 67,100,198,  2,  3, 68,  6\n dcb  35,133,166,  5,101,  4,199,  7, 36,231, 69,134,167, 37, 38,102\n dcb 135, 70,232, 71, 39,103,136,200,168,  8, 11, 10,169,233,104,  9\n dcb  12,137,201, 13, 40, 44, 72, 43,170, 42, 45, 41,105, 73,202, 14\n dcb 138,234, 74, 75,106,203, 76,171, 46, 77,235,107,139, 15,108,172\n dcb 174,140,173,141,142,204,109,206,207,205, 78,175, 47,236,239,143\n dcb 237,238,110,240,241,111,208, 16, 79,176,209,242, 48,144,243, 80\n dcb 177,244,112,210, 17, 49,178,179, 52, 53,147, 18, 81,211,145, 19\n dcb 146, 51, 85,180, 20, 54,113,148, 22, 50, 84,212, 21, 55,115,245\n dcb  83,114,116, 23, 82, 86, 88, 89, 87,118,117,119,149,213, 56, 57\n dcb 181,214, 90,121,122,150,151,182,183,215,246, 58,120,247, 24,153\n dcb 184,152,216, 25, 26, 59, 91,248,123,185, 27, 60,217,154, 28, 92\n dcb 249, 29,155,186, 61,218, 93,124,250,187, 30,251, 62,156, 94,125\n dcb 219,188, 31,252,254,220,253, 63,126,255,157,221, 95,159,191,222\n dcb 127,189,223,158,190,165, 66, 41,224,208, 72,165, 66, 24,105,  1\n dcb  41, 31,133, 66,165, 67,240,  7,198, 67,169,  0, 76, 97,  8,198\n dcb  69,240,247, 16, 37,166, 64,230, 64,189,177,  9, 16, 15, 41,127\n dcb 133, 67, 73,127,208,228,169,  1,133, 70, 76, 42,  8,170,189,117\n dcb   8,133, 69,234,234,189,181,  8,133, 65,166, 65,230, 65,189,245\n dcb   8,133, 68,165, 66, 24,105,224,133, 66,166, 66,169,  1,102, 68\n dcb  42,157,  0,160, 96,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2\n dcb   3,  2,  3,  3,  3,  3,  3,  1,  2,  3,  1,  5,  3,  3,  3,  3\n dcb   3,  2,  2,  3,  3,  5,  4,  3,  3,  5,  4,  4,  4,  3,  3,  4\n dcb   4,  1,  3,  4,  3,  5,  5,  5,  4,  5,  4,  4,  3,  4,  4,  7\n dcb   4,  4,  4,  2,  1,  0,  3,  6,  9, 12, 15, 18, 21, 24, 27, 30\n dcb  32, 35, 35, 38, 40, 43, 46, 49, 50, 52,  4, 55, 55, 60, 63, 65\n dcb  68, 71, 73, 75, 78, 78, 33, 83, 86, 89, 94, 98,102,106,109,112\n dcb 116, 94,120,123,127,130,134,139,144,148,153,157,161,164,167,171\n dcb 178,171,182,186,  5, 56, 68, 56, 36,124,  4, 76, 84, 36, 68, 84\n dcb  40, 24, 40,124,100, 84, 88, 56, 84, 72, 76, 80, 96, 40, 84, 40\n dcb  36, 84, 56, 44, 28,124, 36, 24, 24, 36,124, 24, 52, 16, 60, 80\n dcb  24, 37, 30,124, 32, 28,188,  1,190,124, 24, 36, 60, 32, 28, 32\n dcb  28, 24, 36, 24, 63, 36, 24, 36, 63, 60, 16, 32, 52, 44,120, 36\n dcb  56,  4, 60, 56,  4, 56,  4, 56, 57,  6, 56, 44, 52, 36, 12, 48\n dcb 208, 48, 12,252,164,164, 88,120,132,132, 72,252,132,132,120,252\n dcb 164,132,252,160,128,120,132,164, 56,252, 32, 32,252,  8,  4,248\n dcb 252, 48, 80,140,252,  4,  4,252, 64, 60, 64,252, 64, 48,  8,252\n dcb 120,132,132,132,120,252,144,144, 96,120,132,134,133,120,252,144\n dcb 144,108, 68,164,164,152,128,252,128,248,  4,  4,248,  4,  8,240\n dcb 224, 28, 16,224, 28, 16,224,204, 48, 48,204,140,148,164,196,  0\n dcb   0,133, 41, 10, 28, 29, 63, 63, 63,136, 15, 10, 28, 29, 14, 27\n dcb  63, 63, 63,132, 55, 17, 18, 28, 62, 18, 28, 62, 10,136, 27, 14\n dcb  10, 21, 21, 34,143, 15, 10, 28, 29,142, 39, 40, 48, 50,149,145\n dcb  10, 23, 13, 62, 23, 24, 32,136, 28, 24, 22, 14,136, 11, 14, 10\n dcb  30, 29, 18, 15, 30, 21,128, 14, 15, 15, 14, 12, 29, 28, 63, 63\n dcb  63,144,159,255, 55, 17, 18, 28, 62, 18, 28, 62, 10, 21, 21,129\n dcb  15, 24, 27, 62, 23, 24, 32,136, 11, 34, 14, 63, 63, 63,141, 63\n dcb  63, 63, 11, 34, 14,150,159,143, 11, 34, 62, 39, 48, 54, 38,  2\n dcb   0,  0,  7, 63,  5, 63,  2,  9, 11, 34, 62, 39, 48, 54, 38,  2\n dcb   0,  0,  7, 63,  5, 63,  2,  9, 11, 34, 62, 39, 48, 54, 38,  2\n dcb   0,  0,  7, 63,  5, 63,  2,  9,143,159,255,169,  0,133, 42,169\n dcb   1,133, 44,133, 45,169,  0,133, 32,169,160,133, 33,165, 42,133\n dcb  43,162, 15,160, 15,145, 32, 24,101, 44,230, 44,136, 16,246,165\n dcb  32, 24,105, 32,133, 32,165, 33,105,  0,133, 33,169,  1,133, 44\n dcb 165, 43, 24,101, 45,133, 43,230, 45,202, 16,215,169,  0,133, 32\n dcb 169,160,133, 33,169,224,133, 34,169,  3,133, 35,169,  0,133, 36\n dcb 169,  4,133, 37,169,240,133, 38,169,  3,133, 39,169, 16,133, 40\n dcb 169,  4,133, 41,169, 15,133, 46,160, 15,177, 32, 74, 74, 74, 74\n dcb 170,189, 62, 11,209, 34,240, 18,145, 34,145, 36,170,152, 73, 15\n dcb 168,138,145, 38,145, 40,152, 73, 15,168,136, 16,221,165, 32, 24\n dcb 105, 32,133, 32,165, 33,105,  0,133, 33,165, 34, 24,105,224,133\n dcb  34,165, 35,105,255,133, 35,165, 36, 24,105, 32,133, 36,165, 37\n dcb 105,  0,133, 37,165, 38, 24,105,224,133, 38,165, 39,105,255,133\n dcb  39,165, 40, 24,105, 32,133, 40,165, 41,105,  0,133, 41,198, 46\n dcb  16,150,230, 42,165, 42, 41, 63,240,  3, 76, 95, 10, 96,  0, 11\n dcb  12, 15,  1, 15, 12, 11,  0, 11, 12, 15,  1, 15, 12, 11,  0, 11\n dcb  12, 15,  1, 15, 12, 11,  0, 11, 12, 15,  1, 15, 12, 11,169,  1\n dcb 162,255,134, 16,162,  1,134, 17, 32,  3,  6,169,  2,162,  7,134\n dcb  16,162,  2,134, 17, 32,  3,  6,169,  3,162,  7,134, 16,162,  3\n dcb 134, 17, 32,  3,  6,169, 31,133, 66,169,  0,133, 70,133, 67,133\n dcb  64,169,  1,141,109,  8,169,  0,141,114,  8,169,160,141,115,  8\n dcb 169, 63,133, 48,169,128,133, 49,169,  3,141,109,  8,169,  0,170\n dcb 157,  0,160,232,208,250, 32, 33,  6, 32,170,  6, 32,  6,  7, 32\n dcb  21,  8,165, 66, 73, 31,208, 13,173,109,  8, 24,105,  2, 41,  3\n dcb 105,  3,141,109,  8,165, 49,208,221,173, 17,  7, 73,  1,141, 17\n dcb   7,165, 70,240,209, 32, 29, 12, 32, 91, 10,169, 31,133, 66,169\n dcb   0,133, 70,133, 67,141,109,  8,169,  0,141,114,  8,169,  3,141\n dcb 115,  8, 32, 29, 12, 32, 21,  8,165, 66, 73, 31,208,247,173,115\n dcb   8, 73,  7,141,115,  8,165, 70,240,235, 76, 94, 11,169,  0,170\n dcb 157,  0,  2,157,  0,  3,157,  0,  4,157,  0,  5,232,208,241, 96\n \n",
    "lda #0\n sta _0\nlop:\n lda _0\n sta _1\n lda #3\n sta _6\n lda #232\n sta _5\n ldx #0\nlpN:\n lsr _1\n bcc nos\n lda _5\n clc\n adc tL,x\n sta _5\n lda _6\n adc tH,x\n sta _6\nnos:\n inx\n lda _1\n bne lpN\n inx\n txa\n ldy #0\n sta (_5),y\n inc _0\n bne lop\n rts\ntL:\n dcb 32, 31, 254, 190, 128, 132, 8, 8\ntH:\n dcb 0, 0, 255, 255, 255, 255, 0, 1 \n",
    "start:\n  lda #<logo\n  sta _0\n  lda #>logo\n  sta _1\n  lda #_00\n  sta _2\n  lda #_02\n  sta _3\n  ldx #_0\nl:\n  lda (_0,x)\n  sta (_2,x)\n  inc _00\n  lda _00\n  cmp #_00\n  bne notReset1\n  inc _01\nnotReset1:\n  inc _02\n  lda _02 \n  cmp #_00\n  bne notReset2\n  lda _03\n  cmp #_05\n  beq done\n  inc _03\nnotReset2:\n  jmp l\ndone:\n  rts\nlogo:\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,6,6,6\n dcb 6,6,6,6,1,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,1\n dcb 1,1,1,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6\n dcb 1,1,6,6,6,6,6,6,6,6,6,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,1\n dcb 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,6,1,1\n dcb 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,1,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,1,1,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1\n dcb 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1\n dcb 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1\n dcb 1,1,6,6,6,6,6,6,6,6,6,1,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1\n dcb 1,1,1,6,6,6,6,6,6,6,6,6,1,1,1,1\n dcb 1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2\n dcb 1,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1\n dcb 1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,6,6,6,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,6,6,6,6\n dcb 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n dcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n",
    "init:\n  ldx #0\n  stx _0\n  inx\n  stx _2\n  stx _3\n  inx\n  stx _1\nloop:\n  lda _2\n  cmp #_20\n  bne notIncF2\n  inc _3\n  lda #0\n  sta _2\nnotIncF2:\n  inc _2\n  lda _2\n  sta _f1\n  lda _2\n  sta _f2\n  jsr multiply\n  lda _f4\n  sta _f8\n  lda _3\n  sta _f1\n  lda _3\n  sta _f2\n  jsr multiply\n  lda _f4\n  clc\n  adc _f8\n  lsr\n  lsr\n  lsr\n  lsr\n  lsr\n  ldx #0\n  sta (_0,x)\n  inc _0\n  lda _0\n  cmp #_00\n  bne notNextY\n  inc _1\n  lda _1\n  cmp #6\n  beq exit\nnotNextY:\n  jmp loop\nexit:\n  rts\nmultiply:\n  lda #0\n  sta _f4\n  sta _f5\n  ldx #8\na:asl _f4\n  rol _f5\n  asl _f2\n  bcc b\n  clc\n  lda _f4\n  adc _f1\n  sta _f4\n  bcc b\n  inc _f5\nb:dex\n  bne a\n  rts \n",
    "\t\nloop:   \n   \tlda _fe\n\tand #_1f\n\ttay\n\ttax\n\tlda matrix,y\n\tsta _1\n\ttay\n\tlda #0\n\tjsr paint\n   inc _1\n   lda _1\n   and #_1f\n   sta matrix,y\n   tay\n   lda #5 \n   jsr paint\n   \tlda _fe\n\tand #_1f\n\ttay\n\ttax\n\tlda matrix,y\n\tsta _1\n\ttay\n\tlda #_d\n\tjsr paint\n   \tlda _fe\n\tand #_1f\n\ttay\n\ttax\n\tlda matrix,y\n\tsta _1\n\ttay\n\tlda #_5\n\tjsr paint\n   jmp loop\n\t\npaint:\n   pha\n   lda yl,y\n   sta _2\n   lda yh,y\n   sta _3\n   txa\n   tay\n   pla\n   sta (_2),y\n   rts\nyh:\n       dcb _02, _02, _02, _02, _02, _02, _02, _02\n       dcb _03, _03, _03, _03, _03, _03, _03, _03\n       dcb _04, _04, _04, _04, _04, _04, _04, _04\n       dcb _05, _05, _05, _05, _05, _05, _05, _05\n       \nyl:\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n   \nmatrix:\n\tdcb 5,16,19,19,17,26,10,14,11,4,1,2,20,1,8,30\n\tdcb 17,26,19,19,31,21,11,19,3,24,4,24,13,8,8,26\n",
    "start: ldy #_ff\n       ldx #_0\nloop:  lda _fe\n       sta _200,x\n       and #_7\n       sta _300,x\n       and #_3\n       sta _400,x\n       and #_1\n       sta _500,x\n       inx\n       dey\n       bne loop\n       rts\n",
    "   lda #16\n   sta _0\n   sta _1\n   lda _fe\n   sta _5\n   lda _fe\n   sta _6\nloop:\n   ldx _0\n   ldy _1\n   lda _5\n   jsr paint\n   jsr walk\n   dec _6\n   bne loop\n   lda _fe\n   sta _5\n   lda _fe\n   sta _6\n   jmp loop\nwalk:\n   lda _fe\n   and #3\n   cmp #0\n   beq right\n   cmp #1\n   beq left\n   cmp #2\n   beq up\n   jmp down\nright:\n   inc _0\n   jmp done\nleft:\n   dec _0\n   jmp done\nup:\n   dec _1\n   jmp done\ndown:\n   inc _1\n   jmp done\ndone:\n   lda _0\n   and #31\n   sta _0\n   lda _1\n   and #31\n   sta _1\n   rts\npaint:\n   pha\n   lda yl,y\n   sta _2\n   lda yh,y\n   sta _3\n   txa\n   tay\n   pla\n   sta (_2),y\n   rts\nyh:\n       dcb _02, _02, _02, _02, _02, _02, _02, _02\n       dcb _03, _03, _03, _03, _03, _03, _03, _03\n       dcb _04, _04, _04, _04, _04, _04, _04, _04\n       dcb _05, _05, _05, _05, _05, _05, _05, _05\nyl:\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0\n       dcb _00, _20, _40, _60, _80, _a0, _c0, _e0 \n",
    "loop: lda _fe\n      sta _00\n      lda _fe\n      and #_3\n      clc\n      adc #_2\n      sta _01\n      lda _fe\n      ldy #_0\n      sta (_00),y\n      jmp loop\n",
    "      lda _fe\n      sta _00\n      lda _fe\n      and #_3\n      clc\n      adc #_2\n      sta _01\n      lda _fe\n      ldy #_0\n      sta (_00),y\n      jmp _600\n",
    "  lda #8\n  tax\ndr:\n  sta _3cb,x\n  sta _40b,x\n  dex\n  bpl dr\n  sta _3f3\n  sta _3eb\n  lda #1\n  sta _3ec\n  ldx #255\nmk:\n  lda _fe\n  sta _1200,x\n  lda _fe\n  sta _1300,x\n  lda _fe\n  sta _1400,x\n  lda _fe\n  sta _1500,x\n  dex\n  cpx #_ff\n  bne mk\n  ldy #0\nre:\n  lda #1\n  sta _3ec,y\n  ldx #255\nsm:\n  lda _1201,x\n  adc _11ff,x\n  adc _1220,x\n  adc _11e0,x\n  lsr\n  lsr\n  sta _1200,x\n  lda _1301,x\n  adc _12ff,x\n  adc _1320,x\n  adc _12e0,x\n  lsr\n  lsr\n  sta _1300,x\n  lda _1401,x\n  adc _13ff,x\n  adc _1420,x\n  adc _13e0,x\n  lsr\n  lsr\n  sta _1400,x\n  lda _1501,x\n  adc _14ff,x\n  adc _1520,x\n  adc _14e0,x\n  lsr\n  lsr\n  sta _1500,x\n  dex\n  cpx #_ff\n  bne sm\n  iny\n  cpy #7\n  bne re\n  lda #1\n  sta _3f0\n  clc\n  ldx #255\ncp:\n  lda _1200,x\n  lsr\n  lsr\n  tay\n  lda colors,y\n  sta _200,x\n  lda _1300,x\n  lsr\n  lsr\n  tay\n  lda colors,y\n  sta _300,x\n  lda _1400,x\n  lsr\n  lsr\n  tay\n  lda colors,y\n  sta _400,x\n  lda _1500,x\n  lsr\n  lsr\n  tay\n  lda colors,y\n  sta _500,x\n  dex\n  cpx #_ff\n  bne cp\n  rts\ncolors:\n  dcb 0,0,0,0,0,_9,_9,1,1,0,0,0,0,0\n",
    "start:\nldx #0\ncs:\nlda _2000,x\nsta _500,x\ndex\nbne cs\nstx _20\nloop:\ninc _20\nlda _20\nand #_7f\ntay\nand #_1f\ntax\nlda sinus,x\ntax\nd:\nlda #0\nsta _1e0,x\nsta _2e0,x\nlda _1000,y\nsta _200,x\nlda _1080,y\nsta _220,x\nlda _1100,y\nsta _240,x\nlda _1180,y\nsta _260,x\nlda _1200,y\nsta _280,x\nlda _1280,y\nsta _2a0,x\nlda _1300,y\nsta _2c0,x\nlda _1380,y\nsta _2c0,x\ninx\niny\ntxa\nand #_1f\nbne d\njmp loop\nsinus:\ndcb 0,0,0,0,_20,_20,_20\ndcb _40,_40,_60,_80,_a0,_a0,_c0,_c0,_c0\ndcb _e0,_e0,_e0,_e0,_c0,_c0,_c0\ndcb _a0,_a0,_80,_60,_40,_40,_20,_20,_20\n*=_1000\nsanta:\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,_a,_a,0,0,0,0,0,0\ndcb 0,0,0,0,0,_a,_a,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,2,2,2,1,0,0,0,0,_9,_9,_9,_9,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,_a,_a,_a,0,0,0,0,0\ndcb 0,0,0,0,0,_a,_a,_a,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,_9,_9,0,0,0,0,0,0,0,0\ndcb 0,1,1,2,2,0,_9,_9,_9,_9,_9,_9,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,_a,_a,_a,_a,_a,_a,0,0,0,0\ndcb 0,0,0,_a,_a,_a,_a,_a,_a,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,_9,_9,_9,0,0,0,0,0,0\ndcb 0,1,2,2,_9,_9,_9,_9,_9,_9,_9,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,_a,_a,_a,_a,_a,_a,_b\ndcb _b,_b,_b,_b,_b,_b,_a,_a,_a,_a,_a,_a,_b,_b,_b,_b\ndcb _b,_b,_b,_b,_b,_9,_9,_9,_9,_9,_9,_9,_9,_9,_9,_9\ndcb _9,2,2,_9,_9,_9,_9,_9,_9,_9,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,_a,_a,_a,_a,_a,_a,_a\ndcb _a,0,0,0,0,0,_a,_a,_a,_a,_a,_a,_a,_a,0,0\ndcb 0,0,0,0,0,0,0,_9,_9,_9,_9,_9,_9,_9,_9,_9\ndcb 2,2,_9,_9,_9,_9,_9,_9,_9,_9,_9,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,_a,_a,_a,_a,_a,_a,0\ndcb _a,_a,0,0,0,0,_a,_a,_a,_a,_a,_a,0,_a,_a,0\ndcb 0,0,0,0,0,_a,_a,0,0,_9,_a,_9,_9,_9,_9,_9\ndcb _9,_9,_a,_9,_9,_9,_9,_9,_9,_9,_9,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,_a,0,_a,0,0,_a,0\ndcb 0,_a,0,0,0,0,_a,0,_a,0,0,_a,0,0,_a,0\ndcb 0,0,0,0,0,_a,0,0,0,_a,0,0,0,0,0,0\ndcb 0,_a,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,_a,_a,0,_a,0,0,_a,_a\ndcb 0,_a,_a,0,0,_a,_a,0,_a,0,0,_a,_a,0,_a,_a\ndcb 0,0,0,0,0,0,_a,_a,_a,_a,_a,_a,_a,_a,_a,_a\ndcb _a,_a,_a,_a,_a,_a,_a,_a,_a,_a,_a,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n*=_2000\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,_c,1,1,1\ndcb 0,0,0,0,0,0,0,0,0,0,0,1,1,1,_a,_a\ndcb 0,0,0,0,0,0,0,0,0,0,_c,1,1,1,1,1\ndcb 1,1,_c,0,0,0,0,0,0,0,0,0,1,1,0,0\ndcb 0,0,0,0,0,0,0,0,_c,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,_c,0,0,0,0,0,1,1,1,1,0\ndcb 0,0,0,0,0,0,_c,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,_c,0,0,0,0,1,1,1,1,0\ndcb 0,0,0,0,0,_c,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,_c,0,0,1,1,0,0\ndcb 0,0,_c,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n\t\n",
    "  lda _fe\n  sta _1001\n  jmp _1000\n  *=_1000\n  lda #_00\n  sta _3ef\n  jmp _600\n",
    "\t\n\tLDX #0\n\tLDY #0\nnew_rnd:\n\tLDA _FE\n\tAND #3\n\tCMP #3\n\tBNE good_rnd\n\tJMP new_rnd\ngood_rnd:     \n\tPHA\n\tASL\n\tASL\n\tASL\n\tSTA _F3\n\tPLA\n\tAND #1\n\tASL\n\tASL\n\tASL\n\tASL\n\tSTA _F4\n\tTXA\n\tLSR\n\tADC _F3\n\tTAX\n\tTYA\n\tLSR\n\tADC _F4\n\tTAY\n\tJSR set_point\n\tJMP new_rnd\nset_point:\n\tPHA\n\tTXA\n\tPHA\n\tTYA\n\tPHA \n\tPHA \n\tPHA\n\tSTX _F2\n\tLDY _F2\n\tLDA #0\n\tSTA _F0\n\tLDA #_2\n\tSTA _F1\n\tLDA #0\n\tPLA\n\tAND #_07\n\tASL\n\tASL\n\tASL\n\tASL\n\tASL\n\tCLC\n\tADC _F0\n\tSTA _F0\n\tBCC no_carry\n\tINC _F1\nno_carry:\n\tCLC\n\tPLA\n\tAND #_18\n\tLSR\n\tLSR\n\tLSR\n\tADC _F1\n\tSTA _F1\t\t\n\tCLC\n\tTYA\n\tADC _F0\n\tADC _F1\n\tLDA #1\n   \tJSR set_toning_point\n\tSTA (_F0),Y\n\tPLA\n\tTAY\n\tPLA\n\tTAX\n\tPLA\n\tRTS\nset_toning_point:\n        LDA (_F0),Y\n        CMP #_00\n        BNE not_black\n        LDA #_0B\n        RTS\nnot_black:\n        CMP #_0B\n        BNE not_dgrey\n        LDA #_0C\n        RTS\nnot_dgrey:\n        CMP #_0C\n        BNE not_grey\n        LDA #_0F\n        RTS\nnot_grey:\n        CMP #_0F\n        BNE not_lgrey\n        LDA #_01\n        RTS\nnot_lgrey:\n        RTS\n",
    "loop:\n ldx _90\n inx\n stx _90\n lda #4\n sta _3\n lda #0\n sta _4\nmultiple:\n lda _90\n clc\n adc _4\n tax\n lda sinus,x\n ldy cosinus,x\n asl\n tax\n lda ypos,x\n sta _00\n inx\n lda ypos,x\n sta _01\n ldx #0\n lda #5\n sta _2\ndraw:\n lda image,x\n sta (_0),y\n inx\n iny\n lda image,x\n sta (_0),y\n inx\n iny\n lda image,x\n sta (_0),y\n inx\n iny\n lda image,x\n sta (_0),y\n inx\n iny\n lda image,x\n sta (_0),y\n tya\n clc\n adc #28\n tay\n inx\n dec _2\n bne draw\n lda _4 \n clc\n adc #18\n sta _4\n dec _3\n bne multiple\n jmp loop\nsinus:\n dcb _0e, _0e, _0e, _0f, _0f, _0f, _10, _10, _10, _11\n dcb _11, _11, _12, _12, _12, _13, _13, _13, _14, _14\n dcb _14, _14, _15, _15, _15, _16, _16, _16, _16, _17\n dcb _17, _17, _17, _18, _18, _18, _18, _19, _19, _19\n dcb _19, _19, _1a, _1a, _1a, _1a, _1a, _1a, _1a, _1b\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\ncosinus:\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\n dcb _1a, _1a, _1a, _1a, _1a, _1a, _19, _19, _19, _19\n dcb _19, _18, _18, _18, _18, _18, _17, _17, _17, _17\n dcb _16, _16, _16, _15, _15, _15, _15, _14, _14, _14\n dcb _13, _13, _13, _12, _12, _12, _11, _11, _11, _10\n dcb _10, _10, _0f, _0f, _0f, _0e, _0e, _0e, _0d, _0d\n dcb _0d, _0c, _0c, _0c, _0b, _0b, _0b, _0a, _0a, _0a\n dcb _09, _09, _09, _08, _08, _08, _07, _07, _07, _06\n dcb _06, _06, _06, _05, _05, _05, _04, _04, _04, _04\n dcb _03, _03, _03, _03, _03, _02, _02, _02, _02, _02\n dcb _01, _01, _01, _01, _01, _01, _00, _00, _00, _00\n dcb _00, _00, _00, _00, _00, _00, _00, _00, _00, _00\n dcb _00, _00, _00, _00, _00, _00, _00, _00, _00, _00\n dcb _00, _00, _00, _00, _00, _00, _00, _01, _01, _01\n dcb _01, _01, _01, _01, _02, _02, _02, _02, _02, _03\n dcb _03, _03, _03, _04, _04, _04, _04, _05, _05, _05\n dcb _05, _06, _06, _06, _07, _07, _07, _07, _08, _08\n dcb _08, _09, _09, _09, _0a, _0a, _0a, _0b, _0b, _0b\n dcb _0c, _0c, _0c, _0d, _0d\n dcb _0e, _0e, _0e, _0f, _0f, _0f, _10, _10, _10, _11\n dcb _11, _11, _12, _12, _12, _13, _13, _13, _14, _14\n dcb _14, _14, _15, _15, _15, _16, _16, _16, _16, _17\n dcb _17, _17, _17, _18, _18, _18, _18, _19, _19, _19\n dcb _19, _19, _1a, _1a, _1a, _1a, _1a, _1a, _1a, _1b\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\n dcb _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b, _1b\n dcb _1a, _1a, _1a, _1a, _1a, _1a, _19, _19, _19, _19\nimage:\n dcb _0,_0,_0,_0,_0\n dcb _0,_c,_c,_c,_0\n dcb _0,_c,_1,_c,_0\n dcb _0,_c,_c,_c,_0\n dcb _0,_0,_0,_0,_0\nypos:\n dcb _00,_02,_20,_02,_40,_02,_60,_02\n dcb _80,_02,_a0,_02,_c0,_02,_e0,_02\n dcb _00,_03,_20,_03,_40,_03,_60,_03\n dcb _80,_03,_a0,_03,_c0,_03,_e0,_03\n dcb _00,_04,_20,_04,_40,_04,_60,_04\n dcb _80,_04,_a0,_04,_c0,_04,_e0,_04\n dcb _00,_05,_20,_05,_40,_05,_60,_05\n dcb _80,_05,_a0,_05,_c0,_05,_e0,_05\n",
    "start:\n  jsr init\nloop:\n  jsr drawMap\n  jsr genMap\n  jsr readKeys\n  jmp loop\ndrawShip:\n  lda _82\n  tay\n  lda ypos,y\n  sta _00\n  iny\n  lda ypos,y\n  sta _01\n  ldx #42\n  lda (_00,x)\n  cmp #0\n  beq noCrash\n  cmp #5\nnoCrash:\n  lda #5\n  sta (_00,x)\n  lda _60\n  cmp _61\n  beq ret\n  lda _61\n  asl\n  tay\n  lda ypos,y\n  sta _00\n  iny\n  lda ypos,y\n  sta _01\n  lda #0\n  ldx #42\n  sta (_00,x)\n  lda _60\n  sta _61\nret:\n  rts\ncrashed:\n  lda _fe\n  sta (_00,x)\n  jmp crashed\nreadKeys:\n  lda _ff\n  cmp #119\n  bne notUp\n  dec _60\n  rts\nnotUp:\n  cmp #120\n  bne noMove\n  inc _60\nnoMove:\n  rts\ninit:\n  ldx #0\ndrawLogo:\n  lda bottomLogo,x\n  sta _500,x\n  inx\n  cpx #0\n  bne drawLogo\n  lda #10\n  sta _60\n  sta _61\n  ldx #0\n  lda #_c\nc:sta _200,x\n  sta _400,x\n  dex\n  cpx #0\n  bne c\n  lda #16\n  sta _80\n  ldx #15\nset:\n  sta _81,x\n  dex\n  bpl set\n  rts\ndrawMap:\n  lda #0\n  sta _78\n  lda #32\n  sta _79\n  lda #192\n  sta _7a\n  lda #224\n  sta _7b\n  ldx #15\ndrawLoop:\n  lda _81,x\n  sta _82,x\n  tay\n  lda ypos,y\n  sta _00\n  iny\n  lda ypos,y\n  sta _01\n  lda #_c\n  ldy _78\n  sta (_00),y\n  iny\n  sta (_00),y\n  ldy _7b\n  sta (_00),y\n  iny\n  sta (_00),y\n  ldy _79\n  lda #0\n  sta (_00),y\n  iny\n  sta (_00),y\n  ldy _7a\n  sta (_00),y\n  iny\n  sta (_00),y\n  inc _78\n  inc _79\n  inc _7a\n  inc _7b\n  inc _78\n  inc _79\n  inc _7a\n  inc _7b\n  dex\n  bpl drawLoop\n  rts\ngenMap:\n  lda _80\n  cmp _81\n  beq done\n  lda _80\n  clc\n  sbc _81\n  bpl plus\n  bmi minus\ndone:\n  lda _fe\n  and #_f\n  asl\n  sta _80\n  rts\nminus:\n  dec _81\n  dec _81\n  rts\nplus:\n  inc _81\n  inc _81\n  rts\nypos:\n  dcb _00,_02,_20,_02,_40,_02,_60,_02\n  dcb _80,_02,_a0,_02,_c0,_02,_e0,_02\n  dcb _00,_03,_20,_03,_40,_03,_60,_03\n  dcb _80,_03,_a0,_03,_c0,_03,_e0,_03\n  dcb _00,_04,_20,_04,_40,_04,_60,_04\n  dcb _80,_04,_a0,_04,_c0,_04,_e0,_04\n  dcb _00,_05,_20,_05,_40,_05,_60,_05\n  dcb _80,_05,_a0,_05,_c0,_05,_e0,_05\nbottomLogo:\n  dcb _0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0\n  dcb _0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0\n  dcb _0,_0,_0,_0,_0,_0,_1,_1,_1,_6,_1,_1,_1,_0\n  dcb _0,_6,_1,_1,_6,_0,_0,_1,_1,_1,_6,_0,_1,_1\n  dcb _1,_0,_1,_1,_1,_6,_0,_0,_6,_1,_6,_0,_6,_0\n  dcb _1,_0,_6,_1,_6,_1,_6,_0,_1,_0,_1,_0,_6,_0\n  dcb _6,_1,_6,_0,_6,_0,_1,_0,_6,_1,_6,_0,_0,_6\n  dcb _1,_1,_6,_6,_1,_1,_1,_0,_6,_1,_0,_0,_1,_0\n  dcb _1,_6,_0,_6,_6,_1,_1,_1,_0,_6,_1,_0,_6,_1\n  dcb _0,_6,_6,_6,_6,_6,_1,_6,_1,_1,_6,_6,_6,_1\n  dcb _1,_1,_1,_6,_1,_6,_6,_6,_6,_1,_6,_6,_6,_6\n  dcb _1,_1,_1,_6,_6,_6,_6,_1,_1,_1,_1,_e,_1,_1\n  dcb _e,_6,_6,_1,_1,_6,_1,_6,_1,_1,_1,_1,_e,_1\n  dcb _1,_1,_1,_6,_1,_1,_6,_1,_6,_6,_6,_1,_1,_1\n  dcb _6,_e,_1,_1,_6,_e,_6,_1,_1,_e,_1,_e,_6,_1\n  dcb _1,_1,_6,_e,_1,_1,_1,_e,_1,_1,_6,_1,_6,_e\n  dcb _e,_e,_6,_e,_e,_6,_e,_e,_6,_e,_e,_6,_e,_e\n  dcb _6,_e,_e,_6,_e,_e,_6,_e,_e,_6,_e,_e,_6,_e\n  dcb _e,_6,_e,_e\n",
    "i:ldx #_7\ng:lda _fe\n  and #3\n  adc #1\n  sta _0,x\n  lda _fe\n  and #_1f\n  sta _20,x\n  dex\n  bpl g\nf:\n  lda #_ff\n  sta _10\n  delay:\n  nop\n  dec _10\n  bne delay\n  lda #_00\n  sta _80\n  lda #_02\n  sta _81\n  ldx #_7\nl:lda _20,x\n  pha\n  clc\n  sbc _00,x\n  and #_1f\n  sta _20,x\n  lda _20,x\n  tay\n  lda #1\n  sta (_80),y\n  pla\n  tay\n  lda #0\n  sta (_80),y\n  lda _80\n  clc\n  adc #_80\n  bne n\n  inc _81\nn:sta _80\n  dex\n  bpl l\n  jmp f\n",
    "start:\nldx #0\nstx _20\nlda #5\nsta _21\nlda _fe\nsta _22\nloop:\ndec _21\nlda _21\nbeq randcolor\njmp pastrandcolor\nrandcolor:\nlda #5\nsta _21\nldx #33\ninc _22\nlda _22\nand #7\ntay\nrl:\nlda _1000,x\nbeq pastcolor1\nlda color_row,y\nsta _1000,x\npastcolor1:\nlda _1040,x\nbeq pastcolor2\nlda color_row,y\nsta _1040,x\npastcolor2:\nlda _1080,x\nbeq pastcolor3\nlda color_row,y\nsta _1080,x\npastcolor3:\nlda _10c0,x\nbeq pastcolor4\nlda color_row,y\nsta _10c0,x\npastcolor4:\nlda _1100,x\nbeq pastcolor5\nlda color_row,y\nsta _1100,x\npastcolor5:\nlda _1140,x\nbeq pastcolor6\nlda color_row,y\nsta _1140,x\npastcolor6:\nlda _1180,x\nbeq pastcolor7\nlda color_row,y\nsta _1180,x\npastcolor7:\nlda _11C0,x\nbeq pastcolor8\nlda color_row,y\nsta _11C0,x\npastcolor8:\nlda _1200,x\nbeq pastcolor9\nlda color_row,y\nsta _1200,x\npastcolor9:\ninx\ntxa\nand #_3f\nbne rl\npastrandcolor:\ninc _20\nlda _20\nand #_3f\ntay\nand #_1f\ntax\nlda sinus,x\ntax\nd:\nlda #0\nsta _2e0,x\nsta _3e0,x\nlda _1000,y\nsta _300,x\nlda _1080,y\nsta _320,x\nlda _1100,y\nsta _340,x\nlda _1180,y\nsta _360,x\nlda _1200,y\nsta _380,x\nlda _1280,y\nsta _3a0,x\nlda _1300,y\nsta _3c0,x\nlda _1380,y\nsta _3c0,x\ninx\niny\ntxa\nand #_1f\nbne d\njmp loop\nsinus:\ndcb 0,0,0,0,_20,_20,_20\ndcb _40,_40,_60,_80,_a0,_a0,_c0,_c0,_c0\ndcb _e0,_e0,_e0,_e0,_c0,_c0,_c0\ndcb _a0,_a0,_80,_60,_40,_40,_20,_20,_20\ncolor_row:\ndcb _7,_8,_9,_2,_4,_6,_e,_3\n*=_1000\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0\ndcb 0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0\ndcb 0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1\ndcb 0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1\ndcb 0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1\ndcb 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1\ndcb 0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1\n",
    "ldx #0\nlda #0\nhupsu:\nsta _200,x\nsta _300,x\nsta _400,x\nsta _500,x\nbne hupsu\nlda #1\nldx #0\nfill:\ntxa\ntay\nlda seko,x\ntax\nlda kuva,x\nsta _200,x\nlda kuva_0,x\nsta _300,x\nlda kuva_1,x\nsta _400,x\nlda kuva_2,x\nsta _500,x\ntya\ntax\ninx\nbne fill\nrts\nseko:\ndcb 46,93,219,97,168,170,196,63,204,201,206\ndcb 56,238,25,2,186,209,191,138,226,80,128\ndcb 58,171,81,115,42,44,102,193,69,231,107\ndcb 78,5,218,103,11,13,221,130,149,16,227\ndcb 105,213,232,182,17,255,27,190,205,137,192\ndcb 222,233,94,52,229,96,18,220,202,122,166\ndcb 43,153,131,246,177,4,70,22,7,86,173\ndcb 141,151,164,32,143,40,156,185,121,132,165\ndcb 62,249,252,139,154,251,85,236,12,134,245\ndcb 184,39,195,119,242,244,162,74,1,77,51\ndcb 33,75,35,76,34,10,89,47,189,237,71\ndcb 159,9,38,101,180,116,147,140,183,157,123\ndcb 14,19,126,199,100,45,241,28,125,210,155\ndcb 41,254,31,144,55,247,111,95,57,53,223\ndcb 152,108,203,36,214,37,113,200,66,67,197\ndcb 29,250,20,212,68,87,207,163,145,211,48\ndcb 136,24,98,215,169,83,124,224,181,187,142\ndcb 84,240,54,110,234,59,243,79,50,30,114\ndcb 6,178,0,172,148,146,179,120,60,225,65\ndcb 230,208,15,72,117,248,198,106,129,92,127\ndcb 175,160,49,216,176,133,64,109,112,82,90\ndcb 235,104,158,194,8,161,167,88,91,174,23\ndcb 73,118,150,3,99,61,217,26,239,21,253\ndcb 135,188,228\nkuva:\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0\ndcb 0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1\ndcb 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0\ndcb 0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1\ndcb 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,11,11\ndcb 11,0,0,0,0,0,0,1,0,0,0,11,11,11,0,0,0,0,0,1,1,1,1,1\ndcb 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1\nkuva_0:\ndcb 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,1\ndcb 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1\ndcb 1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0\ndcb 0,1,15,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1\ndcb 0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1,1,0,0,0,1,0,0,0\ndcb 0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1\ndcb 1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0\ndcb 0,0,15,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,1\ndcb 0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,1\nkuva_1:\ndcb 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0\ndcb 0,0,15,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1\ndcb 0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1,1,0,0,0,1,1,0,0\ndcb 0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1\ndcb 1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1\ndcb 1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0\ndcb 1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1\ndcb 1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1\ndcb 1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,15,1,1,1,1,1,1,1,1\ndcb 1,1,15,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,15\ndcb 1,1,1,1,1,1,1,1,1,1,15,0,0,0,1,1\nkuva_2:\ndcb 1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\ndcb 1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,0\ndcb 15,15,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1\ndcb 1,1,1,1,1,15,15,0,15,15,1,1,1,1,1,1,1,1,1,0,0,0,1,1\ndcb 1,0,0,0,15,1,1,1,1,1,1,1,1,15,15,0,1,1,1,1,1,1,1,1\ndcb 1,1,1,0,0,0,1,1,1,0,0,0,0,15,15,15,15,15,15,1,15,1,1,1\ndcb 1,1,15,1,15,15,15,1,1,15,0,0,0,0,1,1,1,0,0,0,0,15,15,15\ndcb 15,15,15,1,15,1,1,1,1,1,15,1,15,15,15,1,1,15,0,0,0,0,1,1\ndcb 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0\ndcb 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1\n" };
// float_extraction_works
// file analogtv.c line 157
static signed int float_extraction_works;
// float_low8_ofs
// file analogtv.c line 156
static const double float_low8_ofs = 8388608.0;
// font6x10_bits
// file images/6x10font.xbm line 3
static unsigned char font6x10_bits[2240l] = { (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x0a, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x7e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x7c, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x86, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x18, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x82, (unsigned char)0x44, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x82, (unsigned char)0x42, (unsigned char)0x80, (unsigned char)0x20, (unsigned char)0x28, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x01, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x51, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x41, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x05, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x40, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x01, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x2a, (unsigned char)0x00, (unsigned char)0x55, (unsigned char)0xe2, (unsigned char)0xe0, (unsigned char)0x08, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x89, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xcc, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x61, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0xc7, (unsigned char)0x07, (unsigned char)0xf1, (unsigned char)0x61, (unsigned char)0x7c, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x84, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0xf9, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x4e, (unsigned char)0x24, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x1e, (unsigned char)0x8e, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x8f, (unsigned char)0x23, (unsigned char)0xe0, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x60, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0xc0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x86, (unsigned char)0x60, (unsigned char)0x90, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x03, (unsigned char)0x10, (unsigned char)0x21, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x84, (unsigned char)0x00, (unsigned char)0xf0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x06, (unsigned char)0x06, (unsigned char)0x60, (unsigned char)0x30, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x45, (unsigned char)0x03, (unsigned char)0xa0, (unsigned char)0xe0, (unsigned char)0x39, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0x87, (unsigned char)0x40, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x0a, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x02, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x38, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x42, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x50, (unsigned char)0x28, (unsigned char)0x06, (unsigned char)0x0a, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xa1, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x42, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x28, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x4a, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x28, (unsigned char)0x08, (unsigned char)0x8b, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x3f, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x03, (unsigned char)0x80, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0xc2, (unsigned char)0x51, (unsigned char)0x29, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x08, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x14, (unsigned char)0x86, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x11, (unsigned char)0x10, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x02, (unsigned char)0x01, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x0a, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x88, (unsigned char)0x20, (unsigned char)0x80, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0xa8, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x04, (unsigned char)0x10, (unsigned char)0x21, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x04, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x00, (unsigned char)0xb8, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x09, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x50, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0xc0, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x24, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x08, (unsigned char)0x20, (unsigned char)0x12, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x18, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0xd5, (unsigned char)0x63, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x0b, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x00, (unsigned char)0xe4, (unsigned char)0xf3, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc5, (unsigned char)0xa7, (unsigned char)0xa0, (unsigned char)0x28, (unsigned char)0x10, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x05, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x22, (unsigned char)0x05, (unsigned char)0x08, (unsigned char)0x42, (unsigned char)0xd1, (unsigned char)0x08, (unsigned char)0x20, (unsigned char)0x22, (unsigned char)0x19, (unsigned char)0x87, (unsigned char)0x83, (unsigned char)0xf0, (unsigned char)0x41, (unsigned char)0x20, (unsigned char)0x32, (unsigned char)0x11, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x21, (unsigned char)0xb0, (unsigned char)0x99, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x80, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x14, (unsigned char)0x0a, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x8e, (unsigned char)0x86, (unsigned char)0xc3, (unsigned char)0xe2, (unsigned char)0x10, (unsigned char)0x78, (unsigned char)0x1a, (unsigned char)0x06, (unsigned char)0x4c, (unsigned char)0x84, (unsigned char)0xb0, (unsigned char)0x68, (unsigned char)0x38, (unsigned char)0x1a, (unsigned char)0x96, (unsigned char)0x86, (unsigned char)0xe3, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x0f, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x48, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x8f, (unsigned char)0x20, (unsigned char)0xa2, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x0d, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0xb8, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x10, (unsigned char)0xb9, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x49, (unsigned char)0x42, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x93, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x24, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0xf0, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0x60, (unsigned char)0x30, (unsigned char)0x18, (unsigned char)0x1c, (unsigned char)0x0d, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x3c, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x9f, (unsigned char)0x4a, (unsigned char)0x22, (unsigned char)0xe0, (unsigned char)0x78, (unsigned char)0x00, (unsigned char)0x3e, (unsigned char)0x0d, (unsigned char)0x01, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x43, (unsigned char)0x41, (unsigned char)0x38, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0xc2, (unsigned char)0x41, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x88, (unsigned char)0xcf, (unsigned char)0x07, (unsigned char)0xf0, (unsigned char)0x01, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x06, (unsigned char)0x23, (unsigned char)0x31, (unsigned char)0x69, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x16, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x10, (unsigned char)0x2a, (unsigned char)0x11, (unsigned char)0x47, (unsigned char)0x40, (unsigned char)0xf2, (unsigned char)0x78, (unsigned char)0x04, (unsigned char)0x3e, (unsigned char)0x04, (unsigned char)0xc4, (unsigned char)0x20, (unsigned char)0x50, (unsigned char)0xa9, (unsigned char)0x44, (unsigned char)0x1e, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0x83, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x80, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x90, (unsigned char)0x49, (unsigned char)0x24, (unsigned char)0x13, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x82, (unsigned char)0x50, (unsigned char)0x99, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x14, (unsigned char)0x11, (unsigned char)0x84, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0xc2, (unsigned char)0xc1, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x24, (unsigned char)0x00, (unsigned char)0x13, (unsigned char)0x8a, (unsigned char)0xc4, (unsigned char)0xe3, (unsigned char)0x99, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1f, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0x10, (unsigned char)0xb1, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x86, (unsigned char)0xe4, (unsigned char)0x74, (unsigned char)0x99, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0xc9, (unsigned char)0x05, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0x83, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x2e, (unsigned char)0x95, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x28, (unsigned char)0x2a, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0xa2, (unsigned char)0x78, (unsigned char)0x14, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0x45, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x93, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x7c, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x55, (unsigned char)0xa2, (unsigned char)0xe3, (unsigned char)0xf0, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xcf, (unsigned char)0xe1, (unsigned char)0xc0, (unsigned char)0xe3, (unsigned char)0xfd, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x1f, (unsigned char)0x00, (unsigned char)0xc0, (unsigned char)0x3b, (unsigned char)0xfc, (unsigned char)0x7e, (unsigned char)0x04, (unsigned char)0xcc, (unsigned char)0x40, (unsigned char)0xf1, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc0, (unsigned char)0x87, (unsigned char)0xa2, (unsigned char)0xa8, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x05, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0xe4, (unsigned char)0x03, (unsigned char)0x99, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0xf0, (unsigned char)0x41, (unsigned char)0x10, (unsigned char)0x1a, (unsigned char)0x1f, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x64, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x21, (unsigned char)0x10, (unsigned char)0xc9, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x91, (unsigned char)0x02, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x04, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x9e, (unsigned char)0x48, (unsigned char)0x20, (unsigned char)0xf2, (unsigned char)0x11, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0xc8, (unsigned char)0x81, (unsigned char)0x50, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x80, (unsigned char)0x43, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x08, (unsigned char)0x19, (unsigned char)0x02, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0xf1, (unsigned char)0x21, (unsigned char)0x48, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x40, (unsigned char)0x02, (unsigned char)0x02, (unsigned char)0x98, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x86, (unsigned char)0xc2, (unsigned char)0x08, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0xe7, (unsigned char)0xf3, (unsigned char)0x79, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x99, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x10, (unsigned char)0x26, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x42, (unsigned char)0x08, (unsigned char)0x24, (unsigned char)0x3c, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x05, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0x87, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x00, (unsigned char)0x2a, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x92, (unsigned char)0x89, (unsigned char)0x64, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x8a, (unsigned char)0x87, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x21, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0xc2, (unsigned char)0x51, (unsigned char)0x49, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x08, (unsigned char)0x81, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x04, (unsigned char)0x14, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x04, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x11, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x95, (unsigned char)0x44, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x6c, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x91, (unsigned char)0x49, (unsigned char)0x24, (unsigned char)0x13, (unsigned char)0x10, (unsigned char)0x78, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x82, (unsigned char)0x50, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x92, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x16, (unsigned char)0x01, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x82, (unsigned char)0xc4, (unsigned char)0x41, (unsigned char)0x20, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x8f, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x30, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x8f, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xa2, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x28, (unsigned char)0x26, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x42, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x10, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x4c, (unsigned char)0x26, (unsigned char)0x63, (unsigned char)0x89, (unsigned char)0x58, (unsigned char)0x2a, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x82, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x3e, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xc0, (unsigned char)0x0f, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0xcf, (unsigned char)0x47, (unsigned char)0x11, (unsigned char)0x68, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x82, (unsigned char)0x90, (unsigned char)0xb0, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x9f, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x08, (unsigned char)0x1c, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x1c, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x09, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x43, (unsigned char)0xe4, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x02, (unsigned char)0x8e, (unsigned char)0x88, (unsigned char)0x83, (unsigned char)0xe0, (unsigned char)0x20, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0xe2, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x9e, (unsigned char)0x86, (unsigned char)0xc3, (unsigned char)0xe2, (unsigned char)0x10, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x49, (unsigned char)0xc4, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x1a, (unsigned char)0x96, (unsigned char)0xc0, (unsigned char)0x83, (unsigned char)0x61, (unsigned char)0x21, (unsigned char)0x28, (unsigned char)0x22, (unsigned char)0x90, (unsigned char)0x0f, (unsigned char)0x86, (unsigned char)0x60, (unsigned char)0x00, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x4f, (unsigned char)0x23, (unsigned char)0x42, (unsigned char)0x20, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1f, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xd0, (unsigned char)0xa0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x82, (unsigned char)0x07, (unsigned char)0xf1, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0xc9, (unsigned char)0x39, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0xc7, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x1e, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x44, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0x41, (unsigned char)0x08, (unsigned char)0x34, (unsigned char)0x3c, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x39, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x16, (unsigned char)0x8b, (unsigned char)0xc5, (unsigned char)0x02, (unsigned char)0x79, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x0a, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x7c, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x83, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x09, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xe0, (unsigned char)0x47, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x06, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xe0, (unsigned char)0x08, (unsigned char)0x38 };
// hextonib
// file analogtv.c line 2409
static const char hextonib[128l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)2, (const char)3, (const char)4, (const char)5, (const char)6, (const char)7, (const char)8, (const char)9, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
// i1
// file yarandom.c line 87
static signed int i1;
// i2
// file yarandom.c line 87
static signed int i2;
// localbyteorder
// file analogtv.c line 155
static signed int localbyteorder;
// m6502_defaults
// file m6502.c line 257
static const char *m6502_defaults[15l] = { ".background:      black", ".foreground:      white", "*file:", "*displaytime:     20", "*TVColor:         70", "*TVTint:          5", "*TVBrightness:  2", "*TVContrast:    150", "*Background:      Black", "*use_cmap:        0", "*geometry:\t     800x600", "*fpsSolid:\t     True", "*useThreads: True", "*useSHM:           True", ((const char *)NULL) };
// m6502_options
// file m6502.c line 266
static struct anonymous_65 m6502_options[10l] = { { .option="-file", .specifier=".file", .argKind=(enum anonymous_64)XrmoptionSepArg, .value=((char *)NULL) },
    { .option="-displaytime", .specifier=".displaytime", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-threads", .specifier=".useThreads", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="True" },
    { .option="-no-threads", .specifier=".useThreads", .argKind=(enum anonymous_64)XrmoptionNoArg,
    .value="False" },
    { .option="-use-cmap", .specifier=".use_cmap", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-color", .specifier=".TVColor", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-tint", .specifier=".TVTint", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-brightness", .specifier=".TVBrightness", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-contrast", .specifier=".TVContrast", .argKind=(enum anonymous_64)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_64)0,
    .value=((char *)NULL) } };
// m6502_xscreensaver_function_table
// file m6502.c line 301
struct xscreensaver_function_table m6502_xscreensaver_function_table;
// m6502_xscreensaver_function_table
// file m6502.c line 301
struct xscreensaver_function_table m6502_xscreensaver_function_table = { .progclass="m6502", .defaults=m6502_defaults, .options=m6502_options,
    .setup_cb=((void (*)(struct xscreensaver_function_table *, void *))NULL), .setup_arg=NULL,
    .init_cb=m6502_init, .draw_cb=m6502_draw,
    .reshape_cb=m6502_reshape, .event_cb=m6502_event,
    .free_cb=m6502_free, .fps_cb=((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL),
    .pick_visual_hook=((struct anonymous_13 * (*)(struct anonymous_25 *))NULL),
    .validate_visual_hook=((signed int (*)(struct anonymous_25 *, const char *, struct anonymous_13 *))NULL) };
// merged_defaults
// file screenhack.c line 178
static char **merged_defaults;
// merged_options
// file screenhack.c line 176
static struct anonymous_65 *merged_options;
// merged_options_size
// file screenhack.c line 177
static signed int merged_options_size;
// mono_p
// file screenhack.c line 138
signed int mono_p;
// mutex_initializer
// file thread_util.c line 277
const union anonymous_63 mutex_initializer = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// old_handler
// file xshm.c line 60
signed int (*old_handler)(struct _XDisplay *, struct anonymous_56 *) = ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL);
// progclass
// file screenhack.c line 137
const char *progclass;
// progname
// file screenhack.c line 136
const char *progname;
// screensaver_id
// file ./../utils/version.h line 1
static const char screensaver_id[69l] = { '@', '(', '#', ')', 'x', 's', 'c', 'r', 'e', 'e', 'n', 's', 'a', 'v', 'e', 'r', ' ', '5', '.', '3', '4', ' ', '(', '2', '4', '-', 'O', 'c', 't', '-', '2', '0', '1', '5', ')', ',', ' ', 'b', 'y', ' ', 'J', 'a', 'm', 'i', 'e', ' ', 'Z', 'a', 'w', 'i', 'n', 's', 'k', 'i', ' ', '(', 'j', 'w', 'z', '@', 'j', 'w', 'z', '.', 'o', 'r', 'g', ')', 0 };
// shm_got_x_error
// file xshm.c line 59
static signed int shm_got_x_error = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// topLevelShellWidgetClass
// file /usr/include/X11/Shell.h line 556
extern struct _WidgetClassRec *topLevelShellWidgetClass;
// xscreensaver_function_table
// file m6502.c line 301
struct xscreensaver_function_table *xscreensaver_function_table;
// xscreensaver_function_table
// file m6502.c line 301
struct xscreensaver_function_table *xscreensaver_function_table = &m6502_xscreensaver_function_table;

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window)
{
  _Bool tmp_if_expr_1;
  if(event->xany.type == 19)
    tmp_if_expr_1 = event->xvisibility.window == (unsigned long int)window ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_25 *screen)
{
  signed int return_value___isoc99_sscanf_2;
  static unsigned long int root = (unsigned long int)0;
  static struct anonymous_25 *save_screen = (struct anonymous_25 *)0;
  if(!(screen == save_screen))
  {
    struct _XDisplay *dpy = screen->display;
    unsigned long int __SWM_VROOT = (unsigned long int)0L;
    signed int i;
    unsigned long int rootReturn;
    unsigned long int parentReturn;
    unsigned long int *children;
    unsigned int numChildren;
    const char *xss_id;
    xss_id=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id == ((const char *)NULL)))
    {
      if(!(*xss_id == 0))
      {
        unsigned long int id = (unsigned long int)0;
        char c;
        signed int return_value___isoc99_sscanf_1;
        return_value___isoc99_sscanf_1=__isoc99_sscanf(xss_id, " 0x%lx %c", &id, &c);
        _Bool tmp_if_expr_3;
        if(return_value___isoc99_sscanf_1 == 1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value___isoc99_sscanf_2=__isoc99_sscanf(xss_id, " %lu %c", &id, &c);
          tmp_if_expr_3 = 1 == return_value___isoc99_sscanf_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          root = (unsigned long int)id;
          save_screen = screen;
          return root;
        }

      }

    }

    root = screen->root;
    __SWM_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree_5;
    return_value_XQueryTree_5=XQueryTree(dpy, root, &rootReturn, &parentReturn, &children, &numChildren);
    if(!(return_value_XQueryTree_5 == 0))
    {
      i = 0;
      for( ; !((unsigned int)i >= numChildren); i = i + 1)
      {
        unsigned long int actual_type;
        signed int actual_format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned char *newRoot = ((unsigned char *)NULL);
        signed int return_value_XGetWindowProperty_4;
        return_value_XGetWindowProperty_4=XGetWindowProperty(dpy, children[(signed long int)i], __SWM_VROOT, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type, &actual_format, &nitems, &bytesafter, &newRoot);
        if(return_value_XGetWindowProperty_4 == 0)
        {
          if(!(newRoot == ((unsigned char *)NULL)))
          {
            root = *((unsigned long int *)newRoot);
            break;
          }

        }

      }
      if(!(children == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children);

    }

    save_screen = screen;
  }

  return root;
}

// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_24 *in, signed int *length_ret)
{
  signed int in_len = 0;
  const struct anonymous_24 *in_end;
  signed int out_len;
  char *utf8;
  char *out;
  const char *out_end;
  in_end = in;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(in_end->byte1 == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = in_end->byte2 != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    in_end = in_end + 1l;
    in_len = in_len + 1;
  }
  while((_Bool)1);
  out_len = (in_len + 1) * 3;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(out_len + 1));
  out = (char *)return_value_malloc_2;
  utf8 = out;
  if(out == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    out_end = out + (signed long int)out_len;
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)((signed int)in->byte1 << 8 | (signed int)in->byte2);
      signed int wrote;
      wrote=utf8_encode(uc, out, out_end - out);
      if(wrote >= 4)
        abort();

      out = out + (signed long int)wrote;
      in = in + 1l;
    }
    *out = (char)0;
    out_len = (signed int)((out - utf8) + (signed long int)1);
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)utf8, (unsigned long int)out_len);
    utf8 = (char *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = out_len;

    return utf8;
  }
}

// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self)
{
  /* assertion !self->last_errno */
  assert(!(self->last_errno != 0));
  unsigned int return_value__threadpool_count_parallel_2;
  return_value__threadpool_count_parallel_2=_threadpool_count_parallel(self->parent);
  if(self->parent->parallel_unfinished == return_value__threadpool_count_parallel_2)
  {
    signed int return_value_pthread_cond_broadcast_1;
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->parent->cond);
    /* assertion !(pthread_cond_broadcast(&self->parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  else
  {
    unsigned long int *thread = self->parent->parallel_threads + (signed long int)self->parent->parallel_unfinished;
    self->last_errno=pthread_create(thread, (const union pthread_attr_t *)(void *)0, _start_routine, (void *)self);
    if(!(self->last_errno == 0))
      _parallel_abort(self->parent);

  }
}

// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void)
{
  const signed int *name;
  signed long int result = (signed long int)0;
  static const signed int names[4l] = { 190, 193, 196, 199 };
  name = names;
  for( ; !(name == names + 4l); name = name + 1l)
  {
    signed long int sysconf_result;
    sysconf_result=sysconf(*name);
    if(!(result >= sysconf_result))
      result = sysconf_result;

  }
  if(!(result == 0l))
    return (unsigned int)result;

  else
    return (unsigned int)(1 << 7);
}

// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void)
{
  signed long int count;
  count=sysconf(84);
  return (unsigned int)(count > (signed long int)0 ? count : (signed long int)1);
}

// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self)
{
  /* assertion self->count > 1 */
  assert(self->count > (unsigned int)1);
  self->count = self->parallel_unfinished + (unsigned int)1;
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
  /* assertion !(pthread_cond_broadcast(&self->cond)) */
  assert(!(return_value_pthread_cond_broadcast_1 != 0));
}

// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self)
{
  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    self->thread_destroy(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  free(self->serial_threads);
}

// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw)
{
  struct _parallel_startup_type *startup = (struct _parallel_startup_type *)startup_raw;
  struct threadpool *parent = startup->parent;
  void *thread;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_1 != 0));
  parent->parallel_unfinished = parent->parallel_unfinished + 1u;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment((struct _XDisplay *)(void *)0);
  startup->last_errno=aligned_malloc(&thread, return_value_thread_memory_alignment_2, parent->thread_size);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&parent->mutex);
    /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
    return (void *)0;
  }

  startup->last_errno=startup->thread_create(thread, parent, parent->parallel_unfinished);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    void *return_value__thread_free_and_unlock_4;
    return_value__thread_free_and_unlock_4=_thread_free_and_unlock(parent, thread);
    return return_value__thread_free_and_unlock_4;
  }

  /* assertion !startup->last_errno */
  assert(!(startup->last_errno != 0));
  _add_next_thread(startup);
  void *return_value__thread_destroy_and_unlock_5;
  if(!(startup->last_errno == 0))
  {
    return_value__thread_destroy_and_unlock_5=_thread_destroy_and_unlock(parent, thread);
    return return_value__thread_destroy_and_unlock_5;
  }

  void *return_value__thread_destroy_and_unlock_6;
  if(parent->parallel_pending == 0u)
  {
    if(parent->parallel_threads == ((unsigned long int *)NULL))
    {
      return_value__thread_destroy_and_unlock_6=_thread_destroy_and_unlock(parent, thread);
      return return_value__thread_destroy_and_unlock_6;
    }

    signed int return_value_pthread_cond_wait_7;
    return_value_pthread_cond_wait_7=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_7 != 0));
  }

  parent->parallel_pending = parent->parallel_pending - 1u;
  signed int return_value_pthread_cond_broadcast_8;
  if(parent->parallel_pending == 0u)
  {
    return_value_pthread_cond_broadcast_8=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_8 != 0));
  }

  signed int return_value_pthread_mutex_unlock_9;
  return_value_pthread_mutex_unlock_9=pthread_mutex_unlock(&parent->mutex);
  /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_9 != 0));
  parent->thread_run(thread);
  signed int return_value_pthread_mutex_lock_10;
  return_value_pthread_mutex_lock_10=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_10 != 0));
  signed int return_value_pthread_cond_wait_11;
  if(!(parent->parallel_pending == 0u))
  {
    return_value_pthread_cond_wait_11=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_11 != 0));
  }

  parent->parallel_unfinished = parent->parallel_unfinished - 1u;
  signed int return_value_pthread_cond_broadcast_12;
  if(parent->parallel_unfinished == 0u)
  {
    return_value_pthread_cond_broadcast_12=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_12 != 0));
  }

}

// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread)
{
  self->thread_destroy(thread);
  void *return_value__thread_free_and_unlock_1;
  return_value__thread_free_and_unlock_1=_thread_free_and_unlock(self, thread);
  return return_value__thread_free_and_unlock_1;
}

// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread)
{
  signed int return_value_pthread_mutex_unlock_1;
  return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_1 != 0));
  aligned_free(thread);
  return (void *)0;
}

// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  /* assertion self->count >= 1 */
  assert(self->count >= (unsigned int)1);
  return self->count - (unsigned int)1;
}

// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  if(_has_pthread >= 0)
    return (unsigned int)(self->count != 0u ? 1 : 0);

  else
    return self->count;
}

// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self)
{
  unsigned long int *threads = self->parallel_threads;
  self->parallel_threads = (unsigned long int *)(void *)0;
  signed int return_value_pthread_cond_broadcast_1;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_2 != 0));
  signed int return_value_pthread_join_3;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    unsigned int i;
    unsigned int count;
    count=_threadpool_count_parallel(self);
    i = (unsigned int)0;
    for( ; !(i == count); i = i + 1u)
    {
      return_value_pthread_join_3=pthread_join(threads[(signed long int)i], (void **)(void *)0);
      /* assertion !(pthread_join(threads[i], ((void *)0))) */
      assert(!(return_value_pthread_join_3 != 0));
    }
    free((void *)threads);
    signed int return_value_pthread_cond_destroy_4;
    return_value_pthread_cond_destroy_4=pthread_cond_destroy(&self->cond);
    /* assertion !(pthread_cond_destroy(&self->cond)) */
    assert(!(return_value_pthread_cond_destroy_4 != 0));
    signed int return_value_pthread_mutex_destroy_5;
    return_value_pthread_mutex_destroy_5=pthread_mutex_destroy(&self->mutex);
    /* assertion !(pthread_mutex_destroy(&self->mutex)) */
    assert(!(return_value_pthread_mutex_destroy_5 != 0));
  }

  _serial_destroy(self);
}

// addend
// file asm6502.c line 1185
static struct AsmLine * addend(struct AsmLine *listp, struct AsmLine *newp)
{
  struct AsmLine *p;
  if(listp == ((struct AsmLine *)NULL))
    return newp;

  else
  {
    p = listp;
    for( ; !(p->next == ((struct AsmLine *)NULL)); p = p->next)
      ;
    p->next = newp;
    return listp;
  }
}

// addvalue
// file asm6502.c line 1229
static unsigned char addvalue(struct anonymous_8 *param, unsigned int value)
{
  if(!(param->vp >= 25u))
  {
    unsigned int tmp_post_1 = param->vp;
    param->vp = param->vp + 1u;
    param->value[(signed long int)tmp_post_1] = value;
    return (unsigned char)1;
  }

  else
  {
    fprintf(stderr, "Wrong number of parameters: %d. The limit is %d\n", param->vp + (unsigned int)1, 25);
    return (unsigned char)0;
  }
}

// aligned_free
// file aligned_malloc.c line 42
void aligned_free(void *ptr)
{
  free(((void **)ptr)[(signed long int)-1]);
}

// aligned_malloc
// file aligned_malloc.c line 26
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size)
{
  void *block_start;
  signed long int align1 = (signed long int)(alignment - (unsigned int)1);
  /* assertion alignment && !(alignment & (alignment - 1)) */
  assert(alignment != 0u && !((alignment & alignment - (unsigned int)1) != 0u));
  size = size + sizeof(void *) /*8ul*/  + (unsigned long int)align1;
  block_start=malloc(size);
  if(block_start == NULL)
    return 12;

  else
  {
    *ptr = (void *)((unsigned long int)(signed long int)block_start + sizeof(void *) /*8ul*/  + (unsigned long int)align1 & (unsigned long int)~align1);
    ((void **)*ptr)[(signed long int)-1] = block_start;
    return 0;
  }
}

// analogtv_add_signal
// file analogtv.c line 1231
static void analogtv_add_signal(const struct analogtv_s *it, const struct analogtv_reception_s *rec, unsigned int start, unsigned int end, signed int ec)
{
  struct analogtv_input_s *inp = rec->input;
  float *ps = it->rx_signal + (signed long int)start;
  float *pe = it->rx_signal + (signed long int)end;
  float *p = ps;
  signed char *ss = &inp->signal[(signed long int)0][(signed long int)0];
  signed char *se = &inp->signal[(signed long int)0][(signed long int)0] + (signed long int)238944;
  signed char *s = ss + (signed long int)((start + (unsigned int)rec->ofs) % (unsigned int)238944);
  signed char *s2;
  signed int i;
  float level = (float)rec->level;
  float hfloss = (float)rec->hfloss;
  unsigned int fastrnd;
  fastrnd=rnd_seek((unsigned int)1103515245, (unsigned int)12345, it->random1, start);
  float dp[5l];
  const float noise_decay = 0.99995f;
  float noise_ampl;
  float return_value_powf_1;
  return_value_powf_1=powf(noise_decay, (float)start);
  noise_ampl = 1.3f * return_value_powf_1;
  if(!(end >= (unsigned int)ec))
    ec = (signed int)end;

  i = (signed int)start;
  for( ; !(i >= ec); i = i + 1)
  {
    float analogtv_add_signal__1__1__sig0 = (float)s[(signed long int)0];
    unsigned int fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
    float noise = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * (50.0f / (float)0x7fffffff);
    fastrnd = fastrnd * (unsigned int)1103515245 + (unsigned int)12345 & 0xffffffffu;
    p[(signed long int)0] = p[(signed long int)0] + analogtv_add_signal__1__1__sig0 * level * (1.0f - noise_ampl) + noise * noise_ampl;
    noise_ampl = noise_ampl * noise_decay;
    p = p + 1l;
    s = s + 1l;
    if(s >= se)
      s = ss;

  }
  dp[(signed long int)0] = (float)0.0;
  s2 = s;
  i = 1;
  for( ; !(i >= 5); i = i + 1)
  {
    s2 = s2 - (signed long int)4;
    if(!(s2 >= ss))
      s2 = s2 + (signed long int)238944;

    dp[(signed long int)i] = (float)((signed int)s2[(signed long int)0] + (signed int)s2[(signed long int)1] + (signed int)s2[(signed long int)2] + (signed int)s2[(signed long int)3]);
  }
  /* assertion p <= pe */
  assert(p <= pe);
  /* assertion !((pe - p) % 4) */
  assert(!((pe - p) % (signed long int)4 != 0l));
  while(!(p == pe))
  {
    float sig0;
    float sig1;
    float sig2;
    float sig3;
    float sigr;
    sig0 = (float)s[(signed long int)0];
    sig1 = (float)s[(signed long int)1];
    sig2 = (float)s[(signed long int)2];
    sig3 = (float)s[(signed long int)3];
    dp[(signed long int)0] = sig0 + sig1 + sig2 + sig3;
    sigr = (float)((double)dp[(signed long int)1] * rec->ghostfir[(signed long int)0] + (double)dp[(signed long int)2] * rec->ghostfir[(signed long int)1] + (double)dp[(signed long int)3] * rec->ghostfir[(signed long int)2] + (double)dp[(signed long int)4] * rec->ghostfir[(signed long int)3]);
    dp[(signed long int)4] = dp[(signed long int)3];
    dp[(signed long int)3] = dp[(signed long int)2];
    dp[(signed long int)2] = dp[(signed long int)1];
    dp[(signed long int)1] = dp[(signed long int)0];
    p[(signed long int)0] = p[(signed long int)0] + (sig0 + sigr + sig2 * hfloss) * level;
    p[(signed long int)1] = p[(signed long int)1] + (sig1 + sigr + sig3 * hfloss) * level;
    p[(signed long int)2] = p[(signed long int)2] + (sig2 + sigr + sig0 * hfloss) * level;
    p[(signed long int)3] = p[(signed long int)3] + (sig3 + sigr + sig1 * hfloss) * level;
    p = p + (signed long int)4;
    s = s + (signed long int)4;
    if(s >= se)
      s = ss + (s - se);

  }
  /* assertion p == pe */
  assert(p == pe);
}

// analogtv_alloc_image
// file analogtv.c line 279
static void analogtv_alloc_image(struct analogtv_s *it)
{
  unsigned int bits_per_pixel;
  signed int return_value_get_bits_per_pixel_1;
  return_value_get_bits_per_pixel_1=get_bits_per_pixel(it->dpy, it->xgwa.depth);
  bits_per_pixel = (unsigned int)return_value_get_bits_per_pixel_1;
  unsigned int align;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment(it->dpy);
  align = return_value_thread_memory_alignment_2 * (unsigned int)8 - (unsigned int)1;
  unsigned int width = (unsigned int)it->usewidth * bits_per_pixel + align & ~align;
  if(!(it->use_shm == 0))
  {
    it->image=create_xshm_image(it->dpy, it->xgwa.visual, (unsigned int)it->xgwa.depth, 2, ((char *)NULL), &it->shm_info, width / bits_per_pixel, (unsigned int)it->useheight);
    if(it->image == ((struct _XImage *)NULL))
      it->use_shm = 0;

  }

  if(it->image == ((struct _XImage *)NULL))
  {
    it->image=XCreateImage(it->dpy, it->xgwa.visual, (unsigned int)it->xgwa.depth, 2, 0, ((char *)NULL), (unsigned int)it->usewidth, (unsigned int)it->useheight, 8, (signed int)(width / (unsigned int)8));
    if(!(it->image == ((struct _XImage *)NULL)))
    {
      unsigned int return_value_thread_memory_alignment_3;
      return_value_thread_memory_alignment_3=thread_memory_alignment(it->dpy);
      signed int return_value_posix_memalign_4;
      return_value_posix_memalign_4=posix_memalign((void **)&it->image->data, (unsigned long int)return_value_thread_memory_alignment_3, (unsigned long int)(it->image->height * it->image->bytes_per_line));
      if(!(return_value_posix_memalign_4 == 0))
      {
        it->image->data = (char *)(void *)0;
        it->image->f.destroy_image(it->image);
        it->image = (struct _XImage *)(void *)0;
      }

    }

  }

  if(!(it->image == ((struct _XImage *)NULL)))
    memset((void *)it->image->data, 0, (unsigned long int)(it->image->height * it->image->bytes_per_line));

  else
  {
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(12);
    fprintf(stderr, "analogtv: %s\n", return_value_strerror_5);
  }
}

// analogtv_allocate
// file analogtv.h line 239
struct analogtv_s * analogtv_allocate(struct _XDisplay *dpy, unsigned long int window)
{
  struct anonymous_4 gcv;
  struct analogtv_s *it = (struct analogtv_s *)(void *)0;
  signed int i;
  const unsigned long int rx_signal_len = (const unsigned long int)(238944 + 2 * 912);
  analogtv_init();
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct analogtv_s) /*30336ul*/ );
  it = (struct analogtv_s *)return_value_calloc_1;
  unsigned int return_value_thread_memory_alignment_4;
  signed int return_value_posix_memalign_5;
  unsigned int return_value_hardware_concurrency_6;
  signed int return_value_threadpool_create_7;
  unsigned int return_value_get_pixel_resource_14;
  if(it == ((struct analogtv_s *)NULL))
    return ((struct analogtv_s *)NULL);

  else
  {
    it->threads.count = (unsigned int)0;
    it->rx_signal = (float *)(void *)0;
    it->signal_subtotals = (float *)(void *)0;
    it->dpy = dpy;
    it->window = window;
    unsigned int return_value_thread_memory_alignment_2;
    return_value_thread_memory_alignment_2=thread_memory_alignment(dpy);
    signed int return_value_posix_memalign_3;
    return_value_posix_memalign_3=posix_memalign((void **)&it->rx_signal, (unsigned long int)return_value_thread_memory_alignment_2, sizeof(float) /*4ul*/  * rx_signal_len);
    if(return_value_posix_memalign_3 == 0)
    {
      /* assertion !(ANALOGTV_SIGNAL_LEN % 32) */
      assert(!(238944 % 32 != 0));
      return_value_thread_memory_alignment_4=thread_memory_alignment(dpy);
      return_value_posix_memalign_5=posix_memalign((void **)&it->signal_subtotals, (unsigned long int)return_value_thread_memory_alignment_4, sizeof(float) /*4ul*/  * (rx_signal_len / (unsigned long int)32));
      if(!(return_value_posix_memalign_5 == 0))
        goto fail;

      return_value_hardware_concurrency_6=hardware_concurrency(dpy);
      static struct threadpool_class cls = { .size=sizeof(struct analogtv_thread_s) /*32ul*/ , .create=analogtv_thread_create,
    .destroy=analogtv_thread_destroy };
      return_value_threadpool_create_7=threadpool_create(&it->threads, &cls, dpy, return_value_hardware_concurrency_6);
      if(!(return_value_threadpool_create_7 == 0))
        goto fail;

      /* assertion it->threads.count */
      assert(it->threads.count != 0u);
      it->shrinkpulse = -1;
      it->n_colors = 0;
      it->use_shm = 1;
      XGetWindowAttributes(it->dpy, it->window, &it->xgwa);
      it->screen = it->xgwa.screen;
      it->colormap = it->xgwa.colormap;
      it->visclass = it->xgwa.visual->class;
      it->visbits = it->xgwa.visual->bits_per_rgb;
      it->visdepth = it->xgwa.depth;
      _Bool tmp_if_expr_10;
      if(it->visclass == 4)
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = it->visclass == 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_10)
      {
        signed int return_value_get_integer_resource_8;
        return_value_get_integer_resource_8=get_integer_resource(it->dpy, "use_cmap", "Integer");
        if(!(return_value_get_integer_resource_8 == 0))
          it->use_cmap = 1;

        else
          it->use_cmap = 0;
        it->use_color = (signed int)!(mono_p != 0);
      }

      else
      {
        _Bool tmp_if_expr_9;
        if(it->visclass == 3)
          tmp_if_expr_9 = (_Bool)1;

        else
          tmp_if_expr_9 = it->visclass == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_9)
        {
          it->use_cmap = 1;
          it->use_color = (signed int)!(mono_p != 0);
        }

        else
        {
          it->use_cmap = 1;
          it->use_color = 0;
        }
      }
      it->red_mask = (unsigned int)it->xgwa.visual->red_mask;
      it->green_mask = (unsigned int)it->xgwa.visual->green_mask;
      it->blue_mask = (unsigned int)it->xgwa.visual->blue_mask;
      it->red_invprec = -1;
      it->red_shift = it->red_invprec;
      it->green_invprec = -1;
      it->green_shift = it->green_invprec;
      it->blue_invprec = -1;
      it->blue_shift = it->blue_invprec;
      if(it->use_cmap == 0)
      {
        signed int shift;
        signed int prec;
        shift = 0;
        for( ; !(shift >= 32); shift = shift + 1)
        {
          prec = 1;
          for( ; !(prec >= 40 + -shift) && !(prec >= 16); prec = prec + 1)
          {
            unsigned long int mask = (0xffffUL >> 16 - prec) << shift;
            if(!(it->red_shift >= 0))
            {
              if(mask == (unsigned long int)it->red_mask)
              {
                it->red_shift = shift;
                it->red_invprec = 16 - prec;
              }

            }

            if(!(it->green_shift >= 0))
            {
              if(mask == (unsigned long int)it->green_mask)
              {
                it->green_shift = shift;
                it->green_invprec = 16 - prec;
              }

            }

            if(!(it->blue_shift >= 0))
            {
              if(mask == (unsigned long int)it->blue_mask)
              {
                it->blue_shift = shift;
                it->blue_invprec = 16 - prec;
              }

            }

          }
        }
        _Bool tmp_if_expr_11;
        if(!(it->red_shift >= 0))
          tmp_if_expr_11 = (_Bool)1;

        else
          tmp_if_expr_11 = it->green_shift < 0 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_12;
        if(tmp_if_expr_11)
          tmp_if_expr_12 = (_Bool)1;

        else
          tmp_if_expr_12 = it->blue_shift < 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_12)
          goto fail;

        i = 0;
        for( ; !(i >= 1024); i = i + 1)
        {
          signed int intensity;
          double return_value_pow_13;
          return_value_pow_13=pow((double)i / 256.0, 0.8);
          intensity = (signed int)(return_value_pow_13 * 65535.0);
          if(intensity >= 65536)
            intensity = 65535;

          it->red_values[(signed long int)i] = (unsigned int)((intensity >> it->red_invprec) << it->red_shift);
          it->green_values[(signed long int)i] = (unsigned int)((intensity >> it->green_invprec) << it->green_shift);
          it->blue_values[(signed long int)i] = (unsigned int)((intensity >> it->blue_invprec) << it->blue_shift);
        }
      }

      return_value_get_pixel_resource_14=get_pixel_resource(it->dpy, it->colormap, "background", "Background");
      gcv.background = (unsigned long int)return_value_get_pixel_resource_14;
      it->gc=XCreateGC(it->dpy, it->window, (unsigned long int)(1L << 3), &gcv);
      XSetWindowBackground(it->dpy, it->window, gcv.background);
      XClearWindow(dpy, window);
      analogtv_configure(it);
      return it;
    }

    else
    {

    fail:
      ;
      if(!(it == ((struct analogtv_s *)NULL)))
      {
        if(!(it->threads.count == 0u))
          threadpool_destroy(&it->threads);

        free((void *)it->signal_subtotals);
        free((void *)it->rx_signal);
        free((void *)it);
      }

      return (struct analogtv_s *)(void *)0;
    }
  }
}

// analogtv_blast_imagerow
// file analogtv.c line 1390
static void analogtv_blast_imagerow(const struct analogtv_s *it, float *rgbf, float *rgbf_end, signed int ytop, signed int ybot)
{
  signed int i;
  signed int j;
  signed int x;
  signed int y;
  float *rpf;
  char *level_copyfrom[3l];
  signed int xrepl = it->xrepl;
  unsigned int lineheight = (unsigned int)(ybot - ytop);
  if(lineheight >= 13u)
    lineheight = (unsigned int)12;

  i = 0;
  for( ; !(i >= 3); i = i + 1)
    level_copyfrom[(signed long int)i] = (char *)(void *)0;
  y = ytop;
  for( ; !(y >= ybot); y = y + 1)
  {
    char *rowdata = it->image->data + (signed long int)(y * it->image->bytes_per_line);
    unsigned int line = (unsigned int)(y - ytop);
    signed int level = it->leveltable[(signed long int)lineheight][(signed long int)line].index;
    float levelmult = (float)it->leveltable[(signed long int)lineheight][(signed long int)line].value;
    if(!(level_copyfrom[(signed long int)level] == ((char *)NULL)))
      memcpy((void *)rowdata, (const void *)level_copyfrom[(signed long int)level], (unsigned long int)it->image->bytes_per_line);

    else
    {
      level_copyfrom[(signed long int)level] = rowdata;
      {
        _Bool tmp_if_expr_5;
        if(it->image->format == 2)
          tmp_if_expr_5 = it->image->bits_per_pixel == 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          unsigned int *pixelptr = (unsigned int *)rowdata;
          unsigned int pix;
          rpf = rgbf;
          for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
          {
            signed int analogtv_blast_imagerow__1__1__2__2__1__ntscri = (signed int)(rpf[(signed long int)0] * levelmult);
            signed int analogtv_blast_imagerow__1__1__2__2__1__ntscgi = (signed int)(rpf[(signed long int)1] * levelmult);
            signed int analogtv_blast_imagerow__1__1__2__2__1__ntscbi = (signed int)(rpf[(signed long int)2] * levelmult);
            if(analogtv_blast_imagerow__1__1__2__2__1__ntscri >= 1024)
              analogtv_blast_imagerow__1__1__2__2__1__ntscri = 1024 - 1;

            if(analogtv_blast_imagerow__1__1__2__2__1__ntscgi >= 1024)
              analogtv_blast_imagerow__1__1__2__2__1__ntscgi = 1024 - 1;

            if(analogtv_blast_imagerow__1__1__2__2__1__ntscbi >= 1024)
              analogtv_blast_imagerow__1__1__2__2__1__ntscbi = 1024 - 1;

            pix = it->red_values[(signed long int)analogtv_blast_imagerow__1__1__2__2__1__ntscri] | it->green_values[(signed long int)analogtv_blast_imagerow__1__1__2__2__1__ntscgi] | it->blue_values[(signed long int)analogtv_blast_imagerow__1__1__2__2__1__ntscbi];
            pixelptr[(signed long int)0] = pix;
            if(xrepl >= 2)
            {
              pixelptr[(signed long int)1] = pix;
              if(xrepl >= 3)
                pixelptr[(signed long int)2] = pix;

            }

            pixelptr = pixelptr + (signed long int)xrepl;
          }
        }

        else
        {
          _Bool tmp_if_expr_3;
          if(it->image->format == 2)
            tmp_if_expr_3 = it->image->bits_per_pixel == 16 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          _Bool tmp_if_expr_4;
          if(!(float_extraction_works == 0) && tmp_if_expr_3)
            tmp_if_expr_4 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            unsigned short int *analogtv_blast_imagerow__1__1__2__3__pixelptr = (unsigned short int *)rowdata;
            float r2;
            float g2;
            float b2;
            union anonymous_22 r1;
            union anonymous_22 g1;
            union anonymous_22 b1;
            unsigned short int analogtv_blast_imagerow__1__1__2__3__pix;
            rpf = rgbf;
            for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
            {
              r2 = rpf[(signed long int)0];
              g2 = rpf[(signed long int)1];
              b2 = rpf[(signed long int)2];
              r1.f = (float)((double)(r2 * levelmult) + float_low8_ofs);
              g1.f = (float)((double)(g2 * levelmult) + float_low8_ofs);
              b1.f = (float)((double)(b2 * levelmult) + float_low8_ofs);
              analogtv_blast_imagerow__1__1__2__3__pix = (unsigned short int)(it->red_values[(signed long int)(r1.i & 0x3ff)] | it->green_values[(signed long int)(g1.i & 0x3ff)] | it->blue_values[(signed long int)(b1.i & 0x3ff)]);
              analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)0] = analogtv_blast_imagerow__1__1__2__3__pix;
              if(xrepl >= 2)
              {
                analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)1] = analogtv_blast_imagerow__1__1__2__3__pix;
                if(xrepl >= 3)
                  analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)2] = analogtv_blast_imagerow__1__1__2__3__pix;

              }

              analogtv_blast_imagerow__1__1__2__3__pixelptr = analogtv_blast_imagerow__1__1__2__3__pixelptr + (signed long int)xrepl;
            }
          }

          else
          {
            _Bool tmp_if_expr_1;
            if(it->image->format == 2)
              tmp_if_expr_1 = it->image->bits_per_pixel == 16 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            _Bool tmp_if_expr_2;
            if(tmp_if_expr_1)
              tmp_if_expr_2 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
            {
              unsigned short int *analogtv_blast_imagerow__1__1__2__4__pixelptr = (unsigned short int *)rowdata;
              unsigned short int analogtv_blast_imagerow__1__1__2__4__pix;
              rpf = rgbf;
              for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
              {
                signed int analogtv_blast_imagerow__1__1__2__4__1__r1 = (signed int)(rpf[(signed long int)0] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__4__1__g1 = (signed int)(rpf[(signed long int)1] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__4__1__b1 = (signed int)(rpf[(signed long int)2] * levelmult);
                if(analogtv_blast_imagerow__1__1__2__4__1__r1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__r1 = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__4__1__g1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__g1 = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__4__1__b1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__b1 = 1024 - 1;

                analogtv_blast_imagerow__1__1__2__4__pix = (unsigned short int)(it->red_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__r1] | it->green_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__g1] | it->blue_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__b1]);
                analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)0] = analogtv_blast_imagerow__1__1__2__4__pix;
                if(xrepl >= 2)
                {
                  analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)1] = analogtv_blast_imagerow__1__1__2__4__pix;
                  if(xrepl >= 3)
                    analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)2] = analogtv_blast_imagerow__1__1__2__4__pix;

                }

                analogtv_blast_imagerow__1__1__2__4__pixelptr = analogtv_blast_imagerow__1__1__2__4__pixelptr + (signed long int)xrepl;
              }
            }

            else
            {
              x = 0;
              rpf = rgbf;
              for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
              {
                signed int ntscri = (signed int)(rpf[(signed long int)0] * levelmult);
                signed int ntscgi = (signed int)(rpf[(signed long int)1] * levelmult);
                signed int ntscbi = (signed int)(rpf[(signed long int)2] * levelmult);
                if(ntscri >= 1024)
                  ntscri = 1024 - 1;

                if(ntscgi >= 1024)
                  ntscgi = 1024 - 1;

                if(ntscbi >= 1024)
                  ntscbi = 1024 - 1;

                j = 0;
                if(!(j >= xrepl))
                {
                  it->image->f.put_pixel(it->image, x * xrepl + j, y, (unsigned long int)(it->red_values[(signed long int)ntscri] | it->green_values[(signed long int)ntscgi] | it->blue_values[(signed long int)ntscbi]));
                  j = j + 1;
                }

                x = x + 1;
              }
            }
          }
        }
      }
    }
  }
}

// analogtv_configure
// file analogtv.c line 319
static void analogtv_configure(struct analogtv_s *it)
{
  signed int oldwidth = it->usewidth;
  signed int oldheight = it->useheight;
  signed int wlim;
  signed int hlim;
  signed int height_diff;
  float percent = (float)0.15;
  float min_ratio = (float)((4.0 / 3.0) * (double)((float)1 - percent));
  float max_ratio = (float)((16.0 / 9.0) * (double)((float)1 + percent));
  float ratio;
  float height_snap = (float)0.025;
  hlim = it->xgwa.height;
  wlim = it->xgwa.width;
  ratio = (float)wlim / (float)hlim;
  if(!(hlim >= 200) || !(wlim >= 266))
  {
    wlim = 266;
    hlim = 200;
  }

  else
    if(!(ratio < max_ratio) || !(ratio > min_ratio))
    {
      if(ratio >= max_ratio)
        wlim = (signed int)((float)hlim * max_ratio);

      else
        hlim = (signed int)((float)wlim / min_ratio);
    }

  height_diff = (hlim + 200 / 2) % 200 - 200 / 2;
  double return_value_fabs_1;
  if(!(height_diff == 0))
  {
    return_value_fabs_1=fabs((double)height_diff);
    if(return_value_fabs_1 < (double)((float)hlim * height_snap))
      hlim = hlim - height_diff;

  }

  if(!(hlim == oldheight) || !(wlim == oldwidth))
  {
    it->usewidth = wlim;
    it->useheight = hlim;
    it->xrepl = 1 + it->usewidth / 640;
    if(it->xrepl >= 3)
      it->xrepl = 2;

    it->subwidth = it->usewidth / it->xrepl;
    analogtv_free_image(it);
    analogtv_alloc_image(it);
  }

  it->screen_xo = (it->xgwa.width - it->usewidth) / 2;
  it->screen_yo = (it->xgwa.height - it->useheight) / 2;
  it->need_clear = 1;
}

// analogtv_draw
// file analogtv.h line 250
void analogtv_draw(struct analogtv_s *it, double noiselevel, const struct analogtv_reception_s * const *recs, unsigned int rec_count)
{
  signed int i;
  signed int lineno;
  double baseload;
  signed int overall_top;
  signed int overall_bot;
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    it->rx_signal_level = noiselevel;
    i = 0;
    for( ; !((unsigned int)i == rec_count); i = i + 1)
    {
      const struct analogtv_reception_s *rec = recs[(signed long int)i];
      double level = rec->level;
      struct analogtv_input_s *inp = rec->input;
      it->rx_signal_level=sqrt(it->rx_signal_level * it->rx_signal_level + level * level * (1.0 + 4.0 * (rec->ghostfir[(signed long int)0] + rec->ghostfir[(signed long int)1] + rec->ghostfir[(signed long int)2] + rec->ghostfir[(signed long int)3])));
      memcpy((void *)inp->signal[(signed long int)262], (const void *)inp->signal[(signed long int)0], (unsigned long int)912 * sizeof(signed char) /*1ul*/ );
    }
    analogtv_setup_frame(it);
    analogtv_set_demod(it);
    it->random0=ya_random();
    it->random1=ya_random();
    it->noiselevel = noiselevel;
    it->recs = recs;
    it->rec_count = rec_count;
    threadpool_run(&it->threads, analogtv_thread_add_signals);
    threadpool_wait(&it->threads);
    it->channel_change_cycles = 0;
    memcpy((void *)&it->rx_signal[(signed long int)238944], (const void *)&it->rx_signal[(signed long int)0], (unsigned long int)(2 * 912) * sizeof(float) /*4ul*/ );
    memcpy((void *)&it->signal_subtotals[(signed long int)(238944 / 32)], (const void *)&it->signal_subtotals[(signed long int)0], (unsigned long int)((2 * 912) / 32) * sizeof(float) /*4ul*/ );
    analogtv_sync(it);
    baseload = 0.5;
    it->crtload[(signed long int)(30 - 1)] = (float)baseload;
    float return_value_puramp_1;
    return_value_puramp_1=puramp(it, (float)2.0, (float)1.0, (float)1.3);
    float return_value_puramp_2;
    return_value_puramp_2=puramp(it, (float)2.0, (float)2.0, (float)1.1);
    it->puheight = (float)((double)(return_value_puramp_1 * it->height_control) * (1.125 - 0.125 * (double)return_value_puramp_2));
    analogtv_setup_levels(it, ((double)it->puheight * (double)it->useheight) / (double)200);
    double return_value_cos_3;
    return_value_cos_3=cos(((double)((float)103 + it->tint_control) * 3.1415926) / (double)180);
    it->tint_i = (float)-return_value_cos_3;
    double return_value_sin_4;
    return_value_sin_4=sin(((double)((float)103 + it->tint_control) * 3.1415926) / (double)180);
    it->tint_q = (float)return_value_sin_4;
    lineno = 30;
    for( ; !(lineno >= 230); lineno = lineno + 1)
    {
      signed int slineno;
      signed int ytop;
      signed int ybot;
      unsigned int signal_offset;
      signed int return_value_analogtv_get_line_5;
      return_value_analogtv_get_line_5=analogtv_get_line(it, lineno, &slineno, &ytop, &ybot, &signal_offset);
      if(!(return_value_analogtv_get_line_5 == 0))
      {
        if(lineno == it->shrinkpulse)
        {
          baseload = baseload + 0.4;
          it->shrinkpulse = -1;
        }

        float totsignal = (float)0;
        float ncl;
        unsigned int frac;
        unsigned long int end0;
        unsigned long int end1;
        const float *p;
        frac = signal_offset & (unsigned int)(32 - 1);
        p = it->rx_signal + (signed long int)(signal_offset & (unsigned int)~(32 - 1));
        i = 0;
        for( ; !((unsigned int)i == frac); i = i + 1)
          totsignal = totsignal - p[(signed long int)i];
        end0 = (unsigned long int)(signal_offset + (unsigned int)755);
        end1 = end0 / (unsigned long int)32;
        i = (signed int)(signal_offset / (unsigned int)32);
        for( ; !((unsigned long int)i >= end1); i = i + 1)
          totsignal = totsignal + it->signal_subtotals[(signed long int)i];
        frac = (unsigned int)(end0 & (unsigned long int)(32 - 1));
        p = it->rx_signal + (signed long int)(end0 & (unsigned long int)~(32 - 1));
        i = 0;
        for( ; !((unsigned int)i == frac); i = i + 1)
          totsignal = totsignal + p[(signed long int)i];
        totsignal = totsignal * it->agclevel;
        float tmp_if_expr_6;
        if(slineno >= 185)
          tmp_if_expr_6 = (float)((slineno - 184) * (lineno - 184)) * 0.001f * it->squeezebottom;

        else
          tmp_if_expr_6 = 0.0f;
        ncl = (float)((double)(0.95f * it->crtload[(signed long int)(lineno - 1)]) + (double)0.05f * (baseload + (double)((totsignal - (float)30000) / 100000.0f) + (double)tmp_if_expr_6));
        it->crtload[(signed long int)lineno] = ncl;
      }

    }
    threadpool_run(&it->threads, analogtv_thread_draw_lines);
    threadpool_wait(&it->threads);
    if(!(it->need_clear == 0))
    {
      XClearWindow(it->dpy, it->window);
      it->need_clear = 0;
    }

    overall_top = (signed int)(((float)it->useheight * ((float)1 - it->puheight)) / (float)2);
    overall_bot = (signed int)(((float)it->useheight * ((float)1 + it->puheight)) / (float)2);
    if(!(overall_top >= 0))
      overall_top = 0;

    if(!(it->useheight >= overall_bot))
      overall_bot = it->useheight;

    if(overall_top >= 1)
      XClearArea(it->dpy, it->window, it->screen_xo, it->screen_yo, (unsigned int)it->usewidth, (unsigned int)overall_top, 0);

    if(!(overall_bot >= it->useheight))
      XClearArea(it->dpy, it->window, it->screen_xo, it->screen_yo + overall_bot, (unsigned int)it->usewidth, (unsigned int)(it->useheight - overall_bot), 0);

    if(!(overall_top >= overall_bot))
    {
      if(!(it->use_shm == 0))
        XShmPutImage(it->dpy, it->window, it->gc, it->image, 0, overall_top, it->screen_xo, it->screen_yo + overall_top, (unsigned int)it->usewidth, (unsigned int)(overall_bot - overall_top), 0);

      else
        XPutImage(it->dpy, it->window, it->gc, it->image, 0, overall_top, it->screen_xo, it->screen_yo + overall_top, (unsigned int)it->usewidth, (unsigned int)(overall_bot - overall_top));
    }

  }

}

// analogtv_draw_char
// file analogtv.c line 2364
void analogtv_draw_char(struct analogtv_input_s *input, struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int *ntsc)
{
  signed int yc;
  signed int xc;
  signed int ys;
  signed int xs;
  signed int pix;
  yc = 0;
  for( ; !(yc >= f->char_h); yc = yc + 1)
  {
    ys = y + yc * f->y_mult;
    for( ; !(ys >= (1 + yc) * f->y_mult + y); ys = ys + 1)
      if(!(ys >= 262) && ys >= 0)
      {
        xc = 0;
        for( ; !(xc >= f->char_w); xc = xc + 1)
        {
          pix=analogtv_font_pixel(f, c, xc, yc);
          xs = x + xc * f->x_mult;
          for( ; !(xs >= (1 + xc) * f->x_mult + x); xs = xs + 1)
            if(!(xs >= 912) && xs >= 0)
            {
              if(!(pix == 0))
                input->signal[(signed long int)ys][(signed long int)xs] = (signed char)ntsc[(signed long int)(xs & 3)];

            }

        }
      }

  }
}

// analogtv_draw_solid
// file analogtv.h line 271
void analogtv_draw_solid(struct analogtv_input_s *input, signed int left, signed int right, signed int top, signed int bot, signed int *ntsc)
{
  signed int x;
  signed int y;
  if(!(right + -left >= 4))
    right = left + 4;

  if(!(bot + -top >= 1))
    bot = top + 1;

  y = top;
  for( ; !(y >= bot); y = y + 1)
  {
    x = left;
    for( ; !(x >= right); x = x + 1)
      input->signal[(signed long int)y][(signed long int)x] = (signed char)ntsc[(signed long int)(x & 3)];
  }
}

// analogtv_draw_solid_rel_lcp
// file analogtv.c line 2347
void analogtv_draw_solid_rel_lcp(struct analogtv_input_s *input, double left, double right, double top, double bot, double luma, double chroma, double phase)
{
  signed int ntsc[4l];
  signed int topi = (signed int)((double)30 + (double)200 * top);
  signed int boti = (signed int)((double)30 + (double)200 * bot);
  signed int lefti = (signed int)((double)229 + (double)566 * left);
  signed int righti = (signed int)((double)229 + (double)566 * right);
  analogtv_lcp_to_ntsc(luma, chroma, phase, ntsc);
  analogtv_draw_solid(input, lefti, righti, topi, boti, ntsc);
}

// analogtv_draw_string
// file analogtv.c line 2388
void analogtv_draw_string(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc)
{
  for( ; !(*s == 0); s = s + 1l)
  {
    analogtv_draw_char(input, f, (signed int)*s, x, y, ntsc);
    x = x + f->char_w * 4;
  }
}

// analogtv_draw_string_centered
// file analogtv.c line 2399
void analogtv_draw_string_centered(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc)
{
  signed int width;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  width = (signed int)(return_value_strlen_1 * (unsigned long int)f->char_w * (unsigned long int)4);
  x = x - width / 2;
  analogtv_draw_string(input, f, s, x, y, ntsc);
}

// analogtv_draw_xpm
// file analogtv.c line 2422
void analogtv_draw_xpm(struct analogtv_s *tv, struct analogtv_input_s *input, const char * const *xpm, signed int left, signed int top)
{
  signed int xpmw;
  signed int xpmh;
  signed int x;
  signed int y;
  signed int tvx;
  signed int tvy;
  signed int i;
  signed int rawy;
  signed int rawi;
  signed int rawq;
  signed int ncolors;
  signed int nbytes;
  char dummyc;
  /* tag-#anon#lST[S32'r'|S32'g'|S32'b'] */
struct anonymous_11
{
  // r
  signed int r;
  // g
  signed int g;
  // b
  signed int b;
};

/* */
  ;
  struct anonymous_11 cmap[256l];
  signed int return_value___isoc99_sscanf_1;
  return_value___isoc99_sscanf_1=__isoc99_sscanf((const char *)*xpm, "%d %d %d %d %c", &xpmw, &xpmh, &ncolors, &nbytes, &dummyc);
  if(!(return_value___isoc99_sscanf_1 == 4))
    abort();

  if(ncolors >= 256 || !(ncolors >= 1))
    abort();

  if(!(nbytes == 1))
    abort();

  xpm = xpm + 1l;
  i = 0;
  for( ; !(i >= ncolors); i = i + 1)
  {
    const char *analogtv_draw_xpm__1__1__line = *xpm;
    signed int colori;
    const char *tmp_post_2 = analogtv_draw_xpm__1__1__line;
    analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + 1l;
    colori = (signed int)(unsigned char)*tmp_post_2 & 0xff;
    while(!(*analogtv_draw_xpm__1__1__line == 0))
    {
      signed int r;
      signed int g;
      signed int b;
      char which;
      for( ; (_Bool)1; analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + 1l)
        if(!((signed int)*analogtv_draw_xpm__1__1__line == 32))
        {
          if(!((signed int)*analogtv_draw_xpm__1__1__line == 9))
            goto __CPROVER_DUMP_L8;

        }


    __CPROVER_DUMP_L8:
      ;
      const char *tmp_post_3 = analogtv_draw_xpm__1__1__line;
      analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + 1l;
      which = *tmp_post_3;
      if(!((signed int)which == 99) && !((signed int)which == 109))
        abort();

      for( ; (_Bool)1; analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + 1l)
        if(!((signed int)*analogtv_draw_xpm__1__1__line == 32))
        {
          if(!((signed int)*analogtv_draw_xpm__1__1__line == 9))
            goto __CPROVER_DUMP_L11;

        }


    __CPROVER_DUMP_L11:
      ;
      signed int return_value_strncasecmp_4;
      return_value_strncasecmp_4=strncasecmp(analogtv_draw_xpm__1__1__line, "None", (unsigned long int)4);
      if(return_value_strncasecmp_4 == 0)
      {
        b = -1;
        g = b;
        r = g;
        analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + (signed long int)4;
      }

      else
      {
        if((signed int)*analogtv_draw_xpm__1__1__line == 35)
          analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + 1l;

        r = (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)1]];
        analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + (signed long int)2;
        g = (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)1]];
        analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + (signed long int)2;
        b = (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)analogtv_draw_xpm__1__1__line[(signed long int)1]];
        analogtv_draw_xpm__1__1__line = analogtv_draw_xpm__1__1__line + (signed long int)2;
      }
      if((signed int)which == 99)
      {
        cmap[(signed long int)colori].r = r;
        cmap[(signed long int)colori].g = g;
        cmap[(signed long int)colori].b = b;
      }

    }
    xpm = xpm + 1l;
  }
  y = 0;
  for( ; !(y >= xpmh); y = y + 1)
  {
    const char *line;
    const char * const *tmp_post_5 = xpm;
    xpm = xpm + 1l;
    line = *tmp_post_5;
    tvy = y + top;
    if(!(tvy >= 230) && tvy >= 30)
    {
      x = 0;
      for( ; !(x >= xpmw); x = x + 1)
      {
        signed int cbyte = (signed int)(unsigned char)line[(signed long int)x] & 0xff;
        signed int ntsc[4l];
        tvx = x * 4 + left;
        if(!(4 + tvx >= 891) && tvx >= 135)
        {
          rawy = (5 * cmap[(signed long int)cbyte].r + 11 * cmap[(signed long int)cbyte].g + 2 * cmap[(signed long int)cbyte].b) / 64;
          rawi = ((10 * cmap[(signed long int)cbyte].r - 4 * cmap[(signed long int)cbyte].g) - 5 * cmap[(signed long int)cbyte].b) / 64;
          rawq = ((3 * cmap[(signed long int)cbyte].r - 8 * cmap[(signed long int)cbyte].g) + 5 * cmap[(signed long int)cbyte].b) / 64;
          ntsc[(signed long int)0] = rawy + rawq;
          ntsc[(signed long int)1] = rawy - rawi;
          ntsc[(signed long int)2] = rawy - rawq;
          ntsc[(signed long int)3] = rawy + rawi;
          i = 0;
          for( ; !(i >= 4); i = i + 1)
          {
            if(ntsc[(signed long int)i] >= 101)
              ntsc[(signed long int)i] = 100;

            if(!(ntsc[(signed long int)i] >= 10))
              ntsc[(signed long int)i] = 10;

          }
          input->signal[(signed long int)tvy][(signed long int)(tvx + 0)] = (signed char)ntsc[(signed long int)(tvx + 0 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 1)] = (signed char)ntsc[(signed long int)(tvx + 1 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 2)] = (signed char)ntsc[(signed long int)(tvx + 2 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 3)] = (signed char)ntsc[(signed long int)(tvx + 3 & 3)];
        }

      }
    }

  }
}

// analogtv_font_pixel
// file analogtv.c line 2280
signed int analogtv_font_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y)
{
  _Bool tmp_if_expr_1;
  if(!(x >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = x >= f->char_w ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    _Bool tmp_if_expr_2;
    if(!(y >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = y >= f->char_h ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
      if(c >= 256 || !(c >= 0))
        return 0;

      else
      {
        unsigned long int return_value;
        return_value=f->text_im->f.get_pixel(f->text_im, c * f->char_w + x, y);
        return return_value != 0ul ? 1 : 0;
      }
  }
}

// analogtv_font_set_char
// file analogtv.c line 2299
void analogtv_font_set_char(struct analogtv_font_s *f, signed int c, char *s)
{
  signed int analogtv_font_set_char__1__value;
  signed int x;
  signed int y;
  if(!(c >= 256) && c >= 0)
  {
    y = 0;
    for( ; !(y >= f->char_h); y = y + 1)
    {
      x = 0;
      for( ; !(x >= f->char_w); x = x + 1)
      {
        if(*s == 0)
          goto __CPROVER_DUMP_L7;

        analogtv_font_set_char__1__value = (signed int)*s == 32 ? 0 : 1;
        analogtv_font_set_pixel(f, c, x, y, analogtv_font_set_char__1__value);
        s = s + 1l;
      }
    }
  }


__CPROVER_DUMP_L7:
  ;
}

// analogtv_font_set_pixel
// file analogtv.c line 2289
void analogtv_font_set_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int value)
{
  _Bool tmp_if_expr_1;
  if(!(x >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = x >= f->char_w ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    _Bool tmp_if_expr_2;
    if(!(y >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = y >= f->char_h ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      if(!(c >= 256) && c >= 0)
        f->text_im->f.put_pixel(f->text_im, c * f->char_w + x, y, (unsigned long int)value);

    }

  }

}

// analogtv_free_image
// file analogtv.c line 262
static void analogtv_free_image(struct analogtv_s *it)
{
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    if(!(it->use_shm == 0))
      destroy_xshm_image(it->dpy, it->image, &it->shm_info);

    else
    {
      free((void *)it->image->data);
      it->image->data = (char *)(void *)0;
      it->image->f.destroy_image(it->image);
    }
    it->image = (struct _XImage *)(void *)0;
  }

}

// analogtv_get_line
// file analogtv.c line 1365
static signed int analogtv_get_line(const struct analogtv_s *it, signed int lineno, signed int *slineno, signed int *ytop, signed int *ybot, unsigned int *signal_offset)
{
  *slineno = lineno - 30;
  *ytop = (signed int)((float)((*slineno * it->useheight) / 200 - it->useheight / 2) * it->puheight) + it->useheight / 2;
  *ybot = (signed int)((float)(((*slineno + 1) * it->useheight) / 200 - it->useheight / 2) * it->puheight) + it->useheight / 2;
  *signal_offset = (unsigned int)(((lineno + it->cur_vsync + 262) % 262) * 912 + it->line_hsync[(signed long int)lineno]);
  if(*ytop == *ybot)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(!(*ybot >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *ytop > it->useheight ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    else
    {
      if(!(*ytop >= 0))
        *ytop = 0;

      if(!(it->useheight >= *ybot))
        *ybot = it->useheight;

      if(!(12 + *ytop >= *ybot))
        *ybot = *ytop + 12;

      return 1;
    }
  }
}

// analogtv_init
// file analogtv.c line 165
static void analogtv_init(void)
{
  signed int i;
  unsigned int localbyteorder_loc = (unsigned int)(1 << 24 | 0 << 0);
  localbyteorder = (signed int)*((char *)&localbyteorder_loc);
  {
    union anonymous_22 fe;
    signed int ans;
    float_extraction_works = 1;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      fe.f = (float)(float_low8_ofs + (double)i);
      ans = fe.i & 0x3ff;
      if(!(ans == i))
      {
        float_extraction_works = 0;
        break;
      }

    }
  }
}

// analogtv_init_signal
// file analogtv.c line 1210
static void analogtv_init_signal(const struct analogtv_s *it, double noiselevel, unsigned int start, unsigned int end)
{
  float *ps = it->rx_signal + (signed long int)start;
  float *pe = it->rx_signal + (signed long int)end;
  float *p = ps;
  unsigned int fastrnd;
  fastrnd=rnd_seek((unsigned int)1103515245, (unsigned int)12345, it->random0, start);
  unsigned int fastrnd_offset;
  float nm1;
  float nm2;
  float noisemul;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(noiselevel * (double)150);
  noisemul = (float)(return_value_sqrt_1 / (double)(float)0x7fffffff);
  fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
  nm1 = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * noisemul;
  while(!(p == pe))
  {
    nm2 = nm1;
    fastrnd = fastrnd * (unsigned int)1103515245 + (unsigned int)12345 & 0xffffffffu;
    fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
    nm1 = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * noisemul;
    float *tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = nm1 * nm2;
  }
}

// analogtv_input_allocate
// file analogtv.h line 240
struct analogtv_input_s * analogtv_input_allocate(void)
{
  struct analogtv_input_s *ret;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct analogtv_input_s) /*239888ul*/ );
  ret = (struct analogtv_input_s *)return_value_calloc_1;
  return ret;
}

// analogtv_lcp_to_ntsc
// file analogtv.h line 267
void analogtv_lcp_to_ntsc(double luma, double chroma, double phase, signed int *ntsc)
{
  signed int i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    double w = 90.0 * (double)i + phase;
    double val;
    double return_value_cos_1;
    return_value_cos_1=cos((3.1415926 / 180.0) * w);
    val = luma + chroma * return_value_cos_1;
    if(val < 0.0)
      val = 0.0;

    if(val > 127.0)
      val = 127.0;

    ntsc[(signed long int)i] = (signed int)val;
  }
}

// analogtv_level
// file analogtv.c line 1122
static signed int analogtv_level(const struct analogtv_s *it, signed int y, signed int ytop, signed int ybot)
{
  signed int level;
  if(ybot + -ytop >= 7)
  {
    if(y == ybot + -1 || y == ytop)
      level = 0;

    else
      if(y == 1 + ytop || y == ybot + -2)
        level = 1;

      else
        level = 2;
  }

  else
    if(ybot + -ytop >= 5)
    {
      if(y == ybot + -1 || y == ytop)
        level = 0;

      else
        level = 2;
    }

    else
      if(ybot + -ytop >= 3)
      {
        if(y == ytop)
          level = 0;

        else
          level = 2;
      }

      else
        level = 2;
  return level;
}

// analogtv_levelmult
// file analogtv.c line 1115
static double analogtv_levelmult(const struct analogtv_s *it, signed int level)
{
  float return_value_puramp_1;
  return_value_puramp_1=puramp(it, (float)3.0, (float)6.0, (float)1.0);
  static const double levelfac[3l] = { -7.5, 5.5, 24.5 };
  return (40.0 + levelfac[(signed long int)level] * (double)return_value_puramp_1) / 256.0;
}

// analogtv_load_ximage
// file analogtv.c line 2015
signed int analogtv_load_ximage(struct analogtv_s *it, struct analogtv_input_s *input, struct _XImage *pic_im)
{
  signed int i;
  signed int x;
  signed int y;
  signed int img_w;
  signed int img_h;
  signed int fyx[7l];
  signed int fyy[7l];
  signed int fix[4l];
  signed int fiy[4l];
  signed int fqx[4l];
  signed int fqy[4l];
  struct anonymous_9 col1[755l];
  struct anonymous_9 col2[755l];
  signed int multiq[759l];
  signed int y_overscan = 5;
  signed int y_scanlength = 200 + 2 * y_overscan;
  img_w = pic_im->width;
  img_h = pic_im->height;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    double phase = 90.0 - 90.0 * (double)i;
    double ampl = 1.0;
    double return_value_cos_1;
    return_value_cos_1=cos((3.1415926 / 180.0) * (phase - (double)303));
    multiq[(signed long int)i] = (signed int)(-return_value_cos_1 * 4096.0 * ampl);
  }
  y = 0;
  for( ; !(y >= y_scanlength); y = y + 1)
  {
    signed int picy1 = (y * img_h) / y_scanlength;
    signed int picy2 = (y * img_h + y_scanlength / 2) / y_scanlength;
    x = 0;
    if(!(x >= 755))
    {
      signed int picx = (x * img_w) / 755;
      col1[(signed long int)x].pixel=pic_im->f.get_pixel(pic_im, picx, picy1);
      col2[(signed long int)x].pixel=pic_im->f.get_pixel(pic_im, picx, picy2);
      x = x + 1;
    }

    XQueryColors(it->dpy, it->colormap, col1, 755);
    XQueryColors(it->dpy, it->colormap, col2, 755);
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      fyy[(signed long int)i] = 0;
      fyx[(signed long int)i] = fyy[(signed long int)i];
    }
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      fqy[(signed long int)i] = (signed int)0.0;
      fqx[(signed long int)i] = fqy[(signed long int)i];
      fiy[(signed long int)i] = fqx[(signed long int)i];
      fix[(signed long int)i] = fiy[(signed long int)i];
    }
    x = 0;
    for( ; !(x >= 755); x = x + 1)
    {
      signed int rawy;
      signed int rawi;
      signed int rawq;
      signed int filty;
      signed int filti;
      signed int filtq;
      signed int composite;
      rawy = 5 * (signed int)col1[(signed long int)x].red + 11 * (signed int)col1[(signed long int)x].green + 2 * (signed int)col1[(signed long int)x].blue + 5 * (signed int)col2[(signed long int)x].red + 11 * (signed int)col2[(signed long int)x].green + 2 * (signed int)col2[(signed long int)x].blue >> 7;
      rawi = ((((10 * (signed int)col1[(signed long int)x].red - 4 * (signed int)col1[(signed long int)x].green) - 5 * (signed int)col1[(signed long int)x].blue) + 10 * (signed int)col2[(signed long int)x].red) - 4 * (signed int)col2[(signed long int)x].green) - 5 * (signed int)col2[(signed long int)x].blue >> 7;
      rawq = (((3 * (signed int)col1[(signed long int)x].red - 8 * (signed int)col1[(signed long int)x].green) + 5 * (signed int)col1[(signed long int)x].blue + 3 * (signed int)col2[(signed long int)x].red) - 8 * (signed int)col2[(signed long int)x].green) + 5 * (signed int)col2[(signed long int)x].blue >> 7;
      fyx[(signed long int)0] = fyx[(signed long int)1];
      fyx[(signed long int)1] = fyx[(signed long int)2];
      fyx[(signed long int)2] = fyx[(signed long int)3];
      fyx[(signed long int)3] = fyx[(signed long int)4];
      fyx[(signed long int)4] = fyx[(signed long int)5];
      fyx[(signed long int)5] = fyx[(signed long int)6];
      fyx[(signed long int)6] = rawy * 1897 >> 16;
      fyy[(signed long int)0] = fyy[(signed long int)1];
      fyy[(signed long int)1] = fyy[(signed long int)2];
      fyy[(signed long int)2] = fyy[(signed long int)3];
      fyy[(signed long int)3] = fyy[(signed long int)4];
      fyy[(signed long int)4] = fyy[(signed long int)5];
      fyy[(signed long int)5] = fyy[(signed long int)6];
      fyy[(signed long int)6] = fyx[(signed long int)0] + fyx[(signed long int)6] + 4 * (fyx[(signed long int)1] + fyx[(signed long int)5]) + 7 * (fyx[(signed long int)2] + fyx[(signed long int)4]) + 8 * fyx[(signed long int)3] + (((-151 * fyy[(signed long int)2] + 8115 * fyy[(signed long int)3]) - 38312 * fyy[(signed long int)4]) + 36586 * fyy[(signed long int)5] >> 16);
      filty = fyy[(signed long int)6];
      fix[(signed long int)0] = fix[(signed long int)1];
      fix[(signed long int)1] = fix[(signed long int)2];
      fix[(signed long int)2] = fix[(signed long int)3];
      fix[(signed long int)3] = rawi * 1413 >> 16;
      fiy[(signed long int)0] = fiy[(signed long int)1];
      fiy[(signed long int)1] = fiy[(signed long int)2];
      fiy[(signed long int)2] = fiy[(signed long int)3];
      fiy[(signed long int)3] = fix[(signed long int)0] + fix[(signed long int)3] + 3 * (fix[(signed long int)1] + fix[(signed long int)2]) + ((16559 * fiy[(signed long int)0] - 72008 * fiy[(signed long int)1]) + 109682 * fiy[(signed long int)2] >> 16);
      filti = fiy[(signed long int)3];
      fqx[(signed long int)0] = fqx[(signed long int)1];
      fqx[(signed long int)1] = fqx[(signed long int)2];
      fqx[(signed long int)2] = fqx[(signed long int)3];
      fqx[(signed long int)3] = rawq * 75 >> 16;
      fqy[(signed long int)0] = fqy[(signed long int)1];
      fqy[(signed long int)1] = fqy[(signed long int)2];
      fqy[(signed long int)2] = fqy[(signed long int)3];
      fqy[(signed long int)3] = fqx[(signed long int)0] + fqx[(signed long int)3] + 3 * (fqx[(signed long int)1] + fqx[(signed long int)2]) + ((2612 * fqy[(signed long int)0] - 9007 * fqy[(signed long int)1]) + 10453 * fqy[(signed long int)2] >> 12);
      filtq = fqy[(signed long int)3];
      composite = filty + (multiq[(signed long int)x] * filti + multiq[(signed long int)(x + 3)] * filtq >> 12);
      composite = (composite * 100 >> 14) + 10;
      if(composite >= 126)
        composite = 125;

      if(!(composite >= 0))
        composite = 0;

      input->signal[(signed long int)((y - y_overscan) + 30)][(signed long int)(x + 135)] = (signed char)composite;
    }
  }
  return 1;
}

// analogtv_make_font
// file analogtv.c line 2209
void analogtv_make_font(struct _XDisplay *dpy, unsigned long int window, struct analogtv_font_s *f, signed int w, signed int h, char *fontname)
{
  signed int i;
  struct anonymous_3 *font;
  unsigned long int text_pm;
  struct _XGC *gc;
  struct anonymous_4 gcv;
  struct anonymous_7 xgwa;
  f->char_w = w;
  f->char_h = h;
  XGetWindowAttributes(dpy, window, &xgwa);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(fontname == ((char *)NULL)))
  {
    return_value_strcmp_2=strcmp(fontname, "6x10");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    text_pm=XCreatePixmapFromBitmapData(dpy, window, (char *)font6x10_bits, (unsigned int)1792, (unsigned int)10, (unsigned long int)1, (unsigned long int)0, (unsigned int)1);
    f->text_im=XGetImage(dpy, text_pm, 0, 0, (unsigned int)1792, (unsigned int)10, (unsigned long int)1, 1);
    XFreePixmap(dpy, text_pm);
  }

  else
    if(!(fontname == ((char *)NULL)))
    {
      font=XLoadQueryFont(dpy, fontname);
      if(font == ((struct anonymous_3 *)NULL))
      {
        fprintf(stderr, "analogtv: can't load font %s\n", fontname);
        abort();
      }

      text_pm=XCreatePixmap(dpy, window, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, (unsigned int)1);
      memset((void *)&gcv, 0, sizeof(struct anonymous_4) /*128ul*/ );
      gcv.foreground = (unsigned long int)1;
      gcv.background = (unsigned long int)0;
      gcv.font = font->fid;
      gc=XCreateGC(dpy, text_pm, (unsigned long int)(1L << 14 | 1L << 3 | 1L << 2), &gcv);
      XSetForeground(dpy, gc, (unsigned long int)0);
      XFillRectangle(dpy, text_pm, gc, 0, 0, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h);
      XSetForeground(dpy, gc, (unsigned long int)1);
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        char c = (char)i;
        signed int x = f->char_w * i + 1;
        signed int y = (f->char_h * 8) / 10;
        XDrawString(dpy, text_pm, gc, x, y, &c, 1);
      }
      f->text_im=XGetImage(dpy, text_pm, 0, 0, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, (unsigned long int)1, 1);
      XFreeGC(dpy, gc);
      XFreePixmap(dpy, text_pm);
    }

    else
    {
      f->text_im=XCreateImage(dpy, xgwa.visual, (unsigned int)1, 1, 0, ((char *)NULL), (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, 8, 0);
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)f->text_im->height, (unsigned long int)f->text_im->bytes_per_line);
      f->text_im->data = (char *)return_value_calloc_1;
    }
  f->x_mult = 4;
  f->y_mult = 2;
}

// analogtv_ntsc_to_yiq
// file analogtv.c line 776
static void analogtv_ntsc_to_yiq(const struct analogtv_s *it, signed int lineno, const float *signal, signed int start, signed int end, struct analogtv_yiq_s *it_yiq)
{
  signed int i;
  const float *sp;
  signed int phasecorr = (signed int)(signal - it->rx_signal & (signed long int)3);
  struct analogtv_yiq_s *yiq;
  signed int colormode;
  float agclevel = it->agclevel;
  float brightadd = (float)((double)it->brightness_control * 100.0 - (double)10);
  float delay[787l];
  float *dp;
  float multiq2[4l];
  double cb_i = (it->line_cb_phase[(signed long int)lineno][(signed long int)(2 + phasecorr & 3)] - it->line_cb_phase[(signed long int)lineno][(signed long int)(0 + phasecorr & 3)]) / 16.0;
  double cb_q = (it->line_cb_phase[(signed long int)lineno][(signed long int)(3 + phasecorr & 3)] - it->line_cb_phase[(signed long int)lineno][(signed long int)(1 + phasecorr & 3)]) / 16.0;
  colormode = (signed int)(cb_i * cb_i + cb_q * cb_q > 2.8);
  if(!(colormode == 0))
  {
    multiq2[(signed long int)0] = (float)((cb_i * (double)it->tint_i - cb_q * (double)it->tint_q) * (double)it->color_control);
    multiq2[(signed long int)1] = (float)((cb_q * (double)it->tint_i + cb_i * (double)it->tint_q) * (double)it->color_control);
    multiq2[(signed long int)2] = -multiq2[(signed long int)0];
    multiq2[(signed long int)3] = -multiq2[(signed long int)1];
  }

  dp = (delay + (signed long int)755) - (signed long int)32;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    dp[(signed long int)i] = 0.0f;
  /* assertion start>=0 */
  assert(start >= 0);
  /* assertion end < ANALOGTV_PIC_LEN+10 */
  assert(end < 755 + 10);
  dp = (delay + (signed long int)755) - (signed long int)32;
  i = 0;
  for( ; !(i >= 24); i = i + 1)
    dp[(signed long int)i] = (float)0.0;
  i = start;
  yiq = it_yiq + (signed long int)start;
  sp = signal + (signed long int)start;
  for( ; !(i >= end); sp = sp + 1l)
  {
    dp[(signed long int)0] = sp[(signed long int)0] * 0.0469904257251935f * agclevel;
    dp[(signed long int)8] = ((+1.0f * (dp[(signed long int)6] + dp[(signed long int)0]) + 4.0f * (dp[(signed long int)5] + dp[(signed long int)1]) + 7.0f * (dp[(signed long int)4] + dp[(signed long int)2]) + 8.0f * dp[(signed long int)3]) - 0.0176648f * dp[(signed long int)12]) - 0.4860288f * dp[(signed long int)10];
    yiq->y = dp[(signed long int)8] + brightadd;
    i = i + 1;
    dp = dp - 1l;
    yiq = yiq + 1l;
  }
  if(!(colormode == 0))
  {
    dp = (delay + (signed long int)755) - (signed long int)32;
    i = 0;
    for( ; !(i >= 27); i = i + 1)
      dp[(signed long int)i] = (float)0.0;
    i = start;
    yiq = it_yiq + (signed long int)start;
    sp = signal + (signed long int)start;
    for( ; !(i >= end); sp = sp + 1l)
    {
      float sig = *sp;
      dp[(signed long int)0] = sig * multiq2[(signed long int)(i & 3)] * 0.0833333333333f;
      dp[(signed long int)8] = (dp[(signed long int)5] + dp[(signed long int)0] + 3.0f * (dp[(signed long int)4] + dp[(signed long int)1]) + 4.0f * (dp[(signed long int)3] + dp[(signed long int)2])) - 0.3333333333f * dp[(signed long int)10];
      yiq->i = dp[(signed long int)8];
      dp[(signed long int)16] = sig * multiq2[(signed long int)(i + 3 & 3)] * 0.0833333333333f;
      dp[(signed long int)24] = (dp[(signed long int)(16 + 5)] + dp[(signed long int)(16 + 0)] + 3.0f * (dp[(signed long int)(16 + 4)] + dp[(signed long int)(16 + 1)]) + 4.0f * (dp[(signed long int)(16 + 3)] + dp[(signed long int)(16 + 2)])) - 0.3333333333f * dp[(signed long int)(24 + 2)];
      yiq->q = dp[(signed long int)24];
      i = i + 1;
      dp = dp - 1l;
      yiq = yiq + 1l;
    }
  }

  else
  {
    i = start;
    yiq = it_yiq + (signed long int)start;
    for( ; !(i >= end); yiq = yiq + 1l)
    {
      yiq->q = 0.0f;
      yiq->i = yiq->q;
      i = i + 1;
    }
  }
}

// analogtv_reception_update
// file analogtv.h line 255
void analogtv_reception_update(struct analogtv_reception_s *rec)
{
  signed int i;
  if(rec->multipath > 0.0)
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      double tmp_statement_expression_1;
      double analogtv_reception_update__1__1__1__1__tmp;
      unsigned int return_value_ya_random_2;
      return_value_ya_random_2=ya_random();
      analogtv_reception_update__1__1__1__1__tmp = ((double)return_value_ya_random_2 * (double)0.02) / (double)(unsigned int)~0;
      tmp_statement_expression_1 = analogtv_reception_update__1__1__1__1__tmp < (double)0 ? -analogtv_reception_update__1__1__1__1__tmp : analogtv_reception_update__1__1__1__1__tmp;
      rec->ghostfir2[(signed long int)i] = rec->ghostfir2[(signed long int)i] + -(rec->ghostfir2[(signed long int)i] / 16.0) + rec->multipath * (tmp_statement_expression_1 - 0.01);
    }
    unsigned int return_value_ya_random_6;
    return_value_ya_random_6=ya_random();
    if(return_value_ya_random_6 % 20u == 0u)
    {
      unsigned int return_value_ya_random_3;
      return_value_ya_random_3=ya_random();
      double tmp_statement_expression_4;
      double tmp;
      unsigned int return_value_ya_random_5;
      return_value_ya_random_5=ya_random();
      tmp = ((double)return_value_ya_random_5 * (double)0.08) / (double)(unsigned int)~0;
      tmp_statement_expression_4 = tmp < (double)0 ? -tmp : tmp;
      rec->ghostfir2[(signed long int)(return_value_ya_random_3 % (unsigned int)4)] = rec->multipath * (tmp_statement_expression_4 - 0.04);
    }

    i = 0;
    for( ; !(i >= 4); i = i + 1)
      rec->ghostfir[(signed long int)i] = 0.8 * rec->ghostfir[(signed long int)i] + 0.2 * rec->ghostfir2[(signed long int)i];
  }

  else
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      rec->ghostfir[(signed long int)i] = i >= 4 / 2 ? ((i & 1) != 0 ? +0.04 : -0.08) / (double)4 : 0.0;
  }
}

// analogtv_reconfigure
// file analogtv.h line 243
void analogtv_reconfigure(struct analogtv_s *it)
{
  XGetWindowAttributes(it->dpy, it->window, &it->xgwa);
  analogtv_configure(it);
}

// analogtv_release
// file analogtv.h line 246
void analogtv_release(struct analogtv_s *it)
{
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    if(!(it->use_shm == 0))
      destroy_xshm_image(it->dpy, it->image, &it->shm_info);

    else
    {
      free((void *)it->image->data);
      it->image->data = (char *)(void *)0;
      it->image->f.destroy_image(it->image);
    }
    it->image = (struct _XImage *)(void *)0;
  }

  if(!(it->gc == ((struct _XGC *)NULL)))
    XFreeGC(it->dpy, it->gc);

  it->gc = (struct _XGC *)(void *)0;
  if(!(it->n_colors == 0))
    XFreeColors(it->dpy, it->colormap, it->colors, it->n_colors, (unsigned long int)0L);

  it->n_colors = 0;
  threadpool_destroy(&it->threads);
  free((void *)it->rx_signal);
  free((void *)it->signal_subtotals);
  free((void *)it);
}

// analogtv_set_defaults
// file analogtv.h line 245
void analogtv_set_defaults(struct analogtv_s *it, char *prefix)
{
  char buf[256l];
  sprintf(buf, "%sTVTint", prefix);
  double return_value_get_float_resource_1;
  return_value_get_float_resource_1=get_float_resource(it->dpy, buf, "TVTint");
  it->tint_control = (float)return_value_get_float_resource_1;
  sprintf(buf, "%sTVColor", prefix);
  double return_value_get_float_resource_2;
  return_value_get_float_resource_2=get_float_resource(it->dpy, buf, "TVColor");
  it->color_control = (float)(return_value_get_float_resource_2 / 100.0);
  sprintf(buf, "%sTVBrightness", prefix);
  double return_value_get_float_resource_3;
  return_value_get_float_resource_3=get_float_resource(it->dpy, buf, "TVBrightness");
  it->brightness_control = (float)(return_value_get_float_resource_3 / 100.0);
  sprintf(buf, "%sTVContrast", prefix);
  double return_value_get_float_resource_4;
  return_value_get_float_resource_4=get_float_resource(it->dpy, buf, "TVContrast");
  it->contrast_control = (float)(return_value_get_float_resource_4 / 100.0);
  it->height_control = (float)1.0;
  it->width_control = (float)1.0;
  it->squish_control = (float)0.0;
  it->powerup = (float)1000.0;
  it->hashnoise_rpm = (double)0;
  it->hashnoise_on = 0;
  it->hashnoise_enable = 1;
  double tmp_statement_expression_5;
  double tmp;
  unsigned int return_value_ya_random_6;
  return_value_ya_random_6=ya_random();
  tmp = ((double)return_value_ya_random_6 * (double)10.0) / (double)(unsigned int)~0;
  tmp_statement_expression_5 = tmp < (double)0 ? -tmp : tmp;
  it->horiz_desync = (float)(tmp_statement_expression_5 - 5.0);
  double tmp_statement_expression_7;
  double analogtv_set_defaults__1__2__tmp;
  unsigned int return_value_ya_random_8;
  return_value_ya_random_8=ya_random();
  analogtv_set_defaults__1__2__tmp = ((double)return_value_ya_random_8 * (double)5.0) / (double)(unsigned int)~0;
  tmp_statement_expression_7 = analogtv_set_defaults__1__2__tmp < (double)0 ? -analogtv_set_defaults__1__2__tmp : analogtv_set_defaults__1__2__tmp;
  it->squeezebottom = (float)(tmp_statement_expression_7 - 1.0);
}

// analogtv_set_demod
// file analogtv.c line 647
signed int analogtv_set_demod(struct analogtv_s *it)
{
  signed int y_levels = 10;
  signed int i_levels = 5;
  signed int q_levels = 5;

cmap_again:
  ;
  signed int yli;
  signed int qli;
  signed int ili;
  double interpy;
  double interpi;
  double interpq;
  double levelmult;
  signed int r;
  signed int g;
  signed int b;
  struct anonymous_9 col;
  signed int return_value_XAllocColor_1;
  while((_Bool)1)
  {
    if(it->use_cmap == 0)
      goto __CPROVER_DUMP_L20;

    if(!(it->n_colors == 0))
      goto __CPROVER_DUMP_L20;

    if(!(it->n_colors == 0))
    {
      XFreeColors(it->dpy, it->colormap, it->colors, it->n_colors, (unsigned long int)0L);
      it->n_colors = 0;
    }

    yli = 0;

  __CPROVER_DUMP_L3:
    ;
    if(yli >= y_levels)
      goto __CPROVER_DUMP_L19;

    ili = 0;

  __CPROVER_DUMP_L4:
    ;
    if(ili >= i_levels)
      goto __CPROVER_DUMP_L18;

    qli = 0;

  __CPROVER_DUMP_L5:
    ;
    if(qli >= q_levels)
      goto __CPROVER_DUMP_L17;

    levelmult = 700.0;
    interpy = 100.0 * ((double)yli / (double)y_levels);
    interpi = 50.0 * (((double)ili - 0.5 * (double)i_levels) / (double)i_levels);
    interpq = 50.0 * (((double)qli - 0.5 * (double)q_levels) / (double)q_levels);
    r = (signed int)((interpy + 1.04 * interpi + 0.624 * interpq) * levelmult);
    g = (signed int)(((interpy - 0.276 * interpi) - 0.639 * interpq) * levelmult);
    b = (signed int)(((interpy - 1.105 * interpi) + 1.729 * interpq) * levelmult);
    if(!(r >= 0))
      r = 0;

    if(r >= 65536)
      r = 65535;

    if(!(g >= 0))
      g = 0;

    if(g >= 65536)
      g = 65535;

    if(!(b >= 0))
      b = 0;

    if(b >= 65536)
      b = 65535;

    col.red = (unsigned short int)r;
    col.green = (unsigned short int)g;
    col.blue = (unsigned short int)b;
    col.pixel = (unsigned long int)0;
    return_value_XAllocColor_1=XAllocColor(it->dpy, it->colormap, &col);
    if(!(return_value_XAllocColor_1 == 0))
      break;

    if(!((4 * y_levels) / 12 >= q_levels))
      q_levels = q_levels - 1;

    else
      if(!((5 * y_levels) / 12 >= i_levels))
        i_levels = i_levels - 1;

      else
        y_levels = y_levels - 1;
    if(!(y_levels >= 2))
      return -1;

  }
  signed int tmp_post_2 = it->n_colors;
  it->n_colors = it->n_colors + 1;
  it->colors[(signed long int)tmp_post_2] = col.pixel;
  qli = qli + 1;
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L17:
  ;
  ili = ili + 1;
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L18:
  ;
  yli = yli + 1;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L19:
  ;
  it->cmap_y_levels = y_levels;
  it->cmap_i_levels = i_levels;
  it->cmap_q_levels = q_levels;

__CPROVER_DUMP_L20:
  ;
  return 0;
}

// analogtv_setup_frame
// file analogtv.c line 911
void analogtv_setup_frame(struct analogtv_s *it)
{
  it->redraw_all = 0;
  if(!(it->flutter_horiz_desync == 0))
  {
    unsigned int return_value_ya_random_1;
    return_value_ya_random_1=ya_random();
    unsigned int return_value_ya_random_2;
    return_value_ya_random_2=ya_random();
    unsigned int return_value_ya_random_3;
    return_value_ya_random_3=ya_random();
    it->horiz_desync = it->horiz_desync + (float)(-0.10 * ((double)it->horiz_desync - 3.0) + (double)(((signed int)(return_value_ya_random_1 & (unsigned int)0xff) - 0x80) * ((signed int)(return_value_ya_random_2 & (unsigned int)0xff) - 0x80) * ((signed int)(return_value_ya_random_3 & (unsigned int)0xff) - 0x80)) * 0.000001);
  }

  if(!(it->hashnoise_enable == 0))
  {
    if(it->hashnoise_on == 0)
    {
      unsigned int return_value_ya_random_5;
      return_value_ya_random_5=ya_random();
      if(return_value_ya_random_5 % 10000u == 0u)
      {
        it->hashnoise_on = 1;
        unsigned int return_value_ya_random_4;
        return_value_ya_random_4=ya_random();
        it->shrinkpulse = (signed int)(return_value_ya_random_4 % (unsigned int)262);
      }

    }

  }

  unsigned int return_value_ya_random_6;
  return_value_ya_random_6=ya_random();
  if(return_value_ya_random_6 % 1000u == 0u)
    it->hashnoise_on = 0;

  if(IEEE_FLOAT_NOTEQUAL(it->rx_signal_level, 0.0))
    it->agclevel = (float)(1.0 / it->rx_signal_level);

}

// analogtv_setup_levels
// file analogtv.c line 1154
static void analogtv_setup_levels(struct analogtv_s *it, double avgheight)
{
  signed int i;
  signed int height = 0;
  for( ; (double)height < avgheight + 2.0 && !(height >= 13); height = height + 1)
  {
    i = 0;
    for( ; !(i >= height); i = i + 1)
      it->leveltable[(signed long int)height][(signed long int)i].index = 2;
    if(avgheight >= 3.000000)
      it->leveltable[(signed long int)height][(signed long int)0].index = 0;

    if(avgheight >= 5.000000)
    {
      if(height >= 1)
        it->leveltable[(signed long int)height][(signed long int)(height - 1)].index = 0;

    }

    if(avgheight >= 7.000000)
    {
      it->leveltable[(signed long int)height][(signed long int)1].index = 1;
      if(height >= 2)
        it->leveltable[(signed long int)height][(signed long int)(height - 2)].index = 1;

    }

    i = 0;
    for( ; !(i >= height); i = i + 1)
    {
      float return_value_puramp_1;
      return_value_puramp_1=puramp(it, (float)3.0, (float)6.0, (float)1.0);
      static const double levelfac[3l] = { -7.5, 5.5, 24.5 };
      it->leveltable[(signed long int)height][(signed long int)i].value = (40.0 + levelfac[(signed long int)it->leveltable[(signed long int)height][(signed long int)i].index] * (double)return_value_puramp_1) / 256.0;
    }
  }
}

// analogtv_setup_sync
// file analogtv.h line 249
void analogtv_setup_sync(struct analogtv_input_s *input, signed int do_cb, signed int do_ssavi)
{
  signed int i;
  signed int lineno;
  signed int vsync;
  signed char *sig;
  signed int synclevel = do_ssavi != 0 ? 100 : -40;
  lineno = 0;
  for( ; !(lineno >= 262); lineno = lineno + 1)
  {
    vsync = (signed int)(lineno >= 3 && lineno < 7);
    sig = input->signal[(signed long int)lineno];
    i = 0;
    if(!(vsync == 0))
    {
      while(!(i >= 67))
      {
        signed int tmp_post_1 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_1] = (signed char)0;
      }
      while(!(i >= 912))
      {
        signed int tmp_post_2 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_2] = (signed char)synclevel;
      }
    }

    else
    {
      while(!(i >= 67))
      {
        signed int tmp_post_3 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_3] = (signed char)synclevel;
      }
      while(!(i >= 135))
      {
        signed int tmp_post_4 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_4] = (signed char)0;
      }
      while(!(i >= 890))
      {
        signed int tmp_post_5 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_5] = (signed char)10;
      }
    }
    while(!(i >= 912))
    {
      signed int tmp_post_6 = i;
      i = i + 1;
      sig[(signed long int)tmp_post_6] = (signed char)0;
    }
    if(!(do_cb == 0))
    {
      i = 83;
      for( ; !(i >= 36); i = i + 4)
      {
        sig[(signed long int)(i + 1)] = sig[(signed long int)(i + 1)] + (signed char)20;
        sig[(signed long int)(i + 3)] = sig[(signed long int)(i + 3)] - (signed char)20;
      }
    }

  }
}

// analogtv_setup_teletext
// file analogtv.c line 892
void analogtv_setup_teletext(struct analogtv_input_s *input)
{
  signed int x;
  signed int y;
  signed int teletext = 10;
  y = 19;
  for( ; !(y >= 22); y = y + 1)
  {
    x = 135;
    for( ; !(x >= 890); x = x + 1)
    {
      if((7 & x) == 0)
      {
        unsigned int return_value_ya_random_1;
        return_value_ya_random_1=ya_random();
        teletext = (return_value_ya_random_1 & (unsigned int)1) != 0u ? 100 : 10;
      }

      input->signal[(signed long int)y][(signed long int)x] = (signed char)teletext;
    }
  }
}

// analogtv_sync
// file analogtv.c line 1028
static void analogtv_sync(struct analogtv_s *it)
{
  signed int cur_hsync = it->cur_hsync;
  signed int cur_vsync = it->cur_vsync;
  signed int lineno = 0;
  signed int i;
  signed int j;
  float osc;
  float filt;
  float *sp;
  float cbfc = 1.0f / 128.0f;
  i = -32;
  for( ; !(i >= 32); i = i + 1)
  {
    lineno = (cur_vsync + i + 262) % 262;
    sp = it->rx_signal + (signed long int)(lineno * 912);
    filt = 0.0f;
    j = 0;
    for( ; !(j >= 912); j = j + 912 / 16)
      filt = filt + sp[(signed long int)j];
    filt = filt * it->agclevel;
    osc = (float)(262 + i) / (float)262;
    if(osc >= 1.05f + 0.0002f * filt)
      break;

  }
  cur_vsync = (cur_vsync + i + 262) % 262;
  lineno = 0;
  for( ; !(lineno >= 262); lineno = lineno + 1)
  {
    if(lineno >= 6 && !(lineno >= 259))
    {
      unsigned int lineno2 = (unsigned int)((lineno + cur_vsync + 262) % 262);
      if(lineno2 == 0u)
        lineno2 = (unsigned int)262;

      sp = it->rx_signal + (signed long int)(lineno2 * (unsigned int)912) + (signed long int)cur_hsync;
      i = -8;
      for( ; !(i >= 8); i = i + 1)
      {
        osc = (float)(912 + i) / (float)912;
        filt = (sp[(signed long int)(i - 3)] + sp[(signed long int)(i - 2)] + sp[(signed long int)(i - 1)] + sp[(signed long int)i]) * it->agclevel;
        if(osc >= 1.005f + 0.0001f * filt)
          break;

      }
      cur_hsync = (cur_hsync + i + 912) % 912;
    }

    it->line_hsync[(signed long int)lineno] = (cur_hsync + 135 + 912) % 912;
    if(lineno >= 16)
    {
      sp = it->rx_signal + (signed long int)(lineno * 912) + (signed long int)(cur_hsync & ~3);
      i = 83 + 8;
      for( ; !(i >= 36); i = i + 1)
        it->cb_phase[(signed long int)(i & 3)] = it->cb_phase[(signed long int)(i & 3)] * (double)(1.0f - cbfc) + (double)(sp[(signed long int)i] * it->agclevel * cbfc);
    }

    float tot = 0.1f;
    float cbgain;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      tot = tot + (float)(it->cb_phase[(signed long int)i] * it->cb_phase[(signed long int)i]);
    float return_value_sqrtf_1;
    return_value_sqrtf_1=sqrtf(tot);
    cbgain = 32.0f / return_value_sqrtf_1;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      it->line_cb_phase[(signed long int)lineno][(signed long int)i] = it->cb_phase[(signed long int)i] * (double)cbgain;
  }
  it->cur_hsync = cur_hsync;
  it->cur_vsync = cur_vsync;
}

// analogtv_thread_add_signals
// file analogtv.c line 1323
static void analogtv_thread_add_signals(void *thread_raw)
{
  const struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  const struct analogtv_s *it = thread->it;
  unsigned int i;
  unsigned int j;
  unsigned int subtotal_end;
  unsigned int start = (unsigned int)thread->signal_start;
  while(!((unsigned long int)start == thread->signal_end))
  {
    float *p;
    unsigned int end = start + (unsigned int)2048;
    if(!(thread->signal_end >= (unsigned long int)end))
      end = (unsigned int)thread->signal_end;

    analogtv_init_signal(it, it->noiselevel, start, end);
    i = (unsigned int)0;
    for( ; !(i == it->rec_count); i = i + 1u)
    {
      signed int tmp_if_expr_1;
      if(i == 0u)
        tmp_if_expr_1 = it->channel_change_cycles;

      else
        tmp_if_expr_1 = 0;
      analogtv_add_signal(it, it->recs[(signed long int)i], start, end, tmp_if_expr_1);
    }
    /* assertion !(start % 32) */
    assert(!(start % (unsigned int)32 != 0u));
    /* assertion !(end % 32) */
    assert(!(end % (unsigned int)32 != 0u));
    p = it->rx_signal + (signed long int)start;
    subtotal_end = end / (unsigned int)32;
    i = start / (unsigned int)32;
    for( ; !(i == subtotal_end); i = i + 1u)
    {
      float sum = p[(signed long int)0];
      j = (unsigned int)1;
      for( ; !(j == 32u); j = j + 1u)
        sum = sum + p[(signed long int)j];
      it->signal_subtotals[(signed long int)i] = sum;
      p = p + (signed long int)32;
    }
    start = end;
  }
}

// analogtv_thread_create
// file analogtv.c line 440
static signed int analogtv_thread_create(void *thread_raw, struct threadpool *threads, unsigned int thread_id)
{
  struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  unsigned int align;
  thread->it = (struct analogtv_s *)((char *)threads - (signed long int)160ul);
  thread->thread_id = thread_id;
  unsigned int return_value_thread_memory_alignment_1;
  return_value_thread_memory_alignment_1=thread_memory_alignment(thread->it->dpy);
  align = (unsigned int)((unsigned long int)return_value_thread_memory_alignment_1 / sizeof(float) /*4ul*/ );
  if(align == 0u)
    align = (unsigned int)1;

  align = ~(align * (unsigned int)32 - (unsigned int)1);
  thread->signal_start = (unsigned long int)(((unsigned int)238944 * thread_id) / threads->count & align);
  unsigned int tmp_if_expr_2;
  if(1u + thread_id == threads->count)
    tmp_if_expr_2 = (unsigned int)238944;

  else
    tmp_if_expr_2 = ((unsigned int)238944 * (thread_id + (unsigned int)1)) / threads->count & align;
  thread->signal_end = (unsigned long int)tmp_if_expr_2;
  return 0;
}

// analogtv_thread_destroy
// file analogtv.c line 463
static void analogtv_thread_destroy(void *thread_raw)
{
  ;
}

// analogtv_thread_draw_lines
// file analogtv.c line 1519
static void analogtv_thread_draw_lines(void *thread_raw)
{
  const struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  const struct analogtv_s *it = thread->it;
  signed int lineno;
  float *raw_rgb_start;
  float *raw_rgb_end;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(it->subwidth * 3), sizeof(float) /*4ul*/ );
  raw_rgb_start = (float *)return_value_calloc_1;
  if(!(raw_rgb_start == ((float *)NULL)))
  {
    raw_rgb_end = raw_rgb_start + (signed long int)(3 * it->subwidth);
    lineno = (signed int)((unsigned int)30 + thread->thread_id);
    for( ; !(lineno >= 230); lineno = lineno + (signed int)it->threads.count)
    {
      signed int i;
      signed int j;
      signed int x;
      signed int y;
      signed int slineno;
      signed int ytop;
      signed int ybot;
      unsigned int signal_offset;
      const float *signal;
      signed int scanstart_i;
      signed int scanend_i;
      signed int squishright_i;
      signed int squishdiv;
      signed int pixrate;
      float *rgb_start;
      float *rgb_end;
      float pixbright;
      signed int pixmultinc;
      float *rrp;
      struct analogtv_yiq_s yiq[765l];
      signed int return_value_analogtv_get_line_2;
      return_value_analogtv_get_line_2=analogtv_get_line(it, lineno, &slineno, &ytop, &ybot, &signal_offset);
      if(!(return_value_analogtv_get_line_2 == 0))
      {
        signal = it->rx_signal + (signed long int)signal_offset;
        float bloomthisrow;
        float shiftthisrow;
        float viswidth;
        float middle;
        float scanwidth;
        signed int scw;
        signed int scl;
        signed int scr;
        bloomthisrow = -10.0f * it->crtload[(signed long int)lineno];
        if(bloomthisrow < -10.000000f)
          bloomthisrow = -10.0f;

        if(bloomthisrow > 2.0f)
          bloomthisrow = 2.0f;

        if(!(slineno >= 16))
        {
          float return_value_expf_3;
          return_value_expf_3=expf(-0.17f * (float)slineno);
          float return_value_cosf_4;
          return_value_cosf_4=cosf((float)slineno * 0.6f);
          shiftthisrow = it->horiz_desync * return_value_expf_3 * (0.7f + return_value_cosf_4);
        }

        else
          shiftthisrow = 0.0f;
        viswidth = (float)755 * 0.79f - 5.0f * bloomthisrow;
        middle = (float)(755 / 2) - shiftthisrow;
        float return_value_puramp_5;
        return_value_puramp_5=puramp(it, 0.5f, 0.3f, 1.0f);
        scanwidth = it->width_control * return_value_puramp_5;
        scw = (signed int)((float)it->subwidth * scanwidth);
        if(!(it->subwidth >= scw))
          scw = it->usewidth;

        scl = it->subwidth / 2 - scw / 2;
        scr = it->subwidth / 2 + scw / 2;
        pixrate = (signed int)((float)(signed int)((viswidth * 65536.0f * 1.0f) / (float)it->subwidth) / scanwidth);
        scanstart_i = (signed int)((middle - viswidth * 0.5f) * 65536.0f);
        scanend_i = (755 - 1) * 65536;
        float return_value_puramp_6;
        return_value_puramp_6=puramp(it, 2.0f, 0.0f, 1.1f);
        squishright_i = (signed int)((middle + viswidth * ((0.25f + 0.25f * return_value_puramp_6) - it->squish_control)) * 65536.0f);
        squishdiv = it->subwidth / 15;
        rgb_start = raw_rgb_start + (signed long int)(scl * 3);
        rgb_end = raw_rgb_start + (signed long int)(scr * 3);
        /* assertion scanstart_i>=0 */
        assert(scanstart_i >= 0);
        if(!(it->use_cmap == 0))
        {
          y = ytop;
          for( ; !(y >= ybot); y = y + 1)
          {
            signed int level;
            level=analogtv_level(it, y, ytop, ybot);
            float levelmult;
            double return_value_analogtv_levelmult_7;
            return_value_analogtv_levelmult_7=analogtv_levelmult(it, level);
            levelmult = (float)return_value_analogtv_levelmult_7;
            float levelmult_y;
            float return_value_puramp_8;
            return_value_puramp_8=puramp(it, 1.0f, 0.0f, 1.0f);
            levelmult_y = ((levelmult * it->contrast_control * return_value_puramp_8) / (0.5f + 0.5f * it->puheight)) * 0.070f;
            float levelmult_iq = levelmult * 0.090f;
            analogtv_ntsc_to_yiq(it, lineno, signal, (scanstart_i >> 16) - 10, (scanend_i >> 16) + 10, yiq);
            pixmultinc = pixrate;
            x = 0;
            i = scanstart_i;
            if(!(i >= 0))
            {
              if(!(x >= it->usewidth))
              {
                it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)0]);
                i = i + pixmultinc;
                x = x + 1;
              }

            }

            while(!(i >= scanend_i))
            {
              if(x >= it->usewidth)
                break;

              float analogtv_thread_draw_lines__1__1__2__1__2__pixfrac = (float)(i & 0xffff) / 65536.0f;
              float invpixfrac = 1.0f - analogtv_thread_draw_lines__1__1__2__1__2__pixfrac;
              signed int pati = i >> 16;
              signed int yli;
              signed int ili;
              signed int qli;
              signed int cmi;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpy = (yiq[(signed long int)pati].y * invpixfrac + yiq[(signed long int)(pati + 1)].y * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_y;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpi = (yiq[(signed long int)pati].i * invpixfrac + yiq[(signed long int)(pati + 1)].i * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_iq;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpq = (yiq[(signed long int)pati].q * invpixfrac + yiq[(signed long int)(pati + 1)].q * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_iq;
              yli = (signed int)(analogtv_thread_draw_lines__1__1__2__1__2__interpy * (float)it->cmap_y_levels);
              ili = (signed int)((analogtv_thread_draw_lines__1__1__2__1__2__interpi + 0.5f) * (float)it->cmap_i_levels);
              qli = (signed int)((analogtv_thread_draw_lines__1__1__2__1__2__interpq + 0.5f) * (float)it->cmap_q_levels);
              if(!(yli >= 0))
                yli = 0;

              if(yli >= it->cmap_y_levels)
                yli = it->cmap_y_levels - 1;

              if(!(ili >= 0))
                ili = 0;

              if(ili >= it->cmap_i_levels)
                ili = it->cmap_i_levels - 1;

              if(!(qli >= 0))
                qli = 0;

              if(qli >= it->cmap_q_levels)
                qli = it->cmap_q_levels - 1;

              cmi = qli + it->cmap_i_levels * (ili + it->cmap_q_levels * yli);
              j = 0;
              if(!(j >= it->xrepl))
              {
                it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)cmi]);
                x = x + 1;
                j = j + 1;
              }

              if(i >= squishright_i)
                pixmultinc = pixmultinc + pixmultinc / squishdiv;

              i = i + pixmultinc;
            }
            if(!(x >= it->usewidth))
            {
              it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)0]);
              x = x + 1;
            }

          }
        }

        else
        {
          analogtv_ntsc_to_yiq(it, lineno, signal, (scanstart_i >> 16) - 10, (scanend_i >> 16) + 10, yiq);
          float return_value_puramp_9;
          return_value_puramp_9=puramp(it, 1.0f, 0.0f, 1.0f);
          pixbright = (((it->contrast_control * return_value_puramp_9) / (0.5f + 0.5f * it->puheight)) * 1024.0f) / 100.0f;
          pixmultinc = pixrate;
          i = scanstart_i;
          rrp = rgb_start;
          for( ; !(rrp == rgb_end) && !(i >= 0); rrp = rrp + (signed long int)3)
          {
            rrp[(signed long int)2] = (float)0;
            rrp[(signed long int)1] = rrp[(signed long int)2];
            rrp[(signed long int)0] = rrp[(signed long int)1];
            i = i + pixmultinc;
          }
          while(!(rrp == rgb_end) && !(i >= scanend_i))
          {
            float pixfrac = (float)(i & 0xffff) / 65536.0f;
            float analogtv_thread_draw_lines__1__1__3__2__invpixfrac = 1.0f - pixfrac;
            signed int analogtv_thread_draw_lines__1__1__3__2__pati = i >> 16;
            float r;
            float g;
            float b;
            float interpy = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].y * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].y * pixfrac;
            float interpi = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].i * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].i * pixfrac;
            float interpq = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].q * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].q * pixfrac;
            r = (interpy + 0.948f * interpi + 0.624f * interpq) * pixbright;
            g = ((interpy - 0.276f * interpi) - 0.639f * interpq) * pixbright;
            b = ((interpy - 1.105f * interpi) + 1.729f * interpq) * pixbright;
            if(r < 0.0f)
              r = 0.0f;

            if(g < 0.0f)
              g = 0.0f;

            if(b < 0.0f)
              b = 0.0f;

            rrp[(signed long int)0] = r;
            rrp[(signed long int)1] = g;
            rrp[(signed long int)2] = b;
            if(i >= squishright_i)
            {
              pixmultinc = pixmultinc + pixmultinc / squishdiv;
              pixbright = pixbright + (pixbright / (float)squishdiv) / (float)2;
            }

            i = i + pixmultinc;
            rrp = rrp + (signed long int)3;
          }
          for( ; !(rrp == rgb_end); rrp = rrp + (signed long int)3)
          {
            rrp[(signed long int)2] = 0.0f;
            rrp[(signed long int)1] = rrp[(signed long int)2];
            rrp[(signed long int)0] = rrp[(signed long int)1];
          }
          analogtv_blast_imagerow(it, raw_rgb_start, raw_rgb_end, ytop, ybot);
        }
      }

    }
    free((void *)raw_rgb_start);
  }

}

// apply
// file asm6502.c line 1196
static unsigned char apply(struct AsmLine *listp, unsigned char (*fn)(struct AsmLine *, void *), void *arg)
{
  struct AsmLine *p;
  unsigned char return_value;
  if(listp == ((struct AsmLine *)NULL))
    return (unsigned char)0;

  else
  {
    p = listp;
    if(!(p == ((struct AsmLine *)NULL)))
    {
      return_value=fn(p, arg);
      if(return_value == 0)
        return (unsigned char)0;

      p = p->next;
    }

    return (unsigned char)1;
  }
}

// assignOpCodes
// file asm6502.c line 1005
static void assignOpCodes(struct anonymous_61 *opcodes)
{
  (opcodes + (signed long int)0)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)0)->name, "ADC", (unsigned long int)3);
  (opcodes + (signed long int)0)->Imm = (unsigned char)0x69;
  (opcodes + (signed long int)0)->ZP = (unsigned char)0x65;
  (opcodes + (signed long int)0)->ZPX = (unsigned char)0x75;
  (opcodes + (signed long int)0)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)0)->ABS = (unsigned char)0x6d;
  (opcodes + (signed long int)0)->ABSX = (unsigned char)0x7d;
  (opcodes + (signed long int)0)->ABSY = (unsigned char)0x79;
  (opcodes + (signed long int)0)->INDX = (unsigned char)0x61;
  (opcodes + (signed long int)0)->INDY = (unsigned char)0x71;
  (opcodes + (signed long int)0)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)0)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)0)->func = jmpADC;
  (opcodes + (signed long int)1)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)1)->name, "AND", (unsigned long int)3);
  (opcodes + (signed long int)1)->Imm = (unsigned char)0x29;
  (opcodes + (signed long int)1)->ZP = (unsigned char)0x25;
  (opcodes + (signed long int)1)->ZPX = (unsigned char)0x35;
  (opcodes + (signed long int)1)->ZPY = (unsigned char)0x31;
  (opcodes + (signed long int)1)->ABS = (unsigned char)0x2d;
  (opcodes + (signed long int)1)->ABSX = (unsigned char)0x3d;
  (opcodes + (signed long int)1)->ABSY = (unsigned char)0x39;
  (opcodes + (signed long int)1)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)1)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)1)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)1)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)1)->func = jmpAND;
  (opcodes + (signed long int)2)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)2)->name, "ASL", (unsigned long int)3);
  (opcodes + (signed long int)2)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)2)->ZP = (unsigned char)0x06;
  (opcodes + (signed long int)2)->ZPX = (unsigned char)0x16;
  (opcodes + (signed long int)2)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)2)->ABS = (unsigned char)0x0e;
  (opcodes + (signed long int)2)->ABSX = (unsigned char)0x1e;
  (opcodes + (signed long int)2)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)2)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)2)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)2)->SNGL = (unsigned char)0x0a;
  (opcodes + (signed long int)2)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)2)->func = jmpASL;
  (opcodes + (signed long int)3)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)3)->name, "BIT", (unsigned long int)3);
  (opcodes + (signed long int)3)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)3)->ZP = (unsigned char)0x24;
  (opcodes + (signed long int)3)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)3)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)3)->ABS = (unsigned char)0x2c;
  (opcodes + (signed long int)3)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)3)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)3)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)3)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)3)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)3)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)3)->func = jmpBIT;
  (opcodes + (signed long int)4)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)4)->name, "BPL", (unsigned long int)3);
  (opcodes + (signed long int)4)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)4)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)4)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)4)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)4)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)4)->BRA = (unsigned char)0x10;
  (opcodes + (signed long int)4)->func = jmpBPL;
  (opcodes + (signed long int)5)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)5)->name, "BMI", (unsigned long int)3);
  (opcodes + (signed long int)5)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)5)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)5)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)5)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)5)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)5)->BRA = (unsigned char)0x30;
  (opcodes + (signed long int)5)->func = jmpBMI;
  (opcodes + (signed long int)6)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)6)->name, "BVC", (unsigned long int)3);
  (opcodes + (signed long int)6)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)6)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)6)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)6)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)6)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)6)->BRA = (unsigned char)0x50;
  (opcodes + (signed long int)6)->func = jmpBVC;
  (opcodes + (signed long int)7)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)7)->name, "BVS", (unsigned long int)3);
  (opcodes + (signed long int)7)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)7)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)7)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)7)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)7)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)7)->BRA = (unsigned char)0x70;
  (opcodes + (signed long int)7)->func = jmpBVS;
  (opcodes + (signed long int)8)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)8)->name, "BCC", (unsigned long int)3);
  (opcodes + (signed long int)8)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)8)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)8)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)8)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)8)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)8)->BRA = (unsigned char)0x90;
  (opcodes + (signed long int)8)->func = jmpBCC;
  (opcodes + (signed long int)9)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)9)->name, "BCS", (unsigned long int)3);
  (opcodes + (signed long int)9)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)9)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)9)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)9)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)9)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)9)->BRA = (unsigned char)0xb0;
  (opcodes + (signed long int)9)->func = jmpBCS;
  (opcodes + (signed long int)10)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)10)->name, "BNE", (unsigned long int)3);
  (opcodes + (signed long int)10)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)10)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)10)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)10)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)10)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)10)->BRA = (unsigned char)0xd0;
  (opcodes + (signed long int)10)->func = jmpBNE;
  (opcodes + (signed long int)11)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)11)->name, "BEQ", (unsigned long int)3);
  (opcodes + (signed long int)11)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)11)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)11)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)11)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)11)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)11)->BRA = (unsigned char)0xf0;
  (opcodes + (signed long int)11)->func = jmpBEQ;
  (opcodes + (signed long int)12)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)12)->name, "CMP", (unsigned long int)3);
  (opcodes + (signed long int)12)->Imm = (unsigned char)0xc9;
  (opcodes + (signed long int)12)->ZP = (unsigned char)0xc5;
  (opcodes + (signed long int)12)->ZPX = (unsigned char)0xd5;
  (opcodes + (signed long int)12)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)12)->ABS = (unsigned char)0xcd;
  (opcodes + (signed long int)12)->ABSX = (unsigned char)0xdd;
  (opcodes + (signed long int)12)->ABSY = (unsigned char)0xd9;
  (opcodes + (signed long int)12)->INDX = (unsigned char)0xc1;
  (opcodes + (signed long int)12)->INDY = (unsigned char)0xd1;
  (opcodes + (signed long int)12)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)12)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)12)->func = jmpCMP;
  (opcodes + (signed long int)13)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)13)->name, "CPX", (unsigned long int)3);
  (opcodes + (signed long int)13)->Imm = (unsigned char)0xe0;
  (opcodes + (signed long int)13)->ZP = (unsigned char)0xe4;
  (opcodes + (signed long int)13)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)13)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)13)->ABS = (unsigned char)0xec;
  (opcodes + (signed long int)13)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)13)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)13)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)13)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)13)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)13)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)13)->func = jmpCPX;
  (opcodes + (signed long int)14)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)14)->name, "CPY", (unsigned long int)3);
  (opcodes + (signed long int)14)->Imm = (unsigned char)0xc0;
  (opcodes + (signed long int)14)->ZP = (unsigned char)0xc4;
  (opcodes + (signed long int)14)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)14)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)14)->ABS = (unsigned char)0xcc;
  (opcodes + (signed long int)14)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)14)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)14)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)14)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)14)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)14)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)14)->func = jmpCPY;
  (opcodes + (signed long int)15)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)15)->name, "DEC", (unsigned long int)3);
  (opcodes + (signed long int)15)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)15)->ZP = (unsigned char)0xc6;
  (opcodes + (signed long int)15)->ZPX = (unsigned char)0xd6;
  (opcodes + (signed long int)15)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)15)->ABS = (unsigned char)0xce;
  (opcodes + (signed long int)15)->ABSX = (unsigned char)0xde;
  (opcodes + (signed long int)15)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)15)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)15)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)15)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)15)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)15)->func = jmpDEC;
  (opcodes + (signed long int)16)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)16)->name, "EOR", (unsigned long int)3);
  (opcodes + (signed long int)16)->Imm = (unsigned char)0x49;
  (opcodes + (signed long int)16)->ZP = (unsigned char)0x45;
  (opcodes + (signed long int)16)->ZPX = (unsigned char)0x55;
  (opcodes + (signed long int)16)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)16)->ABS = (unsigned char)0x4d;
  (opcodes + (signed long int)16)->ABSX = (unsigned char)0x5d;
  (opcodes + (signed long int)16)->ABSY = (unsigned char)0x59;
  (opcodes + (signed long int)16)->INDX = (unsigned char)0x41;
  (opcodes + (signed long int)16)->INDY = (unsigned char)0x51;
  (opcodes + (signed long int)16)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)16)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)16)->func = jmpEOR;
  (opcodes + (signed long int)17)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)17)->name, "CLC", (unsigned long int)3);
  (opcodes + (signed long int)17)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)17)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)17)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)17)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)17)->SNGL = (unsigned char)0x18;
  (opcodes + (signed long int)17)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)17)->func = jmpCLC;
  (opcodes + (signed long int)18)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)18)->name, "SEC", (unsigned long int)3);
  (opcodes + (signed long int)18)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)18)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)18)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)18)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)18)->SNGL = (unsigned char)0x38;
  (opcodes + (signed long int)18)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)18)->func = jmpSEC;
  (opcodes + (signed long int)19)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)19)->name, "CLI", (unsigned long int)3);
  (opcodes + (signed long int)19)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)19)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)19)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)19)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)19)->SNGL = (unsigned char)0x58;
  (opcodes + (signed long int)19)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)19)->func = jmpCLI;
  (opcodes + (signed long int)20)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)20)->name, "SEI", (unsigned long int)3);
  (opcodes + (signed long int)20)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)20)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)20)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)20)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)20)->SNGL = (unsigned char)0x78;
  (opcodes + (signed long int)20)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)20)->func = jmpSEI;
  (opcodes + (signed long int)21)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)21)->name, "CLV", (unsigned long int)3);
  (opcodes + (signed long int)21)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)21)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)21)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)21)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)21)->SNGL = (unsigned char)0xb8;
  (opcodes + (signed long int)21)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)21)->func = jmpCLV;
  (opcodes + (signed long int)22)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)22)->name, "CLD", (unsigned long int)3);
  (opcodes + (signed long int)22)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)22)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)22)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)22)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)22)->SNGL = (unsigned char)0xd8;
  (opcodes + (signed long int)22)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)22)->func = jmpCLD;
  (opcodes + (signed long int)23)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)23)->name, "SED", (unsigned long int)3);
  (opcodes + (signed long int)23)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)23)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)23)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)23)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)23)->SNGL = (unsigned char)0xf8;
  (opcodes + (signed long int)23)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)23)->func = jmpSED;
  (opcodes + (signed long int)24)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)24)->name, "INC", (unsigned long int)3);
  (opcodes + (signed long int)24)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)24)->ZP = (unsigned char)0xe6;
  (opcodes + (signed long int)24)->ZPX = (unsigned char)0xf6;
  (opcodes + (signed long int)24)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)24)->ABS = (unsigned char)0xee;
  (opcodes + (signed long int)24)->ABSX = (unsigned char)0xfe;
  (opcodes + (signed long int)24)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)24)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)24)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)24)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)24)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)24)->func = jmpINC;
  (opcodes + (signed long int)25)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)25)->name, "JMP", (unsigned long int)3);
  (opcodes + (signed long int)25)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)25)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)25)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)25)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)25)->ABS = (unsigned char)0x4c;
  (opcodes + (signed long int)25)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)25)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)25)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)25)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)25)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)25)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)25)->func = jmpJMP;
  (opcodes + (signed long int)26)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)26)->name, "JSR", (unsigned long int)3);
  (opcodes + (signed long int)26)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)26)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)26)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)26)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)26)->ABS = (unsigned char)0x20;
  (opcodes + (signed long int)26)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)26)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)26)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)26)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)26)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)26)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)26)->func = jmpJSR;
  (opcodes + (signed long int)27)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)27)->name, "LDA", (unsigned long int)3);
  (opcodes + (signed long int)27)->Imm = (unsigned char)0xa9;
  (opcodes + (signed long int)27)->ZP = (unsigned char)0xa5;
  (opcodes + (signed long int)27)->ZPX = (unsigned char)0xb5;
  (opcodes + (signed long int)27)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)27)->ABS = (unsigned char)0xad;
  (opcodes + (signed long int)27)->ABSX = (unsigned char)0xbd;
  (opcodes + (signed long int)27)->ABSY = (unsigned char)0xb9;
  (opcodes + (signed long int)27)->INDX = (unsigned char)0xa1;
  (opcodes + (signed long int)27)->INDY = (unsigned char)0xb1;
  (opcodes + (signed long int)27)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)27)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)27)->func = jmpLDA;
  (opcodes + (signed long int)28)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)28)->name, "LDX", (unsigned long int)3);
  (opcodes + (signed long int)28)->Imm = (unsigned char)0xa2;
  (opcodes + (signed long int)28)->ZP = (unsigned char)0xa6;
  (opcodes + (signed long int)28)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)28)->ZPY = (unsigned char)0xb6;
  (opcodes + (signed long int)28)->ABS = (unsigned char)0xae;
  (opcodes + (signed long int)28)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)28)->ABSY = (unsigned char)0xbe;
  (opcodes + (signed long int)28)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)28)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)28)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)28)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)28)->func = jmpLDX;
  (opcodes + (signed long int)29)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)29)->name, "LDY", (unsigned long int)3);
  (opcodes + (signed long int)29)->Imm = (unsigned char)0xa0;
  (opcodes + (signed long int)29)->ZP = (unsigned char)0xa4;
  (opcodes + (signed long int)29)->ZPX = (unsigned char)0xb4;
  (opcodes + (signed long int)29)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)29)->ABS = (unsigned char)0xac;
  (opcodes + (signed long int)29)->ABSX = (unsigned char)0xbc;
  (opcodes + (signed long int)29)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)29)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)29)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)29)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)29)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)29)->func = jmpLDY;
  (opcodes + (signed long int)30)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)30)->name, "LSR", (unsigned long int)3);
  (opcodes + (signed long int)30)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)30)->ZP = (unsigned char)0x46;
  (opcodes + (signed long int)30)->ZPX = (unsigned char)0x56;
  (opcodes + (signed long int)30)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)30)->ABS = (unsigned char)0x4e;
  (opcodes + (signed long int)30)->ABSX = (unsigned char)0x5e;
  (opcodes + (signed long int)30)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)30)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)30)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)30)->SNGL = (unsigned char)0x4a;
  (opcodes + (signed long int)30)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)30)->func = jmpLSR;
  (opcodes + (signed long int)31)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)31)->name, "NOP", (unsigned long int)3);
  (opcodes + (signed long int)31)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)31)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)31)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)31)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)31)->SNGL = (unsigned char)0xea;
  (opcodes + (signed long int)31)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)31)->func = jmpNOP;
  (opcodes + (signed long int)32)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)32)->name, "ORA", (unsigned long int)3);
  (opcodes + (signed long int)32)->Imm = (unsigned char)0x09;
  (opcodes + (signed long int)32)->ZP = (unsigned char)0x05;
  (opcodes + (signed long int)32)->ZPX = (unsigned char)0x15;
  (opcodes + (signed long int)32)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)32)->ABS = (unsigned char)0x0d;
  (opcodes + (signed long int)32)->ABSX = (unsigned char)0x1d;
  (opcodes + (signed long int)32)->ABSY = (unsigned char)0x19;
  (opcodes + (signed long int)32)->INDX = (unsigned char)0x01;
  (opcodes + (signed long int)32)->INDY = (unsigned char)0x11;
  (opcodes + (signed long int)32)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)32)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)32)->func = jmpORA;
  (opcodes + (signed long int)33)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)33)->name, "TAX", (unsigned long int)3);
  (opcodes + (signed long int)33)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)33)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)33)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)33)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)33)->SNGL = (unsigned char)0xaa;
  (opcodes + (signed long int)33)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)33)->func = jmpTAX;
  (opcodes + (signed long int)34)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)34)->name, "TXA", (unsigned long int)3);
  (opcodes + (signed long int)34)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)34)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)34)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)34)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)34)->SNGL = (unsigned char)0x8a;
  (opcodes + (signed long int)34)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)34)->func = jmpTXA;
  (opcodes + (signed long int)35)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)35)->name, "DEX", (unsigned long int)3);
  (opcodes + (signed long int)35)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)35)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)35)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)35)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)35)->SNGL = (unsigned char)0xca;
  (opcodes + (signed long int)35)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)35)->func = jmpDEX;
  (opcodes + (signed long int)36)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)36)->name, "INX", (unsigned long int)3);
  (opcodes + (signed long int)36)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)36)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)36)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)36)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)36)->SNGL = (unsigned char)0xe8;
  (opcodes + (signed long int)36)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)36)->func = jmpINX;
  (opcodes + (signed long int)37)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)37)->name, "TAY", (unsigned long int)3);
  (opcodes + (signed long int)37)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)37)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)37)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)37)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)37)->SNGL = (unsigned char)0xa8;
  (opcodes + (signed long int)37)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)37)->func = jmpTAY;
  (opcodes + (signed long int)38)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)38)->name, "TYA", (unsigned long int)3);
  (opcodes + (signed long int)38)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)38)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)38)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)38)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)38)->SNGL = (unsigned char)0x98;
  (opcodes + (signed long int)38)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)38)->func = jmpTYA;
  (opcodes + (signed long int)39)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)39)->name, "DEY", (unsigned long int)3);
  (opcodes + (signed long int)39)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)39)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)39)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)39)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)39)->SNGL = (unsigned char)0x88;
  (opcodes + (signed long int)39)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)39)->func = jmpDEY;
  (opcodes + (signed long int)40)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)40)->name, "INY", (unsigned long int)3);
  (opcodes + (signed long int)40)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)40)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)40)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)40)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)40)->SNGL = (unsigned char)0xc8;
  (opcodes + (signed long int)40)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)40)->func = jmpINY;
  (opcodes + (signed long int)41)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)41)->name, "ROR", (unsigned long int)3);
  (opcodes + (signed long int)41)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)41)->ZP = (unsigned char)0x66;
  (opcodes + (signed long int)41)->ZPX = (unsigned char)0x76;
  (opcodes + (signed long int)41)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)41)->ABS = (unsigned char)0x6e;
  (opcodes + (signed long int)41)->ABSX = (unsigned char)0x7e;
  (opcodes + (signed long int)41)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)41)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)41)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)41)->SNGL = (unsigned char)0x6a;
  (opcodes + (signed long int)41)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)41)->func = jmpROR;
  (opcodes + (signed long int)42)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)42)->name, "ROL", (unsigned long int)3);
  (opcodes + (signed long int)42)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)42)->ZP = (unsigned char)0x26;
  (opcodes + (signed long int)42)->ZPX = (unsigned char)0x36;
  (opcodes + (signed long int)42)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)42)->ABS = (unsigned char)0x2e;
  (opcodes + (signed long int)42)->ABSX = (unsigned char)0x3e;
  (opcodes + (signed long int)42)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)42)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)42)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)42)->SNGL = (unsigned char)0x2a;
  (opcodes + (signed long int)42)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)42)->func = jmpROL;
  (opcodes + (signed long int)43)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)43)->name, "RTI", (unsigned long int)3);
  (opcodes + (signed long int)43)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)43)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)43)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)43)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)43)->SNGL = (unsigned char)0x40;
  (opcodes + (signed long int)43)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)43)->func = jmpRTI;
  (opcodes + (signed long int)44)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)44)->name, "RTS", (unsigned long int)3);
  (opcodes + (signed long int)44)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)44)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)44)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)44)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)44)->SNGL = (unsigned char)0x60;
  (opcodes + (signed long int)44)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)44)->func = jmpRTS;
  (opcodes + (signed long int)45)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)45)->name, "SBC", (unsigned long int)3);
  (opcodes + (signed long int)45)->Imm = (unsigned char)0xe9;
  (opcodes + (signed long int)45)->ZP = (unsigned char)0xe5;
  (opcodes + (signed long int)45)->ZPX = (unsigned char)0xf5;
  (opcodes + (signed long int)45)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)45)->ABS = (unsigned char)0xed;
  (opcodes + (signed long int)45)->ABSX = (unsigned char)0xfd;
  (opcodes + (signed long int)45)->ABSY = (unsigned char)0xf9;
  (opcodes + (signed long int)45)->INDX = (unsigned char)0xe1;
  (opcodes + (signed long int)45)->INDY = (unsigned char)0xf1;
  (opcodes + (signed long int)45)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)45)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)45)->func = jmpSBC;
  (opcodes + (signed long int)46)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)46)->name, "STA", (unsigned long int)3);
  (opcodes + (signed long int)46)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)46)->ZP = (unsigned char)0x85;
  (opcodes + (signed long int)46)->ZPX = (unsigned char)0x95;
  (opcodes + (signed long int)46)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)46)->ABS = (unsigned char)0x8d;
  (opcodes + (signed long int)46)->ABSX = (unsigned char)0x9d;
  (opcodes + (signed long int)46)->ABSY = (unsigned char)0x99;
  (opcodes + (signed long int)46)->INDX = (unsigned char)0x81;
  (opcodes + (signed long int)46)->INDY = (unsigned char)0x91;
  (opcodes + (signed long int)46)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)46)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)46)->func = jmpSTA;
  (opcodes + (signed long int)47)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)47)->name, "TXS", (unsigned long int)3);
  (opcodes + (signed long int)47)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)47)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)47)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)47)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)47)->SNGL = (unsigned char)0x9a;
  (opcodes + (signed long int)47)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)47)->func = jmpTXS;
  (opcodes + (signed long int)48)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)48)->name, "TSX", (unsigned long int)3);
  (opcodes + (signed long int)48)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)48)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)48)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)48)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)48)->SNGL = (unsigned char)0xba;
  (opcodes + (signed long int)48)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)48)->func = jmpTSX;
  (opcodes + (signed long int)49)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)49)->name, "PHA", (unsigned long int)3);
  (opcodes + (signed long int)49)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)49)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)49)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)49)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)49)->SNGL = (unsigned char)0x48;
  (opcodes + (signed long int)49)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)49)->func = jmpPHA;
  (opcodes + (signed long int)50)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)50)->name, "PLA", (unsigned long int)3);
  (opcodes + (signed long int)50)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)50)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)50)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)50)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)50)->SNGL = (unsigned char)0x68;
  (opcodes + (signed long int)50)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)50)->func = jmpPLA;
  (opcodes + (signed long int)51)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)51)->name, "PHP", (unsigned long int)3);
  (opcodes + (signed long int)51)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)51)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)51)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)51)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)51)->SNGL = (unsigned char)0x08;
  (opcodes + (signed long int)51)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)51)->func = jmpPHP;
  (opcodes + (signed long int)52)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)52)->name, "PLP", (unsigned long int)3);
  (opcodes + (signed long int)52)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)52)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)52)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)52)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)52)->SNGL = (unsigned char)0x28;
  (opcodes + (signed long int)52)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)52)->func = jmpPLP;
  (opcodes + (signed long int)53)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)53)->name, "STX", (unsigned long int)3);
  (opcodes + (signed long int)53)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)53)->ZP = (unsigned char)0x86;
  (opcodes + (signed long int)53)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)53)->ZPY = (unsigned char)0x96;
  (opcodes + (signed long int)53)->ABS = (unsigned char)0x8e;
  (opcodes + (signed long int)53)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)53)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)53)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)53)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)53)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)53)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)53)->func = jmpSTX;
  (opcodes + (signed long int)54)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)54)->name, "STY", (unsigned long int)3);
  (opcodes + (signed long int)54)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)54)->ZP = (unsigned char)0x84;
  (opcodes + (signed long int)54)->ZPX = (unsigned char)0x94;
  (opcodes + (signed long int)54)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)54)->ABS = (unsigned char)0x8c;
  (opcodes + (signed long int)54)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)54)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)54)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)54)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)54)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)54)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)54)->func = jmpSTY;
  (opcodes + (signed long int)55)->name[(signed long int)3] = (char)0;
  strncpy((opcodes + (signed long int)55)->name, "---", (unsigned long int)3);
  (opcodes + (signed long int)55)->Imm = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ZP = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ZPX = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ZPY = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ABS = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ABSX = (unsigned char)0x00;
  (opcodes + (signed long int)55)->ABSY = (unsigned char)0x00;
  (opcodes + (signed long int)55)->INDX = (unsigned char)0x00;
  (opcodes + (signed long int)55)->INDY = (unsigned char)0x00;
  (opcodes + (signed long int)55)->SNGL = (unsigned char)0x00;
  (opcodes + (signed long int)55)->BRA = (unsigned char)0x00;
  (opcodes + (signed long int)55)->func = (void (*)(struct machine_6502 *, enum anonymous_60))(void *)0;
}

// bitOff
// file asm6502.c line 243
static unsigned char bitOff(unsigned char value, enum anonymous_18 bit)
{
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(value, bit);
  return (unsigned char)!(return_value_bitOn_1 != 0);
}

// bitOn
// file asm6502.c line 237
static unsigned char bitOn(unsigned char value, enum anonymous_18 bit)
{
  unsigned char mask = (unsigned char)1;
  mask = (unsigned char)((signed int)mask << (signed int)bit);
  return (unsigned char)(((signed int)value & (signed int)mask) > 0);
}

// buildIndexCache
// file asm6502.c line 1074
static void buildIndexCache(struct machine_6502 *machine)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 56u); i = i + 1u)
  {
    if(!((signed int)machine->opcodes[(signed long int)i].Imm == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].Imm].adm = (enum anonymous_60)IMMEDIATE_VALUE;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].Imm].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ZP == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZP].adm = (enum anonymous_60)ZERO;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZP].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ZPX == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZPX].adm = (enum anonymous_60)ZERO_X;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZPX].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ZPY == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZPY].adm = (enum anonymous_60)ZERO_Y;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ZPY].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ABS == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABS].adm = (enum anonymous_60)ABS_VALUE;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABS].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ABSX == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABSX].adm = (enum anonymous_60)ABS_X;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABSX].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].ABSY == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABSY].adm = (enum anonymous_60)ABS_Y;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].ABSY].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].INDX == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].INDX].adm = (enum anonymous_60)INDIRECT_X;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].INDX].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].INDY == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].INDY].adm = (enum anonymous_60)INDIRECT_Y;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].INDY].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].SNGL == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].SNGL].adm = (enum anonymous_60)SINGLE;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].SNGL].index = (unsigned char)i;
    }

    if(!((signed int)machine->opcodes[(signed long int)i].BRA == 0x00))
    {
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].BRA].adm = (enum anonymous_60)ABS_OR_BRANCH;
      machine->opcache[(signed long int)machine->opcodes[(signed long int)i].BRA].index = (unsigned char)i;
    }

  }
}

// changeParamLabelAddr
// file asm6502.c line 2001
static unsigned char changeParamLabelAddr(struct AsmLine *asmline, void *label)
{
  struct anonymous_12 *la = (struct anonymous_12 *)label;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(asmline->param->label, la->label);
  if(return_value_strcmp_1 == 0)
    asmline->param->lbladdr = la->addr;

  return (unsigned char)1;
}

// checkAddress
// file asm6502.c line 123
static void checkAddress(unsigned int address)
{
  if(address >= 65536u)
    fprintf(stderr, "Address %d is beyond 64k", address);

}

// command
// file asm6502.c line 1315
static unsigned char command(struct machine_6502 *machine, char **s, char **cmd)
{
  signed int i = 0;
  skipSpace(s);
  unsigned char return_value_isCmdChar_1;
  do
  {
    return_value_isCmdChar_1=isCmdChar(*(*s));
    if(return_value_isCmdChar_1 == 0 || i >= 4)
      break;

    signed int tmp_post_2 = i;
    i = i + 1;
    (*cmd)[(signed long int)tmp_post_2] = *(*s);
    *s = *s + 1l;
  }
  while((_Bool)1);
  signed int return_value_strcmp_4;
  unsigned char return_value_isCommand_3;
  if(i == 0)
    return (unsigned char)1;

  else
  {
    return_value_strcmp_4=strcmp(*cmd, "*=");
    if(return_value_strcmp_4 == 0)
      return (unsigned char)1;

    else
    {
      return_value_isCommand_3=isCommand(machine, *cmd);
      return return_value_isCommand_3;
    }
  }
}

// comment
// file asm6502.c line 1589
static void comment(char **s)
{
  skipSpace(s);
  _Bool tmp_if_expr_1;
  if((signed int)*(*s) == 59)
    do
    {
      if(!((signed int)*(*s) == 10))
        tmp_if_expr_1 = (signed int)*(*s) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      *s = *s + 1l;
    }
    while((_Bool)1);

}

// compileCode
// file asm6502.c line 2020
static unsigned char compileCode(struct machine_6502 *machine, const char *code)
{
  unsigned char codeOk;
  struct AsmLine *asmlist;
  reset(machine);
  machine->regPC = (unsigned short int)1536;
  machine->defaultCodePC = machine->regPC;
  asmlist=parseAssembly(machine, &codeOk, code);
  if(!(codeOk == 0))
  {
    unsigned char return_value_apply_1;
    return_value_apply_1=apply(asmlist, indexLabels, (void *)machine);
    if(return_value_apply_1 == 0)
      return (unsigned char)0;

    linkLabels(asmlist);
    machine->codeLen = 0;
    machine->defaultCodePC = (unsigned short int)1536;
    unsigned char return_value_apply_2;
    return_value_apply_2=apply(asmlist, compileLine, (void *)machine);
    if(return_value_apply_2 == 0)
      return (unsigned char)0;

    if((signed int)machine->defaultCodePC >= 1537)
    {
      machine->memory[(signed long int)machine->defaultCodePC] = (unsigned char)0x00;
      codeOk = (unsigned char)1;
    }

    else
    {
      fprintf(stderr, "No Code to run.\n");
      codeOk = (unsigned char)0;
    }
  }

  else
  {
    fprintf(stderr, "An error occured while parsing the file.\n");
    codeOk = (unsigned char)0;
  }
  freeallAsmLine(asmlist);
  return codeOk;
}

// compileLine
// file asm6502.c line 1939
static unsigned char compileLine(struct AsmLine *asmline, void *args)
{
  struct machine_6502 *machine = (struct machine_6502 *)args;
  unsigned char return_value_isBlank_1;
  return_value_isBlank_1=isBlank(asmline->command);
  signed int return_value_strcmp_4;
  unsigned char return_value_translate_3;
  if(!(return_value_isBlank_1 == 0))
    return (unsigned char)1;

  else
  {
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp("*=", asmline->command);
    if(return_value_strcmp_5 == 0)
      machine->defaultCodePC = (unsigned short int)asmline->param->value[(signed long int)0];

    else
    {
      return_value_strcmp_4=strcmp("DCB", asmline->command);
      if(return_value_strcmp_4 == 0)
      {
        signed int i = 0;
        for( ; !((unsigned int)i >= asmline->param->vp); i = i + 1)
          pushByte(machine, asmline->param->value[(signed long int)i]);
      }

      else
      {
        signed int compileLine__1__3__i;
        char *compileLine__1__3__command = asmline->command;
        struct anonymous_61 op;
        compileLine__1__3__i = 0;
        for( ; !(compileLine__1__3__i >= 56); compileLine__1__3__i = compileLine__1__3__i + 1)
        {
          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(machine->opcodes[(signed long int)compileLine__1__3__i].name, compileLine__1__3__command);
          if(return_value_strcmp_2 == 0)
          {
            op = machine->opcodes[(signed long int)compileLine__1__3__i];
            break;
          }

        }
        if(compileLine__1__3__i == 56)
          return (unsigned char)0;

        else
        {
          return_value_translate_3=translate(&op, asmline->param, machine);
          return return_value_translate_3;
        }
      }
    }
    return (unsigned char)1;
  }
}

// copyParam
// file asm6502.c line 1151
static void copyParam(struct anonymous_8 *p1, struct anonymous_8 *p2)
{
  signed int i = 0;
  strncpy(p1->label, p2->label, (unsigned long int)80);
  i = 0;
  for( ; !(i >= 25); i = i + 1)
    p1->value[(signed long int)i] = p2->value[(signed long int)i];
  p1->vp = p2->vp;
  p1->type = p2->type;
}

// create_xshm_image
// file ./../utils/xshm.h line 27
extern struct _XImage * create_xshm_image(struct _XDisplay *dpy, struct anonymous_13 *visual, unsigned int depth, signed int format, char *data, struct anonymous_14 *shm_info, unsigned int width, unsigned int height)
{
  signed int status;
  struct _XImage *image = ((struct _XImage *)NULL);
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "useSHM", "Boolean");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct _XImage *)NULL);

  else
  {
    signed int return_value_XShmQueryExtension_2;
    return_value_XShmQueryExtension_2=XShmQueryExtension(dpy);
    if(return_value_XShmQueryExtension_2 == 0)
      return ((struct _XImage *)NULL);

    else
    {
      do
      {
        XSync(dpy, 0);
        shm_got_x_error = 0;
        if(!(old_handler == shm_ehandler))
          old_handler=XSetErrorHandler(shm_ehandler);

      }
      while((_Bool)0);
      image=XShmCreateImage(dpy, visual, depth, format, data, shm_info, width, height);
      do
      {
        XSync(dpy, 0);
        if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL)))
          XSetErrorHandler(old_handler);

        old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL);
      }
      while((_Bool)0);
      if(!(shm_got_x_error == 0))
        return ((struct _XImage *)NULL);

      else
      {
        shm_info->shmid=shmget((signed int)0, (unsigned long int)(image->bytes_per_line * image->height), 01000 | 0777);
        if(shm_info->shmid == -1)
        {
          char buf[1024l];
          sprintf(buf, "%s: shmget failed", progname);
          perror(buf);
          image->f.destroy_image(image);
          image = ((struct _XImage *)NULL);
          XSync(dpy, 0);
        }

        else
        {
          shm_info->readOnly = 0;
          void *return_value_shmat_3;
          return_value_shmat_3=shmat(shm_info->shmid, NULL, 0);
          shm_info->shmaddr = (char *)return_value_shmat_3;
          image->data = shm_info->shmaddr;
          do
          {
            XSync(dpy, 0);
            shm_got_x_error = 0;
            if(!(old_handler == shm_ehandler))
              old_handler=XSetErrorHandler(shm_ehandler);

          }
          while((_Bool)0);
          status=XShmAttach(dpy, shm_info);
          do
          {
            XSync(dpy, 0);
            if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL)))
              XSetErrorHandler(old_handler);

            old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL);
          }
          while((_Bool)0);
          if(!(shm_got_x_error == 0))
            status = 0;

          if(status == 0)
          {
            fprintf(stderr, "%s: XShmAttach failed!\n", progname);
            image->f.destroy_image(image);
            XSync(dpy, 0);
            shmdt((const void *)shm_info->shmaddr);
            image = ((struct _XImage *)NULL);
          }

          XSync(dpy, 0);
          shmctl(shm_info->shmid, 0, ((struct shmid_ds *)NULL));
        }
        return image;
      }
    }
  }
}

// dcbValue
// file asm6502.c line 1489
static unsigned char dcbValue(char **s, struct anonymous_8 *param)
{
  unsigned int val;
  unsigned char return_value_parseValue_1;
  return_value_parseValue_1=parseValue(s, &val);
  if(return_value_parseValue_1 == 0)
    return (unsigned char)0;

  else
    if(val >= 256u)
      return (unsigned char)0;

    else
    {
      unsigned char return_value_addvalue_2;
      return_value_addvalue_2=addvalue(param, val);
      if(return_value_addvalue_2 == 0)
        return (unsigned char)0;

      else
      {
        param->type = (enum anonymous_60)DCB_PARAM;
        skipSpace(s);
        if((signed int)*(*s) == 44)
        {
          *s = *s + 1l;
          unsigned char return_value_dcbValue_3;
          return_value_dcbValue_3=dcbValue(s, param);
          return return_value_dcbValue_3;
        }

        else
          return (unsigned char)1;
      }
    }
}

// declareLabel
// file asm6502.c line 1328
static unsigned char declareLabel(char **s, char **label)
{
  signed int i = 0;
  skipSpace(s);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  do
  {
    if(!((signed int)*(*s) == 58))
      tmp_if_expr_1 = (signed int)*(*s) != 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (signed int)*(*s) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    unsigned char return_value_isWhite_3;
    return_value_isWhite_3=isWhite(*(*s));
    if(return_value_isWhite_3 == 0)
    {
      signed int tmp_post_4 = i;
      i = i + 1;
      (*label)[(signed long int)tmp_post_4] = *(*s);
    }

    *s = *s + 1l;
  }
  while((_Bool)1);
  if(i == 0)
    return (unsigned char)0;

  else
    if((signed int)*(*s) == 58)
    {
      *s = *s + 1l;
      return (unsigned char)1;
    }

    else
      return (unsigned char)0;
}

// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_25 *screen, struct anonymous_13 *visual, signed int private_cmap_p)
{
  char n[10l];
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_19 *)NULL))
    abort();

  if(!(private_cmap_p == 0))
    sprintf(n, "%3d", vi_out->colormap_size);

  else
    strcpy(n, "default");
  char *tmp_if_expr_5;
  char *tmp_if_expr_4;
  char *tmp_if_expr_3;
  char *tmp_if_expr_2;
  char *tmp_if_expr_1;
  if(vi_out->class == 0)
    tmp_if_expr_5 = "StaticGray, ";

  else
  {
    if(vi_out->class == 2)
      tmp_if_expr_4 = "StaticColor,";

    else
    {
      if(vi_out->class == 4)
        tmp_if_expr_3 = "TrueColor,  ";

      else
      {
        if(vi_out->class == 1)
          tmp_if_expr_2 = "GrayScale,  ";

        else
        {
          if(vi_out->class == 3)
            tmp_if_expr_1 = "PseudoColor,";

          else
            tmp_if_expr_1 = vi_out->class == 5 ? "DirectColor," : "UNKNOWN:    ";
          tmp_if_expr_2 = tmp_if_expr_1;
        }
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    tmp_if_expr_5 = tmp_if_expr_4;
  }
  fprintf(f, "0x%02x (%s depth: %2d, cmap: %s)\n", (unsigned int)vi_out->visualid, tmp_if_expr_5, vi_out->depth, (const void *)n);
  XFree((void *)(char *)vi_out);
}

// destroy_xshm_image
// file ./../utils/xshm.h line 32
extern void destroy_xshm_image(struct _XDisplay *dpy, struct _XImage *image, struct anonymous_14 *shm_info)
{
  signed int status;
  do
  {
    XSync(dpy, 0);
    shm_got_x_error = 0;
    if(!(old_handler == shm_ehandler))
      old_handler=XSetErrorHandler(shm_ehandler);

  }
  while((_Bool)0);
  status=XShmDetach(dpy, shm_info);
  do
  {
    XSync(dpy, 0);
    if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL)))
      XSetErrorHandler(old_handler);

    old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_56 *))NULL);
  }
  while((_Bool)0);
  if(!(shm_got_x_error == 0))
    status = 0;

  if(status == 0)
    fprintf(stderr, "%s: XShmDetach failed!\n", progname);

  image->f.destroy_image(image);
  XSync(dpy, 0);
  status=shmdt((const void *)shm_info->shmaddr);
  if(!(status == 0))
  {
    char buf[1024l];
    sprintf(buf, "%s: shmdt(0x%lx) failed", progname, (unsigned long int)shm_info->shmaddr);
    perror(buf);
  }

  XSync(dpy, 0);
}

// doCompare
// file asm6502.c line 626
static void doCompare(struct machine_6502 *machine, unsigned short int reg, struct anonymous_15 *ptr)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)((signed int)reg + (signed int)ptr->value > 0xff));
  manZeroNeg(machine, (unsigned char)((signed int)reg - (signed int)ptr->value));
}

// ecalloc
// file asm6502.c line 109
static void * ecalloc(unsigned int nelm, unsigned long int nsize)
{
  void *p;
  p=calloc((unsigned long int)nelm, nsize);
  if(p == NULL)
    abort();

  return p;
}

// estrdup
// file asm6502.c line 116
static char * estrdup(const char *source)
{
  signed int ln;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(source);
  ln = (signed int)(return_value_strlen_1 + (unsigned long int)1);
  char *s;
  void *return_value_ecalloc_2;
  return_value_ecalloc_2=ecalloc((unsigned int)ln, sizeof(char) /*1ul*/ );
  s = (char *)return_value_ecalloc_2;
  strncpy(s, source, (unsigned long int)ln);
  return s;
}

// execute
// file asm6502.c line 2081
static void execute(struct machine_6502 *machine)
{
  unsigned char opcode;
  enum anonymous_60 adm;
  signed int opidx;
  if(!(machine->codeRunning == 0))
  {
    opcode=popByte(machine);
    if((signed int)opcode == 0x00)
      machine->codeRunning = (unsigned char)0;

    else
    {
      opidx=opIndex(machine, opcode, &adm);
      if(opidx >= 0)
        machine->opcodes[(signed long int)opidx].func(machine, adm);

      else
        fprintf(stderr, "Invalid opcode!\n");
    }
    _Bool tmp_if_expr_1;
    if((signed int)machine->regPC == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(machine->codeRunning != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      machine->codeRunning = (unsigned char)0;

  }

}

// fileToBuffer
// file asm6502.c line 1677
static char * fileToBuffer(const char *filename)
{
  const signed int defaultSize = 1024;
  struct _IO_FILE *ifp;
  signed int c;
  signed int size = defaultSize;
  signed int i = 0;
  char *buffer;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)defaultSize, sizeof(char) /*1ul*/ );
  buffer = (char *)return_value_ecalloc_1;
  if(buffer == ((char *)NULL))
    abort();

  ifp=fopen(filename, "rb");
  if(ifp == ((struct _IO_FILE *)NULL))
    abort();

  do
  {
    c=_IO_getc(ifp);
    if(c == -1)
      break;

    signed int tmp_post_2 = i;
    i = i + 1;
    buffer[(signed long int)tmp_post_2] = (char)c;
    if(i == size)
    {
      size = size + defaultSize;
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)buffer, (unsigned long int)size);
      buffer = (char *)return_value_realloc_3;
      if(buffer == ((char *)NULL))
        abort();

    }

  }
  while((_Bool)1);
  fclose(ifp);
  void *return_value_realloc_4;
  return_value_realloc_4=realloc((void *)buffer, (unsigned long int)(i + 2));
  buffer = (char *)return_value_realloc_4;
  if(buffer == ((char *)NULL))
    abort();

  buffer[(signed long int)i] = (char)10;
  buffer[(signed long int)(i + 1)] = (char)0;
  return buffer;
}

// find_similar_visual
// file visual.c line 503
extern struct anonymous_13 * find_similar_visual(struct anonymous_25 *screen, struct anonymous_13 *old_visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  struct anonymous_13 *result = ((struct anonymous_13 *)NULL);
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.class=visual_class(screen, old_visual);
  vi_in.depth=visual_depth(screen, old_visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8 | 0x4), &vi_in, &out_count);
  if(out_count >= 1 && !(vi_out == ((struct anonymous_19 *)NULL)))
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_19 *)NULL)))
    XFree((void *)vi_out);

  vi_out = ((struct anonymous_19 *)NULL);
  if(result == ((struct anonymous_13 *)NULL))
  {
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8), &vi_in, &out_count);
    if(out_count >= 1 && !(vi_out == ((struct anonymous_19 *)NULL)))
      result = (vi_out + (signed long int)0)->visual;

    if(!(vi_out == ((struct anonymous_19 *)NULL)))
      XFree((void *)vi_out);

    vi_out = ((struct anonymous_19 *)NULL);
  }

  if(result == ((struct anonymous_13 *)NULL))
    result = screen->root_visual;

  return result;
}

// fix_fds
// file screenhack.c line 403
static void fix_fds(void)
{
  signed int fd0;
  fd0=open("/dev/null", 02);
  signed int fd1;
  fd1=open("/dev/null", 02);
  signed int fd2;
  fd2=open("/dev/null", 02);
  if(fd0 >= 3)
    close(fd0);

  if(fd1 >= 3)
    close(fd1);

  if(fd2 >= 3)
    close(fd2);

}

// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth)
{
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(st == ((struct fps_state *)NULL))
    return (double)0;

  else
  {
    signed int tmp_post_1 = st->frame_count;
    st->frame_count = st->frame_count + 1;
    if(tmp_post_1 >= st->last_ifps)
    {
      struct timezone tzp;
      gettimeofday(&st->this_frame_end, &tzp);
      if(st->prev_frame_end.tv_sec == 0l)
        st->prev_frame_end = st->this_frame_end;

    }

    if(!(st->this_frame_end.tv_sec == st->prev_frame_end.tv_sec))
    {
      double uprev_frame_end = (double)st->prev_frame_end.tv_sec + (double)st->prev_frame_end.tv_usec * 0.000001;
      double uthis_frame_end = (double)st->this_frame_end.tv_sec + (double)st->this_frame_end.tv_usec * 0.000001;
      double fps = (double)st->frame_count / (uthis_frame_end - uprev_frame_end);
      double idle = ((double)st->slept * 0.000001) / (uthis_frame_end - uprev_frame_end);
      double load = (double)100 * ((double)1 - idle);
      if(load < 0.000000)
        load = (double)0;

      st->prev_frame_end = st->this_frame_end;
      st->frame_count = 0;
      st->slept = (unsigned long int)0;
      st->last_ifps = (signed int)fps;
      st->last_fps = fps;
      sprintf(st->string, polys != 0ul ? "FPS:   %.1f \nLoad:  %.1f%% " : "FPS:  %.1f \nLoad: %.1f%% ", fps, load);
      if(polys >= 1ul)
      {
        const char *s = "";
        strcat(st->string, "\nPolys: ");
        if(polys >= 1000000ul)
        {
          return_value_strlen_2=strlen(st->string);
          sprintf(st->string + (signed long int)return_value_strlen_2, "%lu,%03lu,%03lu%s ", polys / (unsigned long int)1000000, (polys / (unsigned long int)1000) % (unsigned long int)1000, polys % (unsigned long int)1000, s);
        }

        else
          if(polys >= 1000ul)
          {
            return_value_strlen_3=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_3, "%lu,%03lu%s ", polys / (unsigned long int)1000, polys % (unsigned long int)1000, s);
          }

          else
          {
            return_value_strlen_4=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_4, "%lu%s ", polys, s);
          }
      }

      if(depth >= 0.0)
      {
        unsigned long int L;
        L=strlen(st->string);
        char *fps_compute__1__2__2__s = st->string + (signed long int)L;
        strcat(fps_compute__1__2__2__s, "\nDepth: ");
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(fps_compute__1__2__2__s);
        sprintf(fps_compute__1__2__2__s + (signed long int)return_value_strlen_5, "%.1f", depth);
        L=strlen(fps_compute__1__2__2__s);
        if((signed int)fps_compute__1__2__2__s[-2l + (signed long int)L] == 46)
        {
          if((signed int)fps_compute__1__2__2__s[-1l + (signed long int)L] == 48)
            fps_compute__1__2__2__s[(signed long int)(L - (unsigned long int)2)] = (char)0;

        }

      }

    }

    return st->last_fps;
  }
}

// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st)
{
  struct anonymous_7 xgwa;
  const char *string = st->string;
  const char *s;
  signed int x = st->x;
  signed int y = st->y;
  signed int lines = 1;
  signed int lh = st->font->ascent + st->font->descent;
  XGetWindowAttributes(st->dpy, st->window, &xgwa);
  s = string;
  for( ; !(*s == 0); s = s + 1l)
    if((signed int)*s == 10)
      lines = lines + 1;

  if(!(y >= 0))
    y = -y + (lines - 1) * lh;

  else
    y = xgwa.height - y;
  y = y - (lh * (lines - 1) + st->font->descent);
  if(!(st->clear_p == 0))
  {
    signed int w;
    signed int h;
    w=string_width(st->font, string, &h);
    XFillRectangle(st->dpy, st->window, st->erase_gc, x - st->font->descent, y - lh, (unsigned int)(w + 2 * st->font->descent), (unsigned int)(h + 2 * st->font->descent));
  }

  unsigned long int return_value_strlen_1;
  while(!(lines == 0))
  {
    s=strchr(string, 10);
    if(s == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(string);
      s = string + (signed long int)return_value_strlen_1;
    }

    XDrawString(st->dpy, st->window, st->draw_gc, x, y, string, (signed int)(s - string));
    string = s;
    string = string + 1l;
    lines = lines - 1;
    y = y + lh;
  }
}

// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st)
{
  if(!(st->draw_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->draw_gc);

  if(!(st->erase_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->erase_gc);

  if(!(st->font == ((struct anonymous_3 *)NULL)))
    XFreeFont(st->dpy, st->font);

  free((void *)st);
}

// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct fps_state *st;
  const char *font;
  struct anonymous_3 *f;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "doFPS", "DoFPS");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct fps_state *)NULL);

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct fps_state) /*1152ul*/ );
    st = (struct fps_state *)return_value_calloc_2;
    st->dpy = dpy;
    st->window = window;
    st->clear_p=get_boolean_resource(dpy, "fpsSolid", "FPSSolid");
    font=get_string_resource(dpy, "fpsFont", "Font");
    if(font == ((const char *)NULL))
      font = "-*-courier-bold-r-normal-*-180-*";

    f=XLoadQueryFont(dpy, font);
    if(f == ((struct anonymous_3 *)NULL))
      f=XLoadQueryFont(dpy, "fixed");

    struct anonymous_7 xgwa;
    struct anonymous_4 gcv;
    XGetWindowAttributes(dpy, window, &xgwa);
    gcv.font = f->fid;
    unsigned int return_value_get_pixel_resource_3;
    return_value_get_pixel_resource_3=get_pixel_resource(st->dpy, xgwa.colormap, "foreground", "Foreground");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_3;
    st->draw_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    unsigned int return_value_get_pixel_resource_4;
    return_value_get_pixel_resource_4=get_pixel_resource(st->dpy, xgwa.colormap, "background", "Background");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_4;
    st->erase_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    st->font = f;
    st->x = 10;
    st->y = 10;
    signed int return_value_get_boolean_resource_5;
    return_value_get_boolean_resource_5=get_boolean_resource(dpy, "fpsTop", "FPSTop");
    if(!(return_value_get_boolean_resource_5 == 0))
      st->y = -(st->font->ascent + st->font->descent + 10);

    strcpy(st->string, "FPS: ... ");
    return st;
  }
}

// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs)
{
  st->slept = st->slept + usecs;
}

// freeLabel
// file asm6502.c line 1212
static void freeLabel(struct anonymous_12 *label)
{
  free((void *)label->label);
  free((void *)label);
}

// freeParam
// file asm6502.c line 1207
static void freeParam(struct anonymous_8 *param)
{
  free((void *)param->label);
  free((void *)param);
}

// freeallAsmLine
// file asm6502.c line 1217
static void freeallAsmLine(struct AsmLine *listp)
{
  struct AsmLine *next;
  for( ; !(listp == ((struct AsmLine *)NULL)); listp = next)
  {
    next = listp->next;
    freeParam(listp->param);
    freeLabel(listp->label);
    free((void *)listp->command);
    free((void *)listp);
  }
}

// getDirection
// file asm6502.c line 1436
static unsigned char getDirection(char **s, char *direction)
{
  skipSpace(s);
  if((signed int)*(*s) == 44)
  {
    *s = *s + 1l;
    skipSpace(s);
    unsigned char return_value_isDirection_1;
    return_value_isDirection_1=isDirection(*(*s));
    if(!(return_value_isDirection_1 == 0))
    {
      *direction = *(*s);
      *s = *s + 1l;
      return (unsigned char)1;
    }

  }

  return (unsigned char)0;
}

// getValue
// file asm6502.c line 332
static unsigned char getValue(struct machine_6502 *machine, enum anonymous_60 adm, struct anonymous_15 *pointer)
{
  unsigned char zp;
  pointer->value = (unsigned short int)0;
  pointer->addr = (unsigned short int)0;
  unsigned char return_value_popByte_1;
  unsigned char return_value_popByte_2;
  signed int return_value_memReadByte_3;
  signed int return_value_memReadByte_4;
  signed int return_value_memReadByte_5;
  signed int return_value_memReadByte_6;
  signed int return_value_memReadByte_7;
  signed int return_value_memReadByte_8;
  unsigned char return_value_popByte_9;
  signed int return_value_memReadByte_10;
  unsigned char return_value_popByte_11;
  signed int return_value_memReadByte_12;
  unsigned char return_value_popByte_13;
  signed int return_value_memReadByte_14;
  unsigned char return_value_popByte_15;
  signed int return_value_popWord_16;
  signed int return_value_memReadByte_17;
  signed int return_value_popWord_18;
  signed int return_value_memReadByte_19;
  signed int return_value_popWord_20;
  signed int return_value_memReadByte_21;
  switch((signed int)adm)
  {
    case SINGLE:
      return (unsigned char)0;
    case IMMEDIATE_LESS:

    case IMMEDIATE_GREAT:

    case IMMEDIATE_VALUE:
    {
      return_value_popByte_1=popByte(machine);
      pointer->value = (unsigned short int)return_value_popByte_1;
      return (unsigned char)1;
    }
    case INDIRECT_X:
    {
      return_value_popByte_2=popByte(machine);
      zp = (unsigned char)((signed int)return_value_popByte_2 + (signed int)machine->regX);
      return_value_memReadByte_3=memReadByte(machine, (signed int)zp);
      return_value_memReadByte_4=memReadByte(machine, (signed int)zp + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_3 + (return_value_memReadByte_4 << 8));
      return_value_memReadByte_5=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_5;
      return (unsigned char)1;
    }
    case INDIRECT_Y:
    {
      zp=popByte(machine);
      return_value_memReadByte_6=memReadByte(machine, (signed int)zp);
      return_value_memReadByte_7=memReadByte(machine, (signed int)zp + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_6 + (return_value_memReadByte_7 << 8) + (signed int)machine->regY);
      return_value_memReadByte_8=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_8;
      return (unsigned char)1;
    }
    case ZERO:
    {
      return_value_popByte_9=popByte(machine);
      pointer->addr = (unsigned short int)return_value_popByte_9;
      return_value_memReadByte_10=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_10;
      return (unsigned char)1;
    }
    case ZERO_X:
    {
      return_value_popByte_11=popByte(machine);
      pointer->addr = (unsigned short int)((signed int)return_value_popByte_11 + (signed int)machine->regX);
      return_value_memReadByte_12=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_12;
      return (unsigned char)1;
    }
    case ZERO_Y:
    {
      return_value_popByte_13=popByte(machine);
      pointer->addr = (unsigned short int)((signed int)return_value_popByte_13 + (signed int)machine->regY);
      return_value_memReadByte_14=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_14;
      return (unsigned char)1;
    }
    case ABS_OR_BRANCH:
    {
      return_value_popByte_15=popByte(machine);
      pointer->addr = (unsigned short int)return_value_popByte_15;
      return (unsigned char)1;
    }
    case ABS_VALUE:
    {
      return_value_popWord_16=popWord(machine);
      pointer->addr = (unsigned short int)return_value_popWord_16;
      return_value_memReadByte_17=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_17;
      return (unsigned char)1;
    }
    case ABS_LABEL_X:

    case ABS_X:
    {
      return_value_popWord_18=popWord(machine);
      pointer->addr = (unsigned short int)(return_value_popWord_18 + (signed int)machine->regX);
      return_value_memReadByte_19=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_19;
      return (unsigned char)1;
    }
    case ABS_LABEL_Y:

    case ABS_Y:
    {
      return_value_popWord_20=popWord(machine);
      pointer->addr = (unsigned short int)(return_value_popWord_20 + (signed int)machine->regY);
      return_value_memReadByte_21=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_21;
      return (unsigned char)1;
    }
    case DCB_PARAM:
      ;
    default:
      return (unsigned char)0;
  }
}

// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth)
{
  unsigned int i = (unsigned int)0;
  signed int count;
  signed int result;
  struct anonymous_16 *formats;
  formats=XListPixmapFormats(dpy, &count);
  if(formats == ((struct anonymous_16 *)NULL))
    return 0;

  else
  {
    for( ; (_Bool)1; i = i + 1u)
    {
      if(i == (unsigned int)count)
      {
        result = 0;
        goto __CPROVER_DUMP_L4;
      }

      if((formats + (signed long int)i)->depth == depth)
      {
        result = (formats + (signed long int)i)->bits_per_pixel;
        break;
      }

    }

  __CPROVER_DUMP_L4:
    ;
    XFree((void *)formats);
    return result;
  }
}

// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  char *tmp;
  char buf[100l];
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *os = s;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_15;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    tmp = buf;
    for( ; !(*s == 0); s = s + 1l)
    {
      char *tmp_post_1 = tmp;
      tmp = tmp + 1l;
      _Bool tmp_if_expr_2;
      if((signed int)*s >= 65)
        tmp_if_expr_2 = (signed int)*s <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      signed int tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = ((signed int)*s - 65) + 97;

      else
        tmp_if_expr_3 = (signed int)*s;
      *tmp_post_1 = (char)tmp_if_expr_3;
    }
    *tmp = (char)0;
    free((void *)os);
    while(!(buf[0l] == 0))
    {
      return_value_strlen_4=strlen(buf);
      if(!((signed int)buf[-1l + (signed long int)return_value_strlen_4] == 32))
      {
        return_value_strlen_5=strlen(buf);
        if(!((signed int)buf[-1l + (signed long int)return_value_strlen_5] == 9))
          break;

      }

      return_value_strlen_6=strlen(buf);
      buf[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] = (char)0;
    }
    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(buf, "on");
    _Bool tmp_if_expr_9;
    if(return_value_strcmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcmp_8=strcmp(buf, "true");
      tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_11;
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcmp_10=strcmp(buf, "yes");
      tmp_if_expr_11 = !(return_value_strcmp_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      return 1;

    else
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(buf, "off");
      _Bool tmp_if_expr_14;
      if(return_value_strcmp_12 == 0)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_strcmp_13=strcmp(buf, "false");
        tmp_if_expr_14 = !(return_value_strcmp_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_16;
      if(tmp_if_expr_14)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_strcmp_15=strcmp(buf, "no");
        tmp_if_expr_16 = !(return_value_strcmp_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
        return 0;

      else
      {
        fprintf(stderr, "%s: %s must be boolean, not %s.\n", progname, res_name, (const void *)buf);
        return 0;
      }
    }
  }
}

// get_float_resource
// file resources.c line 122
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  double val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return 0.0;

  else
  {
    signed int return_value___isoc99_sscanf_1;
    return_value___isoc99_sscanf_1=__isoc99_sscanf(s, " %lf %c", &val, &c);
    if(return_value___isoc99_sscanf_1 == 1)
    {
      free((void *)s);
      return val;
    }

    else
    {
      fprintf(stderr, "%s: %s must be a float, not %s.\n", progname, res_name, s);
      free((void *)s);
      return 0.0;
    }
  }
}

// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  signed int val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *ss = s;
  _Bool tmp_if_expr_3;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    for( ; !(*ss == 0); ss = ss + 1l)
      if((signed int)*ss >= 33)
        break;

    _Bool tmp_if_expr_4;
    if((signed int)*ss == 48)
    {
      if((signed int)ss[1l] == 120)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)ss[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int return_value___isoc99_sscanf_1;
      return_value___isoc99_sscanf_1=__isoc99_sscanf(ss + (signed long int)2, "%x %c", (unsigned int *)&val, &c);
      if(return_value___isoc99_sscanf_1 == 1)
      {
        free((void *)s);
        return val;
      }

    }

    else
    {
      signed int return_value___isoc99_sscanf_2;
      return_value___isoc99_sscanf_2=__isoc99_sscanf(ss, "%d %c", &val, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        free((void *)s);
        return val;
      }

    }
    fprintf(stderr, "%s: %s must be an integer, not %s.\n", progname, res_name, s);
    free((void *)s);
    return 0;
  }
}

// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 0);
  return return_value_get_time_resource_1;
}

// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class)
{
  struct anonymous_9 color;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *s2;
  signed int ok = 1;
  unsigned long int return_value_strlen_1;
  signed int return_value_XParseColor_3;
  signed int return_value_XAllocColor_4;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcasecmp_7;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    s2 = (s + (signed long int)return_value_strlen_1) - (signed long int)1;
    for( ; !(s >= s2); s2 = s2 - 1l)
    {
      _Bool tmp_if_expr_2;
      if((signed int)*s2 == 32)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*s2 == 9 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        *s2 = (char)0;

      else
        break;
    }
    return_value_XParseColor_3=XParseColor(dpy, cmap, s, &color);
    if(return_value_XParseColor_3 == 0)
    {
      fprintf(stderr, "%s: can't parse color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
    if(return_value_XAllocColor_4 == 0)
    {
      fprintf(stderr, "%s: couldn't allocate color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    free((void *)s);
    return (unsigned int)color.pixel;
  }

  else
  {

  DEFAULT:
    ;
    if(!(s == ((char *)NULL)))
      free((void *)s);

    signed int black_p;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(res_class);
    _Bool tmp_if_expr_8;
    if(return_value_strlen_5 >= 10ul)
    {
      return_value_strlen_6=strlen(res_class);
      return_value_strcasecmp_7=strcasecmp("Background", (res_class + (signed long int)return_value_strlen_6) - (signed long int)10);
      tmp_if_expr_8 = !(return_value_strcasecmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    black_p = (signed int)tmp_if_expr_8;
    if(ok == 0)
      fprintf(stderr, ": using %s.\n", black_p != 0 ? "black" : "white");

    color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    color.blue = (unsigned short int)(black_p != 0 ? 0 : 0xFFFF);
    color.green = color.blue;
    color.red = color.green;
    signed int return_value_XAllocColor_9;
    return_value_XAllocColor_9=XAllocColor(dpy, cmap, &color);
    if(!(return_value_XAllocColor_9 == 0))
      return (unsigned int)color.pixel;

    else
    {
      fprintf(stderr, "%s: couldn't allocate %s either!\n", progname, black_p != 0 ? "black" : "white");
      return (unsigned int)0;
    }
  }
}

// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 1);
  return return_value_get_time_resource_1;
}

// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  struct anonymous_10 get_string_resource__1__value;
  char *type;
  char full_name[1024l];
  char full_class[1024l];
  strcpy(full_name, progname);
  strcat(full_name, ".");
  strcat(full_name, res_name);
  strcpy(full_class, progclass);
  strcat(full_class, ".");
  strcat(full_class, res_class);
  struct _XrmHashBucketRec *return_value_XtDatabase_2;
  return_value_XtDatabase_2=XtDatabase(dpy);
  signed int return_value_XrmGetResource_3;
  return_value_XrmGetResource_3=XrmGetResource(return_value_XtDatabase_2, full_name, full_class, &type, &get_string_resource__1__value);
  if(!(return_value_XrmGetResource_3 == 0))
  {
    char *str;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(get_string_resource__1__value.size + (unsigned int)1));
    str = (char *)return_value_malloc_1;
    strncpy(str, (char *)get_string_resource__1__value.addr, (unsigned long int)get_string_resource__1__value.size);
    str[(signed long int)get_string_resource__1__value.size] = (char)0;
    return str;
  }

  return ((char *)NULL);
}

// get_time
// file m6502.c line 92
static double get_time(struct state *st)
{
  struct timeval t;
  float f;
  gettimeofday(&t, (struct timezone *)(void *)0);
  t.tv_sec = t.tv_sec - st->start_time.tv_sec;
  f = (float)((double)t.tv_sec + (double)t.tv_usec * 1e-6);
  return (double)f;
}

// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p)
{
  signed int val;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return (unsigned int)0;

  else
  {
    val=parse_time(s, sec_p, 0);
    free((void *)s);
    return (unsigned int)(val < 0 ? 0 : val);
  }
}

// get_visual
// file visual.c line 50
extern struct anonymous_13 * get_visual(struct anonymous_25 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p)
{
  char *v;
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(string == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(string);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = ((char *)NULL);
  v = tmp_if_expr_2;
  char c;
  char *tmp;
  signed int vclass;
  unsigned long int id;
  struct anonymous_13 *result = ((struct anonymous_13 *)NULL);
  if(!(v == ((char *)NULL)))
  {
    tmp = v;
    for( ; !(*tmp == 0); tmp = tmp + 1l)
      if((signed int)*tmp >= 65)
      {
        if(!((signed int)*tmp >= 91))
          *tmp = (char)(((signed int)*tmp - 65) + 97);

      }

  }

  _Bool tmp_if_expr_20;
  if(v == ((char *)NULL))
    tmp_if_expr_20 = (_Bool)1;

  else
    tmp_if_expr_20 = !(*v != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_3;
  if(tmp_if_expr_20)
    vclass = -2;

  else
  {
    return_value_strcmp_19=strcmp(v, "default");
    if(return_value_strcmp_19 == 0)
      vclass = -1;

    else
    {
      return_value_strcmp_18=strcmp(v, "best");
      if(return_value_strcmp_18 == 0)
        vclass = -2;

      else
      {
        return_value_strcmp_17=strcmp(v, "mono");
        if(return_value_strcmp_17 == 0)
          vclass = -3;

        else
        {
          return_value_strcmp_16=strcmp(v, "monochrome");
          if(return_value_strcmp_16 == 0)
            vclass = -3;

          else
          {
            return_value_strcmp_15=strcmp(v, "gray");
            if(return_value_strcmp_15 == 0)
              vclass = -4;

            else
            {
              return_value_strcmp_14=strcmp(v, "grey");
              if(return_value_strcmp_14 == 0)
                vclass = -4;

              else
              {
                return_value_strcmp_13=strcmp(v, "color");
                if(return_value_strcmp_13 == 0)
                  vclass = -5;

                else
                {
                  return_value_strcmp_12=strcmp(v, "gl");
                  if(return_value_strcmp_12 == 0)
                    vclass = -6;

                  else
                  {
                    return_value_strcmp_11=strcmp(v, "staticgray");
                    if(return_value_strcmp_11 == 0)
                      vclass = 0;

                    else
                    {
                      return_value_strcmp_10=strcmp(v, "staticcolor");
                      if(return_value_strcmp_10 == 0)
                        vclass = 2;

                      else
                      {
                        return_value_strcmp_9=strcmp(v, "truecolor");
                        if(return_value_strcmp_9 == 0)
                          vclass = 4;

                        else
                        {
                          return_value_strcmp_8=strcmp(v, "grayscale");
                          if(return_value_strcmp_8 == 0)
                            vclass = 1;

                          else
                          {
                            return_value_strcmp_7=strcmp(v, "greyscale");
                            if(return_value_strcmp_7 == 0)
                              vclass = 1;

                            else
                            {
                              return_value_strcmp_6=strcmp(v, "pseudocolor");
                              if(return_value_strcmp_6 == 0)
                                vclass = 3;

                              else
                              {
                                return_value_strcmp_5=strcmp(v, "directcolor");
                                if(return_value_strcmp_5 == 0)
                                  vclass = 5;

                                else
                                {
                                  return_value___isoc99_sscanf_4=__isoc99_sscanf(v, " %lu %c", &id, &c);
                                  if(return_value___isoc99_sscanf_4 == 1)
                                    vclass = -7;

                                  else
                                  {
                                    return_value___isoc99_sscanf_3=__isoc99_sscanf(v, " 0x%lx %c", &id, &c);
                                    if(return_value___isoc99_sscanf_3 == 1)
                                      vclass = -7;

                                    else
                                    {
                                      fprintf(stderr, "%s: unrecognized visual \"%s\".\n", progname, v);
                                      vclass = -1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_visual_depth_21;
  if(vclass == -1)
    result = screen->root_visual;

  else
    if(vclass == -2)
      result=pick_best_visual(screen, prefer_writable_cells, 0);

    else
      if(vclass == -3)
      {
        result=pick_mono_visual(screen);
        if(result == ((struct anonymous_13 *)NULL) && !(verbose_p == 0))
          fprintf(stderr, "%s: no monochrome visuals.\n", progname);

      }

      else
        if(vclass == -4)
        {
          if(!(prefer_writable_cells == 0))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_13 *)NULL))
            result=pick_best_visual_of_class(screen, 0);

          if(result == ((struct anonymous_13 *)NULL))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_13 *)NULL) && !(verbose_p == 0))
            fprintf(stderr, "%s: no GrayScale or StaticGray visuals.\n", progname);

        }

        else
          if(vclass == -5)
          {
            signed int class;
            result = screen->root_visual;
            class=visual_class(screen, result);
            if(!(class == 2) && !(class == 3) && !(class == 4) && !(class == 5))
              result = ((struct anonymous_13 *)NULL);

            if(!(result == ((struct anonymous_13 *)NULL)))
            {
              return_value_visual_depth_21=visual_depth(screen, result);
              if(!(return_value_visual_depth_21 >= 2))
                result = ((struct anonymous_13 *)NULL);

            }

            if(result == ((struct anonymous_13 *)NULL))
              result=pick_best_visual(screen, prefer_writable_cells, 1);

            if(result == ((struct anonymous_13 *)NULL) && !(verbose_p == 0))
              fprintf(stderr, "%s: no color visuals.\n", progname);

          }

          else
            if(vclass == -6)
            {
              struct anonymous_13 *visual;
              visual=pick_best_gl_visual(screen);
              if(!(visual == ((struct anonymous_13 *)NULL)))
                result = visual;

              else
                if(!(verbose_p == 0))
                  fprintf(stderr, "%s: no visual suitable for GL.\n", progname);

            }

            else
              if(vclass == -7)
              {
                result=id_to_visual(screen, (signed int)id);
                if(result == ((struct anonymous_13 *)NULL) && !(verbose_p == 0))
                  fprintf(stderr, "%s: no visual with id 0x%x.\n", progname, (unsigned int)id);

              }

              else
              {
                struct anonymous_13 *get_visual__1__7__visual;
                get_visual__1__7__visual=pick_best_visual_of_class(screen, vclass);
                if(!(get_visual__1__7__visual == ((struct anonymous_13 *)NULL)))
                  result = get_visual__1__7__visual;

                else
                  if(!(verbose_p == 0))
                    fprintf(stderr, "%s: no visual of class %s.\n", progname, v);

              }
  if(!(v == ((char *)NULL)))
    free((void *)v);

  return result;
}

// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_13 * get_visual_resource(struct anonymous_25 *screen, char *name, char *class, signed int prefer_writable_cells)
{
  char *string;
  string=get_string_resource(screen->display, name, class);
  struct anonymous_13 *v;
  v=get_visual(screen, string, prefer_writable_cells, 1);
  if(!(string == ((char *)NULL)))
    free((void *)string);

  if(!(v == ((struct anonymous_13 *)NULL)))
    return v;

  else
    return screen->root_visual;
}

// hardware_concurrency
// file ./../utils/thread_util.h line 101
unsigned int hardware_concurrency(struct _XDisplay *dpy)
{
  signed int return_value_threads_available_2;
  return_value_threads_available_2=threads_available(dpy);
  unsigned int return_value__hardware_concurrency_1;
  if(return_value_threads_available_2 >= 0)
  {
    return_value__hardware_concurrency_1=_hardware_concurrency();
    return return_value__hardware_concurrency_1;
  }

  return (unsigned int)1;
}

// hasChar
// file asm6502.c line 1289
static unsigned char hasChar(char *s, char c)
{
  _Bool tmp_if_expr_1;
  do
  {
    if(!((signed int)*s == 0))
      tmp_if_expr_1 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    if(*s == c)
      return (unsigned char)1;

    s = s + 1l;
  }
  while((_Bool)1);
  return (unsigned char)0;
}

// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_25 *screen, struct anonymous_13 *visual)
{
  signed int return_value_visual_class_1;
  return_value_visual_class_1=visual_class(screen, visual);
  switch(return_value_visual_class_1)
  {
    case 1:

    case 3:

    case 5:
      return 1;
    case 0:

    case 4:

    case 2:
      return 0;
    default:
    {
      abort();
      return 0;
    }
  }
}

// id_to_visual
// file visual.c line 340
extern struct anonymous_13 * id_to_visual(struct anonymous_25 *screen, signed int id)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid = (unsigned long int)id;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_19 *)NULL)))
  {
    struct anonymous_13 *v = (vi_out + (signed long int)0)->visual;
    XFree((void *)(char *)vi_out);
    return v;
  }

  return ((struct anonymous_13 *)NULL);
}

// immediate
// file asm6502.c line 1401
static unsigned char immediate(char **s, struct anonymous_8 *param)
{
  if(!((signed int)*(*s) == 35))
    return (unsigned char)0;

  else
  {
    *s = *s + 1l;
    _Bool tmp_if_expr_6;
    if((signed int)*(*s) == 60)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)*(*s) == 62 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      char *immediate__1__1__label;
      void *return_value_ecalloc_1;
      return_value_ecalloc_1=ecalloc((unsigned int)80, sizeof(char) /*1ul*/ );
      immediate__1__1__label = (char *)return_value_ecalloc_1;
      param->type = (enum anonymous_60)((signed int)*(*s) == 60 ? IMMEDIATE_LESS : IMMEDIATE_GREAT);
      *s = *s + 1l;
      unsigned char return_value_paramLabel_3;
      return_value_paramLabel_3=paramLabel(s, &immediate__1__1__label);
      if(!(return_value_paramLabel_3 == 0))
      {
        signed int ln;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(immediate__1__1__label);
        ln = (signed int)(return_value_strlen_2 + (unsigned long int)1);
        strncpy(param->label, immediate__1__1__label, (unsigned long int)ln);
        free((void *)immediate__1__1__label);
        return (unsigned char)1;
      }

      free((void *)immediate__1__1__label);
    }

    else
    {
      unsigned int immediate__1__2__value;
      unsigned char return_value_parseValue_5;
      return_value_parseValue_5=parseValue(s, &immediate__1__2__value);
      if(!(return_value_parseValue_5 == 0))
      {
        if(immediate__1__2__value >= 256u)
        {
          parseError("Immediate value is too large.");
          return (unsigned char)0;
        }

        param->type = (enum anonymous_60)IMMEDIATE_VALUE;
        unsigned char return_value_addvalue_4;
        return_value_addvalue_4=addvalue(param, immediate__1__2__value);
        return return_value_addvalue_4;
      }

    }
    return (unsigned char)0;
  }
}

// indexLabels
// file asm6502.c line 1970
static unsigned char indexLabels(struct AsmLine *asmline, void *arg)
{
  struct machine_6502 *machine;
  signed int thisPC;
  unsigned short int oldDefault;
  machine = (struct machine_6502 *)arg;
  oldDefault = machine->defaultCodePC;
  thisPC = (signed int)machine->regPC;
  machine->codeLen = 0;
  unsigned char return_value_compileLine_1;
  return_value_compileLine_1=compileLine(asmline, (void *)machine);
  if(return_value_compileLine_1 == 0)
    return (unsigned char)0;

  else
  {
    if(oldDefault == machine->defaultCodePC)
      machine->regPC = machine->regPC + (unsigned short int)machine->codeLen;

    else
      machine->regPC = machine->defaultCodePC;
    if(!(asmline->labelDecl == 0))
      asmline->label->addr = (unsigned int)thisPC;

    return (unsigned char)1;
  }
}

// indirect
// file asm6502.c line 1450
static unsigned char indirect(char **s, struct anonymous_8 *param)
{
  unsigned int indirect__1__value;
  char c;
  if((signed int)*(*s) == 40)
    *s = *s + 1l;

  else
    return (unsigned char)0;
  unsigned char return_value_parseHex_1;
  return_value_parseHex_1=parseHex(s, &indirect__1__value);
  unsigned char return_value_getDirection_4;
  if(return_value_parseHex_1 == 0)
    return (unsigned char)0;

  else
    if(indirect__1__value >= 256u)
    {
      parseError("Indirect value is too large.");
      return (unsigned char)0;
    }

    else
    {
      unsigned char return_value_addvalue_2;
      return_value_addvalue_2=addvalue(param, indirect__1__value);
      if(return_value_addvalue_2 == 0)
        return (unsigned char)0;

      else
      {
        skipSpace(s);
        if((signed int)*(*s) == 41)
        {
          *s = *s + 1l;
          unsigned char return_value_getDirection_3;
          return_value_getDirection_3=getDirection(s, &c);
          if(!(return_value_getDirection_3 == 0))
          {
            if((signed int)c == 89)
            {
              param->type = (enum anonymous_60)INDIRECT_Y;
              return (unsigned char)1;
            }

          }

        }

        else
        {
          return_value_getDirection_4=getDirection(s, &c);
          if(!(return_value_getDirection_4 == 0))
          {
            if((signed int)c == 88)
            {
              skipSpace(s);
              if((signed int)*(*s) == 41)
              {
                *s = *s + 1l;
                param->type = (enum anonymous_60)INDIRECT_X;
                return (unsigned char)1;
              }

            }

          }

        }
        return (unsigned char)0;
      }
    }
}

// initParam
// file asm6502.c line 1596
static void initParam(struct anonymous_8 *param)
{
  signed int i;
  param->type = (enum anonymous_60)SINGLE;
  i = 0;
  for( ; !(i >= 25); i = i + 1)
    param->value[(signed long int)i] = (unsigned int)0;
  param->vp = (unsigned int)0;
  nullify(param->label, (unsigned int)80);
}

// init_time
// file m6502.c line 110
static void init_time(struct state *st)
{
  gettimeofday(&st->start_time, (struct timezone *)(void *)0);
}

// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title)
{
  unsigned long int window;
  struct anonymous_7 xgwa;
  XtPopup(toplevel, (enum anonymous_70)XtGrabNone);
  XtVaSetValues(toplevel, (char *)&XtShellStrings[(signed long int)356], title, (void *)0);
  window = toplevel->core.window;
  XGetWindowAttributes(dpy, window, &xgwa);
  XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 0 | 1L << 1 | 1L << 2 | 1L << 3);
  XChangeProperty(dpy, window, XA_WM_PROTOCOLS, (unsigned long int)4, 32, 0, (unsigned char *)&XA_WM_DELETE_WINDOW, 1);
}

// io_thread_cancel
// file thread_util.c line 1013
signed int io_thread_cancel(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_cancelled, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_done */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_done);
    signed int return_value_pthread_detach_2;
    return_value_pthread_detach_2=pthread_detach(self->thread);
    /* assertion !(pthread_detach(self->thread)) */
    assert(!(return_value_pthread_detach_2 != 0));
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// io_thread_create
// file thread_util.c line 950
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize)
{
  signed int return_value_threads_available_4;
  return_value_threads_available_4=threads_available(dpy);
  signed int return_value_pthread_attr_destroy_3;
  if(return_value_threads_available_4 >= 0)
  {
    signed int error;
    union pthread_attr_t attr;
    union pthread_attr_t *attr_ptr = (union pthread_attr_t *)(void *)0;
    if(!(stacksize == 0u))
    {
      attr_ptr = &attr;
      signed int return_value_pthread_attr_init_1;
      return_value_pthread_attr_init_1=pthread_attr_init(&attr);
      if(!(return_value_pthread_attr_init_1 == 0))
        return (void *)0;

      /* assertion stacksize >= 16384 */
      assert(stacksize >= (unsigned int)16384);
      signed int return_value_pthread_attr_setstacksize_2;
      return_value_pthread_attr_setstacksize_2=pthread_attr_setstacksize(&attr, (unsigned long int)stacksize);
      /* assertion !(pthread_attr_setstacksize(&attr, stacksize)) */
      assert(!(return_value_pthread_attr_setstacksize_2 != 0));
    }

    self->status = (enum _io_thread_status)_io_thread_working;
    error=pthread_create(&self->thread, attr_ptr, start_routine, parent);
    /* assertion !error || error == 11 */
    assert(!(error != 0) || error == 11);
    if(!(error == 0))
      parent = (void *)0;

    if(!(attr_ptr == ((union pthread_attr_t *)NULL)))
    {
      return_value_pthread_attr_destroy_3=pthread_attr_destroy(attr_ptr);
      /* assertion !(pthread_attr_destroy(attr_ptr)) */
      assert(!(return_value_pthread_attr_destroy_3 != 0));
    }

    return parent;
  }

  return (void *)0;
}

// io_thread_finish
// file thread_util.c line 1029
void io_thread_finish(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status status;
    signed int return_value___atomic_load_n_1;
    return_value___atomic_load_n_1=__atomic_load_n(&self->status, 5);
    status = (enum _io_thread_status)return_value___atomic_load_n_1;
    /* assertion status == _io_thread_working || status == _io_thread_done */
    assert((signed int)status == _io_thread_working || (signed int)status == _io_thread_done);
    signed int return_value_pthread_join_2;
    return_value_pthread_join_2=pthread_join(self->thread, (void **)(void *)0);
    /* assertion !(pthread_join(self->thread, ((void *)0))) */
    assert(!(return_value_pthread_join_2 != 0));
    signed int return_value___atomic_load_n_3;
    return_value___atomic_load_n_3=__atomic_load_n(&self->status, 5);
    /* assertion (__atomic_load_n((&self->status), 5)) == _io_thread_done */
    assert(return_value___atomic_load_n_3 == _io_thread_done);
  }

}

// io_thread_is_done
// file thread_util.c line 1002
signed int io_thread_is_done(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    signed int result;
    result=__atomic_load_n(&self->status, 5);
    /* assertion result != _io_thread_cancelled */
    assert(result != _io_thread_cancelled);
    return result;
  }

  return 1;
}

// io_thread_return
// file thread_util.c line 989
signed int io_thread_return(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_done, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_cancelled */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_cancelled);
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// isBlank
// file asm6502.c line 1270
static unsigned char isBlank(const char *token)
{
  return (unsigned char)((signed int)token[(signed long int)0] == 0);
}

// isCmdChar
// file asm6502.c line 1308
static unsigned char isCmdChar(char c)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  return_value___ctype_b_loc_1=__ctype_b_loc();
  return (unsigned char)((((signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)c] & (signed int)(unsigned short int)1024) != 0 ? (_Bool)1 : ((signed int)c == 42 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : ((signed int)c == 61 ? (_Bool)1 : (_Bool)0));
}

// isCommand
// file asm6502.c line 1274
static unsigned char isCommand(struct machine_6502 *machine, const char *token)
{
  signed int i = 0;
  while(!(i >= 56))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(machine->opcodes[(signed long int)i].name, token);
    if(return_value_strcmp_1 == 0)
      return (unsigned char)1;

    i = i + 1;
  }
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(token, "DCB");
  if(return_value_strcmp_2 == 0)
    return (unsigned char)1;

  else
    return (unsigned char)0;
}

// isDirection
// file asm6502.c line 1432
static unsigned char isDirection(char c)
{
  return (unsigned char)((signed int)c == 88 || (signed int)c == 89);
}

// isWhite
// file asm6502.c line 1254
static unsigned char isWhite(char c)
{
  return (unsigned char)((signed int)c == 13 || (signed int)c == 9 || (signed int)c == 32);
}

// ishexdigit
// file asm6502.c line 1297
static unsigned char ishexdigit(char c)
{
  const unsigned short int **return_value___ctype_b_loc_2;
  return_value___ctype_b_loc_2=__ctype_b_loc();
  if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)c]) == 0))
    return (unsigned char)1;

  else
  {
    char c1;
    signed int return_value_toupper_1;
    return_value_toupper_1=toupper((signed int)c);
    c1 = (char)return_value_toupper_1;
    return (unsigned char)(65 <= (signed int)c1 && (signed int)c1 <= 70);
  }
}

// jmpADC
// file asm6502.c line 465
static void jmpADC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned short int tmp;
  unsigned char c;
  c=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(machine->regA, (enum anonymous_18)NEGATIVE_FL);
  _Bool tmp_if_expr_3;
  unsigned char return_value_bitOn_2;
  if(!(return_value_bitOn_1 == 0))
  {
    return_value_bitOn_2=bitOn((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL);
    tmp_if_expr_3 = return_value_bitOn_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

  else
    machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 1);
  unsigned char return_value_bitOn_12;
  return_value_bitOn_12=bitOn(machine->regP, (enum anonymous_18)DECIMAL_FL);
  if(!(return_value_bitOn_12 == 0))
  {
    unsigned char return_value_nibble_4;
    return_value_nibble_4=nibble(machine->regA, (enum anonymous_17)RIGHT);
    unsigned char return_value_nibble_5;
    return_value_nibble_5=nibble((unsigned char)ptr.value, (enum anonymous_17)RIGHT);
    tmp = (unsigned short int)((signed int)return_value_nibble_4 + (signed int)return_value_nibble_5 + (signed int)c);
    if((signed int)tmp >= 10)
      tmp = (unsigned short int)(0x10 | (signed int)tmp + 6 & 0xf);

    unsigned char return_value_nibble_6;
    return_value_nibble_6=nibble(machine->regA, (enum anonymous_17)LEFT);
    unsigned char return_value_nibble_7;
    return_value_nibble_7=nibble((unsigned char)ptr.value, (enum anonymous_17)LEFT);
    tmp = tmp + (unsigned short int)((signed int)return_value_nibble_6 + (signed int)return_value_nibble_7);
    if((signed int)tmp >= 160)
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 1);
      unsigned char return_value_bitOn_8;
      return_value_bitOn_8=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_8 == 0))
      {
        if((signed int)tmp >= 0x180)
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

      tmp = tmp + (unsigned short int)0x60;
    }

    else
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 0);
      unsigned char return_value_bitOn_9;
      return_value_bitOn_9=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_9 == 0))
      {
        if(!((signed int)tmp >= 0x80))
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }
  }

  else
  {
    tmp = (unsigned short int)((signed int)machine->regA + (signed int)ptr.value + (signed int)c);
    if((signed int)tmp >= 0x100)
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 1);
      unsigned char return_value_bitOn_10;
      return_value_bitOn_10=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_10 == 0))
      {
        if((signed int)tmp >= 0x180)
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }

    else
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 0);
      unsigned char return_value_bitOn_11;
      return_value_bitOn_11=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_11 == 0))
      {
        if(!((signed int)tmp >= 0x80))
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }
  }
  machine->regA = (unsigned char)tmp;
  manZeroNeg(machine, machine->regA);
}

// jmpAND
// file asm6502.c line 516
static void jmpAND(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regA = machine->regA & (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regA);
}

// jmpASL
// file asm6502.c line 524
static void jmpASL(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  if(!(isValue == 0))
  {
    unsigned char return_value_bitOn_1;
    return_value_bitOn_1=bitOn((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_1);
    ptr.value = (unsigned short int)((signed int)ptr.value << 1);
    unsigned char return_value_setBit_2;
    return_value_setBit_2=setBit((unsigned char)ptr.value, (enum anonymous_18)CARRY_FL, 0);
    ptr.value = (unsigned short int)return_value_setBit_2;
    memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
    manZeroNeg(machine, (unsigned char)ptr.value);
  }

  else
  {
    unsigned char return_value_bitOn_3;
    return_value_bitOn_3=bitOn(machine->regA, (enum anonymous_18)NEGATIVE_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_3);
    machine->regA = (unsigned char)((signed int)machine->regA << 1);
    machine->regA=setBit(machine->regA, (enum anonymous_18)CARRY_FL, 0);
    manZeroNeg(machine, machine->regA);
  }
}

// jmpBCC
// file asm6502.c line 594
static void jmpBCC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOff_1;
  return_value_bitOff_1=bitOff(machine->regP, (enum anonymous_18)CARRY_FL);
  if(!(return_value_bitOff_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBCS
// file asm6502.c line 602
static void jmpBCS(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
  if(!(return_value_bitOn_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBEQ
// file asm6502.c line 618
static void jmpBEQ(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(machine->regP, (enum anonymous_18)ZERO_FL);
  if(!(return_value_bitOn_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBIT
// file asm6502.c line 543
static void jmpBIT(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regP=setBit(machine->regP, (enum anonymous_18)ZERO_FL, (signed int)ptr.value & (signed int)machine->regA);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn((unsigned char)ptr.value, (enum anonymous_18)OVERFLOW_FL);
  machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, (signed int)return_value_bitOn_1);
  unsigned char return_value_bitOn_2;
  return_value_bitOn_2=bitOn((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL);
  machine->regP=setBit(machine->regP, (enum anonymous_18)NEGATIVE_FL, (signed int)return_value_bitOn_2);
}

// jmpBMI
// file asm6502.c line 569
static void jmpBMI(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(machine->regP, (enum anonymous_18)NEGATIVE_FL);
  if(!(return_value_bitOn_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBNE
// file asm6502.c line 610
static void jmpBNE(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOff_1;
  return_value_bitOff_1=bitOff(machine->regP, (enum anonymous_18)ZERO_FL);
  if(!(return_value_bitOff_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBPL
// file asm6502.c line 560
static void jmpBPL(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOff_1;
  return_value_bitOff_1=bitOff(machine->regP, (enum anonymous_18)NEGATIVE_FL);
  if(!(return_value_bitOff_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBVC
// file asm6502.c line 578
static void jmpBVC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOff_1;
  return_value_bitOff_1=bitOff(machine->regP, (enum anonymous_18)OVERFLOW_FL);
  if(!(return_value_bitOff_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpBVS
// file asm6502.c line 586
static void jmpBVS(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
  if(!(return_value_bitOn_1 == 0))
    jumpBranch(machine, ptr.addr);

}

// jmpCLC
// file asm6502.c line 672
static void jmpCLC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 0);
}

// jmpCLD
// file asm6502.c line 692
static void jmpCLD(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)DECIMAL_FL, 0);
}

// jmpCLI
// file asm6502.c line 680
static void jmpCLI(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)INTERRUPT_FL, 0);
}

// jmpCLV
// file asm6502.c line 688
static void jmpCLV(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);
}

// jmpCMP
// file asm6502.c line 631
static void jmpCMP(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  doCompare(machine, (unsigned short int)machine->regA, &ptr);
}

// jmpCPX
// file asm6502.c line 638
static void jmpCPX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  doCompare(machine, (unsigned short int)machine->regX, &ptr);
}

// jmpCPY
// file asm6502.c line 645
static void jmpCPY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  doCompare(machine, (unsigned short int)machine->regY, &ptr);
}

// jmpDEC
// file asm6502.c line 652
static void jmpDEC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  if((signed int)ptr.value >= 1)
    ptr.value = ptr.value - 1;

  else
    ptr.value = (unsigned short int)0xFF;
  memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
  manZeroNeg(machine, (unsigned char)ptr.value);
}

// jmpDEX
// file asm6502.c line 796
static void jmpDEX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  if((signed int)machine->regX >= 1)
    machine->regX = machine->regX - 1;

  else
    machine->regX = (unsigned char)0xFF;
  manZeroNeg(machine, machine->regX);
}

// jmpDEY
// file asm6502.c line 820
static void jmpDEY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  if((signed int)machine->regY >= 1)
    machine->regY = machine->regY - 1;

  else
    machine->regY = (unsigned char)0xFF;
  manZeroNeg(machine, machine->regY);
}

// jmpEOR
// file asm6502.c line 664
static void jmpEOR(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regA = machine->regA ^ (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regA);
}

// jmpINC
// file asm6502.c line 700
static void jmpINC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  ptr.value = (unsigned short int)((signed int)ptr.value + 1 & 0xFF);
  memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
  manZeroNeg(machine, (unsigned char)ptr.value);
}

// jmpINX
// file asm6502.c line 804
static void jmpINX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  unsigned short int jmpINX__1__value = (unsigned short int)((signed int)machine->regX + 1);
  machine->regX = (unsigned char)((signed int)jmpINX__1__value & 0xFF);
  manZeroNeg(machine, machine->regX);
}

// jmpINY
// file asm6502.c line 828
static void jmpINY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  unsigned short int jmpINY__1__value = (unsigned short int)((signed int)machine->regY + 1);
  machine->regY = (unsigned char)((signed int)jmpINY__1__value & 0xff);
  manZeroNeg(machine, machine->regY);
}

// jmpJMP
// file asm6502.c line 709
static void jmpJMP(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regPC = ptr.addr;
}

// jmpJSR
// file asm6502.c line 716
static void jmpJSR(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned short int currAddr = (unsigned short int)((signed int)machine->regPC + 2);
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  stackPush(machine, (unsigned char)((signed int)currAddr >> 8 & 0xff));
  stackPush(machine, (unsigned char)((signed int)currAddr & 0xff));
  machine->regPC = ptr.addr;
}

// jmpLDA
// file asm6502.c line 728
static void jmpLDA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regA = (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regA);
}

// jmpLDX
// file asm6502.c line 736
static void jmpLDX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regX = (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regX);
}

// jmpLDY
// file asm6502.c line 744
static void jmpLDY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regY = (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regY);
}

// jmpLSR
// file asm6502.c line 752
static void jmpLSR(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  if(!(isValue == 0))
  {
    unsigned char return_value_bitOn_1;
    return_value_bitOn_1=bitOn((unsigned char)ptr.value, (enum anonymous_18)CARRY_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_1);
    ptr.value = (unsigned short int)((signed int)ptr.value >> 1);
    unsigned char return_value_setBit_2;
    return_value_setBit_2=setBit((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL, 0);
    ptr.value = (unsigned short int)return_value_setBit_2;
    memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
    manZeroNeg(machine, (unsigned char)ptr.value);
  }

  else
  {
    unsigned char return_value_bitOn_3;
    return_value_bitOn_3=bitOn(machine->regA, (enum anonymous_18)CARRY_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_3);
    machine->regA = (unsigned char)((signed int)machine->regA >> 1);
    machine->regA=setBit(machine->regA, (enum anonymous_18)NEGATIVE_FL, 0);
    manZeroNeg(machine, (unsigned char)ptr.value);
  }
}

// jmpNOP
// file asm6502.c line 774
static void jmpNOP(struct machine_6502 *machine, enum anonymous_60 adm)
{
  ;
}

// jmpORA
// file asm6502.c line 778
static void jmpORA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  machine->regA = machine->regA | (unsigned char)ptr.value;
  manZeroNeg(machine, machine->regA);
}

// jmpPHA
// file asm6502.c line 970
static void jmpPHA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  stackPush(machine, machine->regA);
}

// jmpPHP
// file asm6502.c line 979
static void jmpPHP(struct machine_6502 *machine, enum anonymous_60 adm)
{
  stackPush(machine, machine->regP);
}

// jmpPLA
// file asm6502.c line 974
static void jmpPLA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regA=stackPop(machine);
  manZeroNeg(machine, machine->regA);
}

// jmpPLP
// file asm6502.c line 983
static void jmpPLP(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=stackPop(machine);
  machine->regP=setBit(machine->regP, (enum anonymous_18)FUTURE_FL, 1);
}

// jmpROL
// file asm6502.c line 859
static void jmpROL(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char cf;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  if(!(isValue == 0))
  {
    cf=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
    unsigned char return_value_bitOn_1;
    return_value_bitOn_1=bitOn((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_1);
    ptr.value = (unsigned short int)((signed int)ptr.value << 1);
    unsigned char return_value_setBit_2;
    return_value_setBit_2=setBit((unsigned char)ptr.value, (enum anonymous_18)CARRY_FL, (signed int)cf);
    ptr.value = (unsigned short int)return_value_setBit_2;
    memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
    manZeroNeg(machine, (unsigned char)ptr.value);
  }

  else
  {
    cf=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
    unsigned char return_value_bitOn_3;
    return_value_bitOn_3=bitOn(machine->regA, (enum anonymous_18)NEGATIVE_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_3);
    machine->regA = (unsigned char)((signed int)machine->regA << 1);
    machine->regA=setBit(machine->regA, (enum anonymous_18)CARRY_FL, (signed int)cf);
    manZeroNeg(machine, machine->regA);
  }
}

// jmpROR
// file asm6502.c line 834
static void jmpROR(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char cf;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  if(!(isValue == 0))
  {
    cf=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
    unsigned char return_value_bitOn_1;
    return_value_bitOn_1=bitOn((unsigned char)ptr.value, (enum anonymous_18)CARRY_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_1);
    ptr.value = (unsigned short int)((signed int)ptr.value >> 1);
    unsigned char return_value_setBit_2;
    return_value_setBit_2=setBit((unsigned char)ptr.value, (enum anonymous_18)NEGATIVE_FL, (signed int)cf);
    ptr.value = (unsigned short int)return_value_setBit_2;
    memStoreByte(machine, (signed int)ptr.addr, (signed int)ptr.value);
    manZeroNeg(machine, (unsigned char)ptr.value);
  }

  else
  {
    cf=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
    unsigned char return_value_bitOn_3;
    return_value_bitOn_3=bitOn(machine->regA, (enum anonymous_18)CARRY_FL);
    machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, (signed int)return_value_bitOn_3);
    machine->regA = (unsigned char)((signed int)machine->regA >> 1);
    machine->regA=setBit(machine->regA, (enum anonymous_18)NEGATIVE_FL, (signed int)cf);
    manZeroNeg(machine, machine->regA);
  }
}

// jmpRTI
// file asm6502.c line 884
static void jmpRTI(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=stackPop(machine);
  unsigned char return_value_stackPop_1;
  return_value_stackPop_1=stackPop(machine);
  machine->regPC = (unsigned short int)return_value_stackPop_1;
}

// jmpRTS
// file asm6502.c line 889
static void jmpRTS(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  unsigned short int nr;
  unsigned char return_value_stackPop_1;
  return_value_stackPop_1=stackPop(machine);
  nr = (unsigned short int)return_value_stackPop_1;
  unsigned short int nl;
  unsigned char return_value_stackPop_2;
  return_value_stackPop_2=stackPop(machine);
  nl = (unsigned short int)return_value_stackPop_2;
  warnValue((unsigned char)!(isValue != 0));
  machine->regPC = (unsigned short int)((signed int)nl << 8 | (signed int)nr);
}

// jmpSBC
// file asm6502.c line 898
static void jmpSBC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char c;
  c=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
  unsigned short int tmp;
  unsigned short int w;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  unsigned char return_value_bitOn_5;
  return_value_bitOn_5=bitOn(machine->regP, (enum anonymous_18)DECIMAL_FL);
  if(!(return_value_bitOn_5 == 0))
  {
    unsigned char ar;
    ar=nibble(machine->regA, (enum anonymous_17)RIGHT);
    unsigned char br;
    br=nibble((unsigned char)ptr.value, (enum anonymous_17)RIGHT);
    unsigned char al;
    al=nibble(machine->regA, (enum anonymous_17)LEFT);
    unsigned char bl;
    bl=nibble((unsigned char)ptr.value, (enum anonymous_17)LEFT);
    tmp = (unsigned short int)(((0xf + (signed int)ar) - (signed int)br) + (signed int)c);
    if(!((signed int)tmp >= 0x10))
    {
      w = (unsigned short int)0;
      tmp = tmp - (unsigned short int)6;
    }

    else
    {
      w = (unsigned short int)0x10;
      tmp = tmp - (unsigned short int)0x10;
    }
    w = w + (unsigned short int)((0xf0 + (signed int)al) - (signed int)bl);
    if(!((signed int)w >= 0x100))
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 0);
      unsigned char return_value_bitOn_1;
      return_value_bitOn_1=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_1 == 0))
      {
        if(!((signed int)w >= 0x80))
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

      w = w - (unsigned short int)0x60;
    }

    else
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 1);
      unsigned char return_value_bitOn_2;
      return_value_bitOn_2=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_2 == 0))
      {
        if((signed int)w >= 0x180)
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }
    w = w + tmp;
  }

  else
  {
    w = (unsigned short int)(((0xff + (signed int)machine->regA) - (signed int)ptr.value) + (signed int)c);
    if(!((signed int)w >= 0x100))
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 0);
      unsigned char return_value_bitOn_3;
      return_value_bitOn_3=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_3 == 0))
      {
        if(!((signed int)w >= 0x80))
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }

    else
    {
      machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 1);
      unsigned char return_value_bitOn_4;
      return_value_bitOn_4=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
      if(!(return_value_bitOn_4 == 0))
      {
        if((signed int)w >= 0x180)
          machine->regP=setBit(machine->regP, (enum anonymous_18)OVERFLOW_FL, 0);

      }

    }
  }
  machine->regA = (unsigned char)w;
  manZeroNeg(machine, machine->regA);
}

// jmpSEC
// file asm6502.c line 676
static void jmpSEC(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)CARRY_FL, 1);
}

// jmpSED
// file asm6502.c line 696
static void jmpSED(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)DECIMAL_FL, 1);
}

// jmpSEI
// file asm6502.c line 684
static void jmpSEI(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)INTERRUPT_FL, 1);
}

// jmpSTA
// file asm6502.c line 954
static void jmpSTA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  memStoreByte(machine, (signed int)ptr.addr, (signed int)machine->regA);
}

// jmpSTX
// file asm6502.c line 988
static void jmpSTX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  memStoreByte(machine, (signed int)ptr.addr, (signed int)machine->regX);
}

// jmpSTY
// file asm6502.c line 995
static void jmpSTY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  struct anonymous_15 ptr;
  unsigned char isValue;
  isValue=getValue(machine, adm, &ptr);
  warnValue(isValue);
  memStoreByte(machine, (signed int)ptr.addr, (signed int)machine->regY);
}

// jmpTAX
// file asm6502.c line 786
static void jmpTAX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regX = machine->regA;
  manZeroNeg(machine, machine->regX);
}

// jmpTAY
// file asm6502.c line 810
static void jmpTAY(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regY = machine->regA;
  manZeroNeg(machine, machine->regY);
}

// jmpTSX
// file asm6502.c line 965
static void jmpTSX(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regX=stackPop(machine);
  manZeroNeg(machine, machine->regX);
}

// jmpTXA
// file asm6502.c line 791
static void jmpTXA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regA = machine->regX;
  manZeroNeg(machine, machine->regA);
}

// jmpTXS
// file asm6502.c line 961
static void jmpTXS(struct machine_6502 *machine, enum anonymous_60 adm)
{
  stackPush(machine, machine->regX);
}

// jmpTYA
// file asm6502.c line 815
static void jmpTYA(struct machine_6502 *machine, enum anonymous_60 adm)
{
  machine->regA = machine->regY;
  manZeroNeg(machine, machine->regA);
}

// jumpBranch
// file asm6502.c line 553
static void jumpBranch(struct machine_6502 *machine, unsigned short int offset)
{
  if((signed int)offset >= 128)
    machine->regPC = (unsigned short int)((signed int)machine->regPC - (0x100 - (signed int)offset));

  else
    machine->regPC = (unsigned short int)((signed int)machine->regPC + (signed int)offset);
}

// label
// file asm6502.c line 1548
static unsigned char label(char **s, struct anonymous_8 *param)
{
  char *label__1__label;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)80, sizeof(char) /*1ul*/ );
  label__1__label = (char *)return_value_ecalloc_1;
  char c;
  unsigned char labelOk = (unsigned char)0;
  unsigned char return_value_paramLabel_3;
  return_value_paramLabel_3=paramLabel(s, &label__1__label);
  if(!(return_value_paramLabel_3 == 0))
  {
    labelOk = (unsigned char)1;
    param->type = (enum anonymous_60)ABS_OR_BRANCH;
    unsigned char return_value_getDirection_2;
    return_value_getDirection_2=getDirection(s, &c);
    if(!(return_value_getDirection_2 == 0))
    {
      if((signed int)c == 88)
        param->type = (enum anonymous_60)ABS_LABEL_X;

      else
        if((signed int)c == 89)
          param->type = (enum anonymous_60)ABS_LABEL_Y;

        else
          labelOk = (unsigned char)0;
    }

    strncpy(param->label, label__1__label, (unsigned long int)80);
  }

  free((void *)label__1__label);
  return labelOk;
}

// linkLabels
// file asm6502.c line 2015
static void linkLabels(struct AsmLine *asmlist)
{
  apply(asmlist, linkit, (void *)asmlist);
}

// linkit
// file asm6502.c line 2008
static unsigned char linkit(struct AsmLine *asmline, void *asmlist)
{
  apply((struct AsmLine *)asmlist, changeParamLabelAddr, (void *)asmline->label);
  return (unsigned char)1;
}

// m6502_build
// file asm6502.h line 136
struct machine_6502 * m6502_build(void)
{
  struct machine_6502 *machine;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)1, sizeof(struct machine_6502) /*73072ul*/ );
  machine = (struct machine_6502 *)return_value_ecalloc_1;
  assignOpCodes(machine->opcodes);
  buildIndexCache(machine);
  reset(machine);
  return machine;
}

// m6502_destroy6502
// file asm6502.c line 2113
void m6502_destroy6502(struct machine_6502 *machine)
{
  free((void *)machine);
  machine = (struct machine_6502 *)(void *)0;
}

// m6502_draw
// file m6502.c line 221
static unsigned long int m6502_draw(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct state *st = (struct state *)closure;
  unsigned int x = (unsigned int)0;
  unsigned int y = (unsigned int)0;
  double te;
  const struct analogtv_reception_s *reception = &st->reception;
  m6502_next_eval(st->machine, 500);
  x = (unsigned int)0;
  for( ; !(x >= 32u); x = x + 1u)
  {
    y = (unsigned int)0;
    for( ; !(y >= 32u); y = y + 1u)
      paint_pixel(st, (signed int)x, (signed int)y, (signed int)st->pixels[(signed long int)x][(signed long int)y]);
  }
  analogtv_reception_update(&st->reception);
  analogtv_draw(st->tv, 0.04, &reception, (unsigned int)1);
  te=get_time(st);
  _Bool tmp_if_expr_1;
  if(!(st->reset_p == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = te > (double)st->dt ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    st->reset_p = 0;
    x = (unsigned int)0;
    for( ; !(x >= 32u); x = x + 1u)
    {
      y = (unsigned int)0;
      for( ; !(y >= 32u); y = y + 1u)
        st->pixels[(signed long int)x][(signed long int)y] = (unsigned char)0;
    }
    init_time(st);
    start_rand_bin_prog(st->machine, st);
  }

  return (unsigned long int)5000;
}

// m6502_eval_file
// file asm6502.c line 2180
void m6502_eval_file(struct machine_6502 *machine, const char *filename, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState)
{
  char *code = (char *)(void *)0;
  machine->plot = plot;
  machine->plotterState = plotterState;
  code=fileToBuffer(filename);
  unsigned char return_value_compileCode_1;
  return_value_compileCode_1=compileCode(machine, code);
  if(return_value_compileCode_1 == 0)
    abort();

  free((void *)code);
  machine->regPC = (unsigned short int)1536;
  machine->defaultCodePC = machine->regPC;
  machine->codeRunning = (unsigned char)1;
  do
  {
    sleep((unsigned int)0);
    execute(machine);
  }
  while(!(machine->codeRunning == 0));
}

// m6502_event
// file m6502.c line 282
static signed int m6502_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event)
{
  struct state *st = (struct state *)closure;
  signed int return_value_screenhack_event_helper_1;
  return_value_screenhack_event_helper_1=screenhack_event_helper(dpy, window, event);
  if(!(return_value_screenhack_event_helper_1 == 0))
  {
    st->reset_p = 1;
    return 1;
  }

  else
    return 0;
}

// m6502_free
// file m6502.c line 294
static void m6502_free(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct state *st = (struct state *)closure;
  analogtv_release(st->tv);
  free((void *)st);
}

// m6502_hexDump
// file asm6502.c line 1738
void m6502_hexDump(struct machine_6502 *machine, unsigned short int start, unsigned short int numbytes, struct _IO_FILE *output)
{
  unsigned int address;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= (unsigned int)numbytes); i = i + 1u)
  {
    address = (unsigned int)start + i;
    if((15u & i) == 0u)
      fprintf(output, "\n%.4x: ", address);

    fprintf(output, "%.2x%s", machine->memory[(signed long int)address], (i & (unsigned int)1) != 0u ? " " : "");
  }
  fprintf(output, "%s\n", (i & (unsigned int)1) != 0u ? "--" : "");
}

// m6502_init
// file m6502.c line 119
static void * m6502_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct state *st;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct state) /*1248ul*/ );
  st = (struct state *)return_value_calloc_1;
  unsigned int x;
  unsigned int y;
  signed int n;
  n=get_integer_resource(dpy, "displaytime", "Displaytime");
  signed int dh;
  st->demos = (signed int)(sizeof(const char * const [27l]) /*216ul*/  / sizeof(const char *) /*8ul*/ );
  unsigned int return_value_ya_random_2;
  return_value_ya_random_2=ya_random();
  st->which = (signed int)(return_value_ya_random_2 % (unsigned int)st->demos);
  st->dt = n;
  st->dpy = dpy;
  st->window = window;
  st->tv=analogtv_allocate(st->dpy, st->window);
  analogtv_set_defaults(st->tv, "");
  st->machine=m6502_build();
  st->inp=analogtv_input_allocate();
  analogtv_setup_sync(st->inp, 1, 0);
  st->reception.input = st->inp;
  st->reception.level = 2.0;
  st->reception.ofs = (double)0;
  st->reception.multipath = 0.0;
  st->pixw = 566 / 32;
  st->pixh = 200 / 32;
  dh = 200 % 32;
  st->topb = dh / 2;
  init_time(st);
  char *s;
  s=get_string_resource(dpy, "file", "File");
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(s);
  if(return_value_strlen_3 >= 1ul)
    m6502_start_eval_file(st->machine, s, plot6502, (void *)st);

  else
    start_rand_bin_prog(st->machine, st);
  analogtv_lcp_to_ntsc((double)10, 0.0, 0.0, st->field_ntsc);
  analogtv_draw_solid(st->inp, 229, 795, 30, 230, st->field_ntsc);
  x = (unsigned int)0;
  for( ; !(x >= 32u); x = x + 1u)
  {
    y = (unsigned int)0;
    for( ; !(y >= 32u); y = y + 1u)
      st->pixels[(signed long int)x][(signed long int)y] = (unsigned char)0;
  }
  return (void *)st;
}

// m6502_next_eval
// file asm6502.h line 162
void m6502_next_eval(struct machine_6502 *machine, signed int insno)
{
  signed int i = 0;
  i = 1;
  for( ; !(i >= insno); i = i + 1)
    if(!(machine->codeRunning == 0))
      execute(machine);

    else
      break;
}

// m6502_reshape
// file m6502.c line 274
static void m6502_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h)
{
  struct state *st = (struct state *)closure;
  analogtv_reconfigure(st->tv);
}

// m6502_start_eval_file
// file asm6502.h line 149
void m6502_start_eval_file(struct machine_6502 *machine, const char *filename, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState)
{
  char *code = (char *)(void *)0;
  reset(machine);
  machine->plot = plot;
  machine->plotterState = plotterState;
  code=fileToBuffer(filename);
  unsigned char return_value_compileCode_1;
  return_value_compileCode_1=compileCode(machine, code);
  if(return_value_compileCode_1 == 0)
    abort();

  free((void *)code);
  machine->regPC = (unsigned short int)1536;
  machine->defaultCodePC = machine->regPC;
  machine->codeRunning = (unsigned char)1;
  execute(machine);
}

// m6502_start_eval_string
// file asm6502.h line 158
void m6502_start_eval_string(struct machine_6502 *machine, const char *code, void (*plot)(unsigned char, unsigned char, unsigned char, void *), void *plotterState)
{
  reset(machine);
  machine->plot = plot;
  machine->plotterState = plotterState;
  unsigned char return_value_compileCode_1;
  return_value_compileCode_1=compileCode(machine, code);
  if(return_value_compileCode_1 == 0)
    fprintf(stderr, "Could not compile code.\n");

  machine->regPC = (unsigned short int)1536;
  machine->defaultCodePC = machine->regPC;
  machine->codeRunning = (unsigned char)1;
  execute(machine);
}

// m6502_trace
// file asm6502.c line 2118
void m6502_trace(struct machine_6502 *machine, struct _IO_FILE *output)
{
  unsigned char opcode;
  signed int return_value_memReadByte_1;
  return_value_memReadByte_1=memReadByte(machine, (signed int)machine->regPC);
  opcode = (unsigned char)return_value_memReadByte_1;
  enum anonymous_60 adm;
  struct anonymous_15 ptr;
  signed int opidx;
  opidx=opIndex(machine, opcode, &adm);
  signed int stacksz = 511 - (signed int)machine->regSP;
  unsigned char return_value_bitOn_2;
  return_value_bitOn_2=bitOn(machine->regP, (enum anonymous_18)NEGATIVE_FL);
  unsigned char return_value_bitOn_3;
  return_value_bitOn_3=bitOn(machine->regP, (enum anonymous_18)OVERFLOW_FL);
  unsigned char return_value_bitOn_4;
  return_value_bitOn_4=bitOn(machine->regP, (enum anonymous_18)FUTURE_FL);
  unsigned char return_value_bitOn_5;
  return_value_bitOn_5=bitOn(machine->regP, (enum anonymous_18)BREAK_FL);
  unsigned char return_value_bitOn_6;
  return_value_bitOn_6=bitOn(machine->regP, (enum anonymous_18)DECIMAL_FL);
  unsigned char return_value_bitOn_7;
  return_value_bitOn_7=bitOn(machine->regP, (enum anonymous_18)INTERRUPT_FL);
  unsigned char return_value_bitOn_8;
  return_value_bitOn_8=bitOn(machine->regP, (enum anonymous_18)ZERO_FL);
  unsigned char return_value_bitOn_9;
  return_value_bitOn_9=bitOn(machine->regP, (enum anonymous_18)CARRY_FL);
  fprintf(output, "\n   NVFBDIZC\nP: %d%d%d%d%d%d%d%d ", return_value_bitOn_2, return_value_bitOn_3, return_value_bitOn_4, return_value_bitOn_5, return_value_bitOn_6, return_value_bitOn_7, return_value_bitOn_8, return_value_bitOn_9);
  fprintf(output, "A: %.2x X: %.2x Y: %.2x SP: %.4x PC: %.4x\n", machine->regA, machine->regX, machine->regY, machine->regSP, machine->regPC);
  if(opidx >= 0)
  {
    unsigned short int pc = machine->regPC;
    fprintf(output, "\n%.4x:\t%s", machine->regPC, (const void *)machine->opcodes[(signed long int)opidx].name);
    unsigned char return_value_peekValue_10;
    return_value_peekValue_10=peekValue(machine, adm, &ptr, (unsigned short int)((signed int)pc + 1));
    if(!(return_value_peekValue_10 == 0))
      fprintf(output, "\tAddress:%.4x\tValue:%.4x\n", ptr.addr, ptr.value);

    else
      fprintf(output, "\n");
  }

  fprintf(output, "STACK:");
  m6502_hexDump(machine, (unsigned short int)((511 - stacksz) + 1), (unsigned short int)stacksz, output);
}

// main
// file screenhack.c line 696
signed int main(signed int argc, char **argv)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  struct anonymous_7 xgwa;
  struct _WidgetRec *toplevel;
  struct _XDisplay *dpy;
  unsigned long int window;
  unsigned long int window2 = (unsigned long int)0;
  struct _WidgetRec *toplevel2 = ((struct _WidgetRec *)NULL);
  struct _XtAppStruct *app;
  signed int root_p;
  unsigned long int on_window = (unsigned long int)0;
  union _XEvent event;
  char dont_clear;
  char version[255l];
  fix_fds();
  progname = argv[(signed long int)0];
  progclass = ft->progclass;
  if(!(ft->setup_cb == ((void (*)(struct xscreensaver_function_table *, void *))NULL)))
    ft->setup_cb(ft, ft->setup_arg);

  merge_options();
  toplevel=XtAppInitialize(&app, progclass, merged_options, (unsigned int)merged_options_size, &argc, argv, merged_defaults, ((struct anonymous_68 *)NULL), (unsigned int)0);
  dpy = toplevel->core.screen->display;
  XtGetApplicationNameAndClass(dpy, (char **)&progname, (char **)&progclass);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  if(return_value_strlen_1 >= 100ul)
    ((char *)progname)[(signed long int)100] = (char)0;

  XSetErrorHandler(screenhack_ehandler);
  XA_WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  XA_WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  char *v;
  char *return_value_strchr_2;
  return_value_strchr_2=strchr(screensaver_id, 32);
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(return_value_strchr_2);
  v = (char *)return_value_strdup_3;
  char *s1;
  char *s2;
  char *s3;
  char *s4;
  const char *ot;
  ot=get_string_resource(dpy, "title", "Title");
  char *return_value_strchr_4;
  return_value_strchr_4=strchr(v, 32);
  s1 = (char *)return_value_strchr_4;
  s1 = s1 + 1l;
  char *return_value_strchr_5;
  return_value_strchr_5=strchr(s1, 32);
  s2 = (char *)return_value_strchr_5;
  char *return_value_strchr_6;
  return_value_strchr_6=strchr(v, 40);
  s3 = (char *)return_value_strchr_6;
  s3 = s3 + 1l;
  char *return_value_strchr_7;
  return_value_strchr_7=strchr(s3, 41);
  s4 = (char *)return_value_strchr_7;
  *s2 = (char)0;
  *s4 = (char)0;
  if(!(ot == ((const char *)NULL)))
  {
    if(*ot == 0)
      ot = ((const char *)NULL);

  }

  sprintf(version, "%.50s%s%s: from the XScreenSaver %s distribution (%s)", ot != ((const char *)NULL) ? ot : "", ot != ((const char *)NULL) ? ": " : "", progclass, s1, s3);
  free((void *)v);
  signed int return_value_strcmp_9;
  if(argc >= 2)
  {
    const char *main__1__2__s;
    signed int i;
    signed int x = 18;
    signed int end = 78;
    signed int help_p;
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)1], "-help");
    _Bool tmp_if_expr_10;
    if(return_value_strcmp_8 == 0)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(argv[(signed long int)1], "--help");
      tmp_if_expr_10 = !(return_value_strcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    help_p = (signed int)tmp_if_expr_10;
    fprintf(stderr, "%s\n", (const void *)version);
    main__1__2__s = progclass;
    for( ; !(*main__1__2__s == 0); main__1__2__s = main__1__2__s + 1l)
      fprintf(stderr, " ");
    fprintf(stderr, "  http://www.jwz.org/xscreensaver/\n\n");
    if(help_p == 0)
      fprintf(stderr, "Unrecognised option: %s\n", argv[(signed long int)1]);

    fprintf(stderr, "Options include: ");
    i = 0;
    for( ; !(i >= merged_options_size); i = i + 1)
    {
      char *sw = (merged_options + (signed long int)i)->option;
      signed int argp = (signed int)((signed int)(merged_options + (signed long int)i)->argKind == XrmoptionSepArg);
      signed int size;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(sw);
      size = (signed int)(return_value_strlen_11 + (unsigned long int)(argp != 0 ? 6 : 0) + (unsigned long int)2);
      if(size + x >= end)
      {
        fprintf(stderr, "\n\t\t ");
        x = 18;
      }

      x = x + size;
      fprintf(stderr, "%s", sw);
      if(!(argp == 0))
        fprintf(stderr, " <arg>");

      if(!(i == merged_options_size + -1))
        fprintf(stderr, ", ");

    }
    fprintf(stderr, ".\n");
    exit(help_p != 0 ? 0 : 1);
  }

  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    free((void *)*s);
  free((void *)merged_options);
  free((void *)merged_defaults);
  merged_options = ((struct anonymous_65 *)NULL);
  merged_defaults = ((char **)NULL);
  signed int return_value_get_boolean_resource_12;
  return_value_get_boolean_resource_12=get_boolean_resource(dpy, "dontClearRoot", "Boolean");
  dont_clear = (char)return_value_get_boolean_resource_12;
  mono_p=get_boolean_resource(dpy, "mono", "Boolean");
  if(!((((struct anonymous_2 *)dpy)->screens + (signed long int)((struct anonymous_2 *)dpy)->default_screen)->root_visual->map_entries >= 3))
    mono_p = 1;

  root_p=get_boolean_resource(dpy, "root", "Boolean");
  char *main__1__4__s;
  main__1__4__s=get_string_resource(dpy, "windowID", "WindowID");
  signed int return_value_get_integer_resource_13;
  if(!(main__1__4__s == ((char *)NULL)))
  {
    if(!(*main__1__4__s == 0))
    {
      return_value_get_integer_resource_13=get_integer_resource(dpy, "windowID", "WindowID");
      on_window = (unsigned long int)return_value_get_integer_resource_13;
    }

  }

  if(!(main__1__4__s == ((char *)NULL)))
    free((void *)main__1__4__s);

  if(!(on_window == 0ul))
  {
    window = (unsigned long int)on_window;
    XtDestroyWidget(toplevel);
    XGetWindowAttributes(dpy, window, &xgwa);
    visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 1);
    xgwa.your_event_mask = xgwa.your_event_mask | 1L << 0 | 1L << 17;
    XSelectInput(dpy, window, xgwa.your_event_mask);
    if((12l & xgwa.all_event_masks) == 0l)
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 2 | 1L << 3);

  }

  else
    if(!(root_p == 0))
    {
      window=VirtualRootWindowOfScreen(toplevel->core.screen);
      XtDestroyWidget(toplevel);
      XGetWindowAttributes(dpy, window, &xgwa);
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 17);
      visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 0);
    }

    else
    {
      struct _WidgetRec *new;
      new=make_shell(toplevel->core.screen, toplevel, (signed int)toplevel->core.width, (signed int)toplevel->core.height);
      if(!(new == toplevel))
      {
        XtDestroyWidget(toplevel);
        toplevel = new;
      }

      init_window(dpy, toplevel, version);
      window = toplevel->core.window;
      XGetWindowAttributes(dpy, window, &xgwa);
      signed int return_value_get_boolean_resource_14;
      return_value_get_boolean_resource_14=get_boolean_resource(dpy, "pair", "Boolean");
      if(!(return_value_get_boolean_resource_14 == 0))
      {
        toplevel2=make_shell(xgwa.screen, ((struct _WidgetRec *)NULL), (signed int)toplevel->core.width, (signed int)toplevel->core.height);
        init_window(dpy, toplevel2, version);
        window2 = toplevel2->core.window;
      }

    }
  if(dont_clear == 0)
  {
    unsigned int bg;
    bg=get_pixel_resource(dpy, xgwa.colormap, "background", "Background");
    XSetWindowBackground(dpy, window, (unsigned long int)bg);
    XClearWindow(dpy, window);
    if(!(window2 == 0ul))
    {
      XSetWindowBackground(dpy, window2, (unsigned long int)bg);
      XClearWindow(dpy, window2);
    }

  }

  if(root_p == 0 && on_window == 0ul)
    XIfEvent(dpy, &event, MapNotify_event_p, (char *)window);

  XSync(dpy, 0);
  ya_rand_init((unsigned int)0);
  run_screenhack_table(dpy, window, window2, ft);
  XtDestroyWidget(toplevel);
  XtDestroyApplicationContext(app);
  return 0;
}

// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_25 *screen, struct _WidgetRec *toplevel, signed int width, signed int height)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_13 *visual;
  visual=pick_visual(screen);
  char def_visual_p;
  _Bool tmp_if_expr_1;
  if(!(toplevel == ((struct _WidgetRec *)NULL)))
    tmp_if_expr_1 = visual == screen->root_visual ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  def_visual_p = (char)tmp_if_expr_1;
  if(!(width >= 1))
    width = 600;

  if(!(height >= 1))
    height = 480;

  if(!(def_visual_p == 0))
  {
    unsigned long int window;
    XtVaSetValues(toplevel, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    XtRealizeWidget(toplevel);
    window = toplevel->core.window;
    signed int return_value_get_boolean_resource_2;
    return_value_get_boolean_resource_2=get_boolean_resource(dpy, "installColormap", "InstallColormap");
    if(!(return_value_get_boolean_resource_2 == 0))
    {
      unsigned long int make_shell__1__1__1__cmap;
      make_shell__1__1__1__cmap=XCreateColormap(dpy, window, screen->root_visual, 0);
      XSetWindowColormap(dpy, window, make_shell__1__1__1__cmap);
    }

  }

  else
  {
    unsigned int bg;
    unsigned int bd;
    struct _WidgetRec *new;
    unsigned long int cmap;
    unsigned long int return_value_VirtualRootWindowOfScreen_3;
    return_value_VirtualRootWindowOfScreen_3=VirtualRootWindowOfScreen(screen);
    cmap=XCreateColormap(dpy, return_value_VirtualRootWindowOfScreen_3, visual, 0);
    bg=get_pixel_resource(dpy, cmap, "background", "Background");
    bd=get_pixel_resource(dpy, cmap, "borderColor", "Foreground");
    signed int return_value_visual_depth_4;
    return_value_visual_depth_4=visual_depth(screen, visual);
    new=XtVaAppCreateShell(progname, progclass, topLevelShellWidgetClass, dpy, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtShellStrings[(signed long int)104], visual, (char *)&XtStrings[(signed long int)163], return_value_visual_depth_4, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtStrings[(signed long int)154], cmap, (char *)&XtStrings[(signed long int)52], (unsigned long int)bg, (char *)&XtStrings[(signed long int)87], (unsigned long int)bd, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    if(toplevel == ((struct _WidgetRec *)NULL))
      XtVaSetValues(new, (char *)&XtStrings[(signed long int)885], 0, (char *)&XtStrings[(signed long int)887], 550, (void *)0);

    XtRealizeWidget(new);
    toplevel = new;
  }
  return toplevel;
}

// manZeroNeg
// file asm6502.c line 454
static void manZeroNeg(struct machine_6502 *machine, unsigned char value)
{
  machine->regP=setBit(machine->regP, (enum anonymous_18)ZERO_FL, (signed int)((signed int)value == 0));
  unsigned char return_value_bitOn_1;
  return_value_bitOn_1=bitOn(value, (enum anonymous_18)NEGATIVE_FL);
  machine->regP=setBit(machine->regP, (enum anonymous_18)NEGATIVE_FL, (signed int)return_value_bitOn_1);
}

// memReadByte
// file asm6502.c line 206
static signed int memReadByte(struct machine_6502 *machine, signed int addr)
{
  unsigned int return_value_ya_random_1;
  double return_value_floor_2;
  if(addr == 0xfe)
  {
    return_value_ya_random_1=ya_random();
    return_value_floor_2=floor((double)(return_value_ya_random_1 % (unsigned int)255));
    return (signed int)return_value_floor_2;
  }

  return (signed int)machine->memory[(signed long int)addr];
}

// memStoreByte
// file asm6502.c line 227
static void memStoreByte(struct machine_6502 *machine, signed int addr, signed int value)
{
  machine->memory[(signed long int)addr] = (unsigned char)(value & 0xff);
  if(addr >= 0x200 && !(addr >= 1536))
    updateDisplayPixel(machine, (unsigned short int)addr);

}

// merge_options
// file screenhack.c line 182
static void merge_options(void)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  const struct anonymous_65 *options = ft->options;
  const char * const *defaults = ft->defaults;
  const char *merge_options__1__progclass = ft->progclass;
  signed int def_opts_size;
  signed int opts_size;
  signed int def_defaults_size;
  signed int defaults_size;
  def_opts_size = 0;
  for( ; !(default_options[(signed long int)def_opts_size].option == ((char *)NULL)); def_opts_size = def_opts_size + 1)
    ;
  opts_size = 0;
  for( ; !((options + (signed long int)opts_size)->option == ((char *)NULL)); opts_size = opts_size + 1)
    ;
  merged_options_size = def_opts_size + opts_size;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(merged_options_size + 1) * sizeof(struct anonymous_65) /*32ul*/ );
  merged_options = (struct anonymous_65 *)return_value_malloc_1;
  memcpy((void *)merged_options, (const void *)default_options, (unsigned long int)def_opts_size * sizeof(struct anonymous_65) /*32ul*/ );
  memcpy((void *)(merged_options + (signed long int)def_opts_size), (const void *)options, (unsigned long int)(opts_size + 1) * sizeof(struct anonymous_65) /*32ul*/ );
  def_defaults_size = 0;
  for( ; !(default_defaults[(signed long int)def_defaults_size] == ((char *)NULL)); def_defaults_size = def_defaults_size + 1)
    ;
  defaults_size = 0;
  for( ; !(defaults[(signed long int)defaults_size] == ((const char *)NULL)); defaults_size = defaults_size + 1)
    ;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(def_defaults_size + defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  merged_defaults = (char **)return_value_malloc_2;
  memcpy((void *)merged_defaults, (const void *)default_defaults, (unsigned long int)def_defaults_size * sizeof(const char *) /*8ul*/ );
  memcpy((void *)(merged_defaults + (signed long int)def_defaults_size), (const void *)defaults, (unsigned long int)(defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    if((signed int)*(*s) == 46)
    {
      const char *oldr = *s;
      char *newr;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(oldr);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(merge_options__1__progclass);
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)3);
      newr = (char *)return_value_malloc_5;
      strcpy(newr, merge_options__1__progclass);
      strcat(newr, oldr);
      *s = newr;
    }

    else
      *s=strdup(*s);
}

// newAsmLine
// file asm6502.c line 1170
static struct AsmLine * newAsmLine(char *cmd, char *label, unsigned char decl, struct anonymous_8 *param, signed int lc)
{
  struct AsmLine *newp;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)1, sizeof(struct AsmLine) /*40ul*/ );
  newp = (struct AsmLine *)return_value_ecalloc_1;
  newp->labelDecl = decl;
  newp->label=newLabel();
  strncpy(newp->label->label, label, (unsigned long int)80);
  newp->command=estrdup(cmd);
  newp->param=newParam();
  copyParam(newp->param, param);
  newp->next = (struct AsmLine *)(void *)0;
  return newp;
}

// newLabel
// file asm6502.c line 1160
static struct anonymous_12 * newLabel(void)
{
  struct anonymous_12 *newp;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)1, sizeof(struct anonymous_12) /*16ul*/ );
  newp = (struct anonymous_12 *)return_value_ecalloc_1;
  newp->addr = (unsigned int)0;
  void *return_value_ecalloc_2;
  return_value_ecalloc_2=ecalloc((unsigned int)80, sizeof(char) /*1ul*/ );
  newp->label = (char *)return_value_ecalloc_2;
  return newp;
}

// newParam
// file asm6502.c line 1136
static struct anonymous_8 * newParam(void)
{
  struct anonymous_8 *newp;
  signed int i = 0;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)1, sizeof(struct anonymous_8) /*128ul*/ );
  newp = (struct anonymous_8 *)return_value_ecalloc_1;
  newp->type = (enum anonymous_60)SINGLE;
  i = 0;
  for( ; !(i >= 25); i = i + 1)
    newp->value[(signed long int)i] = (unsigned int)0;
  newp->vp = (unsigned int)0;
  void *return_value_ecalloc_2;
  return_value_ecalloc_2=ecalloc((unsigned int)80, sizeof(char) /*1ul*/ );
  newp->label = (char *)return_value_ecalloc_2;
  newp->lbladdr = (unsigned int)0;
  return newp;
}

// nibble
// file asm6502.c line 255
static unsigned char nibble(unsigned char value, enum anonymous_17 side)
{
  switch((signed int)side)
  {
    case LEFT:
      return (unsigned char)((signed int)value & 0xf0);
    case RIGHT:
      return (unsigned char)((signed int)value & 0xf);
    default:
    {
      fprintf(stderr, "nibble unknown side\n");
      return (unsigned char)0;
    }
  }
}

// nullify
// file asm6502.c line 1264
static void nullify(char *token, unsigned int sourceLength)
{
  unsigned int i = (unsigned int)0;
  while(!(i >= sourceLength))
  {
    unsigned int tmp_post_1 = i;
    i = i + 1u;
    token[(signed long int)tmp_post_1] = (char)0;
  }
}

// opIndex
// file asm6502.c line 1127
static signed int opIndex(struct machine_6502 *machine, unsigned char opcode, enum anonymous_60 *adm)
{
  *adm = machine->opcache[(signed long int)opcode].adm;
  return (signed int)machine->opcache[(signed long int)opcode].index;
}

// paint_pixel
// file m6502.c line 174
static void paint_pixel(struct state *st, signed int x, signed int y, signed int idx)
{
  double clr_tbl[16l][3l] = { { (double)0, (double)0, (double)0 }, { (double)255, (double)255, (double)255 },
    { (double)136, (double)0, (double)0 }, { (double)170, (double)255, (double)238 },
    { (double)204, (double)68, (double)204 },
    { (double)0, (double)204, (double)85 }, { (double)0, (double)0, (double)170 }, { (double)238, (double)238, (double)119 },
    { (double)221, (double)136, (double)85 },
    { (double)102, (double)68, (double)0 }, { (double)255, (double)119, (double)119 },
    { (double)51, (double)51, (double)51 }, { (double)119, (double)119, (double)119 },
    { (double)170, (double)255, (double)102 },
    { (double)0, (double)136, (double)255 },
    { (double)187, (double)187, (double)187 } };
  signed int ntsc[4l];
  signed int i;
  signed int rawy;
  signed int rawi;
  signed int rawq;
  rawy = (signed int)(((double)5 * clr_tbl[(signed long int)idx][(signed long int)0] + (double)11 * clr_tbl[(signed long int)idx][(signed long int)1] + (double)2 * clr_tbl[(signed long int)idx][(signed long int)2]) / (double)64);
  rawi = (signed int)((((double)10 * clr_tbl[(signed long int)idx][(signed long int)0] - (double)4 * clr_tbl[(signed long int)idx][(signed long int)1]) - (double)5 * clr_tbl[(signed long int)idx][(signed long int)2]) / (double)64);
  rawq = (signed int)((((double)3 * clr_tbl[(signed long int)idx][(signed long int)0] - (double)8 * clr_tbl[(signed long int)idx][(signed long int)1]) + (double)5 * clr_tbl[(signed long int)idx][(signed long int)2]) / (double)64);
  ntsc[(signed long int)0] = rawy + rawq;
  ntsc[(signed long int)1] = rawy - rawi;
  ntsc[(signed long int)2] = rawy - rawq;
  ntsc[(signed long int)3] = rawy + rawi;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    if(ntsc[(signed long int)i] >= 101)
      ntsc[(signed long int)i] = 100;

    if(!(ntsc[(signed long int)i] >= 10))
      ntsc[(signed long int)i] = 10;

  }
  x = x * st->pixw;
  y = y * st->pixh;
  y = y + st->topb;
  analogtv_draw_solid(st->inp, 229 + x, 229 + x + st->pixw, 30 + y, 30 + y + st->pixh, ntsc);
}

// paramLabel
// file asm6502.c line 1390
static unsigned char paramLabel(char **s, char **label)
{
  signed int i = 0;
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_2;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*(*s)]) == 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*(*s) == 95 ? (_Bool)1 : (_Bool)0;
    if(i >= 80 || !tmp_if_expr_2)
      break;

    signed int tmp_post_3 = i;
    i = i + 1;
    (*label)[(signed long int)tmp_post_3] = *(*s);
    *s = *s + 1l;
  }
  while((_Bool)1);
  if(i >= 1)
    return (unsigned char)1;

  else
    return (unsigned char)0;
}

// parameter
// file asm6502.c line 1569
static unsigned char parameter(const char *cmd, char **s, struct anonymous_8 *param)
{
  skipSpace(s);
  _Bool tmp_if_expr_10;
  if((signed int)*(*s) == 0)
    tmp_if_expr_10 = (_Bool)1;

  else
    tmp_if_expr_10 = (signed int)*(*s) == 10 ? (_Bool)1 : (_Bool)0;
  unsigned char return_value_immediate_1;
  unsigned char return_value_indirect_2;
  const unsigned short int **return_value___ctype_b_loc_8;
  unsigned char return_value_dcbValue_3;
  unsigned char return_value_value_4;
  const unsigned short int **return_value___ctype_b_loc_7;
  unsigned char return_value_label_6;
  if(tmp_if_expr_10)
    return (unsigned char)1;

  else
    if((signed int)*(*s) == 35)
    {
      return_value_immediate_1=immediate(s, param);
      return return_value_immediate_1;
    }

    else
      if((signed int)*(*s) == 40)
      {
        return_value_indirect_2=indirect(s, param);
        return return_value_indirect_2;
      }

      else
      {
        _Bool tmp_if_expr_9;
        if((signed int)*(*s) == 36)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value___ctype_b_loc_8=__ctype_b_loc();
          tmp_if_expr_9 = ((signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)*(*s)] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
        {
          signed int return_value_strcmp_5;
          return_value_strcmp_5=strcmp(cmd, "DCB");
          if(return_value_strcmp_5 == 0)
          {
            return_value_dcbValue_3=dcbValue(s, param);
            return return_value_dcbValue_3;
          }

          else
          {
            return_value_value_4=value(s, param);
            return return_value_value_4;
          }
        }

        else
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*(*s)]) == 0))
          {
            return_value_label_6=label(s, param);
            return return_value_label_6;
          }

          else
            return (unsigned char)0;
        }
      }
}

// parseAssembly
// file asm6502.c line 1606
static struct AsmLine * parseAssembly(struct machine_6502 *machine, unsigned char *codeOk, const char *code)
{
  char *s;
  char *cmd;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)4, sizeof(char) /*1ul*/ );
  cmd = (char *)return_value_ecalloc_1;
  char *parseAssembly__1__label;
  void *return_value_ecalloc_2;
  return_value_ecalloc_2=ecalloc((unsigned int)80, sizeof(char) /*1ul*/ );
  parseAssembly__1__label = (char *)return_value_ecalloc_2;
  char *start;
  unsigned int lc = (unsigned int)1;
  struct anonymous_8 *param;
  unsigned char decl;
  struct AsmLine *listp = (struct AsmLine *)(void *)0;
  *codeOk = (unsigned char)1;
  param=newParam();
  s=estrdup(code);
  start = s;
  stoupper(&s);
  unsigned char return_value_hasChar_4;
  while(!((signed int)*s == 0))
  {
    if(*codeOk == 0)
      break;

    initParam(param);
    nullify(cmd, (unsigned int)4);
    nullify(parseAssembly__1__label, (unsigned int)80);
    decl = (unsigned char)0;
    skipSpace(&s);
    comment(&s);
    if((signed int)*s == 10)
    {
      lc = lc + 1u;
      s = s + 1l;
      continue;
    }

    else
      if((signed int)*s == 0)
        continue;

      else
      {
        return_value_hasChar_4=hasChar(s, (char)58);
        if(!(return_value_hasChar_4 == 0))
        {
          decl = (unsigned char)1;
          unsigned char return_value_declareLabel_3;
          return_value_declareLabel_3=declareLabel(&s, &parseAssembly__1__label);
          if(return_value_declareLabel_3 == 0)
          {
            *codeOk = (unsigned char)0;
            break;
          }

          skipSpace(&s);
        }

      }
    unsigned char return_value_command_5;
    return_value_command_5=command(machine, &s, &cmd);
    if(return_value_command_5 == 0)
    {
      *codeOk = (unsigned char)0;
      break;
    }

    skipSpace(&s);
    comment(&s);
    unsigned char return_value_parameter_6;
    return_value_parameter_6=parameter(cmd, &s, param);
    if(return_value_parameter_6 == 0)
    {
      *codeOk = (unsigned char)0;
      break;
    }

    skipSpace(&s);
    comment(&s);
    _Bool tmp_if_expr_7;
    if((signed int)*s == 10)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)*s == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
    {
      struct AsmLine *asmm;
      asmm=newAsmLine(cmd, parseAssembly__1__label, decl, param, (signed int)lc);
      listp=addend(listp, asmm);
    }

    else
    {
      *codeOk = (unsigned char)0;
      break;
    }
  }
  if(*codeOk == 0)
    fprintf(stderr, "Syntax error at line %u\n", lc);

  free((void *)start);
  free((void *)cmd);
  free((void *)parseAssembly__1__label);
  freeParam(param);
  return listp;
}

// parseDec
// file asm6502.c line 1364
static unsigned char parseDec(char **s, unsigned int *value)
{
  char *dec;
  void *return_value_ecalloc_1;
  return_value_ecalloc_1=ecalloc((unsigned int)4, sizeof(char) /*1ul*/ );
  dec = (char *)return_value_ecalloc_1;
  signed int i = 0;
  const unsigned short int **return_value___ctype_b_loc_2;
  do
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*(*s)]) == 0 || i >= 4)
      break;

    signed int tmp_post_3 = i;
    i = i + 1;
    dec[(signed long int)tmp_post_3] = *(*s);
    *s = *s + 1l;
  }
  while((_Bool)1);
  if(i >= 1)
  {
    signed int return_value_atoi_4;
    return_value_atoi_4=atoi(dec);
    *value = (unsigned int)return_value_atoi_4;
    free((void *)dec);
    return (unsigned char)1;
  }

  else
  {
    free((void *)dec);
    return (unsigned char)0;
  }
}

// parseError
// file asm6502.c line 1241
static void parseError(char *s)
{
  fprintf(stderr, "6502 Syntax Error: %s\n", s);
}

// parseHex
// file asm6502.c line 1346
static unsigned char parseHex(char **s, unsigned int *value)
{
  unsigned char return_value_ishexdigit_2;
  if((signed int)*(*s) == 36)
  {
    char *hex;
    void *return_value_ecalloc_1;
    return_value_ecalloc_1=ecalloc((unsigned int)5, sizeof(char) /*1ul*/ );
    hex = (char *)return_value_ecalloc_1;
    signed int i = 0;
    *s = *s + 1l;
    do
    {
      return_value_ishexdigit_2=ishexdigit(*(*s));
      if(return_value_ishexdigit_2 == 0 || i >= 5)
        break;

      signed int tmp_post_3 = i;
      i = i + 1;
      hex[(signed long int)tmp_post_3] = *(*s);
      *s = *s + 1l;
    }
    while((_Bool)1);
    signed long int return_value_strtol_4;
    return_value_strtol_4=strtol(hex, (char ** restrict )(void *)0, 16);
    *value = (unsigned int)return_value_strtol_4;
    free((void *)hex);
    return (unsigned char)1;
  }

  else
    return (unsigned char)0;
}

// parseValue
// file asm6502.c line 1382
static unsigned char parseValue(char **s, unsigned int *value)
{
  skipSpace(s);
  unsigned char return_value_parseHex_1;
  unsigned char return_value_parseDec_2;
  if((signed int)*(*s) == 36)
  {
    return_value_parseHex_1=parseHex(s, value);
    return return_value_parseHex_1;
  }

  else
  {
    return_value_parseDec_2=parseDec(s, value);
    return return_value_parseDec_2;
  }
}

// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p)
{
  unsigned int h;
  unsigned int m;
  unsigned int s;
  char c;
  signed int return_value___isoc99_sscanf_6;
  return_value___isoc99_sscanf_6=__isoc99_sscanf(string, " %u : %2u : %2u %c", &h, &m, &s, &c);
  signed int return_value___isoc99_sscanf_3;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_2;
  signed int return_value___isoc99_sscanf_1;
  if(!(return_value___isoc99_sscanf_6 == 3))
  {
    return_value___isoc99_sscanf_3=__isoc99_sscanf(string, " : %2u : %2u %c", &m, &s, &c);
    _Bool tmp_if_expr_5;
    if(return_value___isoc99_sscanf_3 == 2)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___isoc99_sscanf_4=__isoc99_sscanf(string, " %u : %2u %c", &m, &s, &c);
      tmp_if_expr_5 = 2 == return_value___isoc99_sscanf_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      h = (unsigned int)0;

    else
    {
      return_value___isoc99_sscanf_2=__isoc99_sscanf(string, " : %2u %c", &s, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        m = (unsigned int)0;
        h = m;
      }

      else
      {
        return_value___isoc99_sscanf_1=__isoc99_sscanf(string, " %u %c", seconds_default_p != 0 ? &s : &m, &c);
        if(return_value___isoc99_sscanf_1 == 1)
        {
          h = (unsigned int)0;
          if(!(seconds_default_p == 0))
            m = (unsigned int)0;

          else
            s = (unsigned int)0;
        }

        else
        {
          if(silent_p == 0)
            fprintf(stderr, "%s: invalid time interval specification \"%s\".\n", progname, string);

          return -1;
        }
      }
    }
  }

  if(s >= 60u && (!(h == 0u) || !(m == 0u)))
  {
    if(silent_p == 0)
      fprintf(stderr, "%s: seconds > 59 in \"%s\".\n", progname, string);

    return -1;
  }

  else
    if(h >= 1u && m >= 60u)
    {
      if(silent_p == 0)
        fprintf(stderr, "%s: minutes > 59 in \"%s\".\n", progname, string);

      return -1;
    }

    else
      return (signed int)(h * (unsigned int)60 * (unsigned int)60 + m * (unsigned int)60 + s);
}

// peekValue
// file asm6502.c line 267
static unsigned char peekValue(struct machine_6502 *machine, enum anonymous_60 adm, struct anonymous_15 *pointer, unsigned short int PC)
{
  unsigned char zp;
  pointer->value = (unsigned short int)0;
  pointer->addr = (unsigned short int)0;
  signed int return_value_memReadByte_1;
  signed int return_value_memReadByte_2;
  signed int return_value_memReadByte_3;
  signed int return_value_memReadByte_4;
  signed int return_value_memReadByte_5;
  signed int return_value_memReadByte_6;
  signed int return_value_memReadByte_7;
  signed int return_value_memReadByte_8;
  signed int return_value_memReadByte_9;
  signed int return_value_memReadByte_10;
  signed int return_value_memReadByte_11;
  signed int return_value_memReadByte_12;
  signed int return_value_memReadByte_13;
  signed int return_value_memReadByte_14;
  signed int return_value_memReadByte_15;
  signed int return_value_memReadByte_16;
  signed int return_value_memReadByte_17;
  signed int return_value_memReadByte_18;
  signed int return_value_memReadByte_19;
  signed int return_value_memReadByte_20;
  signed int return_value_memReadByte_21;
  signed int return_value_memReadByte_22;
  signed int return_value_memReadByte_23;
  signed int return_value_memReadByte_24;
  signed int return_value_memReadByte_25;
  switch((signed int)adm)
  {
    case SINGLE:
      return (unsigned char)0;
    case IMMEDIATE_LESS:

    case IMMEDIATE_GREAT:

    case IMMEDIATE_VALUE:
    {
      return_value_memReadByte_1=memReadByte(machine, (signed int)PC);
      pointer->value = (unsigned short int)return_value_memReadByte_1;
      return (unsigned char)1;
    }
    case INDIRECT_X:
    {
      return_value_memReadByte_2=memReadByte(machine, (signed int)PC);
      zp = (unsigned char)(return_value_memReadByte_2 + (signed int)machine->regX);
      return_value_memReadByte_3=memReadByte(machine, (signed int)zp);
      return_value_memReadByte_4=memReadByte(machine, (signed int)zp + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_3 + (return_value_memReadByte_4 << 8));
      return_value_memReadByte_5=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_5;
      return (unsigned char)1;
    }
    case INDIRECT_Y:
    {
      return_value_memReadByte_6=memReadByte(machine, (signed int)PC);
      zp = (unsigned char)return_value_memReadByte_6;
      return_value_memReadByte_7=memReadByte(machine, (signed int)zp);
      return_value_memReadByte_8=memReadByte(machine, (signed int)zp + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_7 + (return_value_memReadByte_8 << 8) + (signed int)machine->regY);
      return_value_memReadByte_9=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_9;
      return (unsigned char)1;
    }
    case ZERO:
    {
      return_value_memReadByte_10=memReadByte(machine, (signed int)PC);
      pointer->addr = (unsigned short int)return_value_memReadByte_10;
      return_value_memReadByte_11=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_11;
      return (unsigned char)1;
    }
    case ZERO_X:
    {
      return_value_memReadByte_12=memReadByte(machine, (signed int)PC);
      pointer->addr = (unsigned short int)(return_value_memReadByte_12 + (signed int)machine->regX);
      return_value_memReadByte_13=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_13;
      return (unsigned char)1;
    }
    case ZERO_Y:
    {
      return_value_memReadByte_14=memReadByte(machine, (signed int)PC);
      pointer->addr = (unsigned short int)(return_value_memReadByte_14 + (signed int)machine->regY);
      return_value_memReadByte_15=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_15;
      return (unsigned char)1;
    }
    case ABS_OR_BRANCH:
    {
      return_value_memReadByte_16=memReadByte(machine, (signed int)PC);
      pointer->addr = (unsigned short int)return_value_memReadByte_16;
      return (unsigned char)1;
    }
    case ABS_VALUE:
    {
      return_value_memReadByte_17=memReadByte(machine, (signed int)PC);
      return_value_memReadByte_18=memReadByte(machine, (signed int)PC + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_17 + (return_value_memReadByte_18 << 8));
      return_value_memReadByte_19=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_19;
      return (unsigned char)1;
    }
    case ABS_LABEL_X:

    case ABS_X:
    {
      return_value_memReadByte_20=memReadByte(machine, (signed int)PC);
      return_value_memReadByte_21=memReadByte(machine, (signed int)PC + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_20 + (return_value_memReadByte_21 << 8) + (signed int)machine->regX);
      return_value_memReadByte_22=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_22;
      return (unsigned char)1;
    }
    case ABS_LABEL_Y:

    case ABS_Y:
    {
      return_value_memReadByte_23=memReadByte(machine, (signed int)PC);
      return_value_memReadByte_24=memReadByte(machine, (signed int)PC + 1);
      pointer->addr = (unsigned short int)(return_value_memReadByte_23 + (return_value_memReadByte_24 << 8) + (signed int)machine->regY);
      return_value_memReadByte_25=memReadByte(machine, (signed int)pointer->addr);
      pointer->value = (unsigned short int)return_value_memReadByte_25;
      return (unsigned char)1;
    }
    case DCB_PARAM:
      ;
    default:
      return (unsigned char)0;
  }
}

// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_13 * pick_best_gl_visual(struct anonymous_25 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  struct anonymous_13 *result = ((struct anonymous_13 *)NULL);
  signed int ndepths = 0;
  signed int *depths;
  signed int return_value_screen_number_1;
  return_value_screen_number_1=screen_number(screen);
  depths=XListDepths(dpy, return_value_screen_number_1, &ndepths);
  signed int screen_depth;
  signed int tmp_if_expr_2;
  if(!(depths == ((signed int *)NULL)) && !(ndepths == 0))
    tmp_if_expr_2 = depths[(signed long int)(ndepths - 1)];

  else
    tmp_if_expr_2 = 0;
  screen_depth = tmp_if_expr_2;
  XFree((void *)depths);
  vi_in.class = 4;
  vi_in.screen=screen_number(screen);
  vi_in.depth = screen_depth / 2;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
  if(out_count >= 1)
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_19 *)NULL)))
    XFree((void *)(char *)vi_out);

  if(result == ((struct anonymous_13 *)NULL) && screen_depth >= 25)
  {
    vi_in.class = 4;
    vi_in.screen=screen_number(screen);
    vi_in.depth = 12;
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
    if(out_count >= 1)
      result = (vi_out + (signed long int)0)->visual;

  }

  if(result == ((struct anonymous_13 *)NULL))
    result=pick_best_visual_of_class(screen, 4);

  if(result == ((struct anonymous_13 *)NULL))
    result=pick_best_visual(screen, 0, 0);

  return result;
}

// pick_best_visual
// file visual.c line 174
static struct anonymous_13 * pick_best_visual(struct anonymous_25 *screen, signed int prefer_writable_cells, signed int color_only)
{
  struct anonymous_13 *visual;
  signed int return_value_visual_depth_1;
  if(prefer_writable_cells == 0)
  {
    visual=pick_best_visual_of_class(screen, 4);
    if(!(visual == ((struct anonymous_13 *)NULL)))
    {
      return_value_visual_depth_1=visual_depth(screen, visual);
      if(return_value_visual_depth_1 >= 16)
        return visual;

    }

  }

  visual=pick_best_visual_of_class(screen, 3);
  signed int return_value_visual_depth_2;
  if(!(visual == ((struct anonymous_13 *)NULL)))
  {
    _Bool tmp_if_expr_3;
    if(color_only == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_visual_depth_2=visual_depth(screen, visual);
      tmp_if_expr_3 = return_value_visual_depth_2 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 4);
  signed int return_value_visual_depth_4;
  if(!(visual == ((struct anonymous_13 *)NULL)))
  {
    _Bool tmp_if_expr_5;
    if(color_only == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_visual_depth_4=visual_depth(screen, visual);
      tmp_if_expr_5 = return_value_visual_depth_4 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 5);
  signed int return_value_visual_depth_6;
  if(!(visual == ((struct anonymous_13 *)NULL)))
  {
    _Bool tmp_if_expr_7;
    if(color_only == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_visual_depth_6=visual_depth(screen, visual);
      tmp_if_expr_7 = return_value_visual_depth_6 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 2);
  signed int return_value_visual_depth_8;
  if(!(visual == ((struct anonymous_13 *)NULL)))
  {
    _Bool tmp_if_expr_9;
    if(color_only == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_visual_depth_8=visual_depth(screen, visual);
      tmp_if_expr_9 = return_value_visual_depth_8 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      return visual;

  }

  signed int return_value_visual_depth_10;
  signed int return_value_visual_depth_12;
  if(color_only == 0)
  {
    visual=pick_best_visual_of_class(screen, 1);
    if(!(visual == ((struct anonymous_13 *)NULL)))
    {
      _Bool tmp_if_expr_11;
      if(color_only == 0)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_visual_depth_10=visual_depth(screen, visual);
        tmp_if_expr_11 = return_value_visual_depth_10 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        return visual;

    }

    visual=pick_best_visual_of_class(screen, 0);
    if(!(visual == ((struct anonymous_13 *)NULL)))
    {
      _Bool tmp_if_expr_13;
      if(color_only == 0)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_visual_depth_12=visual_depth(screen, visual);
        tmp_if_expr_13 = return_value_visual_depth_12 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        return visual;

    }

  }

  visual = screen->root_visual;
  _Bool tmp_if_expr_15;
  signed int return_value_visual_depth_14;
  if(color_only == 0)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value_visual_depth_14=visual_depth(screen, visual);
    tmp_if_expr_15 = return_value_visual_depth_14 > 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_15)
    return visual;

  else
    return ((struct anonymous_13 *)NULL);
}

// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_13 * pick_best_visual_of_class(struct anonymous_25 *screen, signed int visual_class)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  vi_in.class = visual_class;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2), &vi_in, &out_count);
  _Bool tmp_if_expr_1;
  if(!(vi_out == ((struct anonymous_19 *)NULL)))
  {
    signed int i;
    signed int best;
    struct anonymous_13 *visual;
    i = out_count - 1;
    best = i;
    for( ; i >= 0; i = i - 1)
    {
      _Bool tmp_if_expr_2;
      if(!((vi_out + (signed long int)best)->depth >= (vi_out + (signed long int)i)->depth))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if((vi_out + (signed long int)i)->depth == (vi_out + (signed long int)best)->depth)
          tmp_if_expr_1 = (vi_out + (signed long int)i)->colormap_size > (vi_out + (signed long int)best)->colormap_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        best = i;

    }
    struct anonymous_13 *tmp_if_expr_3;
    if(!(best >= out_count))
      tmp_if_expr_3 = (vi_out + (signed long int)best)->visual;

    else
      tmp_if_expr_3 = ((struct anonymous_13 *)NULL);
    visual = tmp_if_expr_3;
    XFree((void *)(char *)vi_out);
    return visual;
  }

  else
    return ((struct anonymous_13 *)NULL);
}

// pick_mono_visual
// file visual.c line 218
static struct anonymous_13 * pick_mono_visual(struct anonymous_25 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  vi_in.depth = 1;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x4 | 0x2), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_19 *)NULL)))
  {
    struct anonymous_13 *v;
    struct anonymous_13 *tmp_if_expr_1;
    if(out_count >= 1)
      tmp_if_expr_1 = (vi_out + (signed long int)0)->visual;

    else
      tmp_if_expr_1 = ((struct anonymous_13 *)NULL);
    v = tmp_if_expr_1;
    if(!(v == ((struct anonymous_13 *)NULL)))
    {
      if(!(vi_out->depth == 1))
        v = ((struct anonymous_13 *)NULL);

    }

    XFree((void *)(char *)vi_out);
    return v;
  }

  else
    return ((struct anonymous_13 *)NULL);
}

// pick_visual
// file screenhack.c line 321
static struct anonymous_13 * pick_visual(struct anonymous_25 *screen)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  if(!(ft->pick_visual_hook == ((struct anonymous_13 * (*)(struct anonymous_25 *))NULL)))
  {
    struct anonymous_13 *v;
    v=ft->pick_visual_hook(screen);
    if(!(v == ((struct anonymous_13 *)NULL)))
      return v;

  }

  struct anonymous_13 *return_value_get_visual_resource_1;
  return_value_get_visual_resource_1=get_visual_resource(screen, "visualID", "VisualID", 0);
  return return_value_get_visual_resource_1;
}

// plot6502
// file m6502.c line 67
static void plot6502(unsigned char x, unsigned char y, unsigned char color, void *closure)
{
  struct state *st = (struct state *)closure;
  st->pixels[(signed long int)x][(signed long int)y] = color;
}

// popByte
// file asm6502.c line 185
static unsigned char popByte(struct machine_6502 *machine)
{
  unsigned char popByte__1__value = machine->memory[(signed long int)machine->regPC];
  machine->regPC = machine->regPC + 1;
  return popByte__1__value;
}

// popWord
// file asm6502.c line 196
static signed int popWord(struct machine_6502 *machine)
{
  unsigned char return_value_popByte_1;
  return_value_popByte_1=popByte(machine);
  unsigned char return_value_popByte_2;
  return_value_popByte_2=popByte(machine);
  return (signed int)return_value_popByte_1 + ((signed int)return_value_popByte_2 << 8);
}

// puramp
// file analogtv.c line 119
static float puramp(const struct analogtv_s *it, float tc, float start, float over)
{
  float pt = it->powerup - start;
  float ret;
  if(pt < 0.0f)
    return 0.0f;

  else
    if(pt / tc > 8.0f || pt > 900.0f)
      return 1.0f;

    else
    {
      float return_value_expf_1;
      return_value_expf_1=expf(-pt / tc);
      ret = (1.0f - return_value_expf_1) * over;
      if(ret > 1.0f)
        return 1.0f;

      else
        return ret * ret;
    }
}

// pushByte
// file asm6502.c line 162
static void pushByte(struct machine_6502 *machine, unsigned int value)
{
  unsigned int address = (unsigned int)machine->defaultCodePC;
  checkAddress(address);
  machine->memory[(signed long int)address] = (unsigned char)(value & (unsigned int)0xff);
  machine->codeLen = machine->codeLen + 1;
  machine->defaultCodePC = machine->defaultCodePC + 1;
}

// pushWord
// file asm6502.c line 175
static void pushWord(struct machine_6502 *machine, unsigned short int value)
{
  pushByte(machine, (unsigned int)((signed int)value & 0xff));
  pushByte(machine, (unsigned int)((signed int)value >> 8 & 0xff));
}

// reset
// file asm6502.c line 1714
static void reset(struct machine_6502 *machine)
{
  signed int x;
  signed int y = 0;
  for( ; !(y >= 32); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 32); x = x + 1)
      machine->screen[(signed long int)x][(signed long int)y] = 0;
  }
  x = 0;
  for( ; !(x >= 65536); x = x + 1)
    machine->memory[(signed long int)x] = (unsigned char)0;
  machine->codeCompiledOK = (unsigned char)0;
  machine->regA = (unsigned char)0;
  machine->regX = (unsigned char)0;
  machine->regY = (unsigned char)0;
  machine->regP=setBit(machine->regP, (enum anonymous_18)FUTURE_FL, 1);
  machine->regPC = (unsigned short int)1536;
  machine->defaultCodePC = machine->regPC;
  machine->regSP = (unsigned short int)511;
  machine->runForever = (unsigned char)0;
  machine->labelPtr = 0;
  machine->codeRunning = (unsigned char)0;
}

// rnd_combine
// file analogtv.c line 1184
static void rnd_combine(unsigned int *a0, unsigned int *c0, unsigned int a1, unsigned int c1)
{
  *a0 = *a0 * a1 & 0xffffffffu;
  *c0 = c1 + a1 * *c0 & 0xffffffffu;
}

// rnd_seek
// file analogtv.c line 1204
static unsigned int rnd_seek(unsigned int a, unsigned int c, unsigned int rnd, unsigned int dist)
{
  rnd_seek_ac(&a, &c, dist);
  return a * rnd + c;
}

// rnd_seek_ac
// file analogtv.c line 1190
static void rnd_seek_ac(unsigned int *a, unsigned int *c, unsigned int dist)
{
  unsigned int a1 = *a;
  unsigned int c1 = *c;
  *a = (unsigned int)1;
  *c = (unsigned int)0;
  while(!(dist == 0u))
  {
    if(!((1u & dist) == 0u))
      rnd_combine(a, c, a1, c1);

    dist = dist >> 1;
    rnd_combine(&a1, &c1, a1, c1);
  }
}

// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft)
{
  void * (*init_cb)(struct _XDisplay *, unsigned long int, void *) = (void * (*)(struct _XDisplay *, unsigned long int, void *))ft->init_cb;
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *) = ft->fps_cb;
  void *closure;
  closure=init_cb(dpy, window, ft->setup_arg);
  struct fps_state *fpst;
  fpst=fps_init(dpy, window);
  void *closure2 = NULL;
  struct fps_state *fpst2 = ((struct fps_state *)NULL);
  if(!(window2 == 0ul))
    closure2=init_cb(dpy, window2, ft->setup_arg);

  if(!(window2 == 0ul))
    fpst2=fps_init(dpy, window2);

  if(closure == NULL)
    abort();

  if(fps_cb == ((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL))
    fps_cb = screenhack_do_fps;

  {
    unsigned long int delay;
    delay=ft->draw_cb(dpy, window, closure);
    unsigned long int delay2 = (unsigned long int)0;
    if(!(window2 == 0ul))
      delay2=ft->draw_cb(dpy, window2, closure2);

    if(!(fpst == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst, closure);

    if(!(fpst2 == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst2, closure);

    char return_value_usleep_and_process_events_1;
    return_value_usleep_and_process_events_1=usleep_and_process_events(dpy, ft, window, fpst, closure, delay, window2, fpst2, closure2, delay2);
  }
  ft->free_cb(dpy, window, closure);
  if(!(fpst == ((struct fps_state *)NULL)))
    fps_free(fpst);

  if(!(window2 == 0ul))
    ft->free_cb(dpy, window2, closure2);

  if(!(fpst2 == ((struct fps_state *)NULL)))
    fps_free(fpst2);

}

// screen_number
// file visual.c line 475
extern signed int screen_number(struct anonymous_25 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int i = 0;
  for( ; !(i >= ((struct anonymous_2 *)dpy)->nscreens); i = i + 1)
    if(((struct anonymous_2 *)dpy)->screens + (signed long int)i == screen)
      return i;

  abort();
  return 0;
}

// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  fps_compute(fpst, (unsigned long int)0, (double)-1);
  fps_draw(fpst);
}

// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_56 *error)
{
  fprintf(stderr, "\nX error in %s:\n", progname);
  signed int return_value_XmuPrintDefaultErrorMessage_1;
  return_value_XmuPrintDefaultErrorMessage_1=XmuPrintDefaultErrorMessage(dpy, error, stderr);
  if(!(return_value_XmuPrintDefaultErrorMessage_1 == 0))
    exit(-1);

  else
    fprintf(stderr, " (nonfatal.)\n");
  return 0;
}

// screenhack_event_helper
// file ./../utils/resources.h line 39
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event)
{
  if(event->xany.type == 2)
  {
    unsigned long int keysym;
    char c = (char)0;
    XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
    if(keysym == 65361ul || keysym == 65362ul || keysym == 65363ul || keysym == 65364ul || keysym == 65365ul || keysym == 65366ul || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13 || (signed int)c == 32)
      return 1;

  }

  else
    if(event->xany.type == 4)
    {
      if(event->xbutton.button == 1u)
        return 1;

    }

  return 0;
}

// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event)
{
  switch(event->xany.type)
  {
    case 2:
    {
      unsigned long int keysym;
      char c = (char)0;
      XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
      if((signed int)c == 3 || (signed int)c == 27 || (signed int)c == 81 || (signed int)c == 113)
        return 0;

      else
        if(!(keysym >= 65505ul) || keysym >= 65519ul)
          XBell(dpy, 0);

      goto __CPROVER_DUMP_L11;
    }
    case 4:
    {
      XBell(dpy, 0);
      goto __CPROVER_DUMP_L11;
    }
    case 33:
      if(!(event->xclient.message_type == XA_WM_PROTOCOLS))
      {
        char *s;
        s=XGetAtomName(dpy, event->xclient.message_type);
        if(s == ((char *)NULL))
          s = "(null)";

        fprintf(stderr, "%s: unknown ClientMessage %s received!\n", progname, s);
      }

      else
        if(!((unsigned long int)event->xclient.data.l[0l] == XA_WM_DELETE_WINDOW))
        {
          char *s1;
          s1=XGetAtomName(dpy, event->xclient.message_type);
          char *s2;
          s2=XGetAtomName(dpy, (unsigned long int)event->xclient.data.l[(signed long int)0]);
          if(s1 == ((char *)NULL))
            s1 = "(null)";

          if(s2 == ((char *)NULL))
            s2 = "(null)";

          fprintf(stderr, "%s: unknown ClientMessage %s[%s] received!\n", progname, s1, s2);
        }

        else
          return 0;
    default:
    {

    __CPROVER_DUMP_L11:
      ;
      return 1;
    }
  }
}

// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(dpy);
  unsigned long int return_value_XtAppPending_1;
  return_value_XtAppPending_1=XtAppPending(app);
  if(!((6ul & return_value_XtAppPending_1) == 0ul))
    XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  signed int return_value_XPending_2;
  signed int tmp_if_expr_5;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_screenhack_handle_event_1_3;
  do
  {
    return_value_XPending_2=XPending(dpy);
    if(return_value_XPending_2 == 0)
      break;

    union _XEvent event;
    XNextEvent(dpy, &event);
    if(event.xany.type == 22)
    {
      if(event.xany.window == window)
        ft->reshape_cb(dpy, window, closure, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

      if(event.xany.window == window2 && !(window2 == 0ul))
        ft->reshape_cb(dpy, window2, closure2, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

    }

    else
    {
      _Bool tmp_if_expr_6;
      if(event.xany.type == 33)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if(event.xany.window == window)
        {
          return_value=ft->event_cb(dpy, window, closure, &event);
          tmp_if_expr_5 = return_value;
        }

        else
        {
          if(event.xany.window == window2 && !(window2 == 0ul))
          {
            return_value_1=ft->event_cb(dpy, window2, closure2, &event);
            tmp_if_expr_4 = return_value_1;
          }

          else
            tmp_if_expr_4 = 0;
          tmp_if_expr_5 = tmp_if_expr_4;
        }
        tmp_if_expr_6 = !(tmp_if_expr_5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
      {
        return_value_screenhack_handle_event_1_3=screenhack_handle_event_1(dpy, &event);
        if(return_value_screenhack_handle_event_1_3 == 0)
          return (char)0;

      }

    }
    unsigned long int return_value_XtAppPending_7;
    return_value_XtAppPending_7=XtAppPending(app);
    if(!((6ul & return_value_XtAppPending_7) == 0ul))
      XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  }
  while((_Bool)1);
  return (char)1;
}

// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(usecs / (unsigned long int)1000000L);
  tv.tv_usec = (signed long int)(usecs % (unsigned long int)1000000L);
  select(0, ((struct anonymous_20 *)NULL), ((struct anonymous_20 *)NULL), ((struct anonymous_20 *)NULL), &tv);
}

// setBit
// file asm6502.c line 247
static unsigned char setBit(unsigned char value, enum anonymous_18 bit, signed int on)
{
  unsigned char onMask = (unsigned char)1;
  unsigned char offMask = (unsigned char)0xff;
  onMask = (unsigned char)((signed int)onMask << (signed int)bit);
  offMask = (unsigned char)((signed int)offMask ^ (signed int)onMask);
  return (unsigned char)(on != 0 ? (signed int)value | (signed int)onMask : (signed int)value & (signed int)offMask);
}

// shm_ehandler
// file xshm.c line 62
static signed int shm_ehandler(struct _XDisplay *dpy, struct anonymous_56 *error)
{
  shm_got_x_error = 1;
  return 0;
}

// skipSpace
// file asm6502.c line 1258
static void skipSpace(char **s)
{
  unsigned char return_value_isWhite_1;
  do
  {
    return_value_isWhite_1=isWhite(*(*s));
    if(return_value_isWhite_1 == 0)
      break;

    *s = *s + 1l;
  }
  while((_Bool)1);
}

// stackPop
// file asm6502.c line 150
static unsigned char stackPop(struct machine_6502 *machine)
{
  if(!((signed int)machine->regSP >= 511))
  {
    unsigned char stackPop__1__1__value;
    machine->regSP = machine->regSP + 1;
    stackPop__1__1__value = machine->memory[(signed long int)machine->regSP];
    return stackPop__1__1__value;
  }

  else
  {
    machine->codeRunning = (unsigned char)0;
    return (unsigned char)0;
  }
}

// stackPush
// file asm6502.c line 134
static void stackPush(struct machine_6502 *machine, unsigned char value)
{
  if((signed int)machine->regSP >= 256)
  {
    unsigned short int tmp_post_1 = machine->regSP;
    machine->regSP = machine->regSP - 1;
    machine->memory[(signed long int)tmp_post_1] = value;
  }

  else
  {
    fprintf(stderr, "The stack is full: %.4x\n", machine->regSP);
    machine->codeRunning = (unsigned char)0;
  }
}

// start_rand_bin_prog
// file m6502.c line 78
static void start_rand_bin_prog(struct machine_6502 *machine, struct state *st)
{
  signed int n = st->which;
  unsigned int return_value_ya_random_1;
  while(n == st->which)
  {
    return_value_ya_random_1=ya_random();
    n = (signed int)(return_value_ya_random_1 % (unsigned int)st->demos);
  }
  st->which = n;
  m6502_start_eval_string(machine, demo_files[(signed long int)st->which], plot6502, (void *)st);
}

// stoupper
// file asm6502.c line 1246
static void stoupper(char **s)
{
  signed int i = 0;
  while(!((signed int)(*s)[(signed long int)i] == 0))
  {
    signed int return_value_toupper_1;
    return_value_toupper_1=toupper((signed int)(*s)[(signed long int)i]);
    (*s)[(signed long int)i] = (char)return_value_toupper_1;
    i = i + 1;
  }
}

// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_3 *f, const char *c, signed int *height_ret)
{
  signed int x = 0;
  signed int max_w = 0;
  signed int h = f->ascent + f->descent;
  while(!(*c == 0))
  {
    signed int cc = (signed int)*((unsigned char *)c);
    if((signed int)*c == 10)
    {
      if(!(max_w >= x))
        max_w = x;

      x = 0;
      h = h + f->ascent + f->descent;
    }

    else
    {
      signed int tmp_if_expr_1;
      if(!(f->per_char == ((struct anonymous_6 *)NULL)))
        tmp_if_expr_1 = (signed int)(f->per_char + (signed long int)((unsigned int)cc - f->min_char_or_byte2))->width;

      else
        tmp_if_expr_1 = (signed int)f->min_bounds.rbearing;
      x = x + tmp_if_expr_1;
    }
    c = c + 1l;
  }
  if(!(max_w >= x))
    max_w = x;

  if(!(height_ret == ((signed int *)NULL)))
    *height_ret = h;

  return max_w;
}

// thread_memory_alignment
// file ./../utils/thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy)
{
  threads_available(dpy);
  return (unsigned int)_cache_line_size;
}

// threadpool_create
// file ./../utils/thread_util.h line 303
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count)
{
  threads_available(dpy);
  self->count = count;
  /* assertion cls */
  assert(cls != ((struct threadpool_class *)NULL));
  self->thread_size = cls->size;
  self->thread_destroy = cls->destroy;
  void *thread;
  unsigned int i;
  unsigned int count_serial;
  count_serial=_threadpool_count_serial(self);
  if(!(count_serial == 0u))
  {
    thread=malloc(cls->size * (unsigned long int)count_serial);
    if(thread == NULL)
      return 12;

  }

  else
    thread = (void *)0;
  self->serial_threads = thread;
  i = (unsigned int)0;
  if(!(i == count_serial))
  {
    signed int error;
    error=cls->create(thread, self, i);
    if(!(error == 0))
    {
      self->count = i;
      _serial_destroy(self);
      return error;
    }

    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  signed int return_value_pthread_cond_wait_3;
  if(_has_pthread >= 0)
  {
    unsigned int count_parallel;
    count_parallel=_threadpool_count_parallel(self);
    self->mutex = mutex_initializer;
    self->cond = cond_initializer;
    self->parallel_pending = (unsigned int)0;
    self->parallel_unfinished = (unsigned int)0;
    if(count_parallel == 0u)
    {
      self->parallel_threads = (unsigned long int *)(void *)0;
      return 0;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)count_parallel);
    self->parallel_threads = (unsigned long int *)return_value_malloc_1;
    if(self->parallel_threads == ((unsigned long int *)NULL))
      return 12;

    struct _parallel_startup_type startup;
    startup.parent = self;
    startup.thread_create = cls->create;
    startup.last_errno = 0;
    signed int return_value_pthread_mutex_lock_2;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_2 != 0));
    _add_next_thread(&startup);
    if(startup.last_errno == 0)
      while(!(self->parallel_unfinished == count_parallel))
      {
        if(self->parallel_threads == ((unsigned long int *)NULL))
          break;

        return_value_pthread_cond_wait_3=pthread_cond_wait(&self->cond, &self->mutex);
        /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
        assert(!(return_value_pthread_cond_wait_3 != 0));
      }

    if(!(startup.last_errno == 0))
      _unlock_and_destroy(self);

    else
    {
      self->parallel_unfinished = (unsigned int)0;
      signed int return_value_pthread_mutex_unlock_4;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&self->mutex);
      /* assertion !(pthread_mutex_unlock(&self->mutex)) */
      assert(!(return_value_pthread_mutex_unlock_4 != 0));
    }
    return startup.last_errno;
  }

  return 0;
}

// threadpool_destroy
// file ./../utils/thread_util.h line 304
void threadpool_destroy(struct threadpool *self)
{
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    _unlock_and_destroy(self);
    goto __CPROVER_DUMP_L2;
  }

  _serial_destroy(self);

__CPROVER_DUMP_L2:
  ;
}

// threadpool_run
// file ./../utils/thread_util.h line 306
void threadpool_run(struct threadpool *self, void (*func)(void *))
{
  if(_has_pthread >= 0)
  {
    unsigned int threadpool_run__1__1__count;
    threadpool_run__1__1__count=_threadpool_count_parallel(self);
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    /* assertion !self->parallel_pending */
    assert(!(self->parallel_pending != 0u));
    /* assertion !self->parallel_unfinished */
    assert(!(self->parallel_unfinished != 0u));
    self->parallel_pending = threadpool_run__1__1__count;
    self->parallel_unfinished = threadpool_run__1__1__count;
    self->thread_run = func;
    signed int return_value_pthread_cond_broadcast_2;
    return_value_pthread_cond_broadcast_2=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_2 != 0));
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    func(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

}

// threadpool_wait
// file ./../utils/thread_util.h line 307
void threadpool_wait(struct threadpool *self)
{
  signed int return_value_pthread_cond_wait_2;
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    while(!(self->parallel_unfinished == 0u))
    {
      return_value_pthread_cond_wait_2=pthread_cond_wait(&self->cond, &self->mutex);
      /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
      assert(!(return_value_pthread_cond_wait_2 != 0));
    }
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

}

// threads_available
// file thread_util.c line 291
signed int threads_available(struct _XDisplay *dpy)
{
  if(_has_pthread == 0)
  {
    _has_pthread = (signed int)200809L;
    if(_has_pthread >= 0)
    {
      signed int return_value_get_boolean_resource_2;
      return_value_get_boolean_resource_2=get_boolean_resource(dpy, "useThreads", "Boolean");
      if(!(return_value_get_boolean_resource_2 == 0))
      {
        unsigned int return_value__get_cache_line_size_1;
        return_value__get_cache_line_size_1=_get_cache_line_size();
        _cache_line_size = (signed int)return_value__get_cache_line_size_1;
        /* assertion _cache_line_size >= sizeof(void *) */
        assert((unsigned long int)_cache_line_size >= sizeof(void *) /*8ul*/ );
        /* assertion ((_cache_line_size) > 0 && !((_cache_line_size) & ((_cache_line_size) - 1))) */
        assert(_cache_line_size > 0 && !((_cache_line_size & _cache_line_size - 1) != 0));
      }

      else
        _has_pthread = -1;
    }

  }

  return _has_pthread;
}

// translate
// file asm6502.c line 1770
static unsigned char translate(struct anonymous_61 *op, struct anonymous_8 *param, struct machine_6502 *machine)
{
  switch((signed int)param->type)
  {
    case SINGLE:
    {
      if(!(op->SNGL == 0))
        pushByte(machine, (unsigned int)op->SNGL);

      else
      {
        fprintf(stderr, "%s needs a parameter.\n", (const void *)op->name);
        return (unsigned char)0;
      }
      goto __CPROVER_DUMP_L34;
    }
    case IMMEDIATE_VALUE:
      if(!(op->Imm == 0))
      {
        pushByte(machine, (unsigned int)op->Imm);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take IMMEDIATE_VALUE parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case IMMEDIATE_GREAT:
      if(!(op->Imm == 0))
      {
        pushByte(machine, (unsigned int)op->Imm);
        pushByte(machine, param->lbladdr >> 8);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take IMMEDIATE_GREAT parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case IMMEDIATE_LESS:
      if(!(op->Imm == 0))
      {
        pushByte(machine, (unsigned int)op->Imm);
        pushByte(machine, param->lbladdr & (unsigned int)0xFF);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take IMMEDIATE_LESS parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case INDIRECT_X:
      if(!(op->INDX == 0))
      {
        pushByte(machine, (unsigned int)op->INDX);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take INDIRECT_X parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case INDIRECT_Y:
      if(!(op->INDY == 0))
      {
        pushByte(machine, (unsigned int)op->INDY);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take INDIRECT_Y parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ZERO:
      if(!(op->ZP == 0))
      {
        pushByte(machine, (unsigned int)op->ZP);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ZERO parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ZERO_X:
      if(!(op->ZPX == 0))
      {
        pushByte(machine, (unsigned int)op->ZPX);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ZERO_X parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ZERO_Y:
      if(!(op->ZPY == 0))
      {
        pushByte(machine, (unsigned int)op->ZPY);
        pushByte(machine, param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ZERO_Y parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ABS_VALUE:
      if(!(op->ABS == 0))
      {
        pushByte(machine, (unsigned int)op->ABS);
        pushWord(machine, (unsigned short int)param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ABS_VALUE parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ABS_OR_BRANCH:
    {
      if((signed int)op->ABS >= 1)
      {
        pushByte(machine, (unsigned int)op->ABS);
        pushWord(machine, (unsigned short int)param->lbladdr);
      }

      else
        if(!(op->BRA == 0))
        {
          pushByte(machine, (unsigned int)op->BRA);
          signed int diff;
          diff=abs((signed int)(param->lbladdr - (unsigned int)machine->defaultCodePC));
          signed int backward = (signed int)(param->lbladdr < (unsigned int)machine->defaultCodePC);
          pushByte(machine, (unsigned int)(backward != 0 ? 0xff - diff : diff - 1));
        }

        else
        {
          fprintf(stderr, "%s does not take BRANCH parameters.\n", (const void *)op->name);
          return (unsigned char)0;
        }
      goto __CPROVER_DUMP_L34;
    }
    case ABS_X:
      if(!(op->ABSX == 0))
      {
        pushByte(machine, (unsigned int)op->ABSX);
        pushWord(machine, (unsigned short int)param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ABS_X parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ABS_Y:
      if(!(op->ABSY == 0))
      {
        pushByte(machine, (unsigned int)op->ABSY);
        pushWord(machine, (unsigned short int)param->value[(signed long int)0]);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ABS_Y parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ABS_LABEL_X:
      if(!(op->ABSX == 0))
      {
        pushByte(machine, (unsigned int)op->ABSX);
        pushWord(machine, (unsigned short int)param->lbladdr);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ABS_LABEL_X parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case ABS_LABEL_Y:
      if(!(op->ABSY == 0))
      {
        pushByte(machine, (unsigned int)op->ABSY);
        pushWord(machine, (unsigned short int)param->lbladdr);
        goto __CPROVER_DUMP_L34;
      }

      else
      {
        fprintf(stderr, "%s does not take ABS_LABEL_Y parameters.\n", (const void *)op->name);
        return (unsigned char)0;
      }
    case DCB_PARAM:

    default:
    {

    __CPROVER_DUMP_L34:
      ;
      return (unsigned char)1;
    }
  }
}

// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc)
{
  uc = uc & (unsigned long int)0x7FFFFFFFL;
  if(uc >= 1114112ul)
    uc = (unsigned long int)0xFFFD;

  if(uc == 0ul)
    uc = (unsigned long int)0xFFFD;

  if(uc >= 55296ul && !(uc >= 57344ul))
    uc = (unsigned long int)0xFFFD;

  return uc;
}

// updateDisplayPixel
// file asm6502.c line 211
static void updateDisplayPixel(struct machine_6502 *machine, unsigned short int addr)
{
  unsigned char idx;
  signed int return_value_memReadByte_1;
  return_value_memReadByte_1=memReadByte(machine, (signed int)addr);
  idx = (unsigned char)(return_value_memReadByte_1 & 0x0f);
  unsigned char x;
  unsigned char y;
  addr = addr - (unsigned short int)0x200;
  x = (unsigned char)((signed int)addr & 0x1f);
  y = (unsigned char)((signed int)addr >> 5);
  if(!(machine->plot == ((void (*)(unsigned char, unsigned char, unsigned char, void *))NULL)))
    machine->plot(x, y, idx, machine->plotterState);

}

// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2)
{
  do
  {
    unsigned long int quantum = (unsigned long int)33333;
    if(!(delay >= quantum))
      quantum = delay;

    delay = delay - quantum;
    XSync(dpy, 0);
    if(quantum >= 1ul)
    {
      screenhack_usleep(quantum);
      if(!(fpst == ((struct fps_state *)NULL)))
        fps_slept(fpst, quantum);

      if(!(fpst2 == ((struct fps_state *)NULL)))
        fps_slept(fpst2, quantum);

    }

    char return_value_screenhack_table_handle_events_1;
    return_value_screenhack_table_handle_events_1=screenhack_table_handle_events(dpy, ft, window, closure, window2, closure2);
    if(return_value_screenhack_table_handle_events_1 == 0)
      return (char)0;

  }
  while(delay >= 1ul);
  return (char)1;
}

// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret)
{
  const unsigned char *start = in;
  const unsigned char *end = in + length;
  unsigned long int uc = (unsigned long int)0xFFFD;
  unsigned long int min = (unsigned long int)0;
  unsigned char c;
  if(length >= 1l)
  {
    const unsigned char *tmp_post_1 = in;
    in = in + 1l;
    c = *tmp_post_1;
    if((0xC0 & (signed int)c) == 0x80)
      uc = (unsigned long int)0xFFFD;

    else
      if((0x80 & (signed int)c) == 0)
        uc = (unsigned long int)((signed int)c & 0x7F);

      else
        if((0xE0 & (signed int)c) == 0xC0)
        {
          if(!(end >= in + 1l))
          {
            in = end;
            goto DONE;
          }

          min = (unsigned long int)(1 << 7);
          uc = (unsigned long int)(((signed int)c & 0x1F) << 6 | (signed int)in[(signed long int)0] & 0x3F);
          in = in + (signed long int)1;
        }

        else
          if((0xF0 & (signed int)c) == 0xE0)
          {
            if(!(end >= in + 2l))
            {
              in = end;
              goto DONE;
            }

            min = (unsigned long int)(1 << 11);
            uc = (unsigned long int)(((signed int)c & 0x0F) << 12 | ((signed int)in[(signed long int)0] & 0x3F) << 6 | (signed int)in[(signed long int)1] & 0x3F);
            in = in + (signed long int)2;
          }

          else
            if((0xF8 & (signed int)c) == 0xF0)
            {
              if(!(end >= in + 3l))
              {
                in = end;
                goto DONE;
              }

              min = (unsigned long int)(1 << 16);
              uc = (unsigned long int)(((signed int)c & 0x07) << 18 | ((signed int)in[(signed long int)0] & 0x3F) << 12 | ((signed int)in[(signed long int)1] & 0x3F) << 6 | (signed int)in[(signed long int)2] & 0x3F);
              in = in + (signed long int)3;
            }

            else
              if((0xFC & (signed int)c) == 0xF8)
              {
                if(!(end >= in + 4l))
                {
                  in = end;
                  goto DONE;
                }

                min = (unsigned long int)(1 << 21);
                uc = (unsigned long int)(((signed int)c & 0x03) << 24 | ((signed int)in[(signed long int)0] & 0x3F) << 18 | ((signed int)in[(signed long int)1] & 0x3F) << 12 | ((signed int)in[(signed long int)2] & 0x3F) << 6 | (signed int)in[(signed long int)3] & 0x3F);
                in = in + (signed long int)4;
              }

              else
                if((0xFE & (signed int)c) == 0xFC)
                {
                  if(!(end >= in + 5l))
                  {
                    in = end;
                    goto DONE;
                  }

                  min = (unsigned long int)(1 << 26);
                  uc = (unsigned long int)(((signed int)c & 0x01) << 30 | ((signed int)in[(signed long int)0] & 0x3F) << 24 | ((signed int)in[(signed long int)1] & 0x3F) << 18 | ((signed int)in[(signed long int)2] & 0x3F) << 12 | ((signed int)in[(signed long int)3] & 0x3F) << 6 | (signed int)in[(signed long int)4] & 0x3F);
                  in = in + (signed long int)5;
                }

                else
                  uc = (unsigned long int)0xFFFD;
  }


DONE:
  ;
  length = in - start;
  signed int i = 1;
  for( ; !((signed long int)i >= length); i = i + 1)
    if(!((0xC0 & (signed int)start[(signed long int)i]) == 0x80))
    {
      uc = (unsigned long int)0xFFFD;
      length = (signed long int)(i + 1);
      break;
    }

  if(!(uc >= min))
    uc = (unsigned long int)0xFFFD;

  uc=uc_truncate(uc);
  if(!(unicode_ret == ((unsigned long int *)NULL)))
    *unicode_ret = uc;

  return length;
}

// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length)
{
  const char *old = out;
  uc=uc_truncate(uc);
  if(length >= 1l && !(uc >= 128ul))
  {
    char *tmp_post_1 = out;
    out = out + 1l;
    *tmp_post_1 = (char)uc;
  }

  else
    if(length >= 2l && !(uc >= 2048ul))
    {
      char *tmp_post_2 = out;
      out = out + 1l;
      *tmp_post_2 = (char)((unsigned long int)0xC0 | uc >> 6 & (unsigned long int)0x1F);
      char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
    }

    else
      if(length >= 3l && !(uc >= 65536ul))
      {
        char *tmp_post_4 = out;
        out = out + 1l;
        *tmp_post_4 = (char)((unsigned long int)0xE0 | uc >> 12 & (unsigned long int)0x0F);
        char *tmp_post_5 = out;
        out = out + 1l;
        *tmp_post_5 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
        char *tmp_post_6 = out;
        out = out + 1l;
        *tmp_post_6 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
      }

      else
        if(length >= 4l && !(uc >= 2097152ul))
        {
          char *tmp_post_7 = out;
          out = out + 1l;
          *tmp_post_7 = (char)((unsigned long int)0xF0 | uc >> 18 & (unsigned long int)0x07);
          char *tmp_post_8 = out;
          out = out + 1l;
          *tmp_post_8 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
          char *tmp_post_9 = out;
          out = out + 1l;
          *tmp_post_9 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
          char *tmp_post_10 = out;
          out = out + 1l;
          *tmp_post_10 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
        }

        else
          if(length >= 5l && !(uc >= 67108864ul))
          {
            char *tmp_post_11 = out;
            out = out + 1l;
            *tmp_post_11 = (char)((unsigned long int)0xF8 | uc >> 24 & (unsigned long int)0x03);
            char *tmp_post_12 = out;
            out = out + 1l;
            *tmp_post_12 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
            char *tmp_post_13 = out;
            out = out + 1l;
            *tmp_post_13 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
            char *tmp_post_14 = out;
            out = out + 1l;
            *tmp_post_14 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
            char *tmp_post_15 = out;
            out = out + 1l;
            *tmp_post_15 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
          }

          else
            if(length >= 6l)
            {
              char *tmp_post_16 = out;
              out = out + 1l;
              *tmp_post_16 = (char)((unsigned long int)0xFC | uc >> 30 & (unsigned long int)0x01);
              char *tmp_post_17 = out;
              out = out + 1l;
              *tmp_post_17 = (char)((unsigned long int)0x80 | uc >> 24 & (unsigned long int)0x3F);
              char *tmp_post_18 = out;
              out = out + 1l;
              *tmp_post_18 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
              char *tmp_post_19 = out;
              out = out + 1l;
              *tmp_post_19 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
              char *tmp_post_20 = out;
              out = out + 1l;
              *tmp_post_20 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
              char *tmp_post_21 = out;
              out = out + 1l;
              *tmp_post_21 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
            }

  return (signed int)(out - old);
}

// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret)
{
  const unsigned char *in = (const unsigned char *)string;
  signed long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed long int)return_value_strlen_1;
  const unsigned char *end = in + len;
  char **ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + (signed long int)1) * sizeof(char *) /*8ul*/ );
  ret = (char **)return_value_malloc_2;
  signed int i = 0;
  if(ret == ((char **)NULL))
    return ((char **)NULL);

  else
  {
    while(!(in >= end))
    {
      unsigned long int uc;
      signed long int len2;
      len2=utf8_decode(in, len, &uc);
      char tmp[10l];
      strncpy(tmp, (char *)in, (unsigned long int)len2);
      tmp[len2] = (char)0;
      signed int tmp_post_3 = i;
      i = i + 1;
      ret[(signed long int)tmp_post_3]=strdup(tmp);
      in = in + len2;
      if(i >= 2 && uc >= 768ul && !(uc >= 880ul))
      {
        signed long int L1;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(ret[(signed long int)(i - 2)]);
        L1 = (signed long int)return_value_strlen_4;
        signed long int L2;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(ret[(signed long int)(i - 1)]);
        L2 = (signed long int)return_value_strlen_5;
        char *s2;
        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)(L1 + L2 + (signed long int)1));
        s2 = (char *)return_value_malloc_6;
        strncpy(s2, ret[(signed long int)(i - 2)], (unsigned long int)L1);
        strncpy(s2 + L1, ret[(signed long int)(i - 1)], (unsigned long int)L2);
        s2[L1 + L2] = (char)0;
        free((void *)ret[(signed long int)(i - 2)]);
        ret[(signed long int)(i - 2)] = s2;
        i = i - 1;
      }

    }
    ret[(signed long int)i] = ((char *)NULL);
    void *return_value_realloc_7;
    return_value_realloc_7=realloc((void *)ret, (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ );
    ret = (char **)return_value_realloc_7;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = i;

    return ret;
  }
}

// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_24 * utf8_to_XChar2b(const char *string, signed int *length_ret)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  struct anonymous_24 *c2b;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1) * sizeof(struct anonymous_24) /*2ul*/ );
  c2b = (struct anonymous_24 *)return_value_malloc_2;
  struct anonymous_24 *out = c2b;
  if(out == ((struct anonymous_24 *)NULL))
    return ((struct anonymous_24 *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int L;
      L=utf8_decode(in, in_end - in, &uc);
      in = in + L;
      if(uc >= 65536ul)
        uc = (unsigned long int)0xFFFD;

      out->byte1 = (unsigned char)(uc >> 8 & (unsigned long int)0xFF);
      out->byte2 = (unsigned char)(uc & (unsigned long int)0xFF);
      out = out + 1l;
    }
    out->byte1 = (unsigned char)0;
    out->byte2 = (unsigned char)0;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c2b, (unsigned long int)((out - c2b) + (signed long int)1) * sizeof(struct anonymous_24) /*2ul*/ );
    c2b = (struct anonymous_24 *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = (signed int)(out - c2b);

    return c2b;
  }
}

// utf8_to_latin1
// file utf8wc.c line 347
extern char * utf8_to_latin1(const char *string, signed int ascii_p)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  unsigned char *ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1));
  ret = (unsigned char *)return_value_malloc_2;
  unsigned char *out = ret;
  if(ret == ((unsigned char *)NULL))
    return ((char *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int len2;
      len2=utf8_decode(in, in_end - in, &uc);
      in = in + len2;
      if(uc == 18446744073709551520ul)
        uc = (unsigned long int)32;

      else
        if(uc >= 768ul && !(uc >= 880ul))
          uc = (unsigned long int)0;

        else
          if(uc >= 256ul)
            switch(uc)
            {
              case (unsigned long int)0x2000:

              case (unsigned long int)0x2001:

              case (unsigned long int)0x2002:

              case (unsigned long int)0x2003:

              case (unsigned long int)0x2004:

              case (unsigned long int)0x2005:

              case (unsigned long int)0x2006:

              case (unsigned long int)0x2007:

              case (unsigned long int)0x2008:

              case (unsigned long int)0x2009:

              case (unsigned long int)0x200A:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2010:

              case (unsigned long int)0x2011:

              case (unsigned long int)0x2012:

              case (unsigned long int)0x2013:

              case (unsigned long int)0x2014:

              case (unsigned long int)0x2015:
              {
                uc = (unsigned long int)45;
                break;
              }
              case (unsigned long int)0x2018:

              case (unsigned long int)0x2019:

              case (unsigned long int)0x201A:

              case (unsigned long int)0x201B:
              {
                uc = (unsigned long int)39;
                break;
              }
              case (unsigned long int)0x201C:

              case (unsigned long int)0x201D:

              case (unsigned long int)0x201E:

              case (unsigned long int)0x201F:
              {
                uc = (unsigned long int)34;
                break;
              }
              case (unsigned long int)0x2022:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x2023:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2027:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x202F:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2038:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2039:
              {
                uc = (unsigned long int)-85;
                break;
              }
              case (unsigned long int)0x203A:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2041:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2042:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x2043:
              {
                uc = (unsigned long int)61;
                break;
              }
              case (unsigned long int)0x2044:
              {
                uc = (unsigned long int)47;
                break;
              }
              case (unsigned long int)0x204B:
              {
                uc = (unsigned long int)-74;
                break;
              }
              case (unsigned long int)0x204C:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204D:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204E:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x204F:
                uc = (unsigned long int)59;
            }

      if(uc >= 256ul)
        uc = (unsigned long int)(ascii_p != 0 ? 35 : -65);

      if(!(ascii_p == 0))
      {
        const unsigned char latin1_to_ascii[96l] = { ' ', '!', 'C', '#', '#', 'Y', '|', 'S', '_', 'C', '#', '<', '=', '-', 'R', '_', '#', '#', '2', '3', '\'', 'u', 'P', '.', ',', '1', 'o', '>', '#', '#', '#', '?', 'A', 'A', 'A', 'A', 'A', 'A', 'E', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', '0', 'U', 'U', 'U', 'U', 'Y', 'p', 'S', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', '/', 'o', 'u', 'u', 'u', 'u', 'y', 'p', 'y' };
        if(uc >= 160ul)
          uc = (unsigned long int)latin1_to_ascii[(signed long int)(uc - (unsigned long int)0xA0)];

      }

      if(uc >= 1ul)
      {
        unsigned char *tmp_post_3 = out;
        out = out + 1l;
        *tmp_post_3 = (unsigned char)uc;
      }

    }
    *out = (unsigned char)0;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)ret, (unsigned long int)((out - ret) + (signed long int)1) * sizeof(unsigned char) /*1ul*/ );
    ret = (unsigned char *)return_value_realloc_4;
    return (char *)ret;
  }
}

// value
// file asm6502.c line 1511
static unsigned char value(char **s, struct anonymous_8 *param)
{
  unsigned int val;
  unsigned char value__1__abs;
  unsigned char dir;
  char c = (char)0;
  unsigned char return_value_parseValue_1;
  return_value_parseValue_1=parseValue(s, &val);
  if(return_value_parseValue_1 == 0)
    return (unsigned char)0;

  else
  {
    value__1__abs = (unsigned char)(val > (unsigned int)0xFF);
    dir=getDirection(s, &c);
    unsigned char return_value_addvalue_2;
    return_value_addvalue_2=addvalue(param, val);
    if(return_value_addvalue_2 == 0)
      return (unsigned char)0;

    else
    {
      if(!(value__1__abs == 0) && !(dir == 0))
      {
        if((signed int)c == 88)
          param->type = (enum anonymous_60)ABS_X;

        else
          if((signed int)c == 89)
            param->type = (enum anonymous_60)ABS_Y;

          else
            return (unsigned char)0;
      }

      else
        if(!(value__1__abs == 0))
          param->type = (enum anonymous_60)ABS_VALUE;

        else
          if(!(dir == 0))
          {
            if((signed int)c == 88)
              param->type = (enum anonymous_60)ZERO_X;

            else
              if((signed int)c == 89)
                param->type = (enum anonymous_60)ZERO_Y;

              else
                return (unsigned char)0;
          }

          else
            param->type = (enum anonymous_60)ZERO;
      return (unsigned char)1;
    }
  }
}

// visual_cells
// file visual.c line 487
extern signed int visual_cells(struct anonymous_25 *screen, struct anonymous_13 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_19 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->colormap_size;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_class
// file visual.c line 409
extern signed int visual_class(struct anonymous_25 *screen, struct anonymous_13 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_19 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->class;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_25 *screen, struct anonymous_13 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_19 vi_in;
  struct anonymous_19 *vi_out;
  signed int out_count;
  signed int d;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_19 *)NULL))
    abort();

  d = (vi_out + (signed long int)0)->depth;
  XFree((void *)(char *)vi_out);
  return d;
}

// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_25 *screen, unsigned long int window, struct anonymous_13 *visual, unsigned long int cmap, signed int window_p)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  char *visual_string;
  visual_string=get_string_resource(screen->display, "visualID", "VisualID");
  struct anonymous_13 *desired_visual;
  desired_visual=pick_visual(screen);
  char win[100l];
  char why[100l];
  unsigned long int return_value_VirtualRootWindowOfScreen_1;
  return_value_VirtualRootWindowOfScreen_1=VirtualRootWindowOfScreen(screen);
  if(window == return_value_VirtualRootWindowOfScreen_1)
    strcpy(win, "root window");

  else
    sprintf(win, "window 0x%lx", (unsigned long int)window);
  if(!(window_p == 0))
    sprintf(why, "-window-id 0x%lx", (unsigned long int)window);

  else
    strcpy(why, "-root");
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_6;
  if(!(visual_string == ((char *)NULL)))
  {
    if(!(*visual_string == 0))
    {
      char *s = visual_string;
      for( ; !(*s == 0); s = s + 1l)
        if((signed int)*s >= 65)
        {
          if(!((signed int)*s >= 91))
            *s = (char)(((signed int)*s - 65) + 97);

        }

      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(visual_string, "default");
      _Bool tmp_if_expr_5;
      if(return_value_strcmp_3 == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcmp_4=strcmp(visual_string, "default");
        tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_7;
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strcmp_6=strcmp(visual_string, "best");
        tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_7)
      {
        if(!(visual == desired_visual))
        {
          fprintf(stderr, "%s: ignoring `-visual %s' because of `%s'.\n", progname, visual_string, (const void *)why);
          unsigned long int return_value_XVisualIDFromVisual_2;
          return_value_XVisualIDFromVisual_2=XVisualIDFromVisual(visual);
          fprintf(stderr, "%s: using %s's visual 0x%lx.\n", progname, (const void *)win, return_value_XVisualIDFromVisual_2);
        }

      }

      free((void *)visual_string);
    }

  }

  signed int return_value_has_writable_cells_9;
  signed int return_value_get_boolean_resource_8;
  if(visual == screen->root_visual)
  {
    return_value_has_writable_cells_9=has_writable_cells(screen, visual);
    if(!(return_value_has_writable_cells_9 == 0))
    {
      return_value_get_boolean_resource_8=get_boolean_resource(screen->display, "installColormap", "InstallColormap");
      if(!(return_value_get_boolean_resource_8 == 0))
      {
        fprintf(stderr, "%s: ignoring `-install' because of `%s'.\n", progname, (const void *)why);
        fprintf(stderr, "%s: using %s's colormap 0x%lx.\n", progname, (const void *)win, (unsigned long int)cmap);
      }

    }

  }

  if(!(ft->validate_visual_hook == ((signed int (*)(struct anonymous_25 *, const char *, struct anonymous_13 *))NULL)))
  {
    signed int return_value;
    return_value=ft->validate_visual_hook(screen, win, visual);
    if(return_value == 0)
      exit(1);

  }

}

// warnValue
// file asm6502.c line 459
static void warnValue(unsigned char isValue)
{
  if(isValue == 0)
    fprintf(stderr, "Invalid Value from getValue.\n");

}

// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed)
{
  signed int i;
  if(seed == 0u)
  {
    struct timeval tp;
    struct timezone tzp;
    gettimeofday(&tp, &tzp);
    seed = 999U * (unsigned int)tp.tv_sec;
    seed = seed << 11 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)11;
    seed = seed + (unsigned int)((signed long int)1001 * tp.tv_usec);
    seed = seed << 7 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)7;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    seed = seed + (unsigned int)(1003 * return_value_getpid_1);
    seed = seed << 13 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)13;
  }

  a[(signed long int)0] = a[(signed long int)0] + seed;
  i = 1;
  for( ; !(i >= 55); i = i + 1)
  {
    seed = seed * (unsigned int)999;
    seed = seed << 9 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)9;
    seed = seed + a[(signed long int)(i - 1)] * (unsigned int)1001;
    seed = seed << 15 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)15;
    a[(signed long int)i] = a[(signed long int)i] + seed;
  }
  i1 = (signed int)(a[(signed long int)0] % (unsigned int)55);
  i2 = (i1 + 24) % 55;
}

// ya_random
// file ./../utils/yarandom.h line 36
extern unsigned int ya_random(void)
{
  signed int ret = (signed int)(a[(signed long int)i1] + a[(signed long int)i2]);
  a[(signed long int)i1] = (unsigned int)ret;
  i1 = i1 + 1;
  if(i1 >= 55)
    i1 = 0;

  i2 = i2 + 1;
  if(i2 >= 55)
    i2 = 0;

  return (unsigned int)ret;
}

