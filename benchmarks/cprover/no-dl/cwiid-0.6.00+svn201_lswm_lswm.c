// tag-#anon#ST[ARR6{U8}_U8_'b'|]
// file /usr/include/bluetooth/bluetooth.h line 300
struct anonymous;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_4;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR6{U8}_U8_'b'|]#'bdaddr'||U8'pscan_rep_mode'||U8'pscan_period_mode'||U8'pscan_mode'||ARR3{U8}_U8_'dev_class'||U16'clock_offset'|]
// file /usr/include/bluetooth/hci.h line 1748
struct anonymous_1;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-acc_cal
// file cwiid.h line 199
struct acc_cal;

// tag-balance_cal
// file cwiid.h line 204
struct balance_cal;

// tag-balance_state
// file cwiid.h line 301
struct balance_state;

// tag-classic_state
// file cwiid.h line 293
struct classic_state;

// tag-cwiid_acc_mesg
// file cwiid.h line 223
struct cwiid_acc_mesg;

// tag-cwiid_balance_mesg
// file cwiid.h line 255
struct cwiid_balance_mesg;

// tag-cwiid_bdinfo
// file ../libcwiid/cwiid.h line 343
struct cwiid_bdinfo;

// tag-cwiid_btn_mesg
// file cwiid.h line 218
struct cwiid_btn_mesg;

// tag-cwiid_classic_mesg
// file cwiid.h line 246
struct cwiid_classic_mesg;

// tag-cwiid_command
// file cwiid.h line 164
enum cwiid_command { CWIID_CMD_STATUS=0, CWIID_CMD_LED=1, CWIID_CMD_RUMBLE=2, CWIID_CMD_RPT_MODE=3 };

// tag-cwiid_error
// file cwiid.h line 193
enum cwiid_error { CWIID_ERROR_NONE=0, CWIID_ERROR_DISCONNECT=1, CWIID_ERROR_COMM=2 };

// tag-cwiid_error_mesg
// file cwiid.h line 268
struct cwiid_error_mesg;

// tag-cwiid_ext_type
// file cwiid.h line 184
enum cwiid_ext_type { CWIID_EXT_NONE=0, CWIID_EXT_NUNCHUK=1, CWIID_EXT_CLASSIC=2, CWIID_EXT_BALANCE=3, CWIID_EXT_MOTIONPLUS=4, CWIID_EXT_UNKNOWN=5 };

// tag-cwiid_ir_mesg
// file cwiid.h line 234
struct cwiid_ir_mesg;

// tag-cwiid_ir_src
// file cwiid.h line 228
struct cwiid_ir_src;

// tag-cwiid_mesg
// file cwiid.h line 273
union cwiid_mesg;

// tag-cwiid_mesg_type
// file cwiid.h line 171
enum cwiid_mesg_type { CWIID_MESG_STATUS=0, CWIID_MESG_BTN=1, CWIID_MESG_ACC=2, CWIID_MESG_IR=3, CWIID_MESG_NUNCHUK=4, CWIID_MESG_CLASSIC=5, CWIID_MESG_BALANCE=6, CWIID_MESG_MOTIONPLUS=7, CWIID_MESG_ERROR=8, CWIID_MESG_UNKNOWN=9 };

// tag-cwiid_motionplus_mesg
// file cwiid.h line 263
struct cwiid_motionplus_mesg;

// tag-cwiid_nunchuk_mesg
// file cwiid.h line 239
struct cwiid_nunchuk_mesg;

// tag-cwiid_state
// file cwiid.h line 319
struct cwiid_state;

// tag-cwiid_status_mesg
// file cwiid.h line 212
struct cwiid_status_mesg;

// tag-ext_state
// file cwiid.h line 312
union ext_state;

// tag-mesg_array
// file cwiid_internal.h line 147
struct mesg_array;

// tag-motionplus_state
// file cwiid.h line 308
struct motionplus_state;

// tag-nunchuk_state
// file cwiid.h line 287
struct nunchuk_state;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rw_mesg
// file cwiid_internal.h line 161
struct rw_mesg;

// tag-rw_status
// file cwiid_internal.h line 154
enum rw_status { RW_IDLE=0, RW_READ=1, RW_WRITE=2, RW_CANCEL=3 };

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_l2
// file /usr/include/bluetooth/l2cap.h line 41
struct sockaddr_l2;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-wiimote
// file cwiid.h line 333
struct wiimote;

// tag-write_seq
// file cwiid_internal.h line 136
struct write_seq;

// tag-write_seq_type
// file cwiid_internal.h line 131
enum write_seq_type { WRITE_SEQ_RPT=0, WRITE_SEQ_MEM=1 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// ba2str
// file /usr/include/bluetooth/bluetooth.h line 326
signed int ba2str(const struct anonymous *, char *);
// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous *ba1, const struct anonymous *ba2);
// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous *dst, const struct anonymous *src);
// cancel_mesg_callback
// file cwiid_internal.h line 205
signed int cancel_mesg_callback(struct wiimote *wiimote);
// cancel_rw
// file cwiid_internal.h line 204
signed int cancel_rw(struct wiimote *wiimote);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cwiid_beep
// file command.c line 328
signed int cwiid_beep(struct wiimote *wiimote);
// cwiid_close
// file connect.c line 288
signed int cwiid_close(struct wiimote *wiimote);
// cwiid_command
// file command.c line 52
signed int cwiid_command(struct wiimote *wiimote, enum cwiid_command command, signed int flags);
// cwiid_disable
// file interface.c line 70
signed int cwiid_disable(struct wiimote *wiimote, signed int flags);
// cwiid_enable
// file interface.c line 50
signed int cwiid_enable(struct wiimote *wiimote, signed int flags);
// cwiid_err
// file cwiid_internal.h line 197
void cwiid_err(struct wiimote *wiimote, const char *str, ...);
// cwiid_err_default
// file util.c line 74
void cwiid_err_default(struct wiimote *wiimote, const char *str, void **ap);
// cwiid_err_func_object
//
void cwiid_err_func_object(struct wiimote *, const char *, void **);
// cwiid_find_wiimote
// file bluetooth.c line 173
signed int cwiid_find_wiimote(struct anonymous *bdaddr, signed int timeout);
// cwiid_get_acc_cal
// file interface.c line 161
signed int cwiid_get_acc_cal(struct wiimote *wiimote, enum cwiid_ext_type ext_type, struct acc_cal *acc_cal);
// cwiid_get_balance_cal
// file interface.c line 199
signed int cwiid_get_balance_cal(struct wiimote *wiimote, struct balance_cal *balance_cal);
// cwiid_get_bdinfo_array
// file ../libcwiid/cwiid.h line 397
signed int cwiid_get_bdinfo_array(signed int dev_id, unsigned int timeout, signed int max_bdinfo, struct cwiid_bdinfo **bdinfo, unsigned char flags);
// cwiid_get_data
// file interface.c line 45
const void * cwiid_get_data(struct wiimote *wiimote);
// cwiid_get_id
// file interface.c line 34
signed int cwiid_get_id(struct wiimote *wiimote);
// cwiid_get_mesg
// file interface.c line 115
signed int cwiid_get_mesg(struct wiimote *wiimote, signed int *mesg_count, union cwiid_mesg **mesg, struct timespec *timestamp);
// cwiid_get_state
// file interface.c line 143
signed int cwiid_get_state(struct wiimote *wiimote, struct cwiid_state *state);
// cwiid_open
// file connect.c line 68
struct wiimote * cwiid_open(struct anonymous *bdaddr, signed int flags);
// cwiid_open_timeout
// file connect.c line 73
struct wiimote * cwiid_open_timeout(struct anonymous *bdaddr, signed int flags, signed int timeout);
// cwiid_read
// file command.c line 157
signed int cwiid_read(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, void *data);
// cwiid_request_status
// file command.c line 108
signed int cwiid_request_status(struct wiimote *wiimote);
// cwiid_send_rpt
// file command.c line 79
signed int cwiid_send_rpt(struct wiimote *wiimote, unsigned char flags, unsigned char report, unsigned long int len, const void *data);
// cwiid_set_data
// file interface.c line 39
signed int cwiid_set_data(struct wiimote *wiimote, const void *data);
// cwiid_set_err
// file ../libcwiid/cwiid.h line 354
signed int cwiid_set_err(void (*err)(struct wiimote *, const char *, void **));
// cwiid_set_err::err_object
//
void err_object(struct wiimote *, const char *, void **);
// cwiid_set_led
// file command.c line 121
signed int cwiid_set_led(struct wiimote *wiimote, unsigned char led);
// cwiid_set_mesg_callback
// file interface.c line 92
signed int cwiid_set_mesg_callback(struct wiimote *wiimote, void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *));
// cwiid_set_mesg_callback::callback_object
//
void callback_object(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
// cwiid_set_rpt_mode
// file command.c line 151
signed int cwiid_set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode);
// cwiid_set_rumble
// file command.c line 136
signed int cwiid_set_rumble(struct wiimote *wiimote, unsigned char rumble);
// cwiid_write
// file command.c line 234
signed int cwiid_write(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, const void *data);
// exec_write_seq
// file cwiid_internal.h line 199
signed int exec_write_seq(struct wiimote *wiimote, unsigned int len, struct write_seq *seq);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// full_read
// file cwiid_internal.h line 201
signed int full_read(signed int fd, void *buf, unsigned long int len);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// hci_close_dev
// file /usr/include/bluetooth/hci_lib.h line 52
signed int hci_close_dev(signed int);
// hci_get_route
// file /usr/include/bluetooth/hci_lib.h line 146
signed int hci_get_route(struct anonymous *);
// hci_inquiry
// file /usr/include/bluetooth/hci_lib.h line 59
signed int hci_inquiry(signed int, signed int, signed int, const unsigned char *, struct anonymous_1 **, signed long int);
// hci_open_dev
// file /usr/include/bluetooth/hci_lib.h line 51
signed int hci_open_dev(signed int);
// hci_read_remote_name
// file /usr/include/bluetooth/hci_lib.h line 66
signed int hci_read_remote_name(signed int, const struct anonymous *, signed int, char *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mesg_callback_thread
// file cwiid_internal.h line 194
void * mesg_callback_thread(struct wiimote *wiimote);
// mesg_callback_thread::1::callback_object
//
void callback_object(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// print_usage
// file lswm.c line 47
void print_usage(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_acc
// file process.c line 92
signed int process_acc(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_btn
// file process.c line 72
signed int process_btn(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_error
// file process.c line 28
signed int process_error(struct wiimote *wiimote, signed long int len, struct mesg_array *ma);
// process_ext
// file process.c line 180
signed int process_ext(struct wiimote *wiimote, unsigned char *data, unsigned char len, struct mesg_array *ma);
// process_ir10
// file process.c line 108
signed int process_ir10(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_ir12
// file process.c line 151
signed int process_ir12(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_read
// file process.c line 259
signed int process_read(struct wiimote *wiimote, unsigned char *data);
// process_status
// file process.c line 48
signed int process_status(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma);
// process_write
// file process.c line 282
signed int process_write(struct wiimote *wiimote, unsigned char *data);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_2 *, union anonymous_3 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_mesg_array
// file cwiid_internal.h line 203
signed int read_mesg_array(signed int fd, struct mesg_array *ma);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// router_thread
// file cwiid_internal.h line 192
void * router_thread(struct wiimote *wiimote);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// status_thread
// file cwiid_internal.h line 193
void * status_thread(struct wiimote *wiimote);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// update_rpt_mode
// file cwiid_internal.h line 222
signed int update_rpt_mode(struct wiimote *wiimote, signed char rpt_mode);
// update_state
// file state.c line 26
signed int update_state(struct wiimote *wiimote, struct mesg_array *ma);
// verify_handshake
// file cwiid_internal.h line 198
signed int verify_handshake(struct wiimote *wiimote);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_mesg_array
// file cwiid_internal.h line 202
signed int write_mesg_array(struct wiimote *wiimote, struct mesg_array *ma);

struct anonymous
{
  // b
  unsigned char b[6l];
} __attribute__ ((__packed__));

struct anonymous_4
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_1
{
  // bdaddr
  struct anonymous bdaddr;
  // pscan_rep_mode
  unsigned char pscan_rep_mode;
  // pscan_period_mode
  unsigned char pscan_period_mode;
  // pscan_mode
  unsigned char pscan_mode;
  // dev_class
  unsigned char dev_class[3l];
  // clock_offset
  unsigned short int clock_offset;
} __attribute__ ((__packed__));

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // __data
  struct anonymous_4 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct acc_cal
{
  // zero
  unsigned char zero[3l];
  // one
  unsigned char one[3l];
};

struct balance_cal
{
  // right_top
  unsigned short int right_top[3l];
  // right_bottom
  unsigned short int right_bottom[3l];
  // left_top
  unsigned short int left_top[3l];
  // left_bottom
  unsigned short int left_bottom[3l];
};

struct balance_state
{
  // right_top
  unsigned short int right_top;
  // right_bottom
  unsigned short int right_bottom;
  // left_top
  unsigned short int left_top;
  // left_bottom
  unsigned short int left_bottom;
};

struct classic_state
{
  // l_stick
  unsigned char l_stick[2l];
  // r_stick
  unsigned char r_stick[2l];
  // l
  unsigned char l;
  // r
  unsigned char r;
  // buttons
  unsigned short int buttons;
};

struct cwiid_acc_mesg
{
  // type
  enum cwiid_mesg_type type;
  // acc
  unsigned char acc[3l];
};

struct cwiid_balance_mesg
{
  // type
  enum cwiid_mesg_type type;
  // right_top
  unsigned short int right_top;
  // right_bottom
  unsigned short int right_bottom;
  // left_top
  unsigned short int left_top;
  // left_bottom
  unsigned short int left_bottom;
};

struct cwiid_bdinfo
{
  // bdaddr
  struct anonymous bdaddr;
  // btclass
  unsigned char btclass[3l];
  // name
  char name[32l];
};

struct cwiid_btn_mesg
{
  // type
  enum cwiid_mesg_type type;
  // buttons
  unsigned short int buttons;
};

struct cwiid_classic_mesg
{
  // type
  enum cwiid_mesg_type type;
  // l_stick
  unsigned char l_stick[2l];
  // r_stick
  unsigned char r_stick[2l];
  // l
  unsigned char l;
  // r
  unsigned char r;
  // buttons
  unsigned short int buttons;
};

struct cwiid_error_mesg
{
  // type
  enum cwiid_mesg_type type;
  // error
  enum cwiid_error error;
};

struct cwiid_ir_src
{
  // valid
  char valid;
  // pos
  unsigned short int pos[2l];
  // size
  signed char size;
};

struct cwiid_ir_mesg
{
  // type
  enum cwiid_mesg_type type;
  // src
  struct cwiid_ir_src src[4l];
};

struct cwiid_status_mesg
{
  // type
  enum cwiid_mesg_type type;
  // battery
  unsigned char battery;
  // ext_type
  enum cwiid_ext_type ext_type;
};

struct cwiid_nunchuk_mesg
{
  // type
  enum cwiid_mesg_type type;
  // stick
  unsigned char stick[2l];
  // acc
  unsigned char acc[3l];
  // buttons
  unsigned char buttons;
};

struct cwiid_motionplus_mesg
{
  // type
  enum cwiid_mesg_type type;
  // angle_rate
  unsigned short int angle_rate[3l];
};

union cwiid_mesg
{
  // type
  enum cwiid_mesg_type type;
  // status_mesg
  struct cwiid_status_mesg status_mesg;
  // btn_mesg
  struct cwiid_btn_mesg btn_mesg;
  // acc_mesg
  struct cwiid_acc_mesg acc_mesg;
  // ir_mesg
  struct cwiid_ir_mesg ir_mesg;
  // nunchuk_mesg
  struct cwiid_nunchuk_mesg nunchuk_mesg;
  // classic_mesg
  struct cwiid_classic_mesg classic_mesg;
  // balance_mesg
  struct cwiid_balance_mesg balance_mesg;
  // motionplus_mesg
  struct cwiid_motionplus_mesg motionplus_mesg;
  // error_mesg
  struct cwiid_error_mesg error_mesg;
};

struct nunchuk_state
{
  // stick
  unsigned char stick[2l];
  // acc
  unsigned char acc[3l];
  // buttons
  unsigned char buttons;
};

struct motionplus_state
{
  // angle_rate
  unsigned short int angle_rate[3l];
};

union ext_state
{
  // nunchuk
  struct nunchuk_state nunchuk;
  // classic
  struct classic_state classic;
  // balance
  struct balance_state balance;
  // motionplus
  struct motionplus_state motionplus;
};

struct cwiid_state
{
  // rpt_mode
  unsigned char rpt_mode;
  // led
  unsigned char led;
  // rumble
  unsigned char rumble;
  // battery
  unsigned char battery;
  // buttons
  unsigned short int buttons;
  // acc
  unsigned char acc[3l];
  // ir_src
  struct cwiid_ir_src ir_src[4l];
  // ext_type
  enum cwiid_ext_type ext_type;
  // ext
  union ext_state ext;
  // error
  enum cwiid_error error;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct mesg_array
{
  // count
  unsigned char count;
  // timestamp
  struct timespec timestamp;
  // array
  union cwiid_mesg array[5l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rw_mesg
{
  // type
  enum rw_status type;
  // error
  unsigned char error;
  // offset
  unsigned int offset;
  // len
  unsigned char len;
  // data
  char data[16l];
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_l2
{
  // l2_family
  unsigned short int l2_family;
  // l2_psm
  unsigned short int l2_psm;
  // l2_bdaddr
  struct anonymous l2_bdaddr;
  // l2_cid
  unsigned short int l2_cid;
  // l2_bdaddr_type
  unsigned char l2_bdaddr_type;
};

struct wiimote
{
  // flags
  signed int flags;
  // ctl_socket
  signed int ctl_socket;
  // int_socket
  signed int int_socket;
  // router_thread
  unsigned long int router_thread;
  // status_thread
  unsigned long int status_thread;
  // mesg_callback_thread
  unsigned long int mesg_callback_thread;
  // mesg_pipe
  signed int mesg_pipe[2l];
  // status_pipe
  signed int status_pipe[2l];
  // rw_pipe
  signed int rw_pipe[2l];
  // state
  struct cwiid_state state;
  // rw_status
  enum rw_status rw_status;
  // mesg_callback
  void (*mesg_callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *);
  // state_mutex
  union anonymous_3 state_mutex;
  // rw_mutex
  union anonymous_3 rw_mutex;
  // rpt_mutex
  union anonymous_3 rpt_mutex;
  // id
  signed int id;
  // data
  const void *data;
};

struct write_seq
{
  // type
  enum write_seq_type type;
  // report_offset
  unsigned int report_offset;
  // data
  const void *data;
  // len
  unsigned short int len;
  // flags
  unsigned char flags;
};


// cwiid_err_func
// file util.c line 63
static void (*cwiid_err_func)(struct wiimote *, const char *, void **);
// cwiid_err_func
// file util.c line 63
static void (*cwiid_err_func)(struct wiimote *, const char *, void **) = cwiid_err_default;
// global_mutex
// file connect.c line 64
union anonymous_3 global_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ir_block1
// file state.c line 108
unsigned char ir_block1[10l] = { 2, 0, 0, 'q', 1, 0, 170, 0, 'd', 0 };
// ir_block2
// file state.c line 109
unsigned char ir_block2[3l] = { 'c', 3, 0 };
// ir_disable_seq
// file state.c line 129
struct write_seq ir_disable_seq[2l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// ir_enable10_seq
// file state.c line 111
struct write_seq ir_enable10_seq[6l];
// ir_enable10_seq
// file state.c line 111
struct write_seq ir_enable10_seq[6l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00030, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00000, .data=(const void *)ir_block1,
    .len=(unsigned short int)(sizeof(unsigned char [10l]) /*10ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB0001A, .data=(const void *)ir_block2,
    .len=(unsigned short int)(sizeof(unsigned char [3l]) /*3ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00033, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 } };
// ir_enable12_seq
// file state.c line 120
struct write_seq ir_enable12_seq[6l];
// ir_enable12_seq
// file state.c line 120
struct write_seq ir_enable12_seq[6l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x13, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x1A, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00030, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00000, .data=(const void *)ir_block1,
    .len=(unsigned short int)(sizeof(unsigned char [10l]) /*10ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB0001A, .data=(const void *)ir_block2,
    .len=(unsigned short int)(sizeof(unsigned char [3l]) /*3ul*/  - (unsigned long int)1), .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xB00033, .data=(const void *)"\003",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 } };
// speaker_disable_seq
// file command.c line 322
struct write_seq speaker_disable_seq[2l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x14, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// speaker_enable_seq
// file command.c line 311
struct write_seq speaker_enable_seq[7l] = { { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x14, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\004",
    .len=(unsigned short int)1, .flags=(unsigned char)0 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20009, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20001, .data=(const void *)"\b",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20001, .data=(const void *)"\0\0\0\f@\0\0",
    .len=(unsigned short int)7,
    .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)1, .report_offset=(unsigned int)0xA20008, .data=(const void *)"\001",
    .len=(unsigned short int)1, .flags=(unsigned char)0x04 },
    { .type=(enum write_seq_type)0, .report_offset=(unsigned int)0x19, .data=(const void *)"\0",
    .len=(unsigned short int)1, .flags=(unsigned char)0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// wiimote_id
// file connect.c line 65
static signed int wiimote_id = 0;

// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous *ba1, const struct anonymous *ba2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)ba1, (const void *)ba2, sizeof(struct anonymous) /*6ul*/ );
  return return_value_memcmp_1;
}

// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous *dst, const struct anonymous *src)
{
  memcpy((void *)dst, (const void *)src, sizeof(struct anonymous) /*6ul*/ );
}

// cancel_mesg_callback
// file cwiid_internal.h line 205
signed int cancel_mesg_callback(struct wiimote *wiimote)
{
  signed int ret = 0;
  signed int return_value_pthread_cancel_1;
  return_value_pthread_cancel_1=pthread_cancel(wiimote->mesg_callback_thread);
  if(!(return_value_pthread_cancel_1 == 0))
  {
    cwiid_err(wiimote, "Thread cancel error (callback thread)");
    ret = -1;
  }

  signed int return_value_pthread_detach_2;
  return_value_pthread_detach_2=pthread_detach(wiimote->mesg_callback_thread);
  if(!(return_value_pthread_detach_2 == 0))
  {
    cwiid_err(wiimote, "Thread detach error (callback thread)");
    ret = -1;
  }

  return ret;
}

// cancel_rw
// file cwiid_internal.h line 204
signed int cancel_rw(struct wiimote *wiimote)
{
  struct rw_mesg rw_mesg;
  rw_mesg.type = (enum rw_status)RW_CANCEL;
  signed long int return_value_write_1;
  return_value_write_1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
  if(!((unsigned long int)return_value_write_1 == sizeof(struct rw_mesg) /*32ul*/ ))
  {
    cwiid_err(wiimote, "Pipe write error (rw)");
    return -1;
  }

  else
    return 0;
}

// cwiid_beep
// file command.c line 328
signed int cwiid_beep(struct wiimote *wiimote)
{
  unsigned char buf[21l] = { (unsigned char)0xA0, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3, (unsigned char)0xC3 };
  signed int i;
  signed int ret = 0;
  union anonymous_3 timer_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  union anonymous_2 timer_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
  struct timespec t;
  signed int return_value_exec_write_seq_1;
  return_value_exec_write_seq_1=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [7l]) /*168ul*/  / sizeof(struct write_seq) /*24ul*/ ), speaker_enable_seq);
  if(!(return_value_exec_write_seq_1 == 0))
  {
    cwiid_err(wiimote, "Speaker enable error");
    ret = -1;
  }

  pthread_mutex_lock(&timer_mutex);
  i = 0;
  for( ; !(i >= 100); i = i + 1)
  {
    clock_gettime(0, &t);
    t.tv_nsec = t.tv_nsec + (signed long int)10204081;
    signed int return_value_cwiid_send_rpt_2;
    return_value_cwiid_send_rpt_2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x18, (unsigned long int)21, (const void *)buf);
    if(!(return_value_cwiid_send_rpt_2 == 0))
    {
      printf("%d\n", i);
      cwiid_err(wiimote, "Report send error (speaker data)");
      ret = -1;
      break;
    }

    pthread_cond_timedwait(&timer_cond, &timer_mutex, &t);
  }
  pthread_mutex_unlock(&timer_mutex);
  signed int return_value_exec_write_seq_3;
  return_value_exec_write_seq_3=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [2l]) /*48ul*/  / sizeof(struct write_seq) /*24ul*/ ), speaker_disable_seq);
  if(!(return_value_exec_write_seq_3 == 0))
  {
    cwiid_err(wiimote, "Speaker disable error");
    ret = -1;
  }

  return ret;
}

// cwiid_close
// file connect.c line 288
signed int cwiid_close(struct wiimote *wiimote)
{
  void *pthread_ret;
  signed int return_value_pthread_cancel_1;
  return_value_pthread_cancel_1=pthread_cancel(wiimote->router_thread);
  signed int return_value_pthread_join_2;
  return_value_pthread_join_2=pthread_join(wiimote->router_thread, &pthread_ret);
  if(!(return_value_pthread_join_2 == 0))
    cwiid_err(wiimote, "Thread join error (router thread)");

  else
    if(!(pthread_ret == NULL) && !(pthread_ret == (void *)-1))
      cwiid_err(wiimote, "Bad return value from router thread");

  signed int return_value_pthread_cancel_3;
  return_value_pthread_cancel_3=pthread_cancel(wiimote->status_thread);
  signed int return_value_pthread_join_4;
  return_value_pthread_join_4=pthread_join(wiimote->status_thread, &pthread_ret);
  if(!(return_value_pthread_join_4 == 0))
    cwiid_err(wiimote, "Thread join error (status thread)");

  else
    if(!(pthread_ret == NULL) && !(pthread_ret == (void *)-1))
      cwiid_err(wiimote, "Bad return value from status thread");

  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_cancel_mesg_callback_5;
    return_value_cancel_mesg_callback_5=cancel_mesg_callback(wiimote);
  }

  signed int return_value_cancel_rw_6;
  return_value_cancel_rw_6=cancel_rw(wiimote);
  signed int return_value_close_7;
  return_value_close_7=close(wiimote->int_socket);
  if(!(return_value_close_7 == 0))
    cwiid_err(wiimote, "Socket close error (interrupt channel)");

  signed int return_value_close_8;
  return_value_close_8=close(wiimote->ctl_socket);
  if(!(return_value_close_8 == 0))
    cwiid_err(wiimote, "Socket close error (control channel)");

  signed int return_value_close_9;
  return_value_close_9=close(wiimote->mesg_pipe[(signed long int)0]);
  _Bool tmp_if_expr_11;
  signed int return_value_close_10;
  if(!(return_value_close_9 == 0))
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value_close_10=close(wiimote->mesg_pipe[(signed long int)1]);
    tmp_if_expr_11 = return_value_close_10 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_11)
    cwiid_err(wiimote, "Pipe close error (mesg pipe)");

  signed int return_value_close_12;
  return_value_close_12=close(wiimote->status_pipe[(signed long int)0]);
  _Bool tmp_if_expr_14;
  signed int return_value_close_13;
  if(!(return_value_close_12 == 0))
    tmp_if_expr_14 = (_Bool)1;

  else
  {
    return_value_close_13=close(wiimote->status_pipe[(signed long int)1]);
    tmp_if_expr_14 = return_value_close_13 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_14)
    cwiid_err(wiimote, "Pipe close error (status pipe)");

  signed int return_value_close_15;
  return_value_close_15=close(wiimote->rw_pipe[(signed long int)0]);
  _Bool tmp_if_expr_17;
  signed int return_value_close_16;
  if(!(return_value_close_15 == 0))
    tmp_if_expr_17 = (_Bool)1;

  else
  {
    return_value_close_16=close(wiimote->rw_pipe[(signed long int)1]);
    tmp_if_expr_17 = return_value_close_16 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_17)
    cwiid_err(wiimote, "Pipe close error (rw pipe)");

  signed int return_value_pthread_mutex_destroy_18;
  return_value_pthread_mutex_destroy_18=pthread_mutex_destroy(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_destroy_18 == 0))
    cwiid_err(wiimote, "Mutex destroy error (state)");

  signed int return_value_pthread_mutex_destroy_19;
  return_value_pthread_mutex_destroy_19=pthread_mutex_destroy(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_destroy_19 == 0))
    cwiid_err(wiimote, "Mutex destroy error (rw)");

  signed int return_value_pthread_mutex_destroy_20;
  return_value_pthread_mutex_destroy_20=pthread_mutex_destroy(&wiimote->rpt_mutex);
  if(!(return_value_pthread_mutex_destroy_20 == 0))
    cwiid_err(wiimote, "Mutex destroy error (rpt)");

  free((void *)wiimote);
  return 0;
}

// cwiid_command
// file command.c line 52
signed int cwiid_command(struct wiimote *wiimote, enum cwiid_command command, signed int flags)
{
  signed int ret;
  switch((signed int)command)
  {
    case CWIID_CMD_STATUS:
    {
      ret=cwiid_request_status(wiimote);
      break;
    }
    case CWIID_CMD_LED:
    {
      ret=cwiid_set_led(wiimote, (unsigned char)flags);
      break;
    }
    case CWIID_CMD_RUMBLE:
    {
      ret=cwiid_set_rumble(wiimote, (unsigned char)flags);
      break;
    }
    case CWIID_CMD_RPT_MODE:
    {
      ret=cwiid_set_rpt_mode(wiimote, (unsigned char)flags);
      break;
    }
    default:
      ret = -1;
  }
  return ret;
}

// cwiid_disable
// file interface.c line 70
signed int cwiid_disable(struct wiimote *wiimote, signed int flags)
{
  unsigned char data;
  if(!((0x08 & flags) == 0))
  {
    if(!((0x08 & wiimote->flags) == 0))
    {
      signed int return_value_fcntl_1;
      return_value_fcntl_1=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 0);
      if(!(return_value_fcntl_1 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        return -1;
      }

    }

  }

  if(!((0x10 & flags) == 0))
  {
    data = (unsigned char)0x55;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400F0, (unsigned short int)1, (const void *)&data);
    data = (unsigned char)0x00;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400FB, (unsigned short int)1, (const void *)&data);
    cwiid_request_status(wiimote);
  }

  wiimote->flags = wiimote->flags & ~flags;
  return 0;
}

// cwiid_enable
// file interface.c line 50
signed int cwiid_enable(struct wiimote *wiimote, signed int flags)
{
  unsigned char data;
  if(!((0x08 & flags) == 0))
  {
    if((0x08 & wiimote->flags) == 0)
    {
      signed int return_value_fcntl_1;
      return_value_fcntl_1=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 04000);
      if(!(return_value_fcntl_1 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        return -1;
      }

    }

  }

  if(!((0x10 & flags) == 0))
  {
    data = (unsigned char)0x04;
    cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA600FE, (unsigned short int)1, (const void *)&data);
    cwiid_request_status(wiimote);
  }

  wiimote->flags = wiimote->flags | flags;
  return 0;
}

// cwiid_err
// file cwiid_internal.h line 197
void cwiid_err(struct wiimote *wiimote, const char *str, ...)
{
  void **ap;
  if(!(cwiid_err_func == ((void (*)(struct wiimote *, const char *, void **))NULL)))
  {
    ap = (void **)&str;
    cwiid_err_func(wiimote, str, ap);
    ap = ((void **)NULL);
  }

}

// cwiid_err_default
// file util.c line 74
void cwiid_err_default(struct wiimote *wiimote, const char *str, void **ap)
{
  vfprintf(stderr, str, ap);
  fprintf(stderr, "\n");
}

// cwiid_find_wiimote
// file bluetooth.c line 173
signed int cwiid_find_wiimote(struct anonymous *bdaddr, signed int timeout)
{
  struct cwiid_bdinfo *bdinfo;
  signed int bdinfo_count;
  if(timeout == -1)
  {
    do
    {
      bdinfo_count=cwiid_get_bdinfo_array(-1, (unsigned int)2, 1, &bdinfo, (unsigned char)0);
      if(!(bdinfo_count == 0))
        break;

    }
    while((_Bool)1);
    if(bdinfo_count == -1)
      return -1;

  }

  else
  {
    bdinfo_count=cwiid_get_bdinfo_array(-1, (unsigned int)timeout, 1, &bdinfo, (unsigned char)0);
    if(bdinfo_count == -1)
      return -1;

    else
      if(bdinfo_count == 0)
      {
        cwiid_err((struct wiimote *)(void *)0, "No wiimotes found");
        return -1;
      }

  }
  bacpy(bdaddr, &(bdinfo + (signed long int)0)->bdaddr);
  free((void *)bdinfo);
  return 0;
}

// cwiid_get_acc_cal
// file interface.c line 161
signed int cwiid_get_acc_cal(struct wiimote *wiimote, enum cwiid_ext_type ext_type, struct acc_cal *acc_cal)
{
  unsigned char flags;
  unsigned int offset;
  unsigned char buf[7l];
  char *err_str;
  switch((signed int)ext_type)
  {
    case CWIID_EXT_NONE:
    {
      flags = (unsigned char)0x00;
      offset = (unsigned int)0x16;
      err_str = "";
      break;
    }
    case CWIID_EXT_NUNCHUK:
    {
      flags = (unsigned char)0x04;
      offset = (unsigned int)0xA40020;
      err_str = "nunchuk ";
      break;
    }
    default:
    {
      cwiid_err(wiimote, "Unsupported calibration request");
      return -1;
    }
  }
  signed int return_value_cwiid_read_1;
  return_value_cwiid_read_1=cwiid_read(wiimote, flags, offset, (unsigned short int)7, (void *)buf);
  if(!(return_value_cwiid_read_1 == 0))
  {
    cwiid_err(wiimote, "Read error (%scal)", err_str);
    return -1;
  }

  else
  {
    acc_cal->zero[(signed long int)0] = buf[(signed long int)0];
    acc_cal->zero[(signed long int)1] = buf[(signed long int)1];
    acc_cal->zero[(signed long int)2] = buf[(signed long int)2];
    acc_cal->one[(signed long int)0] = buf[(signed long int)4];
    acc_cal->one[(signed long int)1] = buf[(signed long int)5];
    acc_cal->one[(signed long int)2] = buf[(signed long int)6];
    return 0;
  }
}

// cwiid_get_balance_cal
// file interface.c line 199
signed int cwiid_get_balance_cal(struct wiimote *wiimote, struct balance_cal *balance_cal)
{
  unsigned char buf[24l];
  signed int return_value_cwiid_read_1;
  return_value_cwiid_read_1=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xa40024, (unsigned short int)24, (void *)buf);
  if(!(return_value_cwiid_read_1 == 0))
  {
    cwiid_err(wiimote, "Read error (balancecal)");
    return -1;
  }

  else
  {
    balance_cal->right_top[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)0] << 8 | (signed int)(unsigned short int)buf[(signed long int)1]);
    balance_cal->right_bottom[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)2] << 8 | (signed int)(unsigned short int)buf[(signed long int)3]);
    balance_cal->left_top[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)4] << 8 | (signed int)(unsigned short int)buf[(signed long int)5]);
    balance_cal->left_bottom[(signed long int)0] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)6] << 8 | (signed int)(unsigned short int)buf[(signed long int)7]);
    balance_cal->right_top[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)8] << 8 | (signed int)(unsigned short int)buf[(signed long int)9]);
    balance_cal->right_bottom[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)10] << 8 | (signed int)(unsigned short int)buf[(signed long int)11]);
    balance_cal->left_top[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)12] << 8 | (signed int)(unsigned short int)buf[(signed long int)13]);
    balance_cal->left_bottom[(signed long int)1] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)14] << 8 | (signed int)(unsigned short int)buf[(signed long int)15]);
    balance_cal->right_top[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)16] << 8 | (signed int)(unsigned short int)buf[(signed long int)17]);
    balance_cal->right_bottom[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)18] << 8 | (signed int)(unsigned short int)buf[(signed long int)19]);
    balance_cal->left_top[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)20] << 8 | (signed int)(unsigned short int)buf[(signed long int)21]);
    balance_cal->left_bottom[(signed long int)2] = (unsigned short int)((signed int)(unsigned short int)buf[(signed long int)22] << 8 | (signed int)(unsigned short int)buf[(signed long int)23]);
    return 0;
  }
}

// cwiid_get_bdinfo_array
// file ../libcwiid/cwiid.h line 397
signed int cwiid_get_bdinfo_array(signed int dev_id, unsigned int timeout, signed int max_bdinfo, struct cwiid_bdinfo **bdinfo, unsigned char flags)
{
  struct anonymous_1 *dev_list = (struct anonymous_1 *)(void *)0;
  signed int max_inquiry;
  signed int dev_count;
  signed int sock = -1;
  signed int bdinfo_count;
  signed int i;
  signed int j;
  signed int err = 0;
  signed int ret;
  *bdinfo = (struct cwiid_bdinfo *)(void *)0;
  void *return_value_malloc_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_6;
  signed int return_value_strncmp_5;
  if(dev_id == -1)
  {
    dev_id=hci_get_route((struct anonymous *)(void *)0);
    if(!(dev_id == -1))
      goto __CPROVER_DUMP_L1;

    cwiid_err((struct wiimote *)(void *)0, "No Bluetooth interface found");
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!((0x01 & (signed int)flags) == 0) && !(max_bdinfo == -1))
      max_inquiry = max_bdinfo;

    else
      max_inquiry = 256;
    dev_count=hci_inquiry(dev_id, (signed int)timeout, max_inquiry, (const unsigned char *)(void *)0, &dev_list, (signed long int)0x0001);
    if(dev_count == -1)
    {
      cwiid_err((struct wiimote *)(void *)0, "Bluetooth device inquiry error");
      err = 1;
    }

    else
      if(dev_count == 0)
        bdinfo_count = 0;

      else
      {
        sock=hci_open_dev(dev_id);
        if(sock == -1)
        {
          cwiid_err((struct wiimote *)(void *)0, "Bluetooth interface open error");
          err = 1;
        }

        else
        {
          if(max_bdinfo == -1)
            max_bdinfo = dev_count;

          return_value_malloc_1=malloc((unsigned long int)max_bdinfo * sizeof(struct cwiid_bdinfo) /*41ul*/ );
          *bdinfo = (struct cwiid_bdinfo *)return_value_malloc_1;
          if(*bdinfo == ((struct cwiid_bdinfo *)NULL))
          {
            cwiid_err((struct wiimote *)(void *)0, "Memory allocation error (bdinfo array)");
            err = 1;
          }

          else
          {
            i = 0;
            bdinfo_count = i;
            for( ; !(bdinfo_count >= max_bdinfo) && !(i >= dev_count); i = i + 1)
            {
              if((0x01 & (signed int)flags) == 0)
              {
                if(!((signed int)(dev_list + (signed long int)i)->dev_class[0l] == 0x04))
                  tmp_if_expr_2 = (_Bool)1;

                else
                  tmp_if_expr_2 = (signed int)(dev_list + (signed long int)i)->dev_class[(signed long int)1] != 0x25 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_2)
                  tmp_if_expr_3 = (_Bool)1;

                else
                  tmp_if_expr_3 = (signed int)(dev_list + (signed long int)i)->dev_class[(signed long int)2] != 0x00 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_3)
                  goto __CPROVER_DUMP_L19;

              }

              signed int return_value_hci_read_remote_name_4;
              return_value_hci_read_remote_name_4=hci_read_remote_name(sock, &(dev_list + (signed long int)i)->bdaddr, 32, (*bdinfo + (signed long int)bdinfo_count)->name, 10000);
              if(!(return_value_hci_read_remote_name_4 == 0))
              {
                cwiid_err((struct wiimote *)(void *)0, "Bluetooth name read error");
                err = 1;
                goto CODA;
              }

              if((0x01 & (signed int)flags) == 0)
              {
                return_value_strncmp_6=strncmp((*bdinfo + (signed long int)bdinfo_count)->name, "Nintendo RVL-CNT-01", (unsigned long int)32);
                if(return_value_strncmp_6 == 0)
                  goto __CPROVER_DUMP_L16;

                return_value_strncmp_5=strncmp((*bdinfo + (signed long int)bdinfo_count)->name, "Nintendo RVL-WBC-01", (unsigned long int)32);
                if(return_value_strncmp_5 == 0)
                  goto __CPROVER_DUMP_L16;

              }

              else
              {

              __CPROVER_DUMP_L16:
                ;
                bacpy(&(*bdinfo + (signed long int)bdinfo_count)->bdaddr, &(dev_list + (signed long int)i)->bdaddr);
                j = 0;
                for( ; !(j >= 3); j = j + 1)
                  (*bdinfo + (signed long int)bdinfo_count)->btclass[(signed long int)j] = (dev_list + (signed long int)i)->dev_class[(signed long int)j];
                bdinfo_count = bdinfo_count + 1;
              }

            __CPROVER_DUMP_L19:
              ;
            }
            if(bdinfo_count == 0)
              free((void *)*bdinfo);

            else
              if(!(bdinfo_count >= max_bdinfo))
              {
                void *return_value_realloc_7;
                return_value_realloc_7=realloc((void *)*bdinfo, (unsigned long int)bdinfo_count * sizeof(struct cwiid_bdinfo) /*41ul*/ );
                *bdinfo = (struct cwiid_bdinfo *)return_value_realloc_7;
                if(*bdinfo == ((struct cwiid_bdinfo *)NULL))
                {
                  cwiid_err((struct wiimote *)(void *)0, "Memory reallocation error (bdinfo array)");
                  err = 1;
                }

              }

          }
        }
      }

  CODA:
    ;
    if(!(dev_list == ((struct anonymous_1 *)NULL)))
      free((void *)dev_list);

    if(!(sock == -1))
      hci_close_dev(sock);

    if(!(err == 0))
    {
      if(!(*bdinfo == ((struct cwiid_bdinfo *)NULL)))
        free((void *)*bdinfo);

      ret = -1;
    }

    else
      ret = bdinfo_count;
    return ret;
  }
}

// cwiid_get_data
// file interface.c line 45
const void * cwiid_get_data(struct wiimote *wiimote)
{
  return wiimote->data;
}

// cwiid_get_id
// file interface.c line 34
signed int cwiid_get_id(struct wiimote *wiimote)
{
  return wiimote->id;
}

// cwiid_get_mesg
// file interface.c line 115
signed int cwiid_get_mesg(struct wiimote *wiimote, signed int *mesg_count, union cwiid_mesg **mesg, struct timespec *timestamp)
{
  struct mesg_array ma;
  signed int return_value_read_mesg_array_2;
  return_value_read_mesg_array_2=read_mesg_array(wiimote->mesg_pipe[(signed long int)0], &ma);
  if(!(return_value_read_mesg_array_2 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
      return -1;

    else
    {
      cwiid_err(wiimote, "Pipe read error (mesg_pipe)");
      return -1;
    }
  }

  *mesg_count = (signed int)ma.count;
  *timestamp = ma.timestamp;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)ma.count * sizeof(union cwiid_mesg) /*36ul*/ );
  *mesg = (union cwiid_mesg *)return_value_malloc_3;
  if(*mesg == ((union cwiid_mesg *)NULL))
  {
    cwiid_err(wiimote, "Memory allocation error (mesg array)");
    return -1;
  }

  else
  {
    memcpy((void *)*mesg, (const void *)&ma.array, (unsigned long int)ma.count * sizeof(union cwiid_mesg) /*36ul*/ );
    return 0;
  }
}

// cwiid_get_state
// file interface.c line 143
signed int cwiid_get_state(struct wiimote *wiimote, struct cwiid_state *state)
{
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (state mutex)");
    return -1;
  }

  else
  {
    memcpy((void *)state, (const void *)&wiimote->state, sizeof(struct cwiid_state) /*60ul*/ );
    signed int return_value_pthread_mutex_unlock_2;
    return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&wiimote->state_mutex);
    if(!(return_value_pthread_mutex_unlock_2 == 0))
    {
      cwiid_err(wiimote, "Mutex unlock error (state mutex) - deadlock warning");
      return -1;
    }

    else
      return 0;
  }
}

// cwiid_open
// file connect.c line 68
struct wiimote * cwiid_open(struct anonymous *bdaddr, signed int flags)
{
  struct wiimote *return_value_cwiid_open_timeout_1;
  return_value_cwiid_open_timeout_1=cwiid_open_timeout(bdaddr, flags, 5);
  return return_value_cwiid_open_timeout_1;
}

// cwiid_open_timeout
// file connect.c line 73
struct wiimote * cwiid_open_timeout(struct anonymous *bdaddr, signed int flags, signed int timeout)
{
  struct wiimote *wiimote = (struct wiimote *)(void *)0;
  struct sockaddr_l2 remote_addr;
  char mesg_pipe_init = (char)0;
  char status_pipe_init = (char)0;
  char rw_pipe_init = (char)0;
  char state_mutex_init = (char)0;
  char rw_mutex_init = (char)0;
  char rpt_mutex_init = (char)0;
  char router_thread_init = (char)0;
  char status_thread_init = (char)0;
  void *pthread_ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct wiimote) /*272ul*/ );
  wiimote = (struct wiimote *)return_value_malloc_1;
  signed int return_value_pthread_mutex_lock_2;
  signed int tmp_post_3;
  signed int return_value_pthread_mutex_unlock_4;
  struct anonymous literal_6;
  signed int return_value_bacmp_7;
  signed int return_value_connect_8;
  signed int return_value_connect_9;
  signed int return_value_pipe_10;
  signed int return_value_pipe_11;
  signed int return_value_pipe_12;
  signed int return_value_fcntl_13;
  signed int return_value_pthread_mutex_init_15;
  signed int return_value_pthread_mutex_init_16;
  signed int return_value_pthread_mutex_init_17;
  signed int return_value_pthread_create_18;
  signed int return_value_pthread_create_19;
  if(wiimote == ((struct wiimote *)NULL))
    cwiid_err((struct wiimote *)(void *)0, "Memory allocation error (cwiid_wiimote_t)");

  else
  {
    wiimote->flags = flags;
    wiimote->int_socket = -1;
    wiimote->ctl_socket = wiimote->int_socket;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&global_mutex);
    if(!(return_value_pthread_mutex_lock_2 == 0))
      cwiid_err((struct wiimote *)(void *)0, "Mutex lock error (global mutex)");

    else
    {
      tmp_post_3 = wiimote_id;
      wiimote_id = wiimote_id + 1;
      wiimote->id = tmp_post_3;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&global_mutex);
      if(!(return_value_pthread_mutex_unlock_4 == 0))
        cwiid_err(wiimote, "Mutex unlock error (global mutex) - deadlock warning");

      else
      {
        literal_6 = (struct anonymous){ .b={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } };
        return_value_bacmp_7=bacmp(bdaddr, &literal_6);
        if(return_value_bacmp_7 == 0)
        {
          signed int return_value_cwiid_find_wiimote_5;
          return_value_cwiid_find_wiimote_5=cwiid_find_wiimote(bdaddr, timeout);
          if(!(return_value_cwiid_find_wiimote_5 == 0))
            goto ERR_HND;

          sleep((unsigned int)1);
        }

        memset((void *)&remote_addr, 0, sizeof(struct sockaddr_l2) /*14ul*/ );
        remote_addr.l2_family = (unsigned short int)31;
        remote_addr.l2_bdaddr = *bdaddr;
        remote_addr.l2_psm = (unsigned short int)17;
        wiimote->ctl_socket=socket(31, 5, 0);
        if(wiimote->ctl_socket == -1)
          cwiid_err(wiimote, "Socket creation error (control socket)");

        else
        {
          return_value_connect_8=connect(wiimote->ctl_socket, (struct sockaddr *)&remote_addr, (unsigned int)sizeof(struct sockaddr_l2) /*14ul*/ );
          if(!(return_value_connect_8 == 0))
            cwiid_err(wiimote, "Socket connect error (control channel)");

          else
          {
            remote_addr.l2_psm = (unsigned short int)19;
            wiimote->int_socket=socket(31, 5, 0);
            if(wiimote->int_socket == -1)
              cwiid_err(wiimote, "Socket creation error (interrupt socket)");

            else
            {
              return_value_connect_9=connect(wiimote->int_socket, (struct sockaddr *)&remote_addr, (unsigned int)sizeof(struct sockaddr_l2) /*14ul*/ );
              if(!(return_value_connect_9 == 0))
                cwiid_err(wiimote, "Socket connect error (interrupt channel)");

              else
              {
                return_value_pipe_10=pipe(wiimote->mesg_pipe);
                if(!(return_value_pipe_10 == 0))
                  cwiid_err(wiimote, "Pipe creation error (mesg pipe)");

                else
                {
                  mesg_pipe_init = (char)1;
                  return_value_pipe_11=pipe(wiimote->status_pipe);
                  if(!(return_value_pipe_11 == 0))
                    cwiid_err(wiimote, "Pipe creation error (status pipe)");

                  else
                  {
                    status_pipe_init = (char)1;
                    return_value_pipe_12=pipe(wiimote->rw_pipe);
                    if(!(return_value_pipe_12 == 0))
                      cwiid_err(wiimote, "Pipe creation error (rw pipe)");

                    else
                    {
                      rw_pipe_init = (char)1;
                      return_value_fcntl_13=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 04000);
                      if(!(return_value_fcntl_13 == 0))
                        cwiid_err(wiimote, "File control error (mesg write pipe)");

                      else
                      {
                        if(!((0x08 & wiimote->flags) == 0))
                        {
                          signed int return_value_fcntl_14;
                          return_value_fcntl_14=fcntl(wiimote->mesg_pipe[(signed long int)0], 4, 04000);
                          if(!(return_value_fcntl_14 == 0))
                          {
                            cwiid_err(wiimote, "File control error (mesg read pipe)");
                            goto ERR_HND;
                          }

                        }

                        return_value_pthread_mutex_init_15=pthread_mutex_init(&wiimote->state_mutex, (const union anonymous_0 *)(void *)0);
                        if(!(return_value_pthread_mutex_init_15 == 0))
                          cwiid_err(wiimote, "Mutex initialization error (state mutex)");

                        else
                        {
                          state_mutex_init = (char)1;
                          return_value_pthread_mutex_init_16=pthread_mutex_init(&wiimote->rw_mutex, (const union anonymous_0 *)(void *)0);
                          if(!(return_value_pthread_mutex_init_16 == 0))
                            cwiid_err(wiimote, "Mutex initialization error (rw mutex)");

                          else
                          {
                            rw_mutex_init = (char)1;
                            return_value_pthread_mutex_init_17=pthread_mutex_init(&wiimote->rpt_mutex, (const union anonymous_0 *)(void *)0);
                            if(!(return_value_pthread_mutex_init_17 == 0))
                              cwiid_err(wiimote, "Mutex initialization error (rpt mutex)");

                            else
                            {
                              rpt_mutex_init = (char)1;
                              wiimote->rw_status = (enum rw_status)RW_IDLE;
                              return_value_pthread_create_18=pthread_create(&wiimote->router_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))router_thread, (void *)wiimote);
                              if(!(return_value_pthread_create_18 == 0))
                                cwiid_err(wiimote, "Thread creation error (router thread)");

                              else
                              {
                                router_thread_init = (char)1;
                                return_value_pthread_create_19=pthread_create(&wiimote->status_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))status_thread, (void *)wiimote);
                                if(!(return_value_pthread_create_19 == 0))
                                  cwiid_err(wiimote, "Thread creation error (status thread)");

                                else
                                {
                                  status_thread_init = (char)1;
                                  memset((void *)&wiimote->state, 0, sizeof(struct cwiid_state) /*60ul*/ );
                                  wiimote->mesg_callback = (void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))(void *)0;
                                  cwiid_set_led(wiimote, (unsigned char)0);
                                  cwiid_request_status(wiimote);
                                  return wiimote;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

ERR_HND:
  ;
  _Bool tmp_if_expr_26;
  signed int return_value_close_25;
  _Bool tmp_if_expr_29;
  signed int return_value_close_28;
  _Bool tmp_if_expr_32;
  signed int return_value_close_31;
  if(!(wiimote == ((struct wiimote *)NULL)))
  {
    if(!(router_thread_init == 0))
    {
      pthread_cancel(wiimote->router_thread);
      signed int return_value_pthread_join_20;
      return_value_pthread_join_20=pthread_join(wiimote->router_thread, &pthread_ret);
      if(!(return_value_pthread_join_20 == 0))
        cwiid_err(wiimote, "Thread join error (router thread)");

      else
        if(!(pthread_ret == NULL) || !(pthread_ret == (void *)-1))
          cwiid_err(wiimote, "Bad return value from router thread");

    }

    if(!(status_thread_init == 0))
    {
      pthread_cancel(wiimote->status_thread);
      signed int return_value_pthread_join_21;
      return_value_pthread_join_21=pthread_join(wiimote->status_thread, &pthread_ret);
      if(!(return_value_pthread_join_21 == 0))
        cwiid_err(wiimote, "Thread join error (status thread)");

      else
        if(!(pthread_ret == NULL) || !(pthread_ret == (void *)-1))
          cwiid_err(wiimote, "Bad return value from status thread");

    }

    if(!(wiimote->int_socket == -1))
    {
      signed int return_value_close_22;
      return_value_close_22=close(wiimote->int_socket);
      if(!(return_value_close_22 == 0))
        cwiid_err(wiimote, "Socket close error (interrupt channel)");

    }

    if(!(wiimote->ctl_socket == -1))
    {
      signed int return_value_close_23;
      return_value_close_23=close(wiimote->ctl_socket);
      if(!(return_value_close_23 == 0))
        cwiid_err(wiimote, "Socket close error (control channel)");

    }

    if(!(mesg_pipe_init == 0))
    {
      signed int return_value_close_24;
      return_value_close_24=close(wiimote->mesg_pipe[(signed long int)0]);
      if(!(return_value_close_24 == 0))
        tmp_if_expr_26 = (_Bool)1;

      else
      {
        return_value_close_25=close(wiimote->mesg_pipe[(signed long int)1]);
        tmp_if_expr_26 = return_value_close_25 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_26)
        cwiid_err(wiimote, "Pipe close error (mesg pipe)");

    }

    if(!(status_pipe_init == 0))
    {
      signed int return_value_close_27;
      return_value_close_27=close(wiimote->status_pipe[(signed long int)0]);
      if(!(return_value_close_27 == 0))
        tmp_if_expr_29 = (_Bool)1;

      else
      {
        return_value_close_28=close(wiimote->status_pipe[(signed long int)1]);
        tmp_if_expr_29 = return_value_close_28 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_29)
        cwiid_err(wiimote, "Pipe close error (status pipe)");

    }

    if(!(rw_pipe_init == 0))
    {
      signed int return_value_close_30;
      return_value_close_30=close(wiimote->rw_pipe[(signed long int)0]);
      if(!(return_value_close_30 == 0))
        tmp_if_expr_32 = (_Bool)1;

      else
      {
        return_value_close_31=close(wiimote->rw_pipe[(signed long int)1]);
        tmp_if_expr_32 = return_value_close_31 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_32)
        cwiid_err(wiimote, "Pipe close error (rw pipe)");

    }

    if(!(state_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy_33;
      return_value_pthread_mutex_destroy_33=pthread_mutex_destroy(&wiimote->state_mutex);
      if(!(return_value_pthread_mutex_destroy_33 == 0))
        cwiid_err(wiimote, "Mutex destroy error (state mutex)");

    }

    if(!(rw_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy_34;
      return_value_pthread_mutex_destroy_34=pthread_mutex_destroy(&wiimote->rw_mutex);
      if(!(return_value_pthread_mutex_destroy_34 == 0))
        cwiid_err(wiimote, "Mutex destroy error (rw mutex)");

    }

    if(!(rpt_mutex_init == 0))
    {
      signed int return_value_pthread_mutex_destroy_35;
      return_value_pthread_mutex_destroy_35=pthread_mutex_destroy(&wiimote->rpt_mutex);
      if(!(return_value_pthread_mutex_destroy_35 == 0))
        cwiid_err(wiimote, "Mutex destroy error (rpt mutex)");

    }

    free((void *)wiimote);
  }

  return (struct wiimote *)(void *)0;
}

// cwiid_read
// file command.c line 157
signed int cwiid_read(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, void *data)
{
  unsigned char buf[6l];
  struct rw_mesg mesg;
  unsigned char *cursor;
  signed int ret = 0;
  buf[(signed long int)0] = (unsigned char)((signed int)flags & (0x00 | 0x04));
  buf[(signed long int)1] = (unsigned char)(offset >> 16 & (unsigned int)0xFF);
  buf[(signed long int)2] = (unsigned char)(offset >> 8 & (unsigned int)0xFF);
  buf[(signed long int)3] = (unsigned char)(offset & (unsigned int)0xFF);
  buf[(signed long int)4] = (unsigned char)((signed int)len >> 8 & 0xFF);
  buf[(signed long int)5] = (unsigned char)((signed int)len & 0xFF);
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rw_mutex)");
    return -1;
  }

  else
  {
    wiimote->rw_status = (enum rw_status)RW_READ;
    signed int return_value_cwiid_send_rpt_2;
    return_value_cwiid_send_rpt_2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x17, (unsigned long int)6, (const void *)buf);
    if(!(return_value_cwiid_send_rpt_2 == 0))
    {
      cwiid_err(wiimote, "Report send error (read)");
      ret = -1;
    }

    else
    {
      cursor = (unsigned char *)data;
      for( ; !(cursor - (unsigned char *)data >= (signed long int)len); cursor = cursor + (signed long int)mesg.len)
      {
        signed int return_value_full_read_3;
        return_value_full_read_3=full_read(wiimote->rw_pipe[(signed long int)0], (void *)&mesg, sizeof(struct rw_mesg) /*32ul*/ );
        if(!(return_value_full_read_3 == 0))
        {
          cwiid_err(wiimote, "Pipe read error (rw pipe)");
          ret = -1;
          break;
        }

        if((signed int)mesg.type == RW_CANCEL)
        {
          ret = -1;
          break;
        }

        else
          if(!((signed int)mesg.type == RW_READ))
          {
            cwiid_err(wiimote, "Unexpected write message");
            ret = -1;
            break;
          }

        if(!(mesg.error == 0))
        {
          cwiid_err(wiimote, "Wiimote read error");
          ret = -1;
          break;
        }

        memcpy((void *)cursor, (const void *)&mesg.data, (unsigned long int)mesg.len);
      }
    }

  CODA:
    ;
    wiimote->rw_status = (enum rw_status)RW_IDLE;
    signed int return_value_pthread_mutex_unlock_4;
    return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&wiimote->rw_mutex);
    if(!(return_value_pthread_mutex_unlock_4 == 0))
      cwiid_err(wiimote, "Mutex unlock error (rw_mutex) - deadlock warning");

    return ret;
  }
}

// cwiid_request_status
// file command.c line 108
signed int cwiid_request_status(struct wiimote *wiimote)
{
  unsigned char data = (unsigned char)0;
  signed int return_value_cwiid_send_rpt_1;
  return_value_cwiid_send_rpt_1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x15, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt_1 == 0))
  {
    cwiid_err(wiimote, "Status request error");
    return -1;
  }

  else
    return 0;
}

// cwiid_send_rpt
// file command.c line 79
signed int cwiid_send_rpt(struct wiimote *wiimote, unsigned char flags, unsigned char report, unsigned long int len, const void *data)
{
  unsigned char *buf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(len * (unsigned long int)2 * sizeof(unsigned char) /*1ul*/ );
  buf = (unsigned char *)return_value_malloc_1;
  signed int return_value_verify_handshake_2;
  if(buf == ((unsigned char *)NULL))
  {
    cwiid_err(wiimote, "Memory allocation error (mesg array)");
    return -1;
  }

  else
  {
    buf[(signed long int)0] = (unsigned char)(0x50 | 0x02);
    buf[(signed long int)1] = report;
    memcpy((void *)(buf + (signed long int)2), data, len);
    if((0x01 & (signed int)flags) == 0)
      buf[(signed long int)2] = buf[(signed long int)2] | wiimote->state.rumble;

    signed long int return_value_write_3;
    return_value_write_3=write(wiimote->ctl_socket, (const void *)buf, len + (unsigned long int)2);
    if(!(return_value_write_3 == 2l + (signed long int)len))
    {
      free((void *)buf);
      return -1;
    }

    else
    {
      return_value_verify_handshake_2=verify_handshake(wiimote);
      if(!(return_value_verify_handshake_2 == 0))
      {
        free((void *)buf);
        return -1;
      }

    }
    return 0;
  }
}

// cwiid_set_data
// file interface.c line 39
signed int cwiid_set_data(struct wiimote *wiimote, const void *data)
{
  wiimote->data = data;
  return 0;
}

// cwiid_set_err
// file ../libcwiid/cwiid.h line 354
signed int cwiid_set_err(void (*err)(struct wiimote *, const char *, void **))
{
  cwiid_err_func = err;
  return 0;
}

// cwiid_set_led
// file command.c line 121
signed int cwiid_set_led(struct wiimote *wiimote, unsigned char led)
{
  unsigned char data;
  wiimote->state.led = (unsigned char)((signed int)led & 0x0F);
  data = (unsigned char)((signed int)wiimote->state.led << 4);
  signed int return_value_cwiid_send_rpt_1;
  return_value_cwiid_send_rpt_1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x11, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt_1 == 0))
  {
    cwiid_err(wiimote, "Report send error (led)");
    return -1;
  }

  else
    return 0;
}

// cwiid_set_mesg_callback
// file interface.c line 92
signed int cwiid_set_mesg_callback(struct wiimote *wiimote, void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))
{
  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_cancel_mesg_callback_1;
    return_value_cancel_mesg_callback_1=cancel_mesg_callback(wiimote);
    if(!(return_value_cancel_mesg_callback_1 == 0))
      return -1;

  }

  wiimote->mesg_callback = callback;
  if(!(wiimote->mesg_callback == ((void (*)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *))NULL)))
  {
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(&wiimote->mesg_callback_thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))mesg_callback_thread, (void *)wiimote);
    if(!(return_value_pthread_create_2 == 0))
    {
      cwiid_err(wiimote, "Thread creation error (callback thread)");
      return -1;
    }

  }

  return 0;
}

// cwiid_set_rpt_mode
// file command.c line 151
signed int cwiid_set_rpt_mode(struct wiimote *wiimote, unsigned char rpt_mode)
{
  signed int return_value_update_rpt_mode_1;
  return_value_update_rpt_mode_1=update_rpt_mode(wiimote, (signed char)rpt_mode);
  return return_value_update_rpt_mode_1;
}

// cwiid_set_rumble
// file command.c line 136
signed int cwiid_set_rumble(struct wiimote *wiimote, unsigned char rumble)
{
  unsigned char data;
  wiimote->state.rumble = (unsigned char)(rumble != 0 ? 1 : 0);
  data = (unsigned char)((signed int)wiimote->state.led << 4);
  signed int return_value_cwiid_send_rpt_1;
  return_value_cwiid_send_rpt_1=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x11, (unsigned long int)1, (const void *)&data);
  if(!(return_value_cwiid_send_rpt_1 == 0))
  {
    cwiid_err(wiimote, "Report send error (led)");
    return -1;
  }

  else
    return 0;
}

// cwiid_write
// file command.c line 234
signed int cwiid_write(struct wiimote *wiimote, unsigned char flags, unsigned int offset, unsigned short int len, const void *data)
{
  unsigned char buf[21l];
  unsigned short int sent = (unsigned short int)0;
  struct rw_mesg mesg;
  signed int ret = 0;
  buf[(signed long int)0] = flags;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&wiimote->rw_mutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rw mutex)");
    return -1;
  }

  else
  {
    wiimote->rw_status = (enum rw_status)RW_WRITE;
    while(!((signed int)sent >= (signed int)len))
    {
      buf[(signed long int)1] = (unsigned char)(offset + (unsigned int)sent >> 16 & (unsigned int)0xFF);
      buf[(signed long int)2] = (unsigned char)(offset + (unsigned int)sent >> 8 & (unsigned int)0xFF);
      buf[(signed long int)3] = (unsigned char)(offset + (unsigned int)sent & (unsigned int)0xFF);
      if((signed int)len + -((signed int)sent) >= 0x10)
        buf[(signed long int)4] = (unsigned char)0x10;

      else
        buf[(signed long int)4] = (unsigned char)((signed int)len - (signed int)sent);
      memcpy((void *)(buf + (signed long int)5), data + (signed long int)sent, (unsigned long int)buf[(signed long int)4]);
      signed int return_value_cwiid_send_rpt_2;
      return_value_cwiid_send_rpt_2=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x16, (unsigned long int)21, (const void *)buf);
      if(!(return_value_cwiid_send_rpt_2 == 0))
      {
        cwiid_err(wiimote, "Report send error (write)");
        ret = -1;
        break;
      }

      signed long int return_value_read_3;
      return_value_read_3=read(wiimote->rw_pipe[(signed long int)0], (void *)&mesg, sizeof(struct rw_mesg) /*32ul*/ );
      if(!((unsigned long int)return_value_read_3 == sizeof(struct rw_mesg) /*32ul*/ ))
      {
        cwiid_err(wiimote, "Pipe read error (rw pipe)");
        ret = -1;
        break;
      }

      if((signed int)mesg.type == RW_CANCEL)
      {
        ret = -1;
        break;
      }

      else
        if(!((signed int)mesg.type == RW_WRITE))
        {
          cwiid_err(wiimote, "Unexpected read message");
          ret = -1;
          break;
        }

      if(!(mesg.error == 0))
      {
        cwiid_err(wiimote, "Wiimote write error");
        ret = -1;
        break;
      }

      sent = sent + (unsigned short int)buf[(signed long int)4];
    }

  CODA:
    ;
    wiimote->rw_status = (enum rw_status)RW_IDLE;
    signed int return_value_pthread_mutex_unlock_4;
    return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&wiimote->rw_mutex);
    if(!(return_value_pthread_mutex_unlock_4 == 0))
      cwiid_err(wiimote, "Mutex unlock error (rw_mutex) - deadlock warning");

    return ret;
  }
}

// exec_write_seq
// file cwiid_internal.h line 199
signed int exec_write_seq(struct wiimote *wiimote, unsigned int len, struct write_seq *seq)
{
  unsigned int i = (unsigned int)0;
  signed int return_value_cwiid_send_rpt_1;
  signed int return_value_cwiid_write_2;
  for( ; !(i >= len); i = i + 1u)
    switch((signed int)(seq + (signed long int)i)->type)
    {
      case WRITE_SEQ_RPT:
      {
        return_value_cwiid_send_rpt_1=cwiid_send_rpt(wiimote, (seq + (signed long int)i)->flags, (unsigned char)(seq + (signed long int)i)->report_offset, (unsigned long int)(seq + (signed long int)i)->len, (seq + (signed long int)i)->data);
        if(!(return_value_cwiid_send_rpt_1 == 0))
          return -1;

        break;
      }
      case WRITE_SEQ_MEM:
      {
        return_value_cwiid_write_2=cwiid_write(wiimote, (seq + (signed long int)i)->flags, (seq + (signed long int)i)->report_offset, (seq + (signed long int)i)->len, (seq + (signed long int)i)->data);
        if(!(return_value_cwiid_write_2 == 0))
          return -1;

      }
    }
  return 0;
}

// full_read
// file cwiid_internal.h line 201
signed int full_read(signed int fd, void *buf, unsigned long int len)
{
  signed long int last_len = (signed long int)0;
  do
  {
    last_len=read(fd, buf, len);
    if(last_len == -1l)
      return -1;

    len = len - (unsigned long int)last_len;
    buf = buf + last_len;
  }
  while(len >= 1ul);
  return 0;
}

// main
// file lswm.c line 59
signed int main(signed int argc, char **argv)
{
  signed int c;
  unsigned char flags = (unsigned char)0;
  char long_format = (char)0;
  char quiet = (char)0;
  struct cwiid_bdinfo *bdinfo;
  signed int bdinfo_count;
  signed int i;
  char ba_str[18l];
  while((_Bool)1)
  {
    signed int option_index = 0;
    static struct option long_options[6l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name="all", .has_arg=0, .flag=((signed int *)NULL), .val=97 },
    { .name="long", .has_arg=0, .flag=((signed int *)NULL), .val=108 },
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="quiet", .has_arg=0, .flag=((signed int *)NULL), .val=113 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
    c=getopt_long(argc, argv, "halvq", long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 104:
      {
        print_usage();
        return 0;
      }
      case 97:
      {
        flags = flags | (unsigned char)0x01;
        break;
      }
      case 108:
      {
        long_format = (char)1;
        break;
      }
      case 118:
      {
        printf("CWiid Version %s\n", (const void *)"0.6.00");
        return 0;
      }
      case 113:
      {
        quiet = (char)1;
        break;
      }
      case 63:

      default:
      {
        fprintf(stderr, "Try '%s --help' for more information\n", argv[(signed long int)0]);
        return -1;
      }
    }
  }
  if(!(quiet == 0))
    cwiid_set_err((void (*)(struct wiimote *, const char *, void **))(void *)0);

  else
    if(!((0x01 & (signed int)flags) == 0))
      fprintf(stderr, "Put Bluetooth devices in discoverable mode now...\n");

    else
      fprintf(stderr, "Put Wiimotes in discoverable mode now (press 1+2)...\n");
  bdinfo_count=cwiid_get_bdinfo_array(-1, (unsigned int)2, -1, &bdinfo, flags);
  if(bdinfo_count == -1)
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= bdinfo_count); i = i + 1)
    {
      ba2str(&(bdinfo + (signed long int)i)->bdaddr, ba_str);
      if(!(long_format == 0))
        printf("%s 0x%.2X%.2X%.2X %s\n", (const void *)ba_str, (bdinfo + (signed long int)i)->btclass[(signed long int)2], (bdinfo + (signed long int)i)->btclass[(signed long int)1], (bdinfo + (signed long int)i)->btclass[(signed long int)0], (const void *)(bdinfo + (signed long int)i)->name);

      else
        printf("%s\n", (const void *)ba_str);
    }
    return 0;
  }
}

// mesg_callback_thread
// file cwiid_internal.h line 194
void * mesg_callback_thread(struct wiimote *wiimote)
{
  signed int mesg_pipe = wiimote->mesg_pipe[(signed long int)0];
  void (*callback)(struct wiimote *, signed int, union cwiid_mesg *, struct timespec *) = wiimote->mesg_callback;
  struct mesg_array ma;
  signed int cancelstate;
  while((_Bool)1)
  {
    signed int return_value_read_mesg_array_1;
    return_value_read_mesg_array_1=read_mesg_array(mesg_pipe, &ma);
    if(!(return_value_read_mesg_array_1 == 0))
      cwiid_err(wiimote, "Mesg pipe read error");

    else
    {
      signed int return_value_pthread_setcancelstate_2;
      return_value_pthread_setcancelstate_2=pthread_setcancelstate(1, &cancelstate);
      if(!(return_value_pthread_setcancelstate_2 == 0))
        cwiid_err(wiimote, "Cancel state disable error (callback thread)");

      callback(wiimote, (signed int)ma.count, ma.array, &ma.timestamp);
      signed int return_value_pthread_setcancelstate_3;
      return_value_pthread_setcancelstate_3=pthread_setcancelstate(0, &cancelstate);
      if(!(return_value_pthread_setcancelstate_3 == 0))
        cwiid_err(wiimote, "Cancel state restore error (callback thread)");

    }
  }
  return (void *)0;
}

// print_usage
// file lswm.c line 47
void print_usage(void)
{
  printf("lswm lists availiable wiimotes\n");
  printf("Usage: %s [OPTIONS]...\n\n", (const void *)"lswm");
  printf("Options:\n");
  printf("\t-h, --help\t\tPrints this output.\n");
  printf("\t-v, --version\t\toutput version information and exit.\n");
  printf("\t-l, --long\t\tlong format (device details).\n");
  printf("\t-q, --quiet\t\tquiet mode (less verbose).\n");
  printf("\t-a, --all\t\tlist all bluetooth devices (not just wiimotes).\n");
}

// process_acc
// file process.c line 92
signed int process_acc(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_acc_mesg *acc_mesg;
  unsigned char tmp_post_1;
  if(!((0x04 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post_1 = ma->count;
    ma->count = ma->count + 1;
    acc_mesg = &ma->array[(signed long int)tmp_post_1].acc_mesg;
    acc_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_ACC;
    acc_mesg->acc[(signed long int)0] = data[(signed long int)0];
    acc_mesg->acc[(signed long int)1] = data[(signed long int)1];
    acc_mesg->acc[(signed long int)2] = data[(signed long int)2];
  }

  return 0;
}

// process_btn
// file process.c line 72
signed int process_btn(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_btn_mesg *btn_mesg;
  unsigned short int buttons = (unsigned short int)(((signed int)data[(signed long int)0] & 0x1F) << 8 | (signed int)data[(signed long int)1] & 0x9F);
  _Bool tmp_if_expr_2;
  unsigned char tmp_post_1;
  if(!((0x02 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    if(!(wiimote->state.buttons == buttons))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (wiimote->flags & 0x04) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      tmp_post_1 = ma->count;
      ma->count = ma->count + 1;
      btn_mesg = &ma->array[(signed long int)tmp_post_1].btn_mesg;
      btn_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_BTN;
      btn_mesg->buttons = buttons;
    }

  }

  return 0;
}

// process_error
// file process.c line 28
signed int process_error(struct wiimote *wiimote, signed long int len, struct mesg_array *ma)
{
  struct cwiid_error_mesg *error_mesg;
  unsigned char tmp_post_1 = ma->count;
  ma->count = ma->count + 1;
  error_mesg = &ma->array[(signed long int)tmp_post_1].error_mesg;
  error_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_ERROR;
  if(len == 0l)
    error_mesg->error = (enum cwiid_error)CWIID_ERROR_DISCONNECT;

  else
    error_mesg->error = (enum cwiid_error)CWIID_ERROR_COMM;
  signed int return_value_cancel_rw_2;
  return_value_cancel_rw_2=cancel_rw(wiimote);
  if(!(return_value_cancel_rw_2 == 0))
    cwiid_err(wiimote, "RW cancel error");

  return 0;
}

// process_ext
// file process.c line 180
signed int process_ext(struct wiimote *wiimote, unsigned char *data, unsigned char len, struct mesg_array *ma)
{
  struct cwiid_nunchuk_mesg *nunchuk_mesg;
  struct cwiid_classic_mesg *classic_mesg;
  struct cwiid_balance_mesg *balance_mesg;
  struct cwiid_motionplus_mesg *motionplus_mesg;
  signed int i;
  unsigned char tmp_post_1;
  unsigned char tmp_post_2;
  unsigned char tmp_post_3;
  unsigned char tmp_post_4;
  switch((signed int)wiimote->state.ext_type)
  {
    case CWIID_EXT_NONE:
    {
      cwiid_err(wiimote, "Received unexpected extension report");
      break;
    }
    case CWIID_EXT_UNKNOWN:
      break;
    case CWIID_EXT_NUNCHUK:
    {
      if(!((0x10 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post_1 = ma->count;
        ma->count = ma->count + 1;
        nunchuk_mesg = &ma->array[(signed long int)tmp_post_1].nunchuk_mesg;
        nunchuk_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_NUNCHUK;
        nunchuk_mesg->stick[(signed long int)0] = data[(signed long int)0];
        nunchuk_mesg->stick[(signed long int)1] = data[(signed long int)1];
        nunchuk_mesg->acc[(signed long int)0] = data[(signed long int)2];
        nunchuk_mesg->acc[(signed long int)1] = data[(signed long int)3];
        nunchuk_mesg->acc[(signed long int)2] = data[(signed long int)4];
        nunchuk_mesg->buttons = (unsigned char)(~((signed int)data[(signed long int)5]) & 0x03);
      }

      break;
    }
    case CWIID_EXT_CLASSIC:
    {
      if(!((0x20 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post_2 = ma->count;
        ma->count = ma->count + 1;
        classic_mesg = &ma->array[(signed long int)tmp_post_2].classic_mesg;
        classic_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_CLASSIC;
        i = 0;
        for( ; !(i >= 6); i = i + 1)
          data[(signed long int)i] = data[(signed long int)i];
        classic_mesg->l_stick[(signed long int)0] = (unsigned char)((signed int)data[(signed long int)0] & 0x3F);
        classic_mesg->l_stick[(signed long int)1] = (unsigned char)((signed int)data[(signed long int)1] & 0x3F);
        classic_mesg->r_stick[(signed long int)0] = (unsigned char)(((signed int)data[(signed long int)0] & 0xC0) >> 3 | ((signed int)data[(signed long int)1] & 0xC0) >> 5 | ((signed int)data[(signed long int)2] & 0x80) >> 7);
        classic_mesg->r_stick[(signed long int)1] = (unsigned char)((signed int)data[(signed long int)2] & 0x1F);
        classic_mesg->l = (unsigned char)(((signed int)data[(signed long int)2] & 0x60) >> 2 | ((signed int)data[(signed long int)3] & 0xE0) >> 5);
        classic_mesg->r = (unsigned char)((signed int)data[(signed long int)3] & 0x1F);
        classic_mesg->buttons = (unsigned short int)~((signed int)(unsigned short int)data[(signed long int)4] << 8 | (signed int)(unsigned short int)data[(signed long int)5]);
      }

      break;
    }
    case CWIID_EXT_BALANCE:
      if(!((0x40 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post_3 = ma->count;
        ma->count = ma->count + 1;
        balance_mesg = &ma->array[(signed long int)tmp_post_3].balance_mesg;
        balance_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_BALANCE;
        balance_mesg->right_top = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)0] << 8 | (signed int)(unsigned short int)data[(signed long int)1]);
        balance_mesg->right_bottom = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)2] << 8 | (signed int)(unsigned short int)data[(signed long int)3]);
        balance_mesg->left_top = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)4] << 8 | (signed int)(unsigned short int)data[(signed long int)5]);
        balance_mesg->left_bottom = (unsigned short int)((signed int)(unsigned short int)data[(signed long int)6] << 8 | (signed int)(unsigned short int)data[(signed long int)7]);
      }

    case CWIID_EXT_MOTIONPLUS:
      if(!((0x80 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        tmp_post_4 = ma->count;
        ma->count = ma->count + 1;
        motionplus_mesg = &ma->array[(signed long int)tmp_post_4].motionplus_mesg;
        motionplus_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_MOTIONPLUS;
        motionplus_mesg->angle_rate[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)5] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)2]);
        motionplus_mesg->angle_rate[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)4] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)1]);
        motionplus_mesg->angle_rate[(signed long int)2] = (unsigned short int)(((signed int)(unsigned short int)data[(signed long int)3] & 0xFC) << 6 | (signed int)(unsigned short int)data[(signed long int)0]);
      }

  }
  return 0;
}

// process_ir10
// file process.c line 108
signed int process_ir10(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_ir_mesg *ir_mesg;
  signed int i;
  const unsigned char *block;
  unsigned char tmp_post_1;
  if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post_1 = ma->count;
    ma->count = ma->count + 1;
    ir_mesg = &ma->array[(signed long int)tmp_post_1].ir_mesg;
    ir_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_IR;
    i = 0;
    block = data;
    for( ; !(i >= 4); block = block + (signed long int)5)
    {
      if((signed int)*block == 0xFF)
        ir_mesg->src[(signed long int)i].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)i].valid = (char)1;
        ir_mesg->src[(signed long int)i].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x30) << 4 | (signed int)(unsigned short int)block[(signed long int)0]);
        ir_mesg->src[(signed long int)i].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0xC0) << 2 | (signed int)(unsigned short int)block[(signed long int)1]);
        ir_mesg->src[(signed long int)i].size = (signed char)-1;
      }
      if((signed int)block[3l] == 0xFF)
        ir_mesg->src[(signed long int)(i + 1)].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)(i + 1)].valid = (char)1;
        ir_mesg->src[(signed long int)(i + 1)].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x03) << 8 | (signed int)(unsigned short int)block[(signed long int)3]);
        ir_mesg->src[(signed long int)(i + 1)].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x0C) << 6 | (signed int)(unsigned short int)block[(signed long int)4]);
        ir_mesg->src[(signed long int)(i + 1)].size = (signed char)-1;
      }
      i = i + 2;
    }
  }

  return 0;
}

// process_ir12
// file process.c line 151
signed int process_ir12(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_ir_mesg *ir_mesg;
  signed int i;
  const unsigned char *block;
  unsigned char tmp_post_1;
  if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
  {
    tmp_post_1 = ma->count;
    ma->count = ma->count + 1;
    ir_mesg = &ma->array[(signed long int)tmp_post_1].ir_mesg;
    ir_mesg->type = (enum cwiid_mesg_type)CWIID_MESG_IR;
    i = 0;
    block = data;
    for( ; !(i >= 4); block = block + (signed long int)3)
    {
      if((signed int)*block == 0xFF)
        ir_mesg->src[(signed long int)i].valid = (char)0;

      else
      {
        ir_mesg->src[(signed long int)i].valid = (char)1;
        ir_mesg->src[(signed long int)i].pos[(signed long int)0] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0x30) << 4 | (signed int)(unsigned short int)block[(signed long int)0]);
        ir_mesg->src[(signed long int)i].pos[(signed long int)1] = (unsigned short int)(((signed int)(unsigned short int)block[(signed long int)2] & 0xC0) << 2 | (signed int)(unsigned short int)block[(signed long int)1]);
        ir_mesg->src[(signed long int)i].size = (signed char)((signed int)block[(signed long int)2] & 0x0F);
      }
      i = i + 1;
    }
  }

  return 0;
}

// process_read
// file process.c line 259
signed int process_read(struct wiimote *wiimote, unsigned char *data)
{
  struct rw_mesg rw_mesg;
  if(!((signed int)wiimote->rw_status == RW_READ))
  {
    cwiid_err(wiimote, "Received unexpected read report");
    return -1;
  }

  else
  {
    rw_mesg.type = (enum rw_status)RW_READ;
    rw_mesg.len = (unsigned char)(((signed int)data[(signed long int)0] >> 4) + 1);
    rw_mesg.error = (unsigned char)((signed int)data[(signed long int)0] & 0x0F);
    memcpy((void *)&rw_mesg.data, (const void *)(data + (signed long int)3), (unsigned long int)rw_mesg.len);
    signed long int return_value_write_1;
    return_value_write_1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
    if(!((unsigned long int)return_value_write_1 == sizeof(struct rw_mesg) /*32ul*/ ))
    {
      cwiid_err(wiimote, "RW pipe write error");
      return -1;
    }

    else
      return 0;
  }
}

// process_status
// file process.c line 48
signed int process_status(struct wiimote *wiimote, const unsigned char *data, struct mesg_array *ma)
{
  struct cwiid_status_mesg status_mesg;
  status_mesg.type = (enum cwiid_mesg_type)CWIID_MESG_STATUS;
  status_mesg.battery = data[(signed long int)5];
  if(!((0x02 & (signed int)data[2l]) == 0))
    status_mesg.ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;

  else
    status_mesg.ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
  signed long int return_value_write_1;
  return_value_write_1=write(wiimote->status_pipe[(signed long int)1], (const void *)&status_mesg, sizeof(struct cwiid_status_mesg) /*12ul*/ );
  if(!((unsigned long int)return_value_write_1 == sizeof(struct cwiid_status_mesg) /*12ul*/ ))
  {
    cwiid_err(wiimote, "Status pipe write error");
    return -1;
  }

  else
    return 0;
}

// process_write
// file process.c line 282
signed int process_write(struct wiimote *wiimote, unsigned char *data)
{
  struct rw_mesg rw_mesg;
  if(!((signed int)wiimote->rw_status == RW_WRITE))
  {
    cwiid_err(wiimote, "Received unexpected write report");
    return -1;
  }

  else
  {
    rw_mesg.type = (enum rw_status)RW_WRITE;
    rw_mesg.error = data[(signed long int)0];
    signed long int return_value_write_1;
    return_value_write_1=write(wiimote->rw_pipe[(signed long int)1], (const void *)&rw_mesg, sizeof(struct rw_mesg) /*32ul*/ );
    if(!((unsigned long int)return_value_write_1 == sizeof(struct rw_mesg) /*32ul*/ ))
    {
      cwiid_err(wiimote, "RW pipe write error");
      return -1;
    }

    else
      return 0;
  }
}

// read_mesg_array
// file cwiid_internal.h line 203
signed int read_mesg_array(signed int fd, struct mesg_array *ma)
{
  signed long int len = (void *)&ma->array[(signed long int)0] - (void *)ma;
  signed int return_value_full_read_1;
  return_value_full_read_1=full_read(fd, (void *)ma, (unsigned long int)len);
  if(!(return_value_full_read_1 == 0))
    return -1;

  else
  {
    len = (signed long int)((unsigned long int)ma->count * sizeof(union cwiid_mesg) /*36ul*/ );
    signed int return_value_full_read_2;
    return_value_full_read_2=full_read(fd, (void *)&ma->array[(signed long int)0], (unsigned long int)len);
    if(!(return_value_full_read_2 == 0))
      return -1;

    else
      return 0;
  }
}

// router_thread
// file cwiid_internal.h line 192
void * router_thread(struct wiimote *wiimote)
{
  unsigned char buf[23l];
  signed long int len;
  struct mesg_array ma;
  char err;
  char print_clock_err = (char)1;
  signed int return_value_process_status_2;
  signed int return_value_process_btn_3;
  signed int return_value_process_btn_4;
  _Bool tmp_if_expr_6;
  signed int return_value_process_acc_5;
  signed int return_value_process_btn_7;
  _Bool tmp_if_expr_9;
  signed int return_value_process_ext_8;
  signed int return_value_process_btn_10;
  _Bool tmp_if_expr_12;
  signed int return_value_process_acc_11;
  _Bool tmp_if_expr_14;
  signed int return_value_process_ir12_13;
  signed int return_value_process_btn_15;
  _Bool tmp_if_expr_17;
  signed int return_value_process_ext_16;
  signed int return_value_process_btn_18;
  _Bool tmp_if_expr_20;
  signed int return_value_process_acc_19;
  _Bool tmp_if_expr_22;
  signed int return_value_process_ext_21;
  signed int return_value_process_btn_23;
  _Bool tmp_if_expr_25;
  signed int return_value_process_ir10_24;
  _Bool tmp_if_expr_27;
  signed int return_value_process_ext_26;
  signed int return_value_process_btn_28;
  _Bool tmp_if_expr_30;
  signed int return_value_process_acc_29;
  _Bool tmp_if_expr_32;
  signed int return_value_process_ir10_31;
  _Bool tmp_if_expr_34;
  signed int return_value_process_ext_33;
  signed int return_value_process_ext_35;
  signed int return_value_process_read_36;
  _Bool tmp_if_expr_38;
  signed int return_value_process_btn_37;
  signed int return_value_process_write_39;
  while((_Bool)1)
  {
    len=read(wiimote->int_socket, (void *)buf, (unsigned long int)23);
    ma.count = (unsigned char)0;
    signed int return_value_clock_gettime_1;
    return_value_clock_gettime_1=clock_gettime(0, &ma.timestamp);
    if(!(return_value_clock_gettime_1 == 0))
    {
      if(!(print_clock_err == 0))
      {
        cwiid_err(wiimote, "clock_gettime error");
        print_clock_err = (char)0;
      }

    }

    err = (char)0;
    if(len == 0l || len == -1l)
    {
      process_error(wiimote, len, &ma);
      write_mesg_array(wiimote, &ma);
      break;
    }

    else
    {
      if(!((signed int)buf[0l] == 161))
        cwiid_err(wiimote, "Invalid packet type");

      switch((signed int)buf[(signed long int)1])
      {
        case 0x20:
        {
          return_value_process_status_2=process_status(wiimote, &buf[(signed long int)2], &ma);
          err = (char)return_value_process_status_2;
          break;
        }
        case 0x30:
        {
          return_value_process_btn_3=process_btn(wiimote, &buf[(signed long int)2], &ma);
          err = (char)return_value_process_btn_3;
          break;
        }
        case 0x31:
        {
          return_value_process_btn_4=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_4 == 0))
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_process_acc_5=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr_6 = return_value_process_acc_5 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_6;
          break;
        }
        case 0x32:
        {
          return_value_process_btn_7=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_7 == 0))
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_process_ext_8=process_ext(wiimote, &buf[(signed long int)4], (unsigned char)8, &ma);
            tmp_if_expr_9 = return_value_process_ext_8 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_9;
          break;
        }
        case 0x33:
        {
          return_value_process_btn_10=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_10 == 0))
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            return_value_process_acc_11=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr_12 = return_value_process_acc_11 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
            tmp_if_expr_14 = (_Bool)1;

          else
          {
            return_value_process_ir12_13=process_ir12(wiimote, &buf[(signed long int)7], &ma);
            tmp_if_expr_14 = return_value_process_ir12_13 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_14;
          break;
        }
        case 0x34:
        {
          return_value_process_btn_15=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_15 == 0))
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value_process_ext_16=process_ext(wiimote, &buf[(signed long int)4], (unsigned char)19, &ma);
            tmp_if_expr_17 = return_value_process_ext_16 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_17;
          break;
        }
        case 0x35:
        {
          return_value_process_btn_18=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_18 == 0))
            tmp_if_expr_20 = (_Bool)1;

          else
          {
            return_value_process_acc_19=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr_20 = return_value_process_acc_19 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_20)
            tmp_if_expr_22 = (_Bool)1;

          else
          {
            return_value_process_ext_21=process_ext(wiimote, &buf[(signed long int)7], (unsigned char)16, &ma);
            tmp_if_expr_22 = return_value_process_ext_21 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_22;
          break;
        }
        case 0x36:
        {
          return_value_process_btn_23=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_23 == 0))
            tmp_if_expr_25 = (_Bool)1;

          else
          {
            return_value_process_ir10_24=process_ir10(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr_25 = return_value_process_ir10_24 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_25)
            tmp_if_expr_27 = (_Bool)1;

          else
          {
            return_value_process_ext_26=process_ext(wiimote, &buf[(signed long int)14], (unsigned char)9, &ma);
            tmp_if_expr_27 = return_value_process_ext_26 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_27;
          break;
        }
        case 0x37:
        {
          return_value_process_btn_28=process_btn(wiimote, &buf[(signed long int)2], &ma);
          if(!(return_value_process_btn_28 == 0))
            tmp_if_expr_30 = (_Bool)1;

          else
          {
            return_value_process_acc_29=process_acc(wiimote, &buf[(signed long int)4], &ma);
            tmp_if_expr_30 = return_value_process_acc_29 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_30)
            tmp_if_expr_32 = (_Bool)1;

          else
          {
            return_value_process_ir10_31=process_ir10(wiimote, &buf[(signed long int)7], &ma);
            tmp_if_expr_32 = return_value_process_ir10_31 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_32)
            tmp_if_expr_34 = (_Bool)1;

          else
          {
            return_value_process_ext_33=process_ext(wiimote, &buf[(signed long int)17], (unsigned char)6, &ma);
            tmp_if_expr_34 = return_value_process_ext_33 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_34;
          break;
        }
        case 0x3D:
        {
          return_value_process_ext_35=process_ext(wiimote, &buf[(signed long int)2], (unsigned char)21, &ma);
          err = (char)return_value_process_ext_35;
          break;
        }
        case 0x3E:

        case 0x3F:
        {
          cwiid_err(wiimote, "Unsupported report type received (interleaved data)");
          err = (char)1;
          break;
        }
        case 0x21:
        {
          return_value_process_read_36=process_read(wiimote, &buf[(signed long int)4]);
          if(!(return_value_process_read_36 == 0))
            tmp_if_expr_38 = (_Bool)1;

          else
          {
            return_value_process_btn_37=process_btn(wiimote, &buf[(signed long int)2], &ma);
            tmp_if_expr_38 = return_value_process_btn_37 != 0 ? (_Bool)1 : (_Bool)0;
          }
          err = (char)tmp_if_expr_38;
          break;
        }
        case 0x22:
        {
          return_value_process_write_39=process_write(wiimote, &buf[(signed long int)2]);
          err = (char)return_value_process_write_39;
          break;
        }
        default:
        {
          cwiid_err(wiimote, "Unknown message type");
          err = (char)1;
        }
      }
      if(err == 0 && (signed int)ma.count >= 1)
      {
        signed int return_value_update_state_40;
        return_value_update_state_40=update_state(wiimote, &ma);
        if(!(return_value_update_state_40 == 0))
          cwiid_err(wiimote, "State update error");

        if(!((0x01 & wiimote->flags) == 0))
          write_mesg_array(wiimote, &ma);

      }

    }
  }
  return (void *)0;
}

// status_thread
// file cwiid_internal.h line 193
void * status_thread(struct wiimote *wiimote)
{
  struct mesg_array ma;
  struct cwiid_status_mesg *status_mesg;
  unsigned char buf[2l];
  ma.count = (unsigned char)1;
  status_mesg = &ma.array[(signed long int)0].status_mesg;
  signed int return_value_cwiid_write_5;
  signed int return_value_cwiid_write_4;
  signed int return_value_cwiid_read_3;
  while((_Bool)1)
  {
    signed int return_value_full_read_1;
    return_value_full_read_1=full_read(wiimote->status_pipe[(signed long int)0], (void *)status_mesg, sizeof(struct cwiid_status_mesg) /*12ul*/ );
    if(!(return_value_full_read_1 == 0))
    {
      cwiid_err(wiimote, "Pipe read error (status)");
      break;
    }

    if(!((signed int)status_mesg->type == CWIID_MESG_STATUS))
      cwiid_err(wiimote, "Bad message on status pipe");

    else
    {
      if((signed int)status_mesg->ext_type == CWIID_EXT_UNKNOWN)
      {
        signed int return_value_cwiid_read_2;
        return_value_cwiid_read_2=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xA400FE, (unsigned short int)1, (void *)&buf[(signed long int)0]);
        if(!(return_value_cwiid_read_2 == 0))
        {
          cwiid_err(wiimote, "Read error (extension error)");
          status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
        }

        switch((signed int)buf[(signed long int)0])
        {
          case 0x2E:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
            break;
          }
          case 0x00:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NUNCHUK;
            break;
          }
          case 0x01:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_CLASSIC;
            break;
          }
          case 0x2A:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_BALANCE;
            break;
          }
          case 0x04:
          {
            status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_MOTIONPLUS;
            break;
          }
          case 0xFF:
          {
            buf[(signed long int)0] = (unsigned char)0x55;
            buf[(signed long int)1] = (unsigned char)0x00;
            return_value_cwiid_write_5=cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400F0, (unsigned short int)1, (const void *)&buf[(signed long int)0]);
            if(!(return_value_cwiid_write_5 == 0))
            {
              cwiid_err(wiimote, "Extension initialization error");
              status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
            }

            else
            {
              return_value_cwiid_write_4=cwiid_write(wiimote, (unsigned char)0x04, (unsigned int)0xA400FB, (unsigned short int)1, (const void *)&buf[(signed long int)1]);
              if(!(return_value_cwiid_write_4 == 0))
              {
                cwiid_err(wiimote, "Extension initialization error");
                status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
              }

              else
              {
                return_value_cwiid_read_3=cwiid_read(wiimote, (unsigned char)0x04, (unsigned int)0xA400FE, (unsigned short int)1, (void *)&buf[(signed long int)0]);
                if(!(return_value_cwiid_read_3 == 0))
                {
                  cwiid_err(wiimote, "Read error (extension error)");
                  status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
                }

                else
                  switch((signed int)buf[(signed long int)0])
                  {
                    case 0x2E:

                    case 0xFF:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NONE;
                      break;
                    }
                    case 0x00:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_NUNCHUK;
                      break;
                    }
                    case 0x01:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_CLASSIC;
                      break;
                    }
                    case 0x2A:
                    {
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_BALANCE;
                      break;
                    }
                    default:
                      status_mesg->ext_type = (enum cwiid_ext_type)CWIID_EXT_UNKNOWN;
                  }
              }
            }
          }
        }
      }

      signed int return_value_update_state_6;
      return_value_update_state_6=update_state(wiimote, &ma);
      if(!(return_value_update_state_6 == 0))
        cwiid_err(wiimote, "State update error");

      signed int return_value_update_rpt_mode_7;
      return_value_update_rpt_mode_7=update_rpt_mode(wiimote, (signed char)-1);
      if(!(return_value_update_rpt_mode_7 == 0))
        cwiid_err(wiimote, "Error reseting report mode");

      if(!((0x01 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        if(!((0x01 & wiimote->flags) == 0))
        {
          signed int return_value_write_mesg_array_8;
          return_value_write_mesg_array_8=write_mesg_array(wiimote, &ma);
        }

      }

    }
  }
  return (void *)0;
}

// update_rpt_mode
// file cwiid_internal.h line 222
signed int update_rpt_mode(struct wiimote *wiimote, signed char rpt_mode)
{
  unsigned char buf[2l];
  unsigned char rpt_type;
  struct write_seq *ir_enable_seq;
  signed int seq_len;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&wiimote->rpt_mutex);
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  if(!(return_value_pthread_mutex_lock_1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (rpt mutex)");
    return -1;
  }

  else
  {
    if((signed int)rpt_mode == -1)
      rpt_mode = (signed char)wiimote->state.rpt_mode;

    if(!((240 & (signed int)rpt_mode) == 0))
    {
      if((signed int)wiimote->state.ext_type == CWIID_EXT_NUNCHUK)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)wiimote->state.ext_type == CWIID_EXT_CLASSIC ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)wiimote->state.ext_type == CWIID_EXT_MOTIONPLUS ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      if(!((0x04 & (signed int)rpt_mode) == 0) && !((0x08 & (signed int)rpt_mode) == 0))
      {
        rpt_type = (unsigned char)0x37;
        ir_enable_seq = ir_enable10_seq;
        seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
      }

      else
        if(!((0x08 & (signed int)rpt_mode) == 0))
        {
          rpt_type = (unsigned char)0x36;
          ir_enable_seq = ir_enable10_seq;
          seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
        }

        else
          if(!((0x04 & (signed int)rpt_mode) == 0))
            rpt_type = (unsigned char)0x35;

          else
            if(!((0x02 & (signed int)rpt_mode) == 0))
              rpt_type = (unsigned char)0x32;

            else
              rpt_type = (unsigned char)0x3D;
    }

    else
    {
      if(!((240 & (signed int)rpt_mode) == 0))
        tmp_if_expr_2 = (signed int)wiimote->state.ext_type == CWIID_EXT_BALANCE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        rpt_type = (unsigned char)0x32;

      else
        if(!((0x08 & (signed int)rpt_mode) == 0))
        {
          rpt_type = (unsigned char)0x33;
          ir_enable_seq = ir_enable12_seq;
          seq_len = (signed int)(sizeof(struct write_seq [6l]) /*144ul*/  / sizeof(struct write_seq) /*24ul*/ );
        }

        else
          if(!((0x04 & (signed int)rpt_mode) == 0))
            rpt_type = (unsigned char)0x31;

          else
            rpt_type = (unsigned char)0x30;
    }
    if(!((0x08 & (signed int)rpt_mode) == 0))
    {
      signed int return_value_exec_write_seq_6;
      return_value_exec_write_seq_6=exec_write_seq(wiimote, (unsigned int)seq_len, ir_enable_seq);
      if(!(return_value_exec_write_seq_6 == 0))
      {
        cwiid_err(wiimote, "IR enable error");
        return -1;
      }

    }

    else
      if(!((0x08 & (signed int)wiimote->state.rpt_mode) == 0))
      {
        if((0x08 & (signed int)rpt_mode) == 0)
        {
          signed int return_value_exec_write_seq_7;
          return_value_exec_write_seq_7=exec_write_seq(wiimote, (unsigned int)(sizeof(struct write_seq [2l]) /*48ul*/  / sizeof(struct write_seq) /*24ul*/ ), ir_disable_seq);
          if(!(return_value_exec_write_seq_7 == 0))
          {
            cwiid_err(wiimote, "IR disable error");
            return -1;
          }

        }

      }

    buf[(signed long int)0] = (unsigned char)((wiimote->flags & 0x02) != 0 ? 0x04 : 0);
    buf[(signed long int)1] = rpt_type;
    signed int return_value_cwiid_send_rpt_8;
    return_value_cwiid_send_rpt_8=cwiid_send_rpt(wiimote, (unsigned char)0, (unsigned char)0x12, (unsigned long int)2, (const void *)buf);
    if(!(return_value_cwiid_send_rpt_8 == 0))
    {
      cwiid_err(wiimote, "Send report error (report mode)");
      return -1;
    }

    else
    {
      if(!((~((signed int)rpt_mode) & 0x02 & (signed int)wiimote->state.rpt_mode) == 0))
        wiimote->state.buttons = (unsigned short int)0;

      if(!((~((signed int)rpt_mode) & 0x04 & (signed int)wiimote->state.rpt_mode) == 0))
        memset((void *)wiimote->state.acc, 0, sizeof(unsigned char [3l]) /*3ul*/ );

      if(!((~((signed int)rpt_mode) & 0x08 & (signed int)wiimote->state.rpt_mode) == 0))
        memset((void *)wiimote->state.ir_src, 0, sizeof(struct cwiid_ir_src [4l]) /*32ul*/ );

      if((signed int)wiimote->state.ext_type == CWIID_EXT_NUNCHUK)
        tmp_if_expr_11 = (0x10 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
        memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

      else
      {
        if((signed int)wiimote->state.ext_type == CWIID_EXT_CLASSIC)
          tmp_if_expr_10 = (0x20 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
          memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

        else
        {
          if((signed int)wiimote->state.ext_type == CWIID_EXT_BALANCE)
            tmp_if_expr_9 = (0x40 & ~((signed int)rpt_mode) & (signed int)wiimote->state.rpt_mode) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
            memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

          else
            if((signed int)wiimote->state.ext_type == CWIID_EXT_MOTIONPLUS)
            {
              if(!((~((signed int)rpt_mode) & 0x80 & (signed int)wiimote->state.rpt_mode) == 0))
                memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );

            }

        }
      }
      wiimote->state.rpt_mode = (unsigned char)rpt_mode;
      signed int return_value_pthread_mutex_unlock_12;
      return_value_pthread_mutex_unlock_12=pthread_mutex_unlock(&wiimote->rpt_mutex);
      if(!(return_value_pthread_mutex_unlock_12 == 0))
      {
        cwiid_err(wiimote, "Mutex unlock error (rpt mutex) - deadlock warning");
        return -1;
      }

      else
        return 0;
    }
  }
}

// update_state
// file state.c line 26
signed int update_state(struct wiimote *wiimote, struct mesg_array *ma)
{
  signed int i;
  union cwiid_mesg *mesg;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&wiimote->state_mutex);
  if(!(return_value_pthread_mutex_lock_1 == 0))
  {
    cwiid_err(wiimote, "Mutex lock error (state mutex)");
    return -1;
  }

  else
  {
    i = 0;
    while(!(i >= (signed int)ma->count))
    {
      mesg = &ma->array[(signed long int)i];
      switch((signed int)mesg->type)
      {
        case CWIID_MESG_STATUS:
        {
          wiimote->state.battery = mesg->status_mesg.battery;
          if(!(wiimote->state.ext_type == mesg->status_mesg.ext_type))
          {
            memset((void *)&wiimote->state.ext, 0, sizeof(union ext_state) /*8ul*/ );
            wiimote->state.ext_type = mesg->status_mesg.ext_type;
          }

          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_BTN:
        {
          wiimote->state.buttons = mesg->btn_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_ACC:
        {
          memcpy((void *)wiimote->state.acc, (const void *)mesg->acc_mesg.acc, sizeof(unsigned char [3l]) /*3ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_IR:
        {
          memcpy((void *)wiimote->state.ir_src, (const void *)mesg->ir_mesg.src, sizeof(struct cwiid_ir_src [4l]) /*32ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_NUNCHUK:
        {
          memcpy((void *)wiimote->state.ext.nunchuk.stick, (const void *)mesg->nunchuk_mesg.stick, sizeof(unsigned char [2l]) /*2ul*/ );
          memcpy((void *)wiimote->state.ext.nunchuk.acc, (const void *)mesg->nunchuk_mesg.acc, sizeof(unsigned char [3l]) /*3ul*/ );
          wiimote->state.ext.nunchuk.buttons = mesg->nunchuk_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_CLASSIC:
        {
          memcpy((void *)wiimote->state.ext.classic.l_stick, (const void *)mesg->classic_mesg.l_stick, sizeof(unsigned char [2l]) /*2ul*/ );
          memcpy((void *)wiimote->state.ext.classic.r_stick, (const void *)mesg->classic_mesg.r_stick, sizeof(unsigned char [2l]) /*2ul*/ );
          wiimote->state.ext.classic.l = mesg->classic_mesg.l;
          wiimote->state.ext.classic.r = mesg->classic_mesg.r;
          wiimote->state.ext.classic.buttons = mesg->classic_mesg.buttons;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_BALANCE:
        {
          wiimote->state.ext.balance.right_top = mesg->balance_mesg.right_top;
          wiimote->state.ext.balance.right_bottom = mesg->balance_mesg.right_bottom;
          wiimote->state.ext.balance.left_top = mesg->balance_mesg.left_top;
          wiimote->state.ext.balance.left_bottom = mesg->balance_mesg.left_bottom;
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_MOTIONPLUS:
        {
          memcpy((void *)wiimote->state.ext.motionplus.angle_rate, (const void *)mesg->motionplus_mesg.angle_rate, sizeof(unsigned short int [3l]) /*6ul*/ );
          goto __CPROVER_DUMP_L13;
        }
        case CWIID_MESG_ERROR:
          wiimote->state.error = mesg->error_mesg.error;
        case CWIID_MESG_UNKNOWN:

        default:
        {

        __CPROVER_DUMP_L13:
          ;
          i = i + 1;
        }
      }
    }
    signed int return_value_pthread_mutex_unlock_2;
    return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&wiimote->state_mutex);
    if(!(return_value_pthread_mutex_unlock_2 == 0))
    {
      cwiid_err(wiimote, "Mutex unlock error (state mutex) - deadlock warning");
      return -1;
    }

    else
      return 0;
  }
}

// verify_handshake
// file cwiid_internal.h line 198
signed int verify_handshake(struct wiimote *wiimote)
{
  unsigned char handshake;
  signed long int return_value_read_1;
  return_value_read_1=read(wiimote->ctl_socket, (void *)&handshake, (unsigned long int)1);
  if(!(return_value_read_1 == 1l))
  {
    cwiid_err(wiimote, "Socket read error (handshake)");
    return -1;
  }

  else
    if(!((0xF0 & (signed int)handshake) == 0x00))
    {
      cwiid_err(wiimote, "Handshake expected, non-handshake received");
      return -1;
    }

    else
      if(!((0x0F & (signed int)handshake) == 0x00))
      {
        cwiid_err(wiimote, "Non-successful handshake");
        return -1;
      }

  return 0;
}

// write_mesg_array
// file cwiid_internal.h line 202
signed int write_mesg_array(struct wiimote *wiimote, struct mesg_array *ma)
{
  signed long int len = (void *)&ma->array[(signed long int)ma->count] - (void *)ma;
  signed int ret = 0;
  signed long int return_value_write_5;
  return_value_write_5=write(wiimote->mesg_pipe[(signed long int)1], (const void *)ma, (unsigned long int)len);
  if(!(return_value_write_5 == len))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 11)
    {
      cwiid_err(wiimote, "Mesg pipe overflow");
      signed int return_value_fcntl_3;
      return_value_fcntl_3=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 0);
      if(!(return_value_fcntl_3 == 0))
      {
        cwiid_err(wiimote, "File control error (mesg pipe)");
        ret = -1;
      }

      else
      {
        signed long int return_value_write_1;
        return_value_write_1=write(wiimote->mesg_pipe[(signed long int)1], (const void *)ma, (unsigned long int)len);
        if(!(return_value_write_1 == len))
        {
          cwiid_err(wiimote, "Pipe write error (mesg pipe)");
          ret = -1;
        }

        signed int return_value_fcntl_2;
        return_value_fcntl_2=fcntl(wiimote->mesg_pipe[(signed long int)1], 4, 04000);
        if(!(return_value_fcntl_2 == 0))
          cwiid_err(wiimote, "File control error (mesg pipe");

      }
    }

    else
    {
      cwiid_err(wiimote, "Pipe write error (mesg pipe)");
      ret = -1;
    }
  }

  return ret;
}

