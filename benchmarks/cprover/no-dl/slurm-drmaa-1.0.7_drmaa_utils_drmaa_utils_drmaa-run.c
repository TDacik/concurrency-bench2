// #anon_enum_FSD_CONF_INTEGER=0_FSD_CONF_STRING=1_FSD_CONF_DICT=2
// file ../drmaa_utils/conf.h line 29
enum anonymous_4 { FSD_CONF_INTEGER=0, FSD_CONF_STRING=1, FSD_CONF_DICT=2 };

// #anon_enum_FSD_EXC_ENTER=0_FSD_EXC_TRY_BLOCK=1_FSD_EXC_EXCEPTION_HANDLE=2_FSD_EXC_ELSE_BLOCK=3_FSD_EXC_FINALLY_BLOCK=4_FSD_EXC_LEAVE=5
// file ../drmaa_utils/exception.h line 140
enum anonymous_6 { FSD_EXC_ENTER=0, FSD_EXC_TRY_BLOCK=1, FSD_EXC_EXCEPTION_HANDLE=2, FSD_EXC_ELSE_BLOCK=3, FSD_EXC_FINALLY_BLOCK=4, FSD_EXC_LEAVE=5 };

// #anon_enum_FSD_LOG_ALL=0_FSD_LOG_TRACE=1_FSD_LOG_DEBUG=2_FSD_LOG_INFO=3_FSD_LOG_WARNING=4_FSD_LOG_ERROR=5_FSD_LOG_FATAL=6_FSD_LOG_NONE=7
// file ../drmaa_utils/logging.h line 84
enum anonymous_7 { FSD_LOG_ALL=0, FSD_LOG_TRACE=1, FSD_LOG_DEBUG=2, FSD_LOG_INFO=3, FSD_LOG_WARNING=4, FSD_LOG_ERROR=5, FSD_LOG_FATAL=6, FSD_LOG_NONE=7 };

// #anon_enum_yyok=0_yyaccept=1_yyabort=2_yyerr=3
// file datetime_tab.c line 456
enum anonymous { yyok=0, yyaccept=1, yyabort=2, yyerr=3 };

// tag-#anon#ST[*{S32(*{cS8}_cS8_|*{S8}_S8_|U64)->S32}_S32(*{cS8}_cS8_|*{S8}_S8_|U64)->S32_'init'||*{S32(*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64)->S32_'exit'||*{S32(*{*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_}_*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#__|*{S8}_S8_|U64)->S32}_S32(*{*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_}_*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#__|*{S8}_S8_|U64)->S32_'allocate_job_template'||*{S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{S8}_S8_|U64)->S32}_S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{S8}_S8_|U64)->S32_'delete_job_template'||*{S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{cS8}_cS8_|*{S8}_S8_|U64)->S32}_S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{cS8}_cS8_|*{S8}_S8_|U64)->S32_'set_attribute'||*{S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{S8}_S8_|U64|*{S8}_S8_|U64)->S32}_S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{S8}_S8_|U64|*{S8}_S8_|U64)->S32_'get_attribute'||*{S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{*{cS8}_cS8_}_*{cS8}_cS8__|*{S8}_S8_|U64)->S32}_S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{*{cS8}_cS8_}_*{cS8}_cS8__|*{S8}_S8_|U64)->S32_'set_vector_attribute'||*{S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#_}_*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#__|*{S8}_S8_|U64)->S32}_S32(*{SYM#tag-drmaa_job_template_s#}_SYM#tag-drmaa_job_template_s#_|*{cS8}_cS8_|*{*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#_}_*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#__|*{S8}_S8_|U64)->S32_'get_vector_attribute'||*{S32(*{S8}_S8_|U64|*{cSYM#tag-drmaa_job_template_s#}_cSYM#tag-drmaa_job_template_s#_|*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64|*{cSYM#tag-drmaa_job_template_s#}_cSYM#tag-drmaa_job_template_s#_|*{S8}_S8_|U64)->S32_'run_job'||*{S32(*{cS8}_cS8_|S32|*{S8}_S8_|U64)->S32}_S32(*{cS8}_cS8_|S32|*{S8}_S8_|U64)->S32_'control'||*{S32(*{cS8}_cS8_|*{S32}_S32_|*{S8}_S8_|U64)->S32}_S32(*{cS8}_cS8_|*{S32}_S32_|*{S8}_S8_|U64)->S32_'job_ps'||*{S32(*{cS8}_cS8_|*{S8}_S8_|U64|*{S32}_S32_|S64|*{*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#_}_*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#__|*{S8}_S8_|U64)->S32}_S32(*{cS8}_cS8_|*{S8}_S8_|U64|*{S32}_S32_|S64|*{*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#_}_*{SYM#tag-drmaa_attr_values_s#}_SYM#tag-drmaa_attr_values_s#__|*{S8}_S8_|U64)->S32_'wait'||*{S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32}_S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32_'wifexited'||*{S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32}_S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32_'wexitstatus'||*{S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32}_S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32_'wifsignaled'||*{S32(*{S8}_S8_|U64|S32|*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64|S32|*{S8}_S8_|U64)->S32_'wtermsig'||*{S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32}_S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32_'wcoredump'||*{S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32}_S32(*{S32}_S32_|S32|*{S8}_S8_|U64)->S32_'wifaborted'||*{S8(S32)->S8}_S8(S32)->S8_'strerror'||*{S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32_'get_contact'||*{S32(*{U32}_U32_|*{U32}_U32_|*{S8}_S8_|U64)->S32}_S32(*{U32}_U32_|*{U32}_U32_|*{S8}_S8_|U64)->S32_'version'||*{S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32_'get_DRM_system'||*{S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32}_S32(*{S8}_S8_|U64|*{S8}_S8_|U64)->S32_'get_DRMAA_implementation'||*{V}_V_'handle'|]
// file drmaa_run.c line 61
struct anonymous_11;

// tag-#anon#ST[*{S8}_S8_'native_specification'||*{S8}_S8_'walltime'||*{S8}_S8_'rusage_file'||B'interactive'||B'print_rusage'||U48'_pad0'||*{S8}_S8_'command'||*{*{S8}_S8_}_*{S8}_S8__'command_args'||S32'command_argc'||U32'_pad1'|]
// file drmaa_run.c line 89
struct anonymous_12;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_8;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_3;

// tag-#anon#UN[*{SYM#tag-yySemanticOption#}_SYM#tag-yySemanticOption#_'yyfirstVal'||SYM#tag-YYSTYPE#'yysval'|]_link1
// file datetime_tab.c line 688
union anonymous_0;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_9;

// tag-#anon#UN[S32'integer'||*{S8}_S8_'string'||*{SYM#tag-fsd_conf_dict_s#}_SYM#tag-fsd_conf_dict_s#_'dict'|]
// file ../drmaa_utils/conf.h line 37
union anonymous_5;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_1;

// tag-YYLTYPE
// file ../drmaa_utils/conf_impl.h line 32
struct YYLTYPE;

// tag-YYLTYPE_link1
// file datetime_tab.h line 66
struct YYLTYPE_0;

// tag-YYSTYPE
// file ../drmaa_utils/conf_impl.h line 31
union YYSTYPE_0;

// tag-YYSTYPE_link1
// file ../drmaa_utils/datetime_impl.h line 38
union YYSTYPE_1;

// tag-YYSTYPE_link2
// file ../drmaa_utils/datetime_impl.h line 38
union YYSTYPE;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-drmaa_attr_values_s
// file ../drmaa_utils/drmaa.h line 66
struct drmaa_attr_values_s;

// tag-drmaa_attrib
// file drmaa_attrib.gperf line 48
struct drmaa_attrib;

// tag-drmaa_job_template_s
// file ../drmaa_utils/drmaa.h line 64
struct drmaa_job_template_s;

// tag-fsd_attribute_s
// file ../drmaa_utils/common.h line 42
struct fsd_attribute_s;

// tag-fsd_conf_dict_s
// file ../drmaa_utils/common.h line 36
struct fsd_conf_dict_s;

// tag-fsd_conf_lexer_s
// file ../drmaa_utils/conf_impl.h line 30
struct fsd_conf_lexer_s;

// tag-fsd_conf_option_s
// file ../drmaa_utils/common.h line 35
struct fsd_conf_option_s;

// tag-fsd_conf_pair_s
// file ../drmaa_utils/conf_impl.h line 75
struct fsd_conf_pair_s;

// tag-fsd_conf_parser_s
// file ../drmaa_utils/conf_impl.h line 29
struct fsd_conf_parser_s;

// tag-fsd_datetime_s
// file ../drmaa_utils/datetime.h line 52
struct fsd_datetime_s;

// tag-fsd_drmaa_session_s
// file ../drmaa_utils/common.h line 47
struct fsd_drmaa_session_s;

// tag-fsd_dt_lexer_s
// file ../drmaa_utils/datetime_impl.h line 37
struct fsd_dt_lexer_s;

// tag-fsd_dt_parser_s
// file ../drmaa_utils/datetime_impl.h line 36
struct fsd_dt_parser_s;

// tag-fsd_environ_item_s
// file ../drmaa_utils/environ.h line 30
struct fsd_environ_item_s;

// tag-fsd_environ_s
// file ../drmaa_utils/environ.h line 29
struct fsd_environ_s;

// tag-fsd_exc_s
// file ../drmaa_utils/exception.h line 39
struct fsd_exc_s;

// tag-fsd_exc_stack_s
// file exception.c line 61
struct fsd_exc_stack_s;

// tag-fsd_exc_try_block_s
// file ../drmaa_utils/exception.h line 157
struct fsd_exc_try_block_s;

// tag-fsd_expand_drmaa_ph_s
// file ../drmaa_utils/common.h line 50
struct fsd_expand_drmaa_ph_s;

// tag-fsd_iter_s
// file ../drmaa_utils/common.h line 39
struct fsd_iter_s;

// tag-fsd_job_s
// file ../drmaa_utils/common.h line 49
struct fsd_job_s;

// tag-fsd_job_set_s
// file ../drmaa_utils/common.h line 48
struct fsd_job_set_s;

// tag-fsd_template_s
// file ../drmaa_utils/common.h line 43
struct fsd_template_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stringpool_t
// file drmaa_attrib.gperf line 119
struct stringpool_t;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-yyGLRStack_link1
// file datetime_tab.c line 674
struct yyGLRStack;

// tag-yyGLRStackItem_link1
// file datetime_tab.c line 673
union yyGLRStackItem;

// tag-yyGLRState_link1
// file datetime_tab.c line 670
struct yyGLRState;

// tag-yyGLRStateSet_link1
// file datetime_tab.c line 671
struct yyGLRStateSet;

// tag-yySemanticOption_link1
// file datetime_tab.c line 672
struct yySemanticOption;

// tag-yyalloc
// file conf_tab.c line 327
union yyalloc;

#ifndef NULL
#define NULL ((void*)0)
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _fsd_log
// file ../drmaa_utils/logging.h line 66
void _fsd_log(signed int level, const char *file, const char *function, signed int kind, char *message);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// drmaa_attrib_lookup
// file drmaa_attrib.gperf line 175
inline struct drmaa_attrib * drmaa_attrib_lookup(const char *str, unsigned int len);
// drmaa_control_to_str
// file drmaa_util.c line 173
const char * drmaa_control_to_str(signed int action);
// drmaa_job_ps_to_str
// file drmaa_util.c line 194
const char * drmaa_job_ps_to_str(signed int ps);
// drmaa_template_by_code
// file drmaa_attrib.gperf line 92
static const struct fsd_attribute_s * drmaa_template_by_code(const struct fsd_template_s *self, signed int code);
// drmaa_template_by_name
// file drmaa_attrib.gperf line 77
static const struct fsd_attribute_s * drmaa_template_by_name(const struct fsd_template_s *self, const char *name);
// drmaa_template_new
// file drmaa_attrib.gperf line 105
struct fsd_template_s * drmaa_template_new(void);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file conf_tab.c line 314
void free(void *);
// fsd_asprintf
// file ../drmaa_utils/util.h line 79
char * fsd_asprintf(const char *fmt, ...);
// fsd_assertion_failed
// file exception.c line 569
void fsd_assertion_failed(const char *file, signed int lineno, const char *function, const char *precondition);
// fsd_astrerror
// file ../drmaa_utils/util.h line 108
char * fsd_astrerror(signed int errnum, _Bool *malloced);
// fsd_atoi
// file fsd_util.c line 201
signed int fsd_atoi(const char *string);
// fsd_calloc_
// file ../drmaa_utils/xmalloc.h line 66
void * fsd_calloc_(void **p, unsigned long int n, unsigned long int size);
// fsd_calloc_noraise_
// file xmalloc.c line 148
signed int fsd_calloc_noraise_(void **p, unsigned long int n, unsigned long int size);
// fsd_color
// file logging.c line 77
void fsd_color(char *output, unsigned long int len, signed int n);
// fsd_cond_broadcast
// file ../drmaa_utils/thread.h line 96
void fsd_cond_broadcast(union anonymous_2 *cond);
// fsd_cond_destroy
// file ../drmaa_utils/thread.h line 94
void fsd_cond_destroy(union anonymous_2 *cond);
// fsd_cond_init
// file ../drmaa_utils/thread.h line 93
void fsd_cond_init(union anonymous_2 *cond);
// fsd_cond_signal
// file thread.c line 182
void fsd_cond_signal(union anonymous_2 *cond);
// fsd_cond_timedwait
// file thread.c line 209
_Bool fsd_cond_timedwait(union anonymous_2 *cond, union anonymous_1 *mutex, struct timespec *abstime);
// fsd_cond_wait
// file thread.c line 200
void fsd_cond_wait(union anonymous_2 *cond, union anonymous_1 *mutex);
// fsd_conf_dict_create
// file conf.c line 402
struct fsd_conf_dict_s * fsd_conf_dict_create(void);
// fsd_conf_dict_create_noraise
// file conf.c line 556
struct fsd_conf_dict_s * fsd_conf_dict_create_noraise(void);
// fsd_conf_dict_destroy
// file conf.c line 414
void fsd_conf_dict_destroy(struct fsd_conf_dict_s *dict);
// fsd_conf_dict_dump
// file conf.c line 524
void fsd_conf_dict_dump(struct fsd_conf_dict_s *dict);
// fsd_conf_dict_get
// file conf.c line 429
struct fsd_conf_option_s * fsd_conf_dict_get(struct fsd_conf_dict_s *dict, const char *key);
// fsd_conf_dict_merge
// file conf.c line 486
struct fsd_conf_dict_s * fsd_conf_dict_merge(struct fsd_conf_dict_s *lhs, struct fsd_conf_dict_s *rhs);
// fsd_conf_dict_set
// file conf.c line 445
void fsd_conf_dict_set(struct fsd_conf_dict_s *dict, const char *key, struct fsd_conf_option_s *value);
// fsd_conf_dict_set_noraise
// file conf.c line 566
signed int fsd_conf_dict_set_noraise(struct fsd_conf_dict_s *dict, const char *key, struct fsd_conf_option_s *value);
// fsd_conf_error
// file conf.c line 275
void fsd_conf_error(struct YYLTYPE *locp, struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer, const char *fmt, ...);
// fsd_conf_lex
// file conf.c line 164
signed int fsd_conf_lex(union YYSTYPE_0 *lvalp, struct YYLTYPE *locp, struct fsd_conf_lexer_s *lexer);
// fsd_conf_option_create
// file conf.c line 306
struct fsd_conf_option_s * fsd_conf_option_create(enum anonymous_4 type, void *value);
// fsd_conf_option_create_noraise
// file conf.c line 546
struct fsd_conf_option_s * fsd_conf_option_create_noraise(enum anonymous_4 type, void *value);
// fsd_conf_option_destroy
// file conf.c line 332
void fsd_conf_option_destroy(struct fsd_conf_option_s *option);
// fsd_conf_option_dump
// file conf.c line 371
void fsd_conf_option_dump(struct fsd_conf_option_s *option);
// fsd_conf_option_merge
// file conf.c line 354
struct fsd_conf_option_s * fsd_conf_option_merge(struct fsd_conf_option_s *lhs, struct fsd_conf_option_s *rhs);
// fsd_conf_parse
// file ../drmaa_utils/conf_impl.h line 37
signed int fsd_conf_parse(struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer);
// fsd_conf_read
// file conf.c line 44
struct fsd_conf_dict_s * fsd_conf_read(struct fsd_conf_dict_s * volatile configuration, const char *filename, _Bool must_exist, const char *content, unsigned long int content_len);
// fsd_copy_vector
// file ../drmaa_utils/util.h line 41
char ** fsd_copy_vector(const char * const *vector);
// fsd_datetime_after
// file datetime.c line 201
signed long int fsd_datetime_after(struct fsd_datetime_s *dt, signed long int t);
// fsd_datetime_dump
// file datetime.c line 39
void fsd_datetime_dump(const struct fsd_datetime_s *dt, char *s, unsigned long int len);
// fsd_datetime_fill
// file datetime.c line 99
void fsd_datetime_fill(struct fsd_datetime_s *dt, signed long int filler);
// fsd_datetime_mktime
// file datetime.c line 158
signed long int fsd_datetime_mktime(const struct fsd_datetime_s *dt);
// fsd_datetime_parse
// file datetime.c line 250
signed long int fsd_datetime_parse(const char *string);
// fsd_drmaa_code
// file drmaa_util.c line 227
signed int fsd_drmaa_code(signed int fsd_errno);
// fsd_drmaa_strerror
// file drmaa_util.c line 368
const char * fsd_drmaa_strerror(signed int drmaa_errno);
// fsd_dt_error
// file datetime.c line 299
void fsd_dt_error(struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer, const char *fmt, ...);
// fsd_dt_lex
// file datetime.c line 317
signed int fsd_dt_lex(union YYSTYPE_1 *lvalp, struct fsd_dt_lexer_s *lex);
// fsd_dt_parse
// file ../drmaa_utils/datetime_impl.h line 57
signed int fsd_dt_parse(struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// fsd_environ_apply
// file environ.c line 170
static struct fsd_environ_s * fsd_environ_apply(struct fsd_environ_s *self);
// fsd_environ_destroy
// file environ.c line 37
static void fsd_environ_destroy(struct fsd_environ_s *self);
// fsd_environ_get
// file environ.c line 58
static const char * fsd_environ_get(struct fsd_environ_s *self, const char *name);
// fsd_environ_list
// file environ.c line 134
static char ** fsd_environ_list(struct fsd_environ_s *self);
// fsd_environ_new
// file environ.c line 215
struct fsd_environ_s * fsd_environ_new(const char * const *envp);
// fsd_environ_restore
// file environ.c line 199
static void fsd_environ_restore(struct fsd_environ_s *self, struct fsd_environ_s *saved_state);
// fsd_environ_set
// file environ.c line 71
static void fsd_environ_set(struct fsd_environ_s *self, char *name, char *value);
// fsd_environ_update
// file environ.c line 112
static void fsd_environ_update(struct fsd_environ_s *self, const char * const *envp);
// fsd_errno_from_drmaa_code
// file drmaa_util.c line 304
signed int fsd_errno_from_drmaa_code(signed int drmaa_errno);
// fsd_exc_clear
// file exception.c line 292
void fsd_exc_clear(void);
// fsd_exc_code
// file exception.c line 342
signed int fsd_exc_code(const struct fsd_exc_s *self);
// fsd_exc_control
// file ../drmaa_utils/exception.h line 170
void fsd_exc_control(struct fsd_exc_try_block_s *block, signed int *rc);
// fsd_exc_destroy
// file exception.c line 354
void fsd_exc_destroy(struct fsd_exc_s *self);
// fsd_exc_get
// file ../drmaa_utils/exception.h line 85
const struct fsd_exc_s * fsd_exc_get(void);
// fsd_exc_get_stack
// file exception.c line 96
struct fsd_exc_stack_s * fsd_exc_get_stack(_Bool create);
// fsd_exc_init
// file exception.c line 76
void fsd_exc_init(void);
// fsd_exc_message
// file exception.c line 348
const char * fsd_exc_message(const struct fsd_exc_s *self);
// fsd_exc_new
// file ../drmaa_utils/exception.h line 42
struct fsd_exc_s * fsd_exc_new(signed int code, char *message, _Bool own_message);
// fsd_exc_raise
// file ../drmaa_utils/exception.h line 57
void fsd_exc_raise(struct fsd_exc_s *exc);
// fsd_exc_raise_code
// file ../drmaa_utils/exception.h line 61
void fsd_exc_raise_code(signed int error_code);
// fsd_exc_raise_fmt
// file ../drmaa_utils/exception.h line 69
void fsd_exc_raise_fmt(signed int error_code, const char *fmt, ...);
// fsd_exc_raise_fmtv
// file exception.c line 408
void fsd_exc_raise_fmtv(signed int error_code, const char *fmt, void **args);
// fsd_exc_raise_msg
// file exception.c line 392
void fsd_exc_raise_msg(signed int error_code, const char *message);
// fsd_exc_raise_sys
// file exception.c line 427
void fsd_exc_raise_sys(signed int errno_code);
// fsd_exc_reraise
// file ../drmaa_utils/exception.h line 81
void fsd_exc_reraise(void);
// fsd_exc_stack_destroy
// file exception.c line 136
static void fsd_exc_stack_destroy(struct fsd_exc_stack_s *stack);
// fsd_exc_try
// file ../drmaa_utils/exception.h line 167
struct fsd_exc_try_block_s * fsd_exc_try(const char *function, signed int lineno);
// fsd_exc_try_except
// file exception.c line 588
void * fsd_exc_try_except(void * (*f)(void *), void *data, signed int *error_code, char **error_message);

//

// fsd_exec_async
// file exec.c line 95
void fsd_exec_async(const char *command, char **args, signed int *stdin_desc, signed int *stdout_desc, signed int *stderr_desc, signed int *child_pid);
// fsd_exec_sync
// file exec.c line 223
signed int fsd_exec_sync(const char *command, char **args, const char *stdinb, char **stdoutb, char **stderrb);
// fsd_exec_wait
// file exec.c line 195
signed int fsd_exec_wait(signed int child_pid);
// fsd_expand_drmaa_ph_destroy
// file drmaa_util.c line 110
static void fsd_expand_drmaa_ph_destroy(struct fsd_expand_drmaa_ph_s *self);
// fsd_expand_drmaa_ph_expand
// file drmaa_util.c line 44
static char * fsd_expand_drmaa_ph_expand(struct fsd_expand_drmaa_ph_s *self, char *s, unsigned int set);
// fsd_expand_drmaa_ph_new
// file drmaa_util.c line 122
struct fsd_expand_drmaa_ph_s * fsd_expand_drmaa_ph_new(char *home_directory, char *working_directory, char *bulk_incr);
// fsd_expand_drmaa_ph_set
// file drmaa_util.c line 92
static void fsd_expand_drmaa_ph_set(struct fsd_expand_drmaa_ph_s *self, signed int placeholder, char *value);
// fsd_expand_printf_ph
// file fsd_util.c line 342
static char * fsd_expand_printf_ph(const char *fmt);
// fsd_explode
// file ../drmaa_utils/util.h line 39
char * fsd_explode(const char * const *vector, char glue, signed int n);
// fsd_free
// file ../drmaa_utils/xmalloc.h line 63
void fsd_free(void *p);
// fsd_free_vector
// file ../drmaa_utils/util.h line 40
void fsd_free_vector(char **vector);
// fsd_get_time
// file fsd_util.c line 447
void fsd_get_time(struct timespec *ts);
// fsd_getcwd
// file fsd_util.c line 546
char * fsd_getcwd(void);
// fsd_iter_append
// file iter.c line 54
static void fsd_iter_append(struct fsd_iter_s *self, char *string);
// fsd_iter_destroy
// file iter.c line 74
static void fsd_iter_destroy(struct fsd_iter_s *self);
// fsd_iter_len
// file iter.c line 48
static signed int fsd_iter_len(struct fsd_iter_s *self);
// fsd_iter_new
// file iter.c line 135
struct fsd_iter_s * fsd_iter_new(char **list, signed int length);
// fsd_iter_new_const
// file iter.c line 141
struct fsd_iter_s * fsd_iter_new_const(const char * const *list, signed int length);
// fsd_iter_new_impl
// file iter.c line 87
static struct fsd_iter_s * fsd_iter_new_impl(char **list, signed int length, _Bool own);
// fsd_iter_next
// file iter.c line 33
static const char * fsd_iter_next(struct fsd_iter_s *self);
// fsd_iter_reset
// file iter.c line 42
static void fsd_iter_reset(struct fsd_iter_s *self);
// fsd_job_control
// file fsd_job.c line 128
static void fsd_job_control(struct fsd_job_s *self, signed int action);
// fsd_job_destroy
// file fsd_job.c line 112
static void fsd_job_destroy(struct fsd_job_s *self);
// fsd_job_get_termination_status
// file fsd_job.c line 140
static void fsd_job_get_termination_status(struct fsd_job_s *self, signed int *status, struct fsd_iter_s **rusage_out);
// fsd_job_new
// file fsd_job.c line 45
struct fsd_job_s * fsd_job_new(char *job_id);
// fsd_job_on_missing
// file fsd_job.c line 198
static void fsd_job_on_missing(struct fsd_job_s *self);
// fsd_job_release
// file fsd_job.c line 97
static void fsd_job_release(struct fsd_job_s *self);
// fsd_job_set_add
// file fsd_job.c line 284
static void fsd_job_set_add(struct fsd_job_set_s *self, struct fsd_job_s *job);
// fsd_job_set_destroy
// file fsd_job.c line 263
static void fsd_job_set_destroy(struct fsd_job_set_s *self);
// fsd_job_set_empty
// file fsd_job.c line 364
static _Bool fsd_job_set_empty(struct fsd_job_set_s *self);
// fsd_job_set_find_terminated
// file fsd_job.c line 371
static struct fsd_job_s * fsd_job_set_find_terminated(struct fsd_job_set_s *self);
// fsd_job_set_get
// file fsd_job.c line 335
static struct fsd_job_s * fsd_job_set_get(struct fsd_job_set_s *self, const char *job_id);
// fsd_job_set_get_all_job_ids
// file fsd_job.c line 406
static char ** fsd_job_set_get_all_job_ids(struct fsd_job_set_s *self);
// fsd_job_set_new
// file fsd_job.c line 222
struct fsd_job_set_s * fsd_job_set_new(void);
// fsd_job_set_remove
// file fsd_job.c line 301
static void fsd_job_set_remove(struct fsd_job_set_s *self, struct fsd_job_s *job);
// fsd_job_set_signal_all
// file fsd_job.c line 439
static void fsd_job_set_signal_all(struct fsd_job_set_s *self);
// fsd_job_update_status
// file fsd_job.c line 134
static void fsd_job_update_status(struct fsd_job_s *self);
// fsd_log_check_verbosity
// file logging.c line 212
static void fsd_log_check_verbosity(void);
// fsd_log_fmt
// file logging.c line 252
void fsd_log_fmt(signed int level, const char *fmt, ...);
// fsd_log_fmtv
// file logging.c line 262
void fsd_log_fmtv(signed int level, const char *fmt, void **args);
// fsd_log_level_char
// file logging.c line 87
char fsd_log_level_char(signed int level);
// fsd_log_stacktrace
// file ../drmaa_utils/logging.h line 74
void fsd_log_stacktrace(signed int skip, signed int limit);
// fsd_malloc_
// file ../drmaa_utils/xmalloc.h line 65
void * fsd_malloc_(void **p, unsigned long int size);
// fsd_malloc_noraise_
// file ../drmaa_utils/xmalloc.h line 81
signed int fsd_malloc_noraise_(void **p, unsigned long int size);
// fsd_mutex_destroy
// file ../drmaa_utils/thread.h line 81
void fsd_mutex_destroy(union anonymous_1 *mutex);
// fsd_mutex_init
// file ../drmaa_utils/thread.h line 80
void fsd_mutex_init(union anonymous_1 *mutex);
// fsd_mutex_lock
// file ../drmaa_utils/thread.h line 82
_Bool fsd_mutex_lock(union anonymous_1 *mutex);
// fsd_mutex_trylock
// file thread.c line 132
_Bool fsd_mutex_trylock(union anonymous_1 *mutex);
// fsd_mutex_unlock
// file ../drmaa_utils/thread.h line 83
_Bool fsd_mutex_unlock(union anonymous_1 *mutex);
// fsd_mutex_unlock_times
// file thread.c line 148
signed int fsd_mutex_unlock_times(union anonymous_1 *mutex);
// fsd_parse_timedelta
// file timedelta.rl line 37
signed int fsd_parse_timedelta(const char *string);
// fsd_pipe
// file exec.c line 49
static void fsd_pipe(signed int *fds);
// fsd_read_file
// file ../drmaa_utils/util.h line 136
void fsd_read_file(const char *filename, _Bool must_exist, char **content, unsigned long int *length);
// fsd_readline
// file fsd_util.c line 580
char * fsd_readline(struct _IO_FILE *f);
// fsd_realloc_
// file ../drmaa_utils/xmalloc.h line 67
void * fsd_realloc_(void **p, unsigned long int size);
// fsd_realloc_noraise_
// file ../drmaa_utils/xmalloc.h line 83
signed int fsd_realloc_noraise_(void **p, unsigned long int size);
// fsd_replace
// file fsd_util.c line 94
char * fsd_replace(char *str, const char *placeholder, const char *value);
// fsd_set_logging_fd
// file logging.c line 70
void fsd_set_logging_fd(signed int fd);
// fsd_set_verbosity_level
// file logging.c line 64
void fsd_set_verbosity_level(enum anonymous_7 level);
// fsd_snprintf
// file fsd_util.c line 266
unsigned long int fsd_snprintf(_Bool *truncated, char *str, unsigned long int size, const char *fmt, ...);
// fsd_str_append
// file fsd_util.c line 252
void fsd_str_append(_Bool *truncated, char **p, char *end, const char *fmt, ...);
// fsd_strdup
// file ../drmaa_utils/util.h line 44
char * fsd_strdup(const char *s);
// fsd_strerror
// file exception.c line 476
const char * fsd_strerror(signed int error_code);
// fsd_strerror_r
// file fsd_util.c line 393
const char * fsd_strerror_r(signed int errnum, char *buffer, unsigned long int buffer_size);
// fsd_strndup
// file ../drmaa_utils/util.h line 45
char * fsd_strndup(const char *s, unsigned long int n);
// fsd_strsignal
// file fsd_util.c line 640
const char * fsd_strsignal(signed int signum);
// fsd_template_destroy
// file template.c line 134
static void fsd_template_destroy(struct fsd_template_s *self);
// fsd_template_get_attr
// file template.c line 40
static const char * fsd_template_get_attr(const struct fsd_template_s *self, const char *name);
// fsd_template_get_v_attr
// file template.c line 87
static const char * const * fsd_template_get_v_attr(const struct fsd_template_s *self, const char *name);
// fsd_template_new
// file ../drmaa_utils/template.h line 37
struct fsd_template_s * fsd_template_new(const struct fsd_attribute_s * (*by_name_method)(const struct fsd_template_s *, const char *), const struct fsd_attribute_s * (*by_code_method)(const struct fsd_template_s *, signed int), unsigned int n_attributes);
// fsd_template_new::by_code_method_object
//
const struct fsd_attribute_s * by_code_method_object(const struct fsd_template_s *, signed int);
// fsd_template_new::by_name_method_object
//
const struct fsd_attribute_s * by_name_method_object(const struct fsd_template_s *, const char *);
// fsd_template_set_attr
// file template.c line 56
static void fsd_template_set_attr(struct fsd_template_s *self, const char *name, const char *value);
// fsd_template_set_v_attr
// file template.c line 103
static void fsd_template_set_v_attr(struct fsd_template_s *self, const char *name, const char **value);
// fsd_thread_create
// file thread.c line 55
void fsd_thread_create(unsigned long int *thread, void * (*func)(void *), void *arg);

//

// fsd_thread_detach
// file thread.c line 73
void fsd_thread_detach(unsigned long int th);
// fsd_thread_id
// file ../drmaa_utils/thread.h line 122
signed int fsd_thread_id(void);
// fsd_thread_join
// file thread.c line 64
void fsd_thread_join(unsigned long int th, void **thread_return);
// fsd_timezone
// file datetime.c line 69
signed long int fsd_timezone(signed long int t);
// fsd_ts_add
// file fsd_util.c line 463
void fsd_ts_add(struct timespec *a, struct timespec *b);
// fsd_ts_cmp
// file fsd_util.c line 477
signed int fsd_ts_cmp(struct timespec *a, struct timespec *b);
// fsd_vasprintf
// file ../drmaa_utils/util.h line 86
char * fsd_vasprintf(const char *fmt, void **args);
// fsd_vsnprintf
// file fsd_util.c line 282
unsigned long int fsd_vsnprintf(_Bool *truncated, char *str, unsigned long int size, const char *fmt, void **args);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettid
// file thread.c line 39
signed int gettid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// hash
// file drmaa_attrib.gperf line 66
static inline unsigned int hash(const char *str, unsigned int len);
// hashbig
// file lookup3.c line 363
unsigned int hashbig(const void *key, unsigned long int length, unsigned int initval);
// hashlittle
// file ../drmaa_utils/lookup3.h line 13
unsigned int hashlittle(const void *key, unsigned long int length, unsigned int initval);
// hashword
// file ../drmaa_utils/lookup3.h line 12
unsigned int hashword(const unsigned int *k, unsigned long int length, unsigned int initval);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// load_drmaa
// file drmaa_run.c line 137
static struct anonymous_11 load_drmaa();
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file conf_tab.c line 307
void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_args
// file drmaa_run.c line 236
static struct anonymous_12 parse_args(signed int argc, char **argv);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_2 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_2 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_2 *, const union anonymous_9 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_2 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_2 *, union anonymous_1 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_2 *, union anonymous_1 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_1 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_1 *, const union anonymous_9 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_1 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_1 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_9 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_9 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous_9 *, signed int);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// run_and_wait
// file drmaa_run.c line 271
static signed int run_and_wait(struct anonymous_11 api, struct anonymous_12 run_opt);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// stream_ripper
// file exec.c line 314
static void * stream_ripper(void *fdp);
// strerror_r
// file /usr/include/string.h line 437
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlcpy
// file compat.c line 45
unsigned long int strlcpy(char *dest, const char *src, unsigned long int size);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 183
extern char * strndup(const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unload_drmaa
// file drmaa_run.c line 228
static void unload_drmaa(struct anonymous_11 *drmaa_api_handle);
// unsetenv
// file /usr/include/stdlib.h line 588
extern signed int unsetenv(const char *);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// yyFail
// file datetime_tab.c line 758
static void yyFail(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer, const char *yymsg);
// yyLRgotoState
// file datetime_tab.c line 1166
static inline signed int yyLRgotoState(signed int yystate, signed short int yylhs);
// yyMemoryExhausted
// file datetime_tab.c line 768
static void yyMemoryExhausted(struct yyGLRStack *yystackp);
// yyaddDeferredAction
// file datetime_tab.c line 1209
static void yyaddDeferredAction(struct yyGLRStack *yystackp, unsigned long int yyk, struct yyGLRState *yystate, struct yyGLRState *rhs, signed int yyrule);
// yycompressStack
// file datetime_tab.c line 2069
static void yycompressStack(struct yyGLRStack *yystackp);
// yydefaultAction
// file datetime_tab.c line 1127
static inline signed int yydefaultAction(signed int yystate);
// yydestroyGLRState
// file datetime_tab.c line 1074
static void yydestroyGLRState(const char *yymsg, struct yyGLRState *yys, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yydestruct
// file conf_tab.c line 1052
static void yydestruct(const char *yymsg, signed int yytype, union YYSTYPE_0 *yyvaluep, struct YYLTYPE *yylocationp, struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer);
// yydestruct_link1
// file datetime_tab.c line 1048
static void yydestruct_link1(const char *yymsg_link1, signed int yytype_link1, union YYSTYPE *yyvaluep_link1, struct fsd_dt_parser_s *parser_link1, struct fsd_dt_lexer_s *lexer_link1);
// yydoAction
// file datetime_tab.c line 1467
static inline enum anonymous yydoAction(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yyrule, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyexpandGLRStack
// file datetime_tab.c line 1287
static void yyexpandGLRStack(struct yyGLRStack *yystackp);
// yyfill
// file datetime_tab.c line 811
static inline signed int yyfill(union yyGLRStackItem *yyvsp, signed int *yylow, signed int yylow1, unsigned char yynormal);
// yyfillin
// file datetime_tab.c line 790
static void yyfillin(union yyGLRStackItem *yyvsp, signed int yylow0, signed int yylow1);
// yyfreeGLRStack
// file datetime_tab.c line 1345
static void yyfreeGLRStack(struct yyGLRStack *yystackp);
// yyfreeStateSet
// file datetime_tab.c line 1252
static void yyfreeStateSet(struct yyGLRStateSet *yyset);
// yygetLRActions
// file datetime_tab.c line 1144
static inline void yygetLRActions(signed int yystate, signed int yytoken, signed int *yyaction, const signed short int **yyconflicts);
// yyglrReduce
// file datetime_tab.c line 1560
static inline enum anonymous yyglrReduce(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yyrule, unsigned char yyforceEval, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyglrShift
// file datetime_tab.c line 1423
static inline void yyglrShift(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yylrState, unsigned long int yyposn, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp);
// yyglrShiftDefer
// file datetime_tab.c line 1444
static inline void yyglrShiftDefer(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yylrState, unsigned long int yyposn, struct yyGLRState *rhs, signed int yyrule);
// yyidenticalOptions
// file datetime_tab.c line 1670
static unsigned char yyidenticalOptions(struct yySemanticOption *yyy0, struct yySemanticOption *yyy1);
// yyinitGLRStack
// file datetime_tab.c line 1261
static unsigned char yyinitGLRStack(struct yyGLRStack *yystackp, unsigned long int yysize);
// yyinitStateSet
// file datetime_tab.c line 1234
static unsigned char yyinitStateSet(struct yyGLRStateSet *yyset);
// yyisDefaultedState
// file datetime_tab.c line 1120
static inline unsigned char yyisDefaultedState(signed int yystate);
// yyisErrorAction
// file datetime_tab.c line 1183
static inline unsigned char yyisErrorAction(signed int yyaction);
// yyisShiftAction
// file datetime_tab.c line 1177
static inline unsigned char yyisShiftAction(signed int yyaction);
// yylhsNonterm
// file datetime_tab.c line 1109
static inline signed short int yylhsNonterm(signed int yyrule);
// yymarkStackDeleted
// file datetime_tab.c line 1363
static inline void yymarkStackDeleted(struct yyGLRStack *yystackp, unsigned long int yyk);
// yymergeOptionSets
// file datetime_tab.c line 1691
static void yymergeOptionSets(struct yySemanticOption *yyy0, struct yySemanticOption *yyy1);
// yynewGLRStackItem
// file datetime_tab.c line 1195
static inline union yyGLRStackItem * yynewGLRStackItem(struct yyGLRStack *yystackp, unsigned char yyisState);
// yypreference
// file datetime_tab.c line 1745
static signed int yypreference(struct yySemanticOption *y0, struct yySemanticOption *y1);
// yyprocessOneStack
// file datetime_tab.c line 2099
static enum anonymous yyprocessOneStack(struct yyGLRStack *yystackp, unsigned long int yyk, unsigned long int yyposn, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyrecoverSyntaxError
// file datetime_tab.c line 2284
static void yyrecoverSyntaxError(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyremoveDeletes
// file datetime_tab.c line 1385
static inline void yyremoveDeletes(struct yyGLRStack *yystackp);
// yyreportAmbiguity
// file datetime_tab.c line 1879
static enum anonymous yyreportAmbiguity(struct yySemanticOption *yyx0, struct yySemanticOption *yyx1, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyreportSyntaxError
// file datetime_tab.c line 2180
static void yyreportSyntaxError(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyresolveAction
// file datetime_tab.c line 1794
static enum anonymous yyresolveAction(struct yySemanticOption *yyopt, struct yyGLRStack *yystackp, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyresolveLocations
// file datetime_tab.c line 1902
static void yyresolveLocations(struct yyGLRState *yys1, signed int yyn1, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyresolveStack
// file datetime_tab.c line 2051
static enum anonymous yyresolveStack(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyresolveStates
// file datetime_tab.c line 1776
static enum anonymous yyresolveStates(struct yyGLRState *yys, signed int yyn, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyresolveValue
// file datetime_tab.c line 1963
static enum anonymous yyresolveValue(struct yyGLRState *yys, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyrhsLength
// file datetime_tab.c line 1068
static inline signed int yyrhsLength(signed int yyrule);
// yysplitStack
// file datetime_tab.c line 1623
static unsigned long int yysplitStack(struct yyGLRStack *yystackp, unsigned long int yyk);
// yyundeleteLastStack
// file datetime_tab.c line 1374
static void yyundeleteLastStack(struct yyGLRStack *yystackp);
// yyupdateSplit
// file datetime_tab.c line 1355
static inline void yyupdateSplit(struct yyGLRStack *yystackp, struct yyGLRState *yys);
// yyuserAction
// file datetime_tab.c line 827
static enum anonymous yyuserAction(signed int yyn, signed int yyrhslen, union yyGLRStackItem *yyvsp, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer);
// yyuserMerge
// file datetime_tab.c line 1028
static void yyuserMerge(signed int yyn, union YYSTYPE *yy0, union YYSTYPE *yy1);

struct anonymous_11
{
  // init
  signed int (*init)(const char *, char *, unsigned long int);
  // exit
  signed int (*exit)(char *, unsigned long int);
  // allocate_job_template
  signed int (*allocate_job_template)(struct drmaa_job_template_s **, char *, unsigned long int);
  // delete_job_template
  signed int (*delete_job_template)(struct drmaa_job_template_s *, char *, unsigned long int);
  // set_attribute
  signed int (*set_attribute)(struct drmaa_job_template_s *, const char *, const char *, char *, unsigned long int);
  // get_attribute
  signed int (*get_attribute)(struct drmaa_job_template_s *, const char *, char *, unsigned long int, char *, unsigned long int);
  // set_vector_attribute
  signed int (*set_vector_attribute)(struct drmaa_job_template_s *, const char *, const char **, char *, unsigned long int);
  // get_vector_attribute
  signed int (*get_vector_attribute)(struct drmaa_job_template_s *, const char *, struct drmaa_attr_values_s **, char *, unsigned long int);
  // run_job
  signed int (*run_job)(char *, unsigned long int, const struct drmaa_job_template_s *, char *, unsigned long int);
  // control
  signed int (*control)(const char *, signed int, char *, unsigned long int);
  // job_ps
  signed int (*job_ps)(const char *, signed int *, char *, unsigned long int);
  // wait
  signed int (*wait)(const char *, char *, unsigned long int, signed int *, signed long int, struct drmaa_attr_values_s **, char *, unsigned long int);
  // wifexited
  signed int (*wifexited)(signed int *, signed int, char *, unsigned long int);
  // wexitstatus
  signed int (*wexitstatus)(signed int *, signed int, char *, unsigned long int);
  // wifsignaled
  signed int (*wifsignaled)(signed int *, signed int, char *, unsigned long int);
  // wtermsig
  signed int (*wtermsig)(char *, unsigned long int, signed int, char *, unsigned long int);
  // wcoredump
  signed int (*wcoredump)(signed int *, signed int, char *, unsigned long int);
  // wifaborted
  signed int (*wifaborted)(signed int *, signed int, char *, unsigned long int);
  // strerror
  char (*strerror)(signed int);
  // get_contact
  signed int (*get_contact)(char *, unsigned long int, char *, unsigned long int);
  // version
  signed int (*version)(unsigned int *, unsigned int *, char *, unsigned long int);
  // get_DRM_system
  signed int (*get_DRM_system)(char *, unsigned long int, char *, unsigned long int);
  // get_DRMAA_implementation
  signed int (*get_DRMAA_implementation)(char *, unsigned long int, char *, unsigned long int);
  // handle
  void *handle;
};

struct anonymous_12
{
  // native_specification
  char *native_specification;
  // walltime
  char *walltime;
  // rusage_file
  char *rusage_file;
  // interactive
  _Bool interactive;
  // print_rusage
  _Bool print_rusage;
  // command
  char *command;
  // command_args
  char **command_args;
  // command_argc
  signed int command_argc;
};

struct anonymous_8
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct fsd_datetime_s
{
  // mask
  unsigned int mask;
  // year
  signed int year;
  // month
  signed int month;
  // day
  signed int day;
  // hour
  signed int hour;
  // minute
  signed int minute;
  // second
  signed int second;
  // tz_delta
  signed long int tz_delta;
};

union YYSTYPE
{
  // datetime
  struct fsd_datetime_s datetime;
  // integer
  signed int integer;
};

union anonymous_0
{
  // yyfirstVal
  struct yySemanticOption *yyfirstVal;
  // yysval
  union YYSTYPE yysval;
};

union anonymous_9
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // integer
  signed int integer;
  // string
  char *string;
  // dict
  struct fsd_conf_dict_s *dict;
};

union anonymous_2
{
  // __data
  struct anonymous_3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct YYLTYPE
{
  // first_line
  signed int first_line;
  // first_column
  signed int first_column;
  // last_line
  signed int last_line;
  // last_column
  signed int last_column;
};

struct YYLTYPE_0
{
  // yydummy
  char yydummy;
};

struct fsd_conf_pair_s
{
  // key
  char *key;
  // value
  struct fsd_conf_option_s *value;
};

union YYSTYPE_0
{
  // integer
  signed int integer;
  // string
  char *string;
  // option
  struct fsd_conf_option_s *option;
  // dictionary
  struct fsd_conf_dict_s *dictionary;
  // pair
  struct fsd_conf_pair_s pair;
};

union YYSTYPE_1
{
  // datetime
  struct fsd_datetime_s datetime;
  // integer
  signed int integer;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_8 __saved_mask;
};

struct drmaa_attrib
{
  // name
  signed int name;
  // attr
  const struct fsd_attribute_s *attr;
};

struct fsd_attribute_s
{
  // name
  const char *name;
  // code
  signed int code;
  // is_vector
  _Bool is_vector;
};

struct fsd_conf_dict_s
{
  // next
  struct fsd_conf_dict_s *next;
  // key
  char *key;
  // value
  struct fsd_conf_option_s *value;
};

struct fsd_conf_lexer_s
{
  // parser
  struct fsd_conf_parser_s *parser;
  // filename
  const char *filename;
  // buffer
  const unsigned char *buffer;
  // buflen
  unsigned long int buflen;
  // pos
  const unsigned char *pos;
  // lineno
  signed int lineno;
  // cline
  const unsigned char *cline;
};

struct fsd_conf_option_s
{
  // type
  enum anonymous_4 type;
  // val
  union anonymous_5 val;
};

struct fsd_conf_parser_s
{
  // lexer
  struct fsd_conf_lexer_s *lexer;
  // result
  struct fsd_conf_dict_s *result;
  // n_errors
  signed int n_errors;
  // errors
  char **errors;
};

struct fsd_dt_lexer_s
{
  // parser
  struct fsd_dt_parser_s *parser;
  // begin
  const unsigned char *begin;
  // end
  const unsigned char *end;
  // p
  const unsigned char *p;
};

struct fsd_dt_parser_s
{
  // lexer
  struct fsd_dt_lexer_s *lexer;
  // result
  struct fsd_datetime_s result;
  // n_errors
  signed int n_errors;
};

struct fsd_environ_item_s
{
  // next
  struct fsd_environ_item_s *next;
  // name
  char *name;
  // value
  char *value;
};

struct fsd_environ_s
{
  // destroy
  void (*destroy)(struct fsd_environ_s *);
  // get
  const char * (*get)(struct fsd_environ_s *, const char *);
  // set
  void (*set)(struct fsd_environ_s *, char *, char *);
  // update
  void (*update)(struct fsd_environ_s *, const char * const *);
  // list
  char ** (*list)(struct fsd_environ_s *);
  // apply
  struct fsd_environ_s * (*apply)(struct fsd_environ_s *);
  // restore
  void (*restore)(struct fsd_environ_s *, struct fsd_environ_s *);
  // _table
  struct fsd_environ_item_s **_table;
  // _table_size
  unsigned int _table_size;
};

struct fsd_exc_s
{
  // code
  signed int (*code)(const struct fsd_exc_s *);
  // message
  const char * (*message)(const struct fsd_exc_s *);
  // destroy
  void (*destroy)(struct fsd_exc_s *);
  // _code
  signed int _code;
  // _message
  char *_message;
  // _own_message
  _Bool _own_message;
  // _own_self
  _Bool _own_self;
};

struct fsd_exc_stack_s
{
  // restore_points
  struct fsd_exc_try_block_s **restore_points;
  // n_restore_points
  signed int n_restore_points;
};

struct fsd_exc_try_block_s
{
  // env
  struct __jmp_buf_tag env[1l];
  // handled_exc
  struct fsd_exc_s *handled_exc;
  // state
  enum anonymous_6 state;
  // function
  const char *function;
  // lineno
  signed int lineno;
};

struct fsd_expand_drmaa_ph_s
{
  // expand
  char * (*expand)(struct fsd_expand_drmaa_ph_s *, char *, unsigned int);
  // set
  void (*set)(struct fsd_expand_drmaa_ph_s *, signed int, char *);
  // destroy
  void (*destroy)(struct fsd_expand_drmaa_ph_s *);
  // home_directory
  char *home_directory;
  // working_directory
  char *working_directory;
  // bulk_incr
  char *bulk_incr;
};

struct fsd_iter_s
{
  // next
  const char * (*next)(struct fsd_iter_s *);
  // reset
  void (*reset)(struct fsd_iter_s *);
  // len
  signed int (*len)(struct fsd_iter_s *);
  // append
  void (*append)(struct fsd_iter_s *, char *);
  // destroy
  void (*destroy)(struct fsd_iter_s *);
  // _list
  char **_list;
  // _position
  signed int _position;
  // _length
  signed int _length;
  // _own_list
  _Bool _own_list;
};

struct fsd_job_s
{
  // release
  void (*release)(struct fsd_job_s *);
  // destroy
  void (*destroy)(struct fsd_job_s *);
  // control
  void (*control)(struct fsd_job_s *, signed int);
  // update_status
  void (*update_status)(struct fsd_job_s *);
  // get_termination_status
  void (*get_termination_status)(struct fsd_job_s *, signed int *, struct fsd_iter_s **);
  // on_missing
  void (*on_missing)(struct fsd_job_s *);
  // next
  struct fsd_job_s *next;
  // ref_cnt
  signed int ref_cnt;
  // job_id
  char *job_id;
  // session
  struct fsd_drmaa_session_s *session;
  // last_update_time
  signed long int last_update_time;
  // flags
  unsigned int flags;
  // state
  signed int state;
  // exit_status
  signed int exit_status;
  // submit_time
  signed long int submit_time;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
  // cpu_usage
  signed long int cpu_usage;
  // mem_usage
  signed long int mem_usage;
  // vmem_usage
  signed long int vmem_usage;
  // walltime
  signed long int walltime;
  // execution_hosts
  char *execution_hosts;
  // queue
  char *queue;
  // project
  char *project;
  // mutex
  union anonymous_1 mutex;
  // status_cond
  union anonymous_2 status_cond;
  // destroy_cond
  union anonymous_2 destroy_cond;
};

struct fsd_job_set_s
{
  // destroy
  void (*destroy)(struct fsd_job_set_s *);
  // add
  void (*add)(struct fsd_job_set_s *, struct fsd_job_s *);
  // remove
  void (*remove)(struct fsd_job_set_s *, struct fsd_job_s *);
  // get
  struct fsd_job_s * (*get)(struct fsd_job_set_s *, const char *);
  // empty
  _Bool (*empty)(struct fsd_job_set_s *);
  // find_terminated
  struct fsd_job_s * (*find_terminated)(struct fsd_job_set_s *);
  // get_all_job_ids
  char ** (*get_all_job_ids)(struct fsd_job_set_s *);
  // signal_all
  void (*signal_all)(struct fsd_job_set_s *);
  // tab
  struct fsd_job_s **tab;
  // tab_size
  unsigned long int tab_size;
  // tab_mask
  unsigned int tab_mask;
  // n_jobs
  unsigned int n_jobs;
  // mutex
  union anonymous_1 mutex;
};

struct fsd_template_s
{
  // get_attr
  const char * (*get_attr)(const struct fsd_template_s *, const char *);
  // set_attr
  void (*set_attr)(struct fsd_template_s *, const char *, const char *);
  // get_v_attr
  const char * const * (*get_v_attr)(const struct fsd_template_s *, const char *);
  // set_v_attr
  void (*set_v_attr)(struct fsd_template_s *, const char *, const char **);
  // by_name
  const struct fsd_attribute_s * (*by_name)(const struct fsd_template_s *, const char *);
  // by_code
  const struct fsd_attribute_s * (*by_code)(const struct fsd_template_s *, signed int);
  // destroy
  void (*destroy)(struct fsd_template_s *);
  // attributes
  void **attributes;
  // n_attributes
  unsigned int n_attributes;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stringpool_t
{
  // stringpool_str8
  char stringpool_str8[(signed long int)sizeof(char [9l]) /*9l*/ ];
  // stringpool_str11
  char stringpool_str11[(signed long int)sizeof(char [12l]) /*12l*/ ];
  // stringpool_str12
  char stringpool_str12[(signed long int)sizeof(char [13l]) /*13l*/ ];
  // stringpool_str13
  char stringpool_str13[(signed long int)sizeof(char [14l]) /*14l*/ ];
  // stringpool_str14
  char stringpool_str14[(signed long int)sizeof(char [15l]) /*15l*/ ];
  // stringpool_str16
  char stringpool_str16[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str17
  char stringpool_str17[(signed long int)sizeof(char [18l]) /*18l*/ ];
  // stringpool_str18
  char stringpool_str18[(signed long int)sizeof(char [19l]) /*19l*/ ];
  // stringpool_str19
  char stringpool_str19[(signed long int)sizeof(char [15l]) /*15l*/ ];
  // stringpool_str20
  char stringpool_str20[(signed long int)sizeof(char [21l]) /*21l*/ ];
  // stringpool_str21
  char stringpool_str21[(signed long int)sizeof(char [22l]) /*22l*/ ];
  // stringpool_str22
  char stringpool_str22[(signed long int)sizeof(char [18l]) /*18l*/ ];
  // stringpool_str24
  char stringpool_str24[(signed long int)sizeof(char [20l]) /*20l*/ ];
  // stringpool_str25
  char stringpool_str25[(signed long int)sizeof(char [21l]) /*21l*/ ];
  // stringpool_str26
  char stringpool_str26[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str29
  char stringpool_str29[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str31
  char stringpool_str31[(signed long int)sizeof(char [22l]) /*22l*/ ];
  // stringpool_str34
  char stringpool_str34[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str36
  char stringpool_str36[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str41
  char stringpool_str41[(signed long int)sizeof(char [17l]) /*17l*/ ];
  // stringpool_str46
  char stringpool_str46[(signed long int)sizeof(char [27l]) /*27l*/ ];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct yyGLRStateSet
{
  // yystates
  struct yyGLRState **yystates;
  // yylookaheadNeeds
  unsigned char *yylookaheadNeeds;
  // yysize
  unsigned long int yysize;
  // yycapacity
  unsigned long int yycapacity;
};

struct yyGLRStack
{
  // yyerrState
  signed int yyerrState;
  // yyerrcnt
  signed int yyerrcnt;
  // yyrawchar
  signed int yyrawchar;
  // yyval
  union YYSTYPE yyval;
  // yyloc
  struct YYLTYPE_0 yyloc;
  // yyexception_buffer
  struct __jmp_buf_tag yyexception_buffer[1l];
  // yyitems
  union yyGLRStackItem *yyitems;
  // yynextFree
  union yyGLRStackItem *yynextFree;
  // yyspaceLeft
  unsigned long int yyspaceLeft;
  // yysplitPoint
  struct yyGLRState *yysplitPoint;
  // yylastDeleted
  struct yyGLRState *yylastDeleted;
  // yytops
  struct yyGLRStateSet yytops;
};

struct yyGLRState
{
  // yyisState
  unsigned char yyisState;
  // yyresolved
  unsigned char yyresolved;
  // yylrState
  signed int yylrState;
  // yypred
  struct yyGLRState *yypred;
  // yyposn
  unsigned long int yyposn;
  // yysemantics
  union anonymous_0 yysemantics;
  // yyloc
  struct YYLTYPE_0 yyloc;
};

struct yySemanticOption
{
  // yyisState
  unsigned char yyisState;
  // yyrule
  signed int yyrule;
  // yystate
  struct yyGLRState *yystate;
  // yyrawchar
  signed int yyrawchar;
  // yyval
  union YYSTYPE yyval;
  // yyloc
  struct YYLTYPE_0 yyloc;
  // yynext
  struct yySemanticOption *yynext;
};

union yyGLRStackItem
{
  // yystate
  struct yyGLRState yystate;
  // yyoption
  struct yySemanticOption yyoption;
};

union yyalloc
{
  // yyss_alloc
  signed short int yyss_alloc;
  // yyvs_alloc
  union YYSTYPE_0 yyvs_alloc;
  // yyls_alloc
  struct YYLTYPE yyls_alloc;
};


// YYEMPTY
// file datetime_tab.c line 454
static const signed int YYEMPTY = -2;
// YYEOF
// file datetime_tab.c line 453
static const signed int YYEOF = 0;
// drmaa_attributes
// file drmaa_attrib.gperf line 115
const struct fsd_attribute_s drmaa_attributes[21l] = { { .name="drmaa_remote_command", .code=0, .is_vector=(_Bool)0 },
    { .name="drmaa_v_argv", .code=1, .is_vector=(_Bool)1 },
    { .name="drmaa_js_state", .code=2, .is_vector=(_Bool)0 },
    { .name="drmaa_v_env", .code=3, .is_vector=(_Bool)1 },
    { .name="drmaa_wd", .code=4, .is_vector=(_Bool)0 },
    { .name="drmaa_job_category", .code=5, .is_vector=(_Bool)0 },
    { .name="drmaa_native_specification", .code=6, .is_vector=(_Bool)0 },
    { .name="drmaa_v_email", .code=7, .is_vector=(_Bool)1 },
    { .name="drmaa_block_email", .code=8, .is_vector=(_Bool)0 },
    { .name="drmaa_start_time", .code=9, .is_vector=(_Bool)0 },
    { .name="drmaa_job_name", .code=10, .is_vector=(_Bool)0 },
    { .name="drmaa_input_path", .code=11, .is_vector=(_Bool)0 },
    { .name="drmaa_output_path", .code=12, .is_vector=(_Bool)0 },
    { .name="drmaa_error_path", .code=13, .is_vector=(_Bool)0 },
    { .name="drmaa_join_files", .code=14, .is_vector=(_Bool)0 },
    { .name="drmaa_transfer_files", .code=15, .is_vector=(_Bool)0 },
    { .name="drmaa_deadline_time", .code=16, .is_vector=(_Bool)0 },
    { .name="drmaa_wct_hlimit", .code=17, .is_vector=(_Bool)0 },
    { .name="drmaa_wct_slimit", .code=18, .is_vector=(_Bool)0 },
    { .name="drmaa_duration_hlimit", .code=19, .is_vector=(_Bool)0 },
    { .name="drmaa_duration_slimit", .code=20, .is_vector=(_Bool)0 } };
// environ
// file /usr/include/unistd.h line 545
extern char **environ;
// fsd_exc_init_once
// file exception.c line 68
static signed int fsd_exc_init_once = 0;
// fsd_exc_stack
// file exception.c line 67
static unsigned int fsd_exc_stack;
// fsd_logging_output
// file logging.c line 49
static signed int fsd_logging_output = 2;
// fsd_logging_start
// file logging.c line 59
static struct timeval fsd_logging_start = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
// fsd_stacktrace_length
// file exception.c line 566
static const signed int fsd_stacktrace_length = 32;
// fsd_verbose_level
// file logging.c line 51
enum anonymous_7 fsd_verbose_level = (enum anonymous_7)FSD_LOG_FATAL;
// no_memory_exception
// file exception.c line 53
static const struct fsd_exc_s no_memory_exception;
// no_memory_exception
// file exception.c line 53
static const struct fsd_exc_s no_memory_exception = { .code=fsd_exc_code, .message=fsd_exc_message, .destroy=fsd_exc_destroy,
    ._code=1002, ._message="Not enough memory.",
    ._own_message=(_Bool)0, ._own_self=(_Bool)0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stringpool_contents
// file drmaa_attrib.gperf line 143
static struct stringpool_t stringpool_contents = { .stringpool_str8={ 'd', 'r', 'm', 'a', 'a', '_', 'w', 'd', 0 }, .stringpool_str11={ 'd', 'r', 'm', 'a', 'a', '_', 'v', '_', 'e', 'n', 'v', 0 },
    .stringpool_str12={ 'd', 'r', 'm', 'a', 'a', '_', 'v', '_', 'a', 'r', 'g', 'v', 0 },
    .stringpool_str13={ 'd', 'r', 'm', 'a', 'a', '_', 'v', '_', 'e', 'm', 'a', 'i', 'l', 0 },
    .stringpool_str14={ 'd', 'r', 'm', 'a', 'a', '_', 'j', 's', '_', 's', 't', 'a', 't', 'e', 0 },
    .stringpool_str16={ 'd', 'r', 'm', 'a', 'a', '_', 'w', 'c', 't', '_', 's', 'l', 'i', 'm', 'i', 't', 0 },
    .stringpool_str17={ 'd', 'r', 'm', 'a', 'a', '_', 'o', 'u', 't', 'p', 'u', 't', '_', 'p', 'a', 't', 'h', 0 },
    .stringpool_str18={ 'd', 'r', 'm', 'a', 'a', '_', 'j', 'o', 'b', '_', 'c', 'a', 't', 'e', 'g', 'o', 'r', 'y', 0 },
    .stringpool_str19={ 'd', 'r', 'm', 'a', 'a', '_', 'j', 'o', 'b', '_', 'n', 'a', 'm', 'e', 0 },
    .stringpool_str20={ 'd', 'r', 'm', 'a', 'a', '_', 't', 'r', 'a', 'n', 's', 'f', 'e', 'r', '_', 'f', 'i', 'l', 'e', 's', 0 },
    .stringpool_str21={ 'd', 'r', 'm', 'a', 'a', '_', 'd', 'u', 'r', 'a', 't', 'i', 'o', 'n', '_', 's', 'l', 'i', 'm', 'i', 't', 0 },
    .stringpool_str22={ 'd', 'r', 'm', 'a', 'a', '_', 'b', 'l', 'o', 'c', 'k', '_', 'e', 'm', 'a', 'i', 'l', 0 },
    .stringpool_str24={ 'd', 'r', 'm', 'a', 'a', '_', 'd', 'e', 'a', 'd', 'l', 'i', 'n', 'e', '_', 't', 'i', 'm', 'e', 0 },
    .stringpool_str25={ 'd', 'r', 'm', 'a', 'a', '_', 'r', 'e', 'm', 'o', 't', 'e', '_', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 0 },
    .stringpool_str26={ 'd', 'r', 'm', 'a', 'a', '_', 'i', 'n', 'p', 'u', 't', '_', 'p', 'a', 't', 'h', 0 },
    .stringpool_str29={ 'd', 'r', 'm', 'a', 'a', '_', 'w', 'c', 't', '_', 'h', 'l', 'i', 'm', 'i', 't', 0 },
    .stringpool_str31={ 'd', 'r', 'm', 'a', 'a', '_', 'd', 'u', 'r', 'a', 't', 'i', 'o', 'n', '_', 'h', 'l', 'i', 'm', 'i', 't', 0 },
    .stringpool_str34={ 'd', 'r', 'm', 'a', 'a', '_', 'j', 'o', 'i', 'n', '_', 'f', 'i', 'l', 'e', 's', 0 },
    .stringpool_str36={ 'd', 'r', 'm', 'a', 'a', '_', 's', 't', 'a', 'r', 't', '_', 't', 'i', 'm', 'e', 0 },
    .stringpool_str41={ 'd', 'r', 'm', 'a', 'a', '_', 'e', 'r', 'r', 'o', 'r', '_', 'p', 'a', 't', 'h', 0 },
    .stringpool_str46={ 'd', 'r', 'm', 'a', 'a', '_', 'n', 'a', 't', 'i', 'v', 'e', '_', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', 0 } };
// yycheck
// file conf_tab.c line 533
static const signed char yycheck[18l] = { (const signed char)3, (const signed char)4, (const signed char)4, (const signed char)6, (const signed char)6, (const signed char)9, (const signed char)4, (const signed char)0, (const signed char)8, (const signed char)-1, (const signed char)7, (const signed char)2, (const signed char)-1, (const signed char)9, (const signed char)-1, (const signed char)-1, (const signed char)-1, (const signed char)12 };
// yycheck_link1
// file datetime_tab.c line 397
static const unsigned char yycheck_link1[26l] = { (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)6, (const unsigned char)0, (const unsigned char)5, (const unsigned char)9, (const unsigned char)10, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)8, (const unsigned char)11, (const unsigned char)21, (const unsigned char)6, (const unsigned char)3, (const unsigned char)7, (const unsigned char)3, (const unsigned char)8, (const unsigned char)8, (const unsigned char)3, (const unsigned char)3 };
// yyconfl
// file datetime_tab.c line 392
static const signed short int yyconfl[1l] = { (const signed short int)0 };
// yyconflp
// file datetime_tab.c line 383
static const unsigned char yyconflp[26l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
// yydefact
// file conf_tab.c line 495
static const unsigned char yydefact[19l] = { (const unsigned char)8, (const unsigned char)0, (const unsigned char)8, (const unsigned char)0, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4, (const unsigned char)6, (const unsigned char)9, (const unsigned char)0, (const unsigned char)0, (const unsigned char)1, (const unsigned char)7, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)11, (const unsigned char)5, (const unsigned char)10 };
// yydefact_link1
// file datetime_tab.c line 336
static const unsigned char yydefact_link1[32l] = { (const unsigned char)0, (const unsigned char)11, (const unsigned char)0, (const unsigned char)2, (const unsigned char)5, (const unsigned char)14, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)1, (const unsigned char)6, (const unsigned char)0, (const unsigned char)20, (const unsigned char)17, (const unsigned char)19, (const unsigned char)3, (const unsigned char)0, (const unsigned char)8, (const unsigned char)10, (const unsigned char)12, (const unsigned char)0, (const unsigned char)14, (const unsigned char)15, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)4, (const unsigned char)0, (const unsigned char)7, (const unsigned char)9, (const unsigned char)13, (const unsigned char)16 };
// yydefgoto
// file conf_tab.c line 502
static const signed char yydefgoto[8l] = { (const signed char)-1, (const signed char)3, (const signed char)4, (const signed char)5, (const signed char)6, (const signed char)7, (const signed char)8, (const signed char)16 };
// yydefgoto_link1
// file datetime_tab.c line 345
static const signed char yydefgoto_link1[8l] = { (const signed char)-1, (const signed char)2, (const signed char)3, (const signed char)11, (const signed char)4, (const signed char)5, (const signed char)15, (const signed char)16 };
// yydprec
// file datetime_tab.c line 318
static const unsigned char yydprec[21l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
// yymerger
// file datetime_tab.c line 326
static const unsigned char yymerger[21l] = { (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
// yypact
// file conf_tab.c line 510
static const signed char yypact[19l] = { (const signed char)-2, (const signed char)-4, (const signed char)2, (const signed char)7, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)0, (const signed char)-5, (const signed char)-3, (const signed char)3, (const signed char)-5, (const signed char)2, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5 };
// yypact_link1
// file datetime_tab.c line 353
static const signed char yypact_link1[32l] = { (const signed char)-2, (const signed char)2, (const signed char)4, (const signed char)-5, (const signed char)0, (const signed char)-3, (const signed char)-1, (const signed char)8, (const signed char)9, (const signed char)-5, (const signed char)-5, (const signed char)10, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)11, (const signed char)12, (const signed char)13, (const signed char)7, (const signed char)14, (const signed char)-3, (const signed char)15, (const signed char)16, (const signed char)18, (const signed char)21, (const signed char)-5, (const signed char)22, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5 };
// yypgoto
// file conf_tab.c line 517
static const signed char yypgoto[8l] = { (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)4, (const signed char)9, (const signed char)-5, (const signed char)5, (const signed char)-5 };
// yypgoto_link1
// file datetime_tab.c line 362
static const signed char yypgoto_link1[8l] = { (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)-5, (const signed char)5, (const signed char)-4, (const signed char)-5 };
// yyr1
// file conf_tab.c line 479
static const unsigned char yyr1[15l] = { (const unsigned char)0, (const unsigned char)10, (const unsigned char)11, (const unsigned char)12, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)14, (const unsigned char)14, (const unsigned char)15, (const unsigned char)15, (const unsigned char)16, (const unsigned char)17, (const unsigned char)17, (const unsigned char)17 };
// yyr1_link1
// file datetime_tab.c line 302
static const unsigned char yyr1_link1[21l] = { (const unsigned char)0, (const unsigned char)11, (const unsigned char)12, (const unsigned char)13, (const unsigned char)13, (const unsigned char)14, (const unsigned char)14, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)15, (const unsigned char)16, (const unsigned char)16, (const unsigned char)17, (const unsigned char)17, (const unsigned char)17, (const unsigned char)17, (const unsigned char)18, (const unsigned char)18, (const unsigned char)18 };
// yyr2
// file conf_tab.c line 486
static const unsigned char yyr2[15l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1, (const unsigned char)3, (const unsigned char)1, (const unsigned char)2, (const unsigned char)0, (const unsigned char)1, (const unsigned char)3, (const unsigned char)3, (const unsigned char)1, (const unsigned char)1, (const unsigned char)1 };
// yyr2_link1
// file datetime_tab.c line 310
static const unsigned char yyr2_link1[21l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)4, (const unsigned char)0, (const unsigned char)1, (const unsigned char)5, (const unsigned char)3, (const unsigned char)5, (const unsigned char)3, (const unsigned char)1, (const unsigned char)3, (const unsigned char)5, (const unsigned char)0, (const unsigned char)2, (const unsigned char)4, (const unsigned char)1, (const unsigned char)0, (const unsigned char)1, (const unsigned char)1 };
// yystos
// file conf_tab.c line 541
static const unsigned char yystos[19l] = { (const unsigned char)0, (const unsigned char)4, (const unsigned char)6, (const unsigned char)11, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)15, (const unsigned char)16, (const unsigned char)9, (const unsigned char)14, (const unsigned char)0, (const unsigned char)8, (const unsigned char)3, (const unsigned char)4, (const unsigned char)13, (const unsigned char)17, (const unsigned char)7, (const unsigned char)16 };
// yystos_link1
// file datetime_tab.c line 406
static const unsigned char yystos_link1[32l] = { (const unsigned char)0, (const unsigned char)3, (const unsigned char)12, (const unsigned char)13, (const unsigned char)15, (const unsigned char)16, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)0, (const unsigned char)5, (const unsigned char)14, (const unsigned char)6, (const unsigned char)9, (const unsigned char)10, (const unsigned char)17, (const unsigned char)18, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)16, (const unsigned char)3, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)17, (const unsigned char)8, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3, (const unsigned char)3 };
// yytable
// file conf_tab.c line 527
static const unsigned char yytable[18l] = { (const unsigned char)13, (const unsigned char)14, (const unsigned char)1, (const unsigned char)2, (const unsigned char)2, (const unsigned char)9, (const unsigned char)1, (const unsigned char)11, (const unsigned char)12, (const unsigned char)0, (const unsigned char)17, (const unsigned char)10, (const unsigned char)0, (const unsigned char)15, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)18 };
// yytable_link1
// file datetime_tab.c line 372
static const signed char yytable_link1[26l] = { (const signed char)-18, (const signed char)1, (const signed char)17, (const signed char)12, (const signed char)9, (const signed char)10, (const signed char)13, (const signed char)14, (const signed char)6, (const signed char)7, (const signed char)8, (const signed char)18, (const signed char)19, (const signed char)20, (const signed char)22, (const signed char)25, (const signed char)21, (const signed char)26, (const signed char)23, (const signed char)28, (const signed char)24, (const signed char)29, (const signed char)8, (const signed char)27, (const signed char)30, (const signed char)31 };
// yytranslate
// file conf_tab.c line 401
static const unsigned char yytranslate[261l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)8, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)9, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)6, (const unsigned char)2, (const unsigned char)7, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4, (const unsigned char)5 };
// yytranslate_link1
// file datetime_tab.c line 229
static const unsigned char yytranslate_link1[260l] = { (const unsigned char)0, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)10, (const unsigned char)2, (const unsigned char)6, (const unsigned char)2, (const unsigned char)7, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)8, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)5, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)9, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)2, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4 };
// yyval_default
// file datetime_tab.c line 103
static union YYSTYPE yyval_default;

// _fsd_log
// file ../drmaa_utils/logging.h line 66
void _fsd_log(signed int level, const char *file, const char *function, signed int kind, char *message)
{
  const _Bool color = (const _Bool)0;
  char colorbeg[16l];
  const char *colorend;
  signed int tid;
  signed long int seconds;
  signed long int microseconds;
  const char *prefix;
  const char *p;
  char *return_value_fsd_asprintf_1;
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_4;
  if(!(level >= (signed int)fsd_verbose_level))
    free((void *)message);

  else
    if(!(message == ((char *)NULL)))
    {
      tid=fsd_thread_id();
      if(!(color == (_Bool)0))
      {
        fsd_color(colorbeg, sizeof(char [16l]) /*16ul*/ , tid);
        colorend = "\033[0m";
      }

      else
      {
        colorbeg[(signed long int)0] = (char)0;
        colorend = "";
      }
      struct timeval tv;
      gettimeofday(&tv, (struct timezone *)(void *)0);
      seconds = tv.tv_sec;
      microseconds = tv.tv_usec;
      if(fsd_logging_start.tv_sec == 0l)
      {
        signed long int t;
        struct tm utc;
        char rep[32l];
        fsd_log_check_verbosity();
        fsd_logging_start.tv_sec = seconds;
        fsd_logging_start.tv_usec = microseconds;
        t = seconds;
        gmtime_r(&t, &utc);
        strftime(rep, sizeof(char [32l]) /*32ul*/ , "%Y-%m-%d %H:%M:%S", &utc);
        do
          if(!((signed int)fsd_verbose_level >= 4))
          {
            return_value_fsd_asprintf_1=fsd_asprintf("logging started at: %s.%02ld Z", (const void *)rep, microseconds / (signed long int)10000);
            _fsd_log(FSD_LOG_INFO, "logging.c", "_fsd_log", 0, return_value_fsd_asprintf_1);
          }

        while((_Bool)0);
        if(!(level >= (signed int)fsd_verbose_level))
        {
          free((void *)message);
          goto __CPROVER_DUMP_L20;
        }

      }

      if(!(microseconds >= fsd_logging_start.tv_usec))
      {
        seconds = seconds - 1l;
        microseconds = microseconds + (signed long int)1000000;
      }

      seconds = seconds - fsd_logging_start.tv_sec;
      microseconds = microseconds - fsd_logging_start.tv_usec;
      switch(kind)
      {
        case 1:
        {
          prefix = "->";
          break;
        }
        case 2:
        {
          prefix = "<-";
          break;
        }
        default:
        {
          prefix = " *";
          function = "";
        }
      }
      p = message;
      while((_Bool)1)
      {
        if((signed int)*p == 10)
        {
          prefix = " |";
          function = "";
          p = p + 1l;
        }

        else
        {
          const char *end;
          char *line = (char *)(void *)0;
          signed int rc;
          end=strchr(p, 10);
          if(end == ((const char *)NULL))
          {
            return_value_strlen_2=strlen(p);
            end = p + (signed long int)return_value_strlen_2;
          }

          char return_value_fsd_log_level_char_3;
          return_value_fsd_log_level_char_3=fsd_log_level_char(level);
          rc=asprintf(&line, "%c #%s%04x%s [%6ld.%02ld] %s %s%.*s\n", return_value_fsd_log_level_char_3, (const void *)colorbeg, tid, colorend, seconds, microseconds / (signed long int)10000, prefix, function, (signed int)(end - p), p);
          if(!(rc == -1))
          {
            return_value_strlen_4=strlen(line);
            write(fsd_logging_output, (const void *)line, return_value_strlen_4);
          }

          else
            goto __CPROVER_DUMP_L20;
          free((void *)line);
          p = end;
        }
        if((signed int)*p == 0)
          break;

      }
      free((void *)message);
    }


__CPROVER_DUMP_L20:
  ;
}

// drmaa_attrib_lookup
// file drmaa_attrib.gperf line 175
inline struct drmaa_attrib * drmaa_attrib_lookup(const char *str, unsigned int len)
{
  signed int return_value_strcmp_2;
  if(len >= 8u && !(len >= 27u))
  {
    signed int key;
    unsigned int return_value_hash_1;
    return_value_hash_1=hash(str, len);
    key = (signed int)return_value_hash_1;
    if(key >= 0 && !(key >= 47))
    {
      static struct drmaa_attrib wordlist[47l] = { { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str8, .attr=&drmaa_attributes[(signed long int)4] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str11, .attr=&drmaa_attributes[(signed long int)3] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str12, .attr=&drmaa_attributes[(signed long int)1] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str13, .attr=&drmaa_attributes[(signed long int)7] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str14, .attr=&drmaa_attributes[(signed long int)2] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str16, .attr=&drmaa_attributes[(signed long int)18] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str17, .attr=&drmaa_attributes[(signed long int)12] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str18, .attr=&drmaa_attributes[(signed long int)5] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str19, .attr=&drmaa_attributes[(signed long int)10] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str20, .attr=&drmaa_attributes[(signed long int)15] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str21, .attr=&drmaa_attributes[(signed long int)20] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str22, .attr=&drmaa_attributes[(signed long int)8] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str24, .attr=&drmaa_attributes[(signed long int)16] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str25, .attr=&drmaa_attributes[(signed long int)0] },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str26, .attr=&drmaa_attributes[(signed long int)11] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str29, .attr=&drmaa_attributes[(signed long int)17] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str31, .attr=&drmaa_attributes[(signed long int)19] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str34, .attr=&drmaa_attributes[(signed long int)14] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str36, .attr=&drmaa_attributes[(signed long int)9] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str41, .attr=&drmaa_attributes[(signed long int)13] },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=-1, .attr=((const struct fsd_attribute_s *)NULL) },
    { .name=(signed int)(signed long int)&((struct stringpool_t *)0)->stringpool_str46, .attr=&drmaa_attributes[(signed long int)6] } };
      signed int o = wordlist[(signed long int)key].name;
      if(o >= 0)
      {
        const char *s = (signed long int)o + (const char *)&stringpool_contents;
        if(*str == *s)
        {
          return_value_strcmp_2=strcmp(str + (signed long int)1, s + (signed long int)1);
          if(return_value_strcmp_2 == 0)
            return &wordlist[(signed long int)key];

        }

      }

    }

  }

  return ((struct drmaa_attrib *)NULL);
}

// drmaa_control_to_str
// file drmaa_util.c line 173
const char * drmaa_control_to_str(signed int action)
{
  switch(action)
  {
    case 0:
      return "suspend";
    case 1:
      return "resume";
    case 2:
      return "hold";
    case 3:
      return "release";
    case 4:
      return "terminate";
    default:
      return "?";
  }
}

// drmaa_job_ps_to_str
// file drmaa_util.c line 194
const char * drmaa_job_ps_to_str(signed int ps)
{
  switch(ps)
  {
    case 0x00:
      return "undetermined";
    case 0x10:
      return "queued_active";
    case 0x11:
      return "system_on_hold";
    case 0x12:
      return "user_on_hold";
    case 0x13:
      return "user_system_on_hold";
    case 0x20:
      return "running";
    case 0x21:
      return "system_suspended";
    case 0x22:
      return "user_suspended";
    case 0x23:
      return "user_system_suspended";
    case 0x30:
      return "done";
    case 0x40:
      return "failed";
    default:
      return "?";
  }
}

// drmaa_template_by_code
// file drmaa_attrib.gperf line 92
static const struct fsd_attribute_s * drmaa_template_by_code(const struct fsd_template_s *self, signed int code)
{
  if(code >= 0 && !(code >= 21))
    return &drmaa_attributes[(signed long int)code];

  else
    fsd_exc_raise_fmt(1003, "invalid attribute code: %d", code);
}

// drmaa_template_by_name
// file drmaa_attrib.gperf line 77
static const struct fsd_attribute_s * drmaa_template_by_name(const struct fsd_template_s *self, const char *name)
{
  struct drmaa_attrib *found;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  found=drmaa_attrib_lookup(name, (unsigned int)return_value_strlen_1);
  if(!(found == ((struct drmaa_attrib *)NULL)))
    return found->attr;

  else
    fsd_exc_raise_fmt(1003, "invalid DRMAA attribute name: %s", name);
}

// drmaa_template_new
// file drmaa_attrib.gperf line 105
struct fsd_template_s * drmaa_template_new(void)
{
  struct fsd_template_s *return_value_fsd_template_new_1;
  return_value_fsd_template_new_1=fsd_template_new(drmaa_template_by_name, drmaa_template_by_code, (unsigned int)21);
  return return_value_fsd_template_new_1;
}

// fsd_asprintf
// file ../drmaa_utils/util.h line 79
char * fsd_asprintf(const char *fmt, ...)
{
  void **args;
  char *result = (char *)(void *)0;
  args = (void **)&fmt;
  result=fsd_vasprintf(fmt, args);
  args = ((void **)NULL);
  return result;
}

// fsd_assertion_failed
// file exception.c line 569
void fsd_assertion_failed(const char *file, signed int lineno, const char *function, const char *precondition)
{
  char *message = (char *)(void *)0;
  signed int return_value_asprintf_1;
  return_value_asprintf_1=asprintf(&message, "%s:%d: %s: Assertion `%s' failed.", file, lineno, function, precondition);
  if(return_value_asprintf_1 == -1)
    message = (char *)(void *)0;

  char *return_value_fsd_asprintf_2;
  if(!(message == ((char *)NULL)))
    do
      if(!((signed int)fsd_verbose_level >= 7))
      {
        return_value_fsd_asprintf_2=fsd_asprintf("%s", message);
        _fsd_log(FSD_LOG_FATAL, "exception.c", "fsd_assertion_failed", 0, return_value_fsd_asprintf_2);
      }

    while((_Bool)0);

  fsd_log_stacktrace(1, fsd_stacktrace_length);
  if(!(message == ((char *)NULL)))
    free((void *)message);

  abort();
}

// fsd_astrerror
// file ../drmaa_utils/util.h line 108
char * fsd_astrerror(signed int errnum, _Bool *malloced)
{
  char *buffer = (char *)(void *)0;
  unsigned long int buffer_size = (unsigned long int)0;
  char *result = (char *)(void *)0;
  unsigned long int return_value_strlen_1;
  do
  {
    if(buffer_size == 0ul)
      buffer_size = (unsigned long int)1024;

    else
      buffer_size = buffer_size * (unsigned long int)2;
    fsd_realloc_((void **)(void *)&buffer, buffer_size * sizeof(char) /*1ul*/ );
    result=strerror_r(errnum, buffer, buffer_size);
    if(result == buffer)
    {
      return_value_strlen_1=strlen(result);
      if(1ul + return_value_strlen_1 == buffer_size)
        continue;

    }

  }
  while((_Bool)0);
  *malloced = buffer == result;
  if(!(buffer == result))
    fsd_free((void *)buffer);

  return result;
}

// fsd_atoi
// file fsd_util.c line 201
signed int fsd_atoi(const char *string)
{
  const char *s = string;
  signed int sign = +1;
  signed int v = 0;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*((const unsigned char *)s)]) == 0)
      break;

    s = s + 1l;
  }
  while((_Bool)1);
  switch((signed int)*s)
  {
    case 43:
    {
      sign = +1;
      s = s + 1l;
      break;
    }
    case 45:
    {
      sign = -1;
      s = s + 1l;
    }
  }
  const unsigned short int **return_value___ctype_b_loc_2;
  do
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*((const unsigned char *)s)]) == 0)
      break;

    s = s + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_4;
  if((signed int)*s >= 48)
    tmp_if_expr_4 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  const char *tmp_post_3;
  if(tmp_if_expr_4)
    while((signed int)*s >= 48)
    {
      if((signed int)*s >= 58)
        break;

      if(v >= 214748365)
        goto range_error;

      v = v * 10;
      tmp_post_3 = s;
      s = s + 1l;
      v = v + ((signed int)*tmp_post_3 - 48);
      if(!(v >= 0))
        goto range_error;

    }

  else
    goto nan_error;
  const unsigned short int **return_value___ctype_b_loc_5;
  do
  {
    return_value___ctype_b_loc_5=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)*((const unsigned char *)s)]) == 0)
      break;

    s = s + 1l;
  }
  while((_Bool)1);
  if((signed int)*s == 0)
  {
    return sign * v;

  range_error:
    ;
    fsd_exc_raise_fmt(1003, "value out of range: %s", string);
    return 0;
  }

  else
  {

  nan_error:
    ;
    fsd_exc_raise_fmt(1003, "not an number: %s", string);
    return 0;
  }
}

// fsd_calloc_
// file ../drmaa_utils/xmalloc.h line 66
void * fsd_calloc_(void **p, unsigned long int n, unsigned long int size)
{
  void *ptr = (void *)0;
  if(!(n == 0ul) && !(size == 0ul))
  {
    if(18446744073709551615ul / size >= n)
      ptr=calloc(n, size);

    if(ptr == NULL)
    {
      *p = (void *)0;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 12;
      fsd_exc_raise_sys(*return_value___errno_location_1);
    }

  }

  *p = ptr;
  return ptr;
}

// fsd_calloc_noraise_
// file xmalloc.c line 148
signed int fsd_calloc_noraise_(void **p, unsigned long int n, unsigned long int size)
{
  signed int result = 0;
  void *ptr = (void *)0;
  if(!(n == 0ul) && !(size == 0ul))
  {
    if(18446744073709551615ul / size >= n)
      ptr=calloc(n, size);

    if(ptr == NULL)
      result = 12;

  }

  *p = ptr;
  return result;
}

// fsd_color
// file logging.c line 77
void fsd_color(char *output, unsigned long int len, signed int n)
{
  unsigned int k = (unsigned int)n;
  k=hashword(&k, (unsigned long int)1, (unsigned int)0);
  k = k % (unsigned int)12;
  snprintf(output, len, "\033[0;%d;%dm", k >= (unsigned int)6, (unsigned int)31 + k % (unsigned int)6);
}

// fsd_cond_broadcast
// file ../drmaa_utils/thread.h line 96
void fsd_cond_broadcast(union anonymous_2 *cond)
{
  signed int errno_ = 0;
  errno_=pthread_cond_broadcast(cond);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_cond_destroy
// file ../drmaa_utils/thread.h line 94
void fsd_cond_destroy(union anonymous_2 *cond)
{
  signed int errno_ = 0;
  errno_=pthread_cond_destroy(cond);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_cond_init
// file ../drmaa_utils/thread.h line 93
void fsd_cond_init(union anonymous_2 *cond)
{
  signed int errno_ = 0;
  errno_=pthread_cond_init(cond, (const union anonymous_9 *)(void *)0);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_cond_signal
// file thread.c line 182
void fsd_cond_signal(union anonymous_2 *cond)
{
  signed int errno_ = 0;
  errno_=pthread_cond_signal(cond);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_cond_timedwait
// file thread.c line 209
_Bool fsd_cond_timedwait(union anonymous_2 *cond, union anonymous_1 *mutex, struct timespec *abstime)
{
  signed int errno_ = 0;
  errno_=pthread_cond_timedwait(cond, mutex, abstime);
  switch(errno_)
  {
    case 0:
      return (_Bool)1;
    case 110:
      return (_Bool)0;
    default:
      fsd_exc_raise_sys(errno_);
  }
}

// fsd_cond_wait
// file thread.c line 200
void fsd_cond_wait(union anonymous_2 *cond, union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  errno_=pthread_cond_wait(cond, mutex);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_conf_dict_create
// file conf.c line 402
struct fsd_conf_dict_s * fsd_conf_dict_create(void)
{
  struct fsd_conf_dict_s *dict = (struct fsd_conf_dict_s *)(void *)0;
  fsd_malloc_((void **)(void *)&dict, sizeof(struct fsd_conf_dict_s) /*24ul*/ );
  dict->next = (struct fsd_conf_dict_s *)(void *)0;
  dict->key = (char *)(void *)0;
  dict->value = (struct fsd_conf_option_s *)(void *)0;
  return dict;
}

// fsd_conf_dict_create_noraise
// file conf.c line 556
struct fsd_conf_dict_s * fsd_conf_dict_create_noraise(void)
{
  struct fsd_conf_dict_s * volatile result = (struct fsd_conf_dict_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_conf_dict_create_noraise", 559);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      result=fsd_conf_dict_create();
      goto __CPROVER_DUMP_L6;
    }

    if(_fsd_exc_rc >= 1)
      _fsd_exc_handled = (_Bool)1;


  __CPROVER_DUMP_L6:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L7:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_conf_dict_destroy
// file conf.c line 414
void fsd_conf_dict_destroy(struct fsd_conf_dict_s *dict)
{
  struct fsd_conf_dict_s *i = dict;
  while(!(i == ((struct fsd_conf_dict_s *)NULL)))
  {
    struct fsd_conf_dict_s *c = i;
    i = i->next;
    fsd_free((void *)c->key);
    fsd_conf_option_destroy(c->value);
    fsd_free((void *)c);
  }
}

// fsd_conf_dict_dump
// file conf.c line 524
void fsd_conf_dict_dump(struct fsd_conf_dict_s *dict)
{
  struct fsd_conf_dict_s *i;
  if(dict == ((struct fsd_conf_dict_s *)NULL))
    printf("(null)");

  else
  {
    printf("{");
    i = dict->next;
    for( ; !(i == ((struct fsd_conf_dict_s *)NULL)); i = i->next)
    {
      if(!(i == dict->next))
        printf(",");

      printf(" %s=", i->key);
      fsd_conf_option_dump(i->value);
    }
    printf(" }");
  }
}

// fsd_conf_dict_get
// file conf.c line 429
struct fsd_conf_option_s * fsd_conf_dict_get(struct fsd_conf_dict_s *dict, const char *key)
{
  struct fsd_conf_dict_s *i;
  if(key == ((const char *)NULL) || dict == ((struct fsd_conf_dict_s *)NULL))
    return (struct fsd_conf_option_s *)(void *)0;

  else
  {
    i = dict->next;
    for( ; !(i == ((struct fsd_conf_dict_s *)NULL)); i = i->next)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(i->key, key);
      if(return_value_strcmp_1 == 0)
        return i->value;

    }
    return (struct fsd_conf_option_s *)(void *)0;
  }
}

// fsd_conf_dict_merge
// file conf.c line 486
struct fsd_conf_dict_s * fsd_conf_dict_merge(struct fsd_conf_dict_s *lhs, struct fsd_conf_dict_s *rhs)
{
  struct fsd_conf_dict_s *i;
  struct fsd_conf_dict_s *j;
  signed int return_value_strcmp_1;
  if(lhs == ((struct fsd_conf_dict_s *)NULL))
    return rhs;

  else
    if(rhs == ((struct fsd_conf_dict_s *)NULL))
      return lhs;

    else
    {
      j = rhs->next;
      while(!(j == ((struct fsd_conf_dict_s *)NULL)))
      {
        struct fsd_conf_dict_s *r = j;
        j = j->next;
        i = lhs->next;
        for( ; !(i == ((struct fsd_conf_dict_s *)NULL)); i = i->next)
        {
          return_value_strcmp_1=strcmp(i->key, r->key);
          if(return_value_strcmp_1 == 0)
            break;

        }
        if(!(i == ((struct fsd_conf_dict_s *)NULL)))
        {
          i->value=fsd_conf_option_merge(i->value, r->value);
          fsd_free((void *)r->key);
          fsd_free((void *)r);
        }

        else
        {
          r->next = lhs->next;
          lhs->next = r;
        }
      }
      fsd_free((void *)rhs);
      return lhs;
    }
}

// fsd_conf_dict_set
// file conf.c line 445
void fsd_conf_dict_set(struct fsd_conf_dict_s *dict, const char *key, struct fsd_conf_option_s *value)
{
  struct fsd_conf_dict_s *i = dict->next;
  for( ; !(i == ((struct fsd_conf_dict_s *)NULL)); i = i->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(i->key, key);
    if(return_value_strcmp_1 == 0)
      break;

  }
  if(!(i == ((struct fsd_conf_dict_s *)NULL)))
  {
    fsd_conf_option_destroy(i->value);
    i->value = value;
  }

  else
  {
    struct fsd_conf_dict_s * volatile n = (struct fsd_conf_dict_s *)(void *)0;
    struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
    signed int _fsd_exc_rc;
    _fsd_exc_try_block=fsd_exc_try("fsd_conf_dict_set", 464);
    if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
      _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

    else
      _fsd_exc_rc = -3;
    while((_Bool)1)
    {
      _Bool _fsd_exc_handled = (_Bool)0;
      fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
      if(_fsd_exc_rc == -3)
        break;

      if(!(_fsd_exc_rc == 0))
      {
        if(_fsd_exc_rc == -1)
          goto __CPROVER_DUMP_L10;

      }

      else
      {
        fsd_malloc_((void **)(void *)&n, sizeof(struct fsd_conf_dict_s) /*24ul*/ );
        n->key=fsd_strdup(key);
        n->value = value;
        goto __CPROVER_DUMP_L11;
      }
      if(_fsd_exc_rc >= 1)
      {
        _fsd_exc_handled = (_Bool)1;
        fsd_free((void *)n);
        fsd_exc_reraise();
      }

      goto __CPROVER_DUMP_L11;

    __CPROVER_DUMP_L10:
      ;
      n->next = dict->next;
      dict->next = n;

    __CPROVER_DUMP_L11:
      ;
      if(!(_fsd_exc_handled == (_Bool)0))
      {

      __CPROVER_DUMP_L12:
        ;
        _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
        _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
      }

    }
  }
}

// fsd_conf_dict_set_noraise
// file conf.c line 566
signed int fsd_conf_dict_set_noraise(struct fsd_conf_dict_s *dict, const char *key, struct fsd_conf_option_s *value)
{
  volatile signed int rc = 0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_conf_dict_set_noraise", 570);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_conf_dict_set(dict, key, value);
      goto __CPROVER_DUMP_L6;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      const struct fsd_exc_s *e;
      e=fsd_exc_get();
      rc=e->code(e);
    }


  __CPROVER_DUMP_L6:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L7:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return rc;
}

// fsd_conf_error
// file conf.c line 275
void fsd_conf_error(struct YYLTYPE *locp, struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer, const char *fmt, ...)
{
  char * volatile message = (char *)(void *)0;
  void **args;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_conf_error", 284);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_asprintf_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        args = (void **)&fmt;
        message=fsd_vasprintf(fmt, args);
        args = ((void **)NULL);
        fsd_realloc_((void **)(void *)&parser->errors, (unsigned long int)(parser->n_errors + 1) * sizeof(char *) /*8ul*/ );
        parser->errors[(signed long int)parser->n_errors]=fsd_asprintf("%s:%d:%d: %s", parser->lexer->filename, locp->first_line, locp->first_column, message);
        do
          if(!((signed int)fsd_verbose_level >= 6))
          {
            return_value_fsd_asprintf_1=fsd_asprintf("Parser error: %s:%d:%d: %s", parser->lexer->filename, locp->first_line, locp->first_column, message);
            _fsd_log(FSD_LOG_ERROR, "conf.c", "fsd_conf_error", 0, return_value_fsd_asprintf_1);
          }

        while((_Bool)0);
        parser->n_errors = parser->n_errors + 1;
        break;
      }
      case -2:
        fsd_free((void *)message);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L9:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_conf_lex
// file conf.c line 164
signed int fsd_conf_lex(union YYSTYPE_0 *lvalp, struct YYLTYPE *locp, struct fsd_conf_lexer_s *lexer)
{
  const unsigned char *c = lexer->pos;
  const unsigned char *end = lexer->buffer + (signed long int)lexer->buflen;
  const char *error = (const char *)(void *)0;
  signed int result;
  while(!(c >= end))
    switch((signed int)*c)
    {
      case 35:
        for( ; !(c >= end); c = c + 1l)
          if((signed int)*c == 10)
            break;

      case 10:
      {
        lexer->lineno = lexer->lineno + 1;
        lexer->cline = c + (signed long int)1;
      }
      case 32:

      case 9:

      case 13:
      {
        c = c + 1l;
        break;
      }
      default:
        goto token_begin;
    }

token_begin:
  ;
  locp->first_line = lexer->lineno;
  locp->first_column = (signed int)((c - lexer->cline) + (signed long int)1);
  const unsigned char *tmp_post_1;
  signed int v;
  unsigned char delimiter;
  const unsigned char *begin;
  const unsigned char *tmp_post_2;
  const unsigned char *fsd_conf_lex__1__2__3__begin;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(c == end)
    result = 0;

  else
    switch((signed int)*c)
    {
      case 58:

      case 44:

      case 123:

      case 125:
      {
        tmp_post_1 = c;
        c = c + 1l;
        result = (signed int)*tmp_post_1;
        break;
      }
      case 48:

      case 49:

      case 50:

      case 51:

      case 52:

      case 53:

      case 54:

      case 55:

      case 56:

      case 57:
      {
        v = 0;
        for( ; !(c >= end); c = c + 1l)
        {
          if(!((signed int)*c >= 48))
            break;

          if((signed int)*c >= 58)
            break;

          v = v * 10;
          v = v + ((signed int)*c - 48);
        }
        lvalp->integer = v;
        result = 258;
        break;
      }
      case 34:

      case 39:
      {
        tmp_post_2 = c;
        c = c + 1l;
        delimiter = *tmp_post_2;
        begin = c;
        for( ; !(c >= end); c = c + 1l)
          if(*c == delimiter)
            break;

        if(c == end)
        {
          error = "expected string delimiter but EOF found";
          result = 260;
        }

        else
        {
          lvalp->string=fsd_strndup((const char *)begin, (unsigned long int)(c - begin));
          result = 259;
          c = c + 1l;
        }
        break;
      }
      default:
      {
        fsd_conf_lex__1__2__3__begin = c;
        for( ; !(c >= end); c = c + 1l)
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*c]) == 0))
            break;

          if((signed int)*c == 44 || (signed int)*c == 58 || (signed int)*c == 123 || (signed int)*c == 125)
            break;

        }

      end_of_string:
        ;
        lvalp->string=fsd_strndup((const char *)fsd_conf_lex__1__2__3__begin, (unsigned long int)(c - fsd_conf_lex__1__2__3__begin));
        result = 259;
      }
    }
  locp->last_line = lexer->lineno;
  locp->last_column = (signed int)(c - lexer->cline);
  if(!(locp->last_column >= locp->first_column))
    locp->last_column = locp->first_column;

  lexer->pos = c;
  if(!(error == ((const char *)NULL)))
    fsd_conf_error(locp, lexer->parser, lexer, error);

  return result;
}

// fsd_conf_option_create
// file conf.c line 306
struct fsd_conf_option_s * fsd_conf_option_create(enum anonymous_4 type, void *value)
{
  struct fsd_conf_option_s *o = (struct fsd_conf_option_s *)(void *)0;
  fsd_malloc_((void **)(void *)&o, sizeof(struct fsd_conf_option_s) /*16ul*/ );
  o->type = type;
  switch((signed int)type)
  {
    case FSD_CONF_INTEGER:
    {
      o->val.integer = *((signed int *)value);
      break;
    }
    case FSD_CONF_STRING:
    {
      o->val.string = (char *)value;
      break;
    }
    case FSD_CONF_DICT:
    {
      o->val.dict = (struct fsd_conf_dict_s *)value;
      break;
    }
    default:

      __CPROVER_DUMP_L4:
        ;
  }
  return o;
}

// fsd_conf_option_create_noraise
// file conf.c line 546
struct fsd_conf_option_s * fsd_conf_option_create_noraise(enum anonymous_4 type, void *value)
{
  struct fsd_conf_option_s * volatile result = (struct fsd_conf_option_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_conf_option_create_noraise", 549);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      result=fsd_conf_option_create(type, value);
      goto __CPROVER_DUMP_L6;
    }

    if(_fsd_exc_rc >= 1)
      _fsd_exc_handled = (_Bool)1;


  __CPROVER_DUMP_L6:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L7:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_conf_option_destroy
// file conf.c line 332
void fsd_conf_option_destroy(struct fsd_conf_option_s *option)
{
  if(!(option == ((struct fsd_conf_option_s *)NULL)))
  {
    switch((signed int)option->type)
    {
      case FSD_CONF_INTEGER:
        break;
      case FSD_CONF_STRING:
      {
        fsd_free((void *)option->val.string);
        break;
      }
      case FSD_CONF_DICT:
      {
        fsd_conf_dict_destroy(option->val.dict);
        break;
      }
      default:

        __CPROVER_DUMP_L4:
          ;
    }
    fsd_free((void *)option);
  }

}

// fsd_conf_option_dump
// file conf.c line 371
void fsd_conf_option_dump(struct fsd_conf_option_s *option)
{
  if(option == ((struct fsd_conf_option_s *)NULL))
    printf("(null)");

  else
    switch((signed int)option->type)
    {
      case FSD_CONF_STRING:
      {
        printf("\"%s\"", option->val.string);
        break;
      }
      case FSD_CONF_INTEGER:
      {
        printf("%d", option->val.integer);
        break;
      }
      case FSD_CONF_DICT:
        fsd_conf_dict_dump(option->val.dict);
    }
}

// fsd_conf_option_merge
// file conf.c line 354
struct fsd_conf_option_s * fsd_conf_option_merge(struct fsd_conf_option_s *lhs, struct fsd_conf_option_s *rhs)
{
  _Bool tmp_if_expr_1;
  if(lhs->type == rhs->type)
    tmp_if_expr_1 = (signed int)rhs->type == FSD_CONF_DICT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    lhs->val.dict=fsd_conf_dict_merge(lhs->val.dict, rhs->val.dict);
    fsd_free((void *)rhs);
    return lhs;
  }

  else
  {
    fsd_conf_option_destroy(lhs);
    return rhs;
  }
}

// fsd_conf_parse
// file ../drmaa_utils/conf_impl.h line 37
signed int fsd_conf_parse(struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer)
{
  signed int fsd_conf_char;
  union YYSTYPE_0 fsd_conf_lval;
  struct YYLTYPE fsd_conf_lloc;
  signed int fsd_conf_nerrs;
  signed int yystate;
  signed int yyerrstatus;
  signed short int yyssa[200l];
  signed short int *yyss;
  signed short int *yyssp;
  union YYSTYPE_0 yyvsa[200l];
  union YYSTYPE_0 *yyvs;
  union YYSTYPE_0 *yyvsp;
  struct YYLTYPE yylsa[200l];
  struct YYLTYPE *yyls;
  struct YYLTYPE *yylsp;
  struct YYLTYPE yyerror_range[2l];
  unsigned long int yystacksize;
  signed int yyn;
  signed int yyresult;
  signed int yytoken;
  union YYSTYPE_0 yyval;
  struct YYLTYPE yyloc;
  signed int yylen = 0;
  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yyls = yylsa;
  yystacksize = (unsigned long int)200;
  yystate = 0;
  yyerrstatus = 0;
  fsd_conf_nerrs = 0;
  fsd_conf_char = -2;
  yyssp = yyss;
  yyvsp = yyvs;
  yylsp = yyls;
  fsd_conf_lloc.last_line = 1;
  fsd_conf_lloc.first_line = fsd_conf_lloc.last_line;
  fsd_conf_lloc.last_column = 1;
  fsd_conf_lloc.first_column = fsd_conf_lloc.last_column;
  goto yysetstate;

yynewstate:
  ;
  yyssp = yyssp + 1l;

yysetstate:
  ;
  *yyssp = (signed short int)yystate;
  if(yyssp >= yyss + (signed long int)yystacksize + -1l)
  {
    unsigned long int yysize = (unsigned long int)((yyssp - yyss) + (signed long int)1);
    if(yystacksize >= 10000ul)
      goto yyexhaustedlab;

    yystacksize = yystacksize * (unsigned long int)2;
    if(yystacksize >= 10001ul)
      yystacksize = (unsigned long int)10000;

    signed short int *yyss1 = yyss;
    union yyalloc *yyptr;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(yystacksize * (sizeof(signed short int) /*2ul*/  + sizeof(union YYSTYPE_0) /*16ul*/  + sizeof(struct YYLTYPE) /*16ul*/ ) + (unsigned long int)2 * (sizeof(union yyalloc) /*16ul*/  - (unsigned long int)1));
    yyptr = (union yyalloc *)return_value_malloc_1;
    if(yyptr == ((union yyalloc *)NULL))
      goto yyexhaustedlab;

    do
    {
      unsigned long int fsd_conf_parse__1__1__1__1__yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyss_alloc, (const void *)yyss, yysize * sizeof(signed short int) /*2ul*/ );
      yyss = &yyptr->yyss_alloc;
      fsd_conf_parse__1__1__1__1__yynewbytes = yystacksize * sizeof(signed short int) /*2ul*/  + (sizeof(union yyalloc) /*16ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(fsd_conf_parse__1__1__1__1__yynewbytes / sizeof(union yyalloc) /*16ul*/ );
    }
    while((_Bool)0);
    do
    {
      unsigned long int yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyvs_alloc, (const void *)yyvs, yysize * sizeof(union YYSTYPE_0) /*16ul*/ );
      yyvs = &yyptr->yyvs_alloc;
      yynewbytes = yystacksize * sizeof(union YYSTYPE_0) /*16ul*/  + (sizeof(union yyalloc) /*16ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(yynewbytes / sizeof(union yyalloc) /*16ul*/ );
    }
    while((_Bool)0);
    do
    {
      unsigned long int fsd_conf_parse__1__1__1__3__yynewbytes;
      __builtin_memcpy((void *)&yyptr->yyls_alloc, (const void *)yyls, yysize * sizeof(struct YYLTYPE) /*16ul*/ );
      yyls = &yyptr->yyls_alloc;
      fsd_conf_parse__1__1__1__3__yynewbytes = yystacksize * sizeof(struct YYLTYPE) /*16ul*/  + (sizeof(union yyalloc) /*16ul*/  - (unsigned long int)1);
      yyptr = yyptr + (signed long int)(fsd_conf_parse__1__1__1__3__yynewbytes / sizeof(union yyalloc) /*16ul*/ );
    }
    while((_Bool)0);
    if(!(yyss1 == yyssa))
      free((void *)yyss1);

    yyssp = (yyss + (signed long int)yysize) - (signed long int)1;
    yyvsp = (yyvs + (signed long int)yysize) - (signed long int)1;
    yylsp = (yyls + (signed long int)yysize) - (signed long int)1;
    if(yyssp >= yyss + (signed long int)yystacksize + -1l)
      goto yyabortlab;

  }

  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(yystate == 11))
  {

  yybackup:
    ;
    yyn = (signed int)yypact[(signed long int)yystate];
    if(!(yyn == -5))
    {
      if(fsd_conf_char == -2)
        fsd_conf_char=fsd_conf_lex(&fsd_conf_lval, &fsd_conf_lloc, lexer);

      if(!(fsd_conf_char >= 1))
      {
        yytoken = 0;
        fsd_conf_char = yytoken;
      }

      else
      {
        if(!((unsigned int)fsd_conf_char >= 261u))
          tmp_if_expr_2 = (signed int)yytranslate[(signed long int)fsd_conf_char];

        else
          tmp_if_expr_2 = 2;
        yytoken = tmp_if_expr_2;
      }
      yyn = yyn + yytoken;
      if(yyn >= 18 || !(yyn >= 0))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)yycheck[(signed long int)yyn] != yytoken ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_3)
      {
        yyn = (signed int)yytable[(signed long int)yyn];
        if(!(yyn >= 1))
        {
          if(yyn == 0 || yyn == -1)
            goto yyerrlab;

          yyn = -yyn;
          goto yyreduce;
        }

        if(!(yyerrstatus == 0))
          yyerrstatus = yyerrstatus - 1;

        fsd_conf_char = -2;
        yystate = yyn;
        yyvsp = yyvsp + 1l;
        *yyvsp = fsd_conf_lval;
        yylsp = yylsp + 1l;
        *yylsp = fsd_conf_lloc;
        goto yynewstate;
      }

    }


  yydefault:
    ;
    yyn = (signed int)yydefact[(signed long int)yystate];
    if(!(yyn == 0))
    {

    yyreduce:
      ;
      yylen = (signed int)yyr2[(signed long int)yyn];
      yyval = yyvsp[(signed long int)(1 - yylen)];
      do
        if(!(yylen == 0))
        {
          yyloc.first_line = ((yylsp - (signed long int)yylen) + (signed long int)1)->first_line;
          yyloc.first_column = ((yylsp - (signed long int)yylen) + (signed long int)1)->first_column;
          yyloc.last_line = ((yylsp - (signed long int)yylen) + (signed long int)yylen)->last_line;
          yyloc.last_column = ((yylsp - (signed long int)yylen) + (signed long int)yylen)->last_column;
        }

        else
        {
          yyloc.last_line = ((yylsp - (signed long int)yylen) + (signed long int)0)->last_line;
          yyloc.first_line = yyloc.last_line;
          yyloc.last_column = ((yylsp - (signed long int)yylen) + (signed long int)0)->last_column;
          yyloc.first_column = yyloc.last_column;
        }
      while((_Bool)0);
      switch(yyn)
      {
        case 2:
        {
          parser->result = (yyvsp + (signed long int)(1 - 1))->dictionary;
          yyval.dictionary = (struct fsd_conf_dict_s *)(void *)0;
          break;
        }
        case 5:
        {
          yyval.dictionary = (yyvsp + (signed long int)(2 - 3))->dictionary;
          break;
        }
        case 6:
        {
          yyval.dictionary = (yyvsp + (signed long int)(1 - 1))->dictionary;
          break;
        }
        case 7:
        {
          yyval.dictionary = (yyvsp + (signed long int)(1 - 2))->dictionary;
          break;
        }
        case 8:
        {
          yyval.dictionary=fsd_conf_dict_create_noraise();
          if(yyval.dictionary == ((struct fsd_conf_dict_s *)NULL))
            goto yyabortlab;

          break;
        }
        case 9:
        {
          struct fsd_conf_dict_s *dict = (struct fsd_conf_dict_s *)(void *)0;
          signed int rc;
          dict=fsd_conf_dict_create_noraise();
          if(dict == ((struct fsd_conf_dict_s *)NULL))
            goto yyabortlab;

          rc=fsd_conf_dict_set_noraise(dict, (yyvsp + (signed long int)(1 - 1))->pair.key, (yyvsp + (signed long int)(1 - 1))->pair.value);
          if(!(rc == 0))
          {
            fsd_conf_dict_destroy(dict);
            goto yyabortlab;
          }

          yyval.dictionary = dict;
          break;
        }
        case 10:
        {
          signed int fsd_conf_parse__1__8__7__rc;
          fsd_conf_parse__1__8__7__rc=fsd_conf_dict_set_noraise((yyvsp + (signed long int)(1 - 3))->dictionary, (yyvsp + (signed long int)(3 - 3))->pair.key, (yyvsp + (signed long int)(3 - 3))->pair.value);
          if(!(fsd_conf_parse__1__8__7__rc == 0))
            goto yyabortlab;

          yyval.dictionary = (yyvsp + (signed long int)(1 - 3))->dictionary;
          break;
        }
        case 11:
        {
          yyval.pair.key = (yyvsp + (signed long int)(1 - 3))->string;
          yyval.pair.value = (yyvsp + (signed long int)(3 - 3))->option;
          break;
        }
        case 12:
        {
          struct fsd_conf_option_s *o;
          o=fsd_conf_option_create_noraise((enum anonymous_4)FSD_CONF_INTEGER, (void *)&(yyvsp + (signed long int)(1 - 1))->integer);
          if(!(o == ((struct fsd_conf_option_s *)NULL)))
            yyval.option = o;

          else
            goto yyabortlab;
          break;
        }
        case 13:
        {
          struct fsd_conf_option_s *fsd_conf_parse__1__8__10__o;
          fsd_conf_parse__1__8__10__o=fsd_conf_option_create_noraise((enum anonymous_4)FSD_CONF_STRING, (void *)(yyvsp + (signed long int)(1 - 1))->string);
          if(!(fsd_conf_parse__1__8__10__o == ((struct fsd_conf_option_s *)NULL)))
            yyval.option = fsd_conf_parse__1__8__10__o;

          else
            goto yyabortlab;
          break;
        }
        case 14:
        {
          struct fsd_conf_option_s *fsd_conf_parse__1__8__11__o;
          fsd_conf_parse__1__8__11__o=fsd_conf_option_create_noraise((enum anonymous_4)FSD_CONF_DICT, (void *)(yyvsp + (signed long int)(1 - 1))->dictionary);
          if(!(fsd_conf_parse__1__8__11__o == ((struct fsd_conf_option_s *)NULL)))
            yyval.option = fsd_conf_parse__1__8__11__o;

          else
            goto yyabortlab;
        }
      }
      yyvsp = yyvsp - (signed long int)yylen;
      yyssp = yyssp - (signed long int)yylen;
      yylsp = yylsp - (signed long int)yylen;
      yylen = 0;
      yyvsp = yyvsp + 1l;
      *yyvsp = yyval;
      yylsp = yylsp + 1l;
      *yylsp = yyloc;
      yyn = (signed int)yyr1[(signed long int)yyn];
      yystate = (signed int)yypgoto[(signed long int)(yyn - 10)] + (signed int)*yyssp;
      if(yystate >= 0 && !(yystate >= 18))
        tmp_if_expr_4 = (signed int)yycheck[(signed long int)yystate] == (signed int)*yyssp ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        yystate = (signed int)yytable[(signed long int)yystate];

      else
        yystate = (signed int)yydefgoto[(signed long int)(yyn - 10)];
      goto yynewstate;
    }


  yyerrlab:
    ;
    if(yyerrstatus == 0)
    {
      fsd_conf_nerrs = fsd_conf_nerrs + 1;
      fsd_conf_error(&fsd_conf_lloc, parser, lexer, "syntax error");
    }

    yyerror_range[(signed long int)0] = fsd_conf_lloc;
    if(yyerrstatus == 3)
    {
      if(!(fsd_conf_char >= 1))
      {
        if(fsd_conf_char == 0)
          goto yyabortlab;

      }

      else
      {
        yydestruct("Error: discarding", yytoken, &fsd_conf_lval, &fsd_conf_lloc, parser, lexer);
        fsd_conf_char = -2;
      }
    }

    goto yyerrlab1;

  yyerrorlab:
    ;
    yyerror_range[(signed long int)0] = yylsp[(signed long int)(1 - yylen)];
    yyvsp = yyvsp - (signed long int)yylen;
    yyssp = yyssp - (signed long int)yylen;
    yylsp = yylsp - (signed long int)yylen;
    yylen = 0;
    yystate = (signed int)*yyssp;

  yyerrlab1:
    ;
    yyerrstatus = 3;
    do
    {
      yyn = (signed int)yypact[(signed long int)yystate];
      if(!(yyn == -5))
      {
        yyn = yyn + 1;
        if(yyn >= 0 && !(yyn >= 18))
        {
          if((signed int)yycheck[(signed long int)yyn] == 1)
          {
            yyn = (signed int)yytable[(signed long int)yyn];
            if(yyn >= 1)
              break;

          }

        }

      }

      if(yyssp == yyss)
        goto yyabortlab;

      yyerror_range[(signed long int)0] = *yylsp;
      yydestruct("Error: popping", (signed int)yystos[(signed long int)yystate], yyvsp, yylsp, parser, lexer);
      yyvsp = yyvsp - (signed long int)1;
      yyssp = yyssp - (signed long int)1;
      yylsp = yylsp - (signed long int)1;
      yystate = (signed int)*yyssp;
    }
    while((_Bool)1);
    yyvsp = yyvsp + 1l;
    *yyvsp = fsd_conf_lval;
    yyerror_range[(signed long int)1] = fsd_conf_lloc;
    do
    {
      yyloc.first_line = ((yyerror_range - (signed long int)1) + (signed long int)1)->first_line;
      yyloc.first_column = ((yyerror_range - (signed long int)1) + (signed long int)1)->first_column;
      yyloc.last_line = ((yyerror_range - (signed long int)1) + (signed long int)2)->last_line;
      yyloc.last_column = ((yyerror_range - (signed long int)1) + (signed long int)2)->last_column;
    }
    while((_Bool)0);
    yylsp = yylsp + 1l;
    *yylsp = yyloc;
    yystate = yyn;
    goto yynewstate;
  }


yyacceptlab:
  ;
  yyresult = 0;
  goto yyreturn;

yyabortlab:
  ;
  yyresult = 1;
  goto yyreturn;

yyexhaustedlab:
  ;
  fsd_conf_error(&fsd_conf_lloc, parser, lexer, "memory exhausted");
  yyresult = 2;

yyreturn:
  ;
  if(!(fsd_conf_char == -2))
    yydestruct("Cleanup: discarding lookahead", yytoken, &fsd_conf_lval, &fsd_conf_lloc, parser, lexer);

  yyvsp = yyvsp - (signed long int)yylen;
  yyssp = yyssp - (signed long int)yylen;
  yylsp = yylsp - (signed long int)yylen;
  for( ; !(yyssp == yyss); yylsp = yylsp - (signed long int)1)
  {
    yydestruct("Cleanup: popping", (signed int)yystos[(signed long int)*yyssp], yyvsp, yylsp, parser, lexer);
    yyvsp = yyvsp - (signed long int)1;
    yyssp = yyssp - (signed long int)1;
  }
  if(!(yyss == yyssa))
    free((void *)yyss);

  return yyresult;
}

// fsd_conf_read
// file conf.c line 44
struct fsd_conf_dict_s * fsd_conf_read(struct fsd_conf_dict_s * volatile configuration, const char *filename, _Bool must_exist, const char *content, unsigned long int content_len)
{
  struct fsd_conf_dict_s * volatile result = (struct fsd_conf_dict_s *)(void *)0;
  struct fsd_conf_parser_s *parser = (struct fsd_conf_parser_s *)(void *)0;
  struct fsd_conf_lexer_s *lexer = (struct fsd_conf_lexer_s *)(void *)0;
  char *file_content = (char *)(void *)0;
  unsigned long int file_content_len = (unsigned long int)0;

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_conf_read", 61);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  signed int return_value;
  const char *return_value_1;
  const char *return_value_2;
  char *return_value_fsd_asprintf_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        fsd_malloc_((void **)(void *)&parser, sizeof(struct fsd_conf_parser_s) /*32ul*/ );
        fsd_malloc_((void **)(void *)&lexer, sizeof(struct fsd_conf_lexer_s) /*56ul*/ );
        parser->lexer = lexer;
        parser->result = (struct fsd_conf_dict_s *)(void *)0;
        parser->n_errors = 0;
        parser->errors = (char **)(void *)0;
        lexer->parser = parser;
        lexer->filename = filename;
        lexer->buffer = (const unsigned char *)(void *)0;
        lexer->buflen = (unsigned long int)0;
        lexer->pos = (const unsigned char *)(void *)0;
        lexer->lineno = 0;
        lexer->cline = (const unsigned char *)(void *)0;
        if(!(filename == ((const char *)NULL)))
        {
          struct fsd_exc_try_block_s * volatile fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
          signed int fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc;
          fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block=fsd_exc_try("fsd_conf_read", 80);
          if(!(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
            fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc=_setjmp(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block->env);

          else
            fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc = -3;
          while((_Bool)1)
          {
            _Bool fsd_conf_read__1__2__1__1__1__1__1__1___fsd_exc_handled = (_Bool)0;
            fsd_exc_control(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block, &fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc);
            if(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc == -3)
              break;

            if(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc == 0)
            {
              fsd_read_file(filename, must_exist, &file_content, &file_content_len);
              goto __CPROVER_DUMP_L14;
            }

            if(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_rc >= 1)
            {
              fsd_conf_read__1__2__1__1__1__1__1__1___fsd_exc_handled = (_Bool)1;
              const struct fsd_exc_s *e;
              e=fsd_exc_get();
              if(!(must_exist == (_Bool)0))
              {
                return_value=e->code(e);
                return_value_1=e->message(e);
                fsd_exc_raise_fmt(return_value, "%s: %s", filename, return_value_1);
              }

              else
                do
                  if(!((signed int)fsd_verbose_level >= 5))
                  {
                    return_value_2=e->message(e);
                    return_value_fsd_asprintf_1=fsd_asprintf("%s: %s", filename, return_value_2);
                    _fsd_log(FSD_LOG_WARNING, "conf.c", "fsd_conf_read", 0, return_value_fsd_asprintf_1);
                  }

                while((_Bool)0);
            }


          __CPROVER_DUMP_L14:
            ;
            if(!(fsd_conf_read__1__2__1__1__1__1__1__1___fsd_exc_handled == (_Bool)0))
            {

            __CPROVER_DUMP_L15:
              ;
              fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block->handled_exc->destroy(fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block->handled_exc);
              fsd_conf_read__1__2__1__1__1__1__1___fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
            }

          }
        }

        if(!(file_content == ((char *)NULL)))
        {
          lexer->buffer = (const unsigned char *)file_content;
          lexer->buflen = file_content_len;
        }

        else
          if(!(content == ((const char *)NULL)))
          {
            lexer->buffer = (const unsigned char *)content;
            lexer->buflen = content_len;
          }


      __CPROVER_DUMP_L19:
        ;

      __CPROVER_DUMP_L21:
        ;
        if(!(lexer->buffer == ((const unsigned char *)NULL)))
        {
          lexer->cline = lexer->buffer;
          lexer->pos = lexer->cline;
          lexer->lineno = 1;
          fsd_conf_parse(parser, lexer);
          result = parser->result;
        }

        if(parser->n_errors >= 1)
        {
          char *return_value_fsd_explode_2;
          return_value_fsd_explode_2=fsd_explode((const char * const *)parser->errors, (char)10, parser->n_errors);
          struct fsd_exc_s *return_value_fsd_exc_new_3;
          return_value_fsd_exc_new_3=fsd_exc_new(1001, return_value_fsd_explode_2, (_Bool)1);
          fsd_exc_raise(return_value_fsd_exc_new_3);
        }

        break;
      }
      case -1:
      {
        configuration=fsd_conf_dict_merge(configuration, result);
        result = (struct fsd_conf_dict_s *)(void *)0;
        break;
      }
      case -2:
      {
        if(!(parser == ((struct fsd_conf_parser_s *)NULL)))
        {
          if(!(parser->errors == ((char **)NULL)))
          {
            signed int i = 0;
            for( ; !(i >= parser->n_errors); i = i + 1)
              fsd_free((void *)parser->errors[(signed long int)i]);
            fsd_free((void *)parser->errors);
          }

          fsd_free((void *)parser);
        }

        fsd_free((void *)lexer);
        fsd_free((void *)file_content);
        fsd_conf_dict_destroy(result);
      }
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L32:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L35:
  ;
  return configuration;
}

// fsd_copy_vector
// file ../drmaa_utils/util.h line 41
char ** fsd_copy_vector(const char * const *vector)
{
  unsigned int n_items;
  unsigned int i;
  char ** volatile buf = (char ** volatile )(void *)0;
  char ** volatile result = (char ** volatile )(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_copy_vector", 72);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        if(!(vector == ((const char * const *)NULL)))
        {
          n_items = (unsigned int)0;
          for( ; !(vector[(signed long int)n_items] == ((const char *)NULL)); n_items = n_items + 1u)
            ;
        }

        else
          n_items = (unsigned int)0;
        fsd_calloc_((void **)(void *)&buf, (unsigned long int)(n_items + (unsigned int)1), sizeof(char *) /*8ul*/ );
        i = (unsigned int)0;
        for( ; !(i >= n_items); i = i + 1u)
          buf[(signed long int)i]=fsd_strdup(vector[(signed long int)i]);
        break;
      }
      case -1:
      {
        result = buf;
        buf = (char ** volatile )(void *)0;
        break;
      }
      case -2:
        fsd_free_vector(buf);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L14:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_datetime_after
// file datetime.c line 201
signed long int fsd_datetime_after(struct fsd_datetime_s *dt, signed long int t)
{
  char dbg[256l];
  unsigned int unfilled = ~dt->mask;
  signed long int result;
  fsd_datetime_fill(dt, t);
  fsd_datetime_dump(dt, dbg, sizeof(char [256l]) /*256ul*/ );

__CPROVER_DUMP_L1:
  ;
  result=fsd_datetime_mktime(dt);
  if(!(result >= t))
  {
    if(!((4u & unfilled) == 0u))
      for( ; !(result >= t); result = result + (signed long int)(24 * 3600))

        __CPROVER_DUMP_L3:
          ;

    else
      if(!((2u & unfilled) == 0u))
        while(!(result >= t))
        {

        __CPROVER_DUMP_L7:
          ;
          dt->month = dt->month + 1;
          result=fsd_datetime_mktime(dt);
        }

      else
        if(!((1u & unfilled) == 0u))
          while(!(result >= t))
          {

          __CPROVER_DUMP_L11:
            ;
            dt->year = dt->year + 1;
            result=fsd_datetime_mktime(dt);
          }

        else
          fsd_exc_raise_fmt(1004, "'%s' is in the past", (const void *)dbg);
  }

  return result;
}

// fsd_datetime_dump
// file datetime.c line 39
void fsd_datetime_dump(const struct fsd_datetime_s *dt, char *s, unsigned long int len)
{
  char mask[8l] = { 'Y', 'M', 'D', 'h', 'm', 's', 'Z', 0 };
  char sign = (char)43;
  signed long int tz_delta = dt->tz_delta;
  unsigned int d_hour;
  unsigned int d_min;
  unsigned int d_sec;
  unsigned int m;
  if(!(tz_delta >= 0l))
  {
    tz_delta = -tz_delta;
    sign = (char)45;
  }

  d_sec = (unsigned int)(tz_delta % (signed long int)60);
  tz_delta = tz_delta / (signed long int)60;
  d_min = (unsigned int)(tz_delta % (signed long int)60);
  tz_delta = tz_delta / (signed long int)60;
  d_hour = (unsigned int)tz_delta;
  m = (unsigned int)0;
  for( ; !(m >= 7u); m = m + 1u)
    if((dt->mask & (unsigned int)(1 << m)) == 0u)
      mask[(signed long int)m] = (char)45;

  snprintf(s, len, "%04d-%02d-%02d %02d:%02d:%02d %c%02d:%02d:%02d [%s]", dt->year, dt->month, dt->day, dt->hour, dt->minute, dt->second, sign, d_hour, d_min, d_sec, (const void *)mask);
}

// fsd_datetime_fill
// file datetime.c line 99
void fsd_datetime_fill(struct fsd_datetime_s *dt, signed long int filler)
{
  unsigned int unfilled = ~dt->mask;
  struct tm t;
  if(!((64u & unfilled) == 0u))
  {
    localtime_r(&filler, &t);
    dt->tz_delta = t.tm_gmtoff;
  }

  else
  {
    filler = filler + dt->tz_delta;
    gmtime_r(&filler, &t);
  }
  if(!((1u & unfilled) == 0u))
    dt->year = t.tm_year + 1900;

  else
    if(!(dt->year >= 100))
      dt->year = dt->year + 100 * ((t.tm_year + 1900) / 100);

  if(!((2u & unfilled) == 0u))
    dt->month = t.tm_mon + 1;

  if(!((4u & unfilled) == 0u))
    dt->day = t.tm_mday;

  if(!((8u & unfilled) == 0u))
    dt->hour = t.tm_hour;

  if(!((16u & unfilled) == 0u))
    dt->minute = t.tm_min;

  if(!((32u & unfilled) == 0u))
    dt->second = 0;

  dt->mask = dt->mask | (unsigned int)127;
}

// fsd_datetime_mktime
// file datetime.c line 158
signed long int fsd_datetime_mktime(const struct fsd_datetime_s *dt)
{
  const unsigned int month_days[12l] = { (const unsigned int)0, (const unsigned int)31, (const unsigned int)59, (const unsigned int)90, (const unsigned int)120, (const unsigned int)151, (const unsigned int)181, (const unsigned int)212, (const unsigned int)243, (const unsigned int)273, (const unsigned int)304, (const unsigned int)334 };
  unsigned long int year;
  unsigned long int month;
  unsigned long int years;
  unsigned long int days;
  signed long int result;
  year = (unsigned long int)dt->year;
  month = (unsigned long int)dt->month;
  for( ; !(month >= 1ul); month = month + (unsigned long int)12)
    year = year - 1ul;
  for( ; month >= 13ul; month = month - (unsigned long int)12)
    year = year + 1ul;
  years = year - (unsigned long int)1970;
  days = (unsigned long int)365 * years + (years + (unsigned long int)1) / (unsigned long int)4;
  days = days + (unsigned long int)month_days[(signed long int)(month - (unsigned long int)1)];
  if((3ul & year) == 0ul && month >= 3ul)
    days = days + 1ul;

  days = days + (unsigned long int)(dt->day - 1);
  result = (signed long int)((((days * (unsigned long int)24 + (unsigned long int)dt->hour) * (unsigned long int)60 + (unsigned long int)dt->minute) * (unsigned long int)60 + (unsigned long int)dt->second) - (unsigned long int)dt->tz_delta);
  return result;
}

// fsd_datetime_parse
// file datetime.c line 250
signed long int fsd_datetime_parse(const char *string)
{
  struct fsd_dt_parser_s * volatile parser = (struct fsd_dt_parser_s *)(void *)0;
  struct fsd_dt_lexer_s * volatile lexer = (struct fsd_dt_lexer_s *)(void *)0;
  signed int parse_err = 0;
  struct fsd_datetime_s dt;
  signed long int result;

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_datetime_parse", 262);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  _Bool tmp_if_expr_2;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        fsd_malloc_((void **)(void *)&parser, sizeof(struct fsd_dt_parser_s) /*56ul*/ );
        fsd_malloc_((void **)(void *)&lexer, sizeof(struct fsd_dt_lexer_s) /*32ul*/ );
        parser->lexer = lexer;
        parser->n_errors = 0;
        lexer->parser = parser;
        lexer->p = (unsigned char *)string;
        lexer->begin = lexer->p;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(string);
        lexer->end = (unsigned char *)(string + (signed long int)return_value_strlen_1);
        parse_err=fsd_dt_parse(parser, lexer);
        if(!(parse_err == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = parser->n_errors != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          fsd_exc_raise_fmt(1005, "invalid date/time format: %s", string);

        dt = parser->result;
        signed long int return_value_time_3;
        return_value_time_3=time((signed long int *)(void *)0);
        result=fsd_datetime_after(&dt, return_value_time_3);
        break;
      }
      case -2:
      {
        fsd_free((void *)parser);
        fsd_free((void *)lexer);
      }
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L11:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L14:
  ;
  return result;
}

// fsd_drmaa_code
// file drmaa_util.c line 227
signed int fsd_drmaa_code(signed int fsd_errno)
{
  switch(fsd_errno)
  {
    case 0:
      return 0;
    case 1001:
      return 1;
    case 1002:
      return 6;
    case 1003:
      return 4;
    case 1004:
      return 14;
    case 1005:
      return 13;
    case 1006:
      return 25;
    case 1007:
      return 1;
    case 1008:
      return 5;
    case 1009:
      return 23;
    case 1010:
      return 3;
    case 1011:
      return 3;
    case 1012:
      return 16;
    case 1013:
      return 2;
    case 1014:
      return 10;
    case 1015:
      return 12;
    case 1016:
      return 17;
    case 1032:
      return 5;
    case 1033:
      return 7;
    case 1034:
      return 8;
    case 1035:
      return 9;
    case 1036:
      return 11;
    case 1037:
      return 13;
    case 1038:
      return 14;
    case 1039:
      return 15;
    case 1040:
      return 18;
    case 1041:
      return 19;
    case 1042:
      return 20;
    case 1043:
      return 21;
    case 1044:
      return 22;
    case 1045:
      return 23;
    case 1046:
      return 24;
    default:
      return 1;
  }
}

// fsd_drmaa_strerror
// file drmaa_util.c line 368
const char * fsd_drmaa_strerror(signed int drmaa_errno)
{
  switch(drmaa_errno)
  {
    case 0:
      return "Success.";
    case 1:
      return "Unexpected or internal DRMAA error.";
    case 2:
      return "Could not contact DRM system for this request.";
    case 3:
      return "Authorization failure.";
    case 4:
      return "Invalid argument value.";
    case 5:
      return "No active DRMAA session.";
    case 6:
      return "Not enough memory.";
    case 7:
      return "Invalid contact string.";
    case 8:
      return "Can not determine default contact to DRM system.";
    case 9:
      return "Contact to DRM must be set explicitly because there is no default.";
    case 10:
      return "Unable to initialize DRM system.";
    case 11:
      return "DRMAA session already exist.";
    case 12:
      return "Disengagement from the DRM system failed.";
    case 13:
      return "Invalid format of job attribute.";
    case 14:
      return "Invalid value of job attribute.";
    case 15:
      return "Value of attribute conflicts with other attribute value.";
    case 16:
      return "DRM system is overloaded.  Try again later.";
    case 17:
      return "DRM rejected job due to its configuration or job attributes.";
    case 18:
      return "Job does not exist in DRMs queue.";
    case 19:
      return "Can not resume job (not in valid state).";
    case 20:
      return "Can not suspend job (not in valid state).";
    case 21:
      return "Can not hold job (not in valid state).";
    case 22:
      return "Can not release job (not in valid state).";
    case 23:
      return "Waiting for job to terminate finished due to time-out.";
    case 24:
      return "Job finished but resource usage information and/or termination status could not be provided.";
    case 25:
      return "Vector have no more elements.";
    default:
      return "Unknown DRMAA error code!?";
  }
}

// fsd_dt_error
// file datetime.c line 299
void fsd_dt_error(struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer, const char *fmt, ...)
{
  void **args;
  char *msg = (char *)(void *)0;
  parser->n_errors = parser->n_errors + 1;
  args = (void **)&fmt;
  vasprintf(&msg, fmt, args);
  args = ((void **)NULL);
  char *return_value_fsd_asprintf_1;
  do
    if(!((signed int)fsd_verbose_level >= 6))
    {
      return_value_fsd_asprintf_1=fsd_asprintf("fsd_dt_error: %s", msg);
      _fsd_log(FSD_LOG_ERROR, "datetime.c", "fsd_dt_error", 0, return_value_fsd_asprintf_1);
    }

  while((_Bool)0);
  free((void *)msg);
}

// fsd_dt_lex
// file datetime.c line 317
signed int fsd_dt_lex(union YYSTYPE_1 *lvalp, struct fsd_dt_lexer_s *lex)
{
  const unsigned char *end = lex->end;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*lex->p]) == 0)
      break;

    if(lex->p == end)
      break;

    lex->p = lex->p + 1l;
  }
  while((_Bool)1);
  const unsigned char *tmp_post_2;
  _Bool tmp_if_expr_4;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_5;
  if(lex->p == end)
    return -1;

  else
  {
    if((signed int)*lex->p == 43 || (signed int)*lex->p == 45 || (signed int)*lex->p == 47 || (signed int)*lex->p == 58 || (signed int)*lex->p == 84 || (signed int)*lex->p == 90)
    {
      tmp_post_2 = lex->p;
      lex->p = lex->p + 1l;
      return (signed int)*tmp_post_2;
    }

    signed int num = 0;
    if((signed int)*lex->p >= 48)
      tmp_if_expr_4 = (signed int)*lex->p <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(!tmp_if_expr_4)
    {
      tmp_post_3 = lex->p;
      lex->p = lex->p + 1l;
      fsd_dt_error(lex->parser, lex, "invalid char '%c'", *tmp_post_3);
      return 259;
    }

    else
    {
      for( ; !(lex->p == end); num = num + ((signed int)*tmp_post_5 - 48))
      {
        if(!((signed int)*lex->p >= 48))
          break;

        if((signed int)*lex->p >= 58)
          break;

        num = num * 10;
        tmp_post_5 = lex->p;
        lex->p = lex->p + 1l;
      }
      lvalp->integer = num;
      return 258;
    }
  }
}

// fsd_dt_parse
// file ../drmaa_utils/datetime_impl.h line 57
signed int fsd_dt_parse(struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  signed int yyresult;
  struct yyGLRStack yystack;
  struct yyGLRStack * const yystackp = &yystack;
  unsigned long int yyposn;
  yystackp->yyrawchar = YYEMPTY;
  yystackp->yyval = yyval_default;
  unsigned char return_value_yyinitGLRStack_1;
  return_value_yyinitGLRStack_1=yyinitGLRStack(yystackp, (unsigned long int)200);
  signed int return_value__setjmp_2;
  signed int tmp_if_expr_4;
  unsigned char return_value_yyisErrorAction_6;
  signed int tmp_if_expr_11;
  if(!(return_value_yyinitGLRStack_1 == 0))
  {
    return_value__setjmp_2=_setjmp(yystack.yyexception_buffer);
    switch(return_value__setjmp_2)
    {
      case 0:
        break;
      case 1:
        goto yyabortlab;
      case 2:
        goto yyexhaustedlab;
      default:
        goto yybuglab;
    }
    yyglrShift(&yystack, (unsigned long int)0, 0, (unsigned long int)0, &yystackp->yyval, &yystackp->yyloc);
    yyposn = (unsigned long int)0;
    while((_Bool)1)
    {
      while((_Bool)1)
      {
        signed int yyrule;
        signed int yyaction;
        const signed short int *yyconflicts;
        signed int yystate = yystack.yytops.yystates[(signed long int)0]->yylrState;
        if(yystate == 9)
          goto yyacceptlab;

        unsigned char return_value_yyisDefaultedState_8;
        return_value_yyisDefaultedState_8=yyisDefaultedState(yystate);
        if(!(return_value_yyisDefaultedState_8 == 0))
        {
          yyrule=yydefaultAction(yystate);
          if(yyrule == 0)
          {
            yyreportSyntaxError(&yystack, parser, lexer);
            goto yyuser_error;
          }

          do
          {
            enum anonymous return_value_yyglrReduce_3;
            return_value_yyglrReduce_3=yyglrReduce(&yystack, (unsigned long int)0, yyrule, (unsigned char)1, parser, lexer);
            switch((signed int)return_value_yyglrReduce_3)
            {
              case yyok:
                break;
              case yyabort:
                goto yyabortlab;
              case yyaccept:
                goto yyacceptlab;
              case yyerr:
                goto yyuser_error;
              default:
                goto yybuglab;
            }
          }
          while((_Bool)0);
        }

        else
        {
          signed short int yytoken;
          if(yystackp->yyrawchar == YYEMPTY)
            yystackp->yyrawchar=fsd_dt_lex(&yystackp->yyval, lexer);

          if(YYEOF >= yystackp->yyrawchar)
          {
            yytoken = (signed short int)YYEOF;
            yystackp->yyrawchar = (signed int)yytoken;
          }

          else
          {
            if(!((unsigned int)yystackp->yyrawchar >= 260u))
              tmp_if_expr_4 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

            else
              tmp_if_expr_4 = 2;
            yytoken = (signed short int)tmp_if_expr_4;
          }
          yygetLRActions(yystate, (signed int)yytoken, &yyaction, &yyconflicts);
          if(!((signed int)*yyconflicts == 0))
            break;

          unsigned char return_value_yyisShiftAction_7;
          return_value_yyisShiftAction_7=yyisShiftAction(yyaction);
          if(!(return_value_yyisShiftAction_7 == 0))
          {
            yystackp->yyrawchar = YYEMPTY;
            yyposn = yyposn + (unsigned long int)1;
            yyglrShift(&yystack, (unsigned long int)0, yyaction, yyposn, &yystackp->yyval, &yystackp->yyloc);
            if(yystack.yyerrState >= 1)
              yystack.yyerrState = yystack.yyerrState - 1;

          }

          else
          {
            return_value_yyisErrorAction_6=yyisErrorAction(yyaction);
            if(!(return_value_yyisErrorAction_6 == 0))
            {
              yyreportSyntaxError(&yystack, parser, lexer);
              goto yyuser_error;
            }

            else
              do
              {
                enum anonymous return_value_yyglrReduce_5;
                return_value_yyglrReduce_5=yyglrReduce(&yystack, (unsigned long int)0, -yyaction, (unsigned char)1, parser, lexer);
                switch((signed int)return_value_yyglrReduce_5)
                {
                  case yyok:
                    break;
                  case yyabort:
                    goto yyabortlab;
                  case yyaccept:
                    goto yyacceptlab;
                  case yyerr:
                    goto yyuser_error;
                  default:
                    goto yybuglab;
                }
              }
              while((_Bool)0);
          }
        }
      }
      while((_Bool)1)
      {
        signed short int yytoken_to_shift;
        unsigned long int yys = (unsigned long int)0;
        for( ; !(yys >= yystack.yytops.yysize); yys = yys + (unsigned long int)1)
          yystackp->yytops.yylookaheadNeeds[(signed long int)yys] = (unsigned char)(yystackp->yyrawchar != YYEMPTY);
        yys = (unsigned long int)0;
        for( ; !(yys >= yystack.yytops.yysize); yys = yys + (unsigned long int)1)
          do
          {
            enum anonymous return_value_yyprocessOneStack_9;
            return_value_yyprocessOneStack_9=yyprocessOneStack(&yystack, yys, yyposn, parser, lexer);
            switch((signed int)return_value_yyprocessOneStack_9)
            {
              case yyok:
                break;
              case yyabort:
                goto yyabortlab;
              case yyaccept:
                goto yyacceptlab;
              case yyerr:
                goto yyuser_error;
              default:
                goto yybuglab;
            }
          }
          while((_Bool)0);
        yyremoveDeletes(&yystack);
        if(yystack.yytops.yysize == 0ul)
        {
          yyundeleteLastStack(&yystack);
          if(yystack.yytops.yysize == 0ul)
            yyFail(&yystack, parser, lexer, "syntax error");

          do
          {
            enum anonymous return_value_yyresolveStack_10;
            return_value_yyresolveStack_10=yyresolveStack(&yystack, parser, lexer);
            switch((signed int)return_value_yyresolveStack_10)
            {
              case yyok:
                break;
              case yyabort:
                goto yyabortlab;
              case yyaccept:
                goto yyacceptlab;
              case yyerr:
                goto yyuser_error;
              default:
                goto yybuglab;
            }
          }
          while((_Bool)0);
          yyreportSyntaxError(&yystack, parser, lexer);
          goto yyuser_error;
        }

        if(!((unsigned int)yystackp->yyrawchar >= 260u))
          tmp_if_expr_11 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

        else
          tmp_if_expr_11 = 2;
        yytoken_to_shift = (signed short int)tmp_if_expr_11;
        yystackp->yyrawchar = YYEMPTY;
        yyposn = yyposn + (unsigned long int)1;
        yys = (unsigned long int)0;
        for( ; !(yys >= yystack.yytops.yysize); yys = yys + (unsigned long int)1)
        {
          signed int fsd_dt_parse__1__2__2__4__1__yyaction;
          const signed short int *fsd_dt_parse__1__2__2__4__1__yyconflicts;
          signed int fsd_dt_parse__1__2__2__4__1__yystate = yystack.yytops.yystates[(signed long int)yys]->yylrState;
          yygetLRActions(fsd_dt_parse__1__2__2__4__1__yystate, (signed int)yytoken_to_shift, &fsd_dt_parse__1__2__2__4__1__yyaction, &fsd_dt_parse__1__2__2__4__1__yyconflicts);
          yyglrShift(&yystack, yys, fsd_dt_parse__1__2__2__4__1__yyaction, yyposn, &yystackp->yyval, &yystackp->yyloc);
        }
        if(yystack.yytops.yysize == 1ul)
        {
          do
          {
            enum anonymous return_value_yyresolveStack_12;
            return_value_yyresolveStack_12=yyresolveStack(&yystack, parser, lexer);
            switch((signed int)return_value_yyresolveStack_12)
            {
              case yyok:
                break;
              case yyabort:
                goto yyabortlab;
              case yyaccept:
                goto yyacceptlab;
              case yyerr:
                goto yyuser_error;
              default:
                goto yybuglab;
            }
          }
          while((_Bool)0);
          yycompressStack(&yystack);
          break;
        }

      }
      continue;

    yyuser_error:
      ;
      yyrecoverSyntaxError(&yystack, parser, lexer);
      yyposn = yystack.yytops.yystates[(signed long int)0]->yyposn;
    }

  yyacceptlab:
    ;
    yyresult = 0;
    goto yyreturn;

  yybuglab:
    ;
    abort();
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);

  yyabortlab:
    ;
    yyresult = 1;
  }

  else
  {

  yyexhaustedlab:
    ;
    fsd_dt_error(parser, lexer, "memory exhausted");
    yyresult = 2;
  }

yyreturn:
  ;
  signed int tmp_if_expr_13;
  if(!(yystackp->yyrawchar == YYEMPTY))
  {
    if(!((unsigned int)yystackp->yyrawchar >= 260u))
      tmp_if_expr_13 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

    else
      tmp_if_expr_13 = 2;
    yydestruct_link1("Cleanup: discarding lookahead", tmp_if_expr_13, &yystackp->yyval, parser, lexer);
  }

  if(!(yystack.yyitems == ((union yyGLRStackItem *)NULL)))
  {
    struct yyGLRState **yystates = yystack.yytops.yystates;
    if(!(yystates == ((struct yyGLRState **)NULL)))
    {
      unsigned long int yysize = yystack.yytops.yysize;
      unsigned long int yyk = (unsigned long int)0;
      for( ; !(yyk >= yysize); yyk = yyk + (unsigned long int)1)
        if(!(yystates[(signed long int)yyk] == ((struct yyGLRState *)NULL)))
        {
          while(!(yystates[(signed long int)yyk] == ((struct yyGLRState *)NULL)))
          {
            struct yyGLRState *fsd_dt_parse__1__3__1__1__1__1__yys = yystates[(signed long int)yyk];
            if(!(fsd_dt_parse__1__3__1__1__1__1__yys->yypred == ((struct yyGLRState *)NULL)))
              yydestroyGLRState("Cleanup: popping", fsd_dt_parse__1__3__1__1__1__1__yys, parser, lexer);

            yystates[(signed long int)yyk] = fsd_dt_parse__1__3__1__1__1__1__yys->yypred;
            yystack.yynextFree = yystack.yynextFree - (signed long int)1;
            yystack.yyspaceLeft = yystack.yyspaceLeft + (unsigned long int)1;
          }
          break;
        }

    }

    yyfreeGLRStack(&yystack);
  }

  return yyresult;
}

// fsd_environ_apply
// file environ.c line 170
static struct fsd_environ_s * fsd_environ_apply(struct fsd_environ_s *self)
{
  unsigned int i;
  const struct fsd_environ_item_s *j;
  struct fsd_environ_s * volatile saved_state = (struct fsd_environ_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_environ_apply", 175);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_strdup_1;
  char *return_value_fsd_strdup_2;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      saved_state=fsd_environ_new((const char * const *)(void *)0);
      i = (unsigned int)0;
      for( ; !(i >= self->_table_size); i = i + 1u)
      {
        j = self->_table[(signed long int)i];
        for( ; !(j == ((const struct fsd_environ_item_s *)NULL)); j = j->next)
        {
          const char *value;
          value=getenv(j->name);
          if(!(value == ((const char *)NULL)))
          {
            return_value_fsd_strdup_1=fsd_strdup(j->name);
            return_value_fsd_strdup_2=fsd_strdup(value);
            saved_state->set(saved_state, return_value_fsd_strdup_1, return_value_fsd_strdup_2);
          }

          setenv(j->name, j->value, 1);
        }
      }
      goto __CPROVER_DUMP_L12;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(saved_state == ((struct fsd_environ_s *)NULL)))
        saved_state->destroy(saved_state);

      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L12:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L13:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return saved_state;
}

// fsd_environ_destroy
// file environ.c line 37
static void fsd_environ_destroy(struct fsd_environ_s *self)
{
  unsigned int i;
  struct fsd_environ_item_s *j;
  if(!(self->_table == ((struct fsd_environ_item_s **)NULL)))
  {
    i = (unsigned int)0;
    for( ; !(i >= self->_table_size); i = i + 1u)
    {
      j = self->_table[(signed long int)i];
      while(!(j == ((struct fsd_environ_item_s *)NULL)))
      {
        struct fsd_environ_item_s *to_delete = j;
        j = j->next;
        fsd_free((void *)to_delete->name);
        fsd_free((void *)to_delete->value);
        fsd_free((void *)to_delete);
      }
    }
    fsd_free((void *)self->_table);
  }

  fsd_free((void *)self);
}

// fsd_environ_get
// file environ.c line 58
static const char * fsd_environ_get(struct fsd_environ_s *self, const char *name)
{
  unsigned int fsd_environ_get__1__hash;
  const struct fsd_environ_item_s *i;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  fsd_environ_get__1__hash=hashlittle((const void *)name, return_value_strlen_1, (unsigned int)0);
  fsd_environ_get__1__hash = fsd_environ_get__1__hash & self->_table_size - (unsigned int)1;
  i = self->_table[(signed long int)fsd_environ_get__1__hash];
  signed int return_value_strcmp_2;
  for( ; !(i == ((const struct fsd_environ_item_s *)NULL)); i = i->next)
  {
    return_value_strcmp_2=strcmp(i->name, name);
    if(return_value_strcmp_2 == 0)
      return i->value;

  }
  return (const char *)(void *)0;
}

// fsd_environ_list
// file environ.c line 134
static char ** fsd_environ_list(struct fsd_environ_s *self)
{
  unsigned int i;
  const struct fsd_environ_item_s *j;
  char ** volatile result = (char ** volatile )(void *)0;
  unsigned int items = (unsigned int)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_environ_list", 141);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      i = (unsigned int)0;
      for( ; !(i >= self->_table_size); i = i + 1u)
      {
        j = self->_table[(signed long int)i];
        for( ; !(j == ((const struct fsd_environ_item_s *)NULL)); j = j->next)
        {
          items = items + 1u;
          fsd_realloc_((void **)(void *)&result, (unsigned long int)(items + (unsigned int)1) * sizeof(char *) /*8ul*/ );
          result[(signed long int)items] = (char *)(void *)0;
          result[(signed long int)(items - (unsigned int)1)]=fsd_asprintf("%s=%s", j->name, j->value);
        }
      }
      goto __CPROVER_DUMP_L10;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      fsd_free_vector(result);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L10:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L11:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  i = (unsigned int)0;
  for( ; !(result[(signed long int)i] == ((char *)NULL)); i = i + 1u)

    __CPROVER_DUMP_L15:
      ;
  return result;
}

// fsd_environ_new
// file environ.c line 215
struct fsd_environ_s * fsd_environ_new(const char * const *envp)
{
  struct fsd_environ_s * volatile self = (struct fsd_environ_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_environ_new", 218);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_malloc_((void **)(void *)&self, sizeof(struct fsd_environ_s) /*72ul*/ );
      self->destroy = fsd_environ_destroy;
      self->get = fsd_environ_get;
      self->set = fsd_environ_set;
      self->update = fsd_environ_update;
      self->list = fsd_environ_list;
      self->apply = fsd_environ_apply;
      self->restore = fsd_environ_restore;
      self->_table_size = (unsigned int)256;
      fsd_calloc_((void **)(void *)&self->_table, (unsigned long int)self->_table_size, sizeof(struct fsd_environ_item_s *) /*8ul*/ );
      if(!(envp == ((const char * const *)NULL)))
        self->update(self, envp);

      goto __CPROVER_DUMP_L7;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(self == ((struct fsd_environ_s *)NULL)))
        self->destroy(self);

    }


  __CPROVER_DUMP_L7:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L8:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return self;
}

// fsd_environ_restore
// file environ.c line 199
static void fsd_environ_restore(struct fsd_environ_s *self, struct fsd_environ_s *saved_state)
{
  unsigned int i;
  const struct fsd_environ_item_s *j;
  i = (unsigned int)0;
  for( ; !(i >= self->_table_size); i = i + 1u)
  {
    j = self->_table[(signed long int)i];
    if(!(j == ((const struct fsd_environ_item_s *)NULL)))
    {
      const char *value;
      value=saved_state->get(saved_state, j->name);
      if(!(value == ((const char *)NULL)))
        setenv(j->name, value, 1);

      else
        unsetenv(j->name);
      j = j->next;
    }

  }
}

// fsd_environ_set
// file environ.c line 71
static void fsd_environ_set(struct fsd_environ_s *self, char *name, char *value)
{
  unsigned int fsd_environ_set__1__hash;
  struct fsd_environ_item_s *i;
  struct fsd_environ_item_s *item = (struct fsd_environ_item_s *)(void *)0;
  _Bool replaced = (_Bool)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_environ_set", 78);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(name);
      fsd_environ_set__1__hash=hashlittle((const void *)name, return_value_strlen_1, (unsigned int)0);
      fsd_environ_set__1__hash = fsd_environ_set__1__hash & self->_table_size - (unsigned int)1;
      i = self->_table[(signed long int)fsd_environ_set__1__hash];
      for( ; !(i == ((struct fsd_environ_item_s *)NULL)); i = i->next)
      {
        signed int return_value_strcmp_2;
        return_value_strcmp_2=strcmp(i->name, name);
        if(return_value_strcmp_2 == 0)
        {
          fsd_free((void *)i->value);
          i->value = value;
          replaced = (_Bool)1;
          break;
        }

      }
      if(replaced == (_Bool)0)
      {
        fsd_malloc_((void **)(void *)&item, sizeof(struct fsd_environ_item_s) /*24ul*/ );
        item->next = self->_table[(signed long int)fsd_environ_set__1__hash];
        item->name = name;
        item->value = value;
        self->_table[(signed long int)fsd_environ_set__1__hash] = item;
      }

      goto __CPROVER_DUMP_L10;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      fsd_free((void *)name);
      fsd_free((void *)value);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L10:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L11:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_environ_update
// file environ.c line 112
static void fsd_environ_update(struct fsd_environ_s *self, const char * const *envp)
{
  const char * const *i = envp;
  if(!(*i == ((const char *)NULL)))
  {
    const char *eq;
    char * volatile name = (char *)(void *)0;
    char * volatile value = (char *)(void *)0;
    eq=strchr(*i, 61);
    if(eq == ((const char *)NULL))
      fsd_exc_raise_code(1005);

    name=fsd_strndup(*i, (unsigned long int)(eq - *i));
    struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
    signed int _fsd_exc_rc;
    _fsd_exc_try_block=fsd_exc_try("fsd_environ_update", 124);
    if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
      _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

    else
      _fsd_exc_rc = -3;
    while((_Bool)1)
    {
      _Bool _fsd_exc_handled = (_Bool)0;
      fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
      if(_fsd_exc_rc == -3)
        break;

      if(_fsd_exc_rc == 0)
      {
        value=fsd_strdup(eq + (signed long int)1);
        goto __CPROVER_DUMP_L8;
      }

      if(_fsd_exc_rc >= 1)
      {
        _fsd_exc_handled = (_Bool)1;
        fsd_free((void *)name);
        fsd_exc_reraise();
      }


    __CPROVER_DUMP_L8:
      ;
      if(!(_fsd_exc_handled == (_Bool)0))
      {

      __CPROVER_DUMP_L9:
        ;
        _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
        _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
      }

    }
    self->set(self, name, value);
    i = i + 1l;
  }

}

// fsd_errno_from_drmaa_code
// file drmaa_util.c line 304
signed int fsd_errno_from_drmaa_code(signed int drmaa_errno)
{
  switch(drmaa_errno)
  {
    case 0:
      return 0;
    case 1:
      return 1001;
    case 2:
      return 1013;
    case 3:
      return 1011;
    case 4:
      return 1003;
    case 5:
      return 1008;
    case 6:
      return 1002;
    case 7:
      return 1033;
    case 8:
      return 1034;
    case 9:
      return 1035;
    case 10:
      return 1014;
    case 11:
      return 1036;
    case 12:
      return 1015;
    case 13:
      return 1037;
    case 14:
      return 1038;
    case 15:
      return 1039;
    case 16:
      return 1012;
    case 17:
      return 1016;
    case 18:
      return 1040;
    case 19:
      return 1041;
    case 20:
      return 1042;
    case 21:
      return 1043;
    case 22:
      return 1044;
    case 23:
      return 1045;
    case 24:
      return 1046;
    case 25:
      return 1006;
    default:
    {

    __CPROVER_DUMP_L27:
      ;
      return 1001;
    }
  }
}

// fsd_exc_clear
// file exception.c line 292
void fsd_exc_clear(void)
{
  struct fsd_exc_stack_s *stack;
  struct fsd_exc_try_block_s *block;

__CPROVER_DUMP_L1:
  ;
  stack=fsd_exc_get_stack((_Bool)0);

__CPROVER_DUMP_L2:
  ;
  block = stack->restore_points[(signed long int)(stack->n_restore_points - 1)];
  if(!(block->handled_exc == ((struct fsd_exc_s *)NULL)))
    block->handled_exc->destroy(block->handled_exc);

  block->handled_exc = (struct fsd_exc_s *)(void *)0;

__CPROVER_DUMP_L4:
  ;
}

// fsd_exc_code
// file exception.c line 342
signed int fsd_exc_code(const struct fsd_exc_s *self)
{
  return self->_code;
}

// fsd_exc_control
// file ../drmaa_utils/exception.h line 170
void fsd_exc_control(struct fsd_exc_try_block_s *block, signed int *rc)
{
  _Bool tmp_if_expr_1;
  if(block == ((struct fsd_exc_try_block_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *rc == -3 ? (_Bool)1 : (_Bool)0;
  char *return_value_fsd_asprintf_2;
  if(!tmp_if_expr_1)
    switch((signed int)block->state)
    {
      case FSD_EXC_ENTER:
      {
        block->state = (enum anonymous_6)FSD_EXC_TRY_BLOCK;

      __CPROVER_DUMP_L4:
        ;
        break;
      }
      case FSD_EXC_TRY_BLOCK:
        if(*rc == 0)
        {
          block->state = (enum anonymous_6)FSD_EXC_ELSE_BLOCK;
          *rc = -1;
          break;
        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          block->state = (enum anonymous_6)FSD_EXC_EXCEPTION_HANDLE;
          break;
        }
      case FSD_EXC_EXCEPTION_HANDLE:

      case FSD_EXC_ELSE_BLOCK:
      {
        block->state = (enum anonymous_6)FSD_EXC_FINALLY_BLOCK;
        *rc = -2;
        break;
      }
      case FSD_EXC_FINALLY_BLOCK:
      {
        struct fsd_exc_try_block_s *current = (struct fsd_exc_try_block_s *)(void *)0;
        struct fsd_exc_try_block_s *upper = (struct fsd_exc_try_block_s *)(void *)0;
        struct fsd_exc_stack_s *stack = (struct fsd_exc_stack_s *)(void *)0;
        block->state = (enum anonymous_6)FSD_EXC_LEAVE;
        stack=fsd_exc_get_stack((_Bool)0);
        current = stack->restore_points[(signed long int)(stack->n_restore_points - 1)];

      __CPROVER_DUMP_L9:
        ;
        if(stack->n_restore_points >= 2)
          upper = stack->restore_points[(signed long int)(stack->n_restore_points - 2)];

        stack->n_restore_points = stack->n_restore_points - 1;
        if(!(current->handled_exc == ((struct fsd_exc_s *)NULL)) && !(upper == ((struct fsd_exc_try_block_s *)NULL)))
        {
          if(!(upper->handled_exc == ((struct fsd_exc_s *)NULL)))
          {

          __CPROVER_DUMP_L11:
            ;
            if((signed int)upper->state == FSD_EXC_FINALLY_BLOCK)
              do
                if(!((signed int)fsd_verbose_level >= 5))
                {
                  return_value_fsd_asprintf_2=fsd_asprintf("overriding previously raised exception: <%d:%s>", upper->handled_exc->_code, upper->handled_exc->_message);
                  _fsd_log(FSD_LOG_WARNING, "exception.c", "fsd_exc_control", 0, return_value_fsd_asprintf_2);
                }

              while((_Bool)0);

            upper->handled_exc->destroy(upper->handled_exc);
          }

          upper->handled_exc = current->handled_exc;
          fsd_free((void *)current);
          0;
          longjmp(upper->env, upper->handled_exc->_code);
        }

        else
        {
          if(!(current->handled_exc == ((struct fsd_exc_s *)NULL)))
            current->handled_exc->destroy(current->handled_exc);

          fsd_free((void *)current);
          0;
          *rc = -3;
          break;
        }
      }
      default:

        __CPROVER_DUMP_L19:
          ;
    }

}

// fsd_exc_destroy
// file exception.c line 354
void fsd_exc_destroy(struct fsd_exc_s *self)
{
  if(!(self->_own_message == (_Bool)0))
  {
    fsd_free((void *)self->_message);
    0;
  }

  if(!(self->_own_self == (_Bool)0))
  {
    fsd_free((void *)self);
    0;
  }

}

// fsd_exc_get
// file ../drmaa_utils/exception.h line 85
const struct fsd_exc_s * fsd_exc_get(void)
{
  struct fsd_exc_stack_s *stack;
  struct fsd_exc_try_block_s *block;
  stack=fsd_exc_get_stack((_Bool)0);

__CPROVER_DUMP_L1:
  ;
  block = stack->restore_points[(signed long int)(stack->n_restore_points - 1)];
  return block->handled_exc;
}

// fsd_exc_get_stack
// file exception.c line 96
struct fsd_exc_stack_s * fsd_exc_get_stack(_Bool create)
{
  struct fsd_exc_stack_s *stack = (struct fsd_exc_stack_s *)(void *)0;
  signed int rc;
  rc=pthread_once(&fsd_exc_init_once, fsd_exc_init);
  char *return_value_fsd_asprintf_2;
  if(!(rc == 0))
  {
    char errbuf[256l] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'E', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    strerror_r(*return_value___errno_location_1, errbuf, (unsigned long int)256);
    do
      if(!((signed int)fsd_verbose_level >= 7))
      {
        return_value_fsd_asprintf_2=fsd_asprintf("pthread_once: %s", (const void *)errbuf);
        _fsd_log(FSD_LOG_FATAL, "exception.c", "fsd_exc_get_stack", 0, return_value_fsd_asprintf_2);
      }

    while((_Bool)0);
    abort();
  }

  void *return_value_pthread_getspecific_3;
  return_value_pthread_getspecific_3=pthread_getspecific(fsd_exc_stack);
  stack = (struct fsd_exc_stack_s *)return_value_pthread_getspecific_3;
  _Bool tmp_if_expr_7;
  signed int *return_value___errno_location_6;
  char *return_value_fsd_asprintf_5;
  if(stack == ((struct fsd_exc_stack_s *)NULL) && !(create == (_Bool)0))
  {
    rc=fsd_malloc_noraise_((void **)(void *)&stack, sizeof(struct fsd_exc_stack_s) /*16ul*/ );
    if(!(rc == 0))
      return (struct fsd_exc_stack_s *)(void *)0;

    stack->restore_points = (struct fsd_exc_try_block_s **)(void *)0;
    stack->n_restore_points = 0;
    rc=pthread_setspecific(fsd_exc_stack, (const void *)stack);
    if(!(rc == 0))
    {
      return_value___errno_location_6=__errno_location();
      tmp_if_expr_7 = *return_value___errno_location_6 != 12 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      char fsd_exc_get_stack__1__2__1__errbuf[256l] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'E', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      strerror_r(*return_value___errno_location_4, fsd_exc_get_stack__1__2__1__errbuf, (unsigned long int)256);
      do
        if(!((signed int)fsd_verbose_level >= 7))
        {
          return_value_fsd_asprintf_5=fsd_asprintf("pthread_setspecific: %s", (const void *)fsd_exc_get_stack__1__2__1__errbuf);
          _fsd_log(FSD_LOG_FATAL, "exception.c", "fsd_exc_get_stack", 0, return_value_fsd_asprintf_5);
        }

      while((_Bool)0);
      abort();
    }

    else
      if(!(rc == 0))
        fsd_exc_stack_destroy(stack);

  }

  else

    __CPROVER_DUMP_L11:
      ;
  return stack;
}

// fsd_exc_init
// file exception.c line 76
void fsd_exc_init(void)
{
  signed int rc;

__CPROVER_DUMP_L1:
  ;
  rc=pthread_key_create(&fsd_exc_stack, (void (*)(void *))fsd_exc_stack_destroy);
  char *return_value_fsd_asprintf_2;
  if(!(rc == 0))
  {
    char errbuf[256l] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'E', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    strerror_r(*return_value___errno_location_1, errbuf, (unsigned long int)256);
    do
      if(!((signed int)fsd_verbose_level >= 7))
      {
        return_value_fsd_asprintf_2=fsd_asprintf("pthread_key_create: %s", (const void *)errbuf);
        _fsd_log(FSD_LOG_FATAL, "exception.c", "fsd_exc_init", 0, return_value_fsd_asprintf_2);
      }

    while((_Bool)0);
    abort();
  }


__CPROVER_DUMP_L4:
  ;
}

// fsd_exc_message
// file exception.c line 348
const char * fsd_exc_message(const struct fsd_exc_s *self)
{
  return self->_message;
}

// fsd_exc_new
// file ../drmaa_utils/exception.h line 42
struct fsd_exc_s * fsd_exc_new(signed int code, char *message, _Bool own_message)
{
  struct fsd_exc_s *exc = (struct fsd_exc_s *)(void *)0;
  char * volatile message_buffer = (char *)(void *)0;
  char *return_value_fsd_asprintf_1;
  if(code == 1006 || code == 1045)

    __CPROVER_DUMP_L1:
      ;

  else
    do
      if(!((signed int)fsd_verbose_level >= 6))
      {
        return_value_fsd_asprintf_1=fsd_asprintf("fsd_exc_new(%d,%s,%d)", code, message, own_message);
        _fsd_log(FSD_LOG_ERROR, "exception.c", "fsd_exc_new", 0, return_value_fsd_asprintf_1);
      }

    while((_Bool)0);
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_exc_new", 319);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      if(!(own_message == (_Bool)0))
        message_buffer = message;

      fsd_malloc_((void **)(void *)&exc, sizeof(struct fsd_exc_s) /*48ul*/ );
      exc->_code = code;
      exc->_message = message;
      exc->_own_message = own_message;
      exc->_own_self = (_Bool)1;
      exc->code = fsd_exc_code;
      exc->message = fsd_exc_message;
      exc->destroy = fsd_exc_destroy;
      goto __CPROVER_DUMP_L11;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      fsd_free((void *)message_buffer);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L11:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L12:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return exc;
}

// fsd_exc_raise
// file ../drmaa_utils/exception.h line 57
void fsd_exc_raise(struct fsd_exc_s *exc)
{
  struct fsd_exc_stack_s *stack = (struct fsd_exc_stack_s *)(void *)0;
  struct fsd_exc_try_block_s *block = (struct fsd_exc_try_block_s *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  stack=fsd_exc_get_stack((_Bool)0);

__CPROVER_DUMP_L2:
  ;
  block = stack->restore_points[(signed long int)(stack->n_restore_points - 1)];
  if(!(block->handled_exc == ((struct fsd_exc_s *)NULL)))
    block->handled_exc->destroy(block->handled_exc);

  block->handled_exc = exc;
  longjmp(block->env, exc->_code);
}

// fsd_exc_raise_code
// file ../drmaa_utils/exception.h line 61
void fsd_exc_raise_code(signed int error_code)
{
  struct fsd_exc_s *exc;
  const char *return_value_fsd_strerror_1;
  if(error_code == 1002)
    exc = (struct fsd_exc_s *)&no_memory_exception;

  else
  {
    return_value_fsd_strerror_1=fsd_strerror(error_code);
    exc=fsd_exc_new(error_code, (char *)return_value_fsd_strerror_1, (_Bool)0);
  }
  fsd_exc_raise(exc);
}

// fsd_exc_raise_fmt
// file ../drmaa_utils/exception.h line 69
void fsd_exc_raise_fmt(signed int error_code, const char *fmt, ...)
{
  void **args = (void **)&fmt;
  fsd_exc_raise_fmtv(error_code, fmt, args);
  args = ((void **)NULL);
}

// fsd_exc_raise_fmtv
// file exception.c line 408
void fsd_exc_raise_fmtv(signed int error_code, const char *fmt, void **args)
{
  struct fsd_exc_s *exc = (struct fsd_exc_s *)(void *)0;
  char * volatile message = (char *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_exc_raise_fmtv", 412);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        message=fsd_vasprintf(fmt, args);
        exc=fsd_exc_new(error_code, message, (_Bool)1);
        message = (char *)(void *)0;
        break;
      }
      case -2:
        fsd_free((void *)message);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L7:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  fsd_exc_raise(exc);
}

// fsd_exc_raise_msg
// file exception.c line 392
void fsd_exc_raise_msg(signed int error_code, const char *message)
{
  char *return_value_fsd_strdup_1;
  return_value_fsd_strdup_1=fsd_strdup(message);
  struct fsd_exc_s *return_value_fsd_exc_new_2;
  return_value_fsd_exc_new_2=fsd_exc_new(error_code, return_value_fsd_strdup_1, (_Bool)1);
  fsd_exc_raise(return_value_fsd_exc_new_2);
}

// fsd_exc_raise_sys
// file exception.c line 427
void fsd_exc_raise_sys(signed int errno_code)
{
  struct fsd_exc_s *exc = (struct fsd_exc_s *)(void *)0;
  signed int *return_value___errno_location_1;
  if(errno_code == 0)
  {
    return_value___errno_location_1=__errno_location();
    errno_code = *return_value___errno_location_1;
  }

  if(errno_code == 12)
    exc = (struct fsd_exc_s *)&no_memory_exception;

  else
  {
    signed int code;
    char * volatile message = (char *)(void *)0;
    volatile _Bool own_message = (volatile _Bool)0;
    struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
    signed int _fsd_exc_rc;
    _fsd_exc_try_block=fsd_exc_try("fsd_exc_raise_sys", 440);
    if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
      _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

    else
      _fsd_exc_rc = -3;
    while((_Bool)1)
    {
      _Bool _fsd_exc_handled = (_Bool)0;
      fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
      if(_fsd_exc_rc == -3)
        break;

      if(_fsd_exc_rc == 0)
      {
        if(errno_code == 110)
        {
          code = 1009;
          goto __CPROVER_DUMP_L9;
        }

        code = 1001;

      __CPROVER_DUMP_L9:
        ;
        char *return_value_fsd_astrerror_2;
        return_value_fsd_astrerror_2=fsd_astrerror(errno_code, (_Bool *)&own_message);
        message = (char *)return_value_fsd_astrerror_2;
        exc=fsd_exc_new(code, message, own_message);
        goto __CPROVER_DUMP_L12;
      }

      if(_fsd_exc_rc >= 1)
      {
        _fsd_exc_handled = (_Bool)1;
        if(!(message == ((char *)NULL)) && !(own_message == (_Bool)0))
          fsd_free((void *)message);

        fsd_exc_reraise();
      }


    __CPROVER_DUMP_L12:
      ;
      if(!(_fsd_exc_handled == (_Bool)0))
      {

      __CPROVER_DUMP_L13:
        ;
        _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
        _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
      }

    }
  }
  fsd_exc_raise(exc);
}

// fsd_exc_reraise
// file ../drmaa_utils/exception.h line 81
void fsd_exc_reraise(void)
{
  struct fsd_exc_stack_s *stack = (struct fsd_exc_stack_s *)(void *)0;
  struct fsd_exc_try_block_s *block = (struct fsd_exc_try_block_s *)(void *)0;
  stack=fsd_exc_get_stack((_Bool)0);

__CPROVER_DUMP_L1:
  ;
  block = stack->restore_points[(signed long int)(stack->n_restore_points - 1)];

__CPROVER_DUMP_L2:
  ;
  longjmp(block->env, block->handled_exc->_code);
}

// fsd_exc_stack_destroy
// file exception.c line 136
static void fsd_exc_stack_destroy(struct fsd_exc_stack_s *stack)
{
  signed int i;

__CPROVER_DUMP_L1:
  ;
  i = 0;
  for( ; !(i >= stack->n_restore_points); i = i + 1)
  {
    struct fsd_exc_try_block_s *b = stack->restore_points[(signed long int)i];
    if(!(b->handled_exc == ((struct fsd_exc_s *)NULL)))
      b->handled_exc->destroy(b->handled_exc);

    fsd_free((void *)b);
  }
  fsd_free((void *)stack->restore_points);
  fsd_free((void *)stack);

__CPROVER_DUMP_L5:
  ;
}

// fsd_exc_try
// file ../drmaa_utils/exception.h line 167
struct fsd_exc_try_block_s * fsd_exc_try(const char *function, signed int lineno)
{
  struct fsd_exc_stack_s *stack = (struct fsd_exc_stack_s *)(void *)0;
  struct fsd_exc_try_block_s *p = (struct fsd_exc_try_block_s *)(void *)0;
  signed int rc;
  stack=fsd_exc_get_stack((_Bool)1);
  signed int tmp_post_1;
  if(stack == ((struct fsd_exc_stack_s *)NULL))
    return (struct fsd_exc_try_block_s *)(void *)0;

  else
  {
    rc=fsd_realloc_noraise_((void **)(void *)&stack->restore_points, (unsigned long int)(stack->n_restore_points + 1) * sizeof(struct fsd_exc_try_block_s *) /*8ul*/ );
    if(!(rc == 0))
      return (struct fsd_exc_try_block_s *)(void *)0;

    else
    {
      rc=fsd_malloc_noraise_((void **)(void *)&p, sizeof(struct fsd_exc_try_block_s) /*232ul*/ );
      if(!(rc == 0))
        return (struct fsd_exc_try_block_s *)(void *)0;

      else
      {
        p->handled_exc = (struct fsd_exc_s *)(void *)0;
        p->state = (enum anonymous_6)FSD_EXC_ENTER;
        p->function = function;
        p->lineno = lineno;
        tmp_post_1 = stack->n_restore_points;
        stack->n_restore_points = stack->n_restore_points + 1;
        stack->restore_points[(signed long int)tmp_post_1] = p;
        return p;
      }
    }
  }
}

// fsd_exc_try_except
// file exception.c line 588
void * fsd_exc_try_except(void * (*f)(void *), void *data, signed int *error_code, char **error_message)
{
  void *result = (void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_exc_try_except", 595);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(!(_fsd_exc_rc == 0))
    {
      if(_fsd_exc_rc == -1)
        goto __CPROVER_DUMP_L7;

    }

    else
      result=f(data);
    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      const struct fsd_exc_s *e;
      e=fsd_exc_get();
      *error_code=e->code(e);
      const char *return_value;
      return_value=e->message(e);
      *error_message=fsd_strdup(return_value);
    }

    goto __CPROVER_DUMP_L8;

  __CPROVER_DUMP_L7:
    ;
    *error_code = 0;
    *error_message = (char *)(void *)0;

  __CPROVER_DUMP_L8:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L9:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_exec_async
// file exec.c line 95
void fsd_exec_async(const char *command, char **args, signed int *stdin_desc, signed int *stdout_desc, signed int *stderr_desc, signed int *child_pid)
{
  signed int pid;
  signed int stdin_pipe[2l] = { -1, -1 };
  signed int stderr_pipe[2l] = { -1, -1 };
  signed int stdout_pipe[2l] = { -1, -1 };

__CPROVER_DUMP_L1:
  ;
  if(!(stdin_desc == ((signed int *)NULL)))
    *stdin_desc = -1;

  if(!(stderr_desc == ((signed int *)NULL)))
    *stderr_desc = -1;

  if(!(stdout_desc == ((signed int *)NULL)))
    *stdout_desc = -1;

  *child_pid = -1;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_exec_async", 116);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_asprintf_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_pipe(stdin_pipe);
      fsd_pipe(stdout_pipe);
      fsd_pipe(stderr_pipe);
      pid=fork();
      if(pid == -1)
        fsd_exc_raise_sys(0);

      else
        if(pid >= 1)
        {
          if(!(stdin_desc == ((signed int *)NULL)))
            *stdin_desc = stdin_pipe[(signed long int)1];

          else
            close(stdin_pipe[(signed long int)1]);
          if(!(stdout_desc == ((signed int *)NULL)))
            *stdout_desc = stdout_pipe[(signed long int)0];

          else
            close(stdin_pipe[(signed long int)0]);
          if(!(stderr_desc == ((signed int *)NULL)))
            *stderr_desc = stderr_pipe[(signed long int)0];

          else
            close(stderr_pipe[(signed long int)0]);
          close(stdin_pipe[(signed long int)0]);
          close(stdout_pipe[(signed long int)1]);
          close(stderr_pipe[(signed long int)1]);
          *child_pid = pid;
        }

        else
        {
          dup2(stdin_pipe[(signed long int)0], 0);
          close(stdin_pipe[(signed long int)1]);
          dup2(stdout_pipe[(signed long int)1], 1);
          close(stdout_pipe[(signed long int)0]);
          dup2(stderr_pipe[(signed long int)1], 2);
          close(stderr_pipe[(signed long int)0]);
          signed int return_value_execvp_2;
          return_value_execvp_2=execvp(command, args);
          if(return_value_execvp_2 == -1)
          {
            do
              if(!((signed int)fsd_verbose_level >= 6))
              {
                return_value_fsd_asprintf_1=fsd_asprintf("Could not execute command: %s ", command);
                _fsd_log(FSD_LOG_ERROR, "exec.c", "fsd_exec_async", 0, return_value_fsd_asprintf_1);
              }

            while((_Bool)0);
            _exit(127);
          }

        }
      goto __CPROVER_DUMP_L22;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      close(stdin_pipe[(signed long int)0]);
      close(stdin_pipe[(signed long int)1]);
      close(stdout_pipe[(signed long int)0]);
      close(stdout_pipe[(signed long int)1]);
      close(stderr_pipe[(signed long int)0]);
      close(stderr_pipe[(signed long int)1]);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L22:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L23:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_exec_sync
// file exec.c line 223
signed int fsd_exec_sync(const char *command, char **args, const char *stdinb, char **stdoutb, char **stderrb)
{
  signed int child_pid = -1;
  signed int stdin_d = -1;
  signed int stdout_d = -1;
  signed int stderr_d = -1;
  signed int *arg = (signed int *)(void *)0;
  unsigned long int len = (unsigned long int)-1;
  signed int exit_code = -1;
  signed int ret = -1;
  unsigned long int err_t = (unsigned long int)0;
  unsigned long int out_t = (unsigned long int)0;

__CPROVER_DUMP_L1:
  ;
  *stdoutb = (char *)(void *)0;
  *stderrb = (char *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_exec_sync", 246);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_exec_async(command, args, &stdin_d, &stdout_d, &stderr_d, &child_pid);
      fsd_malloc_((void **)(void *)&arg, sizeof(unsigned long int) /*8ul*/ );
      *arg = stdout_d;
      fsd_thread_create(&out_t, stream_ripper, (void *)arg);
      arg = (signed int *)(void *)0;
      fsd_malloc_((void **)(void *)&arg, sizeof(unsigned long int) /*8ul*/ );
      *arg = stderr_d;
      fsd_thread_create(&err_t, stream_ripper, (void *)arg);
      arg = (signed int *)(void *)0;
      if(!(stdinb == ((const char *)NULL)))
      {
        len=strlen(stdinb);
        while((_Bool)1)
        {
          signed long int return_value_write_1;
          return_value_write_1=write(stdin_d, (const void *)stdinb, len);
          ret = (signed int)return_value_write_1;
          if(ret == -1)
            fsd_exc_raise_sys(0);

          len = len - (unsigned long int)ret;
          stdinb = stdinb + (signed long int)ret;
          if(len == 0ul)
            break;

        }
      }

      close(stdin_d);
      stdin_d = -1;
      exit_code=fsd_exec_wait(child_pid);
      fsd_thread_join(out_t, (void **)stdoutb);
      fsd_thread_join(err_t, (void **)stderrb);
      goto __CPROVER_DUMP_L14;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(arg == ((signed int *)NULL)))
        fsd_free((void *)arg);

      if(!(stdin_d == -1))
        close(stdin_d);

      if(!(*stdoutb == ((char *)NULL)))
        fsd_free((void *)*stdoutb);

      close(stdout_d);
      close(stderr_d);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L14:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L15:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return exit_code;
}

// fsd_exec_wait
// file exec.c line 195
signed int fsd_exec_wait(signed int child_pid)
{
  signed int status = -1;
  signed int exit_code = -1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_waitpid_1;
  return_value_waitpid_1=waitpid(child_pid, &status, 0);
  if(!(return_value_waitpid_1 == -1))
  {
    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_10
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if((0x7f & status) == 0)
      exit_code = (((union anonymous_10){ .__in=status }).__i & 0xff00) >> 8;

    else
      fsd_exc_raise_fmt(1001, "Spawned process pid = %d was aborted or signaled", (signed int)child_pid);
  }

  else
    fsd_exc_raise_sys(0);

__CPROVER_DUMP_L2:
  ;
  return exit_code;
}

// fsd_expand_drmaa_ph_destroy
// file drmaa_util.c line 110
static void fsd_expand_drmaa_ph_destroy(struct fsd_expand_drmaa_ph_s *self)
{
  if(!(self == ((struct fsd_expand_drmaa_ph_s *)NULL)))
  {
    fsd_free((void *)self->home_directory);
    fsd_free((void *)self->working_directory);
    fsd_free((void *)self->bulk_incr);
    fsd_free((void *)self);
  }

}

// fsd_expand_drmaa_ph_expand
// file drmaa_util.c line 44
static char * fsd_expand_drmaa_ph_expand(struct fsd_expand_drmaa_ph_s *self, char *s, unsigned int set)
{
  unsigned int mask = (unsigned int)1;
  char *return_value_strstr_2;
  char *return_value_fsd_asprintf_1;
  for( ; !(mask >= 5u); mask = mask << 1)
  {
    const char *ph;
    const char *value;
    switch(mask)
    {
      case (unsigned int)1:
      {
        ph = "_drmaa_hd_ph_";
        value = self->home_directory;
        break;
      }
      case (unsigned int)2:
      {
        ph = "_drmaa_wd_ph_";
        value = self->working_directory;
        break;
      }
      case (unsigned int)4:
      {
        ph = "_drmaa_incr_ph_";
        value = self->bulk_incr;
        break;
      }
      default:

        __CPROVER_DUMP_L5:
          ;
    }
    if(value == ((const char *)NULL))
      value = "";

    if(!((mask & set) == 0u))
      s=fsd_replace(s, ph, value);

    else
    {
      return_value_strstr_2=strstr(s, ph);
      if(!(return_value_strstr_2 == ((char *)NULL)))
      {
        do
          if(!((signed int)fsd_verbose_level >= 5))
          {
            return_value_fsd_asprintf_1=fsd_asprintf("'%s' can not be expanded in '%s'; removing from string", ph, s);
            _fsd_log(FSD_LOG_WARNING, "drmaa_util.c", "fsd_expand_drmaa_ph_expand", 0, return_value_fsd_asprintf_1);
          }

        while((_Bool)0);
        s=fsd_replace(s, ph, "");
      }

    }
  }
  return s;
}

// fsd_expand_drmaa_ph_new
// file drmaa_util.c line 122
struct fsd_expand_drmaa_ph_s * fsd_expand_drmaa_ph_new(char *home_directory, char *working_directory, char *bulk_incr)
{
  struct fsd_expand_drmaa_ph_s * volatile p = (struct fsd_expand_drmaa_ph_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_expand_drmaa_ph_new", 130);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      struct fsd_expand_drmaa_ph_s *self;
      fsd_malloc_((void **)(void *)&p, sizeof(struct fsd_expand_drmaa_ph_s) /*48ul*/ );
      self = p;
      self->expand = fsd_expand_drmaa_ph_expand;
      self->set = fsd_expand_drmaa_ph_set;
      self->destroy = fsd_expand_drmaa_ph_destroy;
      self->home_directory = home_directory;
      self->working_directory = working_directory;
      self->bulk_incr = bulk_incr;
      if(self->home_directory == ((char *)NULL))
      {
        const char *home;
        home=getenv("HOME");
        if(home == ((const char *)NULL))
          home = "";

        self->home_directory=fsd_strdup(home);
      }

      if(self->working_directory == ((char *)NULL))
        self->working_directory=fsd_strdup(self->home_directory);

      else
        self->working_directory=self->expand(self, self->working_directory, (unsigned int)1);
      if(self->bulk_incr == ((char *)NULL))
        self->bulk_incr=fsd_strdup("");

      goto __CPROVER_DUMP_L12;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(p == ((struct fsd_expand_drmaa_ph_s *)NULL)))
        p->destroy(p);

      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L12:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L13:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return p;
}

// fsd_expand_drmaa_ph_set
// file drmaa_util.c line 92
static void fsd_expand_drmaa_ph_set(struct fsd_expand_drmaa_ph_s *self, signed int placeholder, char *value)
{
  char **var;
  switch(placeholder)
  {
    case 1:
    {
      var = &self->home_directory;
      break;
    }
    case 2:
    {
      var = &self->working_directory;
      break;
    }
    case 4:
    {
      var = &self->bulk_incr;
      break;
    }
    default:
    {
      fsd_free((void *)value);
      fsd_exc_raise_code(1003);
    }
  }
  fsd_free((void *)*var);
  *var = value;
}

// fsd_expand_printf_ph
// file fsd_util.c line 342
static char * fsd_expand_printf_ph(const char *fmt)
{
  char * volatile result = (char *)(void *)0;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(fmt, "%m");
  if(return_value_strstr_1 == ((char *)NULL))
    return result;

  else
  {
    struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
    signed int _fsd_exc_rc;
    _fsd_exc_try_block=fsd_exc_try("fsd_expand_printf_ph", 349);
    if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
      _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

    else
      _fsd_exc_rc = -3;
    while((_Bool)1)
    {
      _Bool _fsd_exc_handled = (_Bool)0;
      fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
      if(_fsd_exc_rc == -3)
        break;

      if(_fsd_exc_rc == 0)
      {
        const char *pos;
        do
        {
          pos=strstr(fmt, "%m");
          if(pos == ((const char *)NULL))
            break;

          if(!(pos == fmt))
          {
            if((signed int)pos[-1l] == 37)
              break;

          }

          char * volatile errno_msg = (char *)(void *)0;
          volatile _Bool own_errno_msg = (volatile _Bool)0;
          struct fsd_exc_try_block_s * volatile fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
          signed int fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc;
          fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block=fsd_exc_try("fsd_expand_printf_ph", 357);
          if(!(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
            fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc=_setjmp(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block->env);

          else
            fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc = -3;
          while((_Bool)1)
          {
            _Bool fsd_expand_printf_ph__1__1__1__1__1__1__1__1__1___fsd_exc_handled = (_Bool)0;
            fsd_exc_control(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block, &fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc);
            if(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc == -3)
              break;

            switch(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_rc)
            {
              case 0:
              {
                char *buf = (char *)(void *)0;
                unsigned long int fmt_len;
                fmt_len=strlen(fmt);
                unsigned long int ph_pos = (unsigned long int)(pos - fmt);
                unsigned long int errno_msg_len;
                signed int *return_value___errno_location_2;
                return_value___errno_location_2=__errno_location();
                errno_msg=fsd_astrerror(*return_value___errno_location_2, (_Bool *)&own_errno_msg);
                errno_msg_len=strlen(errno_msg);
                fsd_calloc_((void **)(void *)&buf, (fmt_len - (unsigned long int)2) + errno_msg_len + (unsigned long int)1, sizeof(char) /*1ul*/ );
                strncat(buf, fmt, ph_pos);
                strcat(buf + (signed long int)ph_pos, errno_msg);
                strcat(buf + (signed long int)ph_pos + (signed long int)errno_msg_len, fmt + (signed long int)ph_pos + (signed long int)2);
                fsd_free((void *)result);
                result = buf;
                fmt = result;
                break;
              }
              case -2:
                if(!(errno_msg == ((char *)NULL)) && !(own_errno_msg == (_Bool)0))
                  fsd_free((void *)errno_msg);

            }
            if(!(fsd_expand_printf_ph__1__1__1__1__1__1__1__1__1___fsd_exc_handled == (_Bool)0))
            {

            __CPROVER_DUMP_L14:
              ;
              fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc->destroy(fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc);
              fsd_expand_printf_ph__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
            }

          }
        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L19;
      }

      if(_fsd_exc_rc >= 1)
      {
        _fsd_exc_handled = (_Bool)1;
        fsd_free((void *)result);
        fsd_exc_reraise();
      }


    __CPROVER_DUMP_L19:
      ;
      if(!(_fsd_exc_handled == (_Bool)0))
      {

      __CPROVER_DUMP_L20:
        ;
        _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
        _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
      }

    }
    return result;
  }
}

// fsd_explode
// file ../drmaa_utils/util.h line 39
char * fsd_explode(const char * const *vector, char glue, signed int n)
{
  char * volatile result = (char *)(void *)0;
  char * volatile buf = (char *)(void *)0;
  char *s;
  const char * const *i;
  unsigned int idx;
  unsigned int max = (unsigned int)n;
  unsigned long int size = (unsigned long int)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_explode", 145);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  char *tmp_post_4;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        i = vector;
        idx = (unsigned int)0;
        do
        {
          if(!(idx >= max))
            tmp_if_expr_1 = *i != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          if(!(i == vector))
            size = size + 1ul;

          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(*i);
          size = size + return_value_strlen_2;
          i = i + 1l;
          idx = idx + 1u;
        }
        while((_Bool)1);
        fsd_calloc_((void **)(void *)&buf, size + (unsigned long int)1, sizeof(char) /*1ul*/ );
        s = buf;
        i = vector;
        idx = (unsigned int)0;
        do
        {
          if(!(idx >= max))
            tmp_if_expr_3 = *i != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          if(!(i == vector))
          {
            tmp_post_4 = s;
            s = s + 1l;
            *tmp_post_4 = glue;
          }

          strcpy(s, *i);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(*i);
          s = s + (signed long int)return_value_strlen_5;
          i = i + 1l;
          idx = idx + 1u;
        }
        while((_Bool)1);
        break;
      }
      case -1:
      {
        result = buf;
        buf = (char *)(void *)0;
        break;
      }
      case -2:
        fsd_free((void *)buf);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L18:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_free
// file ../drmaa_utils/xmalloc.h line 63
void fsd_free(void *p)
{
  if(!(p == NULL))
    free(p);

}

// fsd_free_vector
// file ../drmaa_utils/util.h line 40
void fsd_free_vector(char **vector)
{
  char **i;
  if(!(vector == ((char **)NULL)))
  {
    i = vector;
    for( ; !(*i == ((char *)NULL)); i = i + 1l)
      fsd_free((void *)*i);
    fsd_free((void *)vector);
  }

}

// fsd_get_time
// file fsd_util.c line 447
void fsd_get_time(struct timespec *ts)
{
  struct timeval tv;
  signed int rc;
  rc=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(!(rc == 0))
    fsd_exc_raise_sys(0);

  else
  {
    ts->tv_sec = tv.tv_sec;
    ts->tv_nsec = (signed long int)1000 * tv.tv_usec;
  }
}

// fsd_getcwd
// file fsd_util.c line 546
char * fsd_getcwd(void)
{
  char * volatile buffer = (char *)(void *)0;
  char * volatile result = (char *)(void *)0;
  unsigned long int size = (unsigned long int)64;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_getcwd", 552);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  signed int *return_value___errno_location_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        fsd_calloc_((void **)(void *)&buffer, size, sizeof(char) /*1ul*/ );
        while((_Bool)1)
        {
          char *fsd_getcwd__1__1__1__1__1__1__1__result;
          fsd_getcwd__1__1__1__1__1__1__1__result=getcwd(buffer, size);
          if(!(fsd_getcwd__1__1__1__1__1__1__1__result == ((char *)NULL)))
            break;

          else
          {
            return_value___errno_location_1=__errno_location();
            if(*return_value___errno_location_1 == 34)
            {
              size = size * (unsigned long int)2;
              fsd_realloc_((void **)(void *)&buffer, size * sizeof(char) /*1ul*/ );
            }

            else
              fsd_exc_raise_sys(0);
          }
        }
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(buffer);
        fsd_realloc_((void **)(void *)&buffer, (return_value_strlen_2 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
        break;
      }
      case -1:
      {
        result = buffer;
        buffer = (char *)(void *)0;
        break;
      }
      case -2:
        fsd_free((void *)buffer);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L13:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_iter_append
// file iter.c line 54
static void fsd_iter_append(struct fsd_iter_s *self, char *string)
{
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_iter_append", 56);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  signed int tmp_post_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      if(self->_own_list == (_Bool)0)
        fsd_exc_raise_msg(1001, "iter::append called on constant list");

      fsd_realloc_((void **)(void *)&self->_list, (unsigned long int)(self->_length + 1) * sizeof(char *) /*8ul*/ );
      tmp_post_1 = self->_length;
      self->_length = self->_length + 1;
      self->_list[(signed long int)tmp_post_1] = string;
      goto __CPROVER_DUMP_L7;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      fsd_free((void *)string);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L7:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L8:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_iter_destroy
// file iter.c line 74
static void fsd_iter_destroy(struct fsd_iter_s *self)
{
  signed int i;
  if(!(self->_own_list == (_Bool)0))
  {
    if(!(self->_list == ((char **)NULL)))
    {
      i = 0;
      for( ; !(i >= self->_length); i = i + 1)
        fsd_free((void *)self->_list[(signed long int)i]);
      fsd_free((void *)self->_list);
    }

  }

  fsd_free((void *)self);
}

// fsd_iter_len
// file iter.c line 48
static signed int fsd_iter_len(struct fsd_iter_s *self)
{
  return self->_length;
}

// fsd_iter_new
// file iter.c line 135
struct fsd_iter_s * fsd_iter_new(char **list, signed int length)
{
  struct fsd_iter_s *return_value_fsd_iter_new_impl_1;
  return_value_fsd_iter_new_impl_1=fsd_iter_new_impl(list, length, (_Bool)1);
  return return_value_fsd_iter_new_impl_1;
}

// fsd_iter_new_const
// file iter.c line 141
struct fsd_iter_s * fsd_iter_new_const(const char * const *list, signed int length)
{
  struct fsd_iter_s *return_value_fsd_iter_new_impl_1;
  return_value_fsd_iter_new_impl_1=fsd_iter_new_impl((char **)list, length, (_Bool)0);
  return return_value_fsd_iter_new_impl_1;
}

// fsd_iter_new_impl
// file iter.c line 87
static struct fsd_iter_s * fsd_iter_new_impl(char **list, signed int length, _Bool own)
{
  struct fsd_iter_s * volatile self = (struct fsd_iter_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_iter_new_impl", 90);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_malloc_((void **)(void *)&self, sizeof(struct fsd_iter_s) /*64ul*/ );
      self->next = fsd_iter_next;
      self->reset = fsd_iter_reset;
      self->len = fsd_iter_len;
      self->append = fsd_iter_append;
      self->destroy = fsd_iter_destroy;
      self->_list = list;
      self->_position = 0;
      if(list == ((char **)NULL))
        self->_length = 0;

      else
        if(length >= 0)
          self->_length = length;

        else
        {
          char **i;
          signed int cnt = 0;
          i = self->_list;
          for( ; !(*i == ((char *)NULL)); i = i + 1l)
            cnt = cnt + 1;
          self->_length = cnt;
        }
      self->_own_list = own;
      goto __CPROVER_DUMP_L15;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(list == ((char **)NULL)) && !(own == (_Bool)0))
      {
        if(length >= 0)
        {
          signed int fsd_iter_new_impl__1__1__1__1__2__1__1__1__i = 0;
          for( ; !(fsd_iter_new_impl__1__1__1__1__2__1__1__1__i >= length); fsd_iter_new_impl__1__1__1__1__2__1__1__1__i = fsd_iter_new_impl__1__1__1__1__2__1__1__1__i + 1)
            fsd_free((void *)list[(signed long int)fsd_iter_new_impl__1__1__1__1__2__1__1__1__i]);
          fsd_free((void *)list);
        }

        else
          fsd_free_vector(list);
      }

      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L15:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L16:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return self;
}

// fsd_iter_next
// file iter.c line 33
static const char * fsd_iter_next(struct fsd_iter_s *self)
{
  signed int tmp_post_1;
  if(!(self->_position >= self->_length))
  {
    tmp_post_1 = self->_position;
    self->_position = self->_position + 1;
    return self->_list[(signed long int)tmp_post_1];
  }

  else
    fsd_exc_raise_code(1006);
}

// fsd_iter_reset
// file iter.c line 42
static void fsd_iter_reset(struct fsd_iter_s *self)
{
  self->_position = 0;
}

// fsd_job_control
// file fsd_job.c line 128
static void fsd_job_control(struct fsd_job_s *self, signed int action)
{
  fsd_exc_raise_code(1007);
}

// fsd_job_destroy
// file fsd_job.c line 112
static void fsd_job_destroy(struct fsd_job_s *self)
{

__CPROVER_DUMP_L1:
  ;
  fsd_cond_destroy(&self->status_cond);
  fsd_cond_destroy(&self->destroy_cond);
  fsd_mutex_destroy(&self->mutex);
  fsd_free((void *)self->job_id);
  fsd_free((void *)self->execution_hosts);
  fsd_free((void *)self->queue);
  fsd_free((void *)self->project);
  fsd_free((void *)self);

__CPROVER_DUMP_L2:
  ;
}

// fsd_job_get_termination_status
// file fsd_job.c line 140
static void fsd_job_get_termination_status(struct fsd_job_s *self, signed int *status, struct fsd_iter_s **rusage_out)
{
  struct fsd_iter_s * volatile rusage = (struct fsd_iter_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_get_termination_status", 145);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_asprintf_2;
  char *return_value_fsd_asprintf_3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(!(_fsd_exc_rc == 0))
    {
      if(_fsd_exc_rc == -1)
        goto __CPROVER_DUMP_L14;

    }

    else
    {
      if(!(rusage_out == ((struct fsd_iter_s **)NULL)))
      {
        rusage=fsd_iter_new((char **)(void *)0, 0);
        char *return_value_fsd_asprintf_1;
        return_value_fsd_asprintf_1=fsd_asprintf("submission_time=%ld", (signed long int)self->submit_time);
        rusage->append(rusage, return_value_fsd_asprintf_1);
        if(!(self->start_time == 0l))
        {
          return_value_fsd_asprintf_2=fsd_asprintf("start_time=%ld", (signed long int)self->start_time);
          rusage->append(rusage, return_value_fsd_asprintf_2);
        }

        if(!(self->end_time == 0l))
        {
          return_value_fsd_asprintf_3=fsd_asprintf("end_time=%ld", (signed long int)self->end_time);
          rusage->append(rusage, return_value_fsd_asprintf_3);
        }

        char *return_value_fsd_asprintf_4;
        return_value_fsd_asprintf_4=fsd_asprintf("cpu=%ld", self->cpu_usage);
        rusage->append(rusage, return_value_fsd_asprintf_4);
        char *return_value_fsd_asprintf_5;
        return_value_fsd_asprintf_5=fsd_asprintf("mem=%ld", self->mem_usage);
        rusage->append(rusage, return_value_fsd_asprintf_5);
        char *return_value_fsd_asprintf_6;
        return_value_fsd_asprintf_6=fsd_asprintf("vmem=%ld", self->vmem_usage);
        rusage->append(rusage, return_value_fsd_asprintf_6);
        char *return_value_fsd_asprintf_7;
        return_value_fsd_asprintf_7=fsd_asprintf("walltime=%ld", self->walltime);
        rusage->append(rusage, return_value_fsd_asprintf_7);
        char *return_value_fsd_asprintf_8;
        return_value_fsd_asprintf_8=fsd_asprintf("hosts=%s", self->execution_hosts);
        rusage->append(rusage, return_value_fsd_asprintf_8);
        if(!(self->queue == ((char *)NULL)))
        {
          char *return_value_fsd_asprintf_9;
          return_value_fsd_asprintf_9=fsd_asprintf("queue=%s", self->queue);
          rusage->append(rusage, return_value_fsd_asprintf_9);
        }

        if(!(self->project == ((char *)NULL)))
        {
          char *return_value_fsd_asprintf_10;
          return_value_fsd_asprintf_10=fsd_asprintf("project=%s", self->project);
          rusage->append(rusage, return_value_fsd_asprintf_10);
        }

      }

      goto __CPROVER_DUMP_L16;
    }
    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(rusage == ((struct fsd_iter_s *)NULL)))
        rusage->destroy(rusage);

      if(!(rusage_out == ((struct fsd_iter_s **)NULL)))
        *rusage_out = (struct fsd_iter_s *)(void *)0;

      fsd_exc_reraise();
    }

    goto __CPROVER_DUMP_L16;

  __CPROVER_DUMP_L14:
    ;
    if(!(status == ((signed int *)NULL)))
      *status = self->exit_status;

    if(!(rusage_out == ((struct fsd_iter_s **)NULL)))
      *rusage_out = rusage;


  __CPROVER_DUMP_L16:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L17:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_job_new
// file fsd_job.c line 45
struct fsd_job_s * fsd_job_new(char *job_id)
{
  struct fsd_job_s * volatile self = (struct fsd_job_s *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_new", 49);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_malloc_((void **)(void *)&self, sizeof(struct fsd_job_s) /*320ul*/ );
      self->release = fsd_job_release;
      self->destroy = fsd_job_destroy;
      self->control = fsd_job_control;
      self->update_status = fsd_job_update_status;
      self->get_termination_status = fsd_job_get_termination_status;
      self->on_missing = fsd_job_on_missing;
      self->next = (struct fsd_job_s *)(void *)0;
      self->ref_cnt = 1;
      self->job_id = job_id;
      self->session = (struct fsd_drmaa_session_s *)(void *)0;
      self->last_update_time = (signed long int)0;
      self->flags = (unsigned int)0;
      self->state = 0x00;
      self->exit_status = 0;
      self->submit_time = (signed long int)0;
      self->start_time = (signed long int)0;
      self->end_time = (signed long int)0;
      self->cpu_usage = (signed long int)0;
      self->mem_usage = (signed long int)0;
      self->vmem_usage = (signed long int)0;
      self->walltime = (signed long int)0;
      self->execution_hosts = (char *)(void *)0;
      self->queue = (char *)(void *)0;
      self->project = (char *)(void *)0;
      fsd_mutex_init(&self->mutex);
      fsd_cond_init(&self->status_cond);
      fsd_cond_init(&self->destroy_cond);
      fsd_mutex_lock(&self->mutex);
      goto __CPROVER_DUMP_L9;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(self == ((struct fsd_job_s *)NULL)))
        self->destroy(self);

      else
        fsd_free((void *)job_id);
      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L9:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L10:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L13:
  ;
  return self;
}

// fsd_job_on_missing
// file fsd_job.c line 198
static void fsd_job_on_missing(struct fsd_job_s *self)
{
  char *return_value_fsd_asprintf_1;
  do
    if(!((signed int)fsd_verbose_level >= 5))
    {
      return_value_fsd_asprintf_1=fsd_asprintf("job %s missing from DRM queue", self->job_id);
      _fsd_log(FSD_LOG_WARNING, "fsd_job.c", "fsd_job_on_missing", 0, return_value_fsd_asprintf_1);
    }

  while((_Bool)0);
}

// fsd_job_release
// file fsd_job.c line 97
static void fsd_job_release(struct fsd_job_s *self)
{
  _Bool destroy;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  self->ref_cnt = self->ref_cnt - 1;
  destroy = self->ref_cnt == 0;
  fsd_mutex_unlock(&self->mutex);
  if(!(destroy == (_Bool)0))
    self->destroy(self);


__CPROVER_DUMP_L3:
  ;
}

// fsd_job_set_add
// file fsd_job.c line 284
static void fsd_job_set_add(struct fsd_job_set_s *self, struct fsd_job_s *job)
{
  unsigned int h;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(&self->mutex);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(job->job_id);
  h=hashlittle((const void *)job->job_id, return_value_strlen_1, (unsigned int)0);
  h = h & self->tab_mask;
  job->next = self->tab[(signed long int)h];
  self->tab[(signed long int)h] = job;
  self->n_jobs = self->n_jobs + 1u;
  job->ref_cnt = job->ref_cnt + 1;
  fsd_mutex_unlock(&self->mutex);

__CPROVER_DUMP_L2:
  ;
}

// fsd_job_set_destroy
// file fsd_job.c line 263
static void fsd_job_set_destroy(struct fsd_job_set_s *self)
{
  unsigned int i;
  struct fsd_job_s *j;

__CPROVER_DUMP_L1:
  ;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= self->tab_size); i = i + 1u)
  {
    j = self->tab[(signed long int)i];
    if(!(j == ((struct fsd_job_s *)NULL)))
    {
      struct fsd_job_s *job = j;
      j = j->next;
      fsd_mutex_lock(&job->mutex);
      job->release(job);
    }

  }
  fsd_free((void *)self->tab);
  fsd_free((void *)self);

__CPROVER_DUMP_L6:
  ;
}

// fsd_job_set_empty
// file fsd_job.c line 364
static _Bool fsd_job_set_empty(struct fsd_job_set_s *self)
{
  return self->n_jobs == (unsigned int)0;
}

// fsd_job_set_find_terminated
// file fsd_job.c line 371
static struct fsd_job_s * fsd_job_set_find_terminated(struct fsd_job_set_s *self)
{
  struct fsd_job_s *job = (struct fsd_job_s *)(void *)0;
  unsigned long int i;
  union anonymous_1 * volatile mutex = &self->mutex;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(mutex);
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_set_find_terminated", 379);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        i = (unsigned long int)0;
        for( ; !(i >= self->tab_size); i = i + 1ul)
        {
          job = self->tab[(signed long int)i];
          for( ; !(job == ((struct fsd_job_s *)NULL)); job = job->next)
            if(job->state >= 0x30)
              goto found;

        }

      found:
        ;
        if(!(job == ((struct fsd_job_s *)NULL)))
        {
          fsd_mutex_lock(&job->mutex);

        __CPROVER_DUMP_L10:
          ;
          job->ref_cnt = job->ref_cnt + 1;
        }

        break;
      }
      case -2:
        fsd_mutex_unlock(mutex);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L14:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  if(!(job == ((struct fsd_job_s *)NULL)))

    __CPROVER_DUMP_L17:
      ;

  else

    __CPROVER_DUMP_L18:
      ;
  return job;
}

// fsd_job_set_get
// file fsd_job.c line 335
static struct fsd_job_s * fsd_job_set_get(struct fsd_job_set_s *self, const char *job_id)
{
  unsigned int h;
  struct fsd_job_s *job = (struct fsd_job_s *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(&self->mutex);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(job_id);
  h=hashlittle((const void *)job_id, return_value_strlen_1, (unsigned int)0);
  h = h & self->tab_mask;
  job = self->tab[(signed long int)h];
  signed int return_value_strcmp_2;
  for( ; !(job == ((struct fsd_job_s *)NULL)); job = job->next)
  {
    return_value_strcmp_2=strcmp(job->job_id, job_id);
    if(return_value_strcmp_2 == 0)
      break;

  }
  if(!(job == ((struct fsd_job_s *)NULL)))
  {
    fsd_mutex_lock(&job->mutex);

  __CPROVER_DUMP_L4:
    ;
    job->ref_cnt = job->ref_cnt + 1;
  }

  fsd_mutex_unlock(&self->mutex);
  if(!(job == ((struct fsd_job_s *)NULL)))

    __CPROVER_DUMP_L6:
      ;

  else

    __CPROVER_DUMP_L7:
      ;
  return job;
}

// fsd_job_set_get_all_job_ids
// file fsd_job.c line 406
static char ** fsd_job_set_get_all_job_ids(struct fsd_job_set_s *self)
{
  struct fsd_job_s *job = (struct fsd_job_s *)(void *)0;
  char ** volatile job_ids = (char ** volatile )(void *)0;
  unsigned long int i;
  unsigned int j = (unsigned int)0;
  union anonymous_1 * volatile mutex = &self->mutex;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(mutex);
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_set_get_all_job_ids", 417);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  unsigned int tmp_post_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        fsd_calloc_((void **)(void *)&job_ids, (unsigned long int)(self->n_jobs + (unsigned int)1), sizeof(char *) /*8ul*/ );
        i = (unsigned long int)0;
        for( ; !(i >= self->tab_size); i = i + 1ul)
        {
          job = self->tab[(signed long int)i];
          for( ; !(job == ((struct fsd_job_s *)NULL)); job = job->next)
          {
            tmp_post_1 = j;
            j = j + 1u;
            job_ids[(signed long int)tmp_post_1]=fsd_strdup(job->job_id);
          }
        }
        fsd_realloc_((void **)(void *)&job_ids, (unsigned long int)(j + (unsigned int)1) * sizeof(char *) /*8ul*/ );
        break;
      }
      case -2:
      {
        fsd_mutex_unlock(mutex);
        const struct fsd_exc_s *return_value_fsd_exc_get_2;
        return_value_fsd_exc_get_2=fsd_exc_get();
        if(!(return_value_fsd_exc_get_2 == ((const struct fsd_exc_s *)NULL)))
          fsd_free_vector(job_ids);

      }
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L13:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L16:
  ;
  return job_ids;
}

// fsd_job_set_new
// file fsd_job.c line 222
struct fsd_job_set_s * fsd_job_set_new(void)
{
  struct fsd_job_set_s * volatile self = (struct fsd_job_set_s *)(void *)0;
  const unsigned long int initial_size = (const unsigned long int)1024;

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_set_new", 228);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_malloc_((void **)(void *)&self, sizeof(struct fsd_job_set_s) /*128ul*/ );
      self->destroy = fsd_job_set_destroy;
      self->add = fsd_job_set_add;
      self->remove = fsd_job_set_remove;
      self->get = fsd_job_set_get;
      self->empty = fsd_job_set_empty;
      self->find_terminated = fsd_job_set_find_terminated;
      self->get_all_job_ids = fsd_job_set_get_all_job_ids;
      self->signal_all = fsd_job_set_signal_all;
      self->tab = (struct fsd_job_s **)(void *)0;
      self->n_jobs = (unsigned int)0;
      fsd_calloc_((void **)(void *)&self->tab, initial_size, sizeof(struct fsd_job_s *) /*8ul*/ );
      self->tab_size = initial_size;
      self->tab_mask = (unsigned int)(self->tab_size - (unsigned long int)1);
      fsd_mutex_init(&self->mutex);
      goto __CPROVER_DUMP_L8;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(self == ((struct fsd_job_set_s *)NULL)))
      {
        fsd_free((void *)self->tab);
        fsd_free((void *)self);
      }

      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L8:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L9:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L12:
  ;
  return self;
}

// fsd_job_set_remove
// file fsd_job.c line 301
static void fsd_job_set_remove(struct fsd_job_set_s *self, struct fsd_job_s *job)
{
  struct fsd_job_s **pjob = (struct fsd_job_s **)(void *)0;
  unsigned int h;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(&self->mutex);
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_set_remove", 308);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(job->job_id);
        h=hashlittle((const void *)job->job_id, return_value_strlen_1, (unsigned int)0);
        h = h & self->tab_mask;
        pjob = &self->tab[(signed long int)h];
        for( ; !(*pjob == ((struct fsd_job_s *)NULL)); pjob = &(*pjob)->next)
          if(*pjob == job)
            break;

        if(!(*pjob == ((struct fsd_job_s *)NULL)))
        {
          *pjob = (*pjob)->next;
          job->next = (struct fsd_job_s *)(void *)0;
          self->n_jobs = self->n_jobs - 1u;
          job->ref_cnt = job->ref_cnt - 1;
        }

        else
          fsd_exc_raise_code(1040);
        break;
      }
      case -2:
        fsd_mutex_unlock(&self->mutex);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L12:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L15:
  ;
}

// fsd_job_set_signal_all
// file fsd_job.c line 439
static void fsd_job_set_signal_all(struct fsd_job_set_s *self)
{
  struct fsd_job_s * volatile job = (struct fsd_job_s *)(void *)0;
  union anonymous_1 * volatile mutex = &self->mutex;

__CPROVER_DUMP_L1:
  ;
  fsd_mutex_lock(mutex);
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int fsd_job_set_signal_all__1__2___fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_job_set_signal_all", 446);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    fsd_job_set_signal_all__1__2___fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    fsd_job_set_signal_all__1__2___fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool fsd_job_set_signal_all__1__2__1___fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &fsd_job_set_signal_all__1__2___fsd_exc_rc);
    if(fsd_job_set_signal_all__1__2___fsd_exc_rc == -3)
      break;

    switch(fsd_job_set_signal_all__1__2___fsd_exc_rc)
    {
      case 0:
      {
        volatile unsigned long int i = (volatile unsigned long int)0;
        for( ; !(i >= self->tab_size); i = i + 1ul)
        {
          job = self->tab[(signed long int)i];
          for( ; !(job == ((struct fsd_job_s *)NULL)); job = job->next)
          {
            fsd_mutex_lock(&job->mutex);
            struct fsd_exc_try_block_s * volatile fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
            signed int _fsd_exc_rc;
            fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block=fsd_exc_try("fsd_job_set_signal_all", 453);
            if(!(fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
              _fsd_exc_rc=_setjmp(fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block->env);

            else
              _fsd_exc_rc = -3;
            while((_Bool)1)
            {
              _Bool _fsd_exc_handled = (_Bool)0;
              fsd_exc_control(fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block, &_fsd_exc_rc);
              if(_fsd_exc_rc == -3)
                break;

              switch(_fsd_exc_rc)
              {
                case 0:
                {
                  fsd_cond_broadcast(&job->status_cond);
                  break;
                }
                case -2:
                  fsd_mutex_unlock(&job->mutex);
              }
              if(!(_fsd_exc_handled == (_Bool)0))
              {

              __CPROVER_DUMP_L14:
                ;
                fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc->destroy(fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc);
                fsd_job_set_signal_all__1__2__1__1__1__1__1__1__1__1___fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
              }

            }
          }
        }
        break;
      }
      case -2:
        fsd_mutex_unlock(mutex);
    }
    if(!(fsd_job_set_signal_all__1__2__1___fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L21:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }

__CPROVER_DUMP_L24:
  ;
}

// fsd_job_update_status
// file fsd_job.c line 134
static void fsd_job_update_status(struct fsd_job_s *self)
{
  fsd_exc_raise_code(1007);
}

// fsd_log_check_verbosity
// file logging.c line 212
static void fsd_log_check_verbosity(void)
{
  const char *log_level_str;
  log_level_str=getenv("DRMAA_LOG_LEVEL");
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(log_level_str == ((const char *)NULL))
    goto __CPROVER_DUMP_L9;

  else
  {
    return_value_strcmp_6=strcmp(log_level_str, "TRACE");
    if(return_value_strcmp_6 == 0)
      fsd_verbose_level = (enum anonymous_7)FSD_LOG_TRACE;

    else
    {
      return_value_strcmp_5=strcmp(log_level_str, "DEBUG");
      if(return_value_strcmp_5 == 0)
        fsd_verbose_level = (enum anonymous_7)FSD_LOG_DEBUG;

      else
      {
        return_value_strcmp_4=strcmp(log_level_str, "INFO");
        if(return_value_strcmp_4 == 0)
          fsd_verbose_level = (enum anonymous_7)FSD_LOG_INFO;

        else
        {
          return_value_strcmp_3=strcmp(log_level_str, "WARNING");
          if(return_value_strcmp_3 == 0)
            fsd_verbose_level = (enum anonymous_7)FSD_LOG_WARNING;

          else
          {
            return_value_strcmp_2=strcmp(log_level_str, "ERROR");
            if(return_value_strcmp_2 == 0)
              fsd_verbose_level = (enum anonymous_7)FSD_LOG_ERROR;

            else
            {
              return_value_strcmp_1=strcmp(log_level_str, "FATAL");
              if(return_value_strcmp_1 == 0)
                fsd_verbose_level = (enum anonymous_7)FSD_LOG_FATAL;

              else
                fprintf(stderr, "Illegal value of DRMAA_LOG_LEVEL=%s. Using default logging verbosity.", log_level_str);
            }
          }
        }
      }
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// fsd_log_fmt
// file logging.c line 252
void fsd_log_fmt(signed int level, const char *fmt, ...)
{
  void **args = (void **)&fmt;
  fsd_log_fmtv(level, fmt, args);
  args = ((void **)NULL);
}

// fsd_log_fmtv
// file logging.c line 262
void fsd_log_fmtv(signed int level, const char *fmt, void **args)
{
  char *return_value_fsd_vasprintf_1;
  return_value_fsd_vasprintf_1=fsd_vasprintf(fmt, args);
  _fsd_log(level, (const char *)(void *)0, (const char *)(void *)0, 0, return_value_fsd_vasprintf_1);
}

// fsd_log_level_char
// file logging.c line 87
char fsd_log_level_char(signed int level)
{
  switch(level)
  {
    case FSD_LOG_TRACE:
      return (char)116;
    case FSD_LOG_DEBUG:
      return (char)100;
    case FSD_LOG_INFO:
      return (char)73;
    case FSD_LOG_WARNING:
      return (char)87;
    case FSD_LOG_ERROR:
      return (char)69;
    case FSD_LOG_FATAL:
      return (char)70;
    default:
      return (char)63;
  }
}

// fsd_log_stacktrace
// file ../drmaa_utils/logging.h line 74
void fsd_log_stacktrace(signed int skip, signed int limit)
{
  void **ptr_buf = (void **)(void *)0;
  const char **symbols = (const char **)(void *)0;
  signed int i;
  signed int n;
  if(limit == 0)
    limit = 128;

  skip = skip + 1;
  n = skip + limit;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)n, sizeof(void *) /*8ul*/ );
  ptr_buf = (void **)return_value_calloc_1;
  if(!(ptr_buf == ((void **)NULL)))
  {
    n=backtrace(ptr_buf, n);
    char **return_value_backtrace_symbols_2;
    return_value_backtrace_symbols_2=backtrace_symbols(ptr_buf, n);
    symbols = (const char **)return_value_backtrace_symbols_2;
    if(!(symbols == ((const char **)NULL)))
    {

    __CPROVER_DUMP_L3:
      ;
      i = n - skip;
      for( ; i >= 0; i = i - 1)

        __CPROVER_DUMP_L5:
          ;
      free((void *)symbols);
    }

  }

}

// fsd_malloc_
// file ../drmaa_utils/xmalloc.h line 65
void * fsd_malloc_(void **p, unsigned long int size)
{
  void *ptr = (void *)0;
  if(!(size == 0ul))
  {
    ptr=malloc(size);
    if(!(ptr == NULL))
      memset(ptr, 0, size);

    else
    {
      *p = (void *)0;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 12;
      fsd_exc_raise_sys(*return_value___errno_location_1);
    }
  }

  *p = ptr;
  return ptr;
}

// fsd_malloc_noraise_
// file ../drmaa_utils/xmalloc.h line 81
signed int fsd_malloc_noraise_(void **p, unsigned long int size)
{
  signed int result = 0;
  void *ptr = (void *)0;
  if(!(size == 0ul))
  {
    ptr=malloc(size);
    if(!(ptr == NULL))
      memset(ptr, 0, size);

    else
      result = 12;
  }

  *p = ptr;
  return result;
}

// fsd_mutex_destroy
// file ../drmaa_utils/thread.h line 81
void fsd_mutex_destroy(union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  errno_=pthread_mutex_destroy(mutex);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_mutex_init
// file ../drmaa_utils/thread.h line 80
void fsd_mutex_init(union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  union anonymous_9 attr;
  do
  {
    errno_=pthread_mutexattr_init(&attr);
    if(!(errno_ == 0))
      break;

    errno_=pthread_mutexattr_settype(&attr, 1);
    if(!(errno_ == 0))
      break;

    errno_=pthread_mutex_init(mutex, &attr);
    if(!(errno_ == 0))
      break;

    errno_=pthread_mutexattr_destroy(&attr);
  }
  while((_Bool)0);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_mutex_lock
// file ../drmaa_utils/thread.h line 82
_Bool fsd_mutex_lock(union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  errno_=pthread_mutex_lock(mutex);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

  return (_Bool)1;
}

// fsd_mutex_trylock
// file thread.c line 132
_Bool fsd_mutex_trylock(union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  errno_=pthread_mutex_trylock(mutex);
  switch(errno_)
  {
    case 0:
      return (_Bool)1;
    case 16:
      return (_Bool)0;
    default:
      fsd_exc_raise_sys(errno_);
  }
}

// fsd_mutex_unlock
// file ../drmaa_utils/thread.h line 83
_Bool fsd_mutex_unlock(union anonymous_1 *mutex)
{
  signed int errno_ = 0;
  errno_=pthread_mutex_unlock(mutex);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

  return (_Bool)0;
}

// fsd_mutex_unlock_times
// file thread.c line 148
signed int fsd_mutex_unlock_times(union anonymous_1 *mutex)
{
  signed int count = 0;
  signed int errno_ = 0;
  while(errno_ == 0)
  {
    errno_=pthread_mutex_unlock(mutex);
    if(errno_ == 0)
      count = count + 1;

  }
  if(count == 0 || !(errno_ == 1))
    fsd_exc_raise_sys(errno_);

  return count;
}

// fsd_parse_timedelta
// file timedelta.rl line 37
signed int fsd_parse_timedelta(const char *string)
{
  signed int v = 0;
  signed int fields[3l];
  signed int n_fields = 0;
  signed int timedelta;
  signed int i;
  const char *p = string;
  const char *pe;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(p);
  pe = p + (signed long int)return_value_strlen_1;
  const char *eof = pe;
  signed int cs;

__CPROVER_DUMP_L1:
  ;
  static const signed int fsd_timedelta_start = 1;
  cs = fsd_timedelta_start;
  signed int _klen;
  unsigned int _trans;
  const char *_acts;
  unsigned int _nacts;
  const char *_keys;
  const char *tmp_post_2;
  unsigned int tmp_post_3;
  const char *tmp_post_4;
  signed int tmp_post_5;
  static const char _fsd_timedelta_actions[10l] = { (const char)0, (const char)1, (const char)0, (const char)1, (const char)1, (const char)1, (const char)3, (const char)2, (const char)2, (const char)3 };
  if(!(p == pe))
  {
    if(cs == 0)
      goto _out;

    do
    {

    _resume:
      ;
      static const char _fsd_timedelta_key_offsets[7l] = { (const char)0, (const char)0, (const char)2, (const char)5, (const char)7, (const char)9, (const char)12 };
      static const char _fsd_timedelta_trans_keys[15l] = { (const char)48, (const char)57, (const char)58, (const char)48, (const char)57, (const char)48, (const char)57, (const char)48, (const char)57, (const char)58, (const char)48, (const char)57, (const char)48, (const char)57, (const char)0 };
      _keys = _fsd_timedelta_trans_keys + (signed long int)_fsd_timedelta_key_offsets[(signed long int)cs];
      static const char _fsd_timedelta_index_offsets[7l] = { (const char)0, (const char)0, (const char)2, (const char)5, (const char)7, (const char)9, (const char)12 };
      _trans = (unsigned int)_fsd_timedelta_index_offsets[(signed long int)cs];
      static const char _fsd_timedelta_single_lengths[7l] = { (const char)0, (const char)0, (const char)1, (const char)0, (const char)0, (const char)1, (const char)0 };
      _klen = (signed int)_fsd_timedelta_single_lengths[(signed long int)cs];
      if(_klen >= 1)
      {
        const char *_lower = _keys;
        const char *_mid;
        const char *_upper = (_keys + (signed long int)_klen) - (signed long int)1;
        while((_Bool)1)
        {
          if(!(_upper >= _lower))
            break;

          _mid = _lower + (_upper - _lower >> 1);
          if(!((signed int)*p >= (signed int)*_mid))
            _upper = _mid - (signed long int)1;

          else
            if(!((signed int)*_mid >= (signed int)*p))
              _lower = _mid + (signed long int)1;

            else
            {
              _trans = _trans + (unsigned int)(_mid - _keys);
              goto _match;
            }
        }
        _keys = _keys + (signed long int)_klen;
        _trans = _trans + (unsigned int)_klen;
      }

      static const char _fsd_timedelta_range_lengths[7l] = { (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1 };
      _klen = (signed int)_fsd_timedelta_range_lengths[(signed long int)cs];
      if(_klen >= 1)
      {
        const char *fsd_parse_timedelta__1__3__2___lower = _keys;
        const char *fsd_parse_timedelta__1__3__2___mid;
        const char *fsd_parse_timedelta__1__3__2___upper = (_keys + (signed long int)(_klen << 1)) - (signed long int)2;
        while((_Bool)1)
        {
          if(!(fsd_parse_timedelta__1__3__2___upper >= fsd_parse_timedelta__1__3__2___lower))
            break;

          fsd_parse_timedelta__1__3__2___mid = fsd_parse_timedelta__1__3__2___lower + (fsd_parse_timedelta__1__3__2___upper - fsd_parse_timedelta__1__3__2___lower >> 1 & (signed long int)~1);
          if(!((signed int)*p >= (signed int)*fsd_parse_timedelta__1__3__2___mid))
            fsd_parse_timedelta__1__3__2___upper = fsd_parse_timedelta__1__3__2___mid - (signed long int)2;

          else
            if(!((signed int)fsd_parse_timedelta__1__3__2___mid[1l] >= (signed int)*p))
              fsd_parse_timedelta__1__3__2___lower = fsd_parse_timedelta__1__3__2___mid + (signed long int)2;

            else
            {
              _trans = _trans + (unsigned int)(fsd_parse_timedelta__1__3__2___mid - _keys >> 1);
              goto _match;
            }
        }
        _trans = _trans + (unsigned int)_klen;
      }


    _match:
      ;
      static const char _fsd_timedelta_trans_targs[15l] = { (const char)2, (const char)0, (const char)3, (const char)2, (const char)0, (const char)5, (const char)0, (const char)6, (const char)0, (const char)4, (const char)5, (const char)0, (const char)6, (const char)0, (const char)0 };
      cs = (signed int)_fsd_timedelta_trans_targs[(signed long int)_trans];
      static const char _fsd_timedelta_trans_actions[15l] = { (const char)7, (const char)1, (const char)3, (const char)5, (const char)1, (const char)7, (const char)1, (const char)7, (const char)1, (const char)3, (const char)5, (const char)1, (const char)5, (const char)1, (const char)0 };
      if(!((signed int)_fsd_timedelta_trans_actions[(signed long int)_trans] == 0))
      {
        _acts = _fsd_timedelta_actions + (signed long int)_fsd_timedelta_trans_actions[(signed long int)_trans];
        tmp_post_2 = _acts;
        _acts = _acts + 1l;
        _nacts = (unsigned int)*tmp_post_2;
        do
        {
          tmp_post_3 = _nacts;
          _nacts = _nacts - 1u;
          if(!(tmp_post_3 >= 1u))
            break;

          tmp_post_4 = _acts;
          _acts = _acts + 1l;
          switch((signed int)*tmp_post_4)
          {
            case 0:
            {
              fsd_exc_raise_fmt(1005, "time delta syntax error: %s", string);
              break;
            }
            case 1:
            {
              tmp_post_5 = n_fields;
              n_fields = n_fields + 1;
              fields[(signed long int)tmp_post_5] = v;
              break;
            }
            case 2:
            {
              v = 0;
              break;
            }
            case 3:
            {
              v = v * 10;
              v = v + ((signed int)*p - 48);
            }
          }
        }
        while((_Bool)1);
      }


    _again:
      ;
      if(cs == 0)
        goto _out;

      p = p + 1l;
    }
    while(!(p == pe));
  }


_test_eof:
  ;
  const char *tmp_post_6;
  unsigned int tmp_post_7;
  const char *tmp_post_8;
  signed int tmp_post_9;
  if(p == eof)
  {
    static const char _fsd_timedelta_eof_actions[7l] = { (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)3, (const char)3 };
    const char *__acts = _fsd_timedelta_actions + (signed long int)_fsd_timedelta_eof_actions[(signed long int)cs];
    unsigned int __nacts;
    tmp_post_6 = __acts;
    __acts = __acts + 1l;
    __nacts = (unsigned int)*tmp_post_6;
    do
    {
      tmp_post_7 = __nacts;
      __nacts = __nacts - 1u;
      if(!(tmp_post_7 >= 1u))
        break;

      tmp_post_8 = __acts;
      __acts = __acts + 1l;
      switch((signed int)*tmp_post_8)
      {
        case 0:
        {
          fsd_exc_raise_fmt(1005, "time delta syntax error: %s", string);
          break;
        }
        case 1:
        {
          tmp_post_9 = n_fields;
          n_fields = n_fields + 1;
          fields[(signed long int)tmp_post_9] = v;
        }
      }
    }
    while((_Bool)1);
  }


_out:
  ;
  timedelta = 0;
  i = 0;
  for( ; !(i >= n_fields); i = i + 1)
  {
    timedelta = timedelta * 60;
    timedelta = timedelta + fields[(signed long int)i];
  }

__CPROVER_DUMP_L30:
  ;
  return timedelta;
}

// fsd_pipe
// file exec.c line 49
static void fsd_pipe(signed int *fds)
{
  signed int ret;
  signed int i;
  signed int count = 0;
  signed int tmp[3l];

__CPROVER_DUMP_L1:
  ;
  i = 0;
  for( ; !(i >= 3); i = i + 1)
    tmp[(signed long int)i] = -1;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
    fds[(signed long int)i] = -1;
  ret=pipe(fds);
  if(ret == -1)
    fsd_exc_raise_sys(0);

  i = 0;
  signed int tmp_post_1;
  for( ; !(i >= 2); i = i + 1)
    while(!(fds[(signed long int)i] >= 3))
    {
      tmp_post_1 = count;
      count = count + 1;
      tmp[(signed long int)tmp_post_1] = fds[(signed long int)i];
      fds[(signed long int)i]=dup(fds[(signed long int)i]);
      if(fds[(signed long int)i] == -1)
        ret = -1;

    }
  i = 0;
  for( ; !(i >= count); i = i + 1)
    close(tmp[(signed long int)i]);
  if(ret == -1)
  {
    i = 0;
    for( ; !(i >= 2); i = i + 1)
      if(!(fds[(signed long int)i] == -1))
        close(fds[(signed long int)i]);

    fsd_exc_raise_sys(0);
  }

}

// fsd_read_file
// file ../drmaa_utils/util.h line 136
void fsd_read_file(const char *filename, _Bool must_exist, char **content, unsigned long int *length)
{
  volatile signed int fd = -1;
  char * volatile buffer = (char *)(void *)0;
  unsigned long int size = (unsigned long int)0;
  unsigned long int capacity = (unsigned long int)0;
  signed long int n_read;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_read_file", 498);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        *content = (char *)(void *)0;
        *length = (unsigned long int)0;
        fd=open(filename, 00);
        if(fd == -1)
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          if(*return_value___errno_location_1 == 2 && must_exist == (_Bool)0)
          {
            *content = (char *)(void *)0;
            *length = (unsigned long int)0;
          }

          else
            fsd_exc_raise_sys(0);
        }

        else
        {
          do
          {
            capacity = size + (unsigned long int)1024;
            fsd_realloc_((void **)(void *)&buffer, capacity * sizeof(char) /*1ul*/ );
            n_read=read(fd, (void *)buffer, capacity - size);
            if(n_read == -1l)
              fsd_exc_raise_sys(0);

            else
              size = size + (unsigned long int)n_read;
          }
          while(!(n_read == 0l));
          fsd_realloc_((void **)(void *)&buffer, (size + (unsigned long int)1) * sizeof(char) /*1ul*/ );
          buffer[(signed long int)size] = (char)0;
        }
        break;
      }
      case -1:
      {
        *content = buffer;
        buffer = (char *)(void *)0;
        *length = size;
        break;
      }
      case -2:
      {
        fsd_free((void *)buffer);
        if(fd >= 0)
          close(fd);

      }
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L14:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
}

// fsd_readline
// file fsd_util.c line 580
char * fsd_readline(struct _IO_FILE *f)
{
  char * volatile buffer = (char *)(void *)0;
  char * volatile result = (char *)(void *)0;
  unsigned long int size = (unsigned long int)1024;
  signed int ch = 0;
  signed int index = 0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_readline", 588);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  signed int tmp_post_2;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    switch(_fsd_exc_rc)
    {
      case 0:
      {
        fsd_calloc_((void **)(void *)&buffer, size + (unsigned long int)1, sizeof(char) /*1ul*/ );
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        do
        {
          ch=_IO_getc(f);
          if(ch == -1)
            break;

          if(ch == 10)
            break;

          if(index >= (signed int)size)
          {
            size = size * (unsigned long int)2;
            fsd_realloc_((void **)(void *)&buffer, (size + (unsigned long int)1) * sizeof(char) /*1ul*/ );
          }

          tmp_post_2 = index;
          index = index + 1;
          buffer[(signed long int)tmp_post_2] = (char)ch;
        }
        while((_Bool)1);
        if(ch == 10)
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          if(ch == -1)
          {
            return_value___errno_location_5=__errno_location();
            tmp_if_expr_6 = !(*return_value___errno_location_5 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          if(index == 0)
            result = (char *)(void *)0;

          else
          {
            buffer[(signed long int)index] = (char)0;
            result=fsd_strdup(buffer);
          }
        }

        else
        {
          if(ch == -1)
          {
            return_value___errno_location_3=__errno_location();
            tmp_if_expr_4 = *return_value___errno_location_3 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            fsd_exc_raise_sys(0);

          else

            __CPROVER_DUMP_L17:
              ;
        }
        break;
      }
      case -2:
        fsd_free((void *)buffer);
    }
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L21:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return result;
}

// fsd_realloc_
// file ../drmaa_utils/xmalloc.h line 67
void * fsd_realloc_(void **p, unsigned long int size)
{
  void *ptr = *p;
  signed int *return_value___errno_location_1;
  if(!(size == 0ul))
  {
    if(!(ptr == NULL))
      ptr=realloc(ptr, size);

    else
      ptr=malloc(size);
    if(!(ptr == NULL))
      *p = ptr;

    else
    {
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 12;
      fsd_exc_raise_sys(*return_value___errno_location_1);
    }
  }

  else
    if(!(ptr == NULL))
    {
      free(ptr);
      ptr = (void *)0;
      *p = ptr;
    }

  return ptr;
}

// fsd_realloc_noraise_
// file ../drmaa_utils/xmalloc.h line 83
signed int fsd_realloc_noraise_(void **p, unsigned long int size)
{
  signed int result = 0;
  void *ptr = *p;
  if(!(size == 0ul))
  {
    if(!(ptr == NULL))
      ptr=realloc(ptr, size);

    else
      ptr=malloc(size);
    if(!(ptr == NULL))
      *p = ptr;

    else
      result = 12;
  }

  else
    if(!(ptr == NULL))
    {
      free(ptr);
      ptr = (void *)0;
      *p = ptr;
    }

  return result;
}

// fsd_replace
// file fsd_util.c line 94
char * fsd_replace(char *str, const char *placeholder, const char *value)
{
  unsigned long int ph_len;
  unsigned long int v_len;
  char *found = (char *)(void *)0;
  char * volatile s = str;
  if(str == ((char *)NULL))
    fsd_exc_raise_code(1001);

  ph_len=strlen(placeholder);
  v_len=strlen(value);
  do
  {
    unsigned long int s_len;
    s_len=strlen(s);
    found=strstr(s, placeholder);
    if(!(found == ((char *)NULL)))
    {
      char * volatile result;
      unsigned long int pos = (unsigned long int)(found - s);
      struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
      signed int _fsd_exc_rc;
      _fsd_exc_try_block=fsd_exc_try("fsd_replace", 114);
      if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
        _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

      else
        _fsd_exc_rc = -3;
      while((_Bool)1)
      {
        _Bool _fsd_exc_handled = (_Bool)0;
        fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
        if(_fsd_exc_rc == -3)
          break;

        switch(_fsd_exc_rc)
        {
          case 0:
          {
            fsd_calloc_((void **)(void *)&result, (s_len - ph_len) + v_len + (unsigned long int)1, sizeof(char) /*1ul*/ );
            memcpy((void *)result, (const void *)s, pos);
            memcpy((void *)(result + (signed long int)pos), (const void *)value, v_len);
            memcpy((void *)(result + (signed long int)pos + (signed long int)v_len), (const void *)(s + (signed long int)pos + (signed long int)ph_len), (s_len - pos) - ph_len);
            result[(signed long int)((s_len - ph_len) + v_len)] = (char)0;
            break;
          }
          case -2:
          {
            fsd_free((void *)s);
            s = result;
          }
        }
        if(!(_fsd_exc_handled == (_Bool)0))
        {

        __CPROVER_DUMP_L9:
          ;
          _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
          _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
        }

      }
    }

  }
  while(!(found == ((char *)NULL)));
  return s;
}

// fsd_set_logging_fd
// file logging.c line 70
void fsd_set_logging_fd(signed int fd)
{
  fsd_logging_output = fd;
}

// fsd_set_verbosity_level
// file logging.c line 64
void fsd_set_verbosity_level(enum anonymous_7 level)
{
  fsd_verbose_level = level;
}

// fsd_snprintf
// file fsd_util.c line 266
unsigned long int fsd_snprintf(_Bool *truncated, char *str, unsigned long int size, const char *fmt, ...)
{
  void **args;
  unsigned long int result;
  args = (void **)&fmt;
  result=fsd_vsnprintf(truncated, str, size, fmt, args);
  args = ((void **)NULL);
  return result;
}

// fsd_str_append
// file fsd_util.c line 252
void fsd_str_append(_Bool *truncated, char **p, char *end, const char *fmt, ...)
{
  void **args = (void **)&fmt;
  unsigned long int return_value_fsd_vsnprintf_1;
  return_value_fsd_vsnprintf_1=fsd_vsnprintf(truncated, *p, (unsigned long int)(end - *p), fmt, args);
  *p = *p + (signed long int)return_value_fsd_vsnprintf_1;
  args = ((void **)NULL);
}

// fsd_strdup
// file ../drmaa_utils/util.h line 44
char * fsd_strdup(const char *s)
{
  char *result;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    result=strdup(s);
    if(result == ((char *)NULL))
      fsd_exc_raise_sys(12);

    return result;
  }
}

// fsd_strerror
// file exception.c line 476
const char * fsd_strerror(signed int error_code)
{
  switch(error_code)
  {
    case 0:
      return "Success.";
    case 1001:
      return "Unexpected or internal error.";
    case 1002:
      return "Not enough memory.";
    case 1003:
      return "Invalid argument value.";
    case 1004:
      return "Invalid value.";
    case 1005:
      return "Invalid value format.";
    case 1006:
      return "Vector have no more elements.";
    case 1007:
      return "Functionality is not implemented.";
    case 1008:
      return "Library is not initialized";
    case 1009:
      return "Routine returned due to time-out.";
    case 1010:
      return "Authentication failure.";
    case 1011:
      return "Authorization failure";
    case 1012:
      return "System is overloaded.  Try again later.";
    case 1013:
      return "Could not contact DRM system for this request.";
    case 1014:
      return "Unable to initialize DRM system.";
    case 1015:
      return "Disengagement from the DRM system failed.";
    case 1016:
      return "DRM rejected request due to its configuration or request attributes.";
    case 1032:
      return "No active DRMAA session.";
    case 1033:
      return "Invalid contact string.";
    case 1034:
      return "Can not determine default contact to DRM system.";
    case 1035:
      return "Contact to DRM must be set explicitly because there is no default.";
    case 1036:
      return "DRMAA session already exist.";
    case 1037:
      return "Invalid format of job attribute.";
    case 1038:
      return "Invalid value of job attribute.";
    case 1039:
      return "Value of attribute conflicts with other attribute value.";
    case 1040:
      return "Job does not exist in DRMs queue.";
    case 1041:
      return "Can not resume job (not in valid state).";
    case 1042:
      return "Can not suspend job (not in valid state).";
    case 1043:
      return "Can not hold job (not in valid state).";
    case 1044:
      return "Can not release job (not in valid state).";
    case 1045:
      return "Waiting for job to terminate finished due to time-out.";
    case 1046:
      return "Job finished but resource usage information and/or termination status could not be provided.";
    case 1052:
      return "Invalid contact string.";
    case 1053:
      return "Invalid format of job attribute.";
    case 1054:
      return "Invalid value of job attribute.";
    case 1055:
      return "Value of attribute conflicts with other attribute value.";
    case 1056:
      return "Invalid advance reservation identifier..";
    default:
      return "Unknown error code!?";
  }
}

// fsd_strerror_r
// file fsd_util.c line 393
const char * fsd_strerror_r(signed int errnum, char *buffer, unsigned long int buffer_size)
{
  char *return_value_strerror_r_1;
  return_value_strerror_r_1=strerror_r(errnum, buffer, buffer_size);
  return return_value_strerror_r_1;
}

// fsd_strndup
// file ../drmaa_utils/util.h line 45
char * fsd_strndup(const char *s, unsigned long int n)
{
  char *result;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    result=strndup(s, n);
    if(result == ((char *)NULL))
      fsd_exc_raise_sys(12);

    return result;
  }
}

// fsd_strsignal
// file fsd_util.c line 640
const char * fsd_strsignal(signed int signum)
{
  switch(signum)
  {
    case 1:
      return "SIGHUP";
    case 2:
      return "SIGINT";
    case 3:
      return "SIGQUIT";
    case 4:
      return "SIGILL";
    case 6:
      return "SIGABRT";
    case 8:
      return "SIGFPE";
    case 9:
      return "SIGKILL";
    case 11:
      return "SIGSEGV";
    case 13:
      return "SIGPIPE";
    case 14:
      return "SIGALRM";
    case 15:
      return "SIGTERM";
    case 10:
      return "SIGUSR1";
    case 12:
      return "SIGUSR2";
    case 17:
      return "SIGCHLD";
    case 18:
      return "SIGCONT";
    case 19:
      return "SIGSTOP";
    case 20:
      return "SIGTSTP";
    case 21:
      return "SIGTTIN";
    case 22:
      return "SIGTTOU";
    case 7:
      return "SIGBUS";
    case 29:
      return "SIGPOLL";
    case 27:
      return "SIGPROF";
    case 31:
      return "SIGSYS";
    case 5:
      return "SIGTRAP";
    case 23:
      return "SIGURG";
    case 26:
      return "SIGVTALRM";
    case 24:
      return "SIGXCPU";
    case 25:
      return "SIGXFSZ";
    default:
      return "unknown signal?!";
  }
}

// fsd_template_destroy
// file template.c line 134
static void fsd_template_destroy(struct fsd_template_s *self)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= self->n_attributes); i = i + 1u)
    if(!(self->attributes[(signed long int)i] == NULL))
    {
      const struct fsd_attribute_s *attr;
      attr=self->by_code(self, (signed int)i);
      if(!(attr == ((const struct fsd_attribute_s *)NULL)))
      {
        if(!(attr->is_vector == (_Bool)0))
          fsd_free_vector((char **)self->attributes[(signed long int)i]);

        else
          fsd_free(self->attributes[(signed long int)i]);
      }

    }

  fsd_free((void *)self->attributes);
  fsd_free((void *)self);
}

// fsd_template_get_attr
// file template.c line 40
static const char * fsd_template_get_attr(const struct fsd_template_s *self, const char *name)
{
  const struct fsd_attribute_s *attr = (const struct fsd_attribute_s *)(void *)0;
  if(name == ((const char *)NULL))
    fsd_exc_raise_code(1003);

  attr=self->by_name(self, name);
  _Bool tmp_if_expr_1;
  if(attr == ((const struct fsd_attribute_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = attr->is_vector != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fsd_exc_raise_fmt(1003, "invalid scalar attribute name: %s", name);

  return (const char *)self->attributes[(signed long int)attr->code];
}

// fsd_template_get_v_attr
// file template.c line 87
static const char * const * fsd_template_get_v_attr(const struct fsd_template_s *self, const char *name)
{
  const struct fsd_attribute_s *attr = (const struct fsd_attribute_s *)(void *)0;
  if(name == ((const char *)NULL))
    fsd_exc_raise_code(1003);

  attr=self->by_name(self, name);
  _Bool tmp_if_expr_1;
  if(attr == ((const struct fsd_attribute_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(attr->is_vector != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fsd_exc_raise_fmt(1003, "invalid vector attribute name: %s", name);

  return (const char * const *)self->attributes[(signed long int)attr->code];
}

// fsd_template_new
// file ../drmaa_utils/template.h line 37
struct fsd_template_s * fsd_template_new(const struct fsd_attribute_s * (*by_name_method)(const struct fsd_template_s *, const char *), const struct fsd_attribute_s * (*by_code_method)(const struct fsd_template_s *, signed int), unsigned int n_attributes)
{
  struct fsd_template_s * volatile self = (struct fsd_template_s *)(void *)0;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_template_new", 163);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      fsd_malloc_((void **)(void *)&self, sizeof(struct fsd_template_s) /*72ul*/ );
      self->attributes = (void **)(void *)0;
      self->n_attributes = (unsigned int)0;
      self->get_attr = fsd_template_get_attr;
      self->set_attr = fsd_template_set_attr;
      self->get_v_attr = fsd_template_get_v_attr;
      self->set_v_attr = fsd_template_set_v_attr;
      self->by_name = by_name_method;
      self->by_code = by_code_method;
      self->destroy = fsd_template_destroy;
      fsd_calloc_((void **)(void *)&self->attributes, (unsigned long int)n_attributes, sizeof(void *) /*8ul*/ );
      self->n_attributes = n_attributes;
      goto __CPROVER_DUMP_L7;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      if(!(self == ((struct fsd_template_s *)NULL)))
        self->destroy(self);

      fsd_exc_reraise();
    }


  __CPROVER_DUMP_L7:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L8:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return self;
}

// fsd_template_set_attr
// file template.c line 56
static void fsd_template_set_attr(struct fsd_template_s *self, const char *name, const char *value)
{
  const struct fsd_attribute_s *attr = (const struct fsd_attribute_s *)(void *)0;

__CPROVER_DUMP_L1:
  ;
  if(name == ((const char *)NULL))
    fsd_exc_raise_code(1003);

  attr=self->by_name(self, name);
  _Bool tmp_if_expr_1;
  if(attr == ((const struct fsd_attribute_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = attr->is_vector != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fsd_exc_raise_fmt(1003, "invalid scalar attribute name: %s", name);

  unsigned long int return_value_strlen_2;
  if(!(value == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(value);
    if(return_value_strlen_3 >= 16384ul)
    {
      return_value_strlen_2=strlen(value);
      fsd_exc_raise_fmt(1003, "Argument length exceeds max size: %d > %d", (signed int)return_value_strlen_2, 16 * 1024 - 1);
    }

    if(!(self->attributes[(signed long int)attr->code] == NULL))
      fsd_free(self->attributes[(signed long int)attr->code]);

    char *return_value_fsd_strdup_4;
    return_value_fsd_strdup_4=fsd_strdup(value);
    self->attributes[(signed long int)attr->code] = (void *)return_value_fsd_strdup_4;
  }

  else
    self->attributes[(signed long int)attr->code] = (void *)0;
}

// fsd_template_set_v_attr
// file template.c line 103
static void fsd_template_set_v_attr(struct fsd_template_s *self, const char *name, const char **value)
{
  const struct fsd_attribute_s *attr = (const struct fsd_attribute_s *)(void *)0;
  char ** volatile v = (char ** volatile )(void *)0;
  if(name == ((const char *)NULL))
    fsd_exc_raise_code(1003);

  attr=self->by_name(self, name);
  _Bool tmp_if_expr_1;
  if(attr == ((const struct fsd_attribute_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(attr->is_vector != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    fsd_exc_raise_fmt(1003, "invalid vector attribute name: %s", name);

  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("fsd_template_set_v_attr", 118);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(!(_fsd_exc_rc == -3))
    {
      if(_fsd_exc_rc == 0)
      {
        signed int code = attr->code;
        if(!(value == ((const char **)NULL)))
          v=fsd_copy_vector(value);

        if(!(self->attributes[(signed long int)code] == NULL))
          fsd_free_vector((char **)self->attributes[(signed long int)code]);

        self->attributes[(signed long int)code] = (void *)v;
        v = (char ** volatile )(void *)0;
        fsd_free_vector(v);
      }

      if(!(_fsd_exc_handled == (_Bool)0))
      {
        _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
        _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
      }

    }

  }
}

// fsd_thread_create
// file thread.c line 55
void fsd_thread_create(unsigned long int *thread, void * (*func)(void *), void *arg)
{
  signed int errno_ = 0;
  errno_=pthread_create(thread, (const union pthread_attr_t *)(void *)0, func, arg);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_thread_detach
// file thread.c line 73
void fsd_thread_detach(unsigned long int th)
{
  signed int errno_ = 0;
  errno_=pthread_detach(th);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_thread_id
// file ../drmaa_utils/thread.h line 122
signed int fsd_thread_id(void)
{
  signed int return_value_gettid_1;
  return_value_gettid_1=gettid();
  return (signed int)return_value_gettid_1;
}

// fsd_thread_join
// file thread.c line 64
void fsd_thread_join(unsigned long int th, void **thread_return)
{
  signed int errno_ = 0;
  errno_=pthread_join(th, thread_return);
  if(!(errno_ == 0))
    fsd_exc_raise_sys(errno_);

}

// fsd_timezone
// file datetime.c line 69
signed long int fsd_timezone(signed long int t)
{
  struct tm utc_tm;
  struct tm local_tm;
  signed int d;
  signed long int result;
  gmtime_r(&t, &utc_tm);
  localtime_r(&t, &local_tm);
  if(!(local_tm.tm_year == utc_tm.tm_year))
    d = local_tm.tm_year - utc_tm.tm_year;

  else
    if(!(local_tm.tm_mon == utc_tm.tm_mon))
      d = local_tm.tm_mon - utc_tm.tm_mon;

    else
      if(!(local_tm.tm_mday == utc_tm.tm_mday))
        d = local_tm.tm_mday - utc_tm.tm_mday;

      else
        d = 0;
  result = (signed long int)(((((local_tm.tm_hour - utc_tm.tm_hour) * 60 + local_tm.tm_min) - utc_tm.tm_min) * 60 + local_tm.tm_sec) - utc_tm.tm_sec);
  if(d >= 1)
    result = result + (signed long int)(24 * 3600);

  else
    if(!(d >= 0))
      result = result - (signed long int)(24 * 3600);

  return result;
}

// fsd_ts_add
// file fsd_util.c line 463
void fsd_ts_add(struct timespec *a, struct timespec *b)
{
  const signed int nano = 1000000000;
  a->tv_sec = a->tv_sec + b->tv_sec;
  a->tv_nsec = a->tv_nsec + b->tv_nsec;
  if(a->tv_nsec >= (signed long int)nano)
  {
    a->tv_nsec = a->tv_nsec - (signed long int)nano;
    a->tv_sec = a->tv_sec + 1l;
  }

}

// fsd_ts_cmp
// file fsd_util.c line 477
signed int fsd_ts_cmp(struct timespec *a, struct timespec *b)
{
  if(!(a->tv_sec == b->tv_sec))
    return (signed int)(a->tv_sec - b->tv_sec);

  else
    return (signed int)(a->tv_nsec - b->tv_nsec);
}

// fsd_vasprintf
// file ../drmaa_utils/util.h line 86
char * fsd_vasprintf(const char *fmt, void **args)
{
  char *result = (char *)(void *)0;
  char *fmt_buf = (char *)(void *)0;
  signed int rc;
  fmt_buf=fsd_expand_printf_ph(fmt);
  if(!(fmt_buf == ((char *)NULL)))
    fmt = fmt_buf;

  rc=vasprintf(&result, fmt, args);
  if(!(fmt_buf == ((char *)NULL)))
    fsd_free((void *)fmt_buf);

  if(rc == -1)
    fsd_exc_raise_sys(12);

  return result;
}

// fsd_vsnprintf
// file fsd_util.c line 282
unsigned long int fsd_vsnprintf(_Bool *truncated, char *str, unsigned long int size, const char *fmt, void **args)
{
  signed int n;
  char *fmt_buf = (char *)(void *)0;
  fmt_buf=fsd_expand_printf_ph(fmt);
  if(!(fmt_buf == ((char *)NULL)))
    fmt = fmt_buf;

  n=vsnprintf(str, size, fmt, args);
  if(!(fmt_buf == ((char *)NULL)))
    fsd_free((void *)fmt_buf);

  if(!(n >= 0) || (unsigned long int)n >= size)
  {
    str[(signed long int)(size - (unsigned long int)1)] = (char)0;
    *truncated = (_Bool)1;
  }

  return (unsigned long int)n;
}

// gettid
// file thread.c line 39
signed int gettid(void)
{
  signed long int return_value_syscall_1;
  return_value_syscall_1=syscall((signed long int)186);
  return (signed int)return_value_syscall_1;
}

// hash
// file drmaa_attrib.gperf line 66
static inline unsigned int hash(const char *str, unsigned int len)
{
  signed int hval = (signed int)len;
  static const unsigned char asso_values[257l] = { (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)18, (const unsigned char)47, (const unsigned char)0, (const unsigned char)47, (const unsigned char)0, (const unsigned char)47, (const unsigned char)47, (const unsigned char)20, (const unsigned char)0, (const unsigned char)13, (const unsigned char)10, (const unsigned char)5, (const unsigned char)0, (const unsigned char)5, (const unsigned char)47, (const unsigned char)5, (const unsigned char)47, (const unsigned char)0, (const unsigned char)47, (const unsigned char)15, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47, (const unsigned char)47 };
  if(!(hval == 11) && !(hval == 12) && !(hval == 13) && !(hval == 14) && !(hval == 15))
  {
    if(hval == 8 || hval == 9 || hval == 10)
      goto __CPROVER_DUMP_L2;

    hval = hval + (signed int)asso_values[(signed long int)((signed int)(unsigned char)str[(signed long int)15] + 1)];
  }

  hval = hval + (signed int)asso_values[(signed long int)(unsigned char)str[(signed long int)10]];

__CPROVER_DUMP_L2:
  ;
  return (unsigned int)hval;
}

// hashbig
// file lookup3.c line 363
unsigned int hashbig(const void *key, unsigned long int length, unsigned int initval)
{
  unsigned int a;
  unsigned int b;
  unsigned int c = 0xdeadbeef + (unsigned int)length + initval;
  b = c;
  a = b;
  if((_Bool)0)
  {
    const unsigned int *k = (const unsigned int *)key;
    for( ; length >= 13ul; k = k + (signed long int)3)
    {
      a = a + k[(signed long int)0];
      b = b + k[(signed long int)1];
      c = c + k[(signed long int)2];
      a = a - c;
      a = a ^ c << 4 ^ c >> 32 - 4;
      c = c + b;
      b = b - a;
      b = b ^ a << 6 ^ a >> 32 - 6;
      a = a + c;
      c = c - b;
      c = c ^ b << 8 ^ b >> 32 - 8;
      b = b + a;
      a = a - c;
      a = a ^ c << 16 ^ c >> 32 - 16;
      c = c + b;
      b = b - a;
      b = b ^ a << 19 ^ a >> 32 - 19;
      a = a + c;
      c = c - b;
      c = c ^ b << 4 ^ b >> 32 - 4;
      b = b + a;
      length = length - (unsigned long int)12;
    }
    switch(length)
    {
      case (unsigned long int)12:
      {
        c = c + k[(signed long int)2];
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)11:
      {
        c = c + (k[(signed long int)2] << 8);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)10:
      {
        c = c + (k[(signed long int)2] << 16);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)9:
      {
        c = c + (k[(signed long int)2] << 24);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)8:
      {
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)7:
      {
        b = b + (k[(signed long int)1] << 8);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)6:
      {
        b = b + (k[(signed long int)1] << 16);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)5:
      {
        b = b + (k[(signed long int)1] << 24);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)4:
      {
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)3:
      {
        a = a + (k[(signed long int)0] << 8);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)2:
      {
        a = a + (k[(signed long int)0] << 16);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)1:
      {
        a = a + (k[(signed long int)0] << 24);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)0:
        return c;
      default:

        __CPROVER_DUMP_L16:
          ;
    }
  }

  else
  {
    const unsigned char *hashbig__1__2__k = (const unsigned char *)key;
    for( ; length >= 13ul; hashbig__1__2__k = hashbig__1__2__k + (signed long int)12)
    {
      a = a + ((unsigned int)hashbig__1__2__k[(signed long int)0] << 24);
      a = a + ((unsigned int)hashbig__1__2__k[(signed long int)1] << 16);
      a = a + ((unsigned int)hashbig__1__2__k[(signed long int)2] << 8);
      a = a + (unsigned int)hashbig__1__2__k[(signed long int)3];
      b = b + ((unsigned int)hashbig__1__2__k[(signed long int)4] << 24);
      b = b + ((unsigned int)hashbig__1__2__k[(signed long int)5] << 16);
      b = b + ((unsigned int)hashbig__1__2__k[(signed long int)6] << 8);
      b = b + (unsigned int)hashbig__1__2__k[(signed long int)7];
      c = c + ((unsigned int)hashbig__1__2__k[(signed long int)8] << 24);
      c = c + ((unsigned int)hashbig__1__2__k[(signed long int)9] << 16);
      c = c + ((unsigned int)hashbig__1__2__k[(signed long int)10] << 8);
      c = c + (unsigned int)hashbig__1__2__k[(signed long int)11];
      a = a - c;
      a = a ^ c << 4 ^ c >> 32 - 4;
      c = c + b;
      b = b - a;
      b = b ^ a << 6 ^ a >> 32 - 6;
      a = a + c;
      c = c - b;
      c = c ^ b << 8 ^ b >> 32 - 8;
      b = b + a;
      a = a - c;
      a = a ^ c << 16 ^ c >> 32 - 16;
      c = c + b;
      b = b - a;
      b = b ^ a << 19 ^ a >> 32 - 19;
      a = a + c;
      c = c - b;
      c = c ^ b << 4 ^ b >> 32 - 4;
      b = b + a;
      length = length - (unsigned long int)12;
    }
    switch(length)
    {
      case (unsigned long int)12:
        c = c + ((unsigned int)hashbig__1__2__k[(signed long int)11] << 24);
      case (unsigned long int)11:
        c = c + ((unsigned int)hashbig__1__2__k[(signed long int)10] << 16);
      case (unsigned long int)10:
        c = c + ((unsigned int)hashbig__1__2__k[(signed long int)9] << 8);
      case (unsigned long int)9:
        c = c + (unsigned int)hashbig__1__2__k[(signed long int)8];
      case (unsigned long int)8:
        b = b + ((unsigned int)hashbig__1__2__k[(signed long int)7] << 24);
      case (unsigned long int)7:
        b = b + ((unsigned int)hashbig__1__2__k[(signed long int)6] << 16);
      case (unsigned long int)6:
        b = b + ((unsigned int)hashbig__1__2__k[(signed long int)5] << 8);
      case (unsigned long int)5:
        b = b + (unsigned int)hashbig__1__2__k[(signed long int)4];
      case (unsigned long int)4:
        a = a + ((unsigned int)hashbig__1__2__k[(signed long int)3] << 24);
      case (unsigned long int)3:
        a = a + ((unsigned int)hashbig__1__2__k[(signed long int)2] << 16);
      case (unsigned long int)2:
        a = a + ((unsigned int)hashbig__1__2__k[(signed long int)1] << 8);
      case (unsigned long int)1:
      {
        a = a + (unsigned int)hashbig__1__2__k[(signed long int)0];
        goto __CPROVER_DUMP_L33;
      }
      case (unsigned long int)0:
        return c;
      default:

        __CPROVER_DUMP_L33:
          ;
    }
  }
  c = c ^ b;
  c = c - (b << 14 ^ b >> 32 - 14);
  a = a ^ c;
  a = a - (c << 11 ^ c >> 32 - 11);
  b = b ^ a;
  b = b - (a << 25 ^ a >> 32 - 25);
  c = c ^ b;
  c = c - (b << 16 ^ b >> 32 - 16);
  a = a ^ c;
  a = a - (c << 4 ^ c >> 32 - 4);
  b = b ^ a;
  b = b - (a << 14 ^ a >> 32 - 14);
  c = c ^ b;
  c = c - (b << 24 ^ b >> 32 - 24);
  return c;
}

// hashlittle
// file ../drmaa_utils/lookup3.h line 13
unsigned int hashlittle(const void *key, unsigned long int length, unsigned int initval)
{
  unsigned int a;
  unsigned int b;
  unsigned int c = 0xdeadbeef + (unsigned int)length + initval;
  b = c;
  a = b;
  if((_Bool)0)
  {
    const unsigned int *k = (const unsigned int *)key;
    for( ; length >= 13ul; k = k + (signed long int)3)
    {
      a = a + k[(signed long int)0];
      b = b + k[(signed long int)1];
      c = c + k[(signed long int)2];
      a = a - c;
      a = a ^ c << 4 ^ c >> 32 - 4;
      c = c + b;
      b = b - a;
      b = b ^ a << 6 ^ a >> 32 - 6;
      a = a + c;
      c = c - b;
      c = c ^ b << 8 ^ b >> 32 - 8;
      b = b + a;
      a = a - c;
      a = a ^ c << 16 ^ c >> 32 - 16;
      c = c + b;
      b = b - a;
      b = b ^ a << 19 ^ a >> 32 - 19;
      a = a + c;
      c = c - b;
      c = c ^ b << 4 ^ b >> 32 - 4;
      b = b + a;
      length = length - (unsigned long int)12;
    }
    switch(length)
    {
      case (unsigned long int)12:
      {
        c = c + k[(signed long int)2];
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)11:
      {
        c = c + (k[(signed long int)2] & (unsigned int)0xffffff);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)10:
      {
        c = c + (k[(signed long int)2] & (unsigned int)0xffff);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)9:
      {
        c = c + (k[(signed long int)2] & (unsigned int)0xff);
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)8:
      {
        b = b + k[(signed long int)1];
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)7:
      {
        b = b + (k[(signed long int)1] & (unsigned int)0xffffff);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)6:
      {
        b = b + (k[(signed long int)1] & (unsigned int)0xffff);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)5:
      {
        b = b + (k[(signed long int)1] & (unsigned int)0xff);
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)4:
      {
        a = a + k[(signed long int)0];
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)3:
      {
        a = a + (k[(signed long int)0] & (unsigned int)0xffffff);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)2:
      {
        a = a + (k[(signed long int)0] & (unsigned int)0xffff);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)1:
      {
        a = a + (k[(signed long int)0] & (unsigned int)0xff);
        goto __CPROVER_DUMP_L16;
      }
      case (unsigned long int)0:
        return c;
      default:

        __CPROVER_DUMP_L16:
          ;
    }
  }

  else
    if((_Bool)0)
    {
      const unsigned short int *hashlittle__1__2__k = (const unsigned short int *)key;
      for( ; length >= 13ul; hashlittle__1__2__k = hashlittle__1__2__k + (signed long int)6)
      {
        a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
        b = b + (unsigned int)hashlittle__1__2__k[(signed long int)2] + ((unsigned int)hashlittle__1__2__k[(signed long int)3] << 16);
        c = c + (unsigned int)hashlittle__1__2__k[(signed long int)4] + ((unsigned int)hashlittle__1__2__k[(signed long int)5] << 16);
        a = a - c;
        a = a ^ c << 4 ^ c >> 32 - 4;
        c = c + b;
        b = b - a;
        b = b ^ a << 6 ^ a >> 32 - 6;
        a = a + c;
        c = c - b;
        c = c ^ b << 8 ^ b >> 32 - 8;
        b = b + a;
        a = a - c;
        a = a ^ c << 16 ^ c >> 32 - 16;
        c = c + b;
        b = b - a;
        b = b ^ a << 19 ^ a >> 32 - 19;
        a = a + c;
        c = c - b;
        c = c ^ b << 4 ^ b >> 32 - 4;
        b = b + a;
        length = length - (unsigned long int)12;
      }
      switch(length)
      {
        case (unsigned long int)12:
        {
          c = c + (unsigned int)hashlittle__1__2__k[(signed long int)4] + ((unsigned int)hashlittle__1__2__k[(signed long int)5] << 16);
          b = b + (unsigned int)hashlittle__1__2__k[(signed long int)2] + ((unsigned int)hashlittle__1__2__k[(signed long int)3] << 16);
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)11:
          c = c + ((unsigned int)((signed int)hashlittle__1__2__k[(signed long int)5] & 0xff) << 16);
        case (unsigned long int)10:
        {
          c = c + (unsigned int)hashlittle__1__2__k[(signed long int)4];
          b = b + (unsigned int)hashlittle__1__2__k[(signed long int)2] + ((unsigned int)hashlittle__1__2__k[(signed long int)3] << 16);
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)9:
          c = c + (unsigned int)((signed int)hashlittle__1__2__k[(signed long int)4] & 0xff);
        case (unsigned long int)8:
        {
          b = b + (unsigned int)hashlittle__1__2__k[(signed long int)2] + ((unsigned int)hashlittle__1__2__k[(signed long int)3] << 16);
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)7:
          b = b + ((unsigned int)((signed int)hashlittle__1__2__k[(signed long int)3] & 0xff) << 16);
        case (unsigned long int)6:
        {
          b = b + (unsigned int)hashlittle__1__2__k[(signed long int)2];
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)5:
          b = b + (unsigned int)((signed int)hashlittle__1__2__k[(signed long int)2] & 0xff);
        case (unsigned long int)4:
        {
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0] + ((unsigned int)hashlittle__1__2__k[(signed long int)1] << 16);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)3:
          a = a + ((unsigned int)((signed int)hashlittle__1__2__k[(signed long int)1] & 0xff) << 16);
        case (unsigned long int)2:
        {
          a = a + (unsigned int)hashlittle__1__2__k[(signed long int)0];
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)1:
        {
          a = a + (unsigned int)((signed int)hashlittle__1__2__k[(signed long int)0] & 0xff);
          goto __CPROVER_DUMP_L33;
        }
        case (unsigned long int)0:
          return c;
        default:

          __CPROVER_DUMP_L33:
            ;
      }
    }

    else
    {
      const unsigned char *hashlittle__1__3__k = (const unsigned char *)key;
      for( ; length >= 13ul; hashlittle__1__3__k = hashlittle__1__3__k + (signed long int)12)
      {
        a = a + (unsigned int)hashlittle__1__3__k[(signed long int)0];
        a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)1] << 8);
        a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)2] << 16);
        a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)3] << 24);
        b = b + (unsigned int)hashlittle__1__3__k[(signed long int)4];
        b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)5] << 8);
        b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)6] << 16);
        b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)7] << 24);
        c = c + (unsigned int)hashlittle__1__3__k[(signed long int)8];
        c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)9] << 8);
        c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)10] << 16);
        c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)11] << 24);
        a = a - c;
        a = a ^ c << 4 ^ c >> 32 - 4;
        c = c + b;
        b = b - a;
        b = b ^ a << 6 ^ a >> 32 - 6;
        a = a + c;
        c = c - b;
        c = c ^ b << 8 ^ b >> 32 - 8;
        b = b + a;
        a = a - c;
        a = a ^ c << 16 ^ c >> 32 - 16;
        c = c + b;
        b = b - a;
        b = b ^ a << 19 ^ a >> 32 - 19;
        a = a + c;
        c = c - b;
        c = c ^ b << 4 ^ b >> 32 - 4;
        b = b + a;
        length = length - (unsigned long int)12;
      }
      switch(length)
      {
        case (unsigned long int)12:
          c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)11] << 24);
        case (unsigned long int)11:
          c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)10] << 16);
        case (unsigned long int)10:
          c = c + ((unsigned int)hashlittle__1__3__k[(signed long int)9] << 8);
        case (unsigned long int)9:
          c = c + (unsigned int)hashlittle__1__3__k[(signed long int)8];
        case (unsigned long int)8:
          b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)7] << 24);
        case (unsigned long int)7:
          b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)6] << 16);
        case (unsigned long int)6:
          b = b + ((unsigned int)hashlittle__1__3__k[(signed long int)5] << 8);
        case (unsigned long int)5:
          b = b + (unsigned int)hashlittle__1__3__k[(signed long int)4];
        case (unsigned long int)4:
          a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)3] << 24);
        case (unsigned long int)3:
          a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)2] << 16);
        case (unsigned long int)2:
          a = a + ((unsigned int)hashlittle__1__3__k[(signed long int)1] << 8);
        case (unsigned long int)1:
        {
          a = a + (unsigned int)hashlittle__1__3__k[(signed long int)0];
          goto __CPROVER_DUMP_L50;
        }
        case (unsigned long int)0:
          return c;
        default:

          __CPROVER_DUMP_L50:
            ;
      }
    }
  c = c ^ b;
  c = c - (b << 14 ^ b >> 32 - 14);
  a = a ^ c;
  a = a - (c << 11 ^ c >> 32 - 11);
  b = b ^ a;
  b = b - (a << 25 ^ a >> 32 - 25);
  c = c ^ b;
  c = c - (b << 16 ^ b >> 32 - 16);
  a = a ^ c;
  a = a - (c << 4 ^ c >> 32 - 4);
  b = b ^ a;
  b = b - (a << 14 ^ a >> 32 - 14);
  c = c ^ b;
  c = c - (b << 24 ^ b >> 32 - 24);
  return c;
}

// hashword
// file ../drmaa_utils/lookup3.h line 12
unsigned int hashword(const unsigned int *k, unsigned long int length, unsigned int initval)
{
  unsigned int a;
  unsigned int b;
  unsigned int c = 0xdeadbeef + ((unsigned int)length << 2) + initval;
  b = c;
  a = b;
  for( ; length >= 4ul; k = k + (signed long int)3)
  {
    a = a + k[(signed long int)0];
    b = b + k[(signed long int)1];
    c = c + k[(signed long int)2];
    a = a - c;
    a = a ^ c << 4 ^ c >> 32 - 4;
    c = c + b;
    b = b - a;
    b = b ^ a << 6 ^ a >> 32 - 6;
    a = a + c;
    c = c - b;
    c = c ^ b << 8 ^ b >> 32 - 8;
    b = b + a;
    a = a - c;
    a = a ^ c << 16 ^ c >> 32 - 16;
    c = c + b;
    b = b - a;
    b = b ^ a << 19 ^ a >> 32 - 19;
    a = a + c;
    c = c - b;
    c = c ^ b << 4 ^ b >> 32 - 4;
    b = b + a;
    length = length - (unsigned long int)3;
  }
  switch(length)
  {
    case (unsigned long int)3:
      c = c + k[(signed long int)2];
    case (unsigned long int)2:
      b = b + k[(signed long int)1];
    case (unsigned long int)1:
    {
      a = a + k[(signed long int)0];
      c = c ^ b;
      c = c - (b << 14 ^ b >> 32 - 14);
      a = a ^ c;
      a = a - (c << 11 ^ c >> 32 - 11);
      b = b ^ a;
      b = b - (a << 25 ^ a >> 32 - 25);
      c = c ^ b;
      c = c - (b << 16 ^ b >> 32 - 16);
      a = a ^ c;
      a = a - (c << 4 ^ c >> 32 - 4);
      b = b ^ a;
      b = b - (a << 14 ^ a >> 32 - 14);
      c = c ^ b;
      c = c - (b << 24 ^ b >> 32 - 24);
    }
    case (unsigned long int)0:

    default:
      return c;
  }
}

// load_drmaa
// file drmaa_run.c line 137
static struct anonymous_11 load_drmaa()
{
  struct anonymous_11 api;
  const char *path_to_drmaa;
  path_to_drmaa=getenv("DRMAA_LIBRARY_PATH");

__CPROVER_DUMP_L1:
  ;
  memset((void *)&api, 0, sizeof(struct anonymous_11) /*192ul*/ );
  if(path_to_drmaa == ((const char *)NULL))
    path_to_drmaa = "/usr/lib/slurm-drmaa/lib/libdrmaa.so";

  api.handle=dlopen(path_to_drmaa, 0x00001 | 0x00100);
  char *return_value_fsd_asprintf_1;
  char *return_value_fsd_asprintf_2;
  if(api.handle == NULL)
  {
    const char *msg;
    msg=dlerror();
    if(msg == ((const char *)NULL))
      do
        if(!((signed int)fsd_verbose_level >= 7))
        {
          return_value_fsd_asprintf_1=fsd_asprintf("Could not load DRMAA library: %s (DRMAA_LIBRARY_PATH=%s)\n", msg, path_to_drmaa);
          _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "load_drmaa", 0, return_value_fsd_asprintf_1);
        }

      while((_Bool)0);

    else
      do
        if(!((signed int)fsd_verbose_level >= 7))
        {
          return_value_fsd_asprintf_2=fsd_asprintf("Could not load DRMAA library (DRMAA_LIBRARY_PATH=%s)\n", path_to_drmaa);
          _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "load_drmaa", 0, return_value_fsd_asprintf_2);
        }

      while((_Bool)0);
    fsd_exc_raise_code(1004);
  }

  void *return_value_dlsym_3;
  return_value_dlsym_3=dlsym(api.handle, "drmaa_init");
  api.init = (signed int (*)(const char *, char *, unsigned long int))return_value_dlsym_3;
  void *return_value_dlsym_4;
  void *return_value_dlsym_5;
  void *return_value_dlsym_6;
  void *return_value_dlsym_7;
  void *return_value_dlsym_8;
  void *return_value_dlsym_9;
  void *return_value_dlsym_10;
  void *return_value_dlsym_11;
  void *return_value_dlsym_12;
  void *return_value_dlsym_13;
  void *return_value_dlsym_14;
  void *return_value_dlsym_15;
  void *return_value_dlsym_16;
  void *return_value_dlsym_17;
  void *return_value_dlsym_18;
  void *return_value_dlsym_19;
  void *return_value_dlsym_20;
  void *return_value_dlsym_21;
  void *return_value_dlsym_22;
  void *return_value_dlsym_23;
  void *return_value_dlsym_24;
  void *return_value_dlsym_25;
  char *return_value_fsd_asprintf_26;
  if(!(api.init == ((signed int (*)(const char *, char *, unsigned long int))NULL)))
  {
    return_value_dlsym_4=dlsym(api.handle, "drmaa_exit");
    api.exit = (signed int (*)(char *, unsigned long int))return_value_dlsym_4;
    if(api.exit == ((signed int (*)(char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_5=dlsym(api.handle, "drmaa_allocate_job_template");
    api.allocate_job_template = (signed int (*)(struct drmaa_job_template_s **, char *, unsigned long int))return_value_dlsym_5;
    if(api.allocate_job_template == ((signed int (*)(struct drmaa_job_template_s **, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_6=dlsym(api.handle, "drmaa_delete_job_template");
    api.delete_job_template = (signed int (*)(struct drmaa_job_template_s *, char *, unsigned long int))return_value_dlsym_6;
    if(api.delete_job_template == ((signed int (*)(struct drmaa_job_template_s *, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_7=dlsym(api.handle, "drmaa_set_attribute");
    api.set_attribute = (signed int (*)(struct drmaa_job_template_s *, const char *, const char *, char *, unsigned long int))return_value_dlsym_7;
    if(api.set_attribute == ((signed int (*)(struct drmaa_job_template_s *, const char *, const char *, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_8=dlsym(api.handle, "drmaa_get_attribute");
    api.get_attribute = (signed int (*)(struct drmaa_job_template_s *, const char *, char *, unsigned long int, char *, unsigned long int))return_value_dlsym_8;
    if(api.get_attribute == ((signed int (*)(struct drmaa_job_template_s *, const char *, char *, unsigned long int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_9=dlsym(api.handle, "drmaa_set_vector_attribute");
    api.set_vector_attribute = (signed int (*)(struct drmaa_job_template_s *, const char *, const char **, char *, unsigned long int))return_value_dlsym_9;
    if(api.set_vector_attribute == ((signed int (*)(struct drmaa_job_template_s *, const char *, const char **, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_10=dlsym(api.handle, "drmaa_get_vector_attribute");
    api.get_vector_attribute = (signed int (*)(struct drmaa_job_template_s *, const char *, struct drmaa_attr_values_s **, char *, unsigned long int))return_value_dlsym_10;
    if(api.get_vector_attribute == ((signed int (*)(struct drmaa_job_template_s *, const char *, struct drmaa_attr_values_s **, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_11=dlsym(api.handle, "drmaa_run_job");
    api.run_job = (signed int (*)(char *, unsigned long int, const struct drmaa_job_template_s *, char *, unsigned long int))return_value_dlsym_11;
    if(api.run_job == ((signed int (*)(char *, unsigned long int, const struct drmaa_job_template_s *, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_12=dlsym(api.handle, "drmaa_control");
    api.control = (signed int (*)(const char *, signed int, char *, unsigned long int))return_value_dlsym_12;
    if(api.control == ((signed int (*)(const char *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_13=dlsym(api.handle, "drmaa_job_ps");
    api.job_ps = (signed int (*)(const char *, signed int *, char *, unsigned long int))return_value_dlsym_13;
    if(api.job_ps == ((signed int (*)(const char *, signed int *, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_14=dlsym(api.handle, "drmaa_wait");
    api.wait = (signed int (*)(const char *, char *, unsigned long int, signed int *, signed long int, struct drmaa_attr_values_s **, char *, unsigned long int))return_value_dlsym_14;
    if(api.wait == ((signed int (*)(const char *, char *, unsigned long int, signed int *, signed long int, struct drmaa_attr_values_s **, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_15=dlsym(api.handle, "drmaa_wifexited");
    api.wifexited = (signed int (*)(signed int *, signed int, char *, unsigned long int))return_value_dlsym_15;
    if(api.wifexited == ((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_16=dlsym(api.handle, "drmaa_wexitstatus");
    api.wexitstatus = (signed int (*)(signed int *, signed int, char *, unsigned long int))return_value_dlsym_16;
    if(api.wexitstatus == ((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_17=dlsym(api.handle, "drmaa_wifsignaled");
    api.wifsignaled = (signed int (*)(signed int *, signed int, char *, unsigned long int))return_value_dlsym_17;
    if(api.wifsignaled == ((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_18=dlsym(api.handle, "drmaa_wtermsig");
    api.wtermsig = (signed int (*)(char *, unsigned long int, signed int, char *, unsigned long int))return_value_dlsym_18;
    if(api.wtermsig == ((signed int (*)(char *, unsigned long int, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_19=dlsym(api.handle, "drmaa_wcoredump");
    api.wcoredump = (signed int (*)(signed int *, signed int, char *, unsigned long int))return_value_dlsym_19;
    if(api.wcoredump == ((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_20=dlsym(api.handle, "drmaa_wifaborted");
    api.wifaborted = (signed int (*)(signed int *, signed int, char *, unsigned long int))return_value_dlsym_20;
    if(api.wifaborted == ((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_21=dlsym(api.handle, "drmaa_strerror");
    api.strerror = (char (*)(signed int))return_value_dlsym_21;
    if(api.strerror == ((char (*)(signed int))NULL))
      goto fault;

    return_value_dlsym_22=dlsym(api.handle, "drmaa_get_contact");
    api.get_contact = (signed int (*)(char *, unsigned long int, char *, unsigned long int))return_value_dlsym_22;
    if(api.get_contact == ((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_23=dlsym(api.handle, "drmaa_version");
    api.version = (signed int (*)(unsigned int *, unsigned int *, char *, unsigned long int))return_value_dlsym_23;
    if(api.version == ((signed int (*)(unsigned int *, unsigned int *, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_24=dlsym(api.handle, "drmaa_get_DRM_system");
    api.get_DRM_system = (signed int (*)(char *, unsigned long int, char *, unsigned long int))return_value_dlsym_24;
    if(api.get_DRM_system == ((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL))
      goto fault;

    return_value_dlsym_25=dlsym(api.handle, "drmaa_get_DRMAA_implementation");
    api.get_DRMAA_implementation = (signed int (*)(char *, unsigned long int, char *, unsigned long int))return_value_dlsym_25;
    if(api.get_DRMAA_implementation == ((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL))
      goto fault;

    return api;
  }

  else
  {

  fault:
    ;
    do
      if(!((signed int)fsd_verbose_level >= 7))
      {
        return_value_fsd_asprintf_26=fsd_asprintf("Failed to dlsym DRMAA function");
        _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "load_drmaa", 0, return_value_fsd_asprintf_26);
      }

    while((_Bool)0);
    if(!(api.handle == NULL))
      dlclose(api.handle);

    memset((void *)&api, 0, sizeof(struct anonymous_11) /*192ul*/ );
    return api;
  }
}

// main
// file drmaa_run.c line 109
signed int main(signed int argc, char **argv)
{
  struct anonymous_11 drmaa_api = { .init=((signed int (*)(const char *, char *, unsigned long int))NULL), .exit=((signed int (*)(char *, unsigned long int))NULL),
    .allocate_job_template=((signed int (*)(struct drmaa_job_template_s **, char *, unsigned long int))NULL),
    .delete_job_template=((signed int (*)(struct drmaa_job_template_s *, char *, unsigned long int))NULL),
    .set_attribute=((signed int (*)(struct drmaa_job_template_s *, const char *, const char *, char *, unsigned long int))NULL),
    .get_attribute=((signed int (*)(struct drmaa_job_template_s *, const char *, char *, unsigned long int, char *, unsigned long int))NULL),
    .set_vector_attribute=((signed int (*)(struct drmaa_job_template_s *, const char *, const char **, char *, unsigned long int))NULL),
    .get_vector_attribute=((signed int (*)(struct drmaa_job_template_s *, const char *, struct drmaa_attr_values_s **, char *, unsigned long int))NULL),
    .run_job=((signed int (*)(char *, unsigned long int, const struct drmaa_job_template_s *, char *, unsigned long int))NULL),
    .control=((signed int (*)(const char *, signed int, char *, unsigned long int))NULL),
    .job_ps=((signed int (*)(const char *, signed int *, char *, unsigned long int))NULL),
    .wait=((signed int (*)(const char *, char *, unsigned long int, signed int *, signed long int, struct drmaa_attr_values_s **, char *, unsigned long int))NULL),
    .wifexited=((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL),
    .wexitstatus=((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL),
    .wifsignaled=((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL),
    .wtermsig=((signed int (*)(char *, unsigned long int, signed int, char *, unsigned long int))NULL),
    .wcoredump=((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL),
    .wifaborted=((signed int (*)(signed int *, signed int, char *, unsigned long int))NULL),
    .strerror=((char (*)(signed int))NULL),
    .get_contact=((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL),
    .version=((signed int (*)(unsigned int *, unsigned int *, char *, unsigned long int))NULL),
    .get_DRM_system=((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL),
    .get_DRMAA_implementation=((signed int (*)(char *, unsigned long int, char *, unsigned long int))NULL),
    .handle=(void *)0 };
  struct anonymous_12 run_opt;
  signed int status = -1;

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("main", 117);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_asprintf_1;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(!(_fsd_exc_rc == 0))
    {
      if(_fsd_exc_rc == -2)
        goto __CPROVER_DUMP_L10;

    }

    else
    {
      drmaa_api=load_drmaa();
      run_opt=parse_args(argc, argv);
      status=run_and_wait(drmaa_api, run_opt);
      goto __CPROVER_DUMP_L11;
    }
    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      do
        if(!((signed int)fsd_verbose_level >= 7))
        {
          return_value_fsd_asprintf_1=fsd_asprintf("Error");
          _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "main", 0, return_value_fsd_asprintf_1);
        }

      while((_Bool)0);
    }

    goto __CPROVER_DUMP_L11;

  __CPROVER_DUMP_L10:
    ;
    unload_drmaa(&drmaa_api);

  __CPROVER_DUMP_L11:
    ;
    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L12:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  exit(status);
}

// parse_args
// file drmaa_run.c line 236
static struct anonymous_12 parse_args(signed int argc, char **argv)
{
  struct anonymous_12 options;
  memset((void *)&options, 0, sizeof(struct anonymous_12) /*56ul*/ );
  argv = argv + 1l;
  argc = argc - 1;
  char *return_value_fsd_asprintf_1;
  char *return_value_fsd_asprintf_2;
  while(argc >= 0)
  {
    if(!((signed int)*(*argv) == 45))
      break;

    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(argv[(signed long int)0], "-native=", (unsigned long int)8);
    if(return_value_strncmp_3 == 0)
    {
      options.native_specification = argv[(signed long int)0] + (signed long int)8;
      do
        if(!((signed int)fsd_verbose_level >= 4))
        {
          return_value_fsd_asprintf_1=fsd_asprintf("native specification = '%s'", options.native_specification);
          _fsd_log(FSD_LOG_INFO, "drmaa_run.c", "parse_args", 0, return_value_fsd_asprintf_1);
        }

      while((_Bool)0);
    }

    else
    {
      do
        if(!((signed int)fsd_verbose_level >= 7))
        {
          return_value_fsd_asprintf_2=fsd_asprintf("unknown option: %s", argv[(signed long int)0]);
          _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "parse_args", 0, return_value_fsd_asprintf_2);
        }

      while((_Bool)0);
      exit(1);
    }
    argv = argv + 1l;
    argc = argc - 1;
  }
  options.command = argv[(signed long int)0];
  argv = argv + 1l;
  argc = argc - 1;
  options.command_args = argv;
  options.command_argc = argc;
  return options;
}

// run_and_wait
// file drmaa_run.c line 271
static signed int run_and_wait(struct anonymous_11 api, struct anonymous_12 run_opt)
{
  char working_directory[1024l] = { '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct drmaa_job_template_s *jt = (struct drmaa_job_template_s *)(void *)0;
  char errbuf[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char stdin_name[1048l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char stdout_name[1048l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char stderr_name[1048l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char jobid[128l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int status;
  signed int return_value;
  return_value=api.init((const char *)(void *)0, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
  signed int return_value_1;
  signed int return_value_2;
  signed int return_value_4;
  signed int return_value_5;
  signed int return_value_6;
  signed int return_value_getpid_1;
  signed int return_value_getpid_2;
  signed int return_value_getpid_3;
  signed int return_value_isatty_5;
  signed int return_value_8;
  signed int return_value_9;
  signed int return_value_10;
  char *return_value_fsd_asprintf_6;
  signed int return_value_11;
  char *return_value_fsd_asprintf_7;
  char *return_value_fsd_asprintf_8;
  char *return_value_fsd_asprintf_9;
  char *return_value_fsd_asprintf_10;
  char *return_value_fsd_asprintf_13;
  unsigned long int return_value_strlen_16;
  char *return_value_fsd_asprintf_17;
  if(return_value == 0)
  {
    return_value_1=api.allocate_job_template(&jt, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
    if(return_value_1 == 0)
    {
      return_value_2=api.set_attribute(jt, "drmaa_remote_command", run_opt.command, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
      if(return_value_2 == 0)
      {
        if(run_opt.command_argc >= 1)
        {
          char **args_vector = (char **)(void *)0;
          signed int i;
          fsd_calloc_((void **)(void *)&args_vector, (unsigned long int)(run_opt.command_argc + 1), sizeof(char *) /*8ul*/ );
          i = 0;
          if(!(i >= run_opt.command_argc))
          {
            args_vector[(signed long int)i] = run_opt.command_args[(signed long int)i];
            i = i + 1;
          }

          signed int return_value_3;
          return_value_3=api.set_vector_attribute(jt, "drmaa_v_argv", (const char **)args_vector, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
        }

        unsetenv("module");
        return_value_4=api.set_vector_attribute(jt, "drmaa_v_env", (const char **)environ, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
        if(return_value_4 == 0)
        {
          getcwd(working_directory, sizeof(char [1024l]) /*1024ul*/ );
          return_value_5=api.set_attribute(jt, "drmaa_wd", working_directory, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
          if(return_value_5 == 0)
          {
            if(!(run_opt.native_specification == ((char *)NULL)))
              return_value_6=api.set_attribute(jt, "drmaa_native_specification", run_opt.native_specification, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);

            return_value_getpid_1=getpid();
            sprintf(stdin_name, ":%s/.stdin.%u", (const void *)working_directory, (unsigned int)return_value_getpid_1);
            return_value_getpid_2=getpid();
            sprintf(stdout_name, ":%s/.stdout.%u", (const void *)working_directory, (unsigned int)return_value_getpid_2);
            return_value_getpid_3=getpid();
            sprintf(stderr_name, ":%s/.stderr.%u", (const void *)working_directory, (unsigned int)return_value_getpid_3);
            return_value_isatty_5=isatty(0);
            if(return_value_isatty_5 == 0)
            {
              signed int run_and_wait__1__2__fd = -1;
              char buf[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
              signed int bread = -1;
              run_and_wait__1__2__fd=open(stdin_name + (signed long int)1, 01 | 0200 | 0100, 0600);
              if(!(run_and_wait__1__2__fd >= 0))
              {
                perror("open failed:");
                exit(3);
              }

              signed long int return_value_read_4;
              return_value_read_4=read(0, (void *)buf, sizeof(char [1024l]) /*1024ul*/ );
              bread = (signed int)return_value_read_4;
              if(bread >= 1)
                write(run_and_wait__1__2__fd, (const void *)buf, (unsigned long int)bread);

              close(run_and_wait__1__2__fd);
              signed int return_value_7;
              return_value_7=api.set_attribute(jt, "drmaa_input_path", stdin_name, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
            }

            return_value_8=api.set_attribute(jt, "drmaa_output_path", stdout_name, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
            if(return_value_8 == 0)
            {
              return_value_9=api.set_attribute(jt, "drmaa_error_path", stderr_name, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
              if(return_value_9 == 0)
              {
                return_value_10=api.run_job(jobid, sizeof(char [128l]) /*128ul*/  - (unsigned long int)1, jt, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
                if(!(return_value_10 == 0))
                {
                  if(!((signed int)fsd_verbose_level >= 7))
                  {
                    return_value_fsd_asprintf_6=fsd_asprintf("Failed to submit a job: %s ", (const void *)errbuf);
                    _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_6);
                  }

                  exit(2);
                }

                return_value_11=api.wait(jobid, (char *)(void *)0, (unsigned long int)0, &status, (signed long int)-1, (struct drmaa_attr_values_s **)(void *)0, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
                if(!(return_value_11 == 0))
                {
                  if(!((signed int)fsd_verbose_level >= 7))
                  {
                    return_value_fsd_asprintf_7=fsd_asprintf("Failed to wait for a job %s: %s ", (const void *)jobid, (const void *)errbuf);
                    _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_7);
                  }

                  exit(132);
                }

                char run_and_wait__1__5__buf[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                struct stat stat_buf;
                signed int breads;
                signed int tries_count = 0;
                if(!((signed int)fsd_verbose_level >= 4))
                {
                  return_value_fsd_asprintf_8=fsd_asprintf("opening stdout file: %s", (const void *)stdout_name);
                  _fsd_log(FSD_LOG_INFO, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_8);
                }


              retry1:
                ;
                signed int return_value_stat_12;
                return_value_stat_12=stat(stdout_name + (signed long int)1, &stat_buf);
                if(return_value_stat_12 == -1)
                {
                  if(tries_count >= 4)
                  {
                    if(!((signed int)fsd_verbose_level >= 7))
                    {
                      return_value_fsd_asprintf_9=fsd_asprintf("Failed to get stdout (%s) of job %s", stdout_name + (signed long int)1, (const void *)jobid);
                      _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_9);
                    }

                  }

                  else
                  {
                    sleep((unsigned int)3);
                    tries_count = tries_count + 1;
                  }
                }

                else
                {
                  signed int run_and_wait__1__5__3__fd;
                  run_and_wait__1__5__3__fd=open(stdout_name + (signed long int)1, 00);
                  if(!(run_and_wait__1__5__3__fd >= 0))
                  {
                    perror("open failed");
                    exit(3);
                  }

                  if(!((signed int)fsd_verbose_level >= 4))
                  {
                    return_value_fsd_asprintf_10=fsd_asprintf("opened stdout file:%s", (const void *)stdout_name);
                    _fsd_log(FSD_LOG_INFO, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_10);
                  }

                  signed long int return_value_read_11;
                  return_value_read_11=read(run_and_wait__1__5__3__fd, (void *)run_and_wait__1__5__buf, sizeof(char [1024l]) /*1024ul*/ );
                  breads = (signed int)return_value_read_11;
                  if(breads >= 1)
                    write(1, (const void *)run_and_wait__1__5__buf, (unsigned long int)breads);

                  close(run_and_wait__1__5__3__fd);
                  unlink(stdout_name + (signed long int)1);
                }

              retry2:
                ;
                signed int return_value_stat_15;
                return_value_stat_15=stat(stderr_name + (signed long int)1, &stat_buf);
                if(return_value_stat_15 == -1)
                {
                  if(tries_count >= 4)
                  {
                    if(!((signed int)fsd_verbose_level >= 7))
                    {
                      return_value_fsd_asprintf_13=fsd_asprintf("Failed to get stderr (%s) of job %s\n", stderr_name + (signed long int)1, (const void *)jobid);
                      _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_13);
                    }

                  }

                  else
                  {
                    sleep((unsigned int)3);
                    tries_count = tries_count + 1;
                  }
                }

                else
                {
                  signed int fd;
                  fd=open(stderr_name + (signed long int)1, 00);
                  if(!(fd >= 0))
                  {
                    perror("open failed");
                    exit(3);
                  }

                  signed long int return_value_read_14;
                  return_value_read_14=read(fd, (void *)run_and_wait__1__5__buf, sizeof(char [1024l]) /*1024ul*/ );
                  breads = (signed int)return_value_read_14;
                  if(breads >= 1)
                    write(2, (const void *)run_and_wait__1__5__buf, (unsigned long int)breads);

                  close(fd);
                  unlink(stderr_name + (signed long int)1);
                }
                return_value_strlen_16=strlen(stdin_name);
                if(!(return_value_strlen_16 == 0ul))
                  unlink(stdin_name + (signed long int)1);

                signed int exited = 0;
                signed int signaled = 0;
                signed int exit_status = 1;
                signed int return_value_12;
                return_value_12=api.wifexited(&exited, status, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
                if(return_value_12 == 0)
                {
                  signed int return_value_13;
                  return_value_13=api.wifsignaled(&signaled, status, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
                  if(return_value_13 == 0)
                  {
                    if(!(exited == 0))
                      api.wexitstatus(&exit_status, status, errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);

                    else
                      if(!(signaled == 0))
                        exit_status = 128;

                      else
                        exit_status = 1;
                    api.exit(errbuf, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
                    if(!((signed int)fsd_verbose_level >= 4))
                    {
                      return_value_fsd_asprintf_17=fsd_asprintf("exit_status = %d", exit_status);
                      _fsd_log(FSD_LOG_INFO, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_17);
                    }

                    return exit_status;
                  }

                }

              }

            }

          }

        }

      }

    }

  }


fault:
  ;
  char *return_value_fsd_asprintf_18;
  if(!((signed int)fsd_verbose_level >= 7))
  {
    return_value_fsd_asprintf_18=fsd_asprintf("Error");
    _fsd_log(FSD_LOG_FATAL, "drmaa_run.c", "run_and_wait", 0, return_value_fsd_asprintf_18);
  }

  return 1;
}

// stream_ripper
// file exec.c line 314
static void * stream_ripper(void *fdp)
{
  signed int fd;
  struct fsd_iter_s *chunks = (struct fsd_iter_s *)(void *)0;
  char *content = (char *)(void *)0;
  signed long int total_bread = (signed long int)0;
  char *p = (char *)(void *)0;
  fd = *((signed int *)fdp);
  fsd_free(fdp);

__CPROVER_DUMP_L1:
  ;
  struct fsd_exc_try_block_s * volatile _fsd_exc_try_block = (struct fsd_exc_try_block_s *)(void *)0;
  signed int _fsd_exc_rc;
  _fsd_exc_try_block=fsd_exc_try("stream_ripper", 327);
  if(!(_fsd_exc_try_block == ((struct fsd_exc_try_block_s *)NULL)))
    _fsd_exc_rc=_setjmp(_fsd_exc_try_block->env);

  else
    _fsd_exc_rc = -3;
  char *return_value_fsd_asprintf_2;
  while((_Bool)1)
  {
    _Bool _fsd_exc_handled = (_Bool)0;
    fsd_exc_control(_fsd_exc_try_block, &_fsd_exc_rc);
    if(_fsd_exc_rc == -3)
      break;

    if(_fsd_exc_rc == 0)
    {
      void *return_value_fsd_calloc__1;
      return_value_fsd_calloc__1=fsd_calloc_((void **)(void *)&content, (unsigned long int)(1024 * 1024 + 1), sizeof(char) /*1ul*/ );
      content = (char *)return_value_fsd_calloc__1;
      content[(signed long int)0] = (char)0;
      while((_Bool)1)
      {
        signed long int bread = (signed long int)-1;
        if(total_bread >= 1048576l)
        {
          do
            if(!((signed int)fsd_verbose_level >= 6))
            {
              return_value_fsd_asprintf_2=fsd_asprintf("Stream buffer exceeded: %d", 1024 * 1024);
              _fsd_log(FSD_LOG_ERROR, "exec.c", "stream_ripper", 0, return_value_fsd_asprintf_2);
            }

          while((_Bool)0);
          fsd_exc_raise_fmt(1001, "Stream buffer exceeded: %d", 1024 * 1024);
        }

        bread=read(fd, (void *)(content + total_bread), (unsigned long int)((signed long int)(1024 * 1024) - total_bread));
        if(bread == -1l)
          fsd_exc_raise_sys(0);

        else
          if(bread == 0l)
            break;

          else
            total_bread = total_bread + bread;
      }
      close(fd);
      content[total_bread] = (char)0;
      pthread_exit((void *)content);
      return (void *)0;
    }

    if(_fsd_exc_rc >= 1)
    {
      _fsd_exc_handled = (_Bool)1;
      close(fd);
      pthread_exit((void *)0);
    }

    if(!(_fsd_exc_handled == (_Bool)0))
    {

    __CPROVER_DUMP_L16:
      ;
      _fsd_exc_try_block->handled_exc->destroy(_fsd_exc_try_block->handled_exc);
      _fsd_exc_try_block->handled_exc = (struct fsd_exc_s *)(void *)0;
    }

  }
  return (void *)0;
}

// strlcpy
// file compat.c line 45
unsigned long int strlcpy(char *dest, const char *src, unsigned long int size)
{
  unsigned long int result = (unsigned long int)0;
  char *tmp_post_1;
  const char *tmp_post_2;
  char *tmp_post_3;
  if(size == 0ul)
    return (unsigned long int)0;

  else
  {
    for( ; !(*src == 0); result = result + 1ul)
    {
      size = size - 1ul;
      if(!(size >= 1ul))
        break;

      tmp_post_1 = dest;
      dest = dest + 1l;
      tmp_post_2 = src;
      src = src + 1l;
      *tmp_post_1 = *tmp_post_2;
    }
    tmp_post_3 = dest;
    dest = dest + 1l;
    *tmp_post_3 = (char)0;
    return result;
  }
}

// unload_drmaa
// file drmaa_run.c line 228
static void unload_drmaa(struct anonymous_11 *drmaa_api_handle)
{

__CPROVER_DUMP_L1:
  ;
  if(!(drmaa_api_handle->handle == NULL))
    dlclose(drmaa_api_handle->handle);

}

// yyFail
// file datetime_tab.c line 758
static void yyFail(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer, const char *yymsg)
{
  if(!(yymsg == ((const char *)NULL)))
    fsd_dt_error(parser, lexer, yymsg);

  longjmp(yystackp->yyexception_buffer, 1);
}

// yyLRgotoState
// file datetime_tab.c line 1166
static inline signed int yyLRgotoState(signed int yystate, signed short int yylhs)
{
  signed int yyr = (signed int)yypgoto_link1[(signed long int)((signed int)yylhs - 11)] + yystate;
  _Bool tmp_if_expr_1;
  if(yyr >= 0 && !(yyr >= 26))
    tmp_if_expr_1 = (signed int)yycheck_link1[(signed long int)yyr] == yystate ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return (signed int)yytable_link1[(signed long int)yyr];

  else
    return (signed int)yydefgoto_link1[(signed long int)((signed int)yylhs - 11)];
}

// yyMemoryExhausted
// file datetime_tab.c line 768
static void yyMemoryExhausted(struct yyGLRStack *yystackp)
{
  longjmp(yystackp->yyexception_buffer, 2);
}

// yyaddDeferredAction
// file datetime_tab.c line 1209
static void yyaddDeferredAction(struct yyGLRStack *yystackp, unsigned long int yyk, struct yyGLRState *yystate, struct yyGLRState *rhs, signed int yyrule)
{
  struct yySemanticOption *yynewOption;
  union yyGLRStackItem *return_value_yynewGLRStackItem_1;
  return_value_yynewGLRStackItem_1=yynewGLRStackItem(yystackp, (unsigned char)0);
  yynewOption = &return_value_yynewGLRStackItem_1->yyoption;
  yynewOption->yystate = rhs;
  yynewOption->yyrule = yyrule;
  if(!(yystackp->yytops.yylookaheadNeeds[(signed long int)yyk] == 0))
  {
    yynewOption->yyrawchar = yystackp->yyrawchar;
    yynewOption->yyval = yystackp->yyval;
    yynewOption->yyloc = yystackp->yyloc;
  }

  else
    yynewOption->yyrawchar = YYEMPTY;
  yynewOption->yynext = yystate->yysemantics.yyfirstVal;
  yystate->yysemantics.yyfirstVal = yynewOption;
  do
    if(!(yystackp->yyspaceLeft >= 2ul))
      yyexpandGLRStack(yystackp);

  while((_Bool)0);
}

// yycompressStack
// file datetime_tab.c line 2069
static void yycompressStack(struct yyGLRStack *yystackp)
{
  struct yyGLRState *yyp;
  struct yyGLRState *yyq;
  struct yyGLRState *yyr;
  _Bool tmp_if_expr_1;
  if(!(yystackp->yytops.yysize == 1ul))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = yystackp->yysplitPoint == (struct yyGLRState *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    yyp = yystackp->yytops.yystates[(signed long int)0];
    yyq = yyp->yypred;
    yyr = (struct yyGLRState *)(void *)0;
    for( ; !(yyp == yystackp->yysplitPoint); yyq = yyp->yypred)
    {
      yyp->yypred = yyr;
      yyr = yyp;
      yyp = yyq;
    }
    yystackp->yyspaceLeft = yystackp->yyspaceLeft + (unsigned long int)(yystackp->yynextFree - yystackp->yyitems);
    yystackp->yynextFree = (union yyGLRStackItem *)yystackp->yysplitPoint + (signed long int)1;
    yystackp->yyspaceLeft = yystackp->yyspaceLeft - (unsigned long int)(yystackp->yynextFree - yystackp->yyitems);
    yystackp->yysplitPoint = (struct yyGLRState *)(void *)0;
    yystackp->yylastDeleted = (struct yyGLRState *)(void *)0;
    for( ; !(yyr == ((struct yyGLRState *)NULL)); yystackp->yyspaceLeft = yystackp->yyspaceLeft - (unsigned long int)1)
    {
      yystackp->yynextFree->yystate = *yyr;
      yyr = yyr->yypred;
      yystackp->yynextFree->yystate.yypred = &(yystackp->yynextFree + (signed long int)-1)->yystate;
      yystackp->yytops.yystates[(signed long int)0] = &yystackp->yynextFree->yystate;
      yystackp->yynextFree = yystackp->yynextFree + (signed long int)1;
    }
  }

}

// yydefaultAction
// file datetime_tab.c line 1127
static inline signed int yydefaultAction(signed int yystate)
{
  return (signed int)yydefact_link1[(signed long int)yystate];
}

// yydestroyGLRState
// file datetime_tab.c line 1074
static void yydestroyGLRState(const char *yymsg, struct yyGLRState *yys, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  if(!(yys->yyresolved == 0))
    yydestruct_link1(yymsg, (signed int)yystos_link1[(signed long int)yys->yylrState], &yys->yysemantics.yysval, parser, lexer);

  else
    if(!(yys->yysemantics.yyfirstVal == ((struct yySemanticOption *)NULL)))
    {
      struct yySemanticOption *yyoption = yys->yysemantics.yyfirstVal;
      struct yyGLRState *yyrh;
      signed int yyn;
      yyrh = yyoption->yystate;
      yyn=yyrhsLength(yyoption->yyrule);
      for( ; yyn >= 1; yyn = yyn - 1)
      {
        yydestroyGLRState(yymsg, yyrh, parser, lexer);
        yyrh = yyrh->yypred;
      }
    }

}

// yydestruct
// file conf_tab.c line 1052
static void yydestruct(const char *yymsg, signed int yytype, union YYSTYPE_0 *yyvaluep, struct YYLTYPE *yylocationp, struct fsd_conf_parser_s *parser, struct fsd_conf_lexer_s *lexer)
{
  (void)yyvaluep;
  (void)yylocationp;
  (void)parser;
  (void)lexer;
  if(yymsg == ((const char *)NULL))
    yymsg = "Deleting";

  switch(yytype)
  {
    case 4:
    {
      free((void *)yyvaluep->string);
      break;
    }
    case 12:
    {
      fsd_conf_dict_destroy(yyvaluep->dictionary);
      break;
    }
    case 13:
    {
      fsd_conf_dict_destroy(yyvaluep->dictionary);
      break;
    }
    case 14:
    {
      fsd_conf_dict_destroy(yyvaluep->dictionary);
      break;
    }
    case 15:
    {
      fsd_conf_dict_destroy(yyvaluep->dictionary);
      break;
    }
    case 17:
      fsd_conf_option_destroy(yyvaluep->option);
  }
}

// yydestruct_link1
// file datetime_tab.c line 1048
static void yydestruct_link1(const char *yymsg_link1, signed int yytype_link1, union YYSTYPE *yyvaluep_link1, struct fsd_dt_parser_s *parser_link1, struct fsd_dt_lexer_s *lexer_link1)
{
  (void)yyvaluep_link1;
  (void)parser_link1;
  (void)lexer_link1;
  if(yymsg_link1 == ((const char *)NULL))
    yymsg_link1 = "Deleting";

}

// yydoAction
// file datetime_tab.c line 1467
static inline enum anonymous yydoAction(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yyrule, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  signed int yynrhs;
  yynrhs=yyrhsLength(yyrule);
  if(yystackp->yysplitPoint == ((struct yyGLRState *)NULL))
  {
    union yyGLRStackItem *rhs = (union yyGLRStackItem *)yystackp->yytops.yystates[(signed long int)yyk];
    if(yyk == 0ul)
      (_Bool)1;

    else
    {
      abort();
      (_Bool)0;
    }
    yystackp->yynextFree = yystackp->yynextFree - (signed long int)yynrhs;
    yystackp->yyspaceLeft = yystackp->yyspaceLeft + (unsigned long int)yynrhs;
    yystackp->yytops.yystates[(signed long int)0] = &(yystackp->yynextFree + (signed long int)-1)->yystate;
    enum anonymous return_value_yyuserAction_1;
    return_value_yyuserAction_1=yyuserAction(yyrule, yynrhs, rhs, yyvalp, yylocp, yystackp, parser, lexer);
    return return_value_yyuserAction_1;
  }

  else
  {
    signed int yyi;
    struct yyGLRState *yys;
    union yyGLRStackItem yyrhsVals[6l];
    yyrhsVals[(signed long int)(5 + 0)].yystate.yypred = yystackp->yytops.yystates[(signed long int)yyk];
    yys = yyrhsVals[(signed long int)(5 + 0)].yystate.yypred;
    yyi = 0;
    for( ; !(yyi >= yynrhs); yyi = yyi + 1)
    {
      yys = yys->yypred;
      if(!(yys == ((struct yyGLRState *)NULL)))
        (_Bool)1;

      else
      {
        abort();
        (_Bool)0;
      }
    }
    yyupdateSplit(yystackp, yys);
    yystackp->yytops.yystates[(signed long int)yyk] = yys;
    enum anonymous return_value_yyuserAction_2;
    return_value_yyuserAction_2=yyuserAction(yyrule, yynrhs, (yyrhsVals + (signed long int)5 + (signed long int)0) - (signed long int)1, yyvalp, yylocp, yystackp, parser, lexer);
    return return_value_yyuserAction_2;
  }
}

// yyexpandGLRStack
// file datetime_tab.c line 1287
static void yyexpandGLRStack(struct yyGLRStack *yystackp)
{
  union yyGLRStackItem *yynewItems;
  union yyGLRStackItem *yyp0;
  union yyGLRStackItem *yyp1;
  unsigned long int yysize;
  unsigned long int yynewSize;
  unsigned long int yyn;
  yysize = (unsigned long int)(yystackp->yynextFree - yystackp->yyitems);
  if(yysize >= 9999ul)
    yyMemoryExhausted(yystackp);

  yynewSize = (unsigned long int)2 * yysize;
  if(yynewSize >= 10001ul)
    yynewSize = (unsigned long int)10000;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(yynewSize * sizeof(union yyGLRStackItem) /*80ul*/ );
  yynewItems = (union yyGLRStackItem *)return_value_malloc_1;
  if(yynewItems == ((union yyGLRStackItem *)NULL))
    yyMemoryExhausted(yystackp);

  yyp0 = yystackp->yyitems;
  yyp1 = yynewItems;
  yyn = yysize;
  for( ; yyn >= 1ul; yyp1 = yyp1 + (signed long int)1)
  {
    *yyp1 = *yyp0;
    if(!(*((unsigned char *)yyp0) == 0))
    {
      struct yyGLRState *yys0 = &yyp0->yystate;
      struct yyGLRState *yys1 = &yyp1->yystate;
      if(!(yys0->yypred == ((struct yyGLRState *)NULL)))
        yys1->yypred = &(yyp1 - (yyp0 - (union yyGLRStackItem *)yys0->yypred))->yystate;

      if(yys0->yyresolved == 0)
      {
        if(!(yys0->yysemantics.yyfirstVal == ((struct yySemanticOption *)NULL)))
          yys1->yysemantics.yyfirstVal = &(yyp1 - (yyp0 - (union yyGLRStackItem *)yys0->yysemantics.yyfirstVal))->yyoption;

      }

    }

    else
    {
      struct yySemanticOption *yyv0 = &yyp0->yyoption;
      struct yySemanticOption *yyv1 = &yyp1->yyoption;
      if(!(yyv0->yystate == ((struct yyGLRState *)NULL)))
        yyv1->yystate = &(yyp1 - (yyp0 - (union yyGLRStackItem *)yyv0->yystate))->yystate;

      if(!(yyv0->yynext == ((struct yySemanticOption *)NULL)))
        yyv1->yynext = &(yyp1 - (yyp0 - (union yyGLRStackItem *)yyv0->yynext))->yyoption;

    }
    yyn = yyn - (unsigned long int)1;
    yyp0 = yyp0 + (signed long int)1;
  }
  if(!(yystackp->yysplitPoint == ((struct yyGLRState *)NULL)))
    yystackp->yysplitPoint = &(yynewItems - (yystackp->yyitems - (union yyGLRStackItem *)yystackp->yysplitPoint))->yystate;

  yyn = (unsigned long int)0;
  for( ; !(yyn >= yystackp->yytops.yysize); yyn = yyn + (unsigned long int)1)
    if(!(yystackp->yytops.yystates[(signed long int)yyn] == ((struct yyGLRState *)NULL)))
      yystackp->yytops.yystates[(signed long int)yyn] = &(yynewItems - (yystackp->yyitems - (union yyGLRStackItem *)yystackp->yytops.yystates[(signed long int)yyn]))->yystate;

  free((void *)yystackp->yyitems);
  yystackp->yyitems = yynewItems;
  yystackp->yynextFree = yynewItems + (signed long int)yysize;
  yystackp->yyspaceLeft = yynewSize - yysize;
}

// yyfill
// file datetime_tab.c line 811
static inline signed int yyfill(union yyGLRStackItem *yyvsp, signed int *yylow, signed int yylow1, unsigned char yynormal)
{
  if(yynormal == 0)
  {
    if(!(yylow1 >= *yylow))
    {
      yyfillin(yyvsp, *yylow, yylow1);
      *yylow = yylow1;
    }

  }

  return yylow1;
}

// yyfillin
// file datetime_tab.c line 790
static void yyfillin(union yyGLRStackItem *yyvsp, signed int yylow0, signed int yylow1)
{
  struct yyGLRState *s;
  signed int i;
  s = (yyvsp + (signed long int)yylow0)->yystate.yypred;
  i = yylow0 - 1;
  for( ; i >= yylow1; i = i - 1)
  {
    if(!(s->yyresolved == 0))
      (_Bool)1;

    else
    {
      abort();
      (_Bool)0;
    }
    (yyvsp + (signed long int)i)->yystate.yyresolved = (unsigned char)1;
    (yyvsp + (signed long int)i)->yystate.yysemantics.yysval = s->yysemantics.yysval;
    (yyvsp + (signed long int)i)->yystate.yyloc = s->yyloc;
    (yyvsp + (signed long int)i)->yystate.yypred = s->yypred;
    s = (yyvsp + (signed long int)i)->yystate.yypred;
  }
}

// yyfreeGLRStack
// file datetime_tab.c line 1345
static void yyfreeGLRStack(struct yyGLRStack *yystackp)
{
  free((void *)yystackp->yyitems);
  yyfreeStateSet(&yystackp->yytops);
}

// yyfreeStateSet
// file datetime_tab.c line 1252
static void yyfreeStateSet(struct yyGLRStateSet *yyset)
{
  free((void *)yyset->yystates);
  free((void *)yyset->yylookaheadNeeds);
}

// yygetLRActions
// file datetime_tab.c line 1144
static inline void yygetLRActions(signed int yystate, signed int yytoken, signed int *yyaction, const signed short int **yyconflicts)
{
  signed int yyindex = (signed int)yypact_link1[(signed long int)yystate] + yytoken;
  _Bool tmp_if_expr_1;
  if(yyindex >= 26 || !(yyindex >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)yycheck_link1[(signed long int)yyindex] != yytoken ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    *yyaction = -((signed int)yydefact_link1[(signed long int)yystate]);
    *yyconflicts = yyconfl;
  }

  else
  {
    *yyaction = (signed int)yytable_link1[(signed long int)yyindex];
    *yyconflicts = yyconfl + (signed long int)yyconflp[(signed long int)yyindex];
  }
}

// yyglrReduce
// file datetime_tab.c line 1560
static inline enum anonymous yyglrReduce(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yyrule, unsigned char yyforceEval, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  unsigned long int yyposn = yystackp->yytops.yystates[(signed long int)yyk]->yyposn;
  _Bool tmp_if_expr_4;
  if(!(yyforceEval == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = yystackp->yysplitPoint == (struct yyGLRState *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    union YYSTYPE yysval;
    struct YYLTYPE_0 yyloc;
    do
    {
      enum anonymous yyflag;
      yyflag=yydoAction(yystackp, yyk, yyrule, &yysval, &yyloc, parser, lexer);
      if(!((signed int)yyflag == yyok))
        return yyflag;

    }
    while((_Bool)0);
    signed short int return_value_yylhsNonterm_1;
    return_value_yylhsNonterm_1=yylhsNonterm(yyrule);
    signed int return_value_yyLRgotoState_2;
    return_value_yyLRgotoState_2=yyLRgotoState(yystackp->yytops.yystates[(signed long int)yyk]->yylrState, return_value_yylhsNonterm_1);
    yyglrShift(yystackp, yyk, return_value_yyLRgotoState_2, yyposn, &yysval, &yyloc);
  }

  else
  {
    unsigned long int yyi;
    signed int yyn;
    struct yyGLRState *yys;
    struct yyGLRState *yys0 = yystackp->yytops.yystates[(signed long int)yyk];
    signed int yynewLRState;
    yys = yystackp->yytops.yystates[(signed long int)yyk];
    yyn=yyrhsLength(yyrule);
    for( ; yyn >= 1; yyn = yyn - 1)
    {
      yys = yys->yypred;
      if(!(yys == ((struct yyGLRState *)NULL)))
        (_Bool)1;

      else
      {
        abort();
        (_Bool)0;
      }
    }
    yyupdateSplit(yystackp, yys);
    signed short int return_value_yylhsNonterm_3;
    return_value_yylhsNonterm_3=yylhsNonterm(yyrule);
    yynewLRState=yyLRgotoState(yys->yylrState, return_value_yylhsNonterm_3);
    yyi = (unsigned long int)0;
    for( ; !(yyi >= yystackp->yytops.yysize); yyi = yyi + (unsigned long int)1)
      if(!(yyi == yyk))
      {
        if(!(yystackp->yytops.yystates[(signed long int)yyi] == ((struct yyGLRState *)NULL)))
        {
          struct yyGLRState *yyp;
          struct yyGLRState *yysplit = yystackp->yysplitPoint;
          yyp = yystackp->yytops.yystates[(signed long int)yyi];
          for( ; !(yyp == yys); yyp = yyp->yypred)
          {
            if(yyp == yysplit)
              break;

            if(!(yyp->yyposn >= yyposn))
              break;

            if(yyp->yylrState == yynewLRState)
            {
              if(yyp->yypred == yys)
              {
                yyaddDeferredAction(yystackp, yyk, yyp, yys0, yyrule);
                yymarkStackDeleted(yystackp, yyk);
                return (enum anonymous)yyok;
              }

            }

          }
        }

      }

    yystackp->yytops.yystates[(signed long int)yyk] = yys;
    yyglrShiftDefer(yystackp, yyk, yynewLRState, yyposn, yys0, yyrule);
  }
  return (enum anonymous)yyok;
}

// yyglrShift
// file datetime_tab.c line 1423
static inline void yyglrShift(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yylrState, unsigned long int yyposn, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp)
{
  struct yyGLRState *yynewState;
  union yyGLRStackItem *return_value_yynewGLRStackItem_1;
  return_value_yynewGLRStackItem_1=yynewGLRStackItem(yystackp, (unsigned char)1);
  yynewState = &return_value_yynewGLRStackItem_1->yystate;
  yynewState->yylrState = yylrState;
  yynewState->yyposn = yyposn;
  yynewState->yyresolved = (unsigned char)1;
  yynewState->yypred = yystackp->yytops.yystates[(signed long int)yyk];
  yynewState->yysemantics.yysval = *yyvalp;
  yynewState->yyloc = *yylocp;
  yystackp->yytops.yystates[(signed long int)yyk] = yynewState;
  do
    if(!(yystackp->yyspaceLeft >= 2ul))
      yyexpandGLRStack(yystackp);

  while((_Bool)0);
}

// yyglrShiftDefer
// file datetime_tab.c line 1444
static inline void yyglrShiftDefer(struct yyGLRStack *yystackp, unsigned long int yyk, signed int yylrState, unsigned long int yyposn, struct yyGLRState *rhs, signed int yyrule)
{
  struct yyGLRState *yynewState;
  union yyGLRStackItem *return_value_yynewGLRStackItem_1;
  return_value_yynewGLRStackItem_1=yynewGLRStackItem(yystackp, (unsigned char)1);
  yynewState = &return_value_yynewGLRStackItem_1->yystate;
  yynewState->yylrState = yylrState;
  yynewState->yyposn = yyposn;
  yynewState->yyresolved = (unsigned char)0;
  yynewState->yypred = yystackp->yytops.yystates[(signed long int)yyk];
  yynewState->yysemantics.yyfirstVal = (struct yySemanticOption *)(void *)0;
  yystackp->yytops.yystates[(signed long int)yyk] = yynewState;
  yyaddDeferredAction(yystackp, yyk, yynewState, rhs, yyrule);
}

// yyidenticalOptions
// file datetime_tab.c line 1670
static unsigned char yyidenticalOptions(struct yySemanticOption *yyy0, struct yySemanticOption *yyy1)
{
  if(yyy0->yyrule == yyy1->yyrule)
  {
    struct yyGLRState *yys0;
    struct yyGLRState *yys1;
    signed int yyn;
    yys0 = yyy0->yystate;
    yys1 = yyy1->yystate;
    yyn=yyrhsLength(yyy0->yyrule);
    for( ; yyn >= 1; yyn = yyn - 1)
    {
      if(!(yys0->yyposn == yys1->yyposn))
        return (unsigned char)0;

      yys0 = yys0->yypred;
      yys1 = yys1->yypred;
    }
    return (unsigned char)1;
  }

  else
    return (unsigned char)0;
}

// yyinitGLRStack
// file datetime_tab.c line 1261
static unsigned char yyinitGLRStack(struct yyGLRStack *yystackp, unsigned long int yysize)
{
  yystackp->yyerrState = 0;
  yystackp->yyerrcnt = 0;
  yystackp->yyspaceLeft = yysize;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(yysize * sizeof(union yyGLRStackItem) /*80ul*/ );
  yystackp->yyitems = (union yyGLRStackItem *)return_value_malloc_1;
  if(yystackp->yyitems == ((union yyGLRStackItem *)NULL))
    return (unsigned char)0;

  else
  {
    yystackp->yynextFree = yystackp->yyitems;
    yystackp->yysplitPoint = (struct yyGLRState *)(void *)0;
    yystackp->yylastDeleted = (struct yyGLRState *)(void *)0;
    unsigned char return_value_yyinitStateSet_2;
    return_value_yyinitStateSet_2=yyinitStateSet(&yystackp->yytops);
    return return_value_yyinitStateSet_2;
  }
}

// yyinitStateSet
// file datetime_tab.c line 1234
static unsigned char yyinitStateSet(struct yyGLRStateSet *yyset)
{
  yyset->yysize = (unsigned long int)1;
  yyset->yycapacity = (unsigned long int)16;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)16 * sizeof(struct yyGLRState *) /*8ul*/ );
  yyset->yystates = (struct yyGLRState **)return_value_malloc_1;
  if(yyset->yystates == ((struct yyGLRState **)NULL))
    return (unsigned char)0;

  else
  {
    yyset->yystates[(signed long int)0] = (struct yyGLRState *)(void *)0;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)16 * sizeof(unsigned char) /*1ul*/ );
    yyset->yylookaheadNeeds = (unsigned char *)return_value_malloc_2;
    if(yyset->yylookaheadNeeds == ((unsigned char *)NULL))
    {
      free((void *)yyset->yystates);
      return (unsigned char)0;
    }

    else
      return (unsigned char)1;
  }
}

// yyisDefaultedState
// file datetime_tab.c line 1120
static inline unsigned char yyisDefaultedState(signed int yystate)
{
  return (unsigned char)((signed int)yypact_link1[(signed long int)yystate] == -5);
}

// yyisErrorAction
// file datetime_tab.c line 1183
static inline unsigned char yyisErrorAction(signed int yyaction)
{
  return (unsigned char)(yyaction == 0);
}

// yyisShiftAction
// file datetime_tab.c line 1177
static inline unsigned char yyisShiftAction(signed int yyaction)
{
  return (unsigned char)(0 < yyaction);
}

// yylhsNonterm
// file datetime_tab.c line 1109
static inline signed short int yylhsNonterm(signed int yyrule)
{
  return (signed short int)yyr1_link1[(signed long int)yyrule];
}

// yymarkStackDeleted
// file datetime_tab.c line 1363
static inline void yymarkStackDeleted(struct yyGLRStack *yystackp, unsigned long int yyk)
{
  if(!(yystackp->yytops.yystates[(signed long int)yyk] == ((struct yyGLRState *)NULL)))
    yystackp->yylastDeleted = yystackp->yytops.yystates[(signed long int)yyk];

  yystackp->yytops.yystates[(signed long int)yyk] = (struct yyGLRState *)(void *)0;
}

// yymergeOptionSets
// file datetime_tab.c line 1691
static void yymergeOptionSets(struct yySemanticOption *yyy0, struct yySemanticOption *yyy1)
{
  struct yyGLRState *yys0;
  struct yyGLRState *yys1;
  signed int yyn;
  yys0 = yyy0->yystate;
  yys1 = yyy1->yystate;
  yyn=yyrhsLength(yyy0->yyrule);
  for( ; yyn >= 1; yyn = yyn - 1)
  {
    if(yys0 == yys1)
      break;

    else
      if(!(yys0->yyresolved == 0))
      {
        yys1->yyresolved = (unsigned char)1;
        yys1->yysemantics.yysval = yys0->yysemantics.yysval;
      }

      else
        if(!(yys1->yyresolved == 0))
        {
          yys0->yyresolved = (unsigned char)1;
          yys0->yysemantics.yysval = yys1->yysemantics.yysval;
        }

        else
        {
          struct yySemanticOption **yyz0p;
          struct yySemanticOption *yyz1;
          yyz0p = &yys0->yysemantics.yyfirstVal;
          yyz1 = yys1->yysemantics.yyfirstVal;
          for( ; (_Bool)1; yyz0p = &(*yyz0p)->yynext)
            if(yyz1 == ((struct yySemanticOption *)NULL) || yyz1 == *yyz0p)
              break;

            else
              if(*yyz0p == ((struct yySemanticOption *)NULL))
              {
                *yyz0p = yyz1;
                break;
              }

              else
                if(!(*yyz0p >= yyz1))
                {
                  struct yySemanticOption *yyz = *yyz0p;
                  *yyz0p = yyz1;
                  yyz1 = yyz1->yynext;
                  (*yyz0p)->yynext = yyz;
                }

          yys1->yysemantics.yyfirstVal = yys0->yysemantics.yyfirstVal;
        }
    yys0 = yys0->yypred;
    yys1 = yys1->yypred;
  }
}

// yynewGLRStackItem
// file datetime_tab.c line 1195
static inline union yyGLRStackItem * yynewGLRStackItem(struct yyGLRStack *yystackp, unsigned char yyisState)
{
  union yyGLRStackItem *yynewItem = yystackp->yynextFree;
  yystackp->yyspaceLeft = yystackp->yyspaceLeft - (unsigned long int)1;
  yystackp->yynextFree = yystackp->yynextFree + (signed long int)1;
  yynewItem->yystate.yyisState = yyisState;
  return yynewItem;
}

// yypreference
// file datetime_tab.c line 1745
static signed int yypreference(struct yySemanticOption *y0, struct yySemanticOption *y1)
{
  signed int r0 = y0->yyrule;
  signed int r1 = y1->yyrule;
  signed int p0 = (signed int)yydprec[(signed long int)r0];
  signed int p1 = (signed int)yydprec[(signed long int)r1];
  _Bool tmp_if_expr_1;
  if(p0 == p1)
  {
    if((signed int)yymerger[(signed long int)r0] == 0)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = yymerger[(signed long int)r0] != yymerger[(signed long int)r1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    return 1;
  }

  else
    if(p0 == 0 || p1 == 0)
      return 0;

    else
      if(!(p0 >= p1))
        return 3;

      else
        if(!(p1 >= p0))
          return 2;

        else
          return 0;
}

// yyprocessOneStack
// file datetime_tab.c line 2099
static enum anonymous yyprocessOneStack(struct yyGLRStack *yystackp, unsigned long int yyk, unsigned long int yyposn, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  signed int yyaction;
  const signed short int *yyconflicts;
  signed int yyrule;
  signed int tmp_if_expr_1;
  unsigned char return_value_yyisErrorAction_2;
  while(!(yystackp->yytops.yystates[(signed long int)yyk] == ((struct yyGLRState *)NULL)))
  {
    signed int yystate = yystackp->yytops.yystates[(signed long int)yyk]->yylrState;
    if(!(yystate == 9))
      (_Bool)1;

    else
    {
      abort();
      (_Bool)0;
    }
    unsigned char return_value_yyisDefaultedState_4;
    return_value_yyisDefaultedState_4=yyisDefaultedState(yystate);
    if(!(return_value_yyisDefaultedState_4 == 0))
    {
      yyrule=yydefaultAction(yystate);
      if(yyrule == 0)
      {
        yymarkStackDeleted(yystackp, yyk);
        return (enum anonymous)yyok;
      }

      do
      {
        enum anonymous yyflag;
        yyflag=yyglrReduce(yystackp, yyk, yyrule, (unsigned char)0, parser, lexer);
        if(!((signed int)yyflag == yyok))
          return yyflag;

      }
      while((_Bool)0);
    }

    else
    {
      signed short int yytoken;
      yystackp->yytops.yylookaheadNeeds[(signed long int)yyk] = (unsigned char)1;
      if(yystackp->yyrawchar == YYEMPTY)
        yystackp->yyrawchar=fsd_dt_lex(&yystackp->yyval, lexer);

      if(YYEOF >= yystackp->yyrawchar)
      {
        yytoken = (signed short int)YYEOF;
        yystackp->yyrawchar = (signed int)yytoken;
      }

      else
      {
        if(!((unsigned int)yystackp->yyrawchar >= 260u))
          tmp_if_expr_1 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

        else
          tmp_if_expr_1 = 2;
        yytoken = (signed short int)tmp_if_expr_1;
      }
      yygetLRActions(yystate, (signed int)yytoken, &yyaction, &yyconflicts);
      while(!((signed int)*yyconflicts == 0))
      {
        unsigned long int yynewStack;
        yynewStack=yysplitStack(yystackp, yyk);
        do
        {
          enum anonymous yyprocessOneStack__1__1__2__4__1__yyflag;
          yyprocessOneStack__1__1__2__4__1__yyflag=yyglrReduce(yystackp, yynewStack, (signed int)*yyconflicts, (unsigned char)0, parser, lexer);
          if(!((signed int)yyprocessOneStack__1__1__2__4__1__yyflag == yyok))
            return yyprocessOneStack__1__1__2__4__1__yyflag;

        }
        while((_Bool)0);
        do
        {
          enum anonymous yyprocessOneStack__1__1__2__4__2__yyflag;
          yyprocessOneStack__1__1__2__4__2__yyflag=yyprocessOneStack(yystackp, yynewStack, yyposn, parser, lexer);
          if(!((signed int)yyprocessOneStack__1__1__2__4__2__yyflag == yyok))
            return yyprocessOneStack__1__1__2__4__2__yyflag;

        }
        while((_Bool)0);
        yyconflicts = yyconflicts + (signed long int)1;
      }
      unsigned char return_value_yyisShiftAction_3;
      return_value_yyisShiftAction_3=yyisShiftAction(yyaction);
      if(!(return_value_yyisShiftAction_3 == 0))
        break;

      else
      {
        return_value_yyisErrorAction_2=yyisErrorAction(yyaction);
        if(!(return_value_yyisErrorAction_2 == 0))
        {
          yymarkStackDeleted(yystackp, yyk);
          break;
        }

        else
          do
          {
            enum anonymous yyprocessOneStack__1__1__2__6__yyflag;
            yyprocessOneStack__1__1__2__6__yyflag=yyglrReduce(yystackp, yyk, -yyaction, (unsigned char)0, parser, lexer);
            if(!((signed int)yyprocessOneStack__1__1__2__6__yyflag == yyok))
              return yyprocessOneStack__1__1__2__6__yyflag;

          }
          while((_Bool)0);
      }
    }
  }
  return (enum anonymous)yyok;
}

// yyrecoverSyntaxError
// file datetime_tab.c line 2284
static void yyrecoverSyntaxError(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  unsigned long int yyk;
  signed int yyj;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(yystackp->yyerrState == 3)
    while((_Bool)1)
    {
      signed short int yytoken;
      if(yystackp->yyrawchar == YYEOF)
        yyFail(yystackp, parser, lexer, (const char *)(void *)0);

      if(!(yystackp->yyrawchar == YYEMPTY))
      {
        if(!((unsigned int)yystackp->yyrawchar >= 260u))
          tmp_if_expr_1 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

        else
          tmp_if_expr_1 = 2;
        yytoken = (signed short int)tmp_if_expr_1;
        yydestruct_link1("Error: discarding", (signed int)yytoken, &yystackp->yyval, parser, lexer);
      }

      yystackp->yyrawchar=fsd_dt_lex(&yystackp->yyval, lexer);
      if(YYEOF >= yystackp->yyrawchar)
      {
        yytoken = (signed short int)YYEOF;
        yystackp->yyrawchar = (signed int)yytoken;
      }

      else
      {
        if(!((unsigned int)yystackp->yyrawchar >= 260u))
          tmp_if_expr_2 = (signed int)yytranslate_link1[(signed long int)yystackp->yyrawchar];

        else
          tmp_if_expr_2 = 2;
        yytoken = (signed short int)tmp_if_expr_2;
      }
      yyj = (signed int)yypact_link1[(signed long int)yystackp->yytops.yystates[(signed long int)0]->yylrState];
      if(yyj == -5)
        goto __CPROVER_DUMP_L28;

      yyj = yyj + (signed int)yytoken;
      if(yyj >= 26 || !(yyj >= 0))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)yycheck_link1[(signed long int)yyj] != (signed int)yytoken ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        if(!((signed int)yydefact_link1[(signed long int)(*yystackp->yytops.yystates)->yylrState] == 0))
          goto __CPROVER_DUMP_L28;

      }

      else
        if(!((signed int)yytable_link1[(signed long int)yyj] == 0))
          goto __CPROVER_DUMP_L28;

    }

  yyk = (unsigned long int)0;
  for( ; !(yyk >= yystackp->yytops.yysize); yyk = yyk + (unsigned long int)1)
    if(!(yystackp->yytops.yystates[(signed long int)yyk] == ((struct yyGLRState *)NULL)))
      break;

  if(yyk >= yystackp->yytops.yysize)
    yyFail(yystackp, parser, lexer, (const char *)(void *)0);

  yyk = yyk + (unsigned long int)1;
  for( ; !(yyk >= yystackp->yytops.yysize); yyk = yyk + (unsigned long int)1)
    yymarkStackDeleted(yystackp, yyk);
  yyremoveDeletes(yystackp);
  yycompressStack(yystackp);
  yystackp->yyerrState = 3;
  unsigned char return_value_yyisShiftAction_4;
  while(!(*yystackp->yytops.yystates == ((struct yyGLRState *)NULL)))
  {
    struct yyGLRState *yys = yystackp->yytops.yystates[(signed long int)0];
    yyj = (signed int)yypact_link1[(signed long int)yys->yylrState];
    if(!(yyj == -5))
    {
      yyj = yyj + 1;
      if(yyj >= 0 && !(yyj >= 26))
      {
        if((signed int)yycheck_link1[(signed long int)yyj] == 1)
        {
          return_value_yyisShiftAction_4=yyisShiftAction((signed int)yytable_link1[(signed long int)yyj]);
          if(!(return_value_yyisShiftAction_4 == 0))
          {
            struct YYLTYPE_0 yyerrloc;
            yyglrShift(yystackp, (unsigned long int)0, (signed int)yytable_link1[(signed long int)yyj], yys->yyposn, &yystackp->yyval, &yyerrloc);
            yys = yystackp->yytops.yystates[(signed long int)0];
            break;
          }

        }

      }

    }

    if(!(yys->yypred == ((struct yyGLRState *)NULL)))
      yydestroyGLRState("Error: popping", yys, parser, lexer);

    yystackp->yytops.yystates[(signed long int)0] = yys->yypred;
    yystackp->yynextFree = yystackp->yynextFree - (signed long int)1;
    yystackp->yyspaceLeft = yystackp->yyspaceLeft + (unsigned long int)1;
  }
  if(*yystackp->yytops.yystates == ((struct yyGLRState *)NULL))
    yyFail(yystackp, parser, lexer, (const char *)(void *)0);


__CPROVER_DUMP_L28:
  ;
}

// yyremoveDeletes
// file datetime_tab.c line 1385
static inline void yyremoveDeletes(struct yyGLRStack *yystackp)
{
  unsigned long int yyi;
  unsigned long int yyj = (unsigned long int)0;
  yyi = yyj;
  for( ; !(yyj >= yystackp->yytops.yysize); yyi = yyi + (unsigned long int)1)
    if(yystackp->yytops.yystates[(signed long int)yyi] == ((struct yyGLRState *)NULL))
      yystackp->yytops.yysize = yystackp->yytops.yysize - (unsigned long int)1;

    else
    {
      yystackp->yytops.yystates[(signed long int)yyj] = yystackp->yytops.yystates[(signed long int)yyi];
      yystackp->yytops.yylookaheadNeeds[(signed long int)yyj] = yystackp->yytops.yylookaheadNeeds[(signed long int)yyi];
      yyj = yyj + (unsigned long int)1;
    }
}

// yyreportAmbiguity
// file datetime_tab.c line 1879
static enum anonymous yyreportAmbiguity(struct yySemanticOption *yyx0, struct yySemanticOption *yyx1, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  (void)yyx0;
  (void)yyx1;
  fsd_dt_error(parser, lexer, "syntax is ambiguous");
  return (enum anonymous)yyabort;
}

// yyreportSyntaxError
// file datetime_tab.c line 2180
static void yyreportSyntaxError(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  if(yystackp->yyerrState == 0)
  {
    fsd_dt_error(parser, lexer, "syntax error");
    yystackp->yyerrcnt = yystackp->yyerrcnt + 1;
  }

}

// yyresolveAction
// file datetime_tab.c line 1794
static enum anonymous yyresolveAction(struct yySemanticOption *yyopt, struct yyGLRStack *yystackp, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  union yyGLRStackItem yyrhsVals[6l];
  signed int yynrhs;
  signed int yychar_current;
  union YYSTYPE yylval_current;
  struct YYLTYPE_0 yylloc_current;
  enum anonymous yyflag;
  yynrhs=yyrhsLength(yyopt->yyrule);
  yyflag=yyresolveStates(yyopt->yystate, yynrhs, yystackp, parser, lexer);
  if(!((signed int)yyflag == yyok))
  {
    struct yyGLRState *yys = yyopt->yystate;
    for( ; yynrhs >= 1; yynrhs = yynrhs - 1)
    {
      yydestroyGLRState("Cleanup: popping", yys, parser, lexer);
      yys = yys->yypred;
    }
    return yyflag;
  }

  yyrhsVals[(signed long int)(5 + 0)].yystate.yypred = yyopt->yystate;
  yychar_current = yystackp->yyrawchar;
  yylval_current = yystackp->yyval;
  yylloc_current = yystackp->yyloc;
  yystackp->yyrawchar = yyopt->yyrawchar;
  yystackp->yyval = yyopt->yyval;
  yystackp->yyloc = yyopt->yyloc;
  yyflag=yyuserAction(yyopt->yyrule, yynrhs, (yyrhsVals + (signed long int)5 + (signed long int)0) - (signed long int)1, yyvalp, yylocp, yystackp, parser, lexer);
  yystackp->yyrawchar = yychar_current;
  yystackp->yyval = yylval_current;
  yystackp->yyloc = yylloc_current;
  return yyflag;
}

// yyresolveLocations
// file datetime_tab.c line 1902
static void yyresolveLocations(struct yyGLRState *yys1, signed int yyn1, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  if(yyn1 >= 1)
  {
    yyresolveLocations(yys1->yypred, yyn1 - 1, yystackp, parser, lexer);
    if(yys1->yyresolved == 0)
    {
      struct yySemanticOption *yyoption;
      union yyGLRStackItem yyrhsloc[6l];
      signed int yynrhs;
      signed int yychar_current;
      union YYSTYPE yylval_current;
      struct YYLTYPE_0 yylloc_current;
      yyoption = yys1->yysemantics.yyfirstVal;
      if(!(yyoption == ((struct yySemanticOption *)NULL)))
        (_Bool)1;

      else
      {
        abort();
        (_Bool)0;
      }
      yynrhs=yyrhsLength(yyoption->yyrule);
      if(yynrhs >= 1)
      {
        struct yyGLRState *yys;
        signed int yyn;
        yyresolveLocations(yyoption->yystate, yynrhs, yystackp, parser, lexer);
        yys = yyoption->yystate;
        yyn = yynrhs;
        for( ; yyn >= 1; yyn = yyn - 1)
        {
          yyrhsloc[(signed long int)yyn].yystate.yyloc = yys->yyloc;
          yys = yys->yypred;
        }
      }

      else
      {
        struct yyGLRState *yyprevious = yyoption->yystate;
        yyrhsloc[(signed long int)0].yystate.yyloc = yyprevious->yyloc;
      }
      yychar_current = yystackp->yyrawchar;
      yylval_current = yystackp->yyval;
      yylloc_current = yystackp->yyloc;
      yystackp->yyrawchar = yyoption->yyrawchar;
      yystackp->yyval = yyoption->yyval;
      yystackp->yyloc = yyoption->yyloc;
      yystackp->yyrawchar = yychar_current;
      yystackp->yyval = yylval_current;
      yystackp->yyloc = yylloc_current;
    }

  }

}

// yyresolveStack
// file datetime_tab.c line 2051
static enum anonymous yyresolveStack(struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  if(!(yystackp->yysplitPoint == ((struct yyGLRState *)NULL)))
  {
    struct yyGLRState *yys;
    signed int yyn = 0;
    yys = yystackp->yytops.yystates[(signed long int)0];
    for( ; !(yys == yystackp->yysplitPoint); yyn = yyn + 1)
      yys = yys->yypred;
    do
    {
      enum anonymous yyflag;
      yyflag=yyresolveStates(yystackp->yytops.yystates[(signed long int)0], yyn, yystackp, parser, lexer);
      if(!((signed int)yyflag == yyok))
        return yyflag;

    }
    while((_Bool)0);
  }

  return (enum anonymous)yyok;
}

// yyresolveStates
// file datetime_tab.c line 1776
static enum anonymous yyresolveStates(struct yyGLRState *yys, signed int yyn, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  if(yyn >= 1)
  {
    if(!(yys->yypred == ((struct yyGLRState *)NULL)))
      (_Bool)1;

    else
    {
      abort();
      (_Bool)0;
    }
    do
    {
      enum anonymous yyflag;
      yyflag=yyresolveStates(yys->yypred, yyn - 1, yystackp, parser, lexer);
      if(!((signed int)yyflag == yyok))
        return yyflag;

    }
    while((_Bool)0);
    if(yys->yyresolved == 0)
      do
      {
        enum anonymous yyresolveStates__1__1__2__yyflag;
        yyresolveStates__1__1__2__yyflag=yyresolveValue(yys, yystackp, parser, lexer);
        if(!((signed int)yyresolveStates__1__1__2__yyflag == yyok))
          return yyresolveStates__1__1__2__yyflag;

      }
      while((_Bool)0);

  }

  return (enum anonymous)yyok;
}

// yyresolveValue
// file datetime_tab.c line 1963
static enum anonymous yyresolveValue(struct yyGLRState *yys, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  struct yySemanticOption *yyoptionList = yys->yysemantics.yyfirstVal;
  struct yySemanticOption *yybest;
  struct yySemanticOption **yypp;
  unsigned char yymerge;
  union YYSTYPE yysval;
  enum anonymous yyflag;
  struct YYLTYPE_0 *yylocp = &yys->yyloc;
  yybest = yyoptionList;
  yymerge = (unsigned char)0;
  yypp = &yyoptionList->yynext;
  enum anonymous return_value_yyreportAmbiguity_2;
  while(!(*yypp == ((struct yySemanticOption *)NULL)))
  {
    struct yySemanticOption *yyresolveValue__1__1__1__yyp = *yypp;
    unsigned char return_value_yyidenticalOptions_3;
    return_value_yyidenticalOptions_3=yyidenticalOptions(yybest, yyresolveValue__1__1__1__yyp);
    if(!(return_value_yyidenticalOptions_3 == 0))
    {
      yymergeOptionSets(yybest, yyresolveValue__1__1__1__yyp);
      *yypp = yyresolveValue__1__1__1__yyp->yynext;
    }

    else
    {
      signed int return_value_yypreference_1;
      return_value_yypreference_1=yypreference(yybest, yyresolveValue__1__1__1__yyp);
      switch(return_value_yypreference_1)
      {
        case 0:
        {
          yyresolveLocations(yys, 1, yystackp, parser, lexer);
          return_value_yyreportAmbiguity_2=yyreportAmbiguity(yybest, yyresolveValue__1__1__1__yyp, parser, lexer);
          return return_value_yyreportAmbiguity_2;
        }
        case 1:
        {
          yymerge = (unsigned char)1;
          break;
        }
        case 2:
          break;
        case 3:
        {
          yybest = yyresolveValue__1__1__1__yyp;
          yymerge = (unsigned char)0;
          break;
        }
        default:
          ;
      }
      yypp = &yyresolveValue__1__1__1__yyp->yynext;
    }
  }
  if(!(yymerge == 0))
  {
    struct yySemanticOption *yyp;
    signed int yyprec = (signed int)yydprec[(signed long int)yybest->yyrule];
    yyflag=yyresolveAction(yybest, yystackp, &yysval, yylocp, parser, lexer);
    if((signed int)yyflag == yyok)
    {
      yyp = yybest->yynext;
      for( ; !(yyp == ((struct yySemanticOption *)NULL)); yyp = yyp->yynext)
        if(yyprec == (signed int)yydprec[(signed long int)yyp->yyrule])
        {
          union YYSTYPE yysval_other;
          struct YYLTYPE_0 yydummy;
          yyflag=yyresolveAction(yyp, yystackp, &yysval_other, &yydummy, parser, lexer);
          if(!((signed int)yyflag == yyok))
          {
            yydestruct_link1("Cleanup: discarding incompletely merged value for", (signed int)yystos_link1[(signed long int)yys->yylrState], &yysval, parser, lexer);
            break;
          }

          yyuserMerge((signed int)yymerger[(signed long int)yyp->yyrule], &yysval, &yysval_other);
        }

    }

  }

  else
    yyflag=yyresolveAction(yybest, yystackp, &yysval, yylocp, parser, lexer);
  if((signed int)yyflag == yyok)
  {
    yys->yyresolved = (unsigned char)1;
    yys->yysemantics.yysval = yysval;
  }

  else
    yys->yysemantics.yyfirstVal = (struct yySemanticOption *)(void *)0;
  return yyflag;
}

// yyrhsLength
// file datetime_tab.c line 1068
static inline signed int yyrhsLength(signed int yyrule)
{
  return (signed int)yyr2_link1[(signed long int)yyrule];
}

// yysplitStack
// file datetime_tab.c line 1623
static unsigned long int yysplitStack(struct yyGLRStack *yystackp, unsigned long int yyk)
{
  if(yystackp->yysplitPoint == ((struct yyGLRState *)NULL))
  {
    if(yyk == 0ul)
      (_Bool)1;

    else
    {
      abort();
      (_Bool)0;
    }
    yystackp->yysplitPoint = yystackp->yytops.yystates[(signed long int)yyk];
  }

  if(yystackp->yytops.yysize >= yystackp->yytops.yycapacity)
  {
    struct yyGLRState **yynewStates;
    unsigned char *yynewLookaheadNeeds;
    yynewStates = (struct yyGLRState **)(void *)0;
    if(yystackp->yytops.yycapacity >= 1152921504606846976ul)
      yyMemoryExhausted(yystackp);

    yystackp->yytops.yycapacity = yystackp->yytops.yycapacity * (unsigned long int)2;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)yystackp->yytops.yystates, yystackp->yytops.yycapacity * sizeof(struct yyGLRState *) /*8ul*/ );
    yynewStates = (struct yyGLRState **)return_value_realloc_1;
    if(yynewStates == ((struct yyGLRState **)NULL))
      yyMemoryExhausted(yystackp);

    yystackp->yytops.yystates = yynewStates;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)yystackp->yytops.yylookaheadNeeds, yystackp->yytops.yycapacity * sizeof(unsigned char) /*1ul*/ );
    yynewLookaheadNeeds = (unsigned char *)return_value_realloc_2;
    if(yynewLookaheadNeeds == ((unsigned char *)NULL))
      yyMemoryExhausted(yystackp);

    yystackp->yytops.yylookaheadNeeds = yynewLookaheadNeeds;
  }

  yystackp->yytops.yystates[(signed long int)yystackp->yytops.yysize] = yystackp->yytops.yystates[(signed long int)yyk];
  yystackp->yytops.yylookaheadNeeds[(signed long int)yystackp->yytops.yysize] = yystackp->yytops.yylookaheadNeeds[(signed long int)yyk];
  yystackp->yytops.yysize = yystackp->yytops.yysize + (unsigned long int)1;
  return yystackp->yytops.yysize - (unsigned long int)1;
}

// yyundeleteLastStack
// file datetime_tab.c line 1374
static void yyundeleteLastStack(struct yyGLRStack *yystackp)
{
  _Bool tmp_if_expr_1;
  if(yystackp->yylastDeleted == ((struct yyGLRState *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = yystackp->yytops.yysize != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    yystackp->yytops.yystates[(signed long int)0] = yystackp->yylastDeleted;
    yystackp->yytops.yysize = (unsigned long int)1;
    yystackp->yylastDeleted = (struct yyGLRState *)(void *)0;
  }

}

// yyupdateSplit
// file datetime_tab.c line 1355
static inline void yyupdateSplit(struct yyGLRStack *yystackp, struct yyGLRState *yys)
{
  if(!(yystackp->yysplitPoint == ((struct yyGLRState *)NULL)))
  {
    if(!(yys >= yystackp->yysplitPoint))
      yystackp->yysplitPoint = yys;

  }

}

// yyuserAction
// file datetime_tab.c line 827
static enum anonymous yyuserAction(signed int yyn, signed int yyrhslen, union yyGLRStackItem *yyvsp, union YYSTYPE *yyvalp, struct YYLTYPE_0 *yylocp, struct yyGLRStack *yystackp, struct fsd_dt_parser_s *parser, struct fsd_dt_lexer_s *lexer)
{
  unsigned char yynormal = (unsigned char)(yystackp->yysplitPoint == (struct yyGLRState *)(void *)0);
  signed int yylow;
  (void)parser;
  (void)lexer;
  yylow = 1;
  signed int return_value_yyfill_1;
  if(yyrhslen == 0)
    *yyvalp = yyval_default;

  else
  {
    return_value_yyfill_1=yyfill(yyvsp, &yylow, 1 - yyrhslen, yynormal);
    *yyvalp = (yyvsp + (signed long int)return_value_yyfill_1)->yystate.yysemantics.yysval;
  }
  switch(yyn)
  {
    case 2:
    {
      signed int return_value_yyfill_2;
      return_value_yyfill_2=yyfill(yyvsp, &yylow, 1 - 1, yynormal);
      parser->result = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_2)->yystate.yysemantics.yysval.datetime;
      break;
    }
    case 3:
    {
      signed int return_value_yyfill_3;
      return_value_yyfill_3=yyfill(yyvsp, &yylow, 1 - 2, yynormal);
      signed int return_value_yyfill_4;
      return_value_yyfill_4=yyfill(yyvsp, &yylow, 2 - 2, yynormal);
      yyvalp->datetime.mask = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_3)->yystate.yysemantics.yysval.datetime.mask | ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_4)->yystate.yysemantics.yysval.datetime.mask;
      yyvalp->datetime.year = 0;
      yyvalp->datetime.month = 0;
      yyvalp->datetime.day = 0;
      signed int return_value_yyfill_5;
      return_value_yyfill_5=yyfill(yyvsp, &yylow, 1 - 2, yynormal);
      yyvalp->datetime.hour = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_5)->yystate.yysemantics.yysval.datetime.hour;
      signed int return_value_yyfill_6;
      return_value_yyfill_6=yyfill(yyvsp, &yylow, 1 - 2, yynormal);
      yyvalp->datetime.minute = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_6)->yystate.yysemantics.yysval.datetime.minute;
      signed int return_value_yyfill_7;
      return_value_yyfill_7=yyfill(yyvsp, &yylow, 1 - 2, yynormal);
      yyvalp->datetime.second = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_7)->yystate.yysemantics.yysval.datetime.second;
      signed int return_value_yyfill_8;
      return_value_yyfill_8=yyfill(yyvsp, &yylow, 2 - 2, yynormal);
      yyvalp->datetime.tz_delta = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_8)->yystate.yysemantics.yysval.datetime.tz_delta;
      break;
    }
    case 4:
    {
      signed int return_value_yyfill_9;
      return_value_yyfill_9=yyfill(yyvsp, &yylow, 1 - 4, yynormal);
      signed int return_value_yyfill_10;
      return_value_yyfill_10=yyfill(yyvsp, &yylow, 3 - 4, yynormal);
      signed int return_value_yyfill_11;
      return_value_yyfill_11=yyfill(yyvsp, &yylow, 4 - 4, yynormal);
      yyvalp->datetime.mask = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_9)->yystate.yysemantics.yysval.datetime.mask | ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_10)->yystate.yysemantics.yysval.datetime.mask | ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_11)->yystate.yysemantics.yysval.datetime.mask;
      signed int return_value_yyfill_12;
      return_value_yyfill_12=yyfill(yyvsp, &yylow, 1 - 4, yynormal);
      yyvalp->datetime.year = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_12)->yystate.yysemantics.yysval.datetime.year;
      signed int return_value_yyfill_13;
      return_value_yyfill_13=yyfill(yyvsp, &yylow, 1 - 4, yynormal);
      yyvalp->datetime.month = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_13)->yystate.yysemantics.yysval.datetime.month;
      signed int return_value_yyfill_14;
      return_value_yyfill_14=yyfill(yyvsp, &yylow, 1 - 4, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_14)->yystate.yysemantics.yysval.datetime.day;
      signed int return_value_yyfill_15;
      return_value_yyfill_15=yyfill(yyvsp, &yylow, 3 - 4, yynormal);
      yyvalp->datetime.hour = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_15)->yystate.yysemantics.yysval.datetime.hour;
      signed int return_value_yyfill_16;
      return_value_yyfill_16=yyfill(yyvsp, &yylow, 3 - 4, yynormal);
      yyvalp->datetime.minute = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_16)->yystate.yysemantics.yysval.datetime.minute;
      signed int return_value_yyfill_17;
      return_value_yyfill_17=yyfill(yyvsp, &yylow, 3 - 4, yynormal);
      yyvalp->datetime.second = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_17)->yystate.yysemantics.yysval.datetime.second;
      signed int return_value_yyfill_18;
      return_value_yyfill_18=yyfill(yyvsp, &yylow, 4 - 4, yynormal);
      yyvalp->datetime.tz_delta = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_18)->yystate.yysemantics.yysval.datetime.tz_delta;
      break;
    }
    case 7:
    {
      signed int return_value_yyfill_19;
      return_value_yyfill_19=yyfill(yyvsp, &yylow, 1 - 5, yynormal);
      yyvalp->datetime.year = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_19)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_20;
      return_value_yyfill_20=yyfill(yyvsp, &yylow, 3 - 5, yynormal);
      yyvalp->datetime.month = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_20)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_21;
      return_value_yyfill_21=yyfill(yyvsp, &yylow, 5 - 5, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_21)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)(1 | 2 | 4);
      break;
    }
    case 8:
    {
      yyvalp->datetime.year = 0;
      signed int return_value_yyfill_22;
      return_value_yyfill_22=yyfill(yyvsp, &yylow, 1 - 3, yynormal);
      yyvalp->datetime.month = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_22)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_23;
      return_value_yyfill_23=yyfill(yyvsp, &yylow, 3 - 3, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_23)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)(2 | 4);
      break;
    }
    case 9:
    {
      signed int return_value_yyfill_24;
      return_value_yyfill_24=yyfill(yyvsp, &yylow, 1 - 5, yynormal);
      yyvalp->datetime.year = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_24)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_25;
      return_value_yyfill_25=yyfill(yyvsp, &yylow, 3 - 5, yynormal);
      yyvalp->datetime.month = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_25)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_26;
      return_value_yyfill_26=yyfill(yyvsp, &yylow, 5 - 5, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_26)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)(1 | 2 | 4);
      break;
    }
    case 10:
    {
      yyvalp->datetime.year = 0;
      signed int return_value_yyfill_27;
      return_value_yyfill_27=yyfill(yyvsp, &yylow, 1 - 3, yynormal);
      yyvalp->datetime.month = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_27)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_28;
      return_value_yyfill_28=yyfill(yyvsp, &yylow, 3 - 3, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_28)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)(2 | 4);
      break;
    }
    case 11:
    {
      yyvalp->datetime.year = 0;
      yyvalp->datetime.month = 0;
      signed int return_value_yyfill_29;
      return_value_yyfill_29=yyfill(yyvsp, &yylow, 1 - 1, yynormal);
      yyvalp->datetime.day = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_29)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)4;
      break;
    }
    case 12:
    {
      signed int return_value_yyfill_30;
      return_value_yyfill_30=yyfill(yyvsp, &yylow, 1 - 3, yynormal);
      yyvalp->datetime.hour = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_30)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_31;
      return_value_yyfill_31=yyfill(yyvsp, &yylow, 3 - 3, yynormal);
      yyvalp->datetime.minute = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_31)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.second = 0;
      yyvalp->datetime.mask = (unsigned int)(8 | 16);
      break;
    }
    case 13:
    {
      signed int return_value_yyfill_32;
      return_value_yyfill_32=yyfill(yyvsp, &yylow, 1 - 5, yynormal);
      yyvalp->datetime.hour = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_32)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_33;
      return_value_yyfill_33=yyfill(yyvsp, &yylow, 3 - 5, yynormal);
      yyvalp->datetime.minute = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_33)->yystate.yysemantics.yysval.integer;
      signed int return_value_yyfill_34;
      return_value_yyfill_34=yyfill(yyvsp, &yylow, 5 - 5, yynormal);
      yyvalp->datetime.second = ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_34)->yystate.yysemantics.yysval.integer;
      yyvalp->datetime.mask = (unsigned int)(8 | 16 | 32);
      break;
    }
    case 14:
    {
      yyvalp->datetime.tz_delta = (signed long int)0;
      yyvalp->datetime.mask = (unsigned int)0;
      break;
    }
    case 15:
    {
      signed int return_value_yyfill_35;
      return_value_yyfill_35=yyfill(yyvsp, &yylow, 1 - 2, yynormal);
      signed int return_value_yyfill_36;
      return_value_yyfill_36=yyfill(yyvsp, &yylow, 2 - 2, yynormal);
      yyvalp->datetime.tz_delta = (signed long int)(((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_35)->yystate.yysemantics.yysval.integer * 3600 * ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_36)->yystate.yysemantics.yysval.integer);
      yyvalp->datetime.mask = (unsigned int)64;
      break;
    }
    case 16:
    {
      signed int return_value_yyfill_37;
      return_value_yyfill_37=yyfill(yyvsp, &yylow, 1 - 4, yynormal);
      signed int return_value_yyfill_38;
      return_value_yyfill_38=yyfill(yyvsp, &yylow, 2 - 4, yynormal);
      signed int return_value_yyfill_39;
      return_value_yyfill_39=yyfill(yyvsp, &yylow, 4 - 4, yynormal);
      yyvalp->datetime.tz_delta = (signed long int)(((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_37)->yystate.yysemantics.yysval.integer * 60 * (60 * ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_38)->yystate.yysemantics.yysval.integer + ((const union yyGLRStackItem *)yyvsp + (signed long int)return_value_yyfill_39)->yystate.yysemantics.yysval.integer));
      yyvalp->datetime.mask = (unsigned int)64;
      break;
    }
    case 17:
    {
      yyvalp->datetime.tz_delta = (signed long int)0;
      yyvalp->datetime.mask = (unsigned int)64;
      break;
    }
    case 18:
    {
      yyvalp->integer = +1;
      break;
    }
    case 19:
    {
      yyvalp->integer = +1;
      break;
    }
    case 20:
      yyvalp->integer = -1;
  }
  return (enum anonymous)yyok;
}

// yyuserMerge
// file datetime_tab.c line 1028
static void yyuserMerge(signed int yyn, union YYSTYPE *yy0, union YYSTYPE *yy1)
{
  (void)yy0;
  (void)yy1;
}

